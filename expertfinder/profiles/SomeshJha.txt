security related security semantics-based approach malware detection mila dalla preda mihai christodorescu saumya debray somesh jha symposium principles programming languages popl nice france january backtracking algorithmic complexity attacks nids randy smith cristian estan somesh jha twenty-second annual computer security applications conference acsac miami beach december netspy automatic generation spyware signatures nids hao wang somesh jha vinod ganapathy twenty-second annual computer security applications conference acsac miami beach december protomatching network traffic high throughput network intrusion detection rubin jha miller acm conference computer communications security alexandria virginia november secure function evaluation ordered binary decision diagrams eu-jin goh louis kruger dan boneh somesh jha acm conference computer communications security alexandria virginia november automated discovery mimicry attacks giffin jha miller international symposium recent advances intrusion detection raid hamburg germany september reducing dependence spki sdsi pki hao wang somesh jha thomas reps stefan schwoon stuart stubblebine european symposium research computer security esorics hamburg germany september completeness attack mutation algorithms shai rubin somesh jha bart miller ieee computer security foundations workshop csfw july download paper click distributed model-checking algorithms wpds applications trust-management systems somesh jha stefan schwoon hao wang somesh jha tools algorithms construction analysis systems march note invited paper download paper click automated authorization policy enforcement vinod ganapathy trent jaeger somesh jha annual security enhanced linux symposium march download paper click automatic generation vulnerability-based signatures david brumley james newsome dawn song hao wang somesh jha ieee symposium security privacy oakland california download paper click retrofitting legacy code authorization policy enforcement vinod ganapathy trent jaeger somesh jha ieee symposium security privacy oakland california download paper click vinod ganapathy sanjit seshia somesh jha thomas reps randal bryant automatic discovery api-level exploits international conference software engineering icse louis missouri download paper click shai rubin somesh jha bart miller language-based generation evaluation nids signatures ieee symposium security privacy oakland california download paper click mihai christodorescu sanjit seshia somesh jha dawn song randal bryant semantics-aware malware detection ieee symposium security privacy oakland california download paper click vinod yegneswaran jonathon giffin paul barford somesh jha architecture generating semantics-aware signatures usenix security symposium baltimore maryland august download paper click jonathon giffin david dagon somesh jha wenke lee barton miller environment-sensitive intrusion detection international symposium recent advances intrusion detection raid seattle washington september download paper click jha kruger mcdaniel privacy preserving clustering european symposium research computer security esorics milan italy september download paper click vinod ganapathy trent jaeger somesh jha automatic placement authorization hooks linux security modules framework acm conference computer communications security alexandria virginia november download paper click muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau somesh jha logic file systems usenix conference file storage technologies fast dec download paper click jon giffin somesh jha bart miller efficient context-sensitive intrusion detection annual network distributed system security symposium ndss february download paper click vinod yegneswaran paul barford somesh jha global intrusion detection domino overlay system annual network distributed system security symposium ndss february download paper click henry hanping feng jonathon giffin yong huang somesh jha wenke lee barton miller formalizing sensitivity static analysis intrusion detection ieee symposium security privacy oakland california download paper click wang jha mcdaniel livny security policy reconciliation distributed computing environments ieee international workshop policies distributed systems networks policy june download paper click christodorescu jha testing malware detectors international symposium software testing analysis issta july download paper click nbsp nbsp acm sigsoft distinguished paper rubin jha miller automatic generation analysis nids attacks annual computer security applications conference acsac december download paper click nbsp nbsp paper won student paper paper award giffin jha miller detecting manipulated remote call streams usenix security symposium august download paper click edmund clarke somesh jha marrero efficient verification security protocols partial-order reductions international journal software tools technology transfer sttt volume number february schwoon jha reps stubblebine generalized authorization problems ieee computer security foundations workshop june july asilomar pacific grove download paper click christodorescu jha static analysis executables detect malicious patterns usenix sexurity symposium august download paper click vinod ganapathy somesh jha david chandler david melski david vitek buffer overrun detection linear programming static analysis acm conference computer communications security ccs october download paper click sheyner haines jha lippman wing automated generation analysis attack graphs ieee symposium security privacy april download paper click jha sheyner wing formal analyses attack graphs computer security foundations workshop csfw june download paper click jha reps analysis spki sdsi certificates model checking computer security foundations workshop csfw june download paper click earlier clarke jha marrero state space exploration natural deduction style message derivation engine verify security protocols ifip working conference programming concepts methods procomet june clarke jha marrero partial order reductions security protocol verification tools algorithms construction analysis systems tacas april clarke jha marrero verifying security protocols brutus acm transactions software engineering methodology tosem volume number jha linger longstaff wing survivability analysis network specifications workshop depenedability malicious faults international conference dependable systems networks dsn june jha wing survivability analysis networked systems international conference software engineering icse download paper click jha tan maxion markov chains classifiers intrusion detection computer security foundations workshop csfw june download paper click 
software engineering software engineering jackson jha damon faster checking software specifications eliminating isomorphs principles programming languages popl january damon jackson jha checking relational specifications bdds fourth acm sigsoft symposium foundations software engineering fse october jackson jha damon isomorph-free model enumeration method checking relational specifications acm transactions programming languages systems toplas volume dingel garlan jha notkin formal treatment implicit invocation rely guarantee reasoning formal aspects computing volume dingel garlan jha notkin reasoning implicit invocation sixth acm sigsoft symposium foundations software engineering fse november sullivan chalasani jha sazawal software design investment activity real options perspective real options business strategy applications decision making trigeorgis consulting editor risk books campialla chaki clarke jha veith efficient filtering publish subscribe systems binary decision diagrams international conference software engineering icse download paper click jha palsberg zhao efficient type matching foundations software science computation structures fossacs april download paper click sagar chaki edmund clarke alex groce somesh jha helmut veith modular verification software components international conference software engineering icse download paper click nbsp nbsp acm sigsoft distinguished paper edmund clarke orna grumberg somesh jha yuan helmut veith counterexample-guided abstraction refinement symbolic model checking journal acm jacm volume isssue sept sagar chaki pascal fenkam harald gall somesh jha engin kirda helmut veith integrating publish subscribe mobile teamwork support platform international conference software engineering knowledge engineering seke july paper 
model checking model checking clarke grumberg hirashi jha long mcmillan ness verification futurebus cache coherence protocol formal methods system design volume preliminary version appeared chdl clarke enders filkorn jha exploiting symmetry temporal logic model checking formal methods system design volume preliminary version appeared cav browne clarke jha long marrero improved algorithm evaluation fix-point expressions theoretical computer science volume preliminary version appeared cav clarke jha symmetry induction model checking computer science today recent trends developments special lncs -th volume september editor van leeuwen clarke grumberg jha verifying parameterized networks acm transactions programming languages systems toplas volume preliminary version appeared concur emerson jha peled combining partial order symmetry reductions proceedings tools algorithms construction analysis systems tacas april jha minea clarke equivalence checking abstract bdds proceedings international conference computer design iccd october clarke emerson jha sistla symmetry reductions model checking computer aided verification cav clarke jha wang abstract bdds general methodology abstraction model checking -th ifip advanced research working conference correct hardware design verification methods charme september berezin clarke jha marrero model checking algorithms mu-calculus proof language interaction edited plotkin mit press clarke grumberg jha veith counterexample-guided abstract refinement computer aided verification cav july clarke grumberg jha veith progress state explosion problem model checking dagstuhl -th anniversary informatics years back years ahead lncs volume springer verlag editor riehnhard wilhelm chauhan clarke jha kukula veith wang combinatorial optimization methods quantification scheduling correct hardware design verification methods charme sept chauhan clarke jha kukula veith wang non-linear quantification scheduling image computation iccad clarke jha veith tree-like counterexamples model checking logic computer science lics july reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis international static analysis symposium sas june san diego download paper click 
computational finance computational finance chalasani jha varikooty accurate approximations european asian options journal computational finance jcf volume number chalasani jha egriboyun varikooty refined binomial lattice pricing american asian options review derivatives research redr volume issue appeared annual derivative securities conference chalasani jha saias approximate option pricing algorithmica volume appeared proceedings foundations computer science focs chalasani jha randomized stopping times american option pricing transaction costs mathematical finance volume issue -th annual derivative securities conference chalasani jha lecture notes stochastic calculus finance based steven shreve carnegie mellon pages link 
somesh jha computer sciences department wisconsin dayton street madison jha wisc office home education carnegie mellon pittsburgh computer science august thesis symmetry induction model checking advisor prof clarke pennsylvania state park computer science aug indian institute technology delhi india tech electrical engineering employment carnegie mellon pittsburgh postdoctoral fellow school computer science note affiliated cert software engineering institute wisconsin madison assistant professor -present wisconsin madison associate professor awards achievements distinguished acm sigsoft paper award international conference software engineering icse distinguished acm sigsoft paper award international symposium software testing analysis issta student paper award annual computer security applications conference acsac nsf career award paper award annual computer security applications conference acsac information security clarke jha marrero state space exploration natural deduction style message derivation engine verify security protocols ifip working conference programming concepts methods procomet june clarke jha marrero partial order reductions security protocol verification tools algorithms construction analysis systems tacas april clarke jha marrero verifying security protocols brutus acm transactions software engineering methodology tosem volume number jha linger longstaff wing survivability analysis network specifications proceedings international conference dependable systems networks dsn workshop dependability malicious faults york city june jha wing survivability analysis networked systems international conference software engineering icse jha tan maxion markov chains classifiers intrusion detection computer security foundations workshop csfw june shyener haines jha lippmann wing automated generation analysis attack graphs ieee symposium security privacy april jha sheyner wing formal analyses attack graphs computer security foundations workshop csfw june jha reps analysis spki sdsi certificates model checking computer security foundations workshop csfw june giffin jha miller detecting manipulated remote call streams usenix security symposium august clarke jha marrero efficient verification security protocols partial-order reductions international journal software tools technology transfer sttt volume number february schwoon jha reps stubblebine generalized authorization problems computer security foundations workshop csfw july christodorescu jha static analysis executables detect malicious patterns usenix security symposium august ganapathy jha chandler melski vitek buffer overrun detection linear programming static analysis acm conference computer communications security ccs october giffin jha miller efficient context-sensitive intrusion detection network distributed system security symposium ndss february yegneswaran barford jha global intrusion detection domino overlay system network distributed system security symposium ndss february feng giffin huang jha lee miller formalizing sensitivity static analysis intrusion detection ieee symposium security privacy april wang jha mcdaniel livny security policy reconciliation distributed computing environments ieee international workshop policies distributed systems networks policy june christodorescu jha testing malware detectors international symposium software testing analysis issta july note paper won outstanding paper award conference paul barford somesh jha vinod yegneswaran fusion filtering distributed intrusion detection systems annual allerton conference communication control computing september rubin jha miller automatic generation analysis nids attacks annual computer security applications conference acsac december note paper won student outstanding paper award conference somesh jha thomas reps model checking spki sdsi journal computer security rubin jha miller attack mutation test high-end nids information security bulletin volume april vinod ganapathy sanjit seshia somesh jha thomas reps randal bryant automatic discovery api-level exploits international conference software engineering icse louis missouri rubin jha miller language-based generation evaluation nids ieee symposium security privacy christodorescu jha seshia song bryant semantics-aware malware detection ieee symposium security privacy vinod yegneswaran jonathon giffin paul barford somesh jha architecture generating semanticsaware signatures usenix security symposium baltimore maryland august jonathon giffin david dagon somesh jha wenke lee barton miller environment-sensitive intrusion detection international symposium recent advances intrusion detection raid seattle washington september jha kruger mcdaniel privacy preserving clustering european symposium research computer security esorics milan italy september vinod ganapathy trent jaeger somesh jha automatic placement authorization hooks linux security modules framework acm conference computer communications security ccs alexandria virginia november muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau somesh jha logic file systems usenix conference file storage technologies fast dec vinod ganapathy trent jaeger somesh jha retrofitting legacy code authorization policy enforcement ieee symposium security privacy david brumley james newsome dawn song hao wang somesh jha automatic generation vulnerability-based signatures ieee symposium security privacy rubin jha miller completeness attack mutation algorithms ieee computer security foundations workshop csfw july wang jha reps schwoon stubblebine reducing dependence spki sdsi pki european symposium research computer security esorics sept giffin jha miller automated discovery mimicry attacks international conference recent advances intrusion detection raid sept goh kruger boneh jha secure function evaluation binary decision diagrams acm conference computer communications security ccs nov rubin jha miller protocomatching network traffic high throughput network intrusion detection acm conference computer communications security ccs nov wang jha ganapathy netspy automatic generation spyware signatures nids annual computer security applications conference acsac dec smith estan jha backtracking algorithmic complexity attacks nids annual computer security applications conference acsac dec software engineering jackson jha damon faster checking software specifications eliminating isomorphs principles programming languages popl january damon jackson jha checking relational specifications bdds fourth acm sigsoft symposium foundations software engineering fse october jackson jha damon isomorph-free model enumeration method checking relational specifications acm transactions programming languages systems toplas volume dingel garlan jha notkin formal treatment implicit invocation rely guarantee reasoning formal aspects computing volume dingel garlan jha notkin reasoning implicit invocation sixth acm sigsoft symposium foundations software engineering fse november sullivan chalasani jha sazawal software design investment activity real options perspective real options business strategy applications decision making trigeorgis consulting editor risk books campialla chaki clarke jha veith efficient filtering publish subscribe systems binary decision diagrams international conference software engineering icse jha palsberg zhao efficient type matching foundations software science computation structures fossacs april chaki clarke groce jha veith modular verification software components international conference software engineering icse note paper won outstanding paper award conference chaki fenkam gall jha kirda veith integrating publish subscribe mobile teamwork support platform international conference software engineering knowledge engineering seke july sagar chaki edmund clarke somesh jha helmut veith iterative framework simulation conformance journal logic computation jlc oxford press volume number page august model checking clarke grumberg hirashi jha long mcmillan ness verification futurebus cache coherence protocol formal methods system design volume preliminary version appeared chdl clarke enders filkorn jha exploiting symmetry temporal logic model checking formal methods 
system design volume preliminary version appeared cav browne clarke jha long marrero improved algorithm evaluation fixpoint expressions theoretical computer science volume preliminary version appeared cav clarke jha symmetry induction model checking computer science today recent trends developments special lncs -th volume september editor van leeuwen clarke grumberg jha verifying parameterized networks acm transactions programming languages systems toplas volume preliminary version appeared concur emerson jha peled combining partial order symmetry reductions proceedings tools algorithms construction analysis systems tacas april jha minea clarke equivalence checking abstract bdds proceedings international conference computer design iccd october clarke emerson jha sistla symmetry reductions model checking computer aided verification cav clarke jha wang abstract bdds general methodology abstraction model checking -th ifip advanced research working conference correct hardware design verification methods charme september berezin clarke jha marrero model checking algorithms -calculus proof language interaction edited plotkin mit press edmund clarke orna grumberg somesh jha yuan helmut veith counterexample-guided abstraction refinement computer aided verification cav july clarke grumberg jha veith progress state explosion problem model checking dagstuhl anniversary informatics years back years ahead lncs volume springer verlag editor rienhard wilhelm chauhan clarke jha kukula veith wang combinatorial optimization methods quantification scheduling correct hardware design verification methods charme sept chauhan clarke jha kukula veith wang non-linear quantification scheduling image computation iccad clarke jha veith tree-like counterexamples model checking logic computer science lics july reps schwoon jha weighted pushdown systems applications interprocedural dataflow analysis international static analysis symposium sas june clarke grumberg jha veith counterexample-guided abstraction refinement symbolic model checking journal acm jacm volume issue september reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis science computer programming oct computational finance chalasani jha varikooty accurate approximations european asian options journal computational finance jcf volume number chalasani jha egriboyun varikooty refined binomial lattice pricing american asian options review derivatives research redr volume issue appeared annual derivative securities conference chalasani jha saias approximate option pricing algorithmica volume appeared proceedings foundations computer science focs chalasani jha randomized stopping times american option pricing transaction costs mathematical finance volume january appeared annual derivative securities conference multi-agents systems shehory sycara jha multi-agent coordination coalition formation lecture notes artificial intelligence intelligent agents edited rao singh wooldridge pages springer chalasani jha shehory sycara strategies querying information agents lecture notes artificial intelligence edited klusch weiss pages chalasani jha shehory sycara query restart strategies web agents proceedings autonomous agents pages minneapolis shehory sycara chalasani jha agent cloning approach agent mobility resource allocation ieee communications pages vol miscellaneous pothen jha vemulapati orthogonal factorization distributed memory multiprocessor hypercube multiprocessors september edited heath pardalos jha graph separation techniques quadratic zero-one programming computers math applications volume pardalos jha complexity uniqueness local search quadratic programming operations research letters volume grants principal investigator vulnerability information flow analysis cots onr research initiative co-principal investigator static analysis enhance power model checking concurrent software onr research initiative co-principal investigator coordinated anomaly detection characterization wide area network flows aro principal investigator career combating malicious behavior commodity software nsf co-principal investigator advanced methods checking information-security properties nsf co-principal investigator infrastructure support cyberforensics aro principal investigator collaborative research ct-t behavior-based malware detection nsf students advising current mihai christodorescu expected graduate vinod ganapathy expected graduate louis kruger randy smith co-advised prof estan students graduated jon giffin graduated aug employment assistant professor georgia tech shai rubin graduated aug employment microsoft haifa israel hao wang graduated dec employment securitas technologies madison thesis committee ian alderman student uw-madison joseph bockhorst graduated uw-madison dennis brylow graduated purdue alexey loginov student uw-madison oleg sheyner graduated carnegie mellon vinod yegneswaran student uw-madison teaching experience -present developed courses uw-madison analysis software artifacts introduction information security instructor developer graduate classes cmu teaching masters software engineering masters computational finance programs teaching assistant undergraduate courses cmu courses advanced algorithms courses seniors graduate instructor penn state taught introductory programming engineers selected talks aug verifying parametrized networks abstraction regular languages presented -th international conference concurrency theory concur oct checking relational specifications binary decision diagrams presented fourth symposium foundations software engineering fse potential portfolio theory guiding software decisions presented workshop economics-driven software engineering research edseraffiliated international conference software engineering icse survivability analysis networked systems presented -rd international conference software engineering icse june markov chains classifiers intrusion detection presented -th computer security foundations workshop csfw july wisa project overview presented onr osd cip uri kick meeting arlington virginia june static analysis techniques identifying malicious executables presented software security workshop arranged washington microsoft cmu oct efficient context-sensitive intrusion detection presented computer science department arizona july malware detection presented idaho national labs feb behavior-based malware detection frontiers computer science lecture series computer science engineering department california san diego march distributed model-checking algorithms wpds applications trust-management systems invited talk tacas vienna austria nov behavior-based malware detection computer science department florida international fiu miami dec behavior-based malware detection computer science department illinois urbana-champaign illinois program committees computer aided verification cav paris france foundations computer security fcs copenhagen denmark workshop part federated logic conference floc international conference software engineering icse international spin workshop model checking software security privacy track international symposium software testing analysis issta acm-ieee international conference formal methods models co-design memocode annual network distributed system security symposium ndss security privacy track international conference computer aided verification cav usenix security symposium acm conference computer communication security ccs eighth international symposium recent advances intrusion detection raid software engineering secure systems sess workshop rapid malcode worm usenix security symposium international symposium recent advances intrusion detection raid acm conference computer communication security ccs tools algorithms construction analysis systems tacas editorial duties editorial board journal computer security -present service curriculum committee chair remzi arpaci-dusseau spring fall admissions committee chairs raghu ramakrishnan chuck dyer spring arranged distinguished lecture series fall spring admissions committee chairs raghu ramakrishnan steven wright spring curriculum committee chair marvin solomon fall spring admissions committee chairs chuck dyer somesh jha fall present referee conferences journals journals referee acm transactions software engineering methodology tosem ieee transactions software engineering tse formal methods systems design form acm transactions programming languages systems toplas conferences international conference software engineering icse foundations software engineering fse computer 
aided verification cav international conference concurrency theory concur ieee annual symposium logic computer science lics principles programming languages popl tools algorithms construction analysis systems tacas industrial employment worked years computer consultant returning years worked projects projects exposed types systems compilers operating systems transaction management systems consultant ibm danbury ags consulting clarke aug jan involved development fortran compilers pscomputer responsible writing code fixing bugs optimizing compiler consultant ups louisville ags consulting clarke feb july worked software load balancing planes routing packages development stratus machine code written code highly intricate required interfacing hardware components device drivers senior programmer ags consulting clarke aug july worked software checking program confirms posix ansi standards project consultant ibm kingston pencom york sept july worked porting osf kernel ibm-esa architecture specifically responsible porting maintaining threads library job required intimately familiar threads code ibm-esa architecture personal born india naturalized citizen 
past conferences ccs raid usenix security symposium worm sess raid ccs usenix security symposium security privacy track cav ndss memocode security privacy track issta spin icse fcs sreis cav 
introduction information security spring home page home detailed document notes assignments links project messages instructor somesh jha computer sciences building jha wisc office hours somesh jha fri jake rosin room computer sciences building rosin wisc office hours jake rosin wed time place computer sciences building audience introduction information security covers broad range topics general description shared resources internet created global open information infrastructure global infrastructure advantages ease sharing information shared resources increase risk due malicious behavior information security area deals protection detection malicious activity follow general structure cryptographic primitives part focus cryptographic primitives cover topics symmetric-key public-key encryption hash functions digital signatures protocols part focus protocols primitives introduced earlier protocols key establishment protocols kerberos diffie-hellman secret sharing web security secure sockets layer ssl secure payment protocols cybercash digital money digicash system security part focus system security discuss common system vulnerabilities attacks tcp syn flooding denial-of-service attacks discuss general architecture firewalls intrusion detection systems special topics part focus topics security year discuss smartcards applications material notes papers distributed instructor required text stallings cryptography network security principles practice prentice hall fourth edition books required alfred menezes paul van oorschot scott vanstone handbook applied cryptography crc press download chapters book free link chen java card technology smart cards architecture programmer guide addison-wesley publishing company cheswick bellovin firewalls internet security repelling wily hacker addison-wesley publishing company northcutt network intrusion detection analyst handbook riders publishing sherif protocols secure electronic commerce crc press menzes van oorschot vanstone handbook applied crytograph crc press zwicky cooper chapman russell building internet firewalls reilly associates prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments exams presentations projects document details 
courses taught past fall analysis software artifacts spring introduction information security fall analysis software artifacts spring introduction information security spring introduction information security spring introduction information security spring introduction information security 
completeness attack mutation algorithms attack mutation algorithm takes instance attack transforms distinct instances repeatedly applying attack transformations algorithms widely testing intrusion detection systems investigate notion completeness mutation algorithm capability generate attack instances set attack transformations define notion phi-complete mutation algorithm set transformations algorithm complete respect generate instance transformations derive show rules uniform reversible phi-complete algorithm exists intuitively speaking uniform reversible transformations exclusively apply transformations simplify attack exclusively apply transformations complicate instances derived rules uniformity reversibility severe restrictions show common attack transformations uniform reversible phi-complete algorithm incorporated existing testing tools intrusion detection systems show phi-complete algorithm testing purposes determining packet traces mutations attack download pdf somesh jha modified fri sep cdt 
automatic generation vulnerability-based signatures paper explore problem creating vulnerability signatures vulnerability signature matches exploits vulnerability polymorphic metamorphic variants work departs previous approaches focusing semantics program vulnerability exercised sample exploit semantics syntax exploit show semantics vulnerability define language inputs exploit vulnerability vulnerability signature representation regular expression vulnerability language unlike exploitbased signatures error rate empirically measured test cases quality vulnerability signature formally quantified inputs provide formal definition vulnerability signature investigate computational complexity creating matching vulnerability signatures systematically explore design space vulnerability signatures identify central issues vulnerability-signature creation vulnerability signature represents set inputs exercise vulnerability vulnerability coverage number vulnerable program paths subject analysis signature creation vulnerability signature created representation coverage propose data-flow analysis adoption existing techniques constraint solving automatically generating vulnerability signatures built prototype system test techniques experiments show automatically generate vulnerability signature single exploit higher quality previous exploit-based signatures addition techniques security applications independent interest download pdf somesh jha modified tue sep cdt 
distributed certificate-chain discovery spki sdsi authorization problem decide security policy principal allowed access resource trust-management system spki sdsi security policy set certificates proofs authorization form certificate chains problem discover proof authorization request algorithms spki sdsi investigated researchers variant certificate-chain discovery problem certificates distributed number servers cooperate identify proof authorization request propose protocols purpose protocols based distributed model-checking algorithms weighted pushdown systems wpdss protocols handle cases certificates labeled weights multiple certificate chains combined form proof authorization implemented protocols prototype report preliminary results evaluation download pdf somesh jha modified fri sep cdt 
automated authorization policy enforcement systems shared resources authorization policy enforcement ensures resources accessible users allowed recently growing interest extend authorization policy enforcement mechanisms provided operating system enable user-space servers enforce authorization policies clients popular mechanism authorization policy enforcement retrofits code secured hooks monitor basis linux security modules lsm framework intended usage recently-released security-enhanced linux policy management framework user-space servers monitor hooks manually operating system user-space server code approach tedious scale prior work shown context lsm error-prone research techniques largely automate authorization hook placement devised technique tested effectiveness applying determine hook placement linux kernel cross-validating lsm hook placement initial results encouraging extended technique work user-space servers applied technique determine authorization hook placement server download pdf somesh jha modified fri sep cdt 
retrofitting legacy code authorization policy enforcement researchers argued construct secure system proactively integrate security design system tenet rarely economic practical considerations security mechanisms added arises retrofitting legacy code existing techniques manual hoc result security holes present program analysis techniques assist process retrofitting legacy code authorization policy enforcement techniques retrofit legacy servers window web proxy cache servers servers manage multiple clients simultaneously offer shared resources clients ability enforce authorization policies developer techniques identify security-sensitive locations legacy servers place monitor calls mediate locations demonstrate techniques retrofitting server enforce authorization policies clients download pdf somesh jha modified tue sep cdt 
automatic discovery api-level exploits argue finding vulnerabilities software components finding exploits exploits compromise security low-level details component layouts stack frames existing software analysis tools effective identifying vulnerabilities fail model low-level details unsuitable exploit-finding study issues involved exploit-finding application programming interface api level exploits software component vulnerable api-level exploit security compromised invoking sequence api operations allowed component develop formal framework model low-level details api operations develop automatic technique based bounded infinite-state model checking discover api-level exploits present instantiations framework show format-string exploits modeled api-level exploits demonstrate technique finding exploits vulnerabilities widely-used software framework model cryptographic-key management api ibm cca demonstrate tool identifies previously exploit download pdf somesh jha modified thu feb cst 
language-based generation evaluation nids signatures present methodology automatically construct robust signatures accuracy based formal reasoning systematically evaluated methodology based formal languages describe properties attack language called session signature describes temporal relations attack events called attack invariant describes semantic properties hold instance attack invariant state ftp attack include successful ftp login launched ftp representation mode set ascii iteratively eliminate false positives negatives initial session signature comparing signature language language invariant developed gard tool session-signature construction construct session signatures multi-step attacks show session signature accurate existing signatures download pdf somesh jha modified mon apr cdt 
semantics-aware malware detection malware detector system attempts determine program malicious intent order evade detection malware writers hackers frequently obfuscation morph malware malware detectors pattern-matching approach commercial virus scanners susceptible obfuscations hackers fundamental deficiency pattern-matching approach malware detection purely syntactic ignores semantics instructions paper present malware-detection algorithm addresses deficiency incorporating instruction semantics detect malicious program traits experimental evaluation demonstrates malware-detection algorithm detect variants malware low run-time overhead semantics-aware malware detection algorithm resilient common obfuscations hackers download pdf somesh jha modified thu mar cst 
architecture generating semantics-aware signatures identifying intrusions developing effective signatures detect essential protecting computer networks present nemean system automatic generation intrusion signatures honeynet packet traces architecture distinguished emphasis modular design framework encourages independent development modification system components protocol semantics awareness construction signatures greatly reduce false alarms building blocks architecture include transport service normalization intrusion profile clustering automata learning generates connection session aware signatures demonstrate potential nemean semantics-aware resilient signatures prototype implementation datasets evaluate system production dataset false-alarm evaluation honeynet dataset measuring detection rates signatures generated nemean netbios exploits false-positive rate false-negative rate download pdf somesh jha modified thu mar cst 
environment-sensitive intrusion detection perform host-based intrusion detection constructing model program binary code restricting program execution model improve effectiveness model-based intrusion detection systems incorporating model knowledge environment program runs increasing accuracy models data-flow analysis algorithm context-sensitive recovery static data environment configuration files command-line parameters environment variable constrains acceptable process execution environment dependencies added program model update model current environment program execution static data-flow analysis associates program data flows specific calling contexts data analysis differentiate system-call arguments flowing distinct call sites program average reachability measure suitable evaluation call-stack-based program models demonstrate techniques improve precision test programs models download pdf somesh jha modified thu mar cst 
privacy preserving clustering freedom transparency information flow internet heightened concerns privacy set data items clustering algorithms group similar items clustering applications customer-behavior analysis targeted marketing forensics bioinformatics paper present design analysis privacy-preserving -means clustering algorithm cluster means steps algorithm revealed participating parties crucial step privacy-preserving -means privacy-preserving computation cluster means present protocols based oblivious polynomial evaluation based homomorphic encryption privacy-preserving computation cluster means java implementation algorithm implementation performed evaluation privacy-preserving clustering algorithm data sets evaluation demonstrates privacy-preserving clustering feasible homomorphic-encryption based algorithm finished clustering large data set approximately seconds download pdf somesh jha modified thu mar cst 
automatic placement authorization hooks linux security modules framework present technique automatic placement authorization hooks apply linux security modules lsm framework lsm generic framework diverse authorization policies enforced linux kernel consists kernel module encapsulates authorization policy hooks kernel module locations linux kernel kernel enforces authorization policy hook calls current practice hooks manually kernel approach tedious prior work shown prone security holes technique static analysis linux kernel kernel module automate hook placement non-hook-placed version linux kernel kernel module implements authorization policy technique infers set operations authorized hook set operations performed function kernel information infer set hooks guard kernel function describe design implementation prototype tool called tahoe tool authorization hook placement technique demonstrate effectiveness tahoe lsm implementation security-enhanced linux selinux exposition paper focuses hook placement lsm technique place hooks lsm-like architectures download pdf somesh jha modified thu mar cst 
logic file systems years innovation file systems highly successful improving performance functionality cost complicating interaction disk variety techniques exist ensure consistency integrity file system data precise set correctness guarantees provided technique unclear making hard compare reason absence formal framework hampered detailed verification file system correctness present logical framework modeling interaction file system storage system show apply logic represent prove correctness properties demonstrate logic main benefits enables reasoning existing file system mechanisms enabling developers employ aggressive performance optimizations fear compromising correctness logic simplifies introduction adoption file system functionality facilitating rigorous proof correctness finally logic helps reason smart storage systems track semantic information file system key aspect logic enables incremental modeling significantly reducing barrier entry terms actual file system designers general framework transforms hitherto esoteric error-prone art file system design readily understandable formally verifiable process download pdf somesh jha modified tue sep cdt 
efficient context-sensitive intrusion detection model-based intrusion detection compares process execution program model detect intrusion attempts models constructed static program analysis historically traded precision efficiency address problem dyck model efficient statically-constructed context-sensitive model model specifies correct sequences system calls program generate stack occurring function call sites experiments demonstrate dyck model order magnitude precise context-insensitive finite state machine model null call squelching dynamic technique bound cost dyck model operates time similar context-insensitive model present static analysis techniques designed counter mimicry evasion attacks branch analysis identifies test programs system call sites affecting control flow return values interprocedural argument capture general values recovers arguments previously reported techniques download pdf somesh jha modified mon jan cst 
global intrusion detection domino overlay system sharing data widely distributed intrusion detection systems offers possibility significant improvements speed accuracy isolated systems paper describe evaluate domino distributed overlay monitoring internet outbreaks architecture distributed intrusion detection system fosters collaboration heterogeneous nodes organized overlay network overlay design enables domino heterogeneous scalable robust attacks failures important component domino design active-sink nodes respond measure connections unused addresses enables efficient detection attacks spoofed sources reduces false positives enables attack classification production timely blacklists evaluate capabilities performance domino large set intrusion logs collected providers internet analysis demonstrates significant marginal benefit obtained distributed intrusion data sources coordinated system domino evaluate configure domino order maximize performance gains perspectives blacklist length blacklist freshness proximity perform retrospective analysis sql-snake sql-slammer epidemics highlights information exchange domino reduced reaction time false-alarm rates outbreaks finally provide preliminary results prototype active-sink deployment illustrates limited variability sink traffic feasibility efficient classification discrimination attack types download pdf somesh jha modified mon jan cst 
formalizing sensitivity static analysis intrusion detection key function host-based intrusion detection system monitor program execution models constructed static analysis highly desirable feature produce false alarms miss attacks prior work shown trade-off efficiency precision accurate models based pushdown automata pda inefficient operate due non-determinism stack activity paper present techniques determinizing pda models provide formal analysis framework pda models introduce concepts determinism stack-determinism present vpstatic model achieves determinism extracting information stack activity program dyck model achieves stack-determinism transforming program inserting code expose program state results show run-time monitoring models slow execution test programs shows reasonable efficiency sacrificed model precision compare models discover deterministic pda efficient stack-deterministic pda require memory download pdf somesh jha modified fri cdt 
security policy reconciliation distributed computing environments major hurdle sharing resources organizations heterogeneity order organizations collaborate policies resolved process resolving policies policy reconciliation general intractable problem paper addresses policy reconciliation context security present formal framework hierarchical representation security policies hierarchical representation exposes structure policies leads efficient reconciliation algorithm demonstrate agent preferences security mechanisms readily incorporated framework implemented reconciliation algorithm library called policy reconciliation engine pre order test implementation measure overhead reconciliation algorithm integrated pre distributed high-throughput system called condor download pdf somesh jha modified mon mar cst 
testing malware detectors today interconnected world malware worms viruses havoc malware detector commonly virus scanner attempts identify malware spite importance malware detectors dearth testing techniques evaluating present technique based program obfuscation generating tests malware detectors technique geared evaluating resilience malware detectors obfuscation transformations commonly hackers disguise malware demonstrate hacker leverage malware detector weakness handling obfuscation transformations extract signature detector specific malware evaluate widely-used commercial virus scanners techniques discover resilience scanners obfuscations poor download pdf somesh jha modified wed cdt 
automatic generation analysis nids attacks common elude signature-based nids transform attack instance nids recognizes instance misses avoid matching attack payload nids signature attackers split payload tcp packets hide benign messages observe attack instances derived simple transformations model transformations inference rules natural-deduction system starting exemplary attack instance inference engine automatically generate instances derived set rules result simple powerful tool capable generating attack instances nids testing determining sequence packets attack testing phases sets rules tool exposed vulnerabilities snort---a widely deployed nids attackers acquainted vulnerabilities construct instances elude snort tcp-based attack web-cgi attack attack signature type regular expression download pdf somesh jha modified fri dec cst 
detecting manipulated remote call streams internet mobile code ubiquitous includes examples browser plug-ins java applets document macros paper address important vulnerability mobile code security exists remote execution systems condor globus seti home systems schedule user jobs execution remote idle machines send important system calls back local machine execution evil process remote machine manipulate user job send destructive system calls back local machine developed techniques remotely detect manipulation job submitted remote execution construct model users binary program static analysis binary analysis applicable commodity remote execution systems applications remote job execution model checks system calls arriving local machine execution allowed continue model remains valid begin finite-state machine model accepts sequences system calls build optimizations model improve precision efficiency propose program transformations renaming null call insertion significant impact precision efficiency desirable side-effect techniques obfuscate program making harder adversary reverse engineer code implemented simulated remote execution environment demonstrate optimizations transformations binary program increase precision efficiency test programs unoptimized models increase run-time moderate levels optimization run-time increases precision gains reaching download pdf somesh jha modified fri apr cdt 
generalized authorization problem paper defines framework formalize variety authorization policy issues arise access control shared computing resources instantiations framework address issues privacy recency validity trust paper presents efficient algorithm solving authorization problems framework approach yields algorithms number specific authorization problems download pdf somesh jha modified mon apr cdt 
static analysis executables detect malicious patterns malicious code detection crucial component defense mechanism paper present unique viewpoint malicious code detection regard malicious code detection game malicious code writers researchers working malicious code detection malicious code writers attempt obfuscate malicious code subvert malicious code detectors anti-virus software tested resilience commercial virus scanners code obfuscation attacks results surprising commercial virus scanners subverted simple obfuscation transformations present architecture detecting malicious patterns executables resilient common obfuscation transformations experimental results demonstrate efficacy prototype tool safe static analyzer executables download pdf somesh jha modified mon nov cst 
buffer overrun detection liner programming static analysis paper addresses issue identifying buffer overrun vulnerabilities statically analyzing source code demonstrate light-weight analysis based modeling string manipulations linear program present fast scalable solvers based linear programming demonstrate techniques make program analysis context sensitive based techniques built prototype identify vulnerabilities popular security critical applications download pdf somesh jha modified fri nov cst 
automated generation analysis attack graphs integral part modeling global view network security constructing emph attack graphs practice attack graphs produced manually red teams construction hand tedious error-prone impractical attack graphs larger hundred nodes paper present automated technique generating analyzing attack graphs base technique symbolic model checking cite clarkegrumbergpeled algorithms letting construct attack graphs automatically efficiently describe analyses decide attacks cost-effective guard implemented technique tool suite tested small network includes models firewall intrusion detection system download pdf somesh jha modified fri apr cdt 
formal analyses attack graphs attack graph succinct representation paths system end state intruder successfully achieved goal today red teams determine vulnerability networked systems drawing gigantic attack graphs hand constructing attack graphs hand tedious error-prone impractical large systems viewing attack violation safety property off-the-shelf model checking technology produce attack graphs automatically successful path intruder viewpoint counterexample produced model checker paper present algorithm generating attack graphs model checking subroutine security analysts attack graphs detection defense forensics paper present minimization analysis technique analysts decide minimal set security measures guarantee safety system provide formal characterization problem prove polynomially equivalent minimum hitting set problem present greedy algorithm provable bounds present reliability analysis technique analysts perform simple cost-benefit trade-off depending likelihoods attacks interpreting attack graphs markov decision processes iteration algorithm compute probabilities intruder success attack graph download pdf somesh jha modified mon mar cst 
analysis spki sdsi certificates model checking spki sdsi framework expressing naming authorization issues arise distributed-computing environment paper establish connection spki sdsi formalism pushdown systems pdss show spki sdsi-to-pds connection framework formalizing variety certificate-analysis problems connection computational significance analysis problems solved efficiently time polynomial size certificate set existing algorithms model checking pushdown systems download pdf somesh jha modified fri mar cst 
survivability analysis networked systems survivability ability system continue operating presence abnormal events failures intrusions ensuring system survivability increased importance critical infrastructures heavily dependent computers paper present systematic method performing survivability analysis networked systems architect injects failure intrusion events system model visualizes effects injected events form scenario graphs method enables global analyses reliability latency cost-benefit analyses mathematical techniques domains combined systematic manner illustrate ideas abstract model united states payment system download pdf somesh jha modified fri apr cdt 
markov chains classifiers intrusion detection paper presents statistical anomaly detection algorithm based markov chains algorithm directly applied intrusion detection discovering anomalous activities framework constructing anomaly detectors general researchers constructing markov-chain-based anomaly detectors present performance metrics evaluating effectiveness anomaly detectors extensive experimental results demonstrate effectiveness algorithm discuss future directions research based framework presented paper download pdf somesh jha modified mon mar cst 
efficient filtering publish-subscribe systems binary decision diagrams implicit invocation publish-subscribe important architectural style large-scale system design evolution publish-subscribe style facilitates developing large-scale systems composing separately developed components style permits loose coupling components major bottlenecks publish-subscribe systems large scale systems efficiency filtering incoming messages matching published events event subscriptions challenging problem realistic publish-subscribe system number subscriptions large paper present approach matching published events subscriptions scales large number subscriptions approach binary decision diagrams compact data structure representing boolean functions successfully verification techniques model checking experimental results demonstrate efficiency approach download pdf somesh jha modified fri apr cdt 
efficient type matching palsberg zhao cite palsbergzhao presented time algorithm matching recursive types paper present log algorithm problem algorithm works reducing type matching problem well-understood problem finding size-stable partition graph result improve systems polyspin mockingbird designed facilitate interoperability software components discuss applications algorithm small java issues related subtyping recursive types discussed download pdf somesh jha modified fri apr cdt 
modular verification software components present methodology automatic verification programs finite state machine specifications approach compositional naturally enabling decompose verification large software systems subproblems manageable complexity decomposition reflects modularity software design weak simulation notion conformance program specification abstract-verify-refine paradigm tool tool extracts finite model source code predicate abstraction theorem proving subsequently simulation checked reduction boolean satisfiability tool interface publicly theorem provers sat solvers report experimental results procedures linux kernel openssl toolkit download pdf somesh jha modified fri apr cdt 
weighted pushdown systems application interprocedural dataflow analysis recently pushdown systems pdss extended weighted pdss transition labeled goal determine meet-over-all-paths paths meet criterion paper shows weighted pdss yield algorithms classes interprocedural dataflow-analysis problems download pdf somesh jha modified mon mar cst 
notes lectures introduction information security spring notes home detailed content notes assignments links project messages weekly summaries week week week week week week week week week week week week notes papers links 
assignments introduction information security spring assignments home detailed content notes assignments links project messages list give homeworks reading assignments homework pdf due date feb monday homework pdf due date mar tuesday homework pdf due date april homework pdf due date 
links introduction information security spring links home detailed content notes assignments links project messages snort open-source intrusion detection system snort page ipchains open-source firewall linux ipchains page freefire words freefire project founded summer bernd eckenfels beeing starting-point web seeking free security solutions main goal project support developers designers security experts usage free software freefire homepage smartcards information smart cards smart card homepage 
class project introduction information security spring project home detailed content notes assignments links project messages project information documentation project guidelines creating design document found documentation digital cash project documentation poker project documentation electronic voting project document general resources found information important due dates code handin procedure project demos 
document introduction information security somesh jha computer sciences department wisconsin madison jha wisc overview shared resources internet created global-information infrastructure hand shared resources create risks due intentional unintentional malicious behavior information security area deals protection detection malicious activity study fundamentals information security student good understanding facets information security syllabus basic cryptographic primitives part focus cryptographic primitives cover topics detail symmetric-key encryption stream ciphers linear non-linear feedback shift registers block ciphers des modes operations public-key encryption cover rsa elgamal public-key encryption hash functions data integrity basic properties hash functions unkeyed hash functions mdc shakeyed hash functions macs macs based block stream ciphers macs based mdcs digital signatures classification digital signatures digital signatures related rsa digital signature algorithm dsa protocols section focus protocols purposes protocols cryptographic primitives discussed part protocols discuss key establishment protocols kerberos diffie-hellman secret sharing web security secure sockets layer ssl secure payment protocols cybercash digital money digicash system security part focus system security common system vulnerabilities attacks focus tcp syn flooding denial-of-service attacks relevant material provided lecture time list vulnerabilities maintained cert coordination center web-page iswww cert located software engineering institute carnegie mellon firewalls discuss architecture firewalls firewalls discussed books required class notes sufficient intrusion detection systems types intrusion detection systems discussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort special topics time remaining discuss advanced topics elliptic-curve cryptography ecc smartcards book required text class stallings cryptography network security principles practice prentice hall fourth edition hand extra articles reading material class progresses grading criteria finalized homeworks short homeworks assigned class exams exams mid-term final exams equal weight project significant project related security students pick projects provide cheswick bellovin rubin firewalls internet security repelling wily hacker addison wesley publishing company northcutt network intrusion detection analyst handbook riders publishing zwicky cooper chapman russell building internet firewalls reilly associates 
important messages introduction information security spring messages home detailed content notes assignments links project messages important announcements area important announcements message archive 
cisc analysis software artifacts fall home page home detailed document notes assignments tools project messages instructor somesh jha computer sciences statistics building jha wisc time place mwf inghram hall audience introduction analysis variety artifacts arising context software engineering suitable students general background computer science electrical engineering general description motivated dominating trends modern software development artifacts typical software development process produces variety kinds artifacts instance specifications describe requirements state machines object models capture high-level designs solutions implemented source code communicated byte code documented hyper text documents analysis large number software related tasks rely analysis artifacts instance specifications checked consistency completeness state machines code analyzed correctness security legacy code maintained updated structure hypertext documents validated short program design validation verification reuse understanding require analysis artifacts automatic tools size complexity developed software artifacts involved increasing constantly large handled tool support experience academia industry shown degree automation tool important ingredient success tool minimizes user interaction expertise succeed introduces work undertaken academia industry address trends number kinds software artifacts analysis problems identified solution algorithms presented traditional analyses verification testing promising approaches model checking type systems covered balance theory practice existing academic commercial tools discussed suitable graduate students interested theory practice software development general software analysis material notes papers destributed instructor prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments presentations projects 
cisc introduction information security spring home page home detailed document notes assignments links project messages instructor somesh jha computer sciences statistics building jha wisc time place mwf cs-statistics building audience introduction information security covers broad range topics general description shared resources internet created global open information infrastructure global infrastructure advantages ease sharing information shared resources increase risk due malicious behavior information security area deals protection detection malicious activity follow general structure cryptographic primitives part focus cryptographic primitives cover topics symmetric-key public-key encryption hash functions digital signatures protocols part focus protocols primitives introduced earlier protocols key establishment protocols kerberos diffie-hellman secret sharing web security secure sockets layer ssl secure payment protocols cybercash digital money digicash system security part focus system security discuss common system vulnerabilities attacks tcp syn flooding denial-of-service attacks discuss general architecture firewalls intrusion detection systems special topics part focus topics security year discuss smartcards applications material notes papers distributed instructor required text menzes van oorschot vanstone handbook applied crytograph crc press books required chen java card technology smart cards architecture programmer guide addison-wesley publishing company cheswick bellovin firewalls internet security repelling wily hacker addison-wesley publishing company northcutt network intrusion detection analyst handbook riders publishing sherif protocols secure electronic commerce crc press stallings cryptography network security principles practice prentice hall zwicky cooper chapman russell building internet firewalls reilly associates prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments presentations projects 
analysis software artifacts fall home page home detailed document notes assignments tools project messages instructor somesh jha computer sciences statistics building jha wisc time place mwf noland office hours thursday audience introduction analysis variety artifacts arising context software engineering suitable students general background computer science electrical engineering general description motivated dominating trends modern software development artifacts typical software development process produces variety kinds artifacts instance specifications describe requirements state machines object models capture high-level designs solutions implemented source code communicated byte code documented hyper text documents analysis large number software related tasks rely analysis artifacts instance specifications checked consistency completeness state machines code analyzed correctness security legacy code maintained updated structure hypertext documents validated short program design validation verification reuse understanding require analysis artifacts automatic tools size complexity developed software artifacts involved increasing constantly large handled tool support experience academia industry shown degree automation tool important ingredient success tool minimizes user interaction expertise succeed introduces work undertaken academia industry address trends number kinds software artifacts analysis problems identified solution algorithms presented traditional analyses verification testing promising approaches model checking type systems covered balance theory practice existing academic commercial tools discussed suitable graduate students interested theory practice software development general software analysis material notes papers distributed instructor prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments presentations projects 
cisc introduction information security spring home page home detailed document notes assignments links project messages instructor somesh jha computer sciences statistics building jha wisc time place cs-statistics building audience introduction information security covers broad range topics general description shared resources internet created global open information infrastructure global infrastructure advantages ease sharing information shared resources increase risk due malicious behavior information security area deals protection detection malicious activity follow general structure cryptographic primitives part focus cryptographic primitives cover topics symmetric-key public-key encryption hash functions digital signatures protocols part focus protocols primitives introduced earlier protocols key establishment protocols kerberos diffie-hellman secret sharing web security secure sockets layer ssl secure payment protocols cybercash digital money digicash system security part focus system security discuss common system vulnerabilities attacks tcp syn flooding denial-of-service attacks discuss general architecture firewalls intrusion detection systems special topics part focus topics security year discuss smartcards applications material notes papers distributed instructor required text stallings cryptography network security principles practice prentice hall edition books required alfred menezes paul van oorschot scott vanstone handbook applied cryptography crc press download chapters book free link chen java card technology smart cards architecture programmer guide addison-wesley publishing company cheswick bellovin firewalls internet security repelling wily hacker addison-wesley publishing company northcutt network intrusion detection analyst handbook riders publishing sherif protocols secure electronic commerce crc press menzes van oorschot vanstone handbook applied crytograph crc press zwicky cooper chapman russell building internet firewalls reilly associates prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments exams presentations projects document details 
meta redirect code browser automatically redirected homepage http wisc jha course-archive -springindex html 
cisc introduction information security spring home page home detailed document notes assignments links project messages instructor somesh jha computer sciences building jha wisc office hours somesh jha mon fri louis kruger computer sciences building lpkruger wisc office hours louis kruger ampm mon time place computer sciences building audience introduction information security covers broad range topics general description shared resources internet created global open information infrastructure global infrastructure advantages ease sharing information shared resources increase risk due malicious behavior information security area deals protection detection malicious activity follow general structure cryptographic primitives part focus cryptographic primitives cover topics symmetric-key public-key encryption hash functions digital signatures protocols part focus protocols primitives introduced earlier protocols key establishment protocols kerberos diffie-hellman secret sharing web security secure sockets layer ssl secure payment protocols cybercash digital money digicash system security part focus system security discuss common system vulnerabilities attacks tcp syn flooding denial-of-service attacks discuss general architecture firewalls intrusion detection systems special topics part focus topics security year discuss smartcards applications material notes papers distributed instructor required text stallings cryptography network security principles practice prentice hall edition books required alfred menezes paul van oorschot scott vanstone handbook applied cryptography crc press download chapters book free link chen java card technology smart cards architecture programmer guide addison-wesley publishing company cheswick bellovin firewalls internet security repelling wily hacker addison-wesley publishing company northcutt network intrusion detection analyst handbook riders publishing sherif protocols secure electronic commerce crc press menzes van oorschot vanstone handbook applied crytograph crc press zwicky cooper chapman russell building internet firewalls reilly associates prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments exams presentations projects document details 
introduction information security spring home page home detailed document notes assignments links project messages instructor somesh jha computer sciences building jha wisc office hours somesh jha pmpm mihai christodorescu computer sciences building mihai wisc office hours mihai chritodorescu pmpm tba time place computer sciences building audience introduction information security covers broad range topics general description shared resources internet created global open information infrastructure global infrastructure advantages ease sharing information shared resources increase risk due malicious behavior information security area deals protection detection malicious activity follow general structure cryptographic primitives part focus cryptographic primitives cover topics symmetric-key public-key encryption hash functions digital signatures protocols part focus protocols primitives introduced earlier protocols key establishment protocols kerberos diffie-hellman secret sharing web security secure sockets layer ssl secure payment protocols cybercash digital money digicash system security part focus system security discuss common system vulnerabilities attacks tcp syn flooding denial-of-service attacks discuss general architecture firewalls intrusion detection systems special topics part focus topics security year discuss smartcards applications material notes papers distributed instructor required text stallings cryptography network security principles practice prentice hall fourth edition books required alfred menezes paul van oorschot scott vanstone handbook applied cryptography crc press download chapters book free link chen java card technology smart cards architecture programmer guide addison-wesley publishing company cheswick bellovin firewalls internet security repelling wily hacker addison-wesley publishing company northcutt network intrusion detection analyst handbook riders publishing sherif protocols secure electronic commerce crc press menzes van oorschot vanstone handbook applied crytograph crc press zwicky cooper chapman russell building internet firewalls reilly associates prerequisites mathematical maturity programming experience undergraduate students permission instructor evaluation participation assignments exams presentations projects document details 
appears annual security-enhanced linux symposium baltimore march automated authorization policy enforcement vinod ganapathy univ wisconsin-madison wisc trent jaeger pennsylvania state univ tjaeger cse psu somesh jha univ wisconsin-madison jha wisc abstract systems shared resources authorization policy enforcement ensures resources accessible users allowed recently growing interest extend authorization policy enforcement mechanisms provided operating system enable user-space servers enforce authorization policies clients popular mechanism authorization policy enforcement retrofits code secured hooks monitor basis linux security modules lsm framework intended usage recently-released security-enhanced linux policy management framework user-space servers monitor hooks manually operating system user-space server code approach tedious scale prior work shown context lsm error-prone research techniques largely automate authorization hook placement devised technique tested effectiveness applying determine hook placement linux kernel cross-validating lsm hook placement initial results encouraging extended technique work user-space servers applied technique determine authorization hook placement server motivation goal authorization framework ensure security-sensitive operations system resources performed users permitted site-specific authorization policy popular architecture constructing authorization framework monitor encapsulates authorization policy enforced system secured poses authorization query monitor performs security-sensitive operation performs operation authorization query succeeds architecture adopted linux security modules lsm flexible framework diverse authorization policies enforced linux kernel lsm hooks part linuxkernel hooks formed basis implementation selinux lsm monitor implemented loadable kernel module authorization hooks locations kernel hooks define interface api monitor hook call poses authorization query monitor authorization policy enforcement mechanisms traditionally confined operating system recently growing interest retrofit user-space servers ability enforce authorization policies monitoring reason user-space servers windows web-servers middle-ware offer shared resources buffers caches clients manage multiple clients simultaneously paramount protect shared resources unauthorized access server cut-buffer shared clients suppose server runs machine capable enforcing multi-level security mls clients security-labels top-secret unclassified enforce end-to-end security server enforce authorization policy clients instance ensure cut operation top-secret window paste operation unclassified window fact efforts underway secure server monitor-based architecture recent release selinux policy management server intended enable development authorization policies selinux policy language user-space application benefit lsm policy management server answers authorization queries authorization hooks locations appears annual security-enhanced linux symposium baltimore march user-space server work systematic techniques place authorization hooks placement decided manually informally process suffers drawbacks scale process placing hooks linux kernel context lsm iterative time-consuming process tedious repeat process user-space server retrofitted monitoring automated solutions determine hook placement desirable prone security-holes prior research shown security holes due improper hook placement linux kernel zhang demonstrate inadequate placement hooks results security-sensitive operations performed authorization query posed monitor jaeger demonstrate similar bugs comparing consistency hook placements program paths bugs potentially exploitable research techniques largely automate placement authorization hooks developed program analysis-based technique conducted case studies study study effectiveness algorithms reproducing hook placement lsm manual hook placement lsm extensively-verified enables evaluate effectiveness technique show results study encouraging recent work enhanced technique determine authorization hook placement server benefits selinux community technique benefits selinux community ways enables hook placement user-space servers technique combination static dynamic program analysis determine user-space server performs security-sensitive operations locations retrofitted hooks monitor technique largely automated significantly reduce turnaround time hook placement week technique reconstruct placement file-system networking hooks lsm framework fairly good precision refined basic technique refinements determine placement hooks protect window operations server hours verification focus work develop techniques determine authorization hook placement user-space servers technique adapted verification code authorization hooks lsm technique verify existing placement comparing placement produced technique overview technique present high-level informal overview technique refer interested reader details technique proceeds steps shown fig applicable illustrate technique examples server linux kernel discussion denote server retrofitted authorization hooks kernel retrofitted refers kernel step find security-sensitive operations protected step determine set resources server accesses controlled authorization policy refer operations performed resources security-sensitive operations work relied manual identification security-sensitive operations current work investigating heuristics automatically identify security-sensitive operations manual identification security-sensitive operations proceeds typically wide range policies enforce determining set security-sensitive operations based policies instance security-sensitive operations manually identified linux kernel security-sensitive operations manually identified server rest paper represent operations sans-serif font resource operation case linux shared resources included files directories sockets security-sensitive operations identified linux included file write file read file execute dir rmdir dir mkdir socket create socket listen intuitive meanings similarly server shared resources include windows fonts drawables include security-sensitive operations window create window map window enumerate case linux kernel server design team nsa manually identified set security-sensitive operations security-sensitive operations accompanied informal english-language description meaning precise code-level description main contributions formalizing security-sensitive operations code-level descriptions characterize security-sensitive operations actual code-templates referred code-patterns responsible securitysensitive operation formalized step step infer root-cause security-sensitive operations step identify root-cause appears annual security-enhanced linux symposium baltimore march generate monitor security sensitive protected operations monitor codereference operations sec sens locate root find locssens sec causesroot serverinstr identifysec sens operations instrument legacy code monitorreference link retrofitted alpenaid legacy code code figure steps involved retrofitting server authorization policy enforcement security-sensitive operation root-cause security-sensitive operation defined codelevel constructs executed securitysensitive operation performed formally root-cause expressed conjunction codepatterns represent code-level constructs terms abstract-syntax-trees asts presenting formal definition code-patterns rootcauses found present examples examples security-sensitive operation dir write linux kernel denotes write operation directory root-cause identified set inodei ctime call address space opsprepare write intuition writing directory involves adding content data structures store directory content achieved call prepare write setting change time field ctime directory inode operation window map server mapping client window screen characterized set xeventunion- type maprequest set xeventunion- type mapnotify intuitively corresponds client request server mapping window notification server operation successful initial case study placing authorization hooks linux wrote root-causes manually fairly easy write root-causes wrote week securitysensitive operations related file-system networking subsystem clear automated technique needed approach scale userspace servers key challenge automatically recover association security-sensitive operations code-patterns root-causes key observation helps achieve goal security-sensitive operation typically tangible side-effect securitysensitive operation dir write linux kernel typically corresponds changed directory contents similarly security-sensitive operation window map server results client window mapped screen induce server perform tangible side-effect security-sensitive operation trace server codepatterns characterize security-sensitive operation trace program traces typically long challenging identify code-patterns characterize security-sensitive operation thousand entries program trace developed technique details compare program traces 
side-effects reduce portion trace examined determine root-causes technique identifying root-causes reduces studying fewer entries average program trace applied technique determine root-causes security-sensitive operations window data structure server automatically precisely identified rootcauses operations root-cause window map discussed earlier automatically identified technique step find locations securitysensitive finding root-causes security-sensitive operations suffice find locations code server operations potentially performed step results root-cause analysis statically identify locations server codepatterns characterize security-sensitive operation occurs locations performs operation fig shows snippet code mapsubwindows function server writes maprequest mapnotify event type traversal children window pointer pparent call appears annual security-enhanced linux symposium baltimore march function mapsubwindows performs addition window map security-sensitive operation window enumerate enumeration child windows automatically identify set security-sensitive operations performed function call static analysis algorithm searches code server code-patterns root-cause security-sensitive operation mapsubwindows pparent pclient pwin pparentfirstchild pwin pwin pwinnextsib event type maprequest event type mapnotify figure mapsubwindows addition identifying locations securitysensitive operations occur step heuristics identify subject object operation identify variables subject object data types client window scope cases heuristic precisely identifies subject object fig subject client requesting operation pclient object window children mapped pparent parameters mapsubwindows scope steps identify locations server performs security-sensitive operations location identify subject object operation implemented prototype tool called aid performs steps step instrument server identified locations security-sensitive operations performed server retrofitted inserting calls monitor locations achieve complete mediation note aid determines statement stmt security-sensitive identifies securityevent generates security-event triple obj denoting subject requesting operation performed object obj statement stmt generates security event obj instrumented shown query refmon obj false thenhandle failure elsestmt statement handle failure server suitable action offending client terminating client auditing failed request authorization policies typically expressed terms security-labels subjects objects securitylabels stored table monitor generated step alternately data structures server represent subjects objects technique lsm adds fields kernel data structures inodes sockets store security-labels technique user-space servers server extra fields added client windowdata structures store security-labels pass subject object monitor query refmon monitor lookup security-labels consult policy step generate monitor code step generates code query refmon function generate template function omitting details filled-in manually developer developer policy consulted constrain authorization policy language developer choose policy language policy management framework choice tresys selinux policy management framework security-labels subjects objects change response authorization request server security-event pclient pwin window create succeeds creation window security-label pwin newly-created window initialized appropriately similarly securityevent copies data pwin pwin entail updating security-label pwin security-labels stored table monitor fields subject object data structures earlier developer modify data structures appropriately update security-labels note steps policy independent step requires knowledge depends specific policy enforced steps ensure complete mediation security-sensitive operations identified aid prototyped steps tool called alpen fig designed alpen generate code tresys selinux policy management server intend future step link modified server monitor step involves linking retrofitted server monitor code create executable enforce authorization policies noteworthy feature approach modularity alternate implementations root-cause analysis instrumentation place aid alpen technique benefits directly improved algorithms tasks case studies understand effectiveness approach conducted case studies case study performed linuxkernel goal appears annual security-enhanced linux symposium baltimore march hook cat num locs false pos false neg inode socket figure results hook placement technique false positives count locations technique places extra hook false negatives count locations missing hooks reproduce closely hook placement lsm reason chose version kernel version hooks default version allowing objectively evaluate precision technique mentioned earlier study wrote root-causes securitysensitive operations manually realized approach scale user-space applications designed automated technique identify root-causes discussed step case study automated root-cause finding determine hook placement server discuss preliminary results case studies placing hooks linux kernel study effectiveness technique evaluated precision determines hook placement file system networking subsystem linuxkernel fig presents results study lsm framework places distinct hooks locations linuxkernel inode hooks locations kernel socket hooks locations kernel fig compares results produced automated technique manually hooks lsm framework shows false positives false negatives generated technique false positive corresponds location kernel technique places extra authorization hook compared lsm hook placement false positives undesirable result extra authorization potentially wrongly denying user access resource false negatives result missed authorization checks potentially security holes technique produced false positives false negatives inode hooks false positives socket hooks mentioned earlier wrote root-causes manually security-sensitive operations linux kernel encouraged results fig obtained root-causes wrote week enhanced technique automate process writing root-causes placing hooks server case study place hooks server note made similar efforts goal automate process focused placing hooks security-sensitive operations window data structure nsa identified security-sensitive operations server related windows precisely identify rootcauses security-sensitive operations automated root-cause-finding algorithm aid alpen hooks protect security-sensitive window operations tested efficacy technique writing policies prevent attacks written policy prevent unauthorized client setting properties belonging client similarly written policy prevent information leakage unauthorized cut-and-paste operation mentioned earlier policies written selinux policy language future work intend integrate technique work selinux policy management server enabling enforcement policies written selinux policy language ganapathy jaeger jha automatic placement authorization hooks linux security modules framework acm ccs nov ganapathy jaeger jha retrofitting legacy code authorization policy enforcement technical report univ wisconsin nov wisc papers ccs idioms html jaeger edwards zhang consistency analysis authorization hook placement linux security modules framework acm tissec kilpatrick salamon vance securing window system selinux nai smalley vance salamon implementing selinux linux security module technical report nai labs december wright linux security modules general security support linux kernel usenix security august tresys technology selinux policy management server http sepolicy-server sourceforge net walsh integrating xfree security-enhanced linux manuscript zhang edwards jaeger cqual static analysis authorization hook placement usenix security august 
published proceedings ieee symposium security privacy oakland california retrofitting legacy code authorization policy enforcement vinod ganapathy wisconsin madison wivg wisc trent jaeger pennsylvania state park patjaeger cse psu somesh jha wisconsin madison wijha wisc abstract researchers argued construct secure system proactively integrate security design system tenet rarely economic practical considerations security mechanisms added arises retrofitting legacy code existing techniques manual hoc result security holes present program analysis techniques assist process retrofitting legacy code authorization policy enforcement techniques retrofit legacy servers window web proxy cache servers servers manage multiple clients simultaneously offer shared resources clients ability enforce authorization policies developer techniques identify security-sensitive locations legacy servers place monitor calls mediate locations demonstrate techniques retrofitting server enforce authorization policies clients introduction researchers traditionally argued construct secure systems proactively design security unquestionably construct secure systems economic practical considerations force developers choose functionality performance security result commodity systems ship inadequate security mechanisms built security retroactively added arises case linux security modules lsm framework linux kernel retrofitted mechanisms enforce mandatory access control policies similarly popular server applications lack mechanisms enforce authorization policies clients growing interest retrofit servers add mechanisms existing techniques retrofit legacy code security mechanisms ability enforce authorization policies manual hoc surprisingly security holes found manually-retrofitted code desirable automated techniques retrofit legacy code paper address problem retroactively adding security mechanisms legacy software systems focus techniques retrofit class legacy servers authorization policy enforcement examples servers techniques applicable include window servers server middleware web proxy cache database servers servers offer shared resources clients manage multiple clients simultaneously ability enforce authorization policies clients server prevent unauthorized client reading contents client windows main challenge retrofitting legacy server identifying locations security-sensitive operations primitive operations critical server resources performed idea identified locations authorization policy lookups added server code completely mediate locations develop techniques assist identification locations server code security-sensitive operations performed instrumentation locations operation performed allowed authorization policy prototyped techniques tools discussed assistant fingerprint identification hybrid static dynamic analysis tool helps developer identify locations server code security-sensitive operations performed key idea security-sensitive operation typically characterized canonical code-patterns executed server call code-patterns fingerprint security-sensitive operation human fingerprint identifies individual code-patterns identify security-sensitive operation challenge find fingerprints security-sensitive operations identify fingerprints observation security-sensitive operations typically tangible side-effects tracing server performs side-effect analyzing code-patterns trace extract fingerprints security-sensitive operations side-effect server securitysensitive operation window create creates window window creation tangible side-effect client analyzing trace generated server opens client window screen identifies call function createwindow implemented server fingerprint window create function allocates memory initializes variable type window response client request call createwindow server results window create two-phase tool phase traces server identifies fingerprints security-sensitive operations discussed phase statically identifies locations code server fingerprints occur locations deemed perform security-sensitive operation assistant monitoring tool instrument locations discovered adds calls monitor encapsulates authorization policy enforced calls perform authorization policy lookups completely mediate security-sensitive locations ensuring security-sensitive operation performed allowed authorization policy fully automatic feel improvement existing techniques completely manual note techniques applicable legacy code satisfy assumptions lay section case study retrofitting server server accepts connections multiple clients manages resources windows buffers offers clients important server enforce authorization policies clients manual effort retrofit server authorization policy enforcement mechanisms initiated nsa early retrofitted server produced recently taking approximately years demonstrate techniques assist potentially reduce turnaround time efforts retrofit legacy servers performing case study server specifically retrofitted server enforce mandatory access control policies window operations requested clients identify security-sensitive locations server add monitoring code hours manual effort ran retrofitted server security-enhanced operating system selinux clients security-labels top-secret unclassified retrofitted server enforced authorization policies clients based security-labels question arise server retrofitted enforce authorization policies clients existing policy enforcement mechanisms security-enhanced operating system selinux server runs enforce policies answer server provide channels communication clients readily visible operating system enforcing policy server disallows cut operation top-secret window paste operation unclassified window cut paste server-specific channels client communication operations kernel footprint readily visible operating system server primitive operations advisable cases operating system enforce authorization policies modified made aware kernel footprints server-specific operations introduces application-specific code operating system addition server modified expose information operating system internal data structures affected requested operation argued impractical contributions summarize main contributions program analysis techniques identify securitysensitive locations legacy code retrofit locations monitor calls authorization policy enforcement prototype implementations techniques tools section approach based program tracing find fingerprints security-sensitive operations fingerprints statically find security-sensitive locations section retrofits locations monitor calls application tools retrofit server enforce authorization policies clients section broadly feel valuable retroactive techniques tools presented paper add security mechanisms legacy code overview approach goal enforce authorization policy security-sensitive operations requested client connects server section show techniques securely retrofit server begin stating assumptions assumptions server adversarial assume server adversarial written malicious intent actively defeat retroactive instrumentation assume server remove modify instrumentation insert ensured operating system loads server execution comparing hash executable precomputed require server nonself-modifying preclude possibility instrumentation modified runtime property enforced making code pages write-protected defense control-hijacking exploits existing vulnerabilities buffer-overflow vulnerabilities possibly exploited malicious hackers bypass instrumentation hope eliminate vulnerabilities statically assume server protected techniques ccured cyclone runtime execution monitoring sandboxing terminate execution behavior server differs expected behavior cooperation environment environment server runs cooperate enforce authorization policies malicious intent server relies operating system policy enforcement tasks requires operating system ensure authorization policy tamper-proof clients typically connect server operating system server relies operating system important information security-labels clients client communication assume clients communicate directly communication mediated server operating system client communication mediated operating system policy enforced operating system restrict case communication mediated server note clients communicate operating system avail server-specific security-sensitive operations cut paste case server goal enforce authorization policies server-specific security-sensitive operations requested clients finally assume client-server communication altered intervening software layers commercial deployments server accompanied window manager gnome kde window manager controls clients connect server theory alter information exchanged server clients window managers number unlike clients assume verified satisfy assumption operating system ensure certified window managers allowed run server summary suffices ensure operating system trusted computing base bootstraps security ensuring instrumentation inserted server tampered clients trusted malicious client security information security-label bootstrapped operating system client connection stored 
server ensuring clients tamper security information connection established describe rest paper client requests security-sensitive operations mediated instrumentation add enabling enforcement authorization policies clients basic tools enforce authorization policies retrofitting server ensure security-sensitive operations requested clients mediated approved authorization policy monitor authorization policy defined set triples obj triple denotes subject allowed perform security-sensitive operation object obj subjects objects security-labels instance top-secret documents security-label top-secret authorization policies represented security-labels subjects objects subjects objects monitor quadruple parameterized authorization policy set security events security event triple obj state monitor set storing current associations security-labels subjects objects state update function denotes subject object security-labels change response policy decisions bool policy consulter returns true security event permitted monitor enforcer observes events generated response client requests passes monitor violations policy result returning false enforcer action enforcing authorization policies entails implementing enforcer monitor enforcer implementation enforcer ability monitor security events generated response client requests ability action security event results authorization failure action terminate client request resulted authorization failure monitor security events enforcer infer security-sensitive operation requested security-label subject requests operation typically client object operation performed preventive action security event permitted authorization policy enforcer control execution clients server audit failure appropriately monitor implementation monitor ensure state monitor authorization policy tamper-proof addition state updated appropriately response security events implementing entails policy achieved off-the-shelf policy management libraries selinux policy development toolkit approach section present high-level informal overview approach describe implement enforcer monitor details omitted section section section approach proceeds steps shown figure applicable illustrate technique server step find security-sensitive operations protected step determining securitysensitive operations protected manual typically design team considers security requirements server determines security-sensitive operations based requirements approach case lsm framework server security-sensitive operations identified kernel resources server resources design team typically considers wide range policies enforced server security-sensitive operations typically granularity authorization policies written policy set triples form subi obji opi set operations opi identified paper assume set security-sensitive operations server set operations identified manually kilpatrick set operations number considers security-sensitive operations key server resources including client window font drawable input xevent data structures security-sensitive operations window data structure window create window map window enumerate denote securitysensitive operations paper suggestive names informal description securitysensitive operations provided kilpatrick precise code-level description operations needed enforcement steps achieves identifying fingerprints operations noted techniques parameterized set security-sensitive operations additions deletions set affect algorithms step find fingerprints security-sensitive operations step identifies fingerprints securitysensitive operations mentioned introduction server executes canonical code-patterns performs security-sensitive operation codepatterns fingerprint operation association security-sensitive operation code-patterns executed priori goal step recover association key observations achieve goal observation security-sensitive operation typically tangible side-effect security-sensitive operations window create window map window enumerate server opening mapping enumerating child windows client window induce server perform tangible side-effect security-sensitive operation trace server code-patterns form fingerprint security-sensitive operation trace program traces typically long challenging identify code-patterns form fingerprint security-sensitive operation thousand entries program trace observation addresses challenge identify fingerprint security-sensitive operation suffices compare program traces produce tangible side-effect operation displaying visible client window xterm involves mapping window screen window map closing typing xterm window identify code-patterns canonical window map suffices compare trace generated opening xterm window trace generated closing security monitor codereference operationssec sens locatelocs sens sec operationssec sens identify monitor referencelink server referenceproducemonitor instrumentthe serverprintsfinger callsserver retrofittedserver legacy server aid arm findfingerprints figure steps involved retrofitting server authorization policy enforcement typing window similarly closing browser window closing child windows involves window enumerate typing window observations identifying fingerprints reduces studying entries average program trace technique identified fingerprints window create call createwindow window map writes true field mapped variable type window mapnotify field type variable type xevent window enumerate read windowptrfirstchild read windowptrnextsib windowptr nequal intuitively performed linked-list traversal note code-patterns expressed granularity reads writes individual fields data structures discuss tracing infrastructure algorithms compare traces identify fingerprints detail section mapsubwindows pparent pclient pwin pparentfirstchild pwin pwin pwinnextsib pwinmapped true event type mapnotify figure server function mapsubwindows step find locations security-sensitive step results fingerprint analysis statically identify locations server codepatterns form fingerprint security-sensitive operation occur locations performs operation figure shows snippet code mapsubwindows function server writes true pwinmapped mapnotify event type traversal children window pointer pparent call function mapsubwindows performs operations window map window enumerate identify set securitysensitive operations performed function call static analysis section addition identifying locations securitysensitive operations occur step identify subject object operation identify variables subject object data types client window scope cases heuristic good-enough identify subject object figure subject client requesting operation pclient object window enumerate window children enumerated pparent object window map variable denoting child windows pwin mapped screen steps identify locations server performs security-sensitive operations steps realized step instrument server identified locations security-sensitive operations performed server retrofitted inserting calls monitor locations achieve complete mediation determines statement stmt security-sensitive generates security event obj instrumented shown note stmt call function foo query alternately function-body foo query refmon obj handle failure stmt mapsubwindows performs security-sensitive operation window enumerate children pparent enumerated calls mapsubwindows protected shown query refmon pclient pparent window enumerate handle failure mapsubwindows pparent pclient statement handle failure server suitable action offending client terminating client auditing failed request mentioned earlier authorization policies expressed terms security-labels subjects objects securitylabels stored table monitor alternately data structures server represent subjects objects server extra fields added client window data structures store security-labels case pass pointers subject object monitor query refmon monitor lookup security-labels consult policy step generate monitor queries step generates code query refmon function generate template function omitting details filled-in manually developer developer policy consulted implement policy management api implement state update function state monitor updated security-event pclient pwin window create succeeds creation window securitylabel pwin newly-created window initialized appropriately similarly security-event copies data pwin pwin entail updating securitylabel pwin chinese-wall policy security-labels stored table monitor fields subject object data structures earlier developer modify data structures appropriately update security-labels step detail section note steps policy independent step requires implementation depend specific policy enforced steps ensure complete mediation security-sensitive operations identified realized tool step link modified server monitor step involves linking retrofitted server monitor code create executable enforce authorization policies examine security approach enforcer implemented instrumentation inserted 
step subject object operation passed monitor security-labels retrieved authorization policy consulted requested operation permitted policy instrumentation ensures executed server controls client connections handle failure terminate execution malicious clients monitor part server address space tamper-proof assumptions section alternately monitor run separate process communicate server ipc policy protected storing file-system permissions modified privileged system user noteworthy feature approach modularity alternate implementations fingerprintfinding dynamic slicing instrumentation aspect weavers place technique benefits directly improved algorithms tasks locating security-sensitive operations analyzes legacy servers identifies locations perform security-sensitive operations discussed earlier phases identifying fingerprints security-sensitive operations case combinations code-patterns identify operation static analysis phase identifies locations code code-patterns occur discuss steps detail identifying fingerprints analysis program traces recall ultimate goal retrofit legacy server ensure policy lookups completely mediate securitysensitive operations step process locate security-sensitive operations performed fingerprints security-sensitive operations task formally code-pattern defined function call read write field data-structure comparison values shown figure note code-patterns expressed terms abstract-syntax-trees asts express code-patterns generically terms datastructures individual variables fingerprint security-sensitive operation defined conjunction code-patterns codepat call ast read ast write ast compare constant ast ast type-namefield figure code-pattern definition server fingerprint window create call createwindow fingerprint window enumerate enumerates children window windowptr nequal read windowptrfirstchild read windowptrnextsib intuitively denotes code-patterns traverse list children window security-sensitive operation fingerprints ways performing operation forward backwards traversal linked list children window constitute fingerprints window enumerate instance key challenge discover fingerprints security-sensitive operations priori case legacy thirdparty code fingerprints succinct fingerprint small combination code-patterns identifies security-sensitive operation address challenge making observations observation tangible side-effects security-sensitive operations tangible side-effects tangible side-effects determine server performed security-sensitive operation induce server perform security-sensitive operation occurrence tangible side-effect denotes operation performed code-patterns fingerprint security-sensitive operation trace generated server identifying fingerprints reduces tracing server performs tangible sideeffect recording code-patterns figure executes process program trace generated server performs tangible side-effect huge tracing infrastructure server generates trace length experiment performed start server open xterm close xterm close server tangible side-effect impossible identify succinct fingerprints security-sensitive operations window create window destroy studying trace observation addresses problem observation comparing traces comparing trace security-sensitive operation traces operation yields succinct fingerprints key idea underlying observation run server perform security-sensitive operation trace produced server fingerprint operation trace topen opens client window server fingerprint window create trace tclose closes window topen tclose shorter trace fingerprint window create continuing process traces perform window create reduces size trace examined fact server reduce size trace several-fold technique figure whittling search fingerprints functions average technical difficulty addressed compare traces tangible side-effect multiple security-sensitive operations securitysensitive operations identified instance xterm window opened server security-sensitive operations include creating window window create mapping screen window map initializing window attributes window setattr manually identify security-sensitive operations tangible side-effect sideeffects tangible programmers typically intuitive understanding operations involved performing side-effect trace generated tangible side-effect assigned label set security-sensitive operations performs important note tangible side-effects specific server applicable servers database server dropping adding record changing fields records performing table joins tangible side-effects labeling traces manual process conceivable labeled correctly show empirically fingerprints identified succinctly precisely spite errors labeling trace multiple security-sensitive operations formulate set-equations operation terms labels traces definition set equation set set collection subsets set equation element complement element algorithm seff input server retrofitted set security-sensitive operations opn iii seff set tangible side-effects seff seffm output fpn fpi fingerprint security-sensitive operation opi xprime instrumented perform tracing foreach tangible side-effect seffi seff trace generated xprime induced perform seffi label set operations involved seffi foreach opi sei set-equation opi terms label label cpseti set code-patterns fpi result set operations sei performed cpset cpsetm algorithm algorithm find fingerprints security-sensitive operations find fingerprint operation set security-sensitive operations denote label set security sensitive operations performed trace obtained server performs tangible side-effect seffi formulate set-equation terms apply set-operations set code-patterns resulting set code-patterns fingerprint trace side-effect seff performs opprime trace side-effect seff performs opprime opprime opprime set code-patterns set code-patterns find fingerprint observe perform set-operations set codepatterns obtain reported fingerprint process formalized algorithm finding set-equations general hard problem precisely define cnf-set-equation set-equation expressed conjunctive normal form conjunction disjunction operators disjunct equation clause shown cnf-set-equation problem restricted version general problem finding set-equations np-complete definition cnf-set-equation problem set set collection subsets definition integer cnf-set-equation clauses simple brute-force algorithm find set-equations works number sets examine number traces gather fortunately small server evaluation fingerprint-finding algorithm implemented algorithm modified version gcc compile server compilation instrumentation inserted statically statements read write fields critical data structures log field data structure read written function file line number occurs induce modified server perform set tangible side-effects proceed algorithm find fingerprints applied find fingerprints security-sensitive operations server recorded reads writes fields data structures client window font drawable input xevent figure shows portion result performing lines algorithm columns represent traces tangible side-effects rows represent security-sensitive operations window data structure manually labeled trace security-sensitive operations performs entries marked figure opening xterm server includes creating window window create mapping screen window map placing appropriately stack windows server maintains window chstack setting attributes window getattr window setattr drawing contents window window drawevent trace operations calls distinct functions server shown row figure figure shows result performing lines algorithm labeled traces obtained operation set-equation obtain fingerprints size resulting set set fingerprints shown note security-sensitive operation fingerprint case window enumerate window inputevent find errors manual labeling traces finding fingerprints security-sensitive operations checked trace presence fingerprints presence fingerprint security-sensitive operation trace labeled securitysensitive operation shows error manual labeling entries marked figure label trace generated opening browser htmlview window unmap hand absence fingerprints security-sensitive operation trace labeled security-sensitive operation shows error manual labeling entries marked figure label trace generated moving window window getattr fact operation performed window moved evaluate fingerprint finding algorithm answering questions effective locating fingerprints rawtraces generated tangible-side effects average code-patterns abstracts trace function calls identifies fingerprints function-call level delves codepatterns exercised function number distinct functions called trace shown row figure column figure shows terms number function calls size result obtained computing setequation security-sensitive operation determine fingerprints achieve order magnitude reduction terms number distinct functions examined fingerprints examined functions detertrace side-effect sec -sens operation wser close bro wser type windo 
windo open close twm menu switchwindo open menu bro wser window create window destroy window map window unmap window chstack window getattr window setattr window move window enumerate window inputevent window drawevent distinct functions figure examples labeled traces tangible side-effects obtained server entry row column denotes trace represented column performs security-sensitive operation represented row entry denotes mistake manual labeling operation set equation fingerprint window create call createwindow window destroy call deletewindow window map write true windowmapped write mapnotify xeventunion- type window unmap write unmapnotify xeventunion- type window chstack call movewindowinstack window getattr call getwindowattributes window setattr call changewindowattributes window move call proctranslatecoords window enumerate read windowptrfirstchild read windowptrnextsib windowptrnequal read windowptrlastchild read windowptrprevsib window inputevent call coreprocesspointerevent call coreprocesskeyboardevent call eqprocessinputevents window drawevent call delivereventstowindow average figure fingerprints obtained applying algorithm labeled traces figure mine fingerprint cases found security-sensitive operation single function performs operation cases multiple functions perform security-sensitive operation call mapwindow call mapsubwindow present performed window map cases examined traces generated determine common code-patterns exercised call functions window map reveals common code-patterns mapwindow mapsubwindow write true windowmapped write mapnotify xeventunion- type security-sensitive operations window inputevent find common code-patterns exercised candidate functions deemed function calls fingerprints operation precise fingerprints found fingerprints recovered server manually verified fingerprint security-sensitive operation question general recover fingerprints security-sensitive operation runtime analysis capture fingerprints security-sensitive operation exercised runtime traces miss ways perform operation collecting traces larger number tangible side-effects verifying fingerprints collected traces confidence increased precision fingerprints obtained future plan investigate static techniques identify fingerprints overcome limitation effort involved manual labeling traces collected traces tangible side-effects exercising window-related security-sensitive operations hours manually label traces security-sensitive operations effective manual labeling traces cases easy reason security-sensitive operations performed tangible side-effect induced process manual miss security-sensitive operations performed entries figure erroneously label trace security-sensitive operations performed entries experience manually labeling traces server shows process error rate approximately noted recover fingerprints precisely spite labeling errors security-sensitive operation wrongly omitted labels trace performs tangible side-effect operation case security-sensitive operation appears labels traces set-equation formulated operation fingerprint recovered hand security-sensitive operation wrongly added labels trace case functions perform tangible side-effect case trace labels refined process iterated fingerprint identified identifying security-sensitive locations static analysis identified fingerprints security-sensitive operations employs static analysis find locations code server fingerprints occur identifies security-sensitive locations granularity function calls note fingerprints function calls considers fingerprints function calls window map window unmap window enumerate identifies functions code-patterns idea mediating calls functions patterns security-sensitive operations mediated flow-insensitive intraprocedural analysis algorithm identifies set code-patterns body function checks fingerprints security-sensitive operation set function marked performing security-sensitive operation security-sensitive operation fingerprints function calls algorithm marks functions performing operation supports interprocedural search code-patterns fingerprints cross procedure boundaries algorithm input server retrofitted set security-sensitive operations opn set fingerprint sets fpn opn output opset opset denotes set security-sensitive operations performed call function process fingerprints function calls foreach fingerprint set fpi fpseti set code-patterns fpi fpseti call call foreach opset opset opi fpi process fingerprints foreach function opset set code-patterns determined asts statements foreach fingerprint set fpi fpseti opset opset opi return opset algorithm finding functions codepatterns fingerprints encounter fingerprints server function mapsubwindows server figure function maps children window pparent figure screen note code-patterns constitute fingerprint window enumerate window map opset mapsubwindows window map window enumerate slightly powerful variant code-pattern language figure match code-patterns function bodies extends figure ability simple relations instances asts match patterns read windowptr firstchild read windowptr nextsib windowptr nequal windowptr matching codepatterns figure parent firstchild field read nextsib child windows finally helps identify subject requesting object security-sensitive operation performed identifies variables relevant types scope server subject client requesting operation variable client data type object identified based kind operation requested window operations object variable window data type set manually inspected recover relevant subject object location evaluation security-sensitive location-finding algorithm implemented static analysis algorithm plugin cil evaluate security-sensitive location finding algorithm answering questions precise security-sensitive locations found algorithm precisely identifies set security-sensitive operations performed function exception reports false positives window enumerate operation reports functions perform operation fact functions reported performing window enumerate found inadequate expressive power code-pattern language matches functions codepatterns windowptr nequal read windowptrfirstchild read windowptrnextsib perform linked-list traversal false positives eliminated enhancing code-pattern language constructs loop constructs easy identify subjects objects mentioned earlier identify subjects objects variables relevant data types scope simple heuristic effective functions identified performing window operations subject type client object type window formal parameters derivable formal parameters remaining functions specifically performing window inputevent subject object derived global variables case manual inspection quickly reveals relevant global variables protecting security-sensitive locations locations identified performing security-sensitive operations protected instrumentation helps recover complete description security-events adding instrumentation straightforward calls query refmon inserted section function protected implemented server library case security-sensitive function calls server calls query refmon function body variables constitute security-event passed query refmon obj security event call query refmon obj data structures represent subjects objects internal server avoids tocttou bugs construction bool query refmon client window obj operation switch case window create policy lookup sublabel null window create success objlabel sublabel return true return false case window map figure code fragment showing implementation query refmon window create generates template implementation query refmon shown figure developer faced tasks implementing policy consulter developer insert calls policy management api choice template implementation query refmon generated impose restrictions policy language policy management framework figure shows shows snippet code generated subject object labels stored fields label data structures representing statement italics call function policy lookup changed developer substituted call api policymanagement framework developer choice off-the-shelf policy-management tools including selinux policy management toolkit manages policies written selinux policy language tool relevant api call replace policy lookup avc perm implementing monitor state updates developer update state monitor based state update function note depends policy enforced policies choose update security-labels differently functionality determine security-labels change based authorization request succeeds fails ideally provided policy-management tool security-labels change policy-dependent functionality policy-management tool developer update state monitor manually fragment code bold figure shows simple window created security-label initialized security-label client created worth noting pointer window created memory allocated createwindow function server place call query refmon 
createwindow statement allocates memory window call succeeds security-label window initialized free memory allocated return null window handle failure implemented return null finally remains explain bootstrap securitylabels server mentioned earlier assume server runs machine security-enhanced operating system operating system support bootstrap security-labels based clients connect server selinux system socket connections security-labels clients connect server socket security-label socket obtained operating system security-label client propagate client security-labels manipulate resources server shown figure client security-label security-label newly-created window enforcing authorization policies clients retrofitted server demonstrate server retrofitted enforces authorization policies clients run retrofitted server machine running selinux fedora core bootstrap security-labels server selinux security-labels client label socket connect server brevity describe attacks unsecured server describe policies enforced retrofitted server prevent attacks case implemented policy enforced query refmon function attack well-known attacks server rely ability client set properties windows belonging clients changing background content policy disallow client changing properties windows note policy enforced easily server operating system operating system understand server-specific details enforce policy clients communicate server protocol enforce policy operating system interpret protocol messages determine messages change properties windows hand policy easily enforced server setting window properties involves exercising window chprop security-sensitive operation enforcement call query refmon changeproperty function server mediates window chprop enforce policy check security-label subject requesting operation security-label window properties changed equal attack operating systems ensure file belonging top-secret user read unclassified user bell-lapadula policy top-secret unclassified users xterms open server cut operation xterm belonging top-secret user paste operation xterm unclassified user violates bell-lapadula policy policy ensure cut high-security client window pasted client windows equal higher security existing security mechanisms server security extension enforce policy securitylevels enforcement cut paste operations correspond security-sensitive operation window chselection server identifies fingerprints window chselection calls functions procsetselectionowner procconvertselection server turns responsible cut operation paste operation calls query refmon functions mediate cut paste operations created users machine security-labels top-secret confidential unclassified decreasing order security clients created users inherit security-labels successfully ensure cut operation high-security client window confidential result paste client windows equal higher security top-secret confidential performance retrofitted server measured runtime overhead imposed instrumentation running retrofitted server vanilla server perf benchmarks ran retrofitted server null policy authorization requests succeed measure overhead defined time retro itted servertime vanilla server overhead ranged benchmarks average overhead limitations techniques presented paper limitations fundamental artifacts current implementation analysis runtime traces ideally suited cases security-sensitive operation unique small number fingerprints observed typically case practice specifically server context previous study linux kernel potentially miss fingerprints paths exercised runtime traces analyzes research codecoverage metrics static fingerprint-finding algorithms needed address shortcoming techniques incapable analyzing obfuscated code identify individual code-patterns obfuscated code harder identify fingerprints multiple code-patterns identify patterns function addition identifying subjects objects modifying code insert instrumentation harder obfuscated code infrastructure built analyze source code analyze binary executables fundamental limitation analyzing executables requires key enhancements ability instrument executables fingerprint-finding trace reads writes key data structures discussed section adding monitor calls objectives achieved static binary rewriters dynamic rewriters dyninst ability express code-patterns terms abstract syntax trees executables code-patterns expressed terms abstract syntax trees source code level figure constraining analysis work source code related work techniques authorization policy enforcement monitors standard vehicle authorization policy enforcement historically policy enforcement performed operating system linux mechanisms enforce discretionary access control policies recent work selinux aims augment linux mechanisms enforce mandatory access control policies selinux architected lsm framework adds monitor loadable kernel module kernel module encapsulates policy enforced presents authorization hook interface hooks mediate security-sensitive locations kernel context lsm authorization hooks manually informal process process resulted vulnerabilities hook placement hook placement found violate complete mediation hook interface left room tocttou exploits shows automated techniques retrofit legacy code prior work evaluated static analysis techniques automate placement authorization hooks lsm implementation hook interface non-hook-placed version linux static analysis determine set hooks protect security-sensitive kernel locations work static analysis algorithm relied manually-written fingerprints called idioms identify security-sensitive kernel locations hook placement depended accuracy idioms addresses shortcoming providing tool-support write fingerprints java security mechanism conceptually similar lsm framework monitor implemented object type accesscontroller accesscontroller checkpermission calls manually inserted locations code enforce authorization policies techniques presented paper applicable secure legacy java applications selinux obtained retrofitting linux kernel efforts proactively construct secure operating systems asbestos incorporates mechanisms isolate user data effects exploits enforces security policies security-labels selinux languages techniques safety policy enforcement monitoring code retrofitting techniques enforce safety policies legacy code inlined monitors poet pslang toolkit naccio polymer frameworks enforce policies legacy code important difference work tools require codepatterns protected policy poet pslang framework requires names security-sensitive java methods mentioned policy work require code-patterns priori recover aspect-oriented programming aspect defined concern security error-handling crosscuts program aspect-oriented programming aop languages aspectj aspectc concerns developed independently advice aspectweaver merges advice program joinpoints weaver pointcuts pointcuts patterns serve succinctly identify set join-points weaver matches patterns program identify join-points techniques developed paper bear close resemblance aspect-oriented programming paradigm combination code-patterns fingerprint written language shown figure identifies locations server code monitor calls inserted fingerprint pointcut identifies security-sensitive locations join-points inserts monitor calls compiletime aspect-weaver code monitor authorization policy serve advice key issue aop identify join-points context problem identifying security-sensitive locations discussed assists task root-cause analysis root-cause analysis techniques developed primarily debugging typically good bad traces localize root-cause bug similar techniques classifies program traces classification find fingerprints security-sensitive operations primary difference techniques richer set labels arbitrary set securitysensitive operations good bad approach trace analysis primarily debugging dynamic slicing dynamic slicers dataflow analysis work backwards effect vulnerability program crash vulnerability interesting avenue future research adapt dynamic slicing work backwards effect security-sensitive operation tangible side-effect fingerprint operation security window systems server historically developed promote cooperation clients security isolation clients built design server protocol clients communicate server well-documented security flaws rich body work rectify situation identify security requirements create secure versions server work carried context compartmented mode workstation trusted projects built prototype windowing systems meet trusted computer system evaluation criteria efforts focus retrofitting server work building server-like window systems security proactively designed system security extension extends server enabling enforce authorization policies placing monitor calls locations server discussed paper knowledge calls manually techniques presented paper assisted effort 
security extension limited policies enforce statically partitions clients trusted untrusted enforces policies interactions classes clients clients securitylabels top-secret confidential unclassified connect server simultaneously security extension group category enforce policies clients category summary future work shown program analysis assist process retrofitting legacy code authorization policy enforcement prototype tools retrofitted server enforce authorization policies clients addition tools retrofit servers plan explore avenues research improve basic techniques presented paper identifying security-sensitive operations manual process plan develop tool-support assist task runtime analysis potentially miss fingerprints security-sensitive operations discussed earlier plan address exploring codecoverage static fingerprint-finding algorithms investigating monitor calls added running executables dyninst api plan extend techniques presented paper cases source code unavailable acknowledgments mihai christodorescu shaping message paper benefited insightful comments jon giffin boniface hicks louis kruger shai rubin hao wang anonymous reviewers members secure systems department ibm research hawthorne work initiated work supported part onr contracts agrawal horgan dynamic program slicing acm conference programming language design implementation june anderson computer security technology planning study volume technical report esd-tr- deputy command management systems hanscom field bedford october aspect-oriented software development http aosd net home aspectc http aspectc aspectj project http eclipse aspectj bauer ligatti walker composing security policies polymer acm conference programming language design implementation june bell lapadula secure computer system unified exposition multics interpretation technical report esd-tr- deputy command management systems hanscom field bedford march berger picciotto woodward cummings compartmented mode workstation prototype highlights ieee transactions software engineering june bishop digler checking race conditions file accesses computer systems spring brewer nash chinese wall security policy ieee symposium security privacy cleve zeller locating program failures international conference software engineering dyninst api http dyninst efstathopoulos krohn vandebogart frey ziegler kohler mazieres kaashoek morris labels event processes asbestos operating system acm symposium operating system principles october epstein mchugh orman pascale squires danner martin branstad benson rothnie high assurance window system prototype journal computer security epstein picciotto trusting issues building trusted window systems -orwhat trusted annual national computer security conference october epstein prototype trusted labeling policies annual computer security applications conference december erlingsson inlined monitor approach security policy enforcement phd thesis cornell january evans twyman flexible policy-directed code safety ieee symposium security privacy feske helmuth nitpicker guide minimalcomplexity secure gui annual computer security applications conference december ganapathy jaeger jha automatic placement authorization hooks linux security modules framework acm conference computer communications security november gong ellison inside javat platform security architecture api design implementation pearson education jaeger edwards zhang consistency analysis authorization hook placement linux security modules framework acm transactions information system security jim morrisett grossman hicks cheney wang cyclone safe dialect usenix annual technical conference june kiczales lamping mendhekar maeda lopes loingtier irwin aspect-oriented programming european conference object-oriented programming june kilpatrick salamon vance securing window system selinux technical report nai labs march korel rilling application dynamic slicing program debugging automated algorithmic debugging liblit cooperative bug isolation phd thesis california berkeley fall loscocco smalley integrating flexible support security policies linux operating system freenix track usenix annual technical conference june necula mcpeak rahul weimer cil intermediate language tools analysis transformation programs international conference compiler construction april http manju berkeley cil necula mcpeak weimer ccured typesafe retrofitting legacy code acm symposium principles programming languages january picciotto trusted cut paste window system annual computer security applications conference december saltzer schroeder protection information computer systems proceedings ieee september summary informal selinux meeting http selinux-symposium meeting php shapiro vanderburgh northup chizmadia design eros trusted window system usenix security symposium august smalley june personal communication tresys technology security-enhanced linux policy management framework http sepolicy-server sourceforge net wiggins analysis protocol security concerns draft consortium http docs xserver analysis pdf wiggins security extension specification version consortium wright cowan smalley morris kroahhartman linux security modules general security support linux kernel usenix security symposium august perf server performance test program suite server version foundation zeller isolating cause-effect chains computer programs acm symposium foundations software engineering november zhang edwards jaeger cqual static analysis authorization hook placement usenix security symposium august zhang gupta precise dynamic slicing algorithms international conference software engineering 
published proceedings acm conference computer communications security november automatic placement authorization hooks linux security modules framework vinod ganapathy wisconsin wisc trent jaeger pennsylvania state tjaeger cse psu somesh jha wisconsin jha wisc abstract present technique automatic placement authorization hooks apply linux security modules lsm framework lsm generic framework diverse authorization policies enforced linux kernel consists kernel module encapsulates authorization policy hooks kernel module locations linux kernel kernel enforces authorization policy hook calls current practice hooks manually kernel approach tedious prior work shown prone security holes technique static analysis linux kernel kernel module automate hook placement non-hookplaced version linux kernel kernel module implements authorization policy technique infers set operations authorized hook set operations performed function kernel information infer set hooks guard kernel function describe design implementation prototype tool called tahoe tool authorization hook placement technique demonstrate effectiveness tahoe lsm implementation security-enhanced linux selinux exposition paper focuses hook placement lsm technique place hooks lsm-like architectures categories subject descriptors operating systems security protection access controls general terms algorithms security keywords hook placement static analysis lsm selinux introduction linux security modules lsm framework generic framework diverse authorization policies enforced linux kernel goal ensure securitysensitive operations performed users authorized consists monitor encapsulates authorization policy enforced hooks define interface monitor presents calls supported onr contracts work trent jaeger ibm research permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee ccs november alexandria virginia usa copyright acm hooks locations linux kernel mediate security-sensitive operations performed kernel hook call results authorization query monitor kernel performs security-sensitive operation authorization query succeeds figure shows hook linux kernel lsm implementation security-enhanced linux selinux popular mandatory access control mac based authorization policy security-sensitive operation directory removal accomplished function call diri oprmdir line hook line selinux inode rmdir checks process requests directory removal authorized selinux policy directory removal succeeds hook call succeeds case returning observe crucial hook line absence hook directory removal succeed processes authorized selinux policy int vfs rmdir struct inode dir struct dentry dentry err selinux inode rmdir dir dentry err diri oprmdir dir dentry figure hook linux kernel lsm implementation selinux architecture lsm ensures clean separation kernel policy-specific monitor code implemented loadable kernel module offers advantage modular extensible enforce security policy developer writes monitor ensures hooks properly kernel finally monitors implementing policies co-exist kernel kernel enforces security policy loading kernel module implements monitor features lead lsm vehicle-of-choice implementation popular mac-based authorization policies selinux domain type enforcement incorporated mainstream linux kernel version onwards emerging interest enable lsm-like monitoring user-level applications reason applications windows web-servers databaseservers support multiple users time code fragment shown figure atomic code invokes vfs rmdir obtains semaphore prevents processes modifying resources pointed dir dentry ensures security-sensitive operation diri oprmdir performed resources authorized selinux inode rmdir published proceedings acm conference computer communications security november server multiple users possibly securitylevels display clients simultaneously hooks operating system insufficient enforce authorization policies application-level policy cut-andpaste operation high-security client low-security client disallowed enforced server operating system operating system unaware cut-andpaste operation specific windows fact efforts underway secure windows placing hooks lsmlike monitor server recent release policy management infrastructure user-level processes intended enable development monitors application benefit note java security architecture akin lsm calls check access permissions security-sensitive objects enforcement authorization policies placing monitor hooks userlevel applications common practice current practice decision place hooks made informally hooks manually locations deemed linux kernel user-level application process suffers drawbacks inadvertent bugs leading security holes prior research shown security holes due improper hook placement linux kernel zhang demonstrate inadequate placement hooks results security-sensitive operations performed authorization query posed monitor jaeger demonstrate similar bugs comparing consistency hook placements paths kernel bugs lead potentially exploitable security holes inextensibility security policies manual reasoning needed place hooks security policy developed linuxkernel ameliorates effort needed placing hooks dummy monitor pre-defined locations kernel idea developers tailor code hooks suit specific security policies approach problematic care required ensure hook call authorizes security-sensitive operations pre-defined placement intends fairly common practice add hooks implement security policies pre-defined hook placement suffice manual reasoning required determine placement points hook inextensibility emerging applications mentioned earlier recent proposals developing mac authorization policies user-level applications based lsm-like architectures lsm proposals require manual effort determine hook placement static runtime verification techniques proposed solve problem mentioned solve problems paper demonstrate technique automatic placement authorization hooks hooks monitor encapsulates authorization policy exposition evaluation paper restricted placement lsm authorization hooks kernel concepts present extend naturally system monitor pair conforms lsm-like architecture technique requires inputs linux kernel monitor kernel module implements source code authorization hooks analyzes identifies locations kernel hooks security-sensitive operations authorized correctly key idea technique leverage semantic information embedded source code hooks linux kernel static analysis determine set operations authorized hook similar analysis kernel-side determines set operations performed kernel function results hook analysis kernel analysis merged construct authorization graph authorization graph relates kernel function set hooks protect authorization graph hand hook placement straightforward location kernel kernel function called insert hooks determined authorization graph protect function technique addresses problems discussed set operations performed kernel function obtain set hooks guard ensure correctness construction analysis general-purpose analyzes hook kernel code extends easily security policies emerging applications alike contributions summary main contribution paper technique automatic placement authorization hooks linux kernel present design implementation prototype tool called tahoe technique demonstrate efficacy technique tahoe implementation hooks lsm implementation selinux show tahoe precisely recovers set operations authorized hook implementation set operations authorized linux kernel information place hooks linux kernel constructing authorization graph evaluate hook placement tahoe generates comparing existing hook placement lsm implementation selinux paper organization section introduce concepts paper present algorithms tahoe section discuss experience tahoe section review related research section conclude section conceptual operations goal lsm framework ensure security-sensitive operations resources performed entities authorized achieves placing hooks pose authorization queries monitor kernel functions perform security-sensitive operations instance figure security sensitive operation authorized directory removal resources affected operation inodes directory removed directory removed tahoe seeks place hooks works source code kernel module source code 
authorization hooks kernel module implementing selinux hooks non-hook-placed version kernel discussed earlier tahoe analyzes inputs independently correlates results determine hook placement observe securitysensitive operations unifying theme inputs hook authorizes security-sensitive operations kernel performs combine results hook analysis kernel analysis suffices determine security-sensitive operations authorized hook security-sensitive operations performed kernel function term conceptual operations refer security-sensitive operations analyses rest paper assume set conceptual operations analyses set conceptual operations lsm implementations popular mac policies including selinux domain type enforcement set size fairly published proceedings acm conference computer communications security november comprehensive includes generic operations resources reading writing executing file expect set find analysis lsm-like architectures conceptual operations depicted rest paper suggestive names file write file read file execute writing reading executing file note analyses tahoe parameterized set conceptual operations conceptual operations added arises set conceptual operations change algorithms present paper authorization hook placement static analysis figure shows architecture tahoe analyzes source code linux kernel hooks kernel module source code hooks outputs hook-placed kernel combines results hook analysis kernel analysis produce authorization graph relates kernel function set hooks guard kernel function guarded set hooks authorize conceptual operations performs ops authorizedby hook ops performed byeach kernel function hookanalysis joinalgorithm hook placerauthorization graphhook placedkernel source code ofauthorization hooks kernelanalysis linux kernel hooks tahoe figure architecture tahoe demonstrates tahoe analysis figure shows snippet kernel code vfs rmdir virtual file system function remove directory function accepts arguments data structures directory deleted dentry parent directory dir transitively calls permission performs discretionary access control dac check line determine current process write execute permissions parent directory control reaches line resolves physical file system call ext rmdir remove directory figure shows portion output vfs rmdir tahoe kernel module lsm implementation selinux henceforth abbreviated lsm-selinux determines call diri oprmdir line protected lsm-selinux hooks selinux inode rmdir andselinux inode permission called write dac check line supplemented hook selinux inode permission checks mac permissions provide high-level description analysis tahoe employs tahoe kernel analysis section analyzes file system code infers directory removal diri oprmdir line involves performing conceptual operations dir rmdir dir write dir search intuitively typical file system ext remove directory bar directory foo finds entry bar kernel data structure foo dir search removes entry bar data structure dir rmdir involves writing data structure dir write note directory removal specialized write removal bar foo requires removal entry bar foo opposed directory manipulations directory creation adds entry dir rmdir denotes special kind directory write opposed dir write denotes generic write operation int permission struct inode inode int mask inodei oppermission inode mask int delete struct inode dir struct dentry vic int isdir dac check write exec permission dir write exec int vfs rmdir struct inode dir struct dentry dentry delete dir dentry remove directory diri oprmdir dir dentry vfs code linuxfs namei directory removal error checking code omitted brevity hooks inodei oppermission line selinux inode permission dir mask hooks diri oprmdir line selinux inode rmdir dir dentry selinux inode permission dir write analysis results tahoe selinux hooks code fragment shown figure illustrate analysis performed tahoe tahoe hook analysis section analyzes source code selinux hooks shown figure infers hook selinux inode permission invoked exec write checks conceptual operations dir search dir write authorized infers selinux inode rmdir checks conceptual operations dir search dir rmdir authorized tahoe combines results analyses section produces authorization graph portion shown figure diri oprmdir performs dir search dir rmdir protected selinux inode rmdir authorizes operations addition diri oprmdir performs dir write selinux inode permission authorizes invoked write tahoe supplements existing dac checks line hooks perform mac checks shown line output important note tahoe existing dac checks determine hook placement analysis based conceptual operations performed kernel function hooks lsm-selinux shown figure case lsm-selinux placement determined manually validates results tahoe analysis hook placement lsm-selinux tested errors found verification tools fixed case vfs rmdir lsm-selinux optimizes hook placement closer source code vfs rmdir reveals code paths line pass line line formally line line dominate line hook call line subsumed published proceedings acm conference computer communications security november hook call line lsm-selinux places hooks shown line line tahoe infers authorization graph relates hooks kernel functions correctly optimize hook placement leave optimization future work note security lsm framework determined correctness authorization graph rest section describes tahoe components greater detail analysis authorization hooks determine conceptual operations authorized hook tahoe analyzes kernel module source code hooks addition determining conceptual operations authorized determines conditions operations authorized figure shows snippet implementation hook selinux inode permission lsm-selinux kernel module snippet authorizes searching writing reading inode representing directory based mask authorization performed call inode perm authorizes conceptual operation inode based access vector invoked figure access vector obtained call file mask int selinux inode permission struct inode int mask mask return return inode perm file mask inodei mode mask access vector file mask int mode int mask access vector mode ifmt ifdir file-related conceptual operations mask exec dir search mask write dir write mask read dir read return code hook selinux inode permission analysis output algorithm selinux inode permission mask negationslash inode isdir mask exec bardbl dir search mask negationslash inode isdir mask write bardbl dir write mask negationslash inode isdir mask read bardbl dir read inode isdir denotes inodei mode ifmt ifdir portion output tahoe hook analysis selinux inode permission figure illustrate tahoe hook analysis figure shows fragment output tahoe analysis hook line output tuple form predicate bardbl operation predicate formal parameters hook tuple interpreted hook invoked context predicate holds checks conceptual operation operation authorized case tahoe infers inodes represent directories inodes inodei mode ifmt ifdir hook selinux inode permission checks conceptual operations dir search dir write dir read authorized based mask describe hook analysis algorithm tahoe conceptual operations lsm-selinux represented bit-vectors called access vectors derived set conceptual operations tahoe examining lsm implementations popular mac policies including lsm-selinux one-to-one mapping conceptual operations tahoe access vectors lsm-selinux hook analysis algorithm algorithm analyze kernel module source code hooks shown algorithm ease explanation assume recursion explain deal recursion section analysis proceeds constructing call-graph kernel module call-graph captures caller-callee relationships node call-graph function kernel module edge drawn 
automatic discovery api-level exploits vinod ganapathy sanjit seshia somesh jha thomas reps randal bryant computer sciences department school computer science wisconsin-madison carnegie mellon madison wipittsburgh pavg jha reps wisc sanjit bryant cmu abstract argue finding vulnerabilities software components finding exploits exploits compromise security low-level details component layouts stack frames existing software analysis tools effective identifying vulnerabilities fail model low-level details unsuitable exploit-finding study issues involved exploit-finding application programming interface api level exploits software component vulnerable api-level exploit security compromised invoking sequence api operations allowed component present framework model low-level details apis develop automatic technique based bounded infinite-state model checking discover api-level exploits present instantiations framework show format-string exploits modeled api-level exploits demonstrate technique finding exploits vulnerabilities widely-used software framework model cryptographic-key management api ibm cca demonstrate tool identifies previously exploit categories subject descriptors software engineering software program verification general terms algorithms security verification keywords api-level exploit bounded model checking introduction vulnerability software component error implementation possibly alter intended behavior component exploit sequence operations attacks vulnerability typically malicious intent devastating consequences recent years witnessed sharp increase number security exploits tricky craft low-level details program execution instance typical exploit buffer-overrun vulnerability details layout stack constraints buffer sizes architecture machine supported onr contracts aro grant daad permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee icse louis missouri usa copyright acm growing concern security important find exploits controlled environment found attackers analysis tool finds security exploit potential vulnerability component concrete evidence vulnerability exists analyst insight consequences instance static analyzers boon percent-s benefit analysis finds exploits vulnerabilities identify tools produce false positives imprecision analysis process classifying warnings real vulnerabilities false positives typically manual security exploit generated vulnerability identified tools offers benefits evidence threat posed vulnerability real exploit test case stress resilience patched versions component finally cases analysis fails produce security exploit vulnerability automatically classified false positive reducing manual effort involved classifying warnings current tools adequately address problem finding security exploits software tools based model checking proved effective finding control-flow-intensive vulnerabilities tools finite-state abstractions abstract details layout program stack heap interest keeping analysis tractable details important produce security exploits result counter-examples produced tools lack detail generate security exploits similarly type-based analysis tools constraint-based analysis tools track actual values program variables result tools effective localizing vulnerabilities effective generating exploits paper study issues involved exploit-finding api-level security exploits component vulnerable api-level exploit security compromised invoking allowed sequence operations api instance sequence seteuid execl allowed unix obtain root privileges make contributions present formal framework capture low-level details api operations key idea abstract details produce model mimics concrete system closely resulting model typically infinitestate analyzed model checking determine state violates property reachable counterexample produced translated exploit instantiation framework real-world apis significant complexity present analyze printf-family format-string exploits apilevel exploits interpreting format-string sequence api operations reasoning api critically depends modeling runtime execution stack application precisely formal framework model api demonstrate tool discover format-string exploits tool generate exploits vulnerabilities real-world software packages technique analyze subset ibm common cryptographic architecture cca api cryptographic key management api case crucial model attacker enhance knowledge operations api tool based technique discovered previously exploit technique models data precisely existing tools demonstrate presence vulnerability producing security exploit lowlevel details system demonstrate showing technique find exploits vulnerabilities identified percent-s format-string vulnerabilityfinding tool discussed earlier demonstrate finding exploits benefit vulnerability-finding tools automatically classifying vulnerabilities real threats false positives rest paper organized present overview technique section present formal framework section apply analyze printf section ibm cca api section discuss related work section conclude section overview technique section describe toy protection system harrison framework apis technique check specification section printffamily format-string attacks shows framework checker generate security exploits low-level details organization program runtime stack protection system defined finite set rights commands state triple set subjects set objects access matrix row subject column object presented harrison subject object entry access matrix set rights subject object restrict rights read write natural meanings api step analysis involves api formal framework safety property checked framework ingredients set variables describe state component implements api initial state component set api operations semantics operations terms change state component representation set sequences api operations checked fourth component helps encode restrictions ordering api commands restrictions exclude sequences api commands inconsequential analyzing system arise execution system environment system operates generates sequence api calls set sequences forms regular language component expressed finite-state automaton discussed earlier state protection system triple initial state protection system initial values assume read write words rights rights commands presented protection system define api command state protection system restrict types commands shown semantics create adds creates column enters conferread enters read conferwrite analogous conferread assume protection system operations applied order assume check protection system obeys security policy subject read write object checking api explained earlier discover security exploits important work concrete system checking finite-state abstraction results loss low-level details required craft security exploit result finding securityexploit corresponds checking infinite-state system purpose bounded model checking overview technique shown figure safetycondition apispecificationinteger bound counter violation safety model checkerbounded increase bound iterateno violation figure schematic overview method model checker accepts description api framework safety property integer bound systematically explores allowed sequences api operations shorter length integer bound determines trace satisfies safety condition model checker finds violation safety policy terminates trace api operations demonstrates vulnerability instance bound discovers api-level vulnerability protection system create file conferread file conferwrite file sequence api operations adds file read file write add file violates safety condition file read write model checker terminates counter-example increase bound iterate section note undecidable check arbitrary system vulnerable apilevel exploits general iterative process forever procedure sound incomplete vulnerabilities found exploitable model discover vulnerabilities cases including study section derive values bound procedure complete formal framework present formal framework model analyze apis api interface component system analyzed presents client modules command api state component predefined state transformer sequence api operations defines state transformer obtained composing state transformers individual api operations focus sequences api operations affect security underlying component formally 
function calls function call-graph processed bottom-up starting leaves proceeding upwards node call-graph produces summary outputs summaries hooks algorithm analyze module input module source code hooks set names hooks output set predicate bardbl conceptual-op denoting conceptual operations authorized hook conditions authorized construct call-graph module list vertices reverse topologically sorted foreach summary analyze function entrypoint true foreach output summary algorithm tahoe algorithm hook analysis summary construction algorithm summary function set pairs pred bardbl denoting condition pred conceptual operation authorized analysis algorithm flowand contextsensitive respects control-flow function precisely models call-return semantics intuitively summary construction function proceeds propagating predicate statements statement predicate denotes condition control-flow reaches statement analysis begins statement function denoted entrypoint predicate set true ifq -then-else statement true branch analyzed predicate false branch analyzed predicate instance line figure true lines analyzed true mode ifmt ifdir call call function summary specialized calling-context note order functions processed algorithm summary computed processed summary set tuples bardbl opi summaries computed formal parameters predicate specialize summary actual parameters substituted place formal parameters resulting predicate combined entry bardbl opi included summary intuitively authorizes operation opi predicate satisfied substituting actual parameters place formal parameters determine call authorizes operation opi predicate specialized calling context satisfiable call reached condition operation authorized satisfiable statements analysis determines statement potentially authorizes operation determining statement authorizes operation specific conceptual operations represented kernel module instance lsm-selinux conceptual operations denoted bit-vectors called access vectors type access vector one-to-one mapping access vectors conceppublished proceedings acm conference computer communications security november algorithm analyze function input function statement start analysis iii boolean predicate output set predicate bardbl conceptual-op switch type-of case thenbtrue elsebfalse analyze function entrypoint btrue analyze function entrypoint bfalse case callg summary foreach bardbl opi specialized bardbl opi analyze function controlflowsucc authorizes conceptual operation bardbl update appropriately analyze function controlflowsucc foreach bardbl existentially quantify-out local variables appearing return algorithm producing summary function tual operations lsm-selinux occurrence access vector reading statement determine statement authorizes conceptual operation predicate updated appropriately based action statement instance statement question predicate propagated statement predicate updated cases effect determined set unknown special denoting determined precisely functions formal parameter typeaccess vector refer access vector dir read dir write dir search analysis returns true bardbl shown algorithm brevity function potentially authorizes conceptual operation based access vector invoked variable denotes access vector processing statement analysis continues processing control-flow-successors analysis terminates statements reachable entrypoint analyzed analysis tractable algorithm analyzes loop bodies ignores back-edges loops result loops treated conceptually equivalent if-then-else statements finally local variables appearing predicates bardbl summary quantified-out result predicates appearing summary formal parameters illustrate algorithm figure function file mask algorithm returns output mode isdir mask exec bardbl dir search mode isdir mask write bardbl dir write mode isdir mask read bardbl dir read mode isdir denotes mode ifmt ifdir observe summary formal parameters file mask summary specialized call line formal parameters replaced actual parameters mode inodei mode specializing summary call-site producing inode isdir mask exec bardbl dir search inode isdir mask write bardbl dir write inode isdir mask read bardbl dir read inode isdir denotes inodei mode ifmt ifdir forinode perm algorithm returns true bardbl intuitively means function authorizes conceptual operation based access vector passed call inode perm specialized call line summary obtained shown line selinux inode permission reached mask negationslash predicate combined predicates summary function inode perm produce result shown figure handling recursion recursion kernel module introduces strongly-connected components call-graph note algorithm requires call-graph directed acyclic graph dag handle recursion functions stronglyconnected component produce consolidated summary strongly-connected component intuitively summary set conceptual operations conditions potentially authorized function strongly-connected component called observe handling recursion requires small change lines algorithm recursion summary function called function longer line case skip forward line precision hook analysis observe algorithm analyzes reachable statements function function authorizes operation bardbl summary predicate approximations employed algorithm algorithm analysis tractable predicate accurately describe condition authorized kernel module recursion-free functions loop-free updates predicates determined precisely predicates set unknown algorithm propagates predicates precisely predicate statement reached condition algorithm ignores back-edges loops loop bodies analyzed predicates retrieved imprecise similarly algorithm employs heuristic handle recursion predicates retrieved imprecise predicates hook placement determine arguments hook invoked imprecision results analysis manual intervention determine hooks invoked fortunately code hooks complex kernel modules lsm-selinux simple retrieve conditions precisely cases instance loops hooks lsm-selinux analyzed analysis linux kernel tahoe kernel analysis complements hook analysis determining set conceptual operations performed function kernel instance tahoe kernel analysis infers vfs rmdir virtual file system function directory removal figure performs conceptual operations dir rmdir dir search dir write removing searching writing directory observe line vfs rmdir call function pointer targets physical file system-specific functions directory removal ext rmdir ext file system figure shows portion call-graph ext rmdir note functions shown call-graph ext unlink published proceedings acm conference computer communications security november ext dec count called functions kernel edges shown figure request received remove directory bar directory foo ext rmdir checks bar empty call ext rmdir empty shown figure calls ext unlink modifies ext -specific data structures removes entry bar inode foo finally calls ext dec count decrement field nlink inodes foo bar figure shows relevant snippet tahoe analysis linux kernel infers ext rmdir performs conceptual operations dir rmdir dir search dir write ext rmdir pointed diri oprmdir determined pointer analysis algorithms employed cil tool tahoe built called indirectly vfs rmdir tahoe infers vfs rmdir performs conceptual operations examine analysis detail mapping inode mapping page mapping ops prepare write inode size inode nlink ext rmdir inode dentry ext unlink inode dentry ext find entry inode dentry page ext delete entry inode page ext page inode ext dec count inode portion call-graph linux kernel showing ext rmdir relevant code snippets function shown boxes ext delete entry dir write ext page dir search ext find entry dir search ext dec count file unlink ext unlink file unlink dir write dir search ext rmdir dir rmdir dir write dir search portion kernel analysis results relevant figure illustrate tahoe kernel analysis kernel analysis algorithm hook analysis tahoe kernel analysis recovers set conceptual operations performed kernel function unlike hook analysis recover conditions conceptual operation performed 
hooks including selinux inode permission figure authorize conceptual operations based arguments invoked conditions recovered hook analysis infer arguments hook placement hand kernel functions infer exist arguments kernel function performs conceptual operation instance suppose ext rmdir invoked response request remove directory bar directory foo mentioned earlier ext rmdir checks bar empty directory removal fails bar removed important note bar empty conditions satisfied removed exists argument ext rmdir performs conceptual operations shown figure suffices recover conceptual operations performed kernel function irrespective conditions performed kernel analysis algorithm shown algorithm processes call-graph kernel bottom-up fashion analyzing function callees analyzed recursion leads strongly-connected components call-graph dealt consolidating results strongly-connected component section hook analysis algorithm analyze kernel input linux kernel output function kernel set operations perform construct call-graph kernel list vertices reverse topologically sorted foreach analyze kernel function foreach calls codepatterns codepatterns ops search idioms section kernelsummary ops algorithm tahoe algorithm kernel analysis informally algorithm searches combinations code patterns kernel function searches set idioms line code-patterns determine function performs conceptual operation idiom rule relates combination code-patterns conceptual operations intuitively code-patterns correspond manipulations kernel data structures typically happen conceptual operation performed kernel instance removal directory bar foo conceptual operation dir rmdir involves setting field size inode bar decrementing field nlinks inodes bar foo similarly reading directory conceptual operation dir read involves modifying access time field atime inode describe expressive power methodology write idioms section algorithm analyze kernel function input kernel function output set code patterns foreach statement matches entry idiomcodepatterns return algorithm searching code patterns idioms algorithm gathers set code patterns body callees code patterns gathered algorithm scans code kernel function searches code-patterns set idiomcodepatterns set code-patterns idioms tahoe algorithm searches set idioms line determine set operations potentially performed kernel function instance figure lines inodei size inodei nlink-appear functions ext rmdir ext dec count figure shows idioms tahoe dir rmdir -setinodei size decr inodei nlink code patterns set codepatterns ext rmdir line algorithm ext rmdir processed patterns idiom operation dir rmdir added set ops line kernelsummary ext rmdir denotes set conceptual operations performed ext rmdir observe code patterns idiom drawn functions common tasks kernel delegated helper functions published proceedings acm conference computer communications security november idioms tahoe code patterns drawn functions instance inodei size appears ext rmdir decrementing inodei nlink delegated ext dec count important search set idioms code patterns gathered callees function analyzed algorithm scans code function flow-insensitive fashion control-flow scanning statements function suffices kernel analysis mentioned earlier analysis track conditions operation performed returns set conceptual operations performed kernel occurrence idiom function body determine operation performed kernel achieved simple flow-insensitive scan function body idioms idioms rules conceptual operations left-handside conjunctions code-patterns right-hand-side conceptual operation left-hand-side rules figure shows grammar express idioms tahoe kinds code-patterns found sufficient express idioms conceptual operations code-patterns expressed terms abstract-syntaxtree ast variable variable names figure shows idioms relevant figure idiom -vni codepati codepati codepat set ast set ast read ast call ast incr ast decr ast ast typefieldname idiom grammar dir write set inodei ctimev call address space opsprepare write dir search read inodei mapping file unlink decr inodei nlinkv set inodei size dir rmdir set inodei size decr inodei nlink examples idioms analysis ext rmdir figure idiom grammar examples idioms idioms idioms determine conceptual operations performed kernel function set code-patterns appears function callees gathered codepatterns line algorithm search idioms searches set idioms code-patterns right-hand-side idiom codepatterns search idioms adds left-hand-side idiom set conceptual operations performed instance codepatterns ext unlink decr inodeunlink matches idiom figure file unlink added kernelsummary ext unlink note codepatterns ext rmdir pattern set inodei size match idiom file unlink kernelsummary ext rmdir methodology write idioms explain methodology write idioms examples figure examples idioms found dir write set inodei ctime call address space opsprepare write writing directory involves statement adds content data structures store directory content achieved call prepare write setting field ctime directory inode indicating change time dir rmdir set inodei size decr inodei nlink removing directory bar directory foo involves decrementing field nlink link count inodes foo bar setting size size inode bar figure writing idioms writing idioms iterative manual procedure conceptual operation knowledge kernel reason sequence steps kernel perform information extracted code-patterns shown examples unfamiliar sequence steps kernel considered examples functions kernel perform conceptual operation examples formulate idioms figure illustrates general methodology write idioms goal find code-patterns cover set functions perform depicted box code-patterns approximate set figure shows sets functions distinct code patterns guessed code-patterns knowledge kernel manually refined patterns combining code patterns conjunction removing existing code patterns reduce false positives false negatives false positives denote functions code-patterns guessed perform identified obtaining set functions code-patterns automatically algorithm manually inspecting operations performed function set false negatives denote functions perform code-patterns guessed harder identify knowledge kernel identify missing entries set functions covered code-patterns added patterns required tahoe idioms representing rules conceptual operations related file systems networking week write idioms idioms work section shorter amount time experienced kernel developers formulate idioms argue section idioms reusable writing one-time activity expressive power mentioned earlier code-patterns idioms drawn functions idioms interprocedural analysis analyze kernel determine kernel function performs operation express temporal properties enforce order code patterns instance ext rmdir checks directory empty removing temporal property expressed idioms follow grammar figure temporal properties strictly richer express grammar figure express idioms conceptual operations grammar note interprocedural analysis checks temporal properties computationally expenpublished proceedings acm conference computer communications security november sive significant engineering tricks employed mops employed analysis scale hand algorithm works time proportional size linux kernel number functions kernel denotes number idioms checked linear number idioms checked precision kernel analysis algorithm algorithm search statement kernel code-patterns analysis precise sense code-patterns right-hand-side idiom function conceptual operation lefthand-side added kernelsummary precision kernel analysis depends quality idioms mentioned earlier idioms refined iteratively remove false positives false negatives refinement improves precision kernel analysis discussion glance tahoe simply shifts burden placing hooks writing idioms conceptual operations case argue idiom writing requires knowledge kernel demonstrated section writing idioms requires understanding kernel performs conceptual operation kernel analysis independent hook analysis writing idioms require understanding policy-specific code written kernel modules lsmselinux stark 
contrast current practice manual hook placement requires understanding conceptual operations performed kernel function operations authorized hook idiom writing one-time activity idioms written version kernel addition kernel analysis one-time activity results kernel analysis combined results hook analysis mac policies conjecture idioms change versions kernel require incremental updates kernel evolves reason belief kernel performs conceptual operations standard ways instance unlinking inode typically involves decrementing link count link standard versions kernel kernel radically restructured set idioms remain stable idiom refinement improve analysis quality finally iteratively refining idioms identifying false positives false negatives formal systematic improve quality kernel analysis unaware systematic techniques refinement manual hook placement combining results hook kernel analysis results hook analysis kernel analysis hand tahoe obtains set hooks guard kernel function recall output hook analysis set phi bardbl ophi hook output kernel analysis set opki kernel function finding set hooks guard reduces finding cover set output hook analysis predicates output hook analysis determine arguments passed hook giving formal description illustrate algorithm running kernel analysis infers kernelsummary ext rmdir dir rmdir dir write dir search analysis hooks infers summary selinux inode rmdir true bardbl dir rmdir true bardbl dir search summary selinux inode permission shown figure relevant portions summaries shown operations authorized hooks cover set kernelsummary ext rmdir hooks chosen authorize ext rmdir hook selinux inode rmdir unconditionally checks operations dir rmdir dir search authorized called relevant variables scope locations ext rmdir called instance vfs rmdir hookselinux inode permissionchecks operation dir write authorized invoked mask negationslash inodei mode ifmt ifdir mask write true invoked mask write shown problem finding set hooks guard kernel function reduces find set cover set operations performed kernel function well-known np-complete problem employ simple greedy heuristic find set cover based number operations common hook kernel function number hooks applicable kernel function fortunately small brute-force search employed find set covers demonstrates predicates obtained hook analysis determine hook called formally satisfying assignment predicate determines arguments hook called manually obtain satisfying assignments current implementation tahoe process easily automated querying simple theorem-prover simplify satisfying assignments predicates term authorization graph refer relationship obtained analysis discussed structure undirected bipartite graph authorization relationship discovered forms edges bipartite graph nodes correspond hooks kernel functions algorithm find controlled kernel functions input call-graph linux kernel authorization graph output set controlled kernel functions foreach foreach roots hooksag set hooks protect path hooksag hooksag hooksag negationslash hooksag child ckf ckf return ckf algorithm finding controlled kernel functions authorization graph relates kernel function set hooks protect practice hooks protect small set kernel functions call controlled kernel functions idea protecting functions protects security sensitive operations performed kernel tahoe call-graph kernel authorization graph find controlled kernel functions algorithm describes heuristic employed find controlled kernel functions basic intuition algorithm place hooks close functions perform security sensitive operations instance analysis infers sys rmdir directory removal formally kernelsummary sys rmdir dir rmdir dir write dir search directory republished proceedings acm conference computer communications security november moval performed ext rmdir transitively called sys rmdir formally kernelsummary sys rmdir kernelsummary ext rmdir ext rmdir deepest function call-graph reachable sys rmdir property analysis infers ext rmdir controlled kernel function similarly ext unlink deepest function call graph kernelsummary ext unlink kernelsummary sys unlink controlled kernel function hook placement hook placement authorization graph straightforward location kernel controlled kernel function called tahoe places hooks determined authorization graph tahoe optimize hook placement shown section future plan extend implementation optimize hook placement implementation experience tahoe implemented plugin cil toolkit consists lines objective caml code section discuss precision tahoe analysis performance experience tahoe precision hook placement methodology evaluate effectiveness tahoe hook placement linuxkernel hooks lsm-selinux hooks locations kernel version kernel hooks lsm-selinux allowing objectively evaluate results tahoe written idioms conceptual operations representing file socket operations numbering idioms evaluated precision tahoe placing hooks hook manually compare placement lsm-selinux placement suggested tahoe hook placement lsm-selinux extensively verified bug-free good benchmark compare effectiveness tahoe report metrics false negatives false positives discussed false negatives hook lsm-selinux tahoe classifies false negative false negative output tahoe corresponds missing hook results insufficient authorization leading potential security hole tahoe analyzes subset file hooks hooks lsm-selinux kernel module section details hooks analyzed authorize variety conceptual operations files inodes lsm-selinux places hooks locations kernel tahoe obtaining hook placement output missing hooks fell categories discussed hook selinux file receive kernel function scm detach fds lsm-selinux missing output tahoe found reason kernel analysis missing idiom conceptual operations file read file write file append false negative eliminated adding idioms operations hook selinux file set fowner kernel functions missing output found hook analyzed properly tahoe hook updates data structure internal lsm-selinux access vectors result analysis section determined hook analyze operations leading false negatives false negatives category num locs false pos false neg file hooks socket hooks figure comparison tahoe output lsm-selinux false positives count locations tahoe places extra hook false negatives count locations missing hooks easily eliminated update data structure conceptual operation adding idioms kernel analysis hookselinux inode revalidate kernel function revalidate missing output closer investigation found false negative lsm-selinux authorization query posed hook succeeds result tahoe infers operations authorized hook shows semantic information contained hooks valuable determining hook placement tahoe analyzes socket hooks locations kernel lsm-selinux identified hook placements false negatives false positives output tahoe hooks lsm-selinux arise reasons imprecision analysis instance kernel analysis infers kernel function performs controlled operations unoptimized hook placement instance discussed section selinux inode permission redundantly classify hooks category false positives result extra authorizations performed false positives lead security holes result entities requisite permissions denied authorization desirable low false positive rate found tahoe false positives locations lsm-selinux file hooks locations socket hooks lsmselinux case extra hook addition required hook observed imprecision imprecision idioms employed kernel analysis functions wrongly classified performing conceptual operations file read dir read file execute dir search expect refinement idioms reduce number false positives effectiveness finding controlled kernel functions discussion evaluated tahoe hook placement controlled kernel functions defined lsm-selinux hook placements tahoe infers controlled kernel functions heuristic algorithm found controlled kernel functions identified tahoe placing file socket hooks identified lsmselinux case tahoe identified open namei controlled kernel function performed controlled operations 
component defined init denotes finite set variables possibly infinite domain values vector vectorx state component note vectorx init bool predicate characterizes initial states component state vectorx init vectorx holds initial state component denotes finite set api operations opm operation opi input parameters denoted vector vectorai domain opi defines family relations opi vectorai semantics opi vectorai predicates define preand post-conditions prei vectorai bool posti vectorai bool opi vectorai vectorx vectory prei vectorai vectorx posti vectorai vectorx vectory vectorx vectory denote state application opi vectorai prei vectorai vectorx hold opi vectorai aborts language api operations plays roles encodes temporal restrictions api operations inherent implementation component monitor formalizes notion usage patterns api operation sequences invoked client instance suppose api question set system calls supported operating system verify application system calls conforms safety property launch api-level exploit operating system sequences system calls sufficient restrict attention call sequences generated application formally viewed intersection languages api operations plays role plays two-fold conceptually similar optimistic approach interface design language recognizer machine accepts string api operations determines member general recognizer exist restrict cases recognizer exists instance regular context-free case study section special case framework presented regular language recognizer finite-state machine called api-automaton addition predicate bad bool defines set error states state vectorx bad vectorx holds state component enter bad defined based security properties required verifying enters state satisfyingbad restrict attention sequences api operations avoids wasteful exploration state space verification reduces false alarms formally check notion api-safety definition api-safety predicate bad component safe respect vectorx satisfying assignment formula finite opi opi opik vectora vectora vectorak init vectorx opi opi opik opi vectora opi vectora opik vectorak vectorx vectory bad vectory denotes concatenation denotes relational composition vectorx vectorz vectory vectorx vectory vectory vectorz api-level exploit component defined sequence api operations opi opi opik opi opi opik violates api-safety ofs predicatebad surprisingly arbitrary component predicate bad checking safe respect state vectorx undecidable proof undecidability easily similar theorem protection systems approach api-safety problem based bounded infinite-state model checking restrict attention sequences api operations construct product language recognizer api-automaton infinitestate system defined init safety property bad checked resulting infinite-state system stot bounded model checking bounded model checker explores api operation sequences length integer bound stot checking state reached sequence bad satisfied generates concrete error trace sequence states leading error state variable domain exploit extracted concrete error trace recent advances sat solving made bounded model checking practical analyzing finite-state systems led development efficient sat-based decision procedures expressive decidable first-order logics turn fueled progress infinite-state bounded model checking key reason technique illustrative illustrate concepts developed protection system section recall initially subjects objects framework init note variables set-valued matrix viewed set triples denotes init read write create conferread conferwrite predicate pre create asserts entry exist post asserts entry created predicate pre conferread asserts post asserts read predicates conferwrite similar interleavings api operations permitted verify subject read write object predicate bad read write apiautomaton single-state finite-state machine transitions api operations bounded model checking case equivalent unrolling apiautomaton finite number times checking property holds presented bound bounded model checker discovers exploit create conferread conferwrite format-string vulnerabilities format-string vulnerabilities dangerous class bugs attacker execute arbitrary code victim machine printf variable-argument function treats argument format-string restrict discussion printf concepts discussed apply printf-family functions syslog sprintf format-string conversion specifications instructions types call printf expects arguments instructions format output instance conversion specification instructs printf pointer char argument print location string arg conversion specifiers statements printf arg printf arg effect printf arg application user control passed arg application susceptible format-string vulnerability fix vulnerabilities source-to-source transformation replaces occurrences ofprintf arg withprintf arg instance source code application application generates format-strings dynamically shankar built tool percent-s analyze source code identify tainted format-strings controlled attacker potentially vulnerable printf locations identified binary executables aforementioned techniques produce format-strings exploit vulnerabilities identify present analyze understand printffamily format-string vulnerabilities format-string viewed sequence commands instructs printf types arguments application runtime stack built tool analyze potentially vulnerable call sites printf determine exploit exploit tool produces format-string demonstrates exploit technique require source code application analyze potentially vulnerable printf locations binary executables tool conjunction percent-s generate format-strings exploit vulnerabilities identified section discussion implementation make platform-specific assumptions technique applies platforms work architecture runtime stack application grows higher addresses lower addresses machine assumed little-endian arguments function stack left call foo arg arg places arg stack arg popular calling convention implemented compilers analyze printf glibclibrary understanding printf int foo char usrinp char fmt len int strncpy fmt usrinp len printf fmt figure procedure vulnerable call printf section reviews printf works code fragment shown figure procedure foo accepts user input copied local variable fmt local array len characters printf called fmt argument argument printf controlled user program potentially exploited printf called line arguments passed printf stack return address frame pointer saved space allocated local variables printf shown figure case printf called pointer fmt local character buffer foo pointer shown darkly shaded region figure mentioned earlier printf assigns special meaning argument passed treats format-string arguments passed printf higher addresses format-string runtime stack case fmt passed argument arguments runtime stack printf implementation internally maintains pointers stack refer pointers fmtptr argptr purpose fmtptr track current formatting character scanned format-string argptr track location stack read argument printf begins read arguments fmtptr positioned beginning format-string argptr positioned pointer format-string fmt shown figure whenprintfbegins execute moves fmtptr formatstring fmt advancing pointer makes move higher addresses memory fmtptr moves direction opposite stack grows printf modes printing mode reads bytes format-string prints argument-capture mode reads arguments stack location pointed argptr type argument number bytes argptr advanced reads argument determined contents location pointed fmtptr fmtptr argptr move higher addresses reach intermediate configurations shown figure note argptr advances contents fmt printf enter argument-capture mode localvariables foo return address frame pointer return address frame pointer fmtptr argptrfmtptr argptr local variablesof printfprintfstack frame stack framefoo local variables foo direction stack growth dis len printflocal variables fmt fmt figure runtime execution stack program figure concrete suppose fmt printf called figure printf starts printing mode advances fmtptr printing stdout result fmtptr encounters byte enters argument-capture mode fmtptr advanced points byte instructs printf read 
including file create file execute lsm-selinux hooks protect operations functions called open namei opposed locations open namei called performance ran timing experiments machine ghz amd athlon processor ram hook analysis minutes kernel analysis minutes smaller runtime kernel analysis attributed simpler nature published proceedings acm conference computer communications security november opportunities improvement encouraged tahoe ability place hooks identified shortcomings plan address future work tahoe analyze hooks lsm-selinux lsm-selinux hooks allocate free data structures internal kernel module implements hooks authorize conceptual operations crucial locations kernel improper placement hooks lead runtime exceptions tahoe kernel analysis recovers conceptual operations performed kernel function recover specific resource instances performed manually instance figure resource instances dir dentry recovered manually tahoe place hooks granularity function calls places hooks location controlled kernel functions called cases lsm-selinux selinux file set fowner hooks finer granularity modifications kernel data structures idiom writing refinement improve results kernel analysis manual procedures plan investigate automatic idiom writing refinement techniques future related work prior work formal analysis hook placement lsm framework focused verifying correctness existing hook placement vali runtime tool determine consistency hook placement lsm based observation hook placement lsm typically consistent code paths kernel inconsistencies indicative bugs analysis performed execution traces obtained running instrumented version kernel authors demonstrate static version vali built analysis capabilities jaba static analysis tool automatically identify privileges needed execute java program zhang demonstrate type-qualifier-based tool cqual determine inadequacies hook placement analysis determines resource authorized hook conceptual operation performed analysis requires input set conceptual operations performed resource order verify adequacy hook placement type-qualifier-lattice cqual output vali obtain type-qualifier lattice efforts source code hooks analysis focused problem automatic hook placement analysis employed tahoe verifying existing hook placement instance authorization graphs extracted tahoe compared authorization graph existing hook placement anomalies flagged potential errors analyses employed stages tahoe related prior work hook analysis employs flow-sensitive context-sensitive program analysis explored tools past including mops jaba idioms kernel analysis conceptually similar compiler-extensions written language called metal vali runtime techniques extract authorization graph hook-placed kernel consistency analysis graph identify anomalies authorization graphs similar access rights invocation graphs jaba tahoe addresses problem enforcing authorization policy placing hooks kernel module encapsulates policy ensure authorization policy meets security goals integrity confidentiality slat gokyo tools purpose tools construct abstract model authorization policy selinux policy analyze determine conflicts policy system security goals conclusion emerging popularity lsm framework implement mac authorization policies coupled recent interest lsmlike frameworks user-level applications underscores security frameworks techniques presented paper step automatic enforcement authorization policies formal reasoning program analysis acknowledgments shai rubin ccs reviewers insightful comments vijayan prabhakaran patiently answering file system questions anderson computer security technology planning study volume technical report esd-tr- deputy command management systems electronics systems division afsc hanscom field bedford october badger sterne sherman walker haghighat domain type enforcement unix prototype usenix unix security june chen lightweight model checking improving software security phd thesis california berkeley fall engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions acm usenix osdi december foster fahndrich aiken theory type qualifiers acm sigplan pldi garey johnson computers intractability freeman york gong ellison inside javatm platform security architecture api design implementation pearson education guttman herzog ramsdell skorupka verifying information flow goals security-enhanced linux jcs idioms wisc papers ccs idioms html jaeger edwards zhang consistency analysis authorization hook placement linux security modules framework acm tissec jaeger sailer zhang analyzing integrity protection selinux policy usenix security august kilpatrick salamon vance securing window system selinux technical report nai labs march koved pistoia kershenbaum access rights analysis java acm sigplan oopsla november leroy doligez garrigue emy vouillon objective caml system release technical report inria rocquencourt july loscocco smalley integrating flexible support security policies linux operating system usenix annual technical june mclean specification modeling computer security ieee computer muchnick advanced compiler design implementation morgan kaufmann necula mcpeak rahul weimer cil intermediate language tools analysis transformation programs intl conf compiler construction april sharir pnueli approaches interprocedural dataflow analysis muchnick jones editors program flow analysis theory applications pages prentice hall simplify http research compaq src esc simplify html tresys technology security-enhanced linux policy management framework http sepolicy-server sourceforge net wright cowan smalley morris kroah-hartman linux security modules general security support linux kernel usenix security august zhang edwards jaeger cqual static analysis authorization hook placement usenix security august 
bytes location pointed argptr print resulting terminal integer results argptr advanced bytes size integer note integer arguments explicitly passed printf figure reading legitimate integer stack case argptr reads values local variables stack frame foo result read contents stack possibly values interest attacker return addresses format-string exploits discussed paper goal attacker control contents format-string argptr advances stack enters format-string attacker control arguments read printf section develops point formally printf api key observation byte format-string instruction printf move fmtptr argptr amount bytes instruct printf types arguments passed formulation byte format-string treated api command printf format-string specifies sequence api operations goal discover possibly malicious sequences corresponds finding format-strings exploit printf call characterized parameters values dis len shown figure format-string vulnerabilities occur format-string controlled attacker buffer runtime stack len denotes length buffer dis denotes number bytes separate pointer format-string format-string figure shows simple scenario stack frame format-string stack frame printf adjacent general separated stack frames intermediate functions resulting larger values dis note values dis len sufficient capture relevant details problem values dis len printf call obtained disassembling binary executable application calls printf examining call graph sizes functions stack frames formally printf init denotes set local variables implementation printf capture current state identified local variables flags integer boolean values examining source code manuals printf implementation considers flags purposes explanation restrict flags fmtptr argptr longlong fmtptr argptr pointers functionality discussed earlier treat integer values integer counts number bytes printed longlong boolean variable determines argument stack long long long long int bytes length init initial state printf determined initial values flags assume addressing relative initial location argptr init defined argptr fmtptr dis longlong false variables discussed explained byte format-string interpreted instruction printf byte values values pre post operation based state printf obtained examining source code printf instance pre true post captures semantics printf printing mode determined variable mode fmtptr incremented printf enters argument-capture mode printf argument-capture mode fmtptr incremented actual implementation printf flags integer pointer data types finite-precision bit-vectors model flags values treated boolean rest treated unbounded integers approach achieves efficiency raising level abstraction model integer overflow lead imprecision printf enters printing mode corresponds printing stdout formally mode printing fmtptrprime fmtptr modeprime argument-capture mode argument-capture fmtptrprime fmtptr doneprime modeprime printing primed variables denote next-state values variables set language legal format-strings turns regular language extracted api-automaton recognizes legal format-strings control-flow graph implementation printf possibilities forbad determines attack exploits format-string vulnerabilities present possibilities bad section general predicate expressed formula elements decidable logic includes quantifier-free presburger arithmetic uninterpreted functions theory memories arrays formula quantifier-free presburger arithmetic consists set linear constraints integer variables combined boolean operators implemented tool examine system detect format-string exploits tool encodes printf parameterized values dis len predicate bad choice bounded model checker influenced logic needed express model printf elaborated model values stack precisely track contents format-string serves concrete counter-example bad satisfied necessitates theory memories uninterpreted functions printf integer boolean variables integer variables modified linear-arithmetic operations addition multiplication constant express formulas variables quantifier-free presburger arithmetic based requirements chose bounded model checking capabilities uclid verifier details uclid works scope paper found description printf encoded uclid model straightforward manner bad satisfied uclid produces counter-example directly translated format-string demonstrates exploit call-site printf examine format-strings length equal len exclude terminating bound len suffices make bounded model checking complete call-site printf location deemed safe tool bound len safe respect property checked checking printf api exploits goal attacker manipulate contents format-string force argptr move format-string argptr move dis bytes time fmtptr moves len bytes attacker controls format-string control arguments printf reads stack demonstrated vulnerability read data write data location memory reading arbitrary location ways attacker print contents memory address most-significant byte construct format-string moves fmtptr argptr printf printing mode fmtptr points beginning argptr points bad read exploit bad write exploit fmtptr dis len argptr dis argptr dis len fmtptr fmtptr argptr argptr argptr argptr mode printing fmtptr dis len argptr dis argptr dis len fmtptr fmtptr argptr argptr argptr argptr writeval mode printing figure predicate bad read exploit write exploit beginning sequence bytes pointer printf reads interprets argument argptr pointer prints contents memory location pointer string attacker achieve goal formalized predicate bad shown figure note little-endianness machine reflected formulation bad bytes arranged most-significant leastsignificant addresses decrease appears lower address symbolic values stack locations fmtptr argptr bad show track stack contents precisely figure shows results produced tool values dis len instance line shows formatstring read contents memory dis len exploit proceeds initially fmtptr points format-string argptr smaller fmtptr printf starts execution printing mode advances fmtptr prints bytes stdout printf reads advances fmtptr enters argument-capture mode reads advances fmtptr reads integer bytes location pointed argptr prints integer stdout returns printing mode result argptr points beginning format-string fmtptr positioned beginning sequence printf processes contents memory location printed stdout observations figure line tool infer exploit intuitively format-string small sequence commands carry exploit lines present format-strings parameters achieved observing case running tool appending suitable term bad exclude case technique iterated infer variants exploit desired writing arbitrary location kind format-string exploit attacker write choice location memory chosen makes feature provided printf printf printing mode encounters format-string reads argument stack interprets pointer integer writes flag location constraint non-zero interpreted terminates format-string ease explanation impose additional restriction negationslash address parts conversion specifier tool discover exploits address counts number bytes output call printf figure shows case attacker writes integer writeval address figure shows format-strings obtained tool write integer memory address line instance values dis len tool inferred format-string printf starts execution printing mode argptr bytes fmtptr stack fmtptr moves format-string bytes printed stdout incrementing byte increments fmtptr byte forces printf argumentcapture mode bytes treated width parameter printf stores internal flag width part printf printf processes byte advances argptr bytes reads double stack prints appropriately formatted stdout increments width returns printing mode point argptr points beginning format-string bytes fmtptr points beginning sequence printf processes written completing exploit execution times shown figure obtained machine intel pentiumprocessor running ghz ram running redhat linuxall runs completed minutes general trend time increases len increases monotonically reason larger values len run bounded model checker uclid steps leading larger formula 
check largest formulas boolean combinations thousand linear constraints hundred integer variables uclid translates problem checking validity boolean formula checked sat solver called siege note time finding read exploits lower finding write exploits finding write exploit involves solving constrained problem read exploit addition finding sequence conversion specifications moves argptr format-string find width values add desired figure length sequence len optimizations model printf byte format-string considered api operation optimization add aggregated api operations treat sequences primitive api operations single operation create aggregated api operation moves fmtptr bytes argptr bytes reads long double similarly conservative width specifiers form aggregate api operation increments addition changing flags augmenting affect soundness format-strings uclid previously generate generated optimization longer strings potentially found fewer iterations bounded model checking comparison existing tools demonstrate effectiveness tool compared percent-s tool analyzes source code typethe number bytes printed maximum width specifier needed precisely represent output width specifier conservatively large dis len read exploit write exploit exploit string discovered time sec exploit string discovered time sec exploit exploit exploit figure exploits generated tool write exploit chose write integer memory location specific address software dis len exploit exploit string discovered represents non-zero nonascii character phpwrite xbfff xbfff assume qpopperread contents xbfff wu-ftpdwrite xbfffbcab xbfff assume figure exploits generated vulnerabilities real-world software packages qualifiers identify tainted user-controlled inputs potentially format-strings report experiments showing reduce false alarm rate showing confirm true vulnerability generating exploit program figure compiled machine dis bytes irrespective len size bufferfmt percent-s reports theprintf statement line exploitable small values len preclude possibility attack result percent-s produces false alarms account values parameters dis len hand model printf infer read-exploit similar reported earlier len bytes write-exploit write integer len bytes cases analysis produces formatstring demonstrates exploit percent-s tool analyze format-string vulnerabilities real-world software packages figure details phpis language-processor widely-used webscripting language php qpopperis pop mail server wu-ftpdis popular file-transfer daemon explain detail exploit againstwu-ftpdthe similar percent-s correctly identified location vulnerability wu-ftpdbut produce format-string demonstrating exploit dis len obtained disassembling binary executable values dis len checked attacker perform exploit attacker buffer stores format-string additionally store malicious code overwrites return address stack frame printf write exploit section point beginning malicious code sequence assumed return address overwritten stack location xbfff malicious code located address xbfffbcab bytes located buffer stores format-string address values easily read stack exploit explained section written fairly large variant predicate bad writing single address multiple slightly misaligned writes smaller values details misaligned writes found values dis len large optimizations section infer minutes format-string concatenation strings prefix middle part consisting repetitions aggregated api operation suffix xbfff verified string writes desired desired location write performed writes xbcab writes xbfff existing format-string exploit generators attempt construct format strings fixed conversion specifiers instance thuemmel constructs format-strings conversion specifier building block result techniques lack soundness exploit strings space strings explored tools exhaustive search state space technique guarantees soundness model printf addition existing tools incapable finding variants exploit demonstrated lines figure technique discover variants exploit values dis len ibm cca api present case study ibm cca api cca api cryptographic-key management api secure hardware devices coprocessors ibm coprocessor cryptographic services key-management host computer ibm loaded distinct secret master key denoted safeguarded physical security device security host relies secrecy background cca cca ibm key-management host computer issues commands api communicated cca coprocessor noteworthy feature cca ability assign types called control vectors keys control vector key determines subset operations api accessible cca defines control vectors classes keys compute message authentication codes pin numbers control vectors cca implement role-based access control rbac important preserve integrity cryptographic keys clear values keys stored host computer similarly preserve integrity rbac key tightly coupled control vector ibm achieves objectives storing key hard disk host computer operational key-token discussion paper restrict components keytoken denoted emk cvk cvk denotes bit-wise exclusive-or denotes symmetric-key encryption algorithm des key component encrypted clear cvk presented key token ibm cvk component decrypt component retrieve clear revealed ibm observe retrieved component key-token modified note key-token function ibm master keys hosts share cryptographic-keys instance establish session-keys communication discuss communication hosts ibm keys mka mkb cca api key management supported methods communication involves establishing secure communication channel symmetric key-encrypting key encrypt cca-managed keys transported channel key-encrypting key clear denote kek cca key control vector cvkek stored operational key-tokens emka cvkek kek cvkek emkb cvkek kek cvkek techniques supported cca installing key-encrypting keys works parties generates key parts kek key parts transported clear separately entered key part import cca api-operation figure result api-operation operational key-token kek idea clear kek retrieved key-part holders collude situation key control vector cvk stored key-token emka cvk cvk share key-token directly clear encrypted mka keysharing ibm cca api-operation key export shown figure makes key-token deviceindependent api-operation operational key-tokens kek produce token ekek cvk cvk export key-token device-independent intuitively key-token emka cvkek kek cvkek retrieve kek ibm produce kek cvk cvk retrieved key-token emka cvk cvk ibm emka cvk cvk retrieve values produce export key-token export key-token transported network referred import key-token apioperation key import specification figure convert key-token operational key-token input api-operation operational key-token kek input key-token received communication channel key export key import retrieves clear kek cvk input produce kek cvk retrieve decrypting ekek cvk clear cvk produce operational key-token emkb cvk cvk formally api formalize cca api framework developed section focus security cca api restrict attention sequence api operations issued coprocessor make assumptions host analyze communicate hosts establish secure communication channel key-exchange protected keyencrypting key kek assume initiates communication key-encrypting key stored emkb cvkek kek cvkek api-operation key part import install key-encrypting keys framework section init denotes single set-valued variable keytokens denotes set key-tokens init keytokens empty set key part import key import key export subset cca api analyze intuitively track set key-tokens ibm variable keytokens assume set initially empty assume api-operations interleaved arbitrarily denoted operations accept arguments pre post defined key part import pre true post emka cvkek cvkek keytokens key import pre asserts structure key-tokens enc denote half half key-token similarly post asserts emka key keytokens key enc eval key val enc emka val key export analogous key import 
intuitively val denotes clear key-encrypting key retrieved retrieve key produce operational keytoken required post keytokens safety property verify integrity rbac operational key-token obtained key import control vector control vector export key-token communication channel ekek cvk cvk operational key-token emka cvk cvk bad defined emka cvnew cvnew keytokens cvnewnegationslash cvk key study security provided cca api assume attacker complete control attacker observe manipulate messages communication channel addition manipulate key-token stored host computer invoke cca api operations ibm arguments choice assumptions follow standard dolev-yao attacker model formal statement attacker abilities shown figure figure denote set terms attacker rules capture attacker enhance knowledge set terms instance rule attacker terms checking api built prolog-based bounded model checker analyze specification chose prolog inference rules api operation expected input expected input output key part import clear clear emk cvkek cvkek key export emk cvkek kek cvkek emk cvk cvk ekek cvk cvk key import emk cvkek kek cvkek ekek cvk cvk emk cvk cvk figure api operations ibm cca denotes master key coprocessor cca operates kek denotes clear key-encrypting key denotes clear cca key cvk denotes control vector cvkek denotes control vector key-encrypting keys rules turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft cryption turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft pairing turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft figure knowledge enhancement rules associativity commutativity rules shown presented figure api operations easily encoded prolog rules refer reader accompanying technical report details model checker api specification discussed model checker produces counter-example trace shown figure chosendifference exploit control vectors discovered bond key part import input input cvk cvnew output emka cvkek kek cvk cvnew cvkek key import input emka cvkek kek cvk cvnew cvkek input ekek cvk cvnew output emka cvnew cvnew figure counter-example trace showing exploit exploit works suppose attacker kek instance attacker holder statement figure attacker installs key choice key-encrypting key attacker manipulate key part produce cvk cvnew cvk control vector key transported network cvnew control vector chosen attacker key part import executed modified key part argument key-token emka cvkek kek cvk cvnew cvkek results thinks key-token shared key-encrypting key input statement figure corresponds step attacker unpairing pairing rules figure obtain ekek cvk cvnew ekek cvk cvk invokes key import modified key-token key-token shared key obtained step attack key import produces mka cvkek cvkek input retrieve kek cvk cvnew half input normal operation retrieved kek key import extracts cvnew input xor kek cvk cvnew obtain kek cvk retrieve portion ekek cvk input process fooled thinking key control vector cvnew key import terminates producing operational key-token emka cvnew cvnew violates integrity rbac completes exploit bond demonstrates learn sensitive values pin-encrypting keys worth noting analyzing apis requires modeling kinds low-level details instance section considered layout stack frames discover format-string exploits hand cca api considered adversary increase knowledge standard rules figure note rules employed security-protocol verifiers cca api potentially analyzed security-protocol verifier related work model checking software model checking tools proposed recent years tools check software violations user-defined assertions temporal-ordering rules events finite-state abstractions model data values successful verifying control-flow-intensive properties discussed earlier api-level exploit concrete trace model satisfies bad key difference apilevel exploit concrete counter-examples produced tools exploit low-level details unlike aforementioned tools technique capable finding exploits permits modeling low-level details layout program runtime stack strategy employ finding exploits based bounded infinite-state model checking uclid verifier printf case study driven reason quantifier-free presburger arithmetic bound len guarantees completeness general choice analysis tool depend logic needed reason system underlying logic first-order relational logic alloy analyzer similarly unbounded infinite-state model checking techniques potentially test generation formal specifications software generate test cases bounded exhaustive testing specifications typically form preand post-conditions tools exhaustively generate input data structures upto size satisfy conditions counterexamples produced model checking tools generate test cases analysis viewed form test generation api-level exploits generated test patched versions component implements api ad-hoc techniques prior work security-exploit generators including generators format-string exploits noted section techniques proposed typically ad-hoc provide soundness guarantees search specific attack patterns format-strings fixed conversion width specifier miss kinds attacks addition techniques incapable generating variants exploit paper presents general formal framework generate exploits previous exploit-generation tools find typeand constraint-based analysis static analyzers special classes vulnerabilities buffer overruns format-string vulnerabilities proposed demonstrated section analysis complements tools exploit generated vulnerability identified tools evidence vulnerability real hand exploit generated vulnerability automatically classified false alarm interface synthesis complementary analysis finding api-level exploits problem synthesizing correct usage rules apis techniques proposed synthesize interfaces including techniques mine execution traces techniques based model checking output techniques typically finite-state machine api operations api-automaton formal framework superoptimizers code generator produces code optimized respect criteria number instructions called superoptimizer recent work explored sat solvers theorem-provers technique similar presented section produce superoptimized code space code sequences explored propositional boolean formula theorem prover identify code sequences satisfy optimization criterion superoptimizers model low-level instruction semantics generate intricate compact code sequences conclusions main message paper model low-level details software component implementation order find exploits demonstrated api-level exploits presented framework model analyze apis exploits showed framework real-world apis significant complexity briefly discuss difficulties encountered modeling analyzing apis modeling low-level details demonstrated case studies apis exploited ways main problem identify low-level details model api solution model api operation bit-level bit system affected applying api operation approach solve problem identifying low-details api scale expect case studies domainspecific expertise solution identify lowlevel details api constructing predicate bad figure fact read memory location exploits found tool blueprint covers large class exploits ways read memory tool miss domainspecific expertise needed construct predicate bad covers large class exploits automating model construction models printf ibm cca api constructed manually examining source code studying manuals tedious error-prone process modern software model checkers automatically construct finite-state models predicate abstraction case main obstacles automatic model construction twofold low-level details modeled domain-specific resulting model infinite-state section future work intend investigate techniques set low-level details modeled automatically extract models amenable exploit-analysis alur cerny madhusudan nam synthesis interface specifications java classes proc popl acm ammons bodik larus mining specifications proc popl acm ball rajamani slam project debugging system software static analysis proc popl acm beyer chipala henzinger jhala majumdar generating 
tests counterexamples proc icse ieee biere cimatti clarke zhu symbolic model checking bdds proc tacas lncs springer bond chosen key difference attack control vectors manuscript november http cam mkb research cvdif pdf boyapati khurshid marinov korat automated testing based java predicates proc issta acm bryant lahiri seshia modeling verifying systems logic counter arithmetic lambda expressions uninterpreted functions proc cav lncs springer bultan gerber pugh model-checking concurrent systems unbounded integer variables symbolic representations approximations experimental results acm toplas chen wagner mops infrastructure examining security properties software proc ccs acm clarke kroening lerda tool checking ansi-c programs proc tacas cowan barringer beattie kroah-hartman frantzen lokier formatguard automatic protection printf format-string vulnerabilities proc security symp usenix alfaro henzinger interface automata proc esec fse acm moura rue sorea lazy theorem proving bounded model checking infinite domains proc cade lncs springer dolev yao security public key protocols ieee transactions information theory engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions proc osdi acm usenix ferraiolo kuhn role based access control national computer security conference october foster fahndrich aiken theory type qualifiers proc pldi acm ganapathy seshia jha reps bryant automatic discovery api-level vulnerabilities technical report dept univ wisconsin http wisc wisa papers pdf harrison ruzzo ullmann protection operating systems comm acm henzinger jhala majumdar sutre lazy abstraction proc popl acm hoglund mcgraw exploiting software break code addison wesley boston jackson automating first-order relational logic proc fse acm johnson dolan kelly matyas common cryptographic architecture cryptographic application programming interface ibm systems journal joshi nelson randall denali goal-directed superoptimizer proc pldi acm massalin superoptimizer smallest program proc asplos acm matyas abraham key management scheme based control vectors ibm systems journal meadows nrl protocol analyzer overview journal logic programming moskewicz madigan zhao zhang malik chaff engineering efficient sat solver proc dac acm newsham format string attacks securityfocus guest securityfocus qualcomm qpopper vulnerability securityfocus advisories seshia bryant deciding quantifier-free presburger formulas parameterized solution bounds proc lics ieee shankar talwar foster wagner automated detection format-string vulnerabilities type qualifiers proc security symp usenix siege sat solver http sfu loryan personal stump barrett dill cvc cooperating validity checker proc cav lncs springer sullivan yang coppit khurshid jackson software assurance bounded exhaustive testing proc issta acm thuemmel analysis format string bugs manuscript http downloads securityfocus library format-bug-analysis pdf wagner dean intrusion detection static analysis proc symp security privacy ieee wagner foster brewer aiken step automated detection buffer overrun vulnerabilities proc ndss isoc xie aiken scalable error detection boolean satisfiability proc popl acm 
security policy reconciliation distributed computing environments hao wang somesh jha miron livny computer sciences department wisconsin madison hbwang jha miron wisc patrick mcdaniel labs-research shannon laboratory park ave florham park pdmcdan research att abstract major hurdle sharing resources organizations heterogeneity order organizations collaborate policies resolved process resolving policies policy reconciliation general intractable problem paper addresses policy reconciliation context security present formal framework hierarchical representation security policies hierarchical representation exposes structure policies leads efficient reconciliation algorithm demonstrate agent preferences security mechanisms readily incorporated framework implemented reconciliation algorithm library called policy reconciliation engine pre order test implementation measure overhead reconciliation algorithm integrated pre distributed highthroughput system called condor introduction security policy bridges gap static implementations broad diverse security requirements user communities security policy complicated heterogeneous environments hao wang miron livny supported doe contract de-fc nsf nasa contract nas somesh jha supported office naval research contracts government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government entities share security association reach agreement governing policy end-points ipsec session entities express requirements association security policy called domain policy reconciliation algorithm finds policy consistent domain policies consistent policy found association free proceed found participants alter requirements abstain participating general case policy reconciliation intractable result past investigations largely achieved tractability limiting policy representation heuristic algorithms approaches achieve stated goals fail efficiently capture dependencies aspects policy systems preferential policy advantageous policy legal illegal state desirable work addresses limitations past work developing policy framework based graphical policy representations exploit graph representation efficiently encode complex dependencies inherent contemporary policy formally define representation efficient preference dependencyrespecting reconciliation algorithm introducing formalism present overview security provisioning policy intuition framework section security policy term security policy things communities access control policy defines access circumstances forms security policy conditions credentials accepted hmac cbc preshare idea ike cast des encrypt sha group group figure graphical ipsec key management policy firewall configured broadest definition security policy specification security relevant system behavior paper addresses session-specific configuration security services commonly security provisioning policy configurations define guarantees afforded governed environment explicitly identifying algorithms parameters protocols implement security illustrate importance ubiquity security provisioning policy client netscape communicator outlook user specifies provisioning policy time adds account connection method imap ssl dictates set guarantees receive obtaining viewing mail note decision security service specification policy policies defined applications services environment prescribe security afforded users practice provisioning policy complicated suggest important organization-wide goals realized policies implemented environment lower level policies constructed compliant organizational goals operation spans organizations policies organization reconciled form coherent reasonable policy introduce graphical provisioning policy representation graphical policy series policy operations represented cascading circular square nodes singularly rooted directed acyclic graph dag formally structure and-or graph policy read root node node decision circle collection square decision node requires sub-graphs emanating node resolved collection node requires sub-graphs resolved leaf nodes added policy configuration derived policy respects simple rules figure shows graphical provisioning policy key management ipsec vpn policy user network administrator part vpn setup reads policy root decision node configure preshare preshareed keys ike right-hand side graph ike root depicts complex series configurations behavior internet key exchange ike protocol ike sub-policy consists independent configurations read top ike collection node configure group hmac encryption remainder policy read selection single group hashing algorithm encryption algorithm independent encryption algorithm mode cbc selected policy mandates cbc mode policy point endpoint host connected vpn policy evaluated identifying subset nodes leaves graph defined structure collection decision nodes ipsec implementation resulting concrete specification called evaluated policy instance implement ipsec session evaluated policy ike dh-group hmac-md idea-cbc important factors highlighted policies ipsec key management depending goals policy specifier structure policy number ways consistent ipsec implementation policy encryption modes ecb adding additional decision node factor note unlike policy policy specifies range behaviors policy states set configurations equally acceptable structure graph directly mandates sets configurations considered acceptable non-prescriptive policies environment make performance security trade-offs run time essential reconciling policies domains case single source policy end-points vpn lie administrative domains domain wishes exert control session domain policy similar figure parties find evaluated policy consistent domain policies supplied performed reconciling domain policies session continue single governing policy found domain policies incompatible end-points alter policies refrain participating session study provisioning policy unlike policy efforts ways provisioning policy planning process traditional authorization policy systems determine access legal respect larger governing policy conversely provisioning policy attempts find configuration consistent governing provisioning policy provisioning policy embodies complex dependencies decisions aspects policy affect subsequent options figure illustrates simple dependency decision ike pre-shared keys enormous impact development policy selection ike leads decisions kinds diffie-hellman groups encryption algorithms pre-shared keys selected configuration values diffiehellman group considered provisioning subject preferential behavior set configurations desired choices figure policy group group acceptable practice found vast majority ipsec configurations group rightly wrongly decide group environment preferred compatibility reasons preclude group note preferential configurations simple default values partial ordering options existence preferences largely previous work area demonstrate sections reconciliation made complex introduction appreciation deeper aspects policy work aspires provide intuitive policy representations constraints complex semantics contribution lies representation added semantics successful marriage contributions paper addresses aforementioned deficiencies existing systems modeling dependencies preferences graphical policy framework main contributions paper graph-based provisioning policy exposes dependencies present model represents policies directed acyclic graphs dag model captures dependencies policy components schema policies adhere schema impossible define correctly formed policy consistent dependencies efficient reconciliation general policy reconciliation np-complete graphical representation policies expose structure present basis efficient reconciliation algorithm provide efficient reconciliation algorithm graphical model reconciliation algorithm linear size policies preferential policy participant preferences server preferences authentication mechanisms incorporated model important problem arises context resolving multiple partial orders set intuitively partial orders represent preferences participants provide efficient algorithm resolve multiple partial orders extend reconciliation algorithm handle preferences implementation deployment based hierarchical framework implemented reconciliation module called policy reconciliation engine pre download integrated pre condor high-throughput scheduling system manage resources complex distributed environment show experimentally cost reconciliation negligible related work policy systems historically policy systems addressed reconciliation trust management systems keynote spki sdsi binder concerned compliance checking 
reconciliation trust management systems policies called credentials simply cryptographic proofs express authorization delegation compliance checker algorithm searches credentials accepting delegation chain satisfies specific request credentials state set provisioning requirements action allowed provisioning environment matches credential approaches managing policy widely deployed loosely organized environments credentials mandate provisioning opportunity perform reconciliation systems simply assume singular entity manually performs reconciliation issuing policy domain hardness reconciliation reconciliation recently begun explored policy community developed broad characterization problem gong qian discovered reconciliation authorization policy work called policy composition np-complete similarly authors ismene found reconciliation general purpose provisioning policy np-complete results progress made suggests required shift goals investigation ongoing work reconciliation centered techniques alter environment restrict policy obtain efficient reconciliation paper demonstrates representation exposes structure policies reconciliation problem tractable larger class policies reconciliation approaches address inherent complexity reconciliation essentially flattening policy representation explicitly enumerating choices ipsec security policy system sps guarantees efficient two-party reconciliation intersecting fixed independent sets policy values dccm system extends approach multi-party environments providing chinese menu reconciliation algorithm participant chooses values fixed set policy dimensions column column policy reconcilable intersection proposals found dimension conflicts intersection found resolved unspecified algorithm limitation sps dccm assume dependencies policy values ipsec policy encryption algorithm needed esp transform selected ensure resulting policy enforceable disallow policy defines esp transform encryption algorithm practice systems define policy enumeration legal policy combinations espdes-hmac-sha legal enumerations dependency violated number enumeration values grows exponentially size domains enumeration approach inherently scalable ismene policies defined expressions provisioning variables reconciliation algorithm find satisfying truth assignment universe provisioning variables reconciliation cast instance satisfaction conjunction policy proposals efficiency guaranteed pair-wise satisfaction algorithm restricted policy expressions iterative ismene n-policy reconciliation algorithm sound complete collections reconcilable policies rejected sps ismene reconciliation algorithm dependencies dependencies addressed ismene evaluating reconciliation result respect set correctness rules analysis algorithm approach limited occurs policy identified reconciliation re-performed policy rejected analysis bands addresses multi-domain policy reconciliation context ipsec describing security requirements domain policy language provisioning policy nodes source destination proposed source node gathering phase security requirements domains path gathered gathered requirements policy proposed passed path destination node domain path verify policy security requirements return error source node proposed policy reaches destination node error provisioning policy session central limitation approaches defined sensitive structure policy dependencies aspects policy inefficiently encoded externally evaluated prime motivation current work dependencies captured graphical structure policy schema policy resulting reconciliation guaranteed consistent dependencies previous reconciliation algorithms make distinction reconciliation results distinction made result equally desirable environments desire default behavior defaults inefficient infeasible work desires expressed preferences work representation analysis security policies cholvy cuppens complexities detecting managing inconsistencies introduced access control policy specifications approach differs problem domain provisioning avoid consistency evaluation encoding dependencies policy structure collections individual policies inconsistent cholvy cuppens considered preference context ordered application access control regulations focused access control applications explored forms policy graphical representations suited access control policy lasco language specifies access control policy graphical idioms developers lasco assert representation specification intuitive operation permits graph algorithms subsequent enforcement embrace similar approach structural representation enforce dependencies formalization policy reconciliation section provide precise semantics policy reconciliation policies represented hierarchically describe preferences incorpasswordkerberos des aes idea safer figure schemata porated framework finally present efficient reconciliation algorithm definition schemata directed acyclic graph dag root set nodes set edges root distinguished node assume root incoming edge node attributes node node tuple variables denoted vart type variable types string int real enum enum type assume set values des des aes set successors node schemata denoted succs schemata clear context simply write succ succs schemata shown figure root node node represented square left child root -nodes represent authentication encryption mechanisms leaf nodes labeled des -nodes successors special keyword signifies fact authentication encryption scheme required variables -nodes desired attributes key size encryption schemes -nodes definition instance schemata root subgraph nprime prime root nprime prime additionally conditions satisfied -node nprime succ nprime words successors -node instance -node nprime succ non-empty succ nprime words -node non-empty set successors successor instance node nprime vart case assigns values type variable vart tuple values assigned node denoted vali definition policy schemata root -tuple maps nodes tuple conditions -node succ k-tuple conditions var assume condition applies values type type denote satisfies policies shown figures left child root policy specifies kerberos password allowed successors left node edges nodes interpreted similar manner instance nprime prime root policy satisfies denoted iff conditions satisfied -nodes nprime succ nprime words instance choose successors -node subset provided policy vali values assigned node conditions assigned node policy case assigned instance satisfy condition policy policy schemata called satisfiable iff exists define conjunction policies conjunction policies denoted policy sprime cprime -node sprime cprime conjunction policies depicted figure definition set policies reconcilable iff exists instance logicalandtextni words logicalandtextni satisfiable remark semantics reconcilable policies satisfaction relation give alternative definition terms languages schemata defines language instances instances schemata policy schemata defines language instances instances context policies reconcilable iffintersectiontextni non-empty resolving multiple partial orders section discuss policy reconciliation presence preferences preparation develop theory resolving multiple partial orders assume finite set suppose agents give preferences set agent specifies partial order precedesequali set intuitively agent organization process policy precedesequali specifies preference organization process question construct single partial order set denoted precedesequal partial orders precedesequal precedesequaln precise definition combining partial orders provide linear time algorithm compute combined partial order partial orders shown figure set kerberos password assuming agent giving partial order higher preference agent partial order combined partial order assuming order agents combined partial order reconciliation preferences section describes reconciliation policies allowed preferences define concept policy preferences definition policy schemata root -tuple pref maps nodes tuple conditions pref preferences -node succ pref partial order k-tuple conditions var assume condition applies values type type assume policy induces partial order precedesequalp instances satisfying instance dag rooted node called sub-instance sub-instance consists node descendants depth sub-instance length longest path root leaves partial order precedesequalp defined subinstances sub-instances root root precedesequalp iff conditions satisfied roots root root root -node set successors root sub-instances rooted case condition precedesequalp root -node successors root root subinstances rooted case condition precedesequalp precedesequal partial order pref root policy notice precedesequalp inductively 
defined depth sub-instances intuitively partial order precedesequalp extends partial order pref nodes policy subinstances extend definition conjunction policies incorporate preferences conjunction policies pref pref denoted policy sprime cprime pref prime -node sprime pref prime equal precedesequal cprime reconcilable policies instance called preferred instance mpi logicalandtextni maximal element partial order induced combined policy logicalandtextni reconciliation algorithm policies reconciliation algorithm proceeds compute combined policy logicalandtextni starting root combined policy traversed recursively find preferred instance partial order precedesequalp induced combined policy complexity reconciliation algorithm nodes edges details reconciliation algorithm found assume policies shown figures combined policy shown figure suppose partial order authentication mechanisms policies shown figure partial order encryption schemes policies shown figure partial orders resolved policy precedence policy case partial orders authentication encryption schemes combined policy policy partial order labeled figures mpi computed algorithm shown figure applications policy reconciliation framework section illustrates graphical policy real application environments end show policy reconciliation framework augment ipsec existing policy negotiation support condor distributed computing system graphical policy ipsec ipsec suite protocols source authentication data integrity data confidentiality layer services implemented authentication header encapsulating security payload esp transforms security service pcp implements data compression ipsec node host security gateway maintains security compression policy defined terms transforms communicating peers establish pairs policy instances instance represented security association reconciling configured local policies called proposals internet key exchange protocol ike things negotiate governing policy ike policy modeled graphical approach illustrate suppose host desires policy outgoing data protected esp protocols compressed pcp protocol esp des idea des encryption algorithms hmac-md hmac-sha integrity authentication algorithms hmac-md hmac-sha pcp lzs deflate ipsec proposal graphical representation policy depicted figure hierarchical dag structure expressive efficient understand difference square circle nodes interpret policy conversely great deal domain knowledge interpret proposal transform structure ipsec intuitive representation simplifies specification ultimately reduces policy errors extension policy states idea -bit -bit keys ipsec attributes key length transform separate transform required key length generally number transforms grows exponentially number independent attributes conversely graphical representation introduce single subgraph shared relevant nodes hierarchically policy condor system policy reconciliation framework context condor high-throughput distributed system designed efficiently schedule usage distributed heterogeneous resources idle cpu cycles unused memory condor resources owners place policy requirements resources hierarchical dag structure succinctly encode condor security policies design policy infrastructure integration condor detailed section implementation implemented hierarchical reconciliation algorithm policy reconciliation engine pre pre reconciles pairs xml-encoded policies restriction pre two-policy reconciliation limitation approach artifact initial target systems point-to-point communication models ipsec condor extend implementation multi-party policy reconciliation ismene dccm future dictate pre implements asymmetric requester responder model model requester supplies relevant policy responder responder reconciles received policy local policies needed reconciled policy returned requester parties subsequently reconciled policy control session chose requester responder model faithfully represents contemporary policy ike policy negotiation model similar client server communication models responders acting servers govern access communication resources requesters acting clients submit requests resources pre responders assert authority resources placing higher preference local policy note requester validate received reconciled policy consistent originone des aes saferx kerberos password figure policy kerberos password des aes idea figure policy aesx kerberos password des figure combined policy kerberos password kerberos password figure partial orders authentication schemes aes des idea aes des safer figure partial orders encryption schemes kerberos aes figure preferred instance nally proposed policy policy validation interfaces provided pre pre library command line tool directly integrated application external policy processor reconciliation three-step process pre security policy parsed internal data structures pair policies reconciled algorithms defined section finally verification engine ascertains correctness reconciled policy respect local security policy implements consistency test current implementation pre lines code source code documentation pre download integrating pre condor work policy motivated requirements condor system section condor schedules resources based client requests environmental factors condor peer local security policy governs services providing authenticity confidentiality integrity session supports modified condor system pre-based reconciliation construct security policy session past versions condor defined security policy flat structures called classads classads flexibly communicate resource advertisements client requests found structure classads inherently limiting represent range acceptable preferential policies flat structure statements policy previously argued hierarchical nature hierarchical policy drove efforts ultimately lead development pre details implementation refer readers condor authenticate policies policy exchanges supported underlying transport layer general policies issued authenticated environmental systems design issue environments require external services storing validation issued policies ldap collections signed policies issues defined larger policy architecture scope current work interested readers referred taxonomy policy architectures addressing issues performance small policy size restriction pairwise reconciliation anticipate introduction pre condor significantly impact performance sought measure costs controlled experiments experiments measured total execution time policy negotiation protocol defined preceding section experiments executed environment consisting single central manager server mhz duo-processor linux redhat esp pcp hmac shamd sha hmac idea des des deflatelzs transform des hmac sha proposal esp transform des hmac sha transform hmac sha transform hmac proposal transform des hmac transform idea hmac transform idea hmac sha transform des hmac proposal pcp transform lzs transform deflate original ipsec policy proposal ipsec policy schemata dag format figure ipsec policy clients ultra sparc sun solaris mhz pentium iii linux redhat experimental results confirmed intuition average protocol execution policy consisting authentication integrity secrecy total execution time including overhead cost small execution time startup cost program initialization dominant factor execution time closely overhead incurred condor internal data structures future work theoretical framework implementation hierarchical policy model reached maturity exploration application wide range problem domains essential initially seek integrate pre widely policy systems enable explore ways exploiting pre services specific policy reconciliation general work realize ipsec policy software integration tools freeswan provide important data-points extended policy services serve demonstrate power approach seek apply work domains unaddressed requirements policy reconciliation play important role defining security peer-to-peer systems coherent security models egalitarian nature systems mandate autonomy end-point assert realize set security requirements deemed important autonomy counter-balanced interoperability collection participants negotiate shared view security precisely definition reconciliation claim fluid heterogeneous security models systems served work clarity succinctness hierarchical models enable free open security policies large communities paper discussed reconciliation context security policy hierarchical policy models applicable problem domains illustrate 
grid systems share resources heterogeneous environments participants grid diverse policies govern resource usage agreement achieved statically current grid systems mandating adoption single universal policy mandate direct conflict dynamic environments resource constraints requirements frequently change policy reconciliation systems pre bridge gap dynamicity agreement direct dependence resource requirements security settings dynamic policy reconciliation act agent system handles sensitive data remote hosts require minimum security policy enforced conclusion security policy reconciliation process resolving security policies paper presented formal framework policy reconciliation presented efficient algorithm reconciling policies distinguishing features work hierarchical representation preferences implemented simplified version algorithm software module called pre incorporated condor experimental results context condor demonstrate session reconciliation overhead negligible balenson branstad dinsmore heyman scace cryptographic context negotiation protocol technical report network associates balenson branstad mcgrew turner heyman cryptographic context negotiation template technical report network associates bartal mayer nissim wool firmato firewall management toolkit ieee symposium security privacy pages bell lapadula secure computer systems mathematical foundations model technical report mitre corperation bedford blaze feigenbaum keromytis keynote trust management public-key infrastructures lec notes comp sci blaze feigenbaum lacy decentralized trust management proceedings ieee symposium security privacy pages november los alamitos blaze ioannidis keromytis trust management ipsec information system security cholvy cuppens analyzing consistency security policies ieee symposium security privacy pages ieee oakland condor http wisc condor detreville binder logic-based security language symp res sec privacy oakland ieee computer society press dinsmore balenson heyman kruus scace sherman policy-based security management large dynamic groups overview dccm project darpa information survivability conference exposition pages ellison spki requirements rfc sept ellison frantz lampson rivest thomas ylonen spki certificate theory rfc sept automatic generation ipsec vpn security policies intra-domain environment proceedings international workshop distributed system operation management dsom pages october gong qian complexity composability secure interoperation proceedings ieee symposium research security privacy pages oakland california ieee harkins carrel internet key exchange ike http ietf rfc rfc txt hoagland pandey levitt security policy specification graphical approach technical report cse- california davis department computer science june jim trust management system certified evaluation proceedings ieee symposium security privacy kent atkinson security architecture internet protocol http ietf rfc rfc txt koch mancini parisi-presicce graphbased formalism rbac transactions information system security tissec litzkow livny mutka condor hunter idle workstations proceedings international conference distributed computing systems icdcs pages mcdaniel policy management secure group communication phd thesis michigan ann arbor august mcdaniel prakash methods limitations security policy reconciliation ieee symposium security privacy pages mcdaniel prakash honeyman antigone flexible framework secure group communication proceedings usenix security symposium pages august nyanchama osborn role graph model conflict interest transactions information system security tissec pearlman welch foster kesselman tuecke community authorization service group collaboration proceedings ieee international workshop policies distributed systems networks project linux frees wan http freeswan raman livny solomon matchmaking distributed resource management high throughput computing proceedings seventh ieee international symposium high performance distributed computing hpdc sandhu coyne feinstein youman role-based access control models ieee computer sandhu samarati access control principles practice ieee communications magazine wang jha mcdaniel livny security policy reconciliation deistributed computing environments technical report wisconsin-madison march yang bands inter-domain internet security policy management system ipsec vpn integrated network management volume ifip conference proceedings pages kluwer zao sanchez condell lynn fredette helinek krishnan jackson mankins shepard kent domain based internet security policy management darpa information survivability conference exposition pages 
automatic generation vulnerability-based signatures david brumley james newsome dawn song carnegie mellon pittsburgh usa fdbrumley jnewsome dawnsongg cmu hao wang somesh jha wisconsin-madison madison usa fhbwang jhag wisc abstract paper explore problem creating vulnerability signatures vulnerability signature matches exploits vulnerability polymorphic metamorphic variants work departs previous approaches focusing semantics program vulnerability exercised sample exploit semantics syntax exploit show semantics vulnerability language inputs exploit vulnerability vulnerability signature representation regular expression vulnerability language unlike exploitbased signatures error rate empirically measured test cases quality vulnerability signature formally quanti inputs provide formal nition vulnerability signature investigate computational complexity creating matching vulnerability signatures systematically explore design space vulnerability signatures identify central issues vulnerability-signature creation vulnerability signature represents set inputs exercise vulnerability vulnerability coverage number vulnerable program paths subject analysis signature creation vulnerability signature created representation coverage propose dataow analysis adoption existing techniques constraint solving automatically generating vulnerability signatures built prototype system test techniques experiments show automatically generate vulnerability signature single exploit higher quality previous exploit-based signatures addition techniques security applications independent interest introduction vulnerability type bug attacker alter intended operation software malicious exploit actual input triggers software vulnerability typically malicious intent devastating consequences popular effective exploit defense mechanisms signature-based input ltering called content-based ltering improvements signature generation widespread impact automatic signature generation techniques manual signature generation slow error prone fast generation important previously unknown zero-day unpatched vulnerabilities exploited orders magnitude faster human respond worm outbreak automatic techniques potential accurate manual efforts vulnerabilities tend complex require intricate knowledge details realizable program paths corner conditions understanding complexities vulnerability consistently proven difcult humans source code level cots software assembly level challenges automatically creating signatures task automatically constructing signatures complicated fact polymorphic exploit variants trigger software vulnerability buffer-overrun vulnerability network service triggered protocol messages referred metamorphism exploit variants differ syntactically semantically equivalent exploit assembly instructions effect approach distinguish polymorphism metamorphism referred polymorphism paper morphing tools publicly automatically generate polymorphic exploit variants effective signature constructed based property vulnerability exploit observation made limitations previous approaches importance signature generation problem recently prompted researchers investigate automatic signature generation techniques previous approaches fall categories require manual steps employ heuristics fail settings techniques rely speci properties exploit return addresses vulnerability signatures limited underlying signature representation generate work speci vulnerabilities speci circumstances approach pattern-extraction based methods syntactically identify bit patterns attack samples innocuous samples techniques incapable handling polymorphic worms vulnerable adversarial environment attacker inject false super uous tokens over-learning red-herring attack approach based application exploit semantic information techniques heuristics-based rely speci properties exploits overwrite return address invariant shown previously heuristics work real-world vulnerabilities addition previous work line systematically explored design space signature creation focusing single design point creating regular expressions control-hijacking attacks regular-expressions recognize simple syntactic properties precise settings regular expressions recognize vulnerability valid invalid checksums distinguished approach roadmap central issues approach departs previous work analyzing vulnerability uncovered exploit attack analyzing exploit high level main contribution class signature call vulnerability signature speci details exploit successfully hijacks control program executing input potentially result unsafe execution state paper present formal approach reasoning vulnerability signatures intuitively vulnerability signature matches set inputs strings satisfy vulnerability condition program vulnerability condition speci cation type program bug memory writes allocated buffer space systematically explore design space vulnerability signatures identify important dimensions signature represented expressiveness trade-off matching accuracy ciency vulnerability covered signature trade-off amount analysis performed signature false negative rate develop techniques creating vulnerability signatures representations focus representations highlight inherent accuracy ciency creation time trade-offs design space turing machine signatures symbolic constraint signatures regular expression signatures contributions paper presents systematic approach formal model methods create vulnerability signatures static program analysis require single sample exploit initially identify vulnerability automatic signature generation approach applicable vulnerabilities vulnerability condition formally speci approach uncovers rich domain representing signatures techniques creating provide formal nition vulnerability signatures approach leads perspective vulnerability signature represented language classes expressive powers explore design space vulnerability signature show inherent trade-off signature matching accuracy representations perfect signature created turing machine signatures section matching unbounded amount time hand signatures fast matching accurate regular-expression signatures section introduce notion vulnerability signature coverage challenge vulnerability reachable nite number paths program presence looping show iteratively path separately signature generation scale methods identify created vulnerability signature approximates perfect vulnerability signature speci cally setting identify control imprecision introduced property makes easy quantify quality generated vulnerability signature develop static analysis techniques regular expression dataow framework section make adoptions existing techniques program chopping constraint satisfaction problem domain provide prototype implementation techniques automatically create signatures real-world vulnerabilities prototype addresses automatic signatures creation hardest scenarios program binary require source code type information prototype applicable cots software results show techniques automatically generate signatures higher quality previous techniques vulnerability signature section rst give formal nition vulnerability signature intuitively vulnerability signature representation set inputs satisfy speci vulnerability condition vulnerability conditions formally ned section explore dimensions design space vulnerability signatures signature representation coverage roughly speaking design points signature representation dimension trade-off matching accuracy matching ciency design points vulnerability signature creation dimension trade-off creation time signature coverage program paths analyzed problem setting motivate work approach vulnerability signatures setting exploit released unknown vulnerability site detected exploit means dynamic taint analysis stack protection wishes create signature recognizes exploits site furnish analysis tuple program exploit string vulnerability condition execution trace experiments assembly level assume binary program instruction trace techniques work source-code level goal create vulnerability signature match future malicious inputs examining running addition create signatures quickly scenarios signatures deployed immediately detection iterative approach generates successively signatures successive signature match exploit variants requiring exploit samples running paper running figure c-like language clarity implementation operates program binaries returns url request begins keyword null returned null figure running turns url request form gjg url null assume aaaa trace number line number figure vulnerability condition heap overow input satis program exploited iteration line url characters long characters allocated vulnerability signature nition vulnerability -tuple program sequence instructions iki vulnerability condition ned formally execution trace obtained executing program input denoted execution trace simply sequence actual instructions executed vulnerability condition evaluated execution trace satis vulnerability condition denote language vulnerability consists set inputs program resulting execution trace satis domain inputs formally language ned exploit 
vulnerability simply input executing input results trace satis vulnerability condition vulnerability signature matching function match input returns exploit benign running perfect vulnerability signature satis property match exploit benign show section language represented ways ranging turing machines precise accept regular expressions precise error rate soundness completeness signatures completeness vulnerability signature match match exploit match accepts incomplete solutions false negatives soundness match benign match accept extra unsound solutions false positives consequence rice theorem signature representation turing machine sound complete representations pick setting focus soundness tolerate false negatives false positives section show reformulate algorithm generate complete unsound signatures vulnerability conditions vulnerability condition function takes instruction current program state returns exploit indicating benign program state ecting execution rst instruction exploit called vulnerability point intuitively vulnerability point rst instruction unsafe execution rst out-of-bounds write line running formally vulnerability condition function fbenign exploitg memory including state variables vulnerability condition set variables ned program map memory locations values continuation stack instruction execute formally execute instruction order trace instruction affect vulnerability condition state variables scenario local memory vulnerability detection algorithm track important variables bounds allocated memory binds values registers soundness stating equivalent contra-positive note strictly convenient assume vulnerability condition memory separate evaluation stack cisc instructions dereference calculated memory address instruction addr map -bit memory locations values including stack heap addresses encode algorithm section inline encoding original program vulnerability point signature creation note speci type vulnerability contribution vulnerability condition assume note entire programming languages speci similar manner formal operational semantics techniques apply vulnerability condition stated algorithm running vulnerability condition check dereference make allocated bounds accomplish shadow pointer safe pointer records base address size memory allocated dereference checked safe pointer bounds formal operational semantics vulnerability condition exp exp safeptr benign exploit rst rule order calculate memory dereference form exp exp rst evaluated exp resolved address rule lookup context safe pointer safeptr safe pointer base address size dereferenced range speci benign returned exploit signature representation classes explore space language classes represent vulnerability signature signature representation pick determines precision matching ciency investigate concrete signature representations ect intrinsic trade-offs accuracy matching ciency turing machine signatures symbolic constraint signatures regular expression signatures turing machine signature precise false positives negatives matching turing machine signature unbounded amount time loops applicable scenarios symbolic constraint signatures guarantee matching terminate loops approximate constructs benign exploit benign figure signature running program looping memory aliasing lead imprecision signature regular expression signatures extreme point design space matching cient elementary constructions counting approximated accurate representations turing machine signatures turing machine signature program consisting instructions lead vulnerability point vulnerability condition algorithm inlined paths lead vulnerability point return benign paths lead vulnerability point satisfy vulnerability condition return exploit signatures precise trivial signature error rate emulating full program signature running figure symbolic constraint signatures symbolic constraint signature set boolean formulas approximate turing machine signature unlike turing machine signatures loops matching evaluating symbolic constraint signature input terminate loops symbolic constraint signatures approximate constructs loops memory updates statically result symbolic constraint signatures precise turing machine signature represent inclusive range inp means input bytes inclusive symbolic constraint signature considerable simpli cation readability running figure signature states ten-byte input matches signature rst input byte space characters path program path program control graph figure symbolic constraint signature running non-space characters non-space characters needed order -byte allocated url buffer note signature created unrolling loops lines signature statically infer times unroll loop general inferences upper bound unroll loops provided approach bounded model checkers regular expression signatures regular expressions powerful signature representation considerable false positive rate circumstances well-known limitation regular expressions count succinctly express conditions checking message proper checksum simple inequalities regular expression signatures widely practice regular expression signature produce running dataow techniques section gjg matches input begins spaces represented non-space characters signature types main contributions construction language class represent signature signature user free pick representation situation leave future work systematic formal investigation signature representations context free languages signature operations ciency summarize upper bounds signature operations table due space constraints prove bounds extended version paper vulnerability language recognized vulnerability signature representation match operation matching ciency primary concern picking signature representation turing machine signature representation creation signature size matching minimization equivalence turing machine sig poly poly undecidable undecidable undecidable symbolic constraint sig poly poly poly exp exp regular expression sig poly exp exp table summary approximate bounds vulnerability signature representations program length signature size poly denotes function polynomial exp denotes function exponential matching undecidable matching reduced halting problem symbolic constraint signatures matching polynomial time regular expression matching performed linear time signatures created encoding inlining vulnerability condition takes polynomial time symbolic constraint signature generation requires rst creating signature additional polynomial-time transformation unrolling loops xed number times regular expression signature creation entails solving symbolic constraint signature exponential time fact pspacecomplete performing dataow analysis original program takes polynomial time accurately represents solutions symbolic constraints approximates original program dataow analysis accurate section signature merging important operation model merging signatures equivalent performing single analysis lab union languages vulnerabilities union operation signatures creating condition cab evaluates true union operation symbolic constraints disjunction individual constraints constraint system satis union operation regular expression operator monomorphic execution path mep polymorphic execution path pep signature coverage introduce notion vulnerability signature coverage create vulnerability signature respect subset program paths exploit follow ability subset paths vulnerability opposed program paths exploit follow important creating signature program paths lead vulnerability expensive signature creation techniques iterative approach order scalable successively improve signatures rst small coverage incrementally increasing coverage include program paths vulnerability single path program input satis vulnerability condition call monomorphic execution path mep coverage initial mep path path sample exploit mep covers program instructions executed exploit single path vulnerability point excluding statements effect computation line sample exploit semantically no-op respect vulnerability mep conditional branch encountered target instruction leading vulnerability point target state benign mep straight-line program vulnerability point vulnerability condition evaluated returns benign exploit vulnerability signature consists inputs reach exploit state note straight-line programs imply single input leads vulnerability point exists inputs reach vulnerability point vulnerability condition evaluates exploit exploits payload executes arbitrary attacker code straight line program return exploit exploits payloads execution variants differ vulnerability condition satis polymorphic 
execution path pep coverage includes paths meps vulnerability point complete pep coverage includes paths vulnerability point complete pep coverage signature accepts inputs signature complete formally complete coverage obtained generating signature chop program includes instructions executed read statement exploit read vulnerability point chop distinguished nodes vinit nal vinit corresponds input read statement multiple input read statements exist vinit abstract node connected read statement control graph nal corresponds inlined vulnerability condition branch returning exploit outline algorithm computing chop section signature-creation algorithm initially begin mep path consisting instructions executing exploit trace compute program chop vulnerability vinit initial read sample exploit nal vulnerability point chop execution paths exploit read trace vulnerability point initially create signature mep path execution trace iteratively improve paths running mep coverage consists instructions executed trace complete pep coverage consists lines excluding line automatic vulnerability signature creation high level algorithm computing vulnerability signature program vulnerability condition sample exploit instruction trace depicted figure section detail perform steps pre-process program exploit received disassembling program section converting assembly intermediate representation section compute chop respect trace chop includes paths vulnerability point including sample exploit section compute signature compute turing machine signature section stop nal representation compute symbolic constraint signature signature section stop nal representation compute regular expression signature symbolic constraint signature section disassembling binary program con verting rst disassemble binary identify function boundaries require symbol table functions identi prologue epilogue convert disassembled instructions intermediate representation disambiguates instructions making implicit hardware side-effects explicit step seemingly straight-forward fairly involved main complication address modern architectures implicitly set test hardware registers affect program execution tests sets explicitly assembly automatically set executing arithmetic operation tested conditional jump complication register indexed modes lower bits eax register instruction affecting simultaneously affect eax concretely instruction set instructions perform hardware test set operations eflags register extra statements added operations ect updates hardware worse statements add speci mode operands architecture -bit mode -bit mode set depending format instruction operands add addition -bit mode registers speci -bits long carry implicit hardware-assisted effects set respect -bits similar instruction add eax ebx -bit mode implicit hardware effects respect -bits perform remaining steps program chopping vulnerability signature creation statements computing chop rst compute chop vulnerability respect exploit trace discussed section note chopping algorithm results imprecise chop lack pointer analysis result chop smaller program path begins read statement trace ends vulnerability point select signature generation step set paths compute signature perform chop program callgraph chop functions executed reading exploit vulnerability point chop performed essentially reachability analysis function call sequence reach vulnerability point included callgraph directed graph function vertex edges represent caller-callee relationship functions perform algorithm callgraph create chop start statement vinit read statement exploit trace vulnerability point nal trace finit nal functions enclosing vinit nal nodes note path finit nal appears trace add extra edge nal finit resulting loop callgraph calculate strongly connected component scc finit nal scc chop reachable functions finit nal create sigdisassemble convert constraint generationsymbolic execution constraintsolving exploit trace conditionvulnerability binary program signature generation phasepre-processing phase turing machine signature signaturesymbolic constraint signature regular expression compute chop select paths chop automatic vulnerability signature generation figure high level view steps compute vulnerability signature problem deal binary level widespread indirect jumps jmp eax indirect jmp bebefa direct note indirect jumps correspond source code constructs function pointers compiler-generated optimizations central issue target indirect jump potentially instruction result control graph including dependency graphs edge indirect jump instructions order deal widespread indirect jumps binaries pointer analysis creating callgraph make target indirect jump special node ijmp algorithm computing chop essentially ignore indirect jumps chop computed computing chop constrain indirect jump target chop limitation approach technically incorrectly excluding function appears target indirect jump indirect jump problem disappear implemented function pointer analysis remains unclear point future work precisely analysis pin targets indirect jumps computing signature compute signature respect chop compute pep signature iteratively single mep paths dataow analysis optimization iterative method works pick path set paths chop perform analysis output vulnerability signature complete pep coverage signature section analysis paths chop begin describing compute complete pep signature turn input symbolic constraint regular expression signature generation benign benign benign benign benign benign exploit figure mep signature run ning turing machine signature generation mep turing machine signature generation initial mep turing machine signature created respect path instruction trace initial signature match sample exploit exploit variants changing exploit payload create initial mep signature reading instruction trace including statements sequential instructions trace correspond sequential statements mep turing machine signature conditional branch statements targets signature creation benign exploit branch lead vulnerability point returns benign exploit returned vulnerability point reached vulnerability condition satis encode vulnerability condition function vulnerability point insert jump function nal check program vulnerable state returns exploit satis benign figure shows mep vulnerability signature return running vulnerability check inlined pep turing machine signature generation pep turing machine signature created similar mep turing machine signature pep signature rst computes chop computes jump targets lead vulnerability point standard graph reachability analysis paths terminate lead vulnerability point return benign insert call vulnerability condition function vulnerability point returns benign exploit figure shows complete pep vulnerability signature vulnerability condition inlined symbolic constraint signature generation symbolic constraint signature set constraints exploit vulnerability satisfy signature input symbolic constraint signature generation high level generate constraints represent meeting correct conditionals reach vulnerability point satisfy vulnerability condition symbolic constraint signature approximation signature statically estimate effects loops memory updates constraints input symbolic constraint system built symbolically evaluating signature program symbolic inputs actual inputs values formally build constraints based symbolically executing paths function signature represented control graph cfg direct graph ventry vexit instruction node transfer control instructions edge ventry vexit distinguished entry exit nodes conditionals control graph constraints branch reach vulnerability point satisfy vulnerability condition single static assignment ssa form convert single static assignment ssa form prior symbolic constraints step performed pre-processing phase memory locations registers destructively updated times lifespan program destructively updates right-hand side rhs assigning left-hand side lhs symbolic execution requires variable treated single logical entity assigned ssa form semantically equivalent form program satis criteria ssa form sequential statements unique renaming lhs control statements ssa introduces special assignment called -functions merges 
automatic generation analysis nids attacks shai rubin somesh jha barton miller wisconsin madison computer sciences department fshai jha bartg wisc abstract common elude signature-based nids transform attack instance nids recognizes instance misses avoid matching attack payload nids signature attackers split payload tcp packets hide benign messages observe attack instances derived simple transformations model transformations inference rules natural-deduction system starting exemplary attack instance inference engine automatically generate instances derived set rules result simple powerful tool capable generating attack instances nids testing determining sequence packets attack testing phases sets rules tool exposed vulnerabilities snort widely deployed nids attackers acquainted vulnerabilities construct instances elude snort tcp-based attack web-cgi attack attack signature type regular expression introduction goal network intrusion detection system nids alert system administrator time intruder penetrate network signature-based nids defines penetration malicious signatures ongoing activity matches signature alarm raised systems widely deployed simple provide concrete information events occurred weakness signature-based nids inability recognize attack attack signature attacker wishing stealthily penetrate network monitored signature-based nids exploit weakness ways attack signature nids attacks difficult find attack elude nids finding instance attack nids detect elude nids perform tcp reassembly attacker fragment attack signature tcp packets elude nids printable characters signatures attacker change signature http attack substituting equivalent hexadecimal ascii values characters url attacker find instance attack eludes nids nids useless study ability attackers find attack instances elude nids ability nids detect instances concrete translate abilities problems black hat problem nids instance attack find instance evades nids white hat problem instance attack sequence packets determine instance propose approach rigorously tackle problems observe variants attack methodically computed derived express attacker knowledge set inference transformation rules rule represents atomic transformation attacker hide attack signature starting attack instance inference engine successively apply rules automatically compute attack instances based combination rules finally deal black hat problem feed instances nids find undetected deal white hat problem check instance matches instances generated paper makes contributions agent nids testing attack analysis tool based notion attack derivation implemented agent attack generation nids testing tool agent addresses black white hat problems advantages unlike tools agent sound generating instances real attacks nids misses agent-generated attack nids vulnerable agent exhaustive capable generating attack instances instance set rules single instance evades nids agent find similarly agent show nids correctly identifies attack instances derived set transformations results show agent effectively finds nids vulnerabilities generating instances sequence packets agent provide proof sequence transformations obfuscation sequence real attack developers agent analyze attacks identify exact transformation nids fails handle attack derivation model computing attack instances formalized agent inference engine natural deduction system developed formal model computing attack instances model formalize black white hat problems model advantages model sound computes real attacks model exhaustive set transformations attack instance model computes attack instances derivable instance transformations model explanatory proof network event mutated attack event mutated attack proof sequence transformations links event attack instance event benign model asserts respect rules proof exist model agent appears insensitive derivation starting point starting points derive attack instances experience shows rules attacks paper starting point derives instances model applications testing knowledge formal method determine tcp sequence implements attack previously developed attack model formally defines notion tcp sequence implementing model computes tcp sequences implementing deriving initial instance transformations preserve semantics formal model essential examining capabilities single nids comparing capabilities nidss improving widely deployed nids agent found vulnerabilities snort exposed vulnerabilities tcp engine snort snort handles http requests pattern-matching algorithm attacker acquainted vulnerabilities caused snort miss tcp-based attack http scripting attack attacks require wildcard characters signatures foo bar reported suggested fixes vulnerabilities snort development team immediately fixed fixed future rest paper organized section presents related work section illustrates variants real attack derived presents agent architecture section discusses agent implementation section formalizes notion derivation natural deduction section presents vulnerabilities found snort demonstrates agent capability analyze attack instances related work review related work areas attack transformation nids evaluation counter evasion techniques protocol verification deductive databases attack transformation methods ptacek newsham semantics preserving tcp transformations elude nids tested implemented tool packet manipulation similarly handley paxson discussed evasion techniques based inherent ambiguities tcp protocol researchers systematically address nids evasion techniques unlike work research formal model combine transformations tool automatically tools mutate attacks originated work table discuss tools differ agent attack transformation tools attacktransformation tools combine multiple transformations fragroute mutates tcp-based attacks whisker mutates http attacks randomly combine transformations user nids testing limitations address work preserve attack semantics systematically search space attack instances miss instances elude nids snot stick mucus family packet-mutation tools snot stick synthesize raw network packet tcp packet matches snort signature mutated packet perform dos attack snort mucus hand nids testing tool synthesizes packets match snort signature writing random data packet fields required signature testing feeds packname generation capabilities sound transformations implemented handles white hat problem fragroute full-session tcp-based attacks subset transformations whisker full-session http attacks full-session tcp http transformations mucus single tcp udp packets single packet tcp udp transformations thor full-session attacks fragmentation agent full-session attacks full-session tcp finger http ftp table major tools attack variation testing methodology ets nids tools generate raw packets testing nids patternmatching mechanism nids ability detect udp based attacks tcp-based attacks nids produce alert tcp packet generated mucus hard nids discarded packet part tcp session scanned packet missed signature due vulnerability pattern matching algorithm comparison nids misses agent-generated attack necessarily case nids vulnerable agent mucus complement intend explore ways incorporate randomness agent work closest thor thor launches mutated attacks analyze detection capabilities set idss thor mutates attacks altering semantics based concept activity variations analogous semantics-preserving transformations conceptual level extend work developing computational model combine transformations systematic practice address issues work address handling inference transformations bounding number generated attacks thor implementation includes single transformation fragmentation agent implementation includes tcp application-level transformations tools mentioned ability find vulnerabilities agent discovered tools generate full tcp sessions expose vulnerabilities evasive rst table nids mechanism tracks state tcp session tools transport applicationlevel transformations expose vulnerabilities ftp padding table interaction nids mechanism handles tcp packets performs pattern matching concurrently work vigna developed tool combine transformations found vulnerabilities snort iss realsecure set transformations agent found 
vulnerabilities found vice versa unlike earlier work vigna investigate theoretical model systematically apply transformations address white hat problem applications attack transformations dacier noticed idss handle sets transformation methods developed tool evaluates potential set idss handle large set transformation methods manually identified methods ids supposed handle ids documentation prolog rules formulate knowledge automatically found set transformations set idss handle contrast test nids attacking analyzing potential capabilities wagner soto developed formal model based language theory find attack instances elude hostbased ids added system calls attack attack semantics preserved hids longer detect tan provide evidence theoretical model practice strongly support formal models intrusion detection knowledge provide formal model nids evasion type transformation scope paper code obfuscation recent research suggests identify transformations obfuscate viruses future intend explore ways integrate obfuscation transformations attack derivation model nids evaluation lippman present comprehensive effort evaluate ids capabilities critique mchugh compared capabilities idss detect set attacks contrast test single nids ability detect instances attack lee study ability nids handle packet loss due resource attack nids general packet loss semantics preserving transformation nids misses packet host accepts investigate paper fundamental limitation agent generating instances missing packets resisting evasion attacks handley shankar present techniques remove tcp ambiguities network connections techniques prevent evasive rst vulnerability found snort table knowledge methods widely deployed finally kruegel designed nids highly robust resource attacks agent implemented packet loss transformations testing system deductive databases security protocol verification protocol verification deductive systems model capability participants adversary security protocol techniques related approach deductive systems model power adversary improve agent performance intend explore techniques logic programs state-space reduction efficient bottom-up top-down evaluation approach overview illustrate main idea work instances attack systematically computed start examples attack instances ftp vulnerability illustrate instances variants instance derived repeatedly applying single step transformations present simple based real vulnerability discovered snort section present agent architecture based idea attack derivation vulnerability published buffer overflow commonly ftp server blackmoon ftp server windows can- exploiting overflow crash server present root privileges exploit overflow providing overly-long argument ftp cwd change directory command call attack ftp-cwd instance ftp-cwd present similar instances found hacker sites typical instance call ftp-cwdtyp fig phases tcp packets tcp handshake ftp login achieved anonymous login iii benign phase attacker browses server benign ftp commands attack phase attacker launches attack sending long cwd command illustrate derivation ftp-cwd instance present shorter instance ftp-cwd fig called root ftp-cwd denoted ftp-cwdroot respect rules derives ftp-cwd instances ftp-cwdroot instance victimatacker tcp handshakeftp login benign ftp comandscwd aahhh ftp login cwd aahhh victimatacker tcp handshake ftp-cwdtyp instance ftp-cwdroot instance figure ftp-cwd variants data successful ftp-cwd attack data condensed single tcp packet tcphandshake packets putting ftp messages required ftp-cwd user pass cwd single packet server response carry attack ftp application-level protocol indifferent number tcp packets deliver messages attacks considered paper implemented single packet computational model agent handle multi-packet attacks ftp-cwdtyp ftp-cwdroot attacker point view attacker exploit victim ftp-cwdtyp exploit victim ftp-cwdroot intuitively speaking infer ftp-cwdtyp ftp-cwdroot vice versa denotes tcp sequence denotes tcp sequence implements attack called instance transformation rules tcp-fragmentation instance attack obtained copying packets fragmenting single packet fragments instance ftp-padding instance ftp attacka consists malicious ftp command login cwd command ftp-cwd attack obtained inserting benign ftp command login malicious command quit command instance call rules semantics preserving alter semantics tcp specification legal fragment tcp packets desired knowledge ftp attack inflated padded benign ftp commands exist ftp attack padded packets fragmented rules changed legal modifications ftp-cwdroot instance ftp-cwd attack derive conclusion ftp-cwdtyp instance ftp-cwd apply ftp-cwdroot fragment single attack packet ftp login packets malicious cwd packet ftp-cwdtyp apply add benign ftp commands attack natural deduction terminology ftp-cwdtyp derived ftp-cwdroot rules formally write ftp-cwdroot ftp-cwdtyp observations noted process illustrated define closure subset ftp-cwd instances derive ftp-cwdtyp instance instances ftp-cwd rules derive instance ftp-cwd benign ftp commands fragmented tcp packets observation motivates automate derivation process enables identification ftp-cwd instance category generation instances nids testing purposes interference derive ftp-cwdtyp fragment attack add ftp commands add commands fragment attack observation simplifies practical implementation agent section theoretical aspects formal derivation model section inference process bi-directional shrinking rules de-fragmentation removal padding easy ftp-cwdroot derived ftp-cwdtyp bi-directional property suggests derivation process start attack instance finding instances elude nids overly sensitive derivation starting point observation section define starting points attack derivation model translate observations practice built agent tool derives attack instances representative instance attack set transformation rules agent address black white hat problems section agent comprised components fig closure generation set rules attack instance agent computes root instance ftp-cwdroot fig generates instances derived root instance represented list tcp packets attack response packets instances stored file passed stage figure agent architecture eluding-instance search stage finds attack instance eludes snort perform search implement instance simulator successively writes instances network simulator machine installed snort reads network search stops undetected instance found instances checked implemented simulator libraries construct raw tcp packets simulator plays complete tcp sessions including tcp handshake attacker victim packets termination procedures simulates average instances pentium iii mhz instance feasibility check machines connected lan separate attacker victim stage instance simulator send attacker packets victim responses generated real application strictly speaking stage unnecessary agent sound include validate methodology illustrate attacks found work wild agent implementation discuss core components agent describe implementation agent inference engine present transformation rules constructed attack instance start derivation process discuss customized inference-engine address black white hat problems inference engine implemented agent inference engine prolog starting set facts prolog program applies set inference rules successively generate facts implementation represents root instance prolog fact inference rules prolog rules prolog rule specifies set conditions conjunction hold derive conclusion rule conditions hold conclude tcp packets fragments packet represent attack sequence tcp packets attack packets attacker response packets victim choose tcp sequence represent attack majority attacks tcp snort rules target tcp communication representation exposes tcp parameters application data easy manipulate attacks tcp transformations application-level transformations tcp representation essential agent easy define transformation rules representations udp packets inference rules agent inference rules tcp sequence implements attack returns sequence implements inference rules definition sound produce sequence implements soundness ensures agent derives instances real attacks experience defining sound 
nitions variable if-then-else statement assigned true branch false branch mep symbolic execution perform mep symbolic execution evaluating mep signature recall mep signature straight-line program single path ventry vexit vulnerability point vulnerability condition paths end returning benign considered result symbolic execution set constraints input variables met results execution ventry vulnerability point inlined vulnerability condition vexit begin creating symbolic input variables length symbolic input initially length sample exploit statement executed inputs resulting symbolic formula step fundamental operation types evaluate symbolically memory updates arithmetic operations branch predicate evaluation symbolic execution arithmetic operations simply substitution procedure memory store operation assignment symbolic memory location stack heap assignments handled uniform fashion adopt model similar uclid handling memory updates initial state reads writes modeled expressions write memory location yields addr ite addr addr result write if-then-else ite expression subsequent read behaves address read applied argument write expression supplied address matches returned recurse memory address addr loss generality assume branch predicate jump equal jump evaluates true order create desired total path branch predicate forms arithmetic constraint expressions involving memory reads writes relating symbolic execution constant jump results constraint constraints evaluate constant machine instructions comparison expression constant total symbolic formula conjunction branch predicate constraint system consisting conditions branch predicate returned desired signature optionally constraint systems simpli consists deducing multiple constraints collapsed single constraint pep symbolic execution pep symbolic execution similar mep case deal loops loops handled computing xed points dataow analysis widening operator guarantee iteration compute xed-point terminates algorithm handle loops identify induction variables chapter loop induction variable rst loop figure compute bounds induction variable bound induction variable assume induction variable index input array condition loop condition loop bounds induction variable desired result rst loop figure condition generated regular expression signature generation computing mep regular expression signatures method generating regular expression solve constraint system set or-ing members regular expression method explored heavily test-case generation literature adopt approach problem setting divide-and-conquer number variables single path large millions variables assembly level address reader notice expression precise solution precise answer precise symbolic representation symbolic representation unrolls loop regular expression signature ect inputs loop executed time problem decomposing mep single-path solution smaller sub-paths independently ventryv vexit mep path sub-path sequence instructions vivi cfg subpath independently evaluated respect sub-path computation affect computation vice-versa formally partition partition data dependencies sub-path data dependency exists computes computation sub-path affect computation sub-path sub-path independently solved nal solution combined solution sub-path computed solving constraint system sub-path full path conjunction sub-paths mep solution approach divide single mep possibly smaller sub-problems mep path correspond evaluating symbolic input order sub-paths independent reorder sub-paths case signature mep concatenation solution sub-path solution resulting signature computing pep regular expression signatures approaches computing pep solution rst method considers mep path pep independently solves symbolic constraints method optimization based dataow analysis applied portions pep controlow graph conditions stated met dataow analysis optimization works basic blocks paths require access constraint solver exact pep solution pep solution iteratively explores paths solves mep solution note practice create initial mep signature sample exploit process paths background approach generates initial narrow signature quickly continues perform analysis pep dataow optimization cases determine data dependencies partition vulnerability components cfg components direct comparisons input values protocols keywords constant values speci elds input simply compared dataow analysis ciently compute language accepted components component data dependencies components solution component inlined complete pep mep solution high level dataow analysis iteratively processes cfg xed point dataow facts reached dataow analysis widely compilers highly cient dataow analysis combines regular expressions accepted basic block block contiguous instructions single entry exit point regular expression accepted entire component due space constraints give rough overview dataow analysis leave discussion extended version paper high level cfg edge labeled set dataow facts case regular expression accepted basic block true edges negated regular expression false edges key component dataow analysis meet operator summarizes multiple incoming edges node combined combining regular expression point con uence incoming edges operator states combine regular expressions con uence point con uence point corresponds regular expression running instructions line analyzed independently dataow analysis resulting regular expression gjg rst byte input note realistic programs larger components amenable dataow analysis evaluation implementation implemented prototype system evaluate techniques automatically generating signatures section brie discuss implementation details prototype present evaluation results evaluation results show mep vulnerability signature higher quality signatures generated previous approaches focus creating regular expression signatures require generation turing machine symbolic signature implementation total prototype implementing techniques lines code cbmc bounded model checker build solve symbolic constraints produce regular expression signatures disassembling program converting obtaining instruction traces binary program disassembler based kruegel translate instruction statement translation language instruction traces ciently generated modern architectures including hardware software instruction trace instruction address optionally operands instruction executed number instructions executed large trace ciently represented pin create traces solving constraint system model checking solve system constraints translate constraints constraints variables cbmc assert model checker vulnerability condition unsatis model checker verify vulnerability condition unsatis solve constraint system present counter-example construction satisfying input process iterated exhaustively enumerate satisfying inputs exploits regular expression signature satisfying inputs process slow input byte values apply widening operator byte appears unconstrained iterations wild-card byte widening step introduce false positives eliminated desired show precise regular expression signature generation reduced model checking problem extended version paper exploring precise generation techniques techniques work practical examples theoretically limited area future work implementation limitations current implementation prototype researching automatic signature generation prototype works research setting number limitations mentioned previously alias analysis supported specifically assume memory locations aliases addition imprecision introduce symbolic execution limitation prevents computing true chop current callgraphbased chopping algorithm precise true chop source code fact primarily model checker primarily results larger mep pep coverages create sub-paths based controlow based analysis accurately identify sub-paths independent section finally transformations handle oating point operations support entire instruction set add operations needed experiments limitations orthogonal problem resolved implementing techniques manually verify problems introduce errors results mep evaluation atphttpd atphttpd webserver written atphttpd version vulnerable common sprintf-style bufferover http request long speci cally exploit atphttpd vulnerability meet conditions http request method caseinsensitive head rst byte requested requested lename substring end requested lename characters long 
exploit sample consists request shell code http protocol string http experiment vulnerability condition atphttpd pointer write return address signature result quality generated symbolic constraints partitioned distinct subpaths analyzed independently solved constraints create regular expression average time partition taking generated regular expression signature gjg eje tjt regular expression perfect conditions reach vulnerability stated previously recognizes keyword case insensitive bytes bytes constraints signature contained exploit explicitly tested mep vulnerability path exploit contrast signature previous exploit-speci signature generation approaches identify small parts signature match exploit variants crashes server injecting code signatures catch exploit variants single exploit sample bind bind popular dns servers bind supports secret key transaction authentication mechanism messages signed transaction signature tsig bind susceptible stack vulnerability tsig processing code attacker send valid dns transaction signature request order exploit vulnerability dns binary-based protocol messages struct-like dns exploit tcp udp-based udp protocol messages dns messages begin header number resource records exploit vulnerability satisfy conditions request query represented byte message questions present meaning eld number questions byte offsets greater properly encoded questions starting offset eld number additional resource records byte offsets greater dns resource record type eld set tsig dns resource records single request speci byte offset eld function elds request tsig vulnerability exploit lion worm sample exploit signature result quality generated symbolic constraints partitioned distinct graphs independently analyzed generated regular-expression signature speci bytes bytes end query exploit byte rst byte rst query nally bytes byte beginning additional resource records section eld type tsig verify constructed signature identi constraints met exploit vulnerability veri falsepositive rate signature matching dns requests trace high-traf dns server serves top level domains false positives pep evaluation chop atphttpd found functions reachable accepting connection vulnerability point including libraries mentioned previously technique generating pep signature mep path independently technique estimate effects multiple paths simultaneously current prototype implementation technique limited moderate-sized functions atphttpd bind vulnerabilities extremely large library function consists thousand basic blocks addressing scalability issues important part future work expect existing state reduction techniques model checking solve problem evaluate pep techniques synthetic examples compile running binary calculate full pep solution regular expression generated gjg total time compute answer seconds alternatively tool produce regular expression independent component pep dataow facts produce nal signature setting tool runs slightly faster perform symbolic evaluation paths discussion provide extensive analysis including proofs hardness signature creation dataow framework extended version paper application scenarios high level techniques generate input string reaches instruction binary applications techniques plan investigating include improve existing pattern-extraction signature generation algorithms quality signature generated pattern-extraction techniques generally improves number exploit samples increase techniques iteratively generate exploit sample sample exploit scenario give pattern-extractor labeled exploit improve existing signature note previous scenarios pattern extraction limited addition label tokens analysis finally note analysis defend red-herring coincidental token attacks perform robust vulnerability identi cation bug exploitable developer set vinit read statement nal line bug techniques generate sample exploit con rming bug exploitable vendor patches miss paths vulnerability missing alternate paths security problem embarrassment vendor patched systems compromised techniques adapted patch covers ways vulnerability exploited complete unsound signatures satisfying solution generated symbolic equations exploit string signature sound complete complete potentially unsound signature false negatives false positives created setting initial signature removing input leads benign state identifying sources signature imprecision construction signature creator tune accuracy generation time ways creator choice signature representations creator choose information retain expressive representations creating symbolic representation creator choose times loops unrolled creator choose analysis perform creating regular expression signature theorem proving employed enumerate input string exploit program faster accurate dataow analysis choices creator gain fundamental understanding accuracy nal generated signature comparing generated signature perfect signature related work signature creation section detailed previous work area mention vigilante independently proposed signatures essentially straight-line programs regular expressions mep symbolic constraint signatures vigilante creates signature execution path sample exploit explore extensive coverages vulnerability signature representations estimating language classes signi part creating vulnerability signature boils conservatively estimating higher-powered language turing machine lower-power language regular expression techniques provide accomplishing mohri nederhof present algorithm converting context-free languages regular expressions unaware signi work area program analysis static analysis techniques symbolic execution abstract interpretation model checking theorem proving dataow analysis program slicing areas active research area bene advanced techniques impossible note related work static analysis reader referred overview subject automatic test case generation research explores problem automatically creating input reaches point program interested similar problem approximate inputs reach location problem setting relaxed tolerate signatures false positives negatives closely related area static analysis program generated string expressions line work aims discovering strings generated opposed accepted program christensen performed string analysis java programs type information christodorescu extended christensen work binaries techniques exciting research needed apply techniques problem setting approach handles strings types integers conclusion presented general framework obtaining type signature called vulnerability signatures single sample exploit presented techniques automatically generating signature higher quality previous approaches addition formulation opens wide variety signature representations discuss distinct types vulnerability signature representations turing machine symbolic constraints regular expressions provide theoretical practical insights signature representations conclude approach promising alternative exploitcentric techniques dynamorio http cag lcs mit dynamorio admmutate http ktwo admmutatetar metasploit http metasploit aho sethi ullman compilers principles techniques tools addison-wesley publishing company bosch carloganu etiemble complete instruction trace generation hardware bus collect ieee euromicro conference bourdoncle cient chaotic iteration strategies widenings proc international conference formal methods programming applications lncs brumley liu poosank song design space analysis worm defense systems proc acm symposium information computer communication security asiaccs cmu cmu-cs- brumley newsome song wang jha automatic generation vulnerability-based signatures technical report cmu-cs- carnegie mellon bryant lahiri seshia modeling verifying systems logic counter arithmetic lambda expressions uninterpreted functions proc computer-aided veri cation cav cadar engler execution generated test cases make system code crash technical report cstr- stanford cerrudo story dumb patch http argeniss research msbugpaper pdf cert isc bind buffer transaction signature tsig handling code http cert vuls christensen ller schwartzbach precise analysis string expressions proc international static analysis symposium sas volume lncs pages springer-verlag june http brics jsa christodorescu kidd goh string analysis binaries proc acm workshop program analysis software tools engineering paste clarke grumberg peled model checking mit press clarke 
kroening lerda tool checking ansi-c programs jensen podelski editors tools algorithms construction analysis systems tacas volume lecture notes computer science pages springer cost crowcroft castro rowstron zhou zhang barham vigilante end-to-end containment internet worms acm symposium operating system principles sosp cousot cousot abstract interpretation uni lattice model static analysis programs construction approximation xpoints proc acm symposium principles programming languages popl jan crandall chong deriving unknown vulnerabilities zero-day polymorphic metamorphic worm exploits proc acm conference computer communications security ccs detlefs nelson saxe simplify theorem prover program checking technical report hpl- labs detristan ulenspiegel malcom underduk polymorphic shellcode engine spectrum analysis http phrack show php godefroid klarlund sen dart directed automated random testing proc international conference programming language design implementation pldi gotlieb botella rueher automatic test data generation constraint solving techniques acm symposium software testing analysis gotlieb botella rueher clp framework computing structural test data international conference computational logic gupta mathur soffa automated test data generation iterative relaxation method acm sigsoft symposium foundations software engineering hopcroft motwani ullman introduction automata theory langauges computation addisonwesley jackson rollins chopping generalization slicing proc acm sigsoft symposium foundations software engineering jordan dealing metamorphism virus bulletin magazine kildall uni approach global program optimization acm symposium principles programming languages popl kim karp autograph automated distributed worm signature detection proc usenix security symposium august king symbolic execution program testing communications acm kreibich crowcroft honeycomb creating intrusion detection signatures honeypots proc workshop hot topics networks hotnets-ii november kruegel kirda mutz robertson vigna polymophic worm detection structural information executables rapid advances intrusion detection raid kruegel robertson valeur vigna static disassembly obfuscated binaries proc usenix security symposium liang sekar fast automated generation attack signatures basis building self-protecting servers proc acm conference computer communications security ccs locasto wang keromytis stolfo flips hybrid adaptive intrustion prevention proc international symposium recent advances intrusion detection raid luk cohn muth patil klauser lowney wallace reddi hazelwood pin building customized program analysis tools dynamic instrumentation proc programming language design implementation pldi conference june milenkovic milenkovic kulick n-tuple compression method compression branch instruction traces proc international conference parallel distributed computing mohri nederhof robustness language speech technology kluwer academic publishers moore shannon voelker savage internet quarantine requirements self-propagating code ieee infocom conference muchnick advanced compiler design implementation academic press nethercote seward valgrind program supervision framework proc workshop runtime veri cation boulder colorado usa july newsome karp song polygraph automatically generating signatures polymorphic worms proc ieee symposium security privacy newsome song dynamic taint analysis automatic detection analysis signature generation exploits commodity software proc annual network distributed system security symposium ndss february pierce types programming languages mit press code atphttpd exploit http cotse mailing-lists todays att-atphttp ramin atphttpd http redshift yramin atp atphttpd reps rosay precise interprocedural chopping proc acm sigsoft symposium foundations software engineering sandon liao cook schultz nicolas nstrace bus-driven instruction trace tool powerpc microprocessors ibm journal research development singh estan varghese savage automated worm ngerprinting proc acm usenix symposium operating system design implementation osdi dec staniford paxson weaver internet spare time usenix security symposium szor hunting metamorphic virus bulletin conference uhlig mudge trace-driven memory simulation survey acm computing surveys us-cert vulnerability note isc bind buffer transaction signature tsig handling code http cert vuls vixie gudmundsson eastlake wellington rfc secret key transaction authentication dns tsig http ietf rfc rfc txt wang guo simon zugenmaier shield vulnerability-driven network lters preventing vulnerability exploits proc acm sigcomm conference august weiser programmers slices debugging communications acm ning kil zhai bookholt automatic diagnosis response memory corruption vulnerabilities proc acm conference computer communication security ccs 
rules difficult task issues defining rules attack application-level protocol ftp rules section sound respect http attacks rule set specific application-level protocol operating system victim host protocol semantics depend implementation rule preserve semantics operating systems customize rule set operating system sounds complex practice easy process differences operating systems affect small number inference rules network transport levels interference rules rule preserves semantics applied preserve semantics applied rules find application-level transformation interferes transport level encountered interference tcp level tcp-permutation rule permutes packets sequence tcp-retransmission rule adds retransmitted packets sequence interference occurs define retransmitted packet appears original packet permute packets address issue section transformation define rules expanding shrinking rules shrinking rule reverses effect expanding rule vice versa adding benign ftp command expands ftp attack removing commands shrinks transformations change attack length sending tcp packets out-of-order artificially assign expanding rule tcp-permutation shrinking tcp-sorting overly shrinking attack change semantics applying shrinking rule require checking preconditions expanding rule instance rule removes ftp commands ensure remove malicious command building set inference rules time effort single set shared attacks application-level protocol amortized cost effort low cases specific rule unsound respect specific attack http-space-padding rule table nullify buffer overflow attack requires http request length envision large set rules distributed agent soundness rule respect attack consideration experience straightforward manner table summarizes tcp application-level rules supported agent detailed rule descriptions earlier report tcp level cover transformations fragmentation outof-order transmission permutation retransmission header change push flag change developed transformations application-level protocols ftp http andfinger chose ftp http common finger agent development simplicity finger exposed evasive-rst vulnerability snort section ensure soundness simulated attack instances evaded snort real servers bsd finger apache http server verified work rules unique add victim tcp acknowledgments part transformations nids performs stateful tcp inspection acknowledgments update internal tcp state orderings attack packets acknowledgments induce tcp states limited ability influence ordering attack packets victim acknowledgments attacker create ordering induces tcp state nids misses attack snort evasive-rst vulnerability section technical details added acknowledgments earlier report note issue victim responses tcp application levels part transformation fully investigated derivation starting point derivation process starts attack instance called root attack instance compute root successively applying shrinking rules rules applied general inname description tcp fragmentation fragments attack packet packets adds victim acknowledgment packet permutation permutes packets tcp stream sound permutation preserves original order attack packets victim responses interference tcp-retransmission handled section retransmission family rules add retransmitted attack packet original stream focused retransmission evasive rst packets packet retransmitted rst flag set header change family rules change header attack packet practice paper application finger padding adds spaces username ftp padding adds benign ftp commands malicious command rule adds cwd tmpnn list quit preserve semantics http space padding insert spaces http method http request url url http multiple requests adds benign http requests malicious request cmd exe benign commands index html connection close option attack semantics http url encode substitute printable characters url equivalent ascii values practice paper table agent inference rules expanding rules shown stances attack produce roots root instance unique depend application order shrinking rules attacks rules paper found unique root common attack instances discuss formal requirements shrinking rules definition roots section customizing inference engine black hat customizations agent enables derivation infinite number instances practice number instances feed nids finite select finite subset instances high probability finding vulnerabilities common strategy construct subset testing technique called equivalence partitioning technique splits test cases classes class represents cases exercise features software testing attack transformations represent features nids handle define class combination transformations derive instances techniques implement equivalence partitioning strategy apply inference rules depth-first order apply application level rules independent transport rules fragment instance permute instances add retransmitted packets fig order ensures instances derivation path belong classes apply tcp-retransmission tcp-permutation order resolves interference rules section prune derivation paths prevent generation large number instances class prune instances change attack fragmented fragment packets shorter bytes split testing process phases transformations instances phases belong classes strategy impairs agent exhaustiveness experimental results show effective find nids vulnerabilities section white hat customizations white hat settings goal find derivation path root instance exists start root derive instances hit instance approach ineffective difficult determine stop searching instance root instances section search infeasible white hat settings agent performs bottom-up search shrinking rules shrinks instance hits root shrinking case manually determine found root instance implement attack formal model attack derivation agent inference engine generalized computational model deriving attack instances computational model based natural deduction formally define black white hat problems discuss model applications nids testing natural deduction system pair set facts set inference rules sysa figure application order inference rules node represents generated instance black hat setting expanding rules table tem enables derivation facts applying inference rules facts fact derives fact denoted derivation sequence fni result applying derivation rule derivation sequence fni terminates rule applied ensure finite number derivation starting points make assumptions rules rule expanding shrinking version section shrinking version rule increase length bytes instance derivation sequence shrinking rules cycles note assumptions hold rules describe paper assumptions hold general investigation validity left future work set attack instances ang define derivation starting points roots intuitively root compact simple representation formally root instance terminates derivation sequence shrinking rules starts assumptions previous paragraph ensure sequence starts terminates set roots finite denote set roots roots set instances roots formally define derivation model attack black white hat problems readability definitions based single attack instance trivially extended set instances definition derivation model attack instance attack set sound inference rules respect derivation model natural deduction system hroots closure derivation model denoted roots set tcp sequences derived roots rules definition nids view nids view respect attack denoted san set tcp sequences recognizes definition black hat problem hroots attack derivation model nids san view respect black hat problem find tcp sequence derivable roots san formally find roots nsan definition white hat problem hroots attack derivation model tcp sequence white hat problem determine roots properties attack derivation model attack envision derivation model respect set rules sound derives tcp sequences implement complete derive tcp sequence implements decidable tcp sequence algorithm determines sequence derived root black hat problem soundness means instance 
discover evades nids implies vulnerability nids completeness means eventually model generate instances evades nids white hat case soundness means lack false positives completeness means lack false negatives decidability important solve white hat problem derivation model sound definition require rules combinations sound respect inferences rules explore paper model decidable section decidable general code obfuscation rules model undecidable prove completeness show derivation model computes tcp sequences adhere formal definition notion tcp sequence implements knowledge formal definition exist proving completeness derivation model inductively define implementing tcp sequence implements derived tcp sequence implementsa expert determines induction base tcp sequence implementing transformation rules preserve semantics model defines set tcp sequences implement formalism notion implementing crucial studying understating nids capabilities formal model defining attack instances developed model formal compare model agent practice present results agent nids testing attack analysis nids testing agent agent generate instances attacks feed snort snort missed instance stopped investigated snort code find reason generated instances attacks finger-root gain root sensitive information victim cve- perl-in-cgi execute arbitrary commands web server can- iii ftp-cwd buffer overflow gain root access ftp server can- description implications eludes snort evasive rst snort accepts out-of-window tcp rst packet stops tracking live tcp connection tcp-based attack fixed snort flushing snort misses signature fragmented tcp packets attack signature inflated application-level rule http space padding exploits snort default configuration nature report single alert tcp packet snort misses attack generates general alert perl-in-cgi alert web-cgi attack default configuration snort misses attack user-defined configuration snort generates general http alert specific alert attack http multiple requests snort analyzes single http request tcp packet web-cgi attack fixed snort ftp padding snort recognize type regular expressions attack signature foo bar fixed snort concurrently work sommer paxson reported vulnerability table snort bugs found agent earlier report details attack tested agent found instances eluded snort instances exposed vulnerabilities sections snort code tcp engine http decoder pattern matching mechanism vulnerabilities fixed fixed upcoming releases snort table presents summary vulnerabilities testing effort exposed chose snort target nids reasons snort signatures easy find signatures chosen attacks snort considered state-of-the-art nids snort performance comparable commercial nids aware evasion techniques reported past snort techniques tcp reassembly http encoding ttl checks balanced data structures maintained regularly assumed non-trivial find instances elude testing effort summary based equivalencepartitioning testing strategy section performed total testing phases yielded vulnerabilities started simple attack rule set derived small number instances cover classes phase added rules agent changed attack table presents summary test phases phases finger-root transport rules phase agent exposed evasiverst vulnerability continued finger-root attack added finger-padding rule rule yield vulnerabilities phase combining transport rules exposed flushing vulnerability phase continued perl-in-cgi http rule exposed vulnerability snort http decode engine phases finally tested snort instances ftp-cwd attack discovered ftp padding vulnerability phase agent success finding vulnerabilities arises combination features agent sound generates instances real attacks tested millions instances waste time determining tcp sequence real attack agent generates instances set rules generates subset instances based feature testing section finds vulnerabilities exposed small number instances phase agent exposes vulnerabilities requires combination transport application level transformations phase phases illustrate implications agent exhaustiveness phases agent generates instances set rules pruning phase snort identifies instances assert snort correctly reassembles tcp streams characters phase assert snort pattern matching algorithm correctly ignores spaces signature simple claims provide important information snort reliability knowledge reliability claims unknown context network intrusion detection hope future agent assert complex properties agent limitations phase agent found instance eluded snort generating million instances uniformly samphase attack rules table generated instances eluding instances vulnerability discovered table finger-root finger-root evasive rst finger-root finger-root flushing perl-in-cgi http space padding perl-in-cgi http multiple requests ftp-cwd ftp padding table testing effort summary ple instances derived phase found instance samples observation suggests improve agent efficiency random sampling methods attack analysis agent report bug nids includes trace packets captured tcpdump demonstrates attack nids misses task nids development team verify trace real attack demonstrated agent automate task created ftp-cwd attack instances randomly applying ftp-padding tcp-fragmentation tcp-permutation tcp-retransmission rules table ftp-cwdroot instance fig ftp-cwdroot instance bytes single tcp packet handshake packets instance average bytes packets duplicated instances created benign benign instance changed byte nullify attack changed sequence number packet packets reassembled obtained instances real attacks agent white hat tool section distinguish attack benign instances attack instance agent found derivation sequence root seconds average length rules benign instance agent exhaustively searched derivation sequence find average search seconds essentially agent proved respect rules paper benign instance real attack experiment illustrates agent ability analyze complex attack instances manually distinguishing instances required tremendous effort automate process nids crosstesting technique technique provide sequence transformations obfuscate attack assert sequence exist future work expanding knowledge-base rules exploring link transport payload level rules model attackers knowledge intend investigate code obfuscation rules enable attackers change binary code network exploits intend explore techniques proving rules cover ways modify attack intend explore usages attack derivation model model partition attack instances families transformations create characterize compare nids based mutations handle acknowledgments marc dacier jon giffin dennis gopan brian fields vinod ganapathy anonymous reviewers comments earlier draft paper digital information society phreak alessandri editor taxonomy intrusion detection systems attacks ibm zurich research laboratory september deliverable project maftia ist- maftia baker barnyard caswell poor alder babbin beale doxtater foster kohlenberg rash snort intrusion detection syngress edition christodorescu jha static analysis executables detect malicious patterns usenix security symposium washington august crosby wallach denial service algorithmic complexity attacks usenix security symposium washington august dacier editor design intrusion-tolerant intrusion detection system ibm zurich research laboratory august deliverable project maftia ist- maftia debar morin evaluation diagnostic capabilities commercial intrusion detection systems international symposium recent advances intrusion detection zurich switzerland october detristan ulenspiegel malcom underduk polymorphic shellcode engine spectrum analysis phrack online magazine august dietrich extension tables memo relations logic programming international conference symposium logic programming san francisco august fielding gettys mogul frystyk masinter leach berners-lee rfc hypertext transfer protocol internet engineering task force june giovanni fun packets designing stick march endeavor systems handley paxson network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington august internet security systems realsecure 
network http iss net kruegel valeur vigna kemmerer stateful intrusion detection high-speed networks ieee symposium security privacy oakland lee cabrera thomas balwalli saluja zhang performance adaptation real-time intrusion detection systems international symposium recent advances intrusion detection zurich switzerland october lippmann haines fried korba das analysis results darpa off-line intrusion detection evaluation international symposium recent advances intrusion detection toulouse france october lippmann fried graf haines kendall mcclung weber webster wyschogrod cunningham zissman evaluating intrusion detection systems darpa off-line intrusion detection evaluation darpa information survivability conference exposition hilton head january marti thor tool test intrusion detection systems variations attacks master thesis swiss federal institute technology march mchugh testing intrusion detection systems critique darpa intrusion detection system evaluations performed lincoln laboratory acm transactions information system security november meadows model computation nrl protocol analyzer ieee computer security foundations workshop csfw franconia june mitre corporation cve common vulnerabilities exposures cve mitre mutz vigna kemmerer experience developing ids stimulator black-box testing network intrusion detection systems annual computer security applications conference las vegas december myers art software testing john wiley sons edition paulson mechanized proofs security protocols needham-schroeder public keys technical report cambridge computer laboratory paxson bro system detecting network intruders real-time computer networks december postel rfc transmission control protocol internet engineering task force sept postel reynolds rfc file transfer protocol internet engineering task force prawitz natural deduction proof-theoretical study almquist wiskell ptacek newsham custom attack simulation language casl sockpuppet tqbf casl html ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks calgary alberta canada rain forest puppy whisker antiids tactics bad ruin good thing december wiretrip net rfp txt whiskerids html ramakrishnan srivastava sudarshan efficient bottom-up evaluation logic programs computer systems software engineering state-of-the-art kluwer academic publishers june roesch snort open source network intrusion detection system snort rubin jha miller attack generation nids testing natural deduction technical report wisconsin madison january schiffman libnet library portable packet creation injection packetfactory net libnet security administrator newsletter instant poll snort implement intrusion detection system ids network october http winnetmag poll shankar paxson active mapping resisting nids evasion altering traffic ieee symposium security privacy oakland shmatikov stern efficient finite-state analysis large security protocols ieee computer security foundations workshop csfw rockport june sniphs snot january stolenshoes net sniph index html sommer paxson enhancing byte-level network intrusion detection signatures context acm conference computer communications security washington october song fragroute tcp fragmenter april monkey dugsong fragroute sterling shapiro art prolog mit press tan killourhy maxion undermining anomaly-based intrusion detection system common exploits international symposium recent advances intrusion detection zurich switzerland october tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding noordwijkerhout netherlands oct nss group intrusion detection systems ids group test edition december nss ids edition index htm nss group intrusion detection systems ids group test edition nss ids edition index htm tcpdump group tcpdump libpcap tcpdump vigna robertson balzarotti testing networkbased intrusion detection signatures mutant exploits acm conference computer communications security washington october wagner soto mimicry attacks host-based intrusion detection systems acm conference computer communications security washington november zimmerman rfc finger user information protocol internet engineering task force december 
generalized authorization problems schwoony jhaz repsz stubblebinex abstract paper defines framework formalize variety authorization policy issues arise access control shared computing resources instantiations framework address issues privacy recency validity trust paper presents efficient algorithm solving authorization problems framework approach yields algorithms number specific authorization problems introduction main issues access control shared computing resources authentication authorization enforcement identification principals handled authentication authorization addresses question request specific principal allowed enforcement addresses problem implementing authorization execution centralized system authorization based closed-world assumption authorized parties trusted distributed system parties priori closed-world assumption applicable trust management systems address authorization problem context distributed systems requiring authorization access-control policies defined explicitly specification language rethis work supported part national science foundation grant ccrby office naval research contracts alexander von humboldt foundation government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government yinstitutsverbund informatik universit stuttgart breitwiesenstr stuttgart germany e-mail schwoosn informatik unistuttgart zcomp sci dept univ wisconsin dayton madison e-mail fjha repsg wisc xstubblebine research labs llc wayne blvd madison e-mail stuart stubblebine lying algorithm determine specific request allowable survey trust management systems formal framework understanding presented trust management systems binder keynote referee spki sdsi proposed work presented context spki sdsi aspects approach carry trust management systems authorization frameworks spki sdsi principals public keys identity principal established checking validity public key spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations fundamental problem spki sdsi trust management system authorization problem defined security policy spki sdsi represented set authorization certificates principal access resource certificate-chain discovery refers problem finding proof access resource case spki sdsi proof chain certificates found proof presented checks validity proof proof valid allowed access algorithms certificate-chain discovery frameworks proof-carrying authorization efficient algorithm spki sdsi presented clarke improved algorithm presented jha reps algorithm based translating spki sdsi certificates rules pushdown system demonstrated translation enables questions answered security policy expressed set certificates paper generalize pushdown-systems approach enable address important security-policy issues privacy recency validity trust instance authorization suppose company additional insurance cover prescription-drug expenses covered patient health-maintenance organization hmo hmo high deductible drugs covered additional insurance company provide service patients hospital alice buy insurance prove patient suppose certificate chains prove alice patient reveals alice patient internal-medicine clinic reveals alice patient aids clinic obvious reasons alice prefer chain words alice prefers certificate chain reveals amount information privacy-related issues addressed generalized framework context spki sdsi assume metric certificate chains proofs authorization details metric depend specific issue addressed generalized authorization problem gap principal set authorization certificates resource metric certificate chains question gap addresses authorized access resource authorization proof solves gap minimizes maximizes metric depending application demonstrate security-policy issues trust management systems cast gaps metrics demonstrate extension pushdown systems called weighted pushdown systems solve generalized authorization problems algorithm solving gaps thought generalization algorithm general strategy set labeled spki sdsi certificates translated weighted pushdown system translation answer obtained solving generalized shortest-path problem main contributions work reported paper gap framework define generalized authorization problem show versions types security issues related authorization handled gap framework efficient algorithm solving gaps present efficient algorithm solving gaps yields algorithms number specific authorization problems prototype implementation algorithms paper implemented library functionality solving gaps liin gap certificate labeled label depend global property recency policies certificate represents time certificate issued current brary made internet parties remainder paper organized section background spki sdsi section defines gap framework discusses applications section background pushdown systems pdss section reviews connection spki sdsi pdss section defines weighted pdss shows analysis transition system defined weighted pds solve gaps section returns discussion applications gap framework section discusses related work appendix describes enhancement algorithm section generate witnesses proofs authorization background spki sdsi principals names spki sdsi principals represented public keys principal public key principal individual process host active entity denotes set public keys specific keys denoted identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates spki sdsi types certificates certs certificates certs cert definition local issuer local space key issue sign cert defines local space cert signed fourtuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification certificate takes form interval cert valid time inclusive validity specification form on-line check performed authorization certificates auth certs auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert subject term delegation bit turned subject receiving authorization delegate authorization principals authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert request triple consisting principals resource access authorization specification exercise goal certificate-chain discovery prove request valid clarke remove useless certificates remove auth cert invalid validity specification expired validity specification remove auth cert imply authorization specification request rest paper assume request set certificates useless certificates treat certs rewrite rules cert written auth cert written delegation bit turned written authorization problems valid certificates validity specification certificate part rewrite rule generalized authorization problems derive weights rules authorization problem spki sdsi traditional discretionary access control protected resource access-control list acl describing principals permissions access resource auth cert viewed acl entry keys principals represented subject permission access resource term appearing rules viewed string alphabetk elements ofk beginning uniformity refer strings form terms assume rewrite rule cert term case rewrite rule applied term denoted yields term rule viewed function terms terms bob bob myfriends myfriends rules addition assume prefix exists composition rule rules friends bob myfriends bob composition friends myfriends rules called compatible composition defined problem solved authorization question set certs request allowed exercise authorization algorithm simple answer authorization question case answer identifies chain certificates prove result formally certificate-chain discovery attempts find removing useless certificates certificate chain intuitively represents path resource representing permission access delegation elimination useless certs ensures chain represents authorization specification clarke presented algorithm certificatechain discovery spki 
semantics-aware malware detection mihai christodorescu somesh jha wisconsin madison mihai jha wisc sanjit seshia dawn song randal bryant carnegie mellon sanjit dawnsong bryant cmu abstract malware detector system attempts determine program malicious intent order evade detection malware writers hackers frequently obfuscation morph malware malware detectors pattern-matching approach commercial virus scanners susceptible obfuscations hackers fundamental deficiency pattern-matching approach malware detection purely syntactic ignores semantics instructions paper present malwaredetection algorithm addresses deficiency incorporating instruction semantics detect malicious program traits experimental evaluation demonstrates malware-detection algorithm detect variants malware low run-time overhead semantics-aware malware detection algorithm resilient common obfuscations hackers introduction malware instance program malicious intent examples programs include viruses trojans worms classification malware respect propagation method goal malware detector system attempts identify malware virus scanner signatures heuristics identify malware malware detector havoc caused malware malware detection important goal work supported part office naval research undercontractsn theu government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon interpreted necessarily representing official policies endorsements expressed implied government agencies government work supported part army research office grant daad goal malware writer hacker modify morph malware evade detection malware detector common technique malware writers evade detection program obfuscation polymorphism metamorphism common obfuscation techniques malware writers order evade detection virus morph encrypting malicious payload decrypting execution polymorphic virus obfuscates decryption loop transformations asnop-insertion code transposition changing order instructions placing jump instructions maintain original semantics register reassignment permuting register allocation metamorphic viruses attempt evade detection obfuscating entire virus replicate viruses change code variety ways code transposition substitution equivalent instruction sequences change conditional jumps register reassignment addition behaviors existing malware favorite technique malware writers sobig sobig worm variants widespread summer developed iteratively successive iteration adding changing small features variant managed evade detection obfuscations adding behavior recent recurrence netsky agle worms active half adding code changing existing code creates undetectable malicious variants agle worm shows series upgrades version version include addition backdoor code disable local security mechanisms functionality hide worm existing processes quote summarizes challenges worm families pose detectors arguably striking aspect beagle dedication author authors refining code pieces tested perfected deployed great forethought evade antivirus scanners defeat network edge protection devices commercial malware detectors virus scanners simple pattern matching approach malware detection program declared malware sequence instructions matched regular expression recent study demonstrated malware detectors easily defeated simple program obfuscations hackers basic deficiency patternmatchingapproachtomalwaredetectionisthatthey ignore semantics instructions patternmatching algorithm resilient slight variations malware detectors patterns detecting malware instances slight variations reason signature database commercial virus scanner frequently updated goal paper design malware-detection algorithm semantics instructions algorithm resilient minor obfuscations variations suppose program transformed compiler phase register allocation produce program pprime translation-validation problem problem determining pprime simulates translation validation prove compiler phases preserve semantics specific program viewing hacker obfuscations compiler phases malware-detection problem surface similar translation-validation problem fundamental differences problems translation-validation techniques determine programs semantically equivalent variants malware equivalent malware writers add additional functionality variants translationvalidation researchers make assumptions transformed program necula assumes branches target program correspond branches source program context malicious-code detection assumption valid adversary free transform malicious code ideas translation-validation literature context malware detection modeling semantics instructions decision procedures algorithm differs translation-validation literature observation malicious behaviors decryption loop polymorphic virus loop search addresses user mail folder variants malware problem malicious behavior decryption loop appears guises variants formalize problem describe algorithm discovering malicious behaviors program algorithm semantic purely syntactic resistant common obfuscations hackers specifically paper makes contributions formal semantics formally define problem determining program exhibits malicious behavior general problem undecidable semantics detail section semantics presented section semantics researchers working malware detection semantics-aware malware detection algorithm problem determining program exhibits malicious behavior undecidable hope algorithm abovementioned problem section present algorithm handling limited set transformations hackers evaluation section shows algorithm effective discovering malicious behavior detects multiple netsky agle variants single template resilience obfuscation commercial virus scanners semantics malware detection present formal semantics malware detection provide intuitive explanation underlying ideas shown figure running figure shows control-flow graph cfg specification malicious behavior figure shows cfg instruction sequence fragment larger program instructions figure intermediate form tool instructions intuitive give formal description appendix describe components semantics malicious behavior framework malicious behavior templates instruction sequences variables symbolic constants figure describes malicious behavior simplified version decryption loop found polymorphic worms malware specification figure decrypts memory starting address const addr writes decrypted data memory starting address const addr decryption function termination condition denoted function predicate condition abstracting names specific registers symbolic constants specification malicious behavior semantics algorithm insensitive simple obfuscations register renaming changing starting address memory block mem mem condition jump const address const addr const addr truefalse template malicious behavior ebx eax edx eax eax eax eax edx edx ebx ebx mem ebx mem edx false jump true malware instance const addr const addr condition xlessmuch execution context const addr const addr condition symbolic constant types figure malware instance satisfies template semantics instruction sequence malicious behavior instruction sequence shown figure assume symbolic constants template assigned values shown figure template instruction sequence shown figure executed state contents memory executions state memory words template instruction sequence effect memory memory accesses performed addresses executions stores memory locations execution instruction sequence shown figure exhibits behavior template figure words malicious behavior template demonstrated instruction sequence note intuitive notion instruction sequence demonstrating malicious behavior affected program transformations register renaming inserting irrelevant instruction sequences changing starting addresses memory blocks formal semantics template -tuple sequence instructions set variables symbolic constants types symbolic constants n-ary function denoted n-ary predicate denoted notice simple symbolic constant -ary function type constant type written template shown figure variables symbolic constants shown figure instruction sequence program fragment ure memory contents represented function addr values set addresses addr set values values denotes stored address execution context template assignment values types symbolic constants set formally execution contextect templatet function domain type ect execution context template shown figure shown figure execution context ect template ect template obtained replacing constant ect state template -tuple denoted valt pct memt valt values assignment values variables pct program counter memt addr values memory content follow convention state component referring template superscripted template state val mem refer components 
sdsi kjcj time complexity number keys jcj sum lengths right-hand sides rules jha reps presented algorithm based theory pushdown systems note general composition operator associative compatible compatible exist exist exists expressions equal defined omit parentheses assume associative generalized authorization problem section formally define generalized authorization problem gap section show issues privacy validity recency trust formulated gap framework framework certificates labeled weights drawn bounded idempotent semiring definition bounded idempotent semiring quintuple set elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains weighted spki sdsi system wss -tuple set certs bounded idempotent semiring assigns weights certs extend function certificate chains natural certificate chain defined definition weighted spki sdsi system wss request proof denotes set certificate chains prove request fulfilled formally proof set certificate chains useless certificates generalized authorization problem gap asks questions proof non-empty proof non-empty find quantities lff proof witness set certificate chains proof certificates weights patient patient aids patient patient patient aids patient kalice patient kalice figure set weighted certificates notice extender operation calculate certificate chain set certificate chains computed combiner operation general finite set minimal elements minimal respect partial order intuitively gap attempts find set certificate chains proving access resource combination operator weights minimal definition defines general machinery required spki sdsi problem discussed sections problem defined witness set certificate chains identified demonstrate authorization-related problems cast framework privacy-preserving certificate chains return introduction company offers additional insurance patients hospital certificates relevant problem shown figure represents service offered additional insurance offered company filled square represents fact authorization delegated eligible patient delegate permission buy insurance friends principals aids internalmedicine clinics hospital denoted aids alice patient clinics suppose alice buy insurance case equal kalice certificate chain reveals alice aids information alice reveal company alice prefer offer certificate chain company proves authorized buy additional insurance reveals amount information privacy modeled gap framework semiring defined stand insensitive sensitive elements operators defined denotes easy check conditions definition satisfied condition trivially satisfied finite weights certificates shown figure certificate aids patient kalice labeled reveals alice patient aids clinic certificates labeled weights certificate chain alice prefers certificate chain weight section show alice discover certificate chain maximally-valid certificate chain expiration cert cert expire time tcurrent tcurrent current time expiration certificate chain minki suppose alice login host alice certificate chain valid minutes logged host minutes alice find certificate chain authorizes login maximum expiration certificate chains most-recent certificate chain time relative current time cert issued on-line check performed cert tcurrent actual time issue on-line check call recency cert recency certificate chain equal maxki suppose alice login host riskreduction purposes host mandate certificate chain recency ten minutes case alice wishes find certificate chain authorizes login minimum recency chains certificate chain minimum recency maxki equal ten minutes alice certificate chain login certificate chains maximal trust assume certificate assigned trust level issuer certificate intuitively denotes confidence issuer relationship expressed certificate trust level certificate chain nki defined table suppose alice server requires certificate chain trust level case alice find certificate chain authorizes maximal trust level chains certificate chain trust level alice validity max min recency min max trust table semirings validity recency trust formalization semirings semirings cases discussed shown table case maximal-trust trust levels drawn totally ordered set elements elements denote low medium high levels trust element stands link join meet operator totally ordered set defined arbitrary elements pushdown systems pushdown system transition system states involve stack unbounded length definition pushdown system triple finite sets called control locations stack alphabet configuration pair finite number rules formhp define transition relation configurations hri write express rule hri omit index understood reflexive transitive closure written set configurations define pre post sets configurations backwards forwards reachable elements loss generality assume henceforth jwj restrictive pushdown system simulated note highest level trust denoted element lowest total order obeys restriction larger constant factor pushdown systems infinitely configurations symbolic means represent sets configurations finite automata purpose definition pushdown system p-automaton quintuple finite set states set transitions final states initial states control locations configuration accepted final state set configurations regular recognized automaton understood omit prefix refer automaton convenient property regular sets configurations closed forward backward reachability words automaton accepts set construct automataapre andapost accept pre post general idea algorithm pre pushdown system p-automaton accepting set configurations loss generality assume transition leading initial state pre obtained language automaton apre derived saturation procedure procedure adds transitions rule current automaton add transition efficient implementation procedure requires jqj time jqjj space procedure implementation presented constructing p-automaton accepts post show extensions procedures provide efficient algorithms discovering certificate chains needed generalized authorization problems discussed section present extensions pre basic ideas apply post omitted lack space connection spki sdsi pushdown systems correspondence spki sdsi pushdown systems presented finite set certificates keys identifiers associate pushdown system keys control locations identifiers form stack alphabet rule set defined hkx hkh patient hkh patienti hkh aids patienti hkh patienti hkh patienti hkh aids patienti hkalice hkh patienti hkalice figure pds rules correspond figure cert sequence identifiers rule auth cert rule instance set certificates figure pushdown system control locations fkx aids kaliceg stack alphabet fpatient set rules listed figure usefulness correspondence stems simple observation configuration reach configuration chain certificates applied yield instance alice prove buy additional insurance hkx hkalice authorization problem set certs request terms pds certificate set authorization problem stated granted access iff condition pre fhk holds medical determine hkx pre fhkalice hkalice automaton shown figure accepts set set pre shown figure transition symbol state accepting state hkx pre words alice authorized buy additional insurance extra annotations insensitive sensitive transitions transitions involve sensitive information algorithm deriving labels presented section solving generalized authorization problem types problems treated characterized qualitative nature answer questions principal allowed access resource section show answer questions additional quantitative component kaliceh aids kaliceh aids patient patient patient figure automaton representing configurations fhkalice hkalice automaton representing configurations pre long principal allowed access resource pushdown systems rules carry weights weighted pushdown systems pushdown system rules values domain weights weight domains interest bounded idempotent semirings definition definition weighted pushdown system triple pushdown 
state similarly state instruction sequence -tuple val mem val reg values assignment values set registers reg program counter mem addr values memory contents state space template instruction sequence assume execution context ect template template state execute instruction template ect state transition state generate system event context events system calls kernel traps denote state change generating event uniformity instruction generate system event generates null event null initial template state executing template execution context ect generates sequence ect sti state executing instruction template ect eti event generated -th instruction notice template terminate ect infinite similarly denotes sequence instruction sequence executed initial state definition instruction sequence behavior template exists program state execution context ect template state mem mem memory states sequences ect finite conditions hold sequences condition execution sequences ect etk affected ect set addresses mem negationslash mem stk affected ect set memory addresses executing template initial state require mem stk mem holds affected ect values addresses belong set affected ect executing template instruction sequence condition ignoring null events event sequence etk subsequence event sequence order system events match arguments return values identical condition stk affected ect affected ect words program counter end executing template points affected memory area program counter executing point affected memory area shown figure assume execution context shown figure template shown figure suppose execute template instruction sequence shown figure states memory contents state memory executions condition true condition trivially satisfied condition istrivially true definition program satisfies template denoted iff instruction sequence behavior program template call problem determining template matching problem tmp defining variant family definition todefineavariantfamily ants malware common set malicious behavior decryption loop loop search addresses lett set templates set specification malicious behavior common malware family set defines variant family words variant family defined byt programs satisfy templates set theorem tmp undecidable proof reduce halting problem tmp turing machine program instructions simulates turing complete accomplished loss generality assume touch special address addr simulating turing machine starting simulate sets mem addr simulating halts sets mem addr template shown mem addr mem addr easy iff halts square weaker semantics scenarios semantics definition strict template memory locations store temporaries memory locations checked equality comparing executions instruction sequence template ect sequence generated template executed state execution context ect define set core memorylocations core ect whichisasubset affected ect condition definition changed give weaker semantics modified condition require core ect mem stk mem values addresses belong set core ect executing template instruction sequence words memory locations set core ect checked equality executions ways define core memory locations describe definition core memory locations assume instruction template labeled temp persistent intuitively instruction labeled temp performs temporary computation ect sequence generated template executed state execution context ect recall affected ect set addresses mem negationslash mem stk stk state sequence ect core memory locations core ect defined address affected ect target load store instruction label persistent semantics-aware matching algorithm present algorithm checking program satisfies template algorithm sound complete respect semantics presented section handle classes obfuscations section implemented algorithm malware-detection tool tool takes input template binary program microsoft windows intel iax platform determines fragment suspicious program behavior template tool output describes matched fragment program information relating template variables program registers memory locations list irrelevant instruction sequences part matched program fragment architecture tool built top ida pro disassembler figure illustrates flow tool program idapro conversion template program malware detector decision procedures nop library random execution simplify uclid predefined patterns irrelevant instructions randomized interpreter theorem prover decision procedure bit-vector arithmetic increasing precision cost figure code detector gray boxes represent existing infrastructure starting input binary program left ending output indicating program satisfies template disassemble binary program construct control flow graphs program function identified ida pro produce intermediate representation generated library instruction transformers architecture-independent library system calls definition platform-specific remove dependency summary functions expressed form appendix description rest toolkit takes advantage platform- architecture-independent initially focused research microsoft windows intel iaplatform loss generality providing front-ends translate program format malwaredetector tool process programs platforms algorithm description malware detection algorithm amd works finding template node matching node program individual nodes template program match exists assignment variables template node expression unifies program node expression matching nodes found check def-use relationships true template nodes hold true program nodes related defuse relationship node definition variable reaches node variable nodes template matching counterparts conditions algorithm found program fragment satisfies template produces proof relationship formally malicious code template program define malware detection algorithm amd predicate pairs programs templates amd programs templates amd returns program satisfies templatet conditions denote don return algorithm determine program satisfies template figure simpler version template figure expression const addr symbolic constant condition symbol represents bit-vector xor operator similarly program figure simpler version malware instance figure satisfy algorithm amd amd conditions hold matching template nodes program nodes node template unify node words partial function nodes nodes unifiable denote binding variable referred template instruction node expression referred program instruction node figure gray arrows connect unified template nodes program nodes instance program node unifies template node preservation def-use paths node define def set variables defined similarly set variables node figure template node variable template node defines variable def define synthetic nodes npre predecessor templateentrynodeandnpost assuccessortoalltemplate exit nodes def npre npost def-use path sequence nodes conditions true edge valid path template instruction node defines variable def negationslash instructions intermediate nodes redefine variables def def def nodes def-use related denoted duse iff exists path def-use path figure template nodes def-use related def-use path nodes nprime def-use related nodes nprime matched nodes mprime program mprime nprime suppose variable defined nprime nprime mprime rprime bound expression program node rprime program node mprime case make expression executing instruction expression rprime executing instruction mprime program path matching function template path nprime figure program nodes match template nodes respective bindings eax ecx condition enforce eax program instructioni ecx program instruction algorithm invariants checked decision procedure algorithmamd implements conservative approximation formal semantics malware detection section result demonstrates theorem amd sound respect tmp semantics amd implies square ouralgorithmisthus sound respect tmp semantics complete show exists program template amd returns c-like syntax template captures behavior initializing array elements template program 
system bounded idempotent semiring function assigns rule sequence rules associate define configurations path denote set rule sequences transform hrki definition weighted pushdown system regular set configurations generalized pushdown reachability gpr problem find lfv path witness set paths path general finite set paths values minimal elements path minimal respect partial order defined definition remainder section denote fixed weighted pushdown system denote fixed regular set configurations represented p-automaton transition leading initial state gpr problem multi-target meet-over-all-paths problem graph vertices graph configurations edges defined transition relation target vertices vertices graph set target vertices infinite built-in structure regular set gpr problem concerns infinite graphs infinite set paths differs work meet-over-all-paths problems ordinary pushdown-reachability problem infinite nature problem addressed reporting answer indirect fashion form annotated automaton answer automaton annotations identical apre automaton created algorithm pre values read annotations accepting paths automaton pre values solution gpr problem presented stages define language characterizes sequences transitions made pushdown system automaton turn weighted pushdown systems gpr problem language characterizations transition sequences previously results kind grammar problem obtain solution gpr problem solution based grammars inefficient improve performance specialize computation case ending algorithm creating annotated automaton similar pre algorithm languages characterize transition sequences section make definitions aid reasoning set paths lead configuration configurations regular set call set reachability witnesses respect reachabilitywitnesses path convenient pds automaton combined sequence create combined pds call states rules ofp augmented rule transition transition set configuration accepted path configuration hqf note transitions leading initial states behavior accepting run divided phases transitions mimics transitions mimics reaches state perform sequence pops possibly reaching state run reach state terms features original phase corresponds automaton accepting configuration reached starting configuration words accepts configuration iff pre language define characterizes pop sequences pop sequence sequence transitions starts configuration ends configuration family pop sequences characterized complete derivation trees derived nonterminal grammar shown figure theorem pds pop sequence iff nonterminal grammar shown figure complete derivation tree derivation tree root preorder listing derivation tree production instances figure defines correspondence productions pds rules sequence rules pop sequence sequence rules derivation tree root derivation tree complete terminal symbol leaf proof sketch shrink stack removing stack symbol left-hand side rule transition sequence removes symbols stack component rule right-hand side words pop sequence left-hand-side stack symbol involve pop sequence righthand-side stack symbol left-hand right-hand sides productions figure reflect pop-sequence obligations incurred rule capture set reachabilitywitnesses recognized automaton define context-free language set productions shown figure language captures ways pds accept set reachability witnesses corresponds complete derivation trees derivable nonterminal accepted subtree rooted pop sequence performs consume symbol reachability witnesses complete derivation trees root accepted weighted pdss abstract grammar problems turning weighted pdss weighted version denoted weighted pds combined rule added due transition transition set assigned weight reason semiring sums weights paths characterized contextfree grammars defined concept definition semilattice abstract grammar collection context-free grammar productions production form parentheses commas production terminal symbols production function string terminal symbols derived grammar yield complete derivation tree denotes composition functions corresponds unique call valg simply val understood denote strings terminals derivable nonterminal abstract grammar problem compute nonterminal valg production figure context-free language pop sequences rules correspond production production accepting accepted accepting figure set productions complete derivation trees root accepted encode transition sequences accepts cast gpr grammar problem attach production functions productions rule sequence derivation tree yield valg figure note functions place beginning semiring-product expression corresponds preorder listing derivation tree production instances theorem solve gpr problem appeal theorem theorem abstract grammar problem solved iterative computation finds maximum fixed point conditions hold semilattice infinite descending chains production function distributive xik xik arbitrary non-empty finite index sets production function strict argument abstract grammar problem figure meets conditions theorem definition operator associative commutative idempotent semilattice definition infinite descending chains distributivity production functions arbitrary non-empty finite index sets repeated application definition production functions strict argument annihilator respect definition production functions constants functions arguments meet required condition trivially algorithm solving gpr problem weighted pds initial configuration regular set represented automaton create combined weighted pds define abstract grammar problem schema shown figure solve abstract grammar problem finding maximum fixed point chaotic iteration nonterminal fixed-point-finding algorithm maintains current estimate maximum fixed-point solution initially values set updated right-hand side production left-hand-side nonterminal efficient algorithm gpr problem approach previous section efficient configuration takes jqjn jfj time space create grammar productions figure left-hand-side nonterminal accepting improve production accepting accepted accepting figure abstract grammar problem gpr problem algorithm previous section instantiations productions listed figure relevant final solution prevent algorithm exploring useless nonterminals grammar shown figure gpr questions respect target-configuration set involve subgrammar nonterminals ordinary pushdownreachability problem information complete derivation tree root nonterminal exists productive nonterminal precomputed returned form annotated automaton size jqjj exploring subgrammar lazily saves construct entire subgrammar productive nonterminals represent automaton transitions productions involve transition constructed on-thefly algorithm shown figure straightforward algorithm solves grammar problem subgrammar figure workset set transitions nonterminals updated considered line values set function call update computes transition created rule transitions ordered list lines process rules types lines represent fixed-pointfinding loop lines simulate processing rules types involve transition right-hand side line corresponds invocations production functions note line change smaller iterations continue values transitions stabilize workset empty fact algorithm simply expressing grammar problem subgrammar algorithm terminates computes desired result operations algorithm remarkably similar pre algorithm major difference transitions stored workset processed multiple times transition processed length maximal-length descending chain semiring maximal cost extender combiner operation time complexity increases complexity unweighted case factor gpr problem solved time jqj efficient techniques apply semirings total orders discussed section annotated pre automaton configuration read automaton paths accepted accumulating path taking meet resulting set value-accumulation step performed straightforward extension standard algorithm simulating nfa algorithm algorithm dynamic-programming algorithm determining appendix describes extend algorithm additional annotations transitions path set obtained total orderings examples section semirings properties ordering total ordering element respect iii lub lub denotes upper bound maximum total order cases efficient algorithm gpr problem based ideas knuth generalization algorithm input weighted pushdown system p-automaton accepts transitions states output p-automaton apre accepts pre function maps abstract grammar problem defined figure procedure update begin ftg jtj changed workset workset ftg end workset 
program template initialize array elements sets affected memory locations final states template program algorithm amd ebx eax nop ecx eax eax ecx eax eax ebx ebx ecx jump mem ebx mem eax true false const addr const addr jump const address const addr mem mem key false true valpre eax valpost ecx figure program satisfying template left algorithm amd gray arrows connect program nodes template counterparts dashed arrow left marks def-use relations hold true template dashed arrow marks def-use relation hold true program match program template ordering memory updates template loop program loops local unification unification step addresses condition algorithm amd producing assignment variables instruction template node matches program node instruction assignment exists program node expression ground terms algorithm one-way matching instantiates template variables program expressions figure template node matches program node binding ecx const addr prototype implemented template expressions variables symbolic constants predefined functions operators appendix external function calls matching algorithm takes restrictions account variable template unified program expression assignment expressions symbolic constant template unified program constant predefined function memory traditionally written array notation memory unified program function memory predefined operator template unified operator program external function call template unified external function call program standard unification rules apply cases operator expression template unifies expression program program operator template operator operator arguments unify template node const addr unify program nodes eax ebx program nodes template node expression symbolic constant right-hand side result local unification step binding relating template variables program expressions binding figure shown table note bindings program points program node template variable bound eax program node template variable bound ecx requiring bindings consistent monomorphic intuitive approach leads overly restrictive semantics obfuscation attack reassigns registers program fragment evade detection check program expressions bound template variable eax ecx bound verify change template variable values employ mechanism based def-use chains preservation answer problem unified nodes bindings eaxconst addr ebxconst addr ecx const addr eaxb ebx eaxincrement ebxincrement const addr table bindings generated unification template program nodes figure notation refers node template refers node program preservation def-use chains secondconditionofalgorithmamd requirestemplatevariables program expressions similar update patterns necessarily values def-use chain template gram expression template-variable program expression template-variable definition figure template nodes defuse related program nodes map template nodes denote program fragment nodes program paths program node node correspond template paths template nodes path nodes map template paths template node def-use chain template variable connects template node template node program expressions template variable program node program node equal paths condition expressed terms predicates path program fragment valpre eax valpost ecx valpre represents variable-valuation function program state path valpost variable-valuation function program state path formulate query preserving def-use chains preservation problem program fragment check maintains predicate parenleftbigvalpre eax valpost ecx parenrightbig algorithm decision procedures determine predicate holds discuss decision procedures section treat decision procedures oracles answer queries form program fragment maintain invariant match considered program node template node algorithm checks def-use chain preserved program expression template variable matched node appendix listing def-use chains checked shown figure approach eliminates large number matches lead correct template assignment decision procedures check valuepreservation value-preservation oracle decision procedure determines program fragment semantic nop respect program variables formally program fragment program expressions decision procedure determines predicate valpre valpost holds true semantic nop holds similarly define decision procedures determine holds case result false denote decision procedure decision procedure preservation queries frequent algorithm possibly step node matching prototype collections decision procedures ordered precision cost intuitively decision procedures precise fastest execute -style decision procedure reports true input -style decision procedures ordered collection report true input similarly -style decision procedure reports false input alld -style decision procedures ordered collection report false input -style decision procedures sound define order betweend andd decision procedures based performance collection decision procedures efficient algorithm testing program fragment preserves expression values iterate ordered collection decision procedures querying stop returns true false -style decision procedures algorithm incrementally expensive powerful checking program fragment step complexity program fragments simple semantic nops detected early decision procedures ordered collection complex preserving fragments require passes multiple decision procedures present order decision procedures part prototype nop library nop decision procedure identifies sequences actual nop instructions processor-specific instructions similar skip statement high-level programming languages predefined instruction sequences semantic nops based simple pattern matching decision procedure annotates basic blocks nop sequences applicable program fragment analysis annotated semantic nop nop library act cache queries resolved decision procedures randomized symbolic execution oracleisbasedonad domized execution program fragment executed random initial state values registers memory chosen random completion time check true true path program fragment semantic nop program fragment semantic nop theorem proving thsimplify preservation problem formulated theorem proved program fragment loops simplify theorem prover implement oracle program fragment represented state transformer program register memory expression converted ssa form simplify prove formula order show paths program fragment semantic nops simplify theprogramfragment semantic nop limitation simplify theorem prover lack bit-vector arithmetic binary programs based query simplify programs bit-vector operations theorem proving thuclid theorem proving oracle based uclid infinite-state bounded model checker purposes logic supported uclid superset supported simplify uclid precisely models integer bit-vector arithmetic model program fragment instructions state transformers register memory represented uninterpreted function uclid simulates program obfuscation transformation handledby instruction reordering register renaming garbage insertion instruction replacement limited equivalent functionality reordered memory accesses table obfuscation transformations addressed malware detection algorithm limitations fragment number steps determines holds end simulation illustration figure preservationproblemconsistsoftheprogramfragmentr createdfromprogramnodes andthevaluepredicate valpre eax valpost ecx theformula shown table generated program fragment strengths limitations algorithm effective real-life attacks undo obfuscations program transformations malware writer list strengths weaknesses algorithm table discuss detail classes obfuscations algorithm amd handle code reordering equivalent instruction replacement register renaming garbage insertion code reordering simplest obfuscations hackers evade signature matching obfuscation order instructions disk binary image maintaining execution order jump instructions obfuscation handled control flow graphs register renaming simple obfuscation reassigns registers selected program fragments result signature matching tool fail detect obfuscated variant long searches signature specific register template matching algorithm avoids pitfall templates uninterpreted variables assigned program registers memory locations unification matching algorithm identify program behavior template irrespective register allocation garbage insertion obfuscates program inserting instruction sequences change behavior 
update workset select remove transition workset update update update return figure on-the-fly algorithm solving grammar problem subgrammar figure dijkstra algorithm shortest-path problem algorithm workset implemented priority queue transition selected line minimum line changed adjustpriorityqueue worklist adjustpriorityqueue inserts item priority queue key key item approach transitions processed form nondecreasing sequence transition selected workset general case label transition change transition selected causing added workset compared pds-reachability problem unweighted case costs compute maximum fixed-point values cost approach describe applies slightly larger class totally ordered abstract grammar problems studied ramalingam examples fall class defined studied knuth maintaining priority queue time complexity jqj log jqjj set path discussion discuss issues arise applying gap framework recency policies recency metric presented section simplistic compared studied recency policies based number factors financial risk authentication authorization decision semantics invalidity rate certificate contents security system generate certificate realistic setting recency values certificates normalized possibility base normalization remaining lifetime certificate assuming times validity specification appropriately chosen lifetime certificate tnot tcurrent provided certificate valid tcurrent tnot recency certificate defined tcurrent tissuel case semiring recency min max multiple security policies authorization policies subject multiple security policies satisfy simultaneously most-recent certificate-chain policy privacy-preserving policy approach policy-priority approach user declares order security-policy priorities instance privacy priority recency priority problems addressed gap framework component policies involve total orders pairs values semiring values privacy recency values defining lexicographic minimum section gap framework handle partially ordered component policies situation clear preference component policies section trust policies trust policies metrics proposed literature trust metrics efficiently modeled gap framework proposed bounded disjoint paths bdp bounded connective paths metric np-hard conp-hard hope finding efficient solution problems investigated approximation algorithms developed problems applicable setting similarly minimum-capacity-cut metric easily formulated framework bdp weighted shortest paths interesting metrics certificate-chain context metric paths certificatechain evaluation paths problem shown np-complete length bounds greater approximation algorithms np-hard related work algorithm spki sdsi proposed clarke credential-chaindiscovery algorithm role-based trust management language presented proofcarrying-authorization pca framework appel fela infinite descending chains operations performed min max finite number values arise execution gap framework applies ten client theorem prover twelf construct proof authorization client presents server knowledge previously considered issues privacy trust context algorithms trust management systems algorithms pca algorithm based algorithm generalized shortest-path problem weights edges drawn semiring approach general approach applies formalisms spki sdsi pushdown systems related unrestricted hierarchical state machines collections finite-state transition systems connected call return transitions related interprocedural controlflow graphs exploded supergraphs interprocedural dataflow analysis dataflow analysis application weighted pdss algorithm solving gpr problems developed section related existing dataflow-analysis algorithms sagiv showed compute meet-over-all -valid -paths values multientry multi-exit hierarchically structured graphs respect previous work interprocedural dataflow analysis section makes contributions conventional dataflow-analysis algorithms merge values configurations top-of-stack symbol weighted pdss dataflow queries posed respect regular language initial stack configurations strict generalization kind answers obtainable ordinary interprocedural dataflow-analysis algorithms algorithm solving gpr problems provide witness set paths provide client analysis algorithm explanation answer dataflow query reported application weighted pdss interprocedural dataflow analysis examined greater detail model checking pushdown systems verifying security properties programs application weighted pushdown systems verifying security properties programs verification process requires knowing interprocedural dataflow information bouajjani esparza toulli independently developed similar framework pre post queries pushdown systems weights drawn semiring solve overapproximations reachability questions concurrent communicating pushdown systems method obtaining weights automaton transitions significantly differs deriving weights directly obtained fixpoint computation matrix entries transitions pre automaton obtain weights semiring infinite descending chains provided extender operator commutative leads efficient solution finitechain case case algorithm time complexity jqjj jqjj proportional jqj semirings finite descending chains algorithm applies cases efficient solution number trust policies metrics proposed obtain assurance certificate binding well-known notions stem pgp user acts certificate authority creating certificates entities trust transitive manner certificate authorities recommendors introduce certificate authorities trust creating certificates assurance certificate-chaining process provided part independent certificate paths subsequent work studies network connectivity trust metric work studies metrics based confidence valuations minimum-capacity cuts certificated edges represent financial liabilities algebra assessing trust certificate chains private sensitive information reside certificates include names roles identifying information chains authorization certificates tend mirror organization structures business processes personal relations sensitive principal making authorization request follow privacy policy control information disclosed leaked part authorization process flexibility exist requester choose alternative set credentials supplied part proof authorization certificate privacy problem related long history work information flow based lattice model attempts model controls flow information traditional information-flow policies stemming military concerned information-disclosure policies access data requires proper clearance mandatory access control discretionary access control draw work sense willingness provide credentials categories information subject current discretionary access request policies based chinese-wall security policy access data constrained attributes data question data subject holds access rights objective current paper demonstrate simple privacy metric quantifies information flow certificate chain validity time periods included certificate formats early certificate standards validity certificate contents suspect current time certificate-validity period certificaterevocation lists directories queried determine credentials invalid stubblebine formalizes notion recent-secure authentication means authenticating channel subject freshness constraints work means reasoning recent-secure authentication extending calculus authentication rivest develops case flexible mechanisms support authentication subject recency constraints additional recency policies methods analysis recent-secure authentication developed work monotonic logic reasoning synchronization revocation recency monotonic logics reasoning validity intervals spki context studied aho sethi ullman compilers principles techniques tools addison-wesley alur etessami yannakakis analysis recursive state machines proc computer-aided verif july appel felten proof-carrying authentication conf comp commun sec nov aura ellison privacy accountability certificate systems res rep helsinki univ tech espoo finland apr bell lapadula secure computer system unified exposition multics interpretation technical report esd-tr- mitre corp mtrbedford ntis ad-a benedikt godefroid reps model checking unrestricted hierarchical state machines icalp beth borcherding klein valuation trust open networks computer security esorics volume lec notes comp sci pages springerverlag blaze feigenbaum ioannidis keromytis keynote trust-management system version rfc sept blaze feigenbaum ioannidis keromytis role trust management distributed systems security vitek jensen editors secure internet programming security issues mobile distributed objects pages lncs bley complexity vertex-disjoint length restricted path problems tech rep sc- konrad-zusezentrum informationstechnik berlin ger bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur volume lec notes comp sci 
pages springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures pages brewer nash chinese wall security policy symp sec privacy pages chen wagner mops infrastructure examining security properties software conf comp commun sec november chu feigenbaum lamacchia resnick strauss referee trust management web applications computer networks isdn systems sept clarke elien ellison fredette morcos rivest certificate chain discovery spki sdsi jcs denning lattice model secure information flow communications acm detreville binder logic-based security language symp res sec privacy oakland ieee computer society press ellison frantz lampson rivest thomas ylonen spki certificate theory rfc sept esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proc computer-aided verif volume lec notes comp sci pages july esparza cera schwoon model-checking ltl regular valuations pushdown systems proceedings tacas volume lncs pages springer halpern van der meyden logical reconstruction spki comp sec found workshop pages jensen metayer thorn verification control flow based security properties ieee symposium security privacy jha reps analysis spki sdsi certificates model checking ieee comp sec found workshop csfw ieee computer society press jsang algebra assessing trust certification chains kochmar editor proceedings network distributed systems security symposium ndss knoop steffen interprocedural coincidence theorem int conf comp construct pages knuth generalization dijkstra algorithm inf proc kohlas maurer confidence valuation publickey infrastructure based uncertain evidence public key cryptography pages lampson abadi burrows wobber authentication distributed systems theory practice trans comp syst winsborough mitchell distributed credential chain discovery trust management comp sec maurer modeling public-key infrastructure computer security esorics volume lec notes comp sci springer-verlag perl ronen heuristics finding maximum number disjoint bounded paths networks pfenning sch urmann system description twelf meta-logical framework deductive systems ganzinger editor int conf auto deduc pages springer-verlag lnai july ramalingam bounded incremental computation volume lec notes comp sci springer-verlag reiter stubblebine resilient authentication path independence trans computers dec reiter stubblebine authentication metric analysis design trans inf syst sec reps horwitz sagiv precise interprocedural dataflow analysis graph reachability symp princ prog lang pages york acm press reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis international static analysis symposium sas rivest eliminate certificate revocation lists hirschfeld editor financial cryptography pages feb rote path problems graphs tinhofer mayr noltemeier syslo eds cooperation albrecht computational graphs theory springer-verlag computing supplementum sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci schwoon wpds library weighted pushdown systems http tum schwoon moped sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs stubblebine recent-secure authentication enforcing revocation distributed systems symp research sec privacy pages stubblebine wright authentication logic formal semantics supporting synchronization revocation recency trans softw eng mar oencke wilhelm grammar flow analysis alblas melichar editors attribute grammars applications systems volume lec notes comp sci pages prague czechoslovakia june springer-verlag union itu-t recommendation information technology open systems interconnection directory authentication framework aug department defense dod trusted computer system evaluation criteria dod -std weeks understanding trust management systems symp res sec privacy oakland ieee computer society press zimmermann official pgp user guide mit press cambridge appendix generation witness sets section efficient algorithm determining section addresses question obtain problem examining infinite graph nodes pairs configuration edge labeled hri configuration finding means identifying set paths path leads andl words proves computed algorithm note properties general larger situation paths values single path small witness set paths set witness set indirectly form annotation called transitions apre data structures called wnode wstruc transition holds wnode denote entity wnode set wstruc items wstruc item form back rule sequence wnodes nil indicating missing extend algorithm idea execution item denotes suppose apre accepting path starting configuration accepted path pushdown system path family paths path starts accepting path apre successor configuration algorithm procedure update begin ftg jtj return nil create fsg create minimize fsg workset workset ftg end figure modified update procedure constructed replacing transitions wnodes concrete modifications algorithm line set nil line create wnode nil set figure shows revised update procedure line figure computes newly discovered transition line records path discovered line update change line addition strictly smaller path path incomparable line creates set consisting previous paths path incomparable approximate elements procedure minimize shown removes fairly straightforward information contained reconstruction witness set involving wnode created execution wnodes created earlier process reconstructing witness set decoding wnode wstruc information eventually terminate configuration execution modified algorithm wnodes transition created referenced moment wnodes referenced transitions garbage collector track remove nodes longer chain transition totally ordered case section wnode wstruc 
program algorithm amd tackles class obfuscations decision procedures reason predicates def-use chains equivalent instruction replacement rich instruction set architectures notably intel instruction sequence ebx nop ecx eax predicate valpre eax valpost ecx simplify formula implies ebx ecx eax pre ecx post ecx eax pre ecx post table simplify query program fragment predicate iax replace groups consecutive instructions short instruction sequences semantics add register architecture increment instruction add instruction instruction handle limited kind instruction replacement normalizing code intermediate representation semanticallydisjoint operations limitations tool limitations current implementation requires instructions template form program node template operation assignment multiplication hand side program node match means match equivalent programinstruction eax eax arithmeticleft shift attacks requirement fairly hard bar raised attacker devise multiple equivalent distinct implementations computation evade detection inherent limitation semantics handled normalization step limitation def-use chains preservation checking def-use relations malicious template effectively encode specific ordering memory updates algorithm amd detect program exhibit ordering memory updates note automatically generating functionally-equivalent variants hard problem handling obfuscations reorder instructions achieve ordering memory updates goal ongoing research experimental results evaluated implementation algorithmamd real-world malware variants major goals experiments develop malicious behavior templates match malware variants measure false positive rates algorithm generates templates measure detection algorithm resilience obfuscation malware instances wild developing behavior templates starting point obfuscation transformations obfuscation resilience testing highlights evaluation template-based algorithm detects worms family unrelated worms single template false positives generated running illustratingthe soundness algorithm current implementation algorithm exhibits improved resilience obfuscation compared commercial anti-virus tool mcafee virusscan variant detection evaluation developed templates tested malware samples benign programs template captures decryption-loop functionality common malicious programs template captures mass-mailing functionality common worms section decryption-loop template results mass template similar malware samples variants netsky variants agle variants sober worms variants wild ranging size malware template detection running time family decryp-tion loop mass-mailer avg std dev netsky agle sober table malware detection algorithm amd e-mail worm instances decryption-loop template describes behavior programs unpack decrypt memory template consists loop processes data source memory area writes data toadestinationmemoryarea ajumpthattargets destination area binary worms technique make static analysis harder actual code worm inspection runtime construct template analyzed netsky worm manually extracted code performs decryption jump template generalized code replacing actual registers memory addresses variables massmailing template developed similar manner describes custom smtp functionality present worm including composition transmission applied algorithm malware instance decryption-loop template achieved detection netsky agle worm instances templates mass-mailing template required minor tweaks detect agle sober worm instances match mass-mailing template requiring separate template due limitations current prototype implementation matching calls microsoft visual basic runtime library sober worm instances supported nonetheless shown algorithm amd detect multiple worm instances family template contrast commercial virus scanners require signatures mcafee virusscan signatures detect worms test set detection results caveat netsky variants processed ida pro build tool assumption disassembly performed successfully variants false negatives running times tool listed table satisfactory prototype suggest real-time performance achieved optimized implementation false positive evaluation set benign programs order measure false positive rate evaluate templates developed set programs sizes standard microsoft windows system programs compiler tools microsoft office programs test larger benign binaries sizes disassemble successfully successfully disassembled programs false positive rate meaning implementation amd correctly classified programs benign test programs matched templates figure present results evaluation programs grouped size increments disassembly detection rates plotted group bar point represents programs size programs group disassembled successfully detected benign failed disassemble disassembler crashed failed group program code functions running time test case ranged average false positive evaluation binaries bprogram size grouped increments disass embly rate figure evaluation algorithm amd set benign windows programs yielded false positives gray bars percentage programs disassembledcorrectlyandweredetectedas benign white bars percentage programs failed disassemble obfuscation resilience evaluation test resilience obfuscation applied garbage insertion transformations varying degrees complexity worm variant agle compared detection rate malware detection tool mcafee virusscan garbage insertion transformation adds code fragments program code fragment irrelevant insertion context considered types garbage insertion nop insertion adds simple sequences nop instructions stack-op insertion adds sequences stack operations math-op insertion adds sequences arithmetic operations generated variants type obfuscation test limits implementation math-op insertion transformations replaced single instructions form const equivalent sequences results tabulated table tool catches obfuscations exception math-op replacement transformation case algorithm seeks match template instruction form const equivalent instruction sequences detected obfuscation type algorithm amd mcafee virusscanaverage time detection rate nop stack math table evaluation algorithm amd set obfuscated variants agle comparison include detection rate mcafee virusscan related work compare work existing research areas malware detection translation validation software verification malware detection previous work demonstrated current commercial virus scanners easily evaded simple obfuscations hackers malware-detection techniques based staticanalysis executables area previously malware-detection algorithm called safe safe handle simple obfuscations nops matching instructions shown figure handled safe formal semantics malware detection explored earlier work static analysis binaries kruegel detect kernel-level rootkits attack tools hackers hide presence system administrators suspicious instruction sequences symbolic execution detection algorithm presented paper powerful multiple decision procedures symbolic execution specification malicious behavior richer kruegel algorithm result powerful tool detecting kernel-level rootkits explore interesting application algorithm future singh lakhotia provide annotated bibliography papers malware analysis detection essential step statically analyzing executables disassembly translates machine code assembly code linn debray demonstrate simple obfuscations thwart disassembly process abovementioned research demonstrates importance handling obfuscations malware detection kruegel present techniques disassembling obfuscated executables paper assume malware analyzed disassembled theoretical limits malicious code detection specifically virus detection focus researchers virus malware replicates copying code program files cohen chess-white showed general problem virus detection undecidable spinellis proved problem reliably identifying bounded-length virus np-complete results similar result presented paper theorem formal model malware detection researchers present semantics algorithm detecting specific malicious behaviors avoiding problem undecidability proven cohen problem undetectable malware classes introduced chess white dynamic monitoring malware detection cohen chess-white propose virus detection model executes code sandbox approach rewrites binary introduce checks driven enforceable security policy inline monitor irm approach static analysis improve efficiency dynamic analysis techniques static analysis remove redundant checks irm framework future explore hybrid static-dynamic approaches malware detection translation validation translation-validation system attempts verify semantics program changed optimizing transformation differences malware detection translation validation discussed 
introduction software verification work closely related previous results static analysis techniques verifying security properties software larger context work similar existingresearch software verification important differences systems analyze benign code handle obfuscations knowledge existing work static analysis techniques verifying security properties analyzes source code hand analysis technique works executables conclusion observe malicious behaviors decryption loops variants malware based intuition gave formal semantics malware detection presented malware-detection algorithm sound respect semantics experimental evaluation demonstrated algorithm detect variants malware false positives resilient obfuscation transformations generally hackers opportunities work future address limitations discussed section table plan optimize tool reduce execution times acknowledgments thankful anonymous reviewers invaluable comments express gratitude giovanni vigna shepherd revision process feedback ashcraft engler programmer-written compiler extensions catch security holes proceedings ieee symposium security privacy oakland pages ball rajamani automatically validating temporal safety properties interfaces proceedings international spin workshop model checking software spin volume lecture notes computer science pages toronto ontario canada springer-verlag heidelberg bishop dilger checking race conditions file accesses computing systems chen wagner mops infrastructure examining security properties software acm conference computer communications security ccs acm press november chess improving computer security extending static checking proceedings ieee symposium security privacy oakland pages chessands white proceedings virus bulletin conference christodorescu jha static analysis executables detect malicious patterns proceedings usenix security symposium security pages usenix association usenix association aug christodorescu jha testing malware detectors proceedings acm sigsoft international symposium software testing analysis issta pages boston usa july acm press ciubotariu netsky conflict starter virus bulletin pages cohen computer viruses theory experiments computers security corbett dwyer hatcliff pasareanu robby laubach zheng bandera extracting finitestate models java source code proceedings international conference software engineering icse pages acm press currie rajan automatic formal verification dsp software proceedings annual acm ieee conference design automation dac pages acm press datarescue ida pro interactive disassembler published online http datarescue idabase accessed feb detlefs nelson saxe simplify theorem prover published online athttp research compaq src esc simplify html accessed nov erlingsson schneider irm enforcement java stack inspection proceedings ieee symposium security privacy oakland pages feng automatic formal verification scheduled vliw code proceedings joint conferenceonlanguages compilersandtoolsforembedded systems software compilers embedded systems lctes scopes pages acm press gordon lessons virus developers beagle worm history april securityfocus guest feature forum securityfocus published online http securityfocus guest accessed sep gordon loeb lucyshyn richardson csi fbi computer crime security survey technical report computer security institute jensen etayer thorn verification control flow based security properties proceedings ieee symposium security privacy oakland kruegel robertson valeur vigna static disassembly obfuscated binaries proceedings usenix security symposium security san diego aug kruegel robertson vigna detecting kernel-level rootkits binary analysis proceedings annual computer security applications conference acsac tucson dec lahiri seshia uclid decision procedure alur peled editors proceedings international conference computer aided verification cav volume lecture notes computer science pages boston usa july springer-verlag heidelberg linn debray obfuscation executable code improve resistance static disassembly proceedings acm conference computer communications security ccs oct levitt andr olsson mcf amaliciouscode filter computers society lurhq threat intelligence group sobig spam received today technical report lurhq published online http lurhq sobig html accessed jan lurhq threat intelligence group sobig evolution worm technical report lurhq published online http lurhq sobig-e html accessed jan lurhq threat intelligence group sobig examined technical report lurhq published online http lurhq sobig-f html accessed jan marinescu russian doll virus bulletin pages aug mcgraw morrisett attacking malicious code report infosec research council ieee software sept oct nachenberg computer virus-antivirus coevolution communications acm jan necula translation validation optimizing compiler proceedings acm sigplan conference programming language design implementation pldi pages acm press june pnueli siegel singerman translation validation proceedings international conference tools algorithms construction analysis systems tacas volume lecture notes computer science pages springer-verlag heidelberg mar singh lakhotia analysis detection computer viruses worms annotated bibliography acm sigplan notices feb spinellis reliable identification bounded-length viruses np-complete ieee transactions information theory jan ferrie hunting metamorphic proceedings virus bulletin conference pages sept mbie mbie homepage published online http mbie host accessed jan proof theorem program template amd returns function set nodes nodes satisfy conditions section function exists theamd returned prove set states program simply refer state template refer template state recall state program -tuple comprising assignment val values registers program counter memory contents mem node template node state proof equate program counter cfg node corresponds binding define template state denoted letb val ing val equal expression state define program counter node define mem mem initial node template node program state define recall denotes instruction node state denotes state obtained executing instruction state denotes event generated executing instruction state sprime equal equal letst andet sincen unifiable easy template node assume program state sprime feasible path path sprime sprime node executing path sprime state sprime yields state denote fact squiggleright execution sequence starts ends event generated obtain execution sequences squigglerights recall set variables instruction variable expression unchanged path sprime executing instruction template states results memory accesses generate event transitions node template continue augmenting execution sequences obtain template state stk stk corresponds final node template end execution sequences squigglerights squigglerights eksquigglerightsk etk execution sequences program template eti template states sti satisfy property executing instruction program state instruction sti template state results memory accesses generate event template executing instruction sti state sti state results memory accesses generate event proof abovementioned property condition def-use paths preserved program observations easy intermediate representation language intermediate representation program cfgs node graph instruction edges cfg unlabeled exception outgoing edges conditional control flow instruction case instruction labeled jump outgoing edges labeled condition holds true branch instructions elements language simple rules illustrated table instruction term assignment updates state variables call functions program external functions library system routines expression arithmetic bit-vector relational operators special memory addressing operator term expr assign expr call expr expr expr expr ident expr memory expr ident number string xor bitand bitor bitxor bitnot equal lessthan greaterthan leq geq bitshiftleft bitshiftright minus star div mod table resentation expressions def-use paths predicates list complete set predicates program fragments proven semantic nops program figure satisfy template figure table list def-use chains template derived predicates relate program expressions 
program fragments notation nprime describes variable def-use path def nprime def-use chain predicate program fragment valpost ecx valpre eax ebx nop ecx eax valpost ecx valpre eax ebx ebx ecx eax valpost eax valpre eax ebx nop ecx eax eax ecx valpost eax valpre eax ebx ebx ecx eax eax ecx valpost ebx valpre ebx nop ecx eax eax ecx valpost ebx valpre ebx ecx eax eax ecx valpost eax valpre eax ebx nop ecx eax eax ecx mem ebx mem eax valpost eax valpre eax ebx ebx ecx eax eax ecx mem ebx mem eax valpost ebx valpre ebx nop ecx eax eax ecx mem ebx mem eax eax eax valpost ebx valpre ebx ecx eax eax ecx mem ebx mem eax eax eax table def-use paths predicates program paths figure 
automated generation analysis attack graphs oleg sheyner computer science department carnegie mellon oleg cmu joshua hainesa mit lincoln laboratories lexington jhaines sst mit somesh jha computer sciences department wisconsin jha wisc richard lippmanna mit lincoln laboratories lexington rpl sst mit jeannette winga computer science department carnegie mellon wing cmu abstract integral part modeling global view network security constructing attack graphs practice attack graphs produced manually red teams construction hand tedious error-prone impractical attack graphs larger hundred nodes paper present automated technique generating analyzing attack graphs base technique symbolic model checking algorithms letting construct attack graphs automatically efficiently describe analyses decide attacks costeffective guard implemented technique tool suite tested small network includes models firewall intrusion detection system overview networks hosts continue grow size complexity evaluating vulnerability attack increasingly important automate tools cops renaud deraison nessus security scanner report vulnerabilities individual hosts evaluate vulnerability network hosts analyze effects interactions local vulnerabilities find global vulnerabilities introduced interconnections hosts typical work sponsored defense advanced research projects agency air force contract army research office aro contract daad opinions interpretations conclusions recommendations authors necessarily endorsed dod aro united states government process vulnerability analysis network proceeds determine vulnerabilities individual hosts scanning tools cops nessus scanner local vulnerability information information network connectivity hosts produce attack graphs path attack graph series exploits call atomic attacks leads undesirable state state intruder obtained administrative access critical host perform analyses risk analysis reliability analysis shortest path analysis attack graph assess vulnerability network constructing attack graphs crucial part vulnerability analysis network hosts construction hand tedious error-prone impractical attack graphs larger hundred nodes automating process constructing attack graphs ensures attack graphs exhaustive succinct attack graph exhaustive covers attacks succinct network states intruder reach goal follow steps produce analyze attack graphs model network model network finite state machine state transitions correspond atomic attacks launched intruder desired security property intruder obtain root access host intruder goal generally corresponds violating property produce attack graph model step modified version model checker nusmv automatically prominimality compiler modifiednusmv analyzer annotated attack graph xml spec querygraph reliability analyzer attack graphproperty nusmvmodel safety decompiler figure tool suite duces attack graph graphs rendered graphviz visualization package analysis attack graphs raw attack graph low-level state transition diagram domain specialist analyze meaningful parse graph reconstruct original meanings state variables relate network intrusion domain section discuss analyses attack graphs quantify likelihood intruder success figure shows architecture tool suite require expect users tool suite model checking expertise input language nusmv model checker user describe network model desired property xml built special-purpose compiler takes xml description translates input language nusmv field model checking fundamental data structures binary decision diagrams bdds enabled significant advances size systems analyzed recently model checking researchers developed variety reduction abstraction techniques handle larger possibly infinite state spaces techniques build underlying representation algorithms model checking leverage recent success field model checkers handle larger state spaces analysis applied larger networks paper reports contributions analyzing vulnerabilities networks exhibit algorithm automatic generation attack graphs algorithm generates exhaustive succinct attack graphs provide tool part larger tool suite implements algorithm small case study identify level atomicity describing model network intruder arsenal atomic attacks model abstract understood security domain experts simple tool analyze efficiently network model includes intrusion detection components distinguishes stealthy detectable attack variants generate stealthy attack subgraphs subgraphs attacks detected intrusion detection components analysis stealthy attack subgraphs reveals locations placing additional intrusion detection components describe ways analyzing attack graphs algorithm determining minimal set atomic attacks prevention guarantee intruder fail probabilistic reliability analysis determines likelihood intruder succeed paper organization give detailed description attack graph generation algorithm section describe intrusion detection case study section results attack graph analysis section discuss related work section close suggestions future work section attack graphs define formally attack graphs data structure represent attacks network definition attack graph tuple set states transition relation set initial states set success states intuitively denotes set states intruder achieved goals stated assume input set states transition relation set initial states labeling states propositional formulas aga safety property output attack graph algorithm model checking find set states violate safety property aga restrict transition relation states set figure algorithm generating attack graphs transition relation total define execution fragment finite sequence states execution fragment execution execution final state attack execution corresponds sequence atomic attacks leading intruder goal state constructing attack graphs model checking technique checking formal model system satisfies property property false model model checkers typically output counter-example sequence transitions ending violation property model checker nusmv model finite labeled transition system property written computation tree logic ctl paper safety properties ctl form aga formula propositional logic model satisfies property nusmv reports true satisfya nusmv produces counterexample context model network safety property single counter-example shows attack leads violation safety property attack graphs depict ways intruder force network unsafe state express property unsafe state reached aga property false unsafe states reachable initial state precise meaning unsafe depends network property privilege level adversary host index root administrative privilege aga network adversary privilege network priv roota briefly describe algorithm constructing attack graphs property aga step determine set states reachable initial state algorithm computes set reachable states path unsafe state set states computed iterative algorithm derived fix-point characterization operator transition relation model transition state restricting domain range obtain transition relation encapsulates edges attack graph attack graph represent set nodes set edges graph set initial states set success states algorithm figure symbolic model checkers nusmv transition relation sets states represented bdds compact representation boolean functions efficient bdd algorithms operations algorithm attack graph properties show attack graph generated algorithm figure exhaustive lemma succinct lemma succinctness property states attack graph lemma states similar property transitions appendix proof lemma lemma exhaustive execution input model violates property aga attack attack graph succinct states state input model attack graph attack succinct transitions transition input model attack graph attack includes intrusion detection network shown figure target hosts firewall separating rest internet shown host running services ftp sshd database intrusion detection system ids watches network traffic target hosts world atomic attacks identified numerically sshd buffer overflow ftp rhosts remote login local buffer overflow explanation attack atomic attack 
detectable intrusion detection system trigger alarm attack stealthy ids misses ftp rhosts attack find target host vulnerabilities writable home directory executable command shell assigned ftp user local buffer overflow exploits vulnerable version xterm executable intruder launches attack starting single computer lies firewall eventual goal disrupt functioning database intruder root access database host construct finite state model network state transition corresponds single atomic attack intruder state model represents state system atomic attacks typical transition state state corresponds atomic attack preconditions satisfied postconditions hold state attack sequence state transitions culminating intruder achieving goal entire attack graph representation ways intruder succeed finite state model network model network set facts represented relational predicate state network specifies services host vulnerabilities connectivity hosts remote login trust relation ritchey ammann connectivity expressed ternary relation means host reachable host port note connectivity relation incorporates firewalls elements restrict ability host connect slightly abusing notation network route similarly model trust binary relation user log host host authentication host trusts host initially trust hosts trust relation empty connectivity relation shown table entry table corresponds pair hosts entry triple boolean values connected physical link connect ftp port connect sshd port intruder intruder store knowledge target network users knowledge includes host addresses vulnerabilities information running services function plvla hosts user roota level privilege intruder host total order privilege levels user root initially intruder root access machine access hosts intrusion detection system atomic attacks classified detectable stealthy respect intrusion detection system ids attack detectable trigger alarm executed host network segment monitored ids attack stealthy ids ids function ids host host attack ids attack detectable executed source host target host ids attack stealthy executed source host target host ids attack detectable stealthy strains success detecting attack depends database adversary ftp sshd firewall router ids ipa ftp figure network strain refer host ids specifies intrusion detection system component located host refer hosts ids specifies intrusion detection system component monitoring network path addition global boolean variable specifies ids alarm triggered previously executed atomic attack paths monitored single network-based ids path monitored host-based intrusion detection components atomic attacks model atomic attacks sshd buffer overflow remote-to-root attack immediately remote user root shell target machine detectable stealthy variants ftp rhosts ftp vulnerability intruder creates rhosts file ftp home directory creating remote login trust relationship machine target machine attack stealthy remote login existing remote login trust relationship machines intruder logs machine user shell supplying password operation legitimate action performed regular users intruder point view atomic attack attack detectable local buffer overflow intruder acquired user shell target machine step exploit buffer overflow vulnerability setuid root file gain root access intruder transfer binary code ftp scp create locally editor attack stealthy atomic attack rule describes intruder change network add knowledge specification atomic attack components intruder preconditions network preconditions intruder effects network effects intruder preconditions component lists intruder capabilities knowledge required launch atomic attack network preconditions component lists facts network hold launching atomic attack finally intruder network effects components list attack effects intruder network state sshd buffer overflow attack attack sshd-buffer-overflow intruder preconditions user-level privileges host user root-level privileges host root network preconditions host running sshd ssha host reachable port spa intruder effects root-level privileges host root network effects host running sshd ssh end nusmv encoding ensure model checker considers atomic attacks state resulting atatt att att att att att att att att att att att att att att att att att att att att att att att att figure attack graph tack graph enumerates attacks model checker choose attacks nondeterministically subject preconditions fulfilled nondeterministic choices source host target host atomic attack nusmv encoding model nondeterministically assigned state variables attack concretely attack number source host atomic attack initiated target host atomic attack attack detectable stealthy respect intrusion detection system variable set deterministically attack detectable stealthy attack detectable stealthy strains variable set nondeterministically effort reduce state space model nusmv encoding restricts legal states attack number source target variables correspond enabled attack addition variable irrelevant context deterministically set variable fixed context attack local host force variable designating source host attack target host attack experimental results attack graphs recall goal intruder obtain access database service running host intruder root access triggering ids alarm property violate order attack graph intruder root privilege host detected ids aga network adversary privilege network priv root figure shows attack graph produced nusmv property node labeled attack number table corresponds atomic attack attempted flag indicating attack stealthy detectable intrusion detection system numbers source target hosts tables show attack host numbers attack sshd buffer overflow ftp rhosts remote login local buffer overflow host path graph root node leaf node shows sequence atomic attacks intruder employ achieve goal remaining undetected instance path highlighted double-boxed nodes consists sequence atomic attacks overflow sshd buffer host overwrite rhosts file host establish rsh trust hosts log rsh host host finally overflow local buffer host obtain root privileges performance observations conducted experiments pentium iii ghz ram running redhat linux nusmv encoding simple network figure bits state potentially states states reachable tool automatically found bdd variable ordering run time tool seconds gauge run time depends scale model enlarged additional hosts additional atomic attacks vulnerabilities flexible firewall configurations enlarged model bits state reachable states attack graph nodes edges nusmv hours construct attack graph model model checking part minutes performance bottleneck inside graph generation procedure working performance enhancements analysis attack graphs attack graph generated specific network respect safety property user probe analysis analyst faced choice deploying additional network attack detection tools prevention techniques cost-effective deploy minimization analysis sections analyst determine minimal set atomic attacks prevented guarantee intruder achieve goal reliability analysis section analyst determine likelihood intruder succeed likelihood ids detect attack activity minimization analysis fixed set atomic attacks intruder find minimal set atomic attacks prevent intruder fails achieve goal answer question modify model slightly making subset atomic attacks intruder simplicity nondeterministically decide subset initially attack begins choice made subset atomic attacks remains constant attack ran model checker modified model invariant property intruder root privilege host aga network adversary privilege network priv roota post-processor marked states intruder detected ids result shown figure white rectangles 
environment-sensitive intrusion detection jonathon giffin david dagon somesh jha wenke lee barton miller computer sciences department wisconsin giffin jha bart wisc college computing georgia institute technology dagon wenke gatech abstract perform host-based intrusion detection constructing model program binary code restricting program execution model improve effectiveness model-based intrusion detection systems incorporating model knowledge environment program runs increasing accuracy models dataflow analysis algorithm context-sensitive recovery static data environment configuration files command-line parameters environment variables constrains acceptable process execution environment dependencies added program model update model current environment program execution static data-flow analysis associates program data flows specific calling contexts data analysis differentiate systemcall arguments flowing distinct call sites program average reachability measure suitable evaluation call-stackbased program models demonstrate techniques improve precision test programs models key words model-based anomaly detection dyck model static binary analysis static data-flow analysis introduction host-based intrusion detection system hids monitors process execution identify potentially malicious behavior model-based anomaly hids behavior-based hids deviations precomputed model expected behavior intrusion attempts execution monitor verifies stream events system calls generated executing process monitor rejects event streams deviating model ability system detect attacks false alarms relies precision model static analysis builds execution model analyzing source binary code program traditionally static analysis algorithms conservative produce models overapproximate correct execution previous statically constructed models allowed execution behaviors execution environment processes read environment configuration files command-line parameters environment variables process load time fixed entire execution process environment significantly constrain process execution disabling entire blocks functionality restricting process access process generate language event sequences current environment previous program models constructed static analysis accepted language eli set environments superset system call sequences generated correct execution environment overly general models fail detect attacks versions openssh secure-shell server prior design error allowed users alter execution root-level login process configuration file setting uselogin disabled ssh server disabled vulnerable code attacker subverted process bypass uselogin checks directly executing vulnerable code previous statically constructed models allowed paths program including disabled path executing disabled code attacker undetectably execute root-level commands paper make statically constructed program models sensitive execution environment environment-sensitive program model restricts process execution behavior behavior correct current environment model accepts limited language event sequences event sequences correctly generated current environment detected intrusive sequences correct environment openssh uselogin disabled model disallows system calls system-call arguments reachable vulnerable code paths model detects entire class evasion attacks manipulate environment data sect environment dependencies characterize execution behavior depends environment values similar def-use relations static data-flow analysis environment dependency relates values environment uselogin values internal program variables environment-sensitive hids loads program model execution enforcement customizes model current environment based dependencies paper manually identify dependencies long-term goal automate procedure sect postulate automated identification onerous task environment sensitivity works system-call argument analysis static analyzer includes powerful data-flow analysis recover statically system-call arguments execution paths program set system-call argument differently previous data-flow analysis recovered argument values calling context analysis algorithm association argument call site set work encode calling context argument values model correct execution behavior program system-call argument observed runtime match calling context leading system call additionally data-flow analysis crosses shared object boundaries enabling static analysis dynamically-linked executables environment-sensitive program modeling primary focus work make additional contribution evaluation metric existing standard metric measuring model precision average branching factor poorly evaluates models monitor program call stack addition system-call stream context-free language reachability move forward stack events discover set actual system calls reachable current program location average reachability measure fairly evaluates precision program models include function call return events average reachability measure demonstrate whole-program data-flow analysis environment-sensitive models test programs improved precision context-sensitive models summary paper makes contributions static model construction dynamically-linked executables static analyzer continues data-flow analysis shared-object boundaries learning api programs call library code sect context-sensitive encoding recovered system-call arguments detailed sect combined whole-program analysis technique improved argument recovery experiments formal definition environment-sensitive program models methods encode environment dependencies statically constructed program models environment sensitivity static system-call argument recovery improved precision program models section presents work extension commonly-used average branching factor metric suitable program models require update events function calls returns sect average reachability measure fairer comparison call-stack-based models models monitor call stack related work fix schneider added execution environment information programming logic make program specifications precise logic program execute allowing precise analysis program proof system notion environment general including properties scheduler behavior proposing similar idea environment information precisely characterize expected program behavior program model models describe safety properties violated focus environment aspects constrain safety properties chinchani instrumented source-code security checks based environment information definition environment primarily encompassed lowlevel properties physical machine process executes knowing number bits integer allowed authors insert code program prevent integer overflows approach specific exploit vectors requires source-code editing making poorly suited environment-sensitive intrusion detection aspect current work environment dependencies static analysis limit allowed values system-call arguments specific problem received prior attention static analysis identify constant statically arguments extracting execution models source code wagner dean identified arguments kernel trapunlink entryunlinklibc unlinkcall call unlink callsite callsite arg home user testfile tmp arg tmp arg home user testfile entryunlinklibc kernel trapunlink unlinkcall unlinkcall arg unknown arg unknown callsite callsite arg home user testfile fig prior static argument recovery argument values recovered execution paths join execution paths converge association specific argument execution path lost argument statically recovered execution path leading system call recovered values discarded argument completely unconstrained statically earlier work binary code analysis recover arguments sparc executables efforts suffered problems earlier binary data-flow analysis required statically-linked executables paper data-flow analysis learn api shared object analyzing executable continue data-flow analysis library api values recovered sensitive calling context forces inaccuracies association system-call argument execution path lost fig attacker undetectably recovered execution path execution path system call execution path set argument recoverable statically values recovered execution paths discarded analysis safe fig current work avoids inaccuracies encoding calling context recovered values static analysis recover values set dynamically paper make distinction dynamic values set load time values set arbitrary user input environment dependencies augment static analysis describe values set operating system loads process flow system-call arguments dynamic analysis learns program model generalizing behavior observed training phase kruegel sekar dynamic analysis learn constraints system-call 
states attacker detected intrusion detection system black rectangles states intrusion detection system sounded alarm white leaf nodes desirable attacker objective achieved detection black leaf nodes desirable attacker achieves objective alarm resolution atomic attacks intruder circular nodes root graph transition root initial state picks subset attacks intruder child root node root disjoint subgraph subset atomic attacks chosen child note number subgraphs descending root node corresponds number subsets atomic attacks intruder successful model checker determines subset successful sequence atomic attacks root graph figure subgraphs subsets atomic attacks intruder succeed left subgraph sshd buffer overflow attack intruder readily intruder succeed remaining undetected ids subgraph attacks entire attack graph implies atomic attacks sshd attack indispensable intruder succeed analyst information guide decisions network defenses profitably upgraded white cluster middle figure isomorphic scenario graph presented figure shows ways intruder achieve objective detection paths intruder reaches white leaf graph checking subset attacks exponential number attacks subsection show finding minimum set atomic attacks removed thwart intruder fact np-complete subsection show minimal set found polynomial-time minimum minimal critical attack sets assume produced attack graph safety property aga set attacks attack graph set states set edges initial state figure attack graph analysis labeling function edge corresponds attack state set attacks critical respect intruder reach goal attacks removed arsenal equivalently critical respect path unsafe state edge labeled attack critical set state minimal denoted subset critical respect critical set state minimum denoted critical set general multiple minimum multiple minimal critical sets state minimum critical sets size attack graph problem finding minimum critical set attacks call problem minimum critical set attacks mcsa problem prove decision version mcsa np-complete lemma assume attack graph integer problem determining critical set np-complete proof sketch prove problem guess set size check critical set attacks accomplished polynomial time procedure problem prove problem np-hard give reduction minimum cover problem page appendix remaining details proof computing minimal critical sets problem finding minimal critical set initial state give algorithm computing runs time size attack graph number attacks describe procedure determines set critical set initial state procedure runs time simply delete edges labeled action set unsafe state reachable initial state critical set path unsafe state attack set step performed time standard graph algorithms algorithm starts empty set step algorithm perform procedure returns true algorithm stops returns pick add set start empty set adding attacks obtain critical set notice critical set number steps algorithm step takes time worst case running time algorithm attacks costs step pick attack minimum cost pick minimum cost bias procedure pick sets lower cost show procedure carried model checking assume set attacks associate boolean variable attack attack activated intruder attack variable appears precondition attack initially set representing set empty notice model checker returns counter-example path initial state unsafe state recall specification aga step procedure pick index set stop time model checker counter-example set attacks variables set represents critical set worst case complexity procedure practice symbolic model checkers nusmv perform efficiently intuitively model checker implement procedure probabilistic reliability analysis empirical information likelihood events network wellknown graph algorithms answer quantitative questions attack graph suppose probabilities transitions scenario graph appropriately annotating attack graph probabilities interpret markov decision process details standard mdp iteration algorithm computes optimal policy selecting actions mdp results maximum benefit minimum cost decision maker iteration compute worst case probability intruder success attack graph assign nodes intruder goal achieved benefit nodes benefit run iteration algorithm algorithm finds optimal attack selection policy intruder assigns expected benefit resulting policy state scenario graph expected fraction equivalent probability goal state node assuming intruder optimal policy implemented iteration algorithm attack graph post-processor reliability analyzer figure ran slightly modified version modified attack detectable stealthy variants assumed typical network percentage attempted intrusions performed sophisticated attackers top latest ids technology stealthy attack variants arbitrarily assigned probabilities detecting atomic attack sshd buffer overflow ftp rhosts remote login local buffer overflow intruder goal root access host remaining undetected states goal achieved assigned benefit setup computed probability intruder success strategy attempt sshd buffer overflow host conduct rest attack host possibility detection sshd buffer overflow attack ids activity hosts system administrator technique evaluate effectiveness security fixes instance installing additional ids component monitor network traffic hosts reduces probability intruder remaining undetected installing host-based ids host reduces probability things equal indication remedy effective related work work phillips swiler closest propose concept attack graphs similar attack-centric view system work general modeling language express model seemingly benign system events failure link malicious events attacks attack graphs general proposed phillips swiler recently swiler describe tool generating attack graphs based previous work tool constructs attack graph forward exploration starting initial state symbolic model checker nusmv works backward goal state construct attack graph major advantage backward algorithm vulnerabilities relevant safety property goal intruder explored approach result significant savings space swiler refer advantages backward search paper generally advantage model checking forward search technique expanded include liveness properties model service guarantees face malicious activity model checking leverage advanced techniques developed area cone influence reduction model checking abstracts part system relevant specification context vulnerability relevant safety property considered model checking finally attack graph analysis suggested phillips swiler presented paper plan incorporate analysis tool suite templeton levitt propose requires model attacks model links atomic attacks scenarios earlier atomic attacks supplying prerequisites templeton levitt point relating seemingly innocuous system behavior attack scenarios discover atomic attacks combining attack scenarios attack graphs dacier proposes concept privilege graphs node privilege graph represents set privileges owned user edges represent vulnerabilities privilege graphs explored construct attack state graphs represents ways intruder reach goal root access host defines metric called effort failure metf based attack state graphs orlato describe experimental evaluation framework based ideas surface notion attack graphs similar proposed dacier case phillips swiler dacier takes attackcentric view world pointed attack graphs general experiments conducted orlato appears small examples space required construct attack state graphs prohibitive basing algorithm model checking advantage advances representing large state spaces hope represent large attack graphs perform analytical analysis proposed dacier attack graphs constructed tool plan conduct experimental evaluation similar performed orlato ritchey ammann model checking vulnerability analysis networks unmodified model checker smv obtain counter-example attack unsafe 
arguments constraints include values environment part system-call argument forces tradeoff training phase modify environment values learn general model model fails constrain execution specific environment conversely training current environment environment model longer characterizes correct execution retraining including environment dependencies paper learning static binary analyzer binary program data flow models summaries environment sensitivemonitoring global model builder environment sensitive program model execution program environment monitor execution system call sequence accept executionreject environment dependencies environment dependencies specification system call static binary analyzer data flow models summaries shared object analysis shared object environment dependencies specification system call static binary analyzer data flow models summaries shared object analysis shared object executable analysis model assembly fig architecture arguments dependent environment environment dependencies resolve remaining arguments current environment time model subsequently loaded environment-sensitive models suited model-carrying code execution design sekar proposed unknown untrusted executables include models execution consumer executable model checker verify model violate security policy execution monitor limit program execution allowed model code producer build program model consumer specific execution environment avoid false alarms model general suit environments general model satisfy consumer security policy code producer adds environment dependencies model shipped code model automatically adapt consumer unique environment environment constraints model increasingly satisfy consumer security policy overview model-based anomaly detection phases construction program model execution enforcement model environment sensitivity affects phases figure shows architecture system including environment information phase analysis left occurs program shared object global model builder assembles execution models single wholeprogram model panel execution monitoring occurs time program loaded execution static analyzer builds model expected execution reconstructing analyzing control flows binary executable control flow model construct dyck model context-sensitive model finite-state machine enforce ordering system-call events correct function call return behavior static analyzer encodes environment dependencies dyck model void parse args int argc char argv char tempnam getenv tmp int execmode char unlink home user tmpfile getopt argc argv switch case execmode unlink link optarg break execmode exec sbin mail fig code calls library systemcall wrapper functions boldface analyze sparc binary code show source code readability conciseness omit error-handling code commonly required calling library functions sbin mail exec link unlink unlink fig finite-state machine model code system calls include argument restrictions identified static data-flow analysis environment dependencies describe relationship execution environment variable program detailed sect separate process runtime monitor process execution matches program model monitor resolves environment dependencies dyck model actual environment process execute parsing program command line configuration files system environment variables monitor execution environment operating system loads program prunes portions model code unreachable current environment determining directions branches dependent environment similarly propagates environment values dependencies update system-call argument constraints monitored process begins execution model execution verification enforces restrictions arising environment dependencies function fig figure shows source code readability analyze sparc binary code experiments code environment information ways similar real programs getenv call line returns environment variable tmp typically specifies system directory temporary files returned directory tempnam call construct filename temporary directory filename link unlink system calls lines getopt function call line parses options passed program command line sets library global variableoptarg option requires argument optarg passed argument link line command line option case statement line execute exec line execute present opposite holds exec execute code inside case statement skipped figure shows finite-state machine model constructed parse args earlier static analysis methods model overapproximates correct execution function argument unlink calls unconstrained attacker undetectably delete file directory process holds write access arguments statically recovered unlink line depends dynamic environment variable tmp unlink calls target library system-call wrapper function data-flow analysis system-call argument join values propagating call sites fig joining statically recovered line unknown line forces analyzer discard arguments link unconstrained computed dynamically execution environment system calls inside case statement exec system call accepted calls accepted branch correlation forces case statement exec execute lost glance exec call appears safe static analysis constrain argument due overapproximations model model accepts sequence system calls execute shell process attack issues nop call relinks statically recovered filename shell exec call occurs unlink null nop call unlink sbin mail link bin sbin mail exec sbin mail note attack requires initial nop call link transition model preceded unlink transitions environment sensitivity static argument analysis presented paper repair imprecisions produce program model represents correct execution context-sensitive encoding system-call arguments differentiate values passed unique call sites unlink system-call wrapper enabling recovery static argument line call site recovering argument line adding environment dependencies produces environmentsensitive model shown fig model template dependencies resolved execution monitor monitor instantiates template model current environment suppose environment variable tmp set tmp command line unreachable case statement code removed fig command line home user log monitor prune unreachable exec call constrain values remaining system-call arguments fig model reflects correct execution specific environment cases model prevents relinking attack previously home user tmpfile unlink sbin mail exec tmp link tmp unlink fig environment-sensitive model produced static analyzer model template environment dependencies resolved model loaded symbols branch predicates subsequent system calls command-line parameter omitted present parameter command line tmp tmp environment variable home user tmpfile unlink sbin mail exec link home user log tmp home user tmpfile unlink tmp unlink fig environment-sensitive model execution monitor resolved environment dependencies system-call arguments encoded calling context calls unlink enforce arguments string arguments regular expressions command line code processing option pruned model present exec call unreachable pruned system-call argument analysis analyzer attempts recover system-call arguments statically analyzes data flows program code shared object code determine arguments constrained execution monitor enforces restrictions recovered system-call arguments rejects system call attempts incorrect argument values learning library api object code program linked distinct times static linking occurs part compilation process combines object code form single program shared object file runtime linking time program loaded execution links code separate shared objects main executable static analyzers inspect object code static linking final runtime link analyzer simulates effects runtime link build models programs code distributed shared object files model construction primary steps analyze shared objects program build models program code shared object cache models disk future reuse program models include virtual memory addresses kernel traps function call sites addresses shared object code runtime linking occurs analyzer 
state contrast modified model checker nusmv produce attack graphs representing attacks post-facto analyses performed attack graphs analysis techniques meaningfully performed single attacks graph-based data structures network intrusion detection systems netstat major components netstat set probes points network analyzer analyzer processes events generated probes generates alarms consulting network fact base scenario database network fact base information connectivity network monitored scenario database directed graph representation atomic attacks graph spoofing attack shows steps intruder takes mount specific attack authors state analysis process critical operation generation instances attack scenario respect target network tool network intrusion detection systems netstat automatically producing attack scenarios leave future direction research cuppens ortalo propose declarative language lambda attacks terms preand postconditions lambda superset simple language model attacks work language modular hierarchical higher-level attacks lower-level attacks components lambda includes intrusion detection elements attack specifications includes information steps needed detect attack steps needed verify attack carried studying possibility converting representation attacks lambda future work restricted work safety invariant properties exploit full power model checking method generating attack graphs general classes properties liveness property states user access server aga afa property true server disabled denial-of-service attack plan explore generation attack graphs universally quantified fragments computational tree logic linear temporal logic make tool suite usable security experts system administrators building library specifications atomic attacks hope increasing arsenal specifications outpaces growth arsenal attacks reason model checking successful discovers unknown bugs hardware circuits protocols analogously tool suite based power model checking techniques potentially discover unexpected attacks identify network vulnerabilities principle technique limited modeling attacks expressive power model checkers lets model benign system activity ability modern model checkers handle complex properties adapted tool liveness properties legitimate user transaction finish intruder interference easily temporal logic checked model checker unlike invariants properties handled simple reachability analysis classical graph algorithms adapting power model checking analyze properties opens promising research direction automated security analysis labs graphviz open source graph drawing software http research att tools graphviz bug encore gigamax cache coherence protocol needed minimum state transitions lead state violated safety property bug difficult normal human construct bryant graph-based algorithms boolean function manipulation ieee transactions computers aug burch clarke mcmillan dill hwang symbolic model checking states information computation june clarke grumberg peled model checking mit press consortium extensible markup language xml http rec-xml february cormen leiserson rivest introduction algorithms mit press cuppens ortalo lambda language model database detection attacks proceedings international workshop recent advances intrusion detection raid number lncs pages springer-verlag dacier quantitative evaluation computer security phd thesis institut national polytechnique toulouse dec deraison nessus scanner http nessus farmer spafford cops security checker system proceedings summer usenix conference garey johnson computers intractability guide theory np-completeness freeman company san francisco jha sheyner wing minimization reliability analyses attack graphs technical report cmucs- carnegie mellon february jha wing survivability analysis networked systems proceedings international conference software engineering toronto canada kurshan computer-aided verification coordinating processes automata-theoretic approach princeton press mcmillan schwalbe formal verification gigamax cache consistency protocol suzuki editor shared memory multiprocessing mit press nusmv nusmv symbolic model checker http afrodite itc nusmv ortalo dewarte kaaniche experimenting quantitative evaluation tools monitoring operational security ieee transactions software engineering september october phillips swiler graph-based system network vulnerability analysis security paradigms workshop pages puterman markov decision processes john wiley sons york ritchey ammann model checking analyze network vulnerabilities proceedings ieee symposium security privacy pages schneier modeling security threats dobb journal december smv smv symbolic model checker http cmu modelcheck swiler phillips ellis chakerian computerattack graph generation tool proceedings darpa information survivability conference exposition june templeton levitt requires model computer attacks proceedings security paradigms workshop cork ireland vigna kemmerer netstat network-based intrusion detection system journal computer security exhaustive succinct attack graphs lemma exhaustive execution input model violates property aga attack attack graph succinct states state input model attack graph attack succinct transitions transition input model attack graph attack includes proof finite execution input model unsafe state prove attack sufficient show unsafe holds path input model definition violates aga construction follow immediately suppose attack attack graph construction states transitions states transitions input model attack execution input model state initial state model anda false final state violates property aga construction algorithm figure states generated attack graph reachable initial state violate aga state input model path initial state path unsafe state concatenation execution input model violates aga lemma attack proof complete attack trivially lemma attack state attack figure attack graph set cover problem state attack includes states transition attack trivially np-completeness mcsa attack graph problem finding minimum critical set attacks call problem mcsa minimum critical set attacks problem prove decision version problem np-complete lemma assume attack graph integer problem determining critical set np-complete proof prove problem guess set size check critical set attacks accomplished polynomial time procedure problem prove problem np-hard reduction minimum cover problem page minimum cover problem collection subsets finite set positive integer problem determine cover size subset element belongs member construct attack graph collection set attacks equal attack graph initial state final state unsafe enumeration collection collection states edge states collection edge state set edge unsafe state label edge tail label label edge head label easy prove critical set attacks cover size equal give short illustrate reduction set suppose collection consists subsets notice cover size form cover attack graph problem shown figure set attacks set attacks critical path unsafe state edge label set 
performs symbolic relocation shared object code shared object virtual address space indexed strictly symbolic addresses models reside symbolic address space enforcing program model execution monitor detects actual address runtime linker maps shared object code resolves symbolic addresses actual virtual addresses analyze binary executable interest executable call functions exist shared object code analyzer simulates runtime linker symbol resolution identify code body targeted dynamic function call reads cached model shared object code disk incorporates program execution model separate code analysis performed shared object main executable complicates data-flow analysis system-call argument recovery system calls generally library functions frequently argument values system calls set main executable passed library function library api separate analysis library code main executable code precludes previous static data-flow analysis recovering arguments data flow broken library interface remedy problem perform whole-program data-flow analysis track data flowing separate statically linked object files analyzer learns api shared object initiates data-flow analysis system-call sites type information call arguments integer argument string argument data-flow analysis program control flows reverse find instructions affect argument values depends formal argument globally visible function function part api affects system-call arguments cache data-flow summary function characterizes data flows api function entry point system-call site shared object summary function library stipulates argument function call unlink flows argument subsequent unlink system call analyzing object file utilizes learned api continue dataflow analysis calls api analyzer attempts statically recover passed api call composing cached data-flow summary function data dependencies api call site discovered object code analysis recover argument system call inside library context-sensitive argument recovery static argument recovery data-flow analysis identify system-call values statically analysis recovers arguments finite-height lattice values algebra defines combine values lattice lattice bottom element argument argument analyzed top element general means argument determined statically argument values reach system call multiple execution paths shown fig algebra lattice defines compute flow converged execution path join operator combines values previous static argument analysis recovered arguments standard powerset lattice finite set statically strings integers program lattice values elements algebra joined arguments set union lattice values reaching system-call site recovered argument joins lattice diminish precision analysis set union maintain association argument execution path result attacker undetectably recovered path execution path reaching system call suppose program opens temporary file write privileges critical file read-only access argument recovery identify arguments calling context lost attacker write privilege temporary-file open open critical file write privilege worse effect values recovered statically argument identified execution path takes point converging execution entry point library function join recovered discards recovered makes intuitive sense monitoring execution monitor determine recovered enforced knowing calling context solve imprecision extending lattice domain include calling context data-flow analysis annotates recovered string integer values address call site passes strings integers argument stated differently recover values separate powerset lattice calling context data propagates call instruction analyzer annotates return address call found single call site context sufficiently distinguish argument values analysis extended include additional calling context note call site annotation call site nearest system call originating call site argument set originating call site target function program including library calls arbitrary wrapper functions library functions data values recovered data-flow analysis pairs set integers strings calling context information definition powerset lattice set statically-known strings integers program defined call site identifiers special identifier indicating context information context-sensitive data-flow lattice defined domain uniontextni entryunlinklibc kernel trapunlink unlinkcallunlinkcall callsite arg unknown callsite callsite callsite callsite arg home user testfile arg home user testfile fig static argument recovery contextsensitive argument values home user log unlink unlink link sbin mail exec fig model program code fig context-sensitive argument values note argument constrained top-most unlink transition argument unlink call site statically determined define join operator negationslash negationslash join operation maintains calling context information points execution path convergence part joins values powerset lattice values identical calling context part maintains correctness joining context occur previously-identified context lattice improves prior data-flow analysis important ways convergence context-sensitive unrecovered nondestructive analyzer continue propagate execution context fig figure shows model code contextsensitive arguments statically filename passed call unlink call site fig constrains call intuitively discard recovered context-sensitive monitor runtime compare context information executing process call stack determine argument restriction enforced multiple context-sensitive values converge information lost distinct calling contexts remain distinct preserving context enforce association multiple arguments passed system call call site recall previous opening temporary file critical file access privileges analysis annotate filename access mode call site site calling context attacker open critical file read-only access monitor enforces argument restriction execution path system call call-site address annotating argument monitor walks call stack process system call identify calling context system call call-site address annotates exists calling context monitor enforces argument restriction argument recovered context monitor constrain allowed values runtime environment-sensitive models environment-sensitive intrusion detection restricts allowed process execution based fixed data execution environment environment-sensitive program models include data directly encode dependencies environment data evaluated immediately process begins execution formalize notions environment properties dependencies environment program definition environment program input process load time fixed entire execution process includes environment variables command-line parameters configuration file contents definition excludes environment variables altered overwritten execution measurements programs installed solaris modify environment variable definition property environment single variable parameter configuration setting file property present omitted environment present environment dependency captures relation environment properties program execution behavior definition set environments property set non-environment program inputs alue denote possiblyinfinite set values program point read data location environment program input environment dependency exists dbracketleftbig bracketrightbig words executions program data depends function characterizes data depends environment property definition intuitively similar definition def-use relation programming language analysis environment defines data executing process existing program analyses examine relations instructions program extend notion definition environment dependencies interest affect program behavior visible execution monitor focus classes dependencies present code fig control-flow dependencies exist program branches branch direction depends environment property data-flow dependencies occur visible data system-call argument dependent environment environment property flows system-call argument home user tmpfile unlink sbin mail exec link unlink fig dyck model environment branch dependencies symbols branch predicates subsequent system calls command-line parameter omitted present control-flow dependencies control-flow dependencies restrict allowed execution paths based values environment variable tested program branch dependent environment property statement line 
guards exec call executes omitted command line program data variable branch test dependent definition consequence branch direction depends similarly theswitchstatement line environment control-flow dependency execute case line present static analyzer encode control-flow dependencies dyck model predicate transitions figure shows model fig predicate transitions characterizing environment dependency predicatel-is satisfied command line likewise satisfied present execution monitor evaluates predicate transitions loading model program execute predicates satisfied environment -transitions -transition transparent events transition conversely monitor deletes edges predicates satisfied environment legitimate process execution follow path command line passed code fig transition fig subsequent exec transition removed prevent model accepting unlink link calls data-flow dependencies system-call argument values depend environment properties programs frequently environment values computing strings passed system calls filenames values significantly restrict allowed access process attacker subverted process code fig environment variabletmpgives system temporary directory prefix filename argument lines property constrains unlink line files remove temporary files parameter command-line property fully defines filename passed argument link real-world programs exhibit similar behavior apache web server command-line property server root directory environment data-flow dependencies augment existing system-call arguments recovered techniques sect figure adds argument dependencies previous model fig bracketed environment property argument simply template instantiated actual property program load time figure completed environment-sensitive dyck model context-sensitive argument encoding program fig loaded execution monitor reads current environment instantiates model environment template argument values replaced actual values environment properties argument depends final instantiated models fig sect dependency identification paper aims demonstrate environment-sensitive intrusion detection problem automated dependency identification assume environment dependencies precomputed manually experiments manually identified environment dependencies iterative model refinement high-level process parallels counterexample-guided abstraction refinement software model checking dyck model abstraction defining correct execution iteratively refine model environment dependencies improve abstraction monitored process execution collected trace reachable potentially malicious system calls sect trace included calling context potentially malicious call occurred inspected program code determine argument passed call-site calling context depended environment information reached system call branch guarded call-sites branch predicate depended environment function-call arguments branch predicates depend environment backward slice reaches function read environment getenv getopt added dependency dyck model repeated iteration practice number dependencies added iterative refinement small program experiments contained dependencies manual specification drawbacks requires user understand lowlevel process execution behavior dyck model characteristics manual work errorprose miss dependencies obscured control-flows difficult comprehend dependency identification limited manual specification postulate automated techniques identify environment dependencies direction analyst feasible summary functions library calls read environment enable existing static data-flow analysis automatically construct environment-dependent execution constraints complex dependencies learned dynamic analysis dynamic trace analyzer correlate environment properties features execution trace produce dependencies paper makes clear benefits model specialization based environment dependencies improvements noted sect motivate implementation techniques automatically identify dependencies expect future work address implementation issues average reachability measure measurements model precision ability prevent attacks benefits analyses model construction techniques previous papers measured model precision average branching factor metric metric computes average opportunity attacker subverted process execution undetectably execute malicious system call processing system call monitor inspects program model determine set calls accept potentially malicious system calls set unlink unconstrained argument contribute branching factor current monitor configuration average counts entire execution monitor average branching factor model lower numbers precision opportunity undetectably insert malicious call set potentially malicious system calls originally defined wagner remained constant subsequent work average branching factor average branching factor poorly evaluates context-sensitive program models stack update events dyck model paper typical programs characteristics limit suitability average branching factor programs function calls returns system calls number stack update events processed monitor greater number actual system-call events programs rarely execute system-call trap directly programs indirectly invoke system calls calling library functions characteristics important implications stream events observed monitor structure dyck model characteristic implies stack updates dominate event stream characteristic implies configuration monitor set events accepted predominantly safe stack update events contribute configuration branching factor fact potentially malicious system call visible event process execution path entered library function monitor processed stack event function call number potentially malicious system calls visible monitor decreases artificially skewing computed average table test programs workloads instruction counts instruction counts include instructions shared objects program program workload instruction count procmail filter message local mailbox mailx send mode send ascii message receive mode check local mailbox gzip compress ascii text cat write ascii text file branching factor downward call-stack-based model precise average branching factor makes extended average branching factor correctly evaluates contextsensitive models stack update events skew results average reachability measure context-free language reachability identify set actual system calls reachable current configuration monitor simply inspecting events monitor accept average reachability measure walks forward stack events reaching actual system calls forward inspection respects call-and-return semantics stack events limit reachable set system calls monitor operation eventually reach actual system-call event recalculate set reachable system calls count number potentially malicious sum counts divided number system calls generated process average reachability measure average reachability measure subsumes average branching factor metrics identical meaning context-insensitive models context-sensitive models stack events wagner dean abstract stack model compute model types average reachability measures call-stack-based models directly compared measures models allowing understanding differences model types implemented average reachability measure thepost algorithm push-down systems pds research converted dyck model pds ruleset generated post queries system call post algorithm wagner dean operate abstract stack model note expensive post algorithm evaluation purposes monitor verifies event streams efficient dyck model experimental results evaluated precision environment-sensitive program models average reachability precise model closely represents program constructed offers adversary ability execute attacks undetected models utilizing environment sensitivity argument analysis show improvement previous techniques test programs static argument recovery improved precision adding environment sensitivity models increased gains end arguing model-based procmail mailx send mailx receive gzip cat model precision dyck model prior data-flow analysis data-flow analysis environment-sensitive fig precision program models increasing sensitivity data-flows environment y-axis precision average reachability measure average number reachable potentially malicious system calls lower numbers greater precision opportunity attack programs bars bars show graph intrusion detection systems ignore environment information leave susceptible evasion attacks test programs measured model precision unix programs table shows workloads instruction counts programs tested note instruction counts include instructions shared objects program depends procmail additionally code shared objects loaded explicitly 
completeness attack mutation algorithms shai rubin somesh jha barton miller wisconsin madison computer sciences department shai jha bart wisc abstract attack mutation algorithm takes instance attack transforms distinct instances repeatedly applying attack transformations algorithms widely testing intrusion detection systems investigate notion completeness mutation algorithm capability generate attack instances set attack transformations define notion -complete mutation algorithm set transformations algorithm complete respect generate instance transformations derive show rules uniform reversible -complete algorithm exists intuitively speaking uniform reversible transformations exclusively apply transformations simplify attack exclusively apply transformations complicate instances derived rules uniformity reversibility severe restrictions show common attack transformations uniform reversible complete algorithm incorporated existing testing tools intrusion detection systems show -complete algorithm testing purposes determining packet traces mutations attack introduction goal network intrusion detection system nids detect malicious activities attacks network misuse nids defines attack attack signature typically regular expression matches pattern attack ideally time ongoing activity matches attack signature nids raises alarm conceptually nids signature corresponds single attack sequence events exploits vulnerability practice signature match equivalent attack forms attack instances attack split tcp packets ways reliability nids ultimately depends ability detect instance attack researchers attackers successfully evaded nids mutating attack instance nids recognizes instance misses evade nids signature ascii characters url encoding transformation replaces ascii characters url equivalent hexadecimal values increase nids reliability nids developers test nids attack instances generate instances attack developers commonly attack mutation system system components set attack transformation rules url encoding mutation algorithm system testing developer constructs exemplary instance attack developer feeds exemplary instance mutation algorithm algorithm repeatedly applies transformations predetermined random order generates instances attack testing purposes attack mutation systems successfully uncovered vulnerabilities nids knowledge fundamental question underlying nids testing investigated question testing coverage question instances instances derived rules mutation algorithm generate miss address coverage question develop complete mutation algorithm exemplary attack instance set transformations mutation algorithm -complete generate instances length derived exemplary instance rules observations noted -complete mutation algorithm algorithm exhaustively applies rules combination necessarily -complete problem unclear stop generation instances longer eventually derive instances shorter -complete algorithm necessarily generate instances attack theoretically assert rules represent ways transform attack ability prove algorithm -complete step mutation system generates instances attack determining system transformations scope paper achieving -completeness achieve completeness algorithm requires rules reversible uniform reversibility means transformation system inverse uniformity means attack instance derives instance exists derivation simplify complicate result reach define simplify complicate complexity metric attack instances attack instance hex encoding complex instance encodings show rules uniform reversible instances derives derived representative instances called atoms prove atoms split attack instances equivalence classes instances class derived atom property developed two-phase mutation algorithm attack instance automatically compute atom generate instances derivable atom develop union property preserving reversibility uniformity sets transformations set uniform reversible show positively commutative defined section uniform reversible practically speaking property helps prove uniformity reversibility large set rules develop set uniform reversible rules tcp http union property show union sets uniform reversible algorithm -complete respect tcp http rules usages -complete algorithm nids development encounter forensics problem set rules determine attack instances derived problem arises determine trace packets instance attack show section -complete algorithm assert instances derived -complete algorithm asserts instances derived options instances derived algorithm transformations derive instances case algorithm helps uncover transformation instances derived case algorithm helps define attack distinction cases requires manual intervention note incomplete algorithm introduces case instances derivable algorithm determine fact show -complete algorithm efficiently solve forensics problem rules uniform reversible instances algorithm computes atom checks derived atom correctness algorithm stems fact instances derivable atom summary paper makes contributions notion -complete attack mutation algorithm algorithm addresses coverage question core rigorous nids testing process conditions -completeness develop notion uniformity reversibility attack transformations show concepts prove proposed algorithm -complete develop union property helps proving uniformity union sets transformations practical instance uniform reversible set transformations show common attack transformations uniform reversible set rules include transformations tcp-fragmentation tcp-permutation tcp-retransmission application-level transformation url encoding related work review related work areas attack transformations nids testing abstract reduction systems uniform proofs logic programming attack transformations fundamentally network attacks modified transformed level protocol stack ptacek newsham handley paxson introduce tcp transformations fragmentation packet reordering based work tools attack transformations nids testing evasion developed fragroute transforms tcp-based attacks whisker transforms http attacks randomly combine transformations user mucus attack transformations perform cross-testing nids builds packets match signature nids transforms checks nids identifies modified packets recently vigna developed tool applies application-level transformations http encoding injection telnet escape characters addition tcp transformations testing tools based attack transformations snot stick thor tools mentioned successfully found attack instances evade nids tested knowledge researchers developed tools addressed completeness question recently rubin developed tool called agent exhaustively applies transformation rules combinations provide formal proof agent generate instances argue section exhaustiveness guarantee completeness dacier attack mutation evaluate potential set idss handle large set transformations unlike work investigate completeness property system reduction systems uniform proofs formal methodology closely related abstract reduction system reduction system pair binary relation case attack instances relation defined transformation rules knowledge classic reduction system distinguish shrinking simplifying expanding complicating rules general results systems unmodified concept atom section equivalent concept normal form lambda calculus element reduced atom element reduced shrinking rules uniform form lambda calculus reduced rule note instance reduction system strongly normalized respect shrinking rules instance atom miller describe uniform proofs rightintroduction rules analogous shrinking rules section left-introduction rules similar expanding rules main intuition introducing uniform proofs capture goal-directed search proved framework logic programming uniform proofs complete term provable uniform proof uniform proofs explored contexts special structures derivation securityprotocol verification knowledge paper work explores uniform derivations basis generating attack mutations nids testing technical overview exemplary attack demonstrate fundamental concepts attack mutation paper transformations mutation algorithm atoms uniform derivation perl-in-cgi exploit can- perl interpreter installed cgi-bin directory web server allowing remote attackers execute arbitrary commands attack transformations instance perlin-cgi denoted single httpget request web page cgi-bin perl exe assume single tcp segment including tcp handshake segments transformation rules create instances perlin-cgi frag tcp-fragmentation obtained copying segments tcp packets fragmenting single segment segments instance perl-in-cgi url url encoding obtained replacing printable character url hexadecimal ascii instance 
appeared ieee symposium security privacy language-based generation evaluation nids signatures shai rubin somesh jha barton miller wisconsin madison computer sciences department shai jha bart wisc abstract present methodology automatically construct robust signatures accuracy based formal reasoning systematically evaluated methodology based formal languages describe properties attack language called session signature describes temporal relations attack events called attack invariant describes semantic properties hold instance attack invariant state ftp attack include successful ftp login launched ftp representation mode set ascii iteratively eliminate false positives negatives initial session signature comparing signature language language invariant developed gard tool session-signature construction construct session signatures multi-step attacks show session signature accurate existing signatures introduction misuse network intrusion detection system nids defines attack attack signature typically regular expression matches pattern attack ideally time ongoing activity matches attack signature nids raises alarm ultimately security nids depends primarily accuracy signatures conceptually signature represents single attack set events exploit vulnerability practice single attack appears forms attack instances pro-ftpd attack requires ftp commands ordered ways can- signature essentially concise representation large set attack instances construction accurate signature daunting task security analysts inspect exemplary attack instances hypothesize properties hold attack instance write expression match properties analysts systematic identify false positives cases signature over-approximates set attack instances false negatives cases signature under-approximates set systematic evaluate impact analysts perform improve signature accuracy single change fix false positive uncover false negative end result ad-hoc time consuming error prone process surprising current signatures inaccurate producing false positives negatives paper develop systematic method construct accurate signatures main idea simple construct initial signature attack build independent representation set attack instances signature match compare signature independent representation comparison reveals false positives negatives manually refine signature repeat process satisfied signature accuracy signature develop paper called session signature existing signatures based regular language models attack events ftp messages session signature models entire attack attacker initiation connection victim indication attack succeeded compared current signatures enables precise definition temporal relations events attack result session signature potentially accurate current signatures section refine accuracy session signature develop notion attack invariant overapproximation set attack instances invariant describes semantic properties conditions attack property successful ftp login required launching attack invariant pro-ftpd attack mentioned semantic properties enable express knowledge protocol attack properties easily expressed signature bridge session signature represents attack syntactic features attack invariant represents semantic features develop semantic model protocol finite state machine specifies protocol command set variables values define protocol state ftp model type variable tracks representation mode ftp session ascii binary describes type command affects variable semantic model serves goals define invariant set machine states pro-ftpd attack succeeds ascii mode pro-ftpd invariant set states type set ascii model compute protocol state sequence commands determine invariant holds sequence essentially session signature attack invariant independent representations set attack instances formally represents set sequences events find false positives negatives compare set sequences represented signature set represented invariant find false positive search sequence matches signature satisfy invariant analogously find false negative search sequence match signature satisfies invariant figure invariant over-approximates set real attack instances sequence part signature part invariant false positive find false positive refine signature reason sequence match signature satisfies invariant necessarily false negative spurious sequence sequence match signature satisfies invariant implement attack manually distinguish false negatives spurious sequences find false negative refine signature find spusp attackinvariant attackinstances false positive false negative spurious sequence sessionsignature figure searching false positives negatives rious sequence refine invariant repeat search false positives negatives longer refine signature invariant satisfied signature accuracy finding false positives negatives improves signature accuracy discovered spurious sequences contribute accuracy force refine invariant understand conditions identifying attack understanding key building highly accurate signatures find false negatives spurious sequences develop searching strategy search false negatives starts sequences events match signature similar terms string matching sequences match research shows sequences real attacks false negatives signature show section searching strategy effective finding false negatives carry search implement gard tool generation analysis refinement deployment nids signatures gard semantic model formalize notion attack invariant compares signature regular language invariant empirically evaluated gard capabilities show session signature simple attack accurate snort contextual counterparts show respect attack invariants signature produces false alarms miss attack instance signatures recognize show gard capable generating signature complex attack attack requires multiple steps succeed illustrate iterative process gard systematically uncover signature inaccuracies gard guarantee discovery false positives negatives finds false positives negative respect attack invariant defining meaningful invariants art based human expertise experience shows simple invariants gard capable finding false positives negatives anticipate majority semantic properties required invariant formally notion semantic model overcome signature limitations signatures require non-regular languages priori knowledge signature limitations important ability generate robust signature based knowledge signature user make rational decisions risks system faces user address risks security means summary paper makes contributions session signature models entire attack regular language show accuracy session signature systematically improved show session signature attacks analyzed accurate current signatures attack invariant representation attack evaluate session signature based semantic model attack protocol gard tool automatic evaluation generation session signatures show based empirical evaluation signatures gard produces superior current signatures related work gard centered combination capabilities modeling entire attack signature-specification language based language operators formal representation protocol semantics methodology evaluate signature accuracy review research tools respect capabilities signature specification languages snort widelyused nids represents signature set attributes packet attributes packet length pattern attributes regular expression defined attack bytes snort signature corresponds single attack event model entire attack snort facilitate composition rules ability dynamically invoke rules logging purposes bro bases detection policy scripts signatures policy script determines actions alerts based events bro identifies sequence ftp commands general script model entire attack regular language requires programming imperative language similar fact impairs ability easily define signature analyze signature accuracy recently sommer paxson bro implement contextual signature enables sequencing events declarative contextual signature model entire attack supports sequencing operators results show section sequencing constructing tight signatures statl signature specification language netstat represents signature state diagram describes sequence events attack statl support forming regular expressions events construction state diagram signature specification evaluation signature accuracy gard state machine intermediate signature representation easy translate gard signature statl work pursue issue sekar developed signature 
specification language based regular expression events entire attack property important comparing signature accuracies section focus network-level attacks tcp syn-flood applicationlevel language gard language attack types address question signature accuracy suggest means evaluate translate signatures finite state machine work benefit evaluation methodology pauzol ducass proposed language called sutekh focus host-based intrusion detection language features similar model attack sequencing operators represent signature finite state machine lambda adele provide abstraction events languages expressive session-signature language general express network host-based attacks provide ability define parallel execution events required network-based attacks languages language provide ability define attack preconditions post-conditions translating signatures language languages easy task research mentioned work provide means evaluate signature accuracy gard support features found tools signatures require detection based properties network packets timers event scheduling explicit event counters count events regular expression inefficient work focused foundational concept gard formal language tools signature specification evaluation missing features integrated gard plan future signature evaluation methodologies current techniques signature evaluation based testing benchmarking knowledge apply formal verification techniques signature evaluation fundamentally verification testing complement verification process strives uncover signature vulnerabilities show absence respect abstract model protocol semantics testing hand aims uncover bugs exercising signature real network traffic wagner soto applied formal methods find vulnerabilities signatures host-based ids intersect language signature accepts language models attack manually construct instance evades signature false negative provide automatic methods constructing false positives negatives hand gard techniques attack invariant automatically perform tasks gard overview illustrate gard construct evaluate session signature purposes chose simple attack called ftp-cwd section show gard handles complex attacks ftp-cwd attack can- exploits vulnerability blackmoon ftp server windows attack requires steps attacker logs ftp server anonymous login buffer overflow providing overly-long argument ftp cwd change directory command attacker gains root privileges host communicates compromised host ftp control port port define signature ftp-cwd perform steps signature specification construct pattern matches sequence events required attack detection sequence events occur entire attack attacker initiation connection victim indication attack succeeded signature evaluation search signature loopholes sequence ftp events false positive false negative construct ftp-cwd invariant gard automatically compare signature language invariant language iterative process continues decide signature accuracy satisfactory longer refine signature invariant define session signature important understand signature matched practice matching session signature requires components lexical scanner translates raw network traffic stream events scanner identifiescwd commands required ftp-cwd signature matching engine matches stream events scanner pattern signature specification signature specification simple assume lexical scanner pass matching engine event part signature specification ftp store command irrelevant detection ftp-cwd scanner pass token matching engine assume network-level protocols tcp handled nids matching process assume tcp connection aborted matching engine halts signature specification session signature based three-phased abstraction preparation attacker sets attack preconditions exploitation attacker launches attack confirmation attacker determines attack succeeded construct session signature define events phase ftp commands arguments form regular expression phase language session signature concatenation phase languages ftp-cwd events intuitively event corresponds protocol message part formally event observable sequence bytes part attack bytes attacker victim gard represents event lexeme regular expression matches sequence bytes token uniquely identifies event lexical scanners flex identified events ftp-cwd preparation phase identified event corresponds response ftp server confirming successful login corresponds attacker attempt login logout attack length data bin intrusion lpre ftp-cwd preparation phase disjunction events table lexp ftp-cwd exploitation phasea lconf ftp-cwd confirmation phase intrusion logout attack ira cql length data bin intrusion logout attack ira cql accept start reject ordinary state superstate mmain machine concatenation phases ftp-cwd ssftp-cwd machine hsm ftp-cwd attack superstate fully detailed note alphabet superstate bytes main machine events awe bin reality attacker necessarily target bin gard libraries expressions analyst build ftp-cwd explotation phase figure ftp-cwd specification operational ftp-cwd session signature logout ftp session exploitation phase event corresponds ftp cwd command event corresponds argument cwd command finally confirm intrusion identified event corresponds invalid response ftp server message part legal ftp response compromised server well-behaved ftp server matches response unix command attacker ftp-cwd check attack succeeded cases define events gard library predefined events common protocols ftp http based ftp specification ftp library table event definition event ftpcwd specification ftp-cwd phase languages explain process signature specification underlying compilation method gard present phase language finite state machine expression languages section ftp-cwd preparation language denoted lpre ensures attacker logged server launching attack imposes conditions figure attacker successfully completed login procedure attacker executed logout procedure show section signatures ensure condition snort ftp-cwd signature generate false positives language figure common ftp attacks added gard library ftp patterns ftp-cwd exploitation language denoted lexp concatenates event event concatenation matches cwd command benign restrict content malicious malicious cwd argument longer bytes string bin figure gard supports restrictions event length relational operators event data regular expressions straightforward matter translate event restriction regular language ftp-cwd confirmation phase denoted lconf single invalid response event figure generating working signature defining regular language phase completes signature specification gard compiles specification intermediate representation explain signature evaluation process provide short summary process intermediate representation gard section presents detailed compilation process gard compilation process steps iftp-cwd ssftp-cwd uftp-cwd ssa edk ssa main concepts signature evaluation illustrated ftp-cwd attack semantic model protocol implement define search false positives negatives language definition set sequences events protocol sequences implement set unambiguously define ssa sequences session signature accepts sequences satisfy invariant edk ssa sequences k-edit distance ssa false positive ssa false negative ssa spurious sequence ssa formalizing signature evaluation comparison regular languages figure fundamentals language-based generation session signatures gard concatenates phase languages main machine figure gard embeds restrictions events main machine separate finite state machines restrictions regular languages restriction represented fsm gard builds non-recursive hierarchical state machine hsm machine states ordinary states superstates fsm ftp-cwd case superstate imposes restrictions data length state superstate accepts restrictions main machine moves attack state moves state figure straightforward matter translate hsm working signature translate hsm snort plugin bro contextual signature signature evaluation purposes easy translate spin model section signature evaluation ultimately task construct signature matches ftp session implements ftp-cwd attack formally denote set ftp sessions implement ftp-cwd uftp-cwd called ultimate set ftp-cwd denote set sessions matches session signature figure ssftp-cwd ideal signature signature ssftp-cwd uftp-cwd non-ideal signature 
perl-in-cgi http-pipe http pipelining obtained inserting benign httpgetrequest web page index html malicious request instance perl-in-cgi denote set rules instance derivable respect result applying rule naturally extend definition derivability sequence rule applications attack mutation algorithm generates instances perl-in-cgi repeatedly applying rules initial instance algorithm complete respect denoted -complete generate length instances derived rules notice -complete algorithm generate instances perlin-cgi instances derived rules -complete algorithm generate instances based tcp transformations tcp-retransmission partial order attack instances clear frag url http-pipe complicate add arbitrary benign http commands obfuscate urls fragment smaller tcp segments time impact rules reversible undo frag merging tcp segments undo url normalizing url printable characters undo http-pipe removing benign http requests transformation forms expanding form complicates instance shrinking form simplifies arbitrary attack instance attack mutation algorithm expanding shrinking transformations generate instances denote shrinking reverse versions frag url http-pipe fragurl- http-piperespectively expanding shrinking transformations imply partial order instances perl-in-cgi length bytes instance rank instance complexity longer instance higher complexity note frag url http-pipe increase instance complexity fragurl- http-pipereduce frag increases complexity additional tcp segment requires additional tcp header atoms intuitively instance atomic shrink single tcp segment include benign http requests printable characters simplest form attack byte required successful attack respect rules building block instances expanding rules derives perl-in-cgi instance fragmented non-overlapping tcp segments benign http commands urls printable characters hexadecimal ascii values uniform derivation uniform derivation shrinking transformations precede expanding discuss section prove proposed mutation algorithm -complete show derives uniform derivation easy expand instance fragmenting frag replacing hexadecimal ascii printable character urlthen replace character fragment instance summary observations shrinking expanding transformations correspond intuition simplify complicate attack instances atoms correspond intuition attack instances simplified instances building blocks attack instances uniformity corresponds intuition derive instances instance simplifying instance shrinking rules expanding rules generate instances achieving -completeness goal section develop -complete attack mutation algorithm formally define transformation rules mutation algorithm notion -completeness section discuss general set rules algorithm recursively applies rules -complete discuss reversibility uniformity transformations section prove proposed algorithm -complete reversible uniform section develop union property states conditions union sets rules uniform reversible notice discussion section imply set transformations uniform reversible goal reveal properties proving -completeness arbitrary definition transformations properties show common tcp transformations section http transformations section defined uniform reversible attack mutation algorithm section model attack instances strings alphabet alphabet set set strings set strings length transformation rule form pre post strings pre post predicates rule interpreted string satisfies predicate pre derivable provided post true string derived rule write set transformation rules string derivable respect denoted exists sequence rules called derivation string set rules closure respect denoted set strings derivable formally finite set strings closure byuniontext mutation algorithm denoted takes finite set strings returns set strings intuitively mutation algorithm takes set attack instances returns larger set instances mutations original definition sound complete mutation algorithm mutation algorithm set transformation rules set strings called sound respect denoted -sound intuitively -sound mutation algorithm generates attack instances derivable respect called complete respect denoted complete intuitively -complete mutation algorithm covers strings derivable respect called k-complete respect denoted complete intuitively k-complete mutation algorithm covers strings length derivable respect practical applications bound number instances mutation algorithm derives focus rest paper k-complete algorithms sound mutation algorithm trivial construct soundness granted mention property required understand difficulty constructing complete mutation algorithm standard work-list algorithm builds closure recursively deriving successors initial instance difficult determine terminate derivation process suppose derive instance length intuitively long included inclined derive instance part general mutation system rule arbitrary effect long derive shorter instance part closure uniformity reversibility difficulty constructing k-complete algorithm suggests system requires ordering attack instances goal uniformity reversibility formalize concepts simplifying complicating attack instance uniformity reversibility precedesequal partial order set precedesequal negationslash set transformations partial order precedesequal rule called shrinking rule rule called expanding rule denote subsets consisting shrinking expanding rules intuitively shrinking rules simplify attack instance expanding rules complicate derivation called uniform exist expanding rule shrinking rule alternatively uniform derivation shrinking rules applied expanding rules definition uniformity set transformation rules called uniform exists partial order precedesequal conditions hold respect precedesequal rule shrinking expanding exists uniform derivation words derivation uniform definition reversibility set transformation rules called reversible rule inverse inverse rule denoted rule holds important observations noted uniform reversible set transformations shrinking rule inverse expanding rule vice-versa observation construct -complete algorithm section mentioned beginning section set transformations uniform reversible sections show define common transformations existing mutation systems uniform reversible rest paper assume partial order mutation system descending chain finite chain attack instances called descending assumption states shrinking rules applied infinitely corresponds fact simplify attack instance point instance section simplest form perl-in-cgi attack respect rules considered computing atoms atom simplest instance attack formalize intuition shrinking expanding rules partial order precedesequal set transformations rule expanding shrinking respect precedesequal string called -atom exist shrinking rule shrinking rule applied -atom string set atoms set -atoms derived finite set strings set atoms defined atom theorem set transformations uniform reversible string set atoms singleton set proof theorem suppose sequences set atoms definition derivations reversible derivation sequence rules derivation input string set uniform reversible rules output atoms singleton set currentstring true shrinking rule applied currentstring break pick rule applied currentstring perform currentstring currentstring end return currentstring algorithm computing atoms uniform reversible currentstring string obtained applying rule currentstring derivable uniform uniform derivation cases shrinking rule shrinking rule applied violating fact atom expanding rule uniform derivation starts expanding rule definition rules expanding rules shrinking rule applied violating fact atom square algorithm shows compute atoms initially algorithm sets currentstring time loop shrinking rule applied currentstring shrinking rule applied currentstring algorithm terminates claim set transformations string uniform reversible algorithm computes atoms proof claim algorithm computes descending chains assume descending chain finite section algorithm terminate clear algorithm computes atom theorem proves uniform reversible set transformations set atoms singleton set algorithm computes set atoms square k-complete mutation algorithm show uniform reversible exists -complete mutation algorithm algorithm presents -complete mutation algorithm uniform reversible compute atoms algorithm lines apply expanding rules sequences atoms generate additional sequences notice sequence input set strings set transformations rules output set test strings worklist compute atoms 
program dlopen static analyzer identify libraries loaded dlopen manually added dependencies program programs static analyzer runtime monitor run solaris sparc monitor executes separate process traces process execution solaris procfile system generate stack events dyck model monitor walks call stack process system call feng design full execution environment traced process visible monitor environment passed monitor monitor forks executes traced process environment environment-sensitive model effects static argument analysis average reachability evaluate models constructed test programs compared versions dyck model varying degrees static data-flow analysis fig report sets results mailx major modes execution sending receiving mail produce significantly execution behavior programs modes compressing decompressing data gzip exhibit notable precision measurements table environment dependencies test programs manually identified dependencies inspection source code object code program environment dependencies procmail program branching depends command-line argument program branching depends command-line argument filename opened depends user home directory mailx program branching depends command-line argument program branching depends command-line argument program branching depends command-line argument filename created depends parameter command-line argument filename opened depends tmp environment variable filename opened depends user home directory filename unlinked depends tmp environment variable gzip argument chown depends filename command line argument chmod depends filename command line filename unlinked depends filename command line cat filename opened depends filename command-line dyck model data-flow analysis system-call argument recovery overlap current test programs test programs previously dyck model reiterate results computed average reachability measure comparable average branching factor numbers previously reported dyck model current results compared previous average branching factor numbers non-stack-based models added system-call argument constraints dyck model constraints recovered previously reported analysis technique arguments values recovered recovered execution paths reaching system call execution path identified statically entire argument unknown dataflows cross shared object program considered unknown limited data-flow analysis improved model precision enabled static data-flow analyses sect argument analysis improved precision effects environment sensitivity made models environment sensitive program manually identified execution characteristics depended environment properties stated formally defined functions definition describe data-flows environment property program variable system-call argument branch condition table lists dependencies added dyck model program system-call argument dependencies augmented values recovered static data-flow analyses presented sect immediately execution monitor instantiates model current environment resolving dependencies procmail mailx send mailx receive gzip cat percent constrained dyck model prior data-flow analysis data-flow analysis environment-sensitive fig percentage potentially malicious system calls identified average reachability measure made safe constraints arguments dyck model data-flow analysis constrained arguments figure reports average reachability measure program execution monitored environment-sensitive models model precision improved procmail gzip cat gzip cat average reachability measures indicating adversary opportunity undetectably insert malicious system call point process execution successful argument recovery constrains system calls attacker longer calls malicious manner evaluated ability techniques constrain system calls figure shows percentage potentially malicious system calls discovered computation average reachability measure restricted system call argument analysis environment-sensitivity figure higher bars represent improved constraints system calls produced correspondingly lower bars previously shown fig programs mailx gzip cat environment-sensitive models constrained potentially dangerous calls expect environment-sensitive program models affect performance runtime execution monitoring monitor update program model load time remove paths unreachable current environment enforce contextsensitive argument restrictions system call table shows execution time overhead arising model update precise enforcement overheads modest one-half short-lived processes procmail mailxand seconds longer-runningcat overheads forprocmail mailx high viewed percentage original runtime occurs due short lifetime processes monitor upfront fixed cost pruning unreachable paths longer-lived processes cat give indication relative cost improved argument recovery increase size program models model additional constraints programs environmentsensitive models required pages memory dyck model argument recovery environment-sensitivity table performance overheads due execution enforcement environment-sensitive models model update one-time cost pruning model execution paths allowed current environment enforcement times include program execution verification system call executed program model program model update environment-sensitive overheadno enforcement model update enforcement total procmail mailx send mailx receive gzip cat results strongly endorse proposed environment-sensitive intrusion detection precision measurements demonstrate analysis tools program execution safely constrained point attackers ability undetectably execute attacks operating system vulnerable program constrain execution models enforce iteration counts loops verify data read written files strongly limit process execution adversely affect underlying operating system processes executing simultaneously evasion attacks intrusion detection systems environment-sensitive susceptible evasion attacks attacks mimic correct process execution environment current environment demonstrate effectiveness environment sensitivity defense attacks designed attack mailx overwrites command-line arguments stored process address space change process execution original command line passed program directed check mail exit attack environment data mailx reads sensitive information sends unwanted attack makes buffer overrun vulnerability whenmailxunsafely copies string thehomeenvironment variable assume attacker alter home variable possibly monitor resolves environment dependencies attacker variable home code inject mailx exploit typical nop sled payload address pattern part consists sequence nops sled exceeds static buffer size instruction sequence obtain current address stack payload rewrites command-line arguments memory change command-line arguments alters execution process perform operation sending spam leaking information return address end payload selected reenter getopt command-line arguments update state variables evasive exploit alter reentry point additional system calls stack frames occur overflow resumed flow attack reentering getopt sufficient implemented mailx exploit loaded home caused program read arbitrary files send unwanted exploit introduce additional system calls reentered original execution path attack perfectly mimicked normal execution environment exception caused register windows sparc architecture effectively manipulate return address exploit code return callee function corrupting stack double return makes exploit detection slightly easier sparc machines exploit attempts reenter function alters return addresses detectable attack limitation present common architecture environment-sensitive models detect evasion attacks monitor resolves environment dependencies process execution begins attack alters environment data execution paths mailx subsequent attack reading sensitive files sending match expected paths command-line input conclusions program models model-based intrusion detection benefit analyses static argument recovery reduces attack opportunities significantly prior argument analysis approaches adding environment sensitivity continues strengthen program models adding environment features models usefulness model-construction techniques shown results models severely constrain test programs execution acknowledgments anonymous reviewers members wisa project wisconsin helpful comments improved quality paper jonathon giffin partially supported cisco systems distinguished graduate fellowship somesh jha partially supported nsf career grant cnsthis work supported part office naval research grant nsf grant ccrthe government authorized reproduce 
distribute reprints governmental purposes notwithstanding copyright notices affixed hereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government chinchani iyer jayaraman upadhyaya archerr runtime environment driven program safety european symposium research computer security sophia antipolis france sept clarke grumberg jha veith counterexample-guided abstraction refinement computer aided verification chicago july debar dacier wespi taxonomy intrusion-detection systems computer networks esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems computer aided verification chicago july feng giffin huang jha lee miller formalizing sensitivity static analysis intrusion detection ieee symposium security privacy oakland feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland fix schneider reasoning programs exploiting environment international colloquium automata languages programming jerusalem israel july gao reiter song gray-box program tracking anomaly detection usenix security symposium san diego aug giffin jha miller detecting manipulated remote call streams usenix security symposium san francisco aug giffin jha miller efficient context-sensitive intrusion detection network distributed systems security symposium san diego feb httpd solaris manual pages chapter feb koziol litchfield aitel anley eren mehta hassell shellcoder handbook discovering exploiting security holes wiley kruegel mutz valeur vigna detection anomalous system call arguments european symposium research computer security pages vik norway oct lam chiueh automatic extraction accurate application-specific sandboxing policy recent advances intrusion detection sophia antipolis france sept muchnick advanced compiler design implementation morgan kaufmann publishers san francisco sekar venkatakrishnan basu bhatkar duvarney model-carrying code practical approach safe execution untrusted applications acm symposium operating system principles bolton landing oct sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding noordwijkerhout netherlands october department energy computer incident advisory capability openssh uselogin privilege elevation vulnerability dec wagner dean intrusion detection static analysis ieee symposium security privacy oakland wagner soto mimicry attacks host based intrusion detection systems acm conference computer communications security washington nov wagner static analysis computer security techniques software assurance phd dissertation california berkeley fall yannakakis graph-theoretic methods database theory acm symposium principles database systems nashville apr 
forall compute atoms algorithm worklist worklist atoms end compute closure tests worklist worklist negationslash pick worklist worklist worklist compute forall elements negationslash tests worklist worklist end end tests tests end return tests algorithm mutation algorithm theorem proves uniform reversible algorithm k-complete -sound picked worklist successor sequences length denoted generated instance-generation purposes assume precedesequal length preserving precedesequal length length show sections assumption holds common attack transformations claim algorithm terminates proof claim show finite number steps worklist empty notice instance generated line added worklist add newly generated instance tests line add instance worklist instance found tests line notice total number instances added tests line bounded finite number instances added worklist bounded notice iteration loop instance removed worklist line note instance removed exist tests added conclude size worklist bounded iteration removes instance worklist emptied finite number iterations square theorem set transformations mutation algorithm algorithm uniform reversible length preserving partial order k-complete -sound proof theorem soundness algorithm fact apply rules generate test cases prove k-completeness show length algorithm generates formally show sequence set generated algorithm assume arbitrary assume uniform reversible uniform derivation uniform derivation form sequence obtained applying shrinking rules cases atom atoms generated algorithm start derivation atoms line length precedesequal length preserving length fact thatprecedesequal length preserving important ensures length equal algorithm generate instances including atom denote atom construct uniform derivation derives passes note showing derivation implies algorithm generates uniform reversible atoms atoms atoms claim exists derivation reversible exists derivation note precedesequal length preserving length instance derivation insert derivation original derivation obtained uniform derivation passes sequence atoms square claim set transformations uniform reversible atoms atoms proof claim theorem atoms atoms singletons assume contradiction atoms negationslash atoms note reversibility derivation uniform conclude exists uniform derivation follow proof theorem show uniform derivation exist atom square combining mutation systems purpose attack mutation convenient separate sets rules network protocols set tcp transformations set http transformations separation facilitates modular testing process test nids tcp transformations http transformations attack instances derived tcp http transformations theorem proved uniform reversible algorithm -complete complete algorithm -complete prove algorithm -complete prove scratch reversibility uniformity transformations show uniform reversible respect partial order positively commutative result simplifies completeness proof complex mutation systems easier prove commutativity sets rules uniformity union definition positively commutative transformations expanding rule shrinking rule respect partial order precedesequal positively commutative sets transformations precedesequal partial order expanding shirking rules respect precedesequal set-wise positively commutative positively commutative positively commutative note positive commutativity weaker condition full commutativity positive commutativity require claim transformation sets setwise positively commutative proof claim intuitively claim expands notion positive commutativity derivation longer rules derivation set-wise positively commutative shift left times derivation repeat shifting process derivation analogously prove square notice positive commutativity imply uniform set rules derivation positive commutativity implies derivation uniform uniform derivation converted uniform theorem generalizes observation theorem sets transformations rules reversible uniform respect partial order precedesequal set-wise positively commutative reversible uniform respect precedesequal proof theorem clear union transformation sets preserves reversibility left show uniform derivation exists derivation derivation proof similar proof claim uniformity commutativity shift shrinking rules beginning derivation express terms subderivations rules lose generality assume derivation starts rules uniform express derivation uniform subderivations prove induction derivation converted uniform derivation form derivation changed shifting process induction number uniformity violations derivation uniformity violation occurrence derivations induction appendix input strings set transformations output true false compute atoms algorithm compute atoms algorithm return true return false algorithm uniform reversible algorithm solves forensics problem summary theoretical results formulated attack transformations uniformity reversibility proved uniform reversible set transformations algorithm k-complete -sound theorem developed algorithm compute atoms algorithm showed uniform reversible atoms singleton set showed atoms atoms claim observation immediately leads algorithm uniform reversible solves forensics problem algorithm investigated union property ensures union sets uniform reversible transformations uniform reversible section show carefully defined common attack transformations uniform reversible uniform reversible tcp rules present set common tcp transformations reversible uniform prove transformations reversible uniform formally define notion tcp sequence semantics transformations section define partial order tcp streams called complexity section prove rules reversible uniform respect complexity section reader advised proof uniformity reversibility based semantics rules words claim previous attack mutation systems include types transformations define transformations reversible uniform reader encouraged check semantics closely represents nature transformations rule definitions easily adopted mutation systems familiar semantics tcp transformations tcp sequence represents communication attacker victim sequence list segments segment represents single message attacker victim exchange segment description frag fragments payload tcp segment segments create overlapping segments payload abcd frag abc bcd frag defragments tcp segments single removes overlapping segments payload abc bcd frag abcd swap swaps tcp segments out-of-order abc bcd swap bcd abc swap swaps tcp segments in-order bcd abc swap abc bcd ret retransmits tcp segment retransmit part payload note application rule produce identical result frag application abcd ret abcd retremove retransmitted segments tcp stream note application rule produce identical result fragapplication abcd retabcd table tcp uniform reversible set tcp transformations ain tcp jargon out-of-order means order sequence numbers formulated pair seq payload seq represents sequence-number payload represents message bytes position segment sequence determines time segment attacker brevity tcp sequence definition includes segments attacker table presents tcp set transformations tcp mutation system superscript denotes expanding rules superscript denotes shrinking rules formally rule form pre post section observations noted system includes tcp rules fragment tcp stream deliver segments out-of-order add retransmitted segments table informally describes rule effects formal semantics rules presented appendix tcp fragmentation rule create overlapping tcp segments definition broader previous define fragmentation splitting turns splitting uniformity existence retransmission merging unsplitting create overlapping segments simplify segments defining de-fragmentation frag overlapping cases fragmentation retransmission effect abc ret abc abc frag abc rules unique effect retransmission rule retransmits substring segment fragmentation rule split segment tcp retransmission rule retransmits data means segments overlap transmit payload overlapping parts definition retransmission facilitates uniformity proof section discusses retransmission data partial order tcp sequences show tcp table uniform show rules tcp shrinking expanding respect partial order order tcp sequences complexity complex delivers longer payload delivers payload segments delivers payload number segments segments disordered define segments definition length tcp sequence tcp sequence define length pair 
global intrusion detection domino overlay system yegneswaran barford jha computer sciences department wisconsin madison emails vinod jha wisc abstract sharing data widely distributed intrusion detection systems offers possibility significant improvements speed accuracy isolated systems paper describe evaluate domino distributed overlay monitoring internet outbreaks architecture distributed intrusion detection system fosters collaboration heterogeneous nodes organized overlay network overlay design enables domino heterogeneous scalable robust attacks failures important component domino design active sink nodes respond measure connections unused addresses enables efficient detection attacks spoofed sources reduces false positives enables attack classification production timely blacklists evaluate capabilities performance domino large set intrusion logs collected providers internet analysis demonstrates significant marginal benefit obtained distributed intrusion data sources coordinated system domino evaluate configure domino order maximize performance gains perspectives blacklist length blacklist freshness proximity perform retrospective analysis sql-snake sqlslammer epidemics highlights information exchange domino reduced reaction time false-alarm rates outbreaks finally provide preliminary results prototype active sink deployment illustrates limited variability sink traffic feasibility efficient classification discrimination attack types introduction internet intrusions large-scale attacks catastrophic affect including stolen corrupted data wide-spread denial-of-service attacks huge financial losses disruption essential services estimated codered virus infected hosts resulting financial losses billion potentially profound impact detecting network intrusions attacks important goal protecting networks nefarious intrusions attacks remains challenging number reasons foremost fact problem constantly moving target due continued innovation easy access portscanning tools internet basic vulnerability widespread intrusions classes worms exploits identified primary means propagating information organizations cert result unacceptably slow response times installing countermeasures infrastructures ip-supported traceback pushback offer promise combating intrusions attacks similar measures widely deployed current practice protecting intrusions firewalls network intrusion detection systems nids firewalls choke points filter traffic network gateways based local security policies nids systems monitors residing end systems passively observe local network traffic react specific signatures misuse detection statistical anomalies anomaly detection examples nids employ misuse detection snort bro fundamental weaknesses misuse-detection-based nids inability detect types intrusions anomaly detection techniques establish statistical profiles network traffic flag traffic deviating profile anomalous high variability common network packet traffic limits effectiveness approach general current nids suffer major drawbacks high false alarm rates perspective single vantage point limits ability detect distributed coordinated attacks promising approach addressing abovementioned shortcomings distributed network intrusion detection systems dnids environment alerts nids combined address above-mentioned shortcomings valdes skinner show merging alerts nidss deployed single administrative domain reduce false alarm rate improvements limited perspective potential dnids contributions contribution paper description architecture distributed intrusion information sharing domino architecture enables nids deployed diverse locations securely share intrusion information domino overlay design facilitates scalable data sharing heterogeneous participation robustness nodes joining leaving infrastructure domino data sharing architecture describes methods transfer summarization information nodes architecture flexible enable consideration local policies important part domino architecture nodes monitor unused addresses call collection nodes domino active sinks data sources devoid false positives monitor unused addresses active sinks provide mechanisms detect spoofed sources efficient classification attack packets defined categories important additional benefit monitoring unused addresses fewer privacy concerns collecting data contribution paper evaluation domino design performance characteristics evaluation based set intrusion logs gathered networks internet month period knowledge evaluation dnids capability large distributed dataset key insights effectiveness distributed intrusion detection completed architectural specification domino implementation ongoing monitoring components developed implementation message passing components ongoing performed post facto analysis based domino specification evaluate data prototype active sink deployment experiments focused evaluating aspects domino marginal utility adding measurement nodes detecting worst offenders creating port summaries ideal configuration parameters domino architecture focused blacklist size sorted list worst offending sources frequency blacklist generation reaction time identifying worm outbreaks effect false alarm rates effectiveness domino identifying slow scanners variability payload distributions active sink data results important results experimental investigation improved summaries marginal utility experiments demonstrate small network collaborating peers approximately individual networks significantly improve perspective global attack behavior size individual peering nodes significant number collaborating peers blacklists worst offender list show approximately tens attack sources responsible significant portion scans day substantial benefit achieved stale blacklists decreased reaction time evaluate reaction time system data outbreaks sql-snake sql-sapphire provide examples rules domino employ react favorably scenarios significant false alarms demonstrate reaction time exploit recognition substantially reduced domino conditions slow scanners results suggest small daily blacklists sources significant impact deterring slow scanners utility active sink data provide preliminary results active sink deployment highlight limited variability observed payloads malicious traffic motivate approach building robust classifier results number important implications domino architecture demonstrates framework systems administrative domains participate coordinated intrusion detection clear improvements ability identify intrusions coordinated data sharing make compelling consideration network administrators deployment active sink nodes unused address space internet significantly increase fidelity speed alert generation intrusion detection systems widely deployed infrastructure domino considered target attacks effective domino resilient variety attacks discussion threats mitigating measures domino discussed appendix related work techniques intrusion detection misuse detection statistical anomaly detection information retrieval data mining inductive learning survey intrusion detection reader consult existing literature topic classification intrusion detection systems appears section researchers started investigating distributed network intrusion detection general architecture domino dnids presented section authors propose coverage cooperative virus response mechanism reacts highly virulent viruses indra proposes fully peer-to-peer approach intrusion detection organization completely ad-hoc locality account infrastructure serves primarily rule dissemination mechanism domino design combination peer-to-peer hierarchical components providing significant advantages purely hierarchical architecture advantages include simplified information sharing scalability fault tolerance domino flat tuple space express alerts researchers developing languages express alerts languages standardized plan incorporate domino merging alerts sources studied researchers merging algorithm domino influenced experimental results investigating algorithms data fusion purpose goal intention recognition correlate alerts possibly emerging sources infer plan adversary context domino working problem plan incorporate existing intention recognition module domino investigating structures reason sequences attacks privilege graphs attack graphs purposes intention recognition work influenced empirical studies intrusion attack activity moore examined prevalence denial-of-service attacks backscatter analysis authors analyze details codered worm outbreak provide important perspective speed worm propagation follow-on work moore provide insights speed counter measures installed inhibit spread worms code red work closely domino paper explore statistical characteristics internet intrusion activity global perspective work informs domino design perspective potential multiple sites coordinated intrusion detection 
domino architecture domino overview domino network dynamic infrastructure composed diverse collection nodes located network spanning internet objective system provide framework information sharing aimed improving intrusion detection capability participants overarching requirements properties challenges organization network requirements unlike large information sharing infrastructures include availability networks prone system failures congestion attacks infrastructure resilient temporary network instabilities crucial network remain face worm outbreaks denial-of-service attacks internet catastrophes scalability success utility network participants relies ability scale gracefully large number nodes decentralization decentralized architecture greater flexibility eliminates single point failure pervasiveness network effective identifying attack trends characterizing global internet intrusion phenomenon obtains representative participants moderate size portion address space privacy network reveal data individual participants sensitive increase likelihood attack individual participants heterogeneity network harmonize systems disparate networks varying sizes run wide range nids firewall technologies domino overcome weaknesses individual nids rules organizational topologies inducement finally incentive direct benefit networks join infrastructure critical mass participants required obtaining immefigure domino node organization axis nodes participate peer peer overlay diate benefit low shown figure domino network comprised sets participants axis overlay satellite communities terrestrial contributers describe sections communication axis overlay nodes satellites encrypted provide description key distribution strategy section axis overlay axis nodes central component domino architecture responsible bulk intrusion information sharing scalability availability vital resilience infrastructure important requirements resilience failure axis nodes ability quickly detect adapt topological resulting nodes joining leaving overlay networks shown highly resilient disruption possess ability deliver messages large-scale failures network partitions order enhance robustness extend availability architecture external connectivity nodes participating domino axis overlay maintained set domino access points dap participation axis node level domino achieved administrative procedure section axis node overlay terms components intrusion data collection axis nodes act intrusion data collection points domino axis nodes typically belong large well-managed networks high level trust required participate level networks nids firewalls active sinks deployed nids firewall nids firewall logs provide data specific intrusion signatures rejected packets fundamental intrusion data sources domino active sinks sink hole large chunk unused advertised address space active sink sniffs traffic bound addresses addresses simulates virtual machines supporting level interaction naive instantiation active sink labrea tarpit labrea developed mechanism slowing codered propagation creating sticky honey-pot persistent connections sinkholes infecting machines temporarily stuck slowing propagation outbreak examples active sinks include honeyd highly customizable low-interaction honeypot isink scalable sink hole responder approach monitoring important auxiliary benefits domino includes active sinks enable examination payload packets helps associating attack vulnerability examination request helps distinguish codered nimda variants traditional nids service running port spoofed sources behave differently active sink response send payload packet respond reset simply drop syn ack received sink source sends payload active sink considered malicious misconfigured enables creation high confidence blacklists attachment greater accountability attack sources assess feasibility scalability large scale active sink deployment running version active sink analogous tarpit class networks weeks number monitored ips increased measurement period characterization analysis data captured sink discussed appendix axis node ideally maintains nids active sink large unused address space experience similar datasets discussed section collection data sources sufficient identify global attack characteristics high degree accuracy expect number axis nodes consistently order maximize effectiveness system activity database schema axis database important relations packet logs local global summaries vulnerabilities alerts domino summary exchange protocol domino axis nodes overlay participate periodic exchange intrusion information refer data sets exchanged summaries actual format summaries section summaries exchanged levels granularities hourly daily monthly summary exchange involves steps pulling data satellites alternatively implemented periodic push choice left satellites generation summary data multicast axis nodes executing store operation enable persistent availability data domino query engine domino axis nodes export queriable interface tune firewall parameters expeditiously react outbreaks queries external sources directed daps accessibility controlled protect integrity infrastructure finally query engine supports trigger mechanism axis nodes pull data satellites real-time basis mechanisms prove extremely valuable gathering fine-grained information analyzing outbreaks satellite communities satellite communities smaller networks satellite nodes implement local version domino protocol potentially wide disparity sizes underlying nids firewall software running networks extensions provide support domino implemented plug-ins systems satellite nodes organized hierarchy node routes communication larger network parent node domino satellite axis node data collected satellite nodes transmitted axis nodes combination push pull mechanisms data obtained satellites considered trustworthy collected axis nodes satellites potential generate large volume spontaneous alerts due limited perspective nodes incapable performing local analysis classification attack severity nodes organized ad-hoc hierarchies efficient clustering neighboring alerts robust construction pertinent digests preserving hierarchical attributes edges domino overlay facilitates efficient data aggregation intelligent routing queries responses establishment trust levels simplifies administrative demands axis nodes satellites enjoy symbiotic relationship representation satellites network wider coverage space inducement satellites global vantage point rapid outbreak recognition dynamic content filtering application specific source blacklisting protect networks timely manner terrestrial contributers terrestrial contributers form trustworthy potentially large source data nodes implement domino protocol active sinks bound software installation nodes run firewall nids software simply supply daily summaries port scan data terrestrial contributers simply means expanding coverage including intrusion data sets infrastructure domino messages foster interoperability maximize extensibility domino protocol messages represented xml extend schema proposed idwg intrusion detection working group idmef intrusion detection message exchange format draft schema adds message types provided idmef alerts hearbeats message categories domino alerts summary messages heartbeats topology messages queries updates triggers description message types formats appendix information sharing axis node maintains local global view intrusion attack activity local view considers activity network satellites axis nodes periodically receive summaries peers create view global activity issues creating views include scalability timeliness trust axis node employ strategy creating local global views strategies data aggregation create local global views discussed appendix authentication axis nodes domino high degree trust authenticating inter-axis communication vital public-key cryptography specifically rsa purpose schemes source authentication anticipate number axis nodes scale rate domino infrastructure key distribution nodes envisioned big hurdle fact easily special certificate authority domino network axis node joins domino engage key distribution protocol domino axis node multicasts intrusion summary computes shahash summary appends digital signature hash summary verified recipients approach scalable domino axis nodes broadcast summaries infrequently summaries lightweight order kbs current implementation broadcasting period approximately hour plan undertake 
experimental evaluation overhead computing digital signatures context domino investigating mechanisms source authentication including ellipticcurve based public-key systems public-key axis node authentication standard challenge-response protocol finally authentication schemes based secret key exchanges considered chose pursue authentication scheme based sharing secret keys entail sharing secret key pair axis nodes approach scalable require maintenance choice public-key system results section provide background results demonstrate utility sharing intrusion information measure amount information gained adding additional measurement nodes investigate temporal attributes stability blacklists effectiveness blacklist terms size similarity blacklists respect destination proximity explore information sharing infrastructure affect reaction times worm outbreak aforementioned results based data obtained dshield set firewall nids logs portscans collected month period firewall administrators distributed globe basis analysis detailed description data appears appendix description analysis data captured active sink appendix marginal utility information theoretic approach quantify additional information gained adding nodes distributed intrusion detection framework approach utilizes kullback-leibler distance metric probability distributions measure information gain framework evaluating marginal benefit employing additional measurement sites context internet topology discovery presented presented methodologies quantifying marginal benefit obtained incorporating results additional experiment online offline marginal utility metric offline metric considers benefit experiment post facto basis measuring experiment usefulness experiments conducted study experiment corresponds additional intrusion log submitted network choose offline metric concerned order logs submitted assume intrusion logs log defines distribution source ports originate scan probability scan originated port intrusion log rank intrusion logs entropy distribution higher entropy intuitively probability distribution higher entropy contributes distribution distribution information logs combined distribution intrusion logs combined marginal utility denoted dkl log equation sum ranges source ports intrusion log framework measure effectiveness sharing logs identifying worst offenders effectiveness identifying frequently scanned target ports day month june randomly selected dshield logs determine number participating networks required obtain stable distribution figure depicts diminishing marginal benefit adding additional network logs developing port summaries curves networks show similar trend additional benefit declining networks message benefit bigger measurement networks important measurements multiple vantage points graph marginal benefit developing worst offender list blacklist figure message pronounced graph size matter utility additional subnets detecting worst offender utility additional subnets detecting top target port figure marginal utilities graphs imply collaboration networks adequate develop port summaries blacklists high degree confidence interesting note actual marginal utility values worst offenders higher port summaries suggests important add additional sites developing blacklists creating port summaries summary marginal utility information detect target source ports port scans minimal nodes suggests respect identifying target ports worst offenders port scans domino network approximately axis nodes suffice blacklist effectiveness crucial operational parameters domino overlay size blacklists exchanged participants domino axis nodes develop exchange service specific blacklists multiple granularities study generated combined blacklist dshield providers granularities daily weekly monthly figure illustrates relationship blacklist length effectiveness terms percentage scans blocked graph shows hour scanning activity attributed source ips surprisingly global daily blacklist sources account scans similar benefits achieved stale monthly blacklist sources summary sources responsible large fraction scans sources persist size blacklists domino network large blacklist aging figure means visualize aging blacklists create blacklist top sources multiple granularities graph average daily number scans generated rank higher ranks top hourly blacklists deliver superior performance lower ranks instances monthly blacklist performs daily blacklist validates maintaining blacklists multiple granularities suggests lower granularities greater benefit creating longer blacklists address proximity address proximity important consideration organization domino topology conflicting issues resolved allocation satellites axis nodes minimize false alarms effectively cluster related scans attack episodes beneficial organize nearby nodes networks hierarchy scanning attack tools designed sequentially traverse space axis node obtain composite view attack activity ideal data diverse set blocks understand granularity aggregation maximizes tradeoff randomly selected networks measured similarity monthly blacklists june defined distance networks dist express similarity blacklists networks needed metric greater weight match higher rank asymmetric similarity list denoted sim symmetric similarity lists denoted symsimilar average sim sim formally similarity metrics defined denotes length lists length blacklist ips percentage scans filtered daily blacklist weekly blacklist monthly blacklist effectiveness blacklists length source rank average number scans daily weekly monthly effectiveness blacklists age figure effectiveness blacklists sim rank symsimilar sim sim figure shows similarity blacklists function distance networks figure shows high degree similarity blacklists networks close similarity farther summary similarity blacklists positively correlated distance respective networks observation consequences context domino satellite nodes address organized single axis node set address spaces randomly distributed axis participants axis node generates version global summary simple aggregation work weighted merging retrospective analysis sql snake section perform retrospective analysis sql-snake outbreak unlike precedents codered nimda sql-snake slow-spreading worm due small size susceptible population mode propagation tcp wanted measure information sharing system domino affect reaction time alarm rate outbreak randomly selected networks trained port summary data port ms-sql server weeks network measured hourly average number scans average number sources figure shows hourly scanning rate terms number scans number distinct sources scanning port hours surrounding outbreak denote visually apparent point outbreak inflection point simulated random iterations domino networks axis nodes iteration measured number outbreak alarms generated networks size ranging nodes assumed domino nodes exchange hourly summaries scanning activity triggers fired spontaneous alerts experiment voting scheme generate outbreak alarm outbreak alarm generated atleast nodes vote alarm node votes alarm holds increase number scans hourly average increase number sources hourly average number sources greater chosen complicated rule generating alarms based statistical anomaly detection simple rule suffices illustrate point distance blacklist similarity figure similarity blacklists proximity reaction time defined elapsed time inflection point alarm point figure shows decrease observed reaction time average hour single node add sufficient axis nodes approximately figure displays average number alarms decreases topology size stabilizes alarms false alarms correspond preceding hours inflection point show gradual increase source rates points outbreak predicted earlier domino oscillatory behavior alarm rate artifact rule requires integral participants vote outbreak summary adding sufficient nodes outbreaks detected early minimal reaction time false alarms retrospective analysis sql-sapphire sql-sapphire worm sql-slammer released january wreaked significant havoc networking infrastructures ten minutes worm distinguished predecessors small payload size single udp packet bytes enabled rapid propagation rate spite small susceptible population reality high speed worms implies distributed architectures domino opportunity detect react worm outbreaks figure 
generates false positives negatives false positive denoted sequence ssftp-cwd uftp-cwd false negative denoted sequence ssftp-cwd uftp-cwd figure ultimate set easy define regular language signature cases ultimate set difficult define thought easy construct session signature matches uftp-cwd gard found false positive ultimate set complex attacks difficult define section systematically find false positives negatives approximate ultimate set attack invariant predicate hold instance attack define ftp-cwd invariant login procedure completed attacker sends malicious cwd command invariant expressed regular language denoted iftp-cwd evaluation methodology assumes invariant over-approximates ultimate set iftp-cwd uftp-cwd discuss reasons over-approximation section iftp-cwd find false positive searching sequence ssftp-cwd iftp-cwd iftp-cwd uftp-cwd ssftp-cwd iftp-cwd ssftp-cwd uftp-cwd false positive figure find false negative search sequence set ssftp-cwd iftp-cwd iftp-cwd uftp-cwd search yield spurious sequence satisfies invariant implement ftp-cwd formally sequence ssftp-cwd iftp-cwd uftp-cwd figure time find sequence ssftp-cwd iftp-cwd manually check spurious instance refine invariant continue searching discuss techniques guiding search false negatives spurious sequences section illustrate invariant refinement process section false positive ssftp-cwd formally define iftp-cwd ftp semantic model appendix gard compared iftp-cwd ssftp-cwd found false positive sequence ftp commands matches signature malicious cwd appears completed login procedure ftp-cwd specification ignores victim ftp server voluntarily terminates connection event vquit table false positive includes event injected malicious cwd attacker intentionally ignores terminating message continue send malicious cwd causing false alarm open question include event ftp-cwd signature unclear attackers exploit weakness case gard generate versions signature incorporates event ignores signature users choose version fits important lesson ftp-cwd weakness revealed ftp-cwd signature systematic found weakness illustrated formal methods tools systematically construct nids signatures signatures quality evaluated understood discuss gard advantages disadvantages section gard foundations discuss gard signature-specification language algorithm translate signature specification hierarchical state machine methodology finding false positives negatives signature specification language goal gard specification language provide clean separation event representation ability construct regular languages events automate process launching instance vulnerable host leave implementation issue future work achieve goal language event representation constructing regular expressions represent events regular expressions raw network bytes practice flex language form expressions attack events multiple streams stream messages attacker victim responses annotate event stream identify streams common convention addresses port numbers brevity ftp model appendix stream event sender subscript denote attacker denote victim form regular expression events gard standard operators language manipulation table non-standard operator operator restrict data length event figure table presents complete signature specification ftp-cwd languages phases lpre lexp lconf correspond state machines presented figure figure compilation process compiling signature specification table hsm figure based standard algorithm translating regular expression finite state machine compilation process steps standard algorithm translate expression fsm called superstate translate expression ftp-cwd specification machine identifies string pattern bin longer bytes standard algorithm build mmain figure formally build mmain accepts language lpre lexp lconf embed superstates mmain obtaining session signature hsm denoted ssattack-name figure build mmain standard algorithm recall algorithm handle nonstandard operator perform restricted-event renaming replace restricted event token restricted operator table unique identifier convert lexp table data shell length expression phase signature description preparation lpre loginftp macro denoting regular expression matches ftp session successful login macro defines regular expression tokens exploitation lexp data bin length malicious cwd command argument longer bytes pattern bin bin shis practice patterns exploit code confirmation lconf invalid response event connection longer ftp connection table signature specification fpd-cwd renaming restricted event syntactic sugar preserves signature semantics essentially restricted event represents unique sequence bytes restricted event data shell length represents sequence bytes event table renaming enables standard algorithm distinguish restricted events unrestricted versions distinguishes events renaming enables identify places main machine embed superstates step edge main machine labeled renamed event replaced superstate signature evaluation algorithms ssa session signature attack ssftp-cwd figure evaluate session signature comparing language denoted ssa language invariant denoted define invariant attack protocol represent protocol semantics semantic model finite state machine denoted state valuation variables called protocol state variables transition describes event protocol message affects variable values defined set protocol events essentially language represents model ftp appendix attack invariant logical formula state variables language language accepted accepting states states holds mentioned section goal construct signature close ultimate set cases clear definition evaluate accuracy ssa ssa approximations results show comparison effective improve accuracy ssa require attack invariant condition attack occur figure require reasons conditions easy define facilitating fast signature construction easy successful ftp login condition ftp-cwd attack false negatives considered harmful false positives overapproximating ensure theoretically miss false negative find false positive search sequence ssa mentioned section sequence false positive analogously find false negative search sequence set ssa search yield spurious sequence sequence satisfies invariant implement time find sequence ssa check spurious instance refine invariant continue searching search false negatives involves human intervention avoid spurious sequences problem larger yielding spurious sequences iftp-cwd figure sequences ftp commands ftp login completed set larger uftp-cwd set sequences implement ftp-cwd reduce probability hitting spurious sequence search set ssa sequences similar terms string matching sequences ssa strategy based observation attack instances generated introducing small already-known instances attack signature represents instances observation forms basis nids testing tools formalize similarity notion edit distance edit distance strings denoted number insertions deletions substitutions required transform language define k-edit-distance language denoted edk set strings edit distance string formally edk regular language edk regular edk ssa forms regular language superset ssa gard summary pitfalls find false positives gard checks set ssa empty find false negatives gard checks set ssa edk ssa constant empty check emptiness sets gard spin publicly model checker sets regular straightforward promela input language spin represent sets finite state machines spin capable checking emptiness providing sequence sets empty ability greatly simplifies evaluation process gard asserts ssa means interpret events semantic model events model construct false positive matches signature violates attack invariant ftp-cwd signature figure ftp model appendix ftpcwd invariant section gard asserted ssftp-cwd iftp-cwd adding signature means construct sequence events events table matches signature attacker logged believes model accurately describes ways login logout ftp server attacker false positive ftp-cwd signature completing ftp login procedure guarantee exist current ftp-cwd signatures section gard guarantee discovery false positives gard find false positive event part model case semantics model 
refined gard find false positive satisfies attack invariant ssa figure sequence surfaces invariant refined gard asserts ssa edk ssa means interpret events semantic model sequence events model implements k-edit distance sequence matches signature gard guarantee discovery false negatives gard find false negative k-edits signature gard miss false negative event part model case figure inaccurate negationslash surprising vague nature motivation work false negative surfaces semantic model refined implementation notes construct edk lsig recent methodology proposed kari methodology enables define errors permitted words permits restrict transformations attackers perform feature understand transformations preserve attack semantics ftp-cwd attack delete replace cwd command ftp command signature evaluation hsm superstates mmain machine ssftp-cwd machine figure assume false negative positive exists mmain sequence msig attacker finds sequence mmain construct satisfies restrictions imposed supernodes recall lexical scanner drops event explicitly signature specification section dropped events self-loops mmain signature evaluation add loops mmain gard evaluation evaluate accuracy session signature gard ability find false positives negatives complex attacks prove ftp-cwd signature table accurate current signatures vulnerable false positives respect invariant miss attack instance signatures recognize show gard model complex attacks find false positives negatives anticipate session signature evaluation initial study gard identify vulnerabilities ftp-cwd signatures current nids recent contextual signature developed sommer paxson snort signature compare signatures desig sssig-name hsm sizea false operational comments brevity write lsig-name alphabet states edges positive false positive snort ftp ftp cwd cwd athe size deterministic hsm states edges superstates table comparison signatures weaknesses ftp set events table fined snort contextual signatures session signatures denoted snort snort signature include confirmation phase added event section confirmation phase signatures ftp model appendix define invariant login procedure completed attacker sends malicious cwd command gard find false positives signatures gard revealed false positives familiar refined initial ftp-cwd signature verified respect invariant false positives ftp-cwd snort signature signature revision essentially exploitation phase session signature figure knew signature tight attackers false positive sending maliciouscwdcommand logged ftp server signature ignores events precede malicious cwd model preparation phase ftp ftp set ftp events model table ftp-cwd contextual signature signature ensures login event appears malicious cwd knew signature tight attacker false positive sending ftp quit command immediately malicious cwd completed ftp login procedure defined preparation-phase language ftp successful-login event table means observing single login event signature moves exploitation phase ftp-cwd session signature signature defined table denoted cwd evaluation summary table presents summary experiment results row table presents signature snort cwd cwd constructed gard revealed weakness cwd signature show language accepts alphabet signature hsm number nodes edges hsm false positive gard found create operational false positive sequence gard provided observations noted order signatures accuracy snort accurate signature cwd accurate easy prove lsnort lcs lcwd lcwd means accurate signature generates false positives accurate signature prove sequence implements ftp-cwd lsnort lcs lcs lcwd lcwd lcwd means accurate signature misses attack instance accurate signature matches formal proofs claims scope paper operational overhead signatures low signatures require edges indicating insignificant memory footprints hsms proftpd server bro generate operational false positive sequence gard provided cwd sequence server voluntarily terminates ftp tcp connections event bro stops monitoring ftp session immediately observing terminating tcp sequence ignores events generate false alarm additional overhead cwd terms memory consumption insignificant cwd preferable prevents potential false positive cwd constructing complex signatures gard pilot study examined simple attack success wanted challenge gard capabilities complex attack chose multi-step pro-ftpd attack pro-ftpd attack can- pro-ftpd attack exploits buffer overflow proftpd server vulnerability occurs attacker transfers file ascii mode phase signature description lpre loginftp typea loginftp slogin event quit event table pattern ftp-cwd signature figure lexp typea type event type event table intuition ascii mode requires event event lconf ftp event identifies opening unix shell port ftp server pattern matches traffic traverses tcp session address events attacker arbitrary port number table initial signature pro-ftpd attack signature susceptible false positives negatives fix section section event definitions table transfer proftpd server stores data byte chunks check newline characters due incorrect handling characters buffer overflow occurs proftpd parses specially crafted file attack requires steps attacker logs ftp server representation mode ascii iii uploads ftp server file shell code downloads file download buffer overflow occurs attack attacker gains root privileges host communicates compromised host tcp connection opened shell code initial pro-ftpd specification attack requires preconditions ftp session login ascii states store command uploads attacker file simultaneously impose login ascii states intersected languages loginftp typea table resulting pattern concatenated store event modeled retrieval download operations pro-ftpd exploitation phase table boundary preparation exploitation phases set arbitrarily operational meaning boundary exploitation confirmation phases signals nids raise attack alert important set interpretation attack case pro-ftpd clear retrieval operation marks end attack confirmation phase pro-ftpd consists single event opening unix shell unlike case ftpcwd shell opened tcp connection server port identify activity defined event matches communication occurs port pro-ftpd false positives pro-ftpd invariant states successful pro-ftpd attack end login ascii states formally defined ftptype ftplogin variables ftp model table search false positives negatives initialize variable ftptype default proftpd server proftpd enables administrator determine default mode performed search ascii default binary default representation mode ascii gard verified pro-ftpd specification false positives respect invariant default binary gard found false positive sequence type login store retv retv sequence matches signature ends binary mode implement attack type effect appears login procedure sequence matches signature intersection languages loginftp typea enforce required order events login type figure problem typea pattern pattern intends ensure type event type gard instantiates set binary default mode performing logout login quit login events behaves switches mode back binary modified typea change gard verified false positive exists default mode binary pro-ftpd false negatives illustrate iterative process found false negatives initial pro-ftpd signature iteration gard provided sequence match signature satisfies invariant manually round sequence type figure attack invariants invariant model refinement signature fix original false neg ftplogin true ftptype fix loginftp typea compare figure pattern figure original spurious ftplogin true ftptype store command instance attack original spurious ftplogin true ftptype retv command instance attack original false neg ftplogin true ftptype replace loginftp typea loginftp typea original spurious ftplogin true ftptype limit length 
attacks limit attacker transformations ftplogin true ftptype length table search false negatives -edit distance original sequence matches pro-ftpd signature table event definitions table round applied invariant refinements signature fixes performed round determined sequence false negative spurious sequence case refined signature refined invariant repeated steps satisfied signature accuracy searched false negatives -edit distance session signature assumed default representation mode ascii process found false negatives process hours experienced gard user false negative found gard replaced type retv command round table essentially gard showed default representation mode ascii type command required successful pro-ftpd attack successful login puts ftp session ascii mode figure changed pro-ftpd preparation phase expression represented figure removed type false negatives sequence gard replaced store command cwd round table store condition pro-ftpd sequence false negative spurious sequence avoid type sequences added semantic model variable denoted counts number stores sequence ensure store command appears sequence gard surprisingly sequence gard replaced retv cwd round table sequence implement attack added variable counts retv commands ensure sequence retv commands gard added append command replaced store cwd round table false negative pro-ftpd attack implemented append store modeled append modeled store increment table anticipated false negative prevent added append command pro-ftpd preparation phase question store append equivalent general scope paper answer attack-dependent security analyst address ftp attack define gard affords analyst ability investigate implications decision defined commands equivalent gard warn analyst unforeseen false negative behavior undesired analyst disable easily sequence gard replaced retv command cwd increased length sequence include retv commands required attack invariants round table spurious sequence point editdistance mechanism limit transformations attackers perform section proftpd attack retvcannot replaced cwd forbade replacement based restrictions imposed find false negatives summary gard evaluation analytically showed ftp-cwd session signature accurate snort contextual counterparts knowledge start login ascii original loginftp typea pattern machine accept ftp sessions login representation mode set ascii default mode binary sequence results false positive section default ascii sequence results false negative section start login ascii loginftp typea pattern false negative fix section pattern ensures login session ascii mode default ascii mode figure versions loginftp typea pattern provide evidence signature accuracy gard taught tune pro-ftpd signature proftpd server configuration anticipate outcome began experiment experience shows constructing accurate regular expression delicate issue simple cases inaccurate expressions lead unforeseen false positives negatives learned effectiveness formal methods reveal inaccuracies remember gard guarantee signature lacks false positives negatives gard guarantees false positives negatives respect invariant underlying semantic model split pro-ftpd attack ftp sessions longer detected signature refinement signature handle cases left future work conclusion future work signatures based formal reasoning verifiable accuracy worthy paper step goal present methodology construct evaluate improve signatures intend continue work initial results operational cost session signature comparable current signatures table intend perform investigation issue session signatures hsms share machines signatures improve ability nids handle signatures simultaneously develop semantic models protocols acknowledgments deeply anonymous referees comments helped refine concepts presented paper aho sethi ullman compilers principles techniques tools addison-wesley alur yannakakis model checking hierarchical state machines foundations software engineering lake buena vista nov baker barnyard caswell poor alder babbin beale doxtater foster kohlenberg rash snort intrusion detection syngress edition security proftpd ascii file remote root exploit securiteam exploits blackmoon blackmoon ftp server blackmoonftpserver cuppens ortalo lambda language model database detection attacks international symposium recent advances intrusion detection toulouse france oct dacier editor design intrusion-tolerant intrusion detection system ibm zurich research laboratory aug deliverable project maftia ist- maftia eckmann vigna kemmerer statl attack language state-based intrusion detection computer security ginsburg mathematical theory context free languages mcgraw hill handley paxson network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington aug holzmann spin model checker primer manual addison-wesley hopcroft motwani ullman introduction automata theory languages computation addison-wesley edition kari konstantinidis perron wozniak finite-state error edit-systems differencemeasures languages words technical report saint mary department mathematics computing science lippmann haines fried korba das analysis results darpa offline intrusion detection evaluation international symposium recent advances intrusion detection toulouse france oct marti thor tool test intrusion detection systems variations attacks master thesis swiss federal institute technology mar michel adele attack description language knowledge-based intrusion detection international conference information security paris france june mitre corporation cve common vulnerabilities exposures cve mitre morrissey saunders lowes roesen renner proftpd highly configurable gpl-licensed ftp server software proftpd mutz vigna kemmerer experience developing ids stimulator black-box testing network intrusion detection systems annual computer security applications conference las vegas dec paxson flex version fast scanner generator free software foundation mar paxson bro system detecting network intruders real-time computer networks dec postel reynolds rfc file transfer protocol internet engineering task force pouzol ducass declarative signatures misuse ids international symposium recent advances intrusion detection davis oct pouzol ducass formal specification intrusion signatures detection rules ieee computer security foundations workshop cape breton canada june ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks calgary canada roesch snort open source network intrusion detection system snort rubin jha miller automatic generation analysis nids attacks annual computer security applications conference tucson dec security administrator newsletter instant poll snort implement intrusion detection system ids network oct winnetmag poll sekar guang verma shanbhag high-performance network intrusion detection system acm conference computer communications security singapore nov sekar uppuluri synthesizing fast intrusion prevention detection systems high-level specifications usenix security symposium washington aug sommer paxson enhancing byte-level network intrusion detection signatures context acm conference computer communications security washington oct teitelbaum minimal distance analysis syntax errors computer programs phd thesis computer science department carnegie-mellon sep nss group intrusion detection systems ids group test edition nss ids edition index htm vigna kemmerer netstat networkbased intrusion detection system computer security vigna robertson balzarotti testing network-based intrusion detection signatures mutant exploits acm conference computer communications security washington oct wagner soto mimicry attacks host-based intrusion detection systems acm conference computer communications security washington nov ftp semantic model state ftp defined variables table alphabet model section denoted ftp set tokens defined table modeled common ftp commands modeled similar brevity define lexemes upper case letters ftp specification combination upper lower case letters events table form event library ftp model 
complete event defined table state change var values semantic comments user command issued pass command issued victim successful login alias ftplogin section holds session representation type type alias ftptype section ascii binary ebcdic undefined holds session transmission mode mode stream block compressed undefined session passive mode max counts number files uploaded session max counts number files downloaded session table state variables ftp semantic model event token lexemea flow description user user user login pass pass user password cwd cwd change directory cquit quit client terminates session rein rein user logged session restarted pasv pasv enter passive mode type type change representation type ascii type type change representation type binary type type change representation type ebcdic mode mode change transmission mode stream mode mode change transmission mode block mode mode change transmission mode compressed retr retr retrieve file server stor stor store file server appe appe append file server dele dele delete file server list list list files server slogin user successfully logged vquit victim voluntarily terminates session arg str argument ftp command invalid response non-ftp response valid response start digit astr denotes string ftp specification denotes match beginning line denotes alphanumeric bmust precede command requires argument brevity add state variables required track type command table events transitions ftp semantic model rule description token single token valid expression closure valid expression valid expression negation valid expression valid expression concatenation intersection union valid expressions valid expression token restricted event valid expression restricted valid expression data raw expr regular restriction imposed data attribute token length int regular restriction imposed length attribute token negationslash logical combination restrictions valid restriction table grammar construction regular expressions events 
shows exponential increase number scans number sources minutes outbreak epidemics alarms generated hourly axis summaries suffice domino mechanism deal scenarios spontaneous alerts issued triggers domino nodes associate related packets episodes horizontal scan episode sequential scan machines subnet hour starting number scans sources hour number sources scans hour inflection point figure scan rate hrs surrounding sql-snake outbreak figure reduction reaction time add networks aimed target port vertical scan episode scan multiple ports single survey vulnerabilities coordinated scan episode distributed scan subnet multiple sources episodes port domino nodes maintain average number scans average number attack sources duration trigger spontaneous alert defined episode deviates average number sources number scans times average number sources times average duration times average recognize existence outbreak rule rule rule participants generate spontaneous alert hour repeated previous experiment random iterations iteration picked random class-c subnets data weeks january previous subsection sophisticated rule generate spontaneous alert simple rule suffice illustrate point figure change alarm rate add networks train system measured episode rates simulated spontaneous alerts cataloged change reaction time add additional subnets rules figure shows adding sufficient nodes reaction time reduced seconds goal domino outbreak containment outbreak recognition insulation maximal number participants authors show worm infection rate susceptibility accurately predicted observing data collected single network spans small fraction entire address space slow scanners blacklist evasion section evaluate ability slow scanners evade blacklists generated infrastructure domino axis nodes periodically exchange blacklist summaries finite list top-n local worst offenders volume activity simplicity assume summaries generated networks order ensure source global blacklist ensure local blacklist summaries optimal strategy omniscient adversary simultaneously scan subnets rate blacklist threshold volume n-th offender scenario time completely scan single subnet essentially time required scan entire address space utility domino scenarios ability prolong scanning process perform worst case analysis logs dshield built hourly daily blacklists entire month computed -th percentile values basis blacklist thresholds figure shows blacklist thresholds time scan entire subnet ipv address space blacklist size granularity hourly daily noteworthy characteristics graphs hourly daily blacklists effective deterrant evasive scanners evade daily blacklist sources days years year evade hourly blacklist top sources larger values daily blacklists effective hourly blacklists finally staircase behavior hourly blacklist due heavy tailed nature hourly sources sources scans hour corresponds scans flat region daily blacklist corresponds sources horizontally scan entire scans threat vulnerability widely deployed infrastructure domino considered target attacks effective domino resilient variety attacks design robust attempted address vulnerabilities domino attack virtue fact architecture enables heterogeneous client participation infeasible address vulnerabilities address threats domino model considers forms attacks attempted include attacks intent denying service infrastructure attempts infiltrate infrastructure attacks intent reducing domino effectiveness denial service threat attempt effectively remove node dos attack systems domino remedy face standard packet flood attacks set domino nodes effectively removed infrastructure fact non-goal infrastructure protect nodes dos attack distributed coordinated nature infrastructure makes robust removal nodes failures attacks threat compromised domino node begins sending large amounts appears legitimate data attempt mount dos attack axis node remedy axis nodes apply filters incoming data data node set nodes exceed threshold configuration filters dependent system resources historical variability multiple axis nodes compromised filtering cease effective time jan number scans sources minute number sources scans minute scan rates port surrounding sql-sapphire outbreak number subnets reaction time seconds rule rule rule reaction time sql-sapphire outbreak figure statistics sql-sapphire source rank typical volume percentile hourly blacklist daily blacklist typical volume top offenders hourly daily local blacklists blacklist length time scan subnet days hourly blacklist daily blacklist minimal time required days evade top-n blacklist scan subnet figure blacklist evasion infiltration threat attempt gain unauthorized access axis node remedy domino specifically concerned individual system security assume standard practices hardening networked systems intrusions keeping operating system patches closing unused services employed expect vulnerability domino specific software buffer-overrun exploits limited practices software engineering threat attempt masquerade axis node remedy discussed section axis node authenticated axis nodes assume axis nodes intermittently forced participate mutual authentication protocol axis nodes axis node fails authentication protocol initiated specific axis node broadcasts message axis nodes domino network informing axis node compromised obfuscation threat compromised node sends data large amounts supposed real attempt obfuscate activity remedies remedies threat nodes attach shadigest block data collision resistant property shawill make hard adversary tamper data axis node remedy stems distributed nature domino results forwarded axis nodes filters applied data fusion process single node ability skew results simply increasing data volume filtering node set axis node applied discretion axis node effect axis level filter obfuscation attacks based volume fusion process designed emphasize coordinated perspective significantly reduces eliminates effectiveness attack threat attempts stealthy coordinated scanning remedy important strength domino enhanced perspective afforded coordination multiple sites enhanced perspective expose stealthy coordinated scans finer granularity detection single site adversary sufficiently slow scanning employs sufficiently nodes coordinated fashion elude detection domino remedy include nodes domino make threshold stealthy coordinated scanning high render alternative infeasible threat attempt avoid active sink nodes remedy basic function active sink nodes track scanning activity unused addresses sense adversaries isolate specific networks addresses networks combined nids live addresses active sinks unused addresses intrusion attempts possibility tracked simple confuse active sink identification employ probabilistic responses responding syn packets block respond number long attackers spoof source addresses active sink nodes monitor significant fraction unused space traffic captured sinks provide valuable insight network intrusions conclusions future work paper describe evaluate domino cooperative intrusion detection system domino designed enable intrusion information sharing globally distributed network consisting trusted axis nodes organized peer-to-peer overlay satellite nodes axis node hierarchically arranged terrestrial nodes deployed leaves infrastructure provide daily intrusion summaries domino design based heterogeneous data collection nids firewalls active sinks architecture enables domino secure scalable fault-tolerant facilitates data sharing evaluation domino based data sources set intrusion logs collected month period networks world wide prototype sink implementation single network monitors addresses evaluation demonstrates utility sharing information multiple nodes cooperative infrastructure informationtheoretic approach show perspective intrusions greatly enhanced cooperation small number nodes sql-worm outbreaks demonstrate false-alarm rates significantly reduced domino reaction time outbreak detection similarly reduced finally provide initial evaluation effectiveness active sinks discriminating types attacks based examining 
payload data results demonstrate active sinks provide important insight regard based analysis conclude domino offers significant opportunity improve intrusion outbreak detection capability internet intend pursue future work number directions plan develop interactive sink-hole responders enhance attack discrimination capability plan deploy operational domino infrastructure enable test develop domino topology creation maintenance protocols expand infrastructure enable case studies future intrusion outbreak activity plan investigate alternative methods information merging sharing goal improving efficiency precision finally plan develop tools automating firewall rule generation allen christie fithen mchugh pickel stoner state practice intrusion detection technologies technical report cmu sei-tr- software engineering institute carnegie mellon january anagnostakis greenwald ioannidis keromytis cooperative immunization system untrusting internet icon andersen balakrishnan kaashoek morris resilient overlay networks proceedings sosp lake louise alberta october anderson khattak information retrieval techniques intrusion detection proceedings international workshop recent advances intrusion detection raid september balasubramaniyan garcia-fernandez isacoff spafford zamboni architecture intrusion detection autonomous agents annual computer security applications conference acsac pages december bellovin cheswick network firewalls ieee communications magazine september bestavros byers crovella marginal utility network topology measurements proceedings acm sigcomm internet measurement workshop san francisco november center http cert cert cert incident note in- http cert incident note in- html cuppens managing alerts multi-intrusion detection environment proceedings -th annual computer security applications conference acsac cuppens miege alert correlation cooperative intrusion detection framework proceedings ieee symposium security privacy oakland pages cuppens ortalo lambda language model database detection attacks proceedings recent advances intrusion detection raid pages dacier quantitative evaluation computer security phd thesis institut national polytechnique toulouse december goodman mahler nguyen mathematics data fusion kluwer academic publishers group dordrecht gray entropy information theory springerverlag idg study code red costs top billion http thestandard august idwg intrusion detection message exchange format http ietf html charters idwg charter html ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march janakiraman waldvogel zhang indra peer-to-peer approach network intrusion detection prevention unpublished manuscript koblitz elliptic curve cryptosystems mathematics computation krugel toth kerer decentralized event correlation intrusion detection proceedings information security cryptology icisc seoul korea pages december lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy leland taqqu willinger wilson self-similar nature ethernet traffic extended version ieee acm transactions networking pages liston labrea homepage http hackbusters net lunt tamaru gilham jagannathan neumann javitz valdes garvey real-time intrusion detection expert system ides -final technical report technical report computer science laboratory sri international menlo park california february mahajan bellovin floyd ioannidis paxson shenker controlling high bandwidth aggregates network computer communications review july moore paxson savage shannon staniford weaver spread sapphire slammer worm http caida outreach papers sapphire sapphire html moore shannon claffy code red case study spread victims internet worm proceedings acm sigcomm internet measurement workshop november moore shannon voelker savage internet quarantine requirements self-propagating code proceedings ieee infocom april moore voelker savage inferring internet denial service activity proceedings usenix security symposium washington august mukherjee heberlein levitt network intrusion detection ieee network june needham schroeder encryption authentication large networks computers communications acm northcutt network intrusion detection analyst handbook riders paxson bro system detecting network intruders real time proceedings usenix security symposium perrig biba one-time signature broadcast authentication protocol proceedings acm conference computer communications security ccs november provos honeyd virtual honeypot daemon proceedings dfn-cert workshop february rivest shamir adelman method obtaining digital signatures public-key cryptosystems coommunications acm roesch snortlightweight intrusion detection networks proceedings usenix lisa conference november roesch snort network intrusion detection system http snort rohtagi compact fast hybrid signature scheme multicast packet proceedings acm conference computer communications security ccs pages savage wetherall karlin anderson practical network support tracback proceedings acm sigcomm sheyner haines jha lippmann wing automated generation analysis attack graphs proceedings ieee symposium security privacy staniford hoagland mcalerney practical automated detection stealthy portscans proceedings acm ccs ids workshop november staniford paxson weaver internet spare time proceedings usenix security symposium teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy pages ullrich dshield http dshield valdes skinner probabilistic alert correlation proceedings recent advances intrusion detection raid pages warrender forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy pages yegneswaran barford plonka design utility internet sinks network abuse monitoring uwtechnicalreport yegneswaran barford ullrich internet intrusions global characteristics prevalence proceedings acm sigmetrics june zou gao gong towsley monitoring early warning internet worms proceedings acm conference computer communications security ccs october domino messages foster interoperability maximize extensibility domino protocol messages represented xml extend schema proposed idwg intrusion detection working group idmef intrusion detection message exchange format draft schema adds message types provided idmef alerts hearbeats message categories domino alerts alerts spontaneous responses events defined nids firewall custom policies alerts generated small networks satellites propagated axis level depending pervasiveness severity alert clustering suppression challenging problem vital operational success infrastructure idmef draft defines alert classifications tool alert correlation alert overflow alert domino axis nodes exchange alerts significant deviation periodic summaries outbreak alerts blacklist alerts denial-of-service attack alerts dtd alert element alert createtime detecttime analyzertime classification source target additionaldata attlist alert version cdata fixed ident cdata required impact cdata unknown summary messages domino summaries typically exchanged axis peers formats relating type information transmitted summary message types include port summaries source summaries cluster summaries domino defines levels trust low medium high summary messages based source axis satellite choice levels trust arbitrary cues intelligent aggregation dtd summary messages element summary createtime summaryduration ipblocksummary attlist summary version cdata fixed ident cdata required element ipblocksummary minip maxip ipcount trustlevel portsummary sourcesummary clustersummary element portsummary vulnid portnum numuniqsrcip numuniqdestip scancount element sourcesummary vulnid portrange scancount aggregatescancount numuniqtargets element clustersummary srciplist destiplist vulnid portrange scancount heartbeats domino satellite nodes periodically exchange heartbeat messages parent nodes current status higher level nodes vice-versa interval heartbeats left satellites minutes hour element heartbeat createtime analyzertime additionaldata attlist heartbeat ident cdata required topology messages types topology messages adopt detour recall divorce satellite node disconnected parent reconnect normal heartbeat exchange protocol fails issues adopt message dap multicast overlay axis nodes axis node forward adopt message applicable children satellite analyzes acknowledgments responds detour message 
eligible parent axis satellite parent restarts issues recall message children child accept invitation rejoin issuing divorce message foster parent simultaneous detour message original parent element topologymessage createtime type ipblocksummary attlist topologymessage version cdata fixed ident cdata required queries domino query messages exchanged xquery format axis nodes maintain consistent schema inter-axis queries sql chose xquery maximize interoperability satellites provide query create top blacklist port times src distinct document scans xml source scan document scans xml scan source src time scan timestamp port scan port port time time return blacklist source src source num scans sum scan count numscans blacklist sortby sum scan count limit updates domino protocol automatic mechanism updating nids rulesets axis vulnerability database considered means dispensing timely content based filters satellites format messages straightforward element dbupdate createtime vulnerabilityid signature attlist dbupdate version cdata fixed ident cdata required description cdata element signature targetports payload sourceport protocol seqno triggers triggers issued domino axis satellites nodes lower hierarchy trigger components query constraint action define types actions alerts filter rules trigger generation outbreak alert number scans exceeds threshold element trigger createtime query constraint action attlist trigger version cdata fixed ident cdata required description cdata element action alert filter information sharing potential strategies information sharing include local aggregation intrusion information gathered satellite nodes step organize refine data create coherent picture malicious activities satellite nodes send raw alerts axis nodes overwhelmed alerts satellite nodes aggregated communicated axis nodes cuppens describes cooperative intrusion detection module crim means combining alerts idss domino adopts extends design purposes aggregating raw alerts global aggregation straight-forward merge logs multiple sites simple addition average dimension data approach simple means organizing summarizing data risk inaccuracy case port summary logical add number scans number unique destinations simply adding set unique sources axis nodes domino performs simple aggregation port summaries results sources weighted merging potentially important consideration fusing summaries address proximity summaries generated neighboring address blocks germane generated distant network uncommon scans attacks proceed horizontally space weighted merging approach emphasizes proximity domino performs simple weighted merging blacklists sampling sampling standard method reducing scale measurement data goal sampling approach balance quantity data precision measurement case domino challenging intrusions form attacks easy sample stealthy scans rare events hard sample sampling method domino poses ability expose types events investigating feasibility employing sampling technique data sharing related issue important domino aging local data packet data accumulated large sinks order megabytes day summaries meant light weight table monthly summary dshield logs month scans dest ips million june million july million simply purging data older number days reasonable approach practice care ensure periodic patterns monthly rise fall codered worm lost present propose domino maintain summaries granularities weighted averaging merge older summaries timely data intrusion trace data set firewall nids logs portscans collected month period firewall administrators distributed globe basis analysis domino logs provide condensed summary lowest common denominator portscan activity obtained firewall nids platforms platforms supported include blackice defender cisco pix zonealarm linux ipchains portsentry snort approach significantly increases coverage reduces reliance individual nids interpretation events table illustrates format typical log entry date time fields standardized gmt provider hash aggregation destination addresses belong administrative network table high level summary data analysis dataset obtained dshield research effort funded sans institute part internet storm center goals dshield include detection analysis worms vulnerabilities notification isps exploited systems publishing blacklists worst offenders feedback submitters improve firewall rulesets data comprised logs submitted diverse set networks includes class networks class sized networks large number smaller sub-networks networks represented data set widely distributed geographically topologically autonomous system space unique perspective global intrusion activity highlighted dshield contribution detection early analysis codered nimda sql worm outbreaks dshield data port january sql-sapphire analysis preliminary results active sink figures show number packets flows inbound outbound active sink positive flows outbound negative inbound expected number inbound packets higher outbound active sink respond persistent payload packets difference number inbound outbound flows artifact flows accounted minute intervals surprising outbound udp packets number inbound packets typically packets connection attempts active sink running pentium linux problem coping traffic rate per-connection state maintained connection attempts spanned wide variety ports originated hundreds thousands sources typical summary top ports week shown table ms-sql-s mssql-m scans correspond recent sql-sapphire worm sql-snake http probes codered nimda infected hosts microsoft-ds scans port port scans lioten worm scans open proxy servers means obfuscate internet activity figure protocol breakdown active sink packets jan feb figure protocol breakdown active sink flows jan feb important application traffic captured active sink nodes generating signatures malicious table sample log entries portscan logs date time hash scans src src port targt targt port tcp flags provider provider table sample weekly summary top probed services service port protocol flows octets packets ms-sql-s udp microsoft-ds tcp ms-sql-m tcp http tcp netbios-ss tcp analogx proxy server tcp https tcp hyview proxy tcp http-alt tcp win rpc tcp payloads signature payload worm nids simple pattern matching identify malicious payloads method lead significant number false positives variations malicious payloads detected demonstrate traffic captured active sink nodes create robust signature malicious payload step cluster payloads traffic observed active sink nodes intuitively cluster corresponds malicious payload construct classifier cluster classifiers nids identify malicious payloads performed clustering step future investigate constructing classifiers identifying malicious payloads results clustering encouraging performed clustering data collected jan jan constructed fingerprint payload fingerprint payload distribution bytes bytes snort displaying payloads fingerprint records number bytes range distance payloads kullback-leibler distance fingerprints payloads clustered means algorithm sum squared metric determine optimal number clusters results show distinct clusters table figure cumulative distribution function distance cluster centers clusters perfect clusters distance clusters port port variability port scans cluster codered nimda variants variability clusters attributed reasons attack codered nimda sql-snake series similar packets attempt open shell execute series commands variants worms true port slightly search path default presence exploit experiments demonstrate clusters naturally correspond classes malicious payload classifiers generated clusters successful identifying malicious payloads figure variability payload clusters table cluster summary cluster port scans cluster cluster cluster cluster cluster cluster 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def -------------dg begin patch --------------dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dashline dup def pathlength exch div pop def pathlength ifelse add add add def coef mul mul div round mul mul mul add exch div def coef mul def coef mul def coef mul def coef mul def mul ifelse setdash stroke def -------------dg end patch --------------dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def 
summationtextni size payload length length length length length length component complexity disorder level tcp sequence disorder level counts number segment pairs out-of-order disorder level sequence sends segments ordered sequence numbers similarly disorder level sequence sends segments reverse order definition tcp sequence disorder level tcp sequence define order seq seq disorder summationtext order definition complexity tcp sequence tcp sequence define complexity length disorder complexity complexity complexity complexity length length length length disorder disorder complex denoted complexity complexity note complexity partial order ranks sequence length primary index disorder secondary required section descending chain complexity finite simplify attack instance infinitely simply length bounded segments complexity length preserving required theorem claim respect complexity rule tcp shrinking expanding proof claim presented appendix uniformity proof tcp prove tcp uniform prove conditions claim hold claim set transformations reversible rule shrinking expanding respect partial order precedesequal iii atoms atoms atoms singleton set atom exists derivation shrinking rules uniform respect precedesequal proof claim show exists uniform derivation conditions iii exists atoms atoms condition derivations exist reversible condition uniform derivation square notice tcp condition holds rules tcp based string operations reversible concatenation permutation condition holds rules tcp shrinking expanding respect complexity claim tcp sequence reader encouraged check overlapping segments order segments repeatedly apply shrinking rules tcp sequence segments ordered sequence numbers apply swap byte transmitted apply frag ret iii number tcp segments apply frag repeatedly applying shrinking rules atom condition holds single atom rules change payload tcp sequence tcp specifications single transmit payload byte transmitted order number segments atoms tcp singleton set condition holds tcp tcp specifications rules tcp alter payload tcp sequence tcp means transmits payload single atom atoms transmit payload tcp specification atoms identical condition iii holds showed tcp conditions claim hold tcp uniform reversible respect complexity uniform reversible http rules illustrate uniform reversible set transformations http protocol illustrate representative transformations http padding pads http request spaces url http encoding encodes url hexadecimal values chose transformations successfully evade nids transformations represent applicationlevel transformations modify attack payload discuss application-level transformations section abstract http attack single string cgi-bin perl exe http define http attack regular language conforms http specifications denoted lhttp lhttp lurl http lurl defines url string ascii characters hexadecimal encodings formally lurl ascii ascii ascii standard ascii character set ascii regular substitution maps ascii character string representing character hexadecimal encoding pre condition post condition pad url http url http padm url http url http pad url http url http padm url http url http url http ascii http urlm http ascii http table http uniform reversible set transformations http-based attacks regular substitution ascii characters hexadecimal encodings stands white-space characters post common http methods http attacks table presents set http transformations denoted http rules pad pad change number spaces attack components url rule encodes single ascii character attack url hexadecimal encoding proof uniformity http show conditions claim hold http definition table clear rule reversible padpad- urlare shrinking rules respect complexity definition rules reduces number bytes instance reduces instance length definition analogously pad pad url expanding rules proofs atoms http singleton set atoms http atoms http similar proofs presented tcp section case proofs based http specification states single most-concise deliver http attack combining http tcp show http tcp uniform reversible showing conditions claim hold difficult add transformations system uniformity proof tcp section assumed rules change attack payload assumption longer true case http illustrate method proving uniformity theorem show http tcp uniform http tcp positively commutative theorem particulary suitable proving uniformity sets transformations protocols belong levels protocol stack tcp transformation-level protocol http application-level protocol tcp specification indifferent http payload http specification indifferent tcp transfers payload independency basis commutativity proof rules http represent http attack single string rules tcp represent attack tcp sequence section unify http tcp single representation attacks adjust definitions rules http work multiple tcp segments due space constraints discuss adjustment appendix claim tcp http uniform reversible proof claim notice rules tcp http shrinking expanding respect partial order complexity definition show tcp http uniform show sets set-wise positively commutative definition uniformity tcp http theorem show tcp http positively commutative show derivation form http tcp exists equivalent derivation form tcp http derivation form tcp http exists equivalent derivation form http tcp table presents major cases derivations cases similar omit brevity modeling transformations discuss uniformity reversibility transformations part tcp http modeling tcp transformations header change tcp transformations operate header tcp segment modify tcp flags prove transformations uniform involve syntactic manipulation tcp level prove uniformity extend representation tcp sequence section include representation tcp header extend definition complexity enforce notion expanding shrinking rules original change pad frag frag pad url frag frag url url ret ret url ret url url ret frag url url frag ret pad pad ret table positive commutativity http tcp biggest challenge prove uniformity reversibility tcp transformations tcp retransmission payload problem content bytes tcp segments ambiguity creates difficulty define retbecause choose values notice ambiguity practice end host resolves ambiguity linux kernels prefer byte receive comparison operating systems openbsd prefer byte suggests define tcp retransmission preserves uniformity policy defined operating system leave investigation future work modeling application-level transformations application-level transformations operate attack payload ftp padding adds benign commands malicious commands ftp attack transformations similar transformations http uniformity proved similar modeling network-level transformation networklevel transformations udp change attack delivered transformations split packets transformations similar nature tcp transformations uniformity proofs similar proofs tcp conclusion nids testing challenging problem intrusion detection experience shown nids evaded easily frequently -complete mutation algorithm serve basis rigorous testing process infeasible test mutations knowledge present algorithm acknowledgments deeply vinod ganapathy anonymous referees comments helped refine concepts presented paper alessandri editor taxonomy intrusion detection systems attacks ibm zurich research laboratory sep deliverable project maftia ist- maftia baader nipkow term rewriting cambridge press barendregt lambda calculus studies logic foundations mathematics north holland chevalier ksters rusinowitch turuani decision procedure protocol insecurity xor ieee symp logic computer science ottawa canada june clarke jha marrero verifying security protocols brutus acm toplas oct comon-lundh shmatikov intruder deductions constraint solving insecurity decision presence exclusive ieee symp logic computer science ottawa canada june dacier editor design intrusion-tolerant 
exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc tex base encoding revision psencodingfile author rahtz mackay alan jeffrey horn berry schmidt lehman version date october filename enc tex-fonts tug docstring encoding vector type truetype fonts tex file part psnfss bundle version idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin windows ansi including euro symbol macroman extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting dotlessj ffi ffl hyphen appears compatibility ascii windows euro assigned windows ansi missing characters macroman encoding incorporated postscript macroman texbase --------------------------- -------------notequal infinity lessequal greaterequal partialdiff summation product integral omega radical approxequal delta lozenge texbase encoding notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef zcaron zcaron caron dotlessi dotlessj ffi ffl notequal infinity lessequal greaterequal partialdiff summation product grave quotesingle space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef euro integral quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft omega radical approxequal notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright delta lozenge ydieresis notdef exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla 
intrusion detection system ibm zurich research laboratory aug deliverable project maftia ist- maftia fielding gettys mogul frystyk masinter leach berners-lee rfc hypertext transfer protocol internet engineering task force june giovanni fun packets designing stick mar endeavor systems handley paxson network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington aug hodas miller logic programming fragment intuitionistic linear logic information computation hopcroft motwani ullman introduction automata theory languages computation addisonwesley edition marti thor tool test intrusion detection systems variations attacks master thesis swiss federal institute technology mar meadows nrl protocol analysis tool position paper ieee computer security foundations workshop franconia june miller nadathur pfenning scedrov uniform proofs foundation logic programming annals pure applied logic mitre corporation cve common vulnerabilities exposures cve mitre mutz vigna kemmerer experience developing ids stimulator black-box testing network intrusion detection systems annual computer security applications conference las vegas dec paxson bro system detecting network intruders real-time computer networks dec postel rfc transmission control protocol internet engineering task force sept ptacek newsham custom attack simulation language casl sockpuppet tqbf casl html ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks calgary canada rain forest puppy whisker anti-ids tactics bad ruin good thing dec wiretrip net rfp txt whiskerids html roesch snort open source network intrusion detection system snort rubin jha miller automatic generation analysis nids attacks annual computer security applications conference tucson dec rubin jha miller attack mutation test high-end nids information security bulletin apr shankar proof search intuitionistic sequent calculus proceedings international conference automated deduction cadesaratoga springs june sniphs snot jan stolenshoes net sniph index html song fragroute tcp fragmenter apr monkey dugsong fragroute vigna robertson balzarotti testing networkbased intrusion detection signatures mutant exploits acm conference computer communications security washington oct formal definition tcp formal definition tcp table predicates table definition fragmentation defragmentation tcp segment seq payload tcp segment possibly empty prefix payload possibly empty suffix payload size size size payload define seg frag payload payload seq seq seq seq size payload size tcp defragmentation defined inverse operation tcp fragmentation segment defragmentation seg frag definition retransmission tcp segment seq payload tcp segment substr possibly empty substring payload retrans payload substr seq seq index character substr payload proofs mentioned paper induction proof claim derivation single uniformity violation form claim convert derivation induction step derivation uniformity violations induction base convert derivation derivation uniformity violations induction hypothesis series shift side derivation due positive commutativity change uniformity change continue process derivation finally technique shift side derivation square proof claim frag ret based length definition definition fragmenting retransmitting tcp segment increases sequence length increases sequence complexity swap rule swaps segments delivered order operation increases disorder sequence increases sequence complexity formally pre-conditions post-conditions frag frag seg frag frag seg swap seq seq swap seq seq ret retrans ret retrans table formal definitions transformation rules rule form pre post assume swap definition swap seq seq table note order order order order order order order order assume seq seq seq order order order order means swap operation contributes disorder assume seq seq seq order order order order means disorder disorder assume seq seq seq order order order order means disorder disorder note orderings impossible seq seq swap order order proofs shrinking transformations reduce complexity analogous proofs complexity order suitable uniform reversible attack mutation system square properties conclude disorder disorder swap transformation change length stream complexity complexity adjusting http rules http represent http attack single string rules tcp represent attack tcp sequence section unify http tcp single representation tcp representation payload natural express http transformations terms tcp sequences preserve properties http tcp rules express http rules change sequence numbers tcp sequence http rules insert remove bytes shift bytes follow inserted bytes url update sequence numbers tcp segments segment url encoded byte url recall tcp support retransmission payload section means http rule insert remove change byte tcp stream copy byte stream abc bcd url http rules formally expressed simple procedure traverses segments tcp sequence modify 
egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd becd aad affbf dcc abc bff eaeee bed fbffc cdbf cdeb def cleartomark endfont texdict begin course-document dvi start texbase encoding reencodefont courier texbase encoding reencodefont times-bold texbbad fencoding reencodefont cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin end endsetup page texdict begin bop document introduction information security somesh jha computer sciences department uni ersity isconsin madison jha wisc view shared resources internet created global-information infrastructure hand shared resources create risks due intentional unintentional malicious beha ior information security area deals protection detection malicious acti vity study fundamentals information security student good understanding eral acets information security syllab basic cryptographic primiti part focus cryptographic primiti follo wing topics detail symmetric-k encryption str eam ciphers linear non-linear feedback shift gisters block ciphers des modes operations public-k encryption rsa elgamal public-k encryption hash functions data integrity basic properties hash functions unk hash functions mdc shay eop end page texdict begin bop hash functions based block stream ciphers based mdcs digital signatur classi cation digital signatures digital signatures related rsa digital signature algorithm dsa otocols section focus protocols arious purposes protocols cryptographic primiti discussed rst part protocols discuss establishment otocols erberos dif e-hellman secret sharing security secure sock ets layer ssl secur payment otocols cybercash digital money digicash system security part focus system security common system vulnerabilities attacks focus tcp syn ooding denial-of-service attacks rele ant material pro vided lecture time list vulner abilities maintained cer coordination center web-page cert located softw engineering institute carne gie mellon uni ersity fir ewalls discuss architecture alls fire alls discussed books required class notes suf cient intrusion detection systems arious types intrusion detection systems discussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort special opics time remaining discuss adv anced topics elliptic-curve crypto aphy ecc smartcar eop end page texdict begin bop book required class belo stallings crypto aphy network security principles actice prentice hall ourth edition hand xtra articles reading material class progresses grading criteria finalized homew orks short home orks assigned class exams xams mid-term nal xams equal weight oject signi project related security students pick projects pro vide refer ences cheswick bello vin rubin walls internet security repelling ily hac addison esle publishing compan northcutt network intrusion detection analyst handbook riders publishing zwick cooper chapman russell building internet walls reilly associates eop end trailer userdict end-hook end-hook eof 
spring weekly summary summary week instructor town lecture covered classic ciphers ceaser playfair ciphers convered lfsrs geffe generators attack lfsrs illustrated linearity avoided security date page handbook describes correlation attack geffe generators 
cient context-sensitive intrusion detection jonathon gif somesh jha barton miller computer sciences department wisconsin madison e-mail fgiffin jha bartg wisc abstract model-based intrusion detection compares process execution program model detect intrusion attempts models constructed static program analysis historically traded precision ciency address problem dyck model rst cient statically-constructed context-sensitive model model speci correct sequences system calls program generate stack occurring function call sites experiments demonstrate dyck model order magnitude precise context-insensitive nite state machine model null call squelching dynamic technique bound cost dyck model operates time similar contextinsensitive model present static analysis techniques designed counter mimicry evasion attacks branch analysis identi test programs system call sites affecting control return values interprocedural argument capture general values recovers arguments previously reported techniques introduction host-based intrusion detection seeks identify attempts maliciously access machine detection system executes remote intrusion detection identi hostile manipulation processes executing distributed work supported part naval research grant department energy grants de-fg de-fg lawrence livermore national lab grant nsf grant eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices xed thereon views conclusions contained authors interpreted necessarily representing cial policies endorsements expressed implied government agencies government computational grid intrusion detection systems monitor processes running local machine unusual unexpected behavior malicious modelbased detection system model acceptable behavior monitored process model describes actions process allowed execute monitor compares running process execution model ags deviations intrusion attempts model-based intrusion detection detect unknown attacks false alarms system detects attacks model nes acceptable process behavior behavior attacks false alarms low non-existent properly constructed model model captures correct execution behaviors constructing valid precise program model challenging task previous research focused basic techniques model construction human speci cation training static source code analysis static binary code analysis static binary code analysis requires human interaction determination representative data sets access program source code unsuitable interpreted-language analysis constructs models execution paths process follow false alarms occur imprecise model incorrectly accept attack sequences valid static binary analysis construct nite state machine accepts system call sequences generated correctly executing program models constructed static program analysis historically traded precision ciency precise program representations generally context-sensitive push-down automata pda prohibitively expensive operate wagner dean suggested precise digraph model simply precise models proved expensive earlier work regular language overapproximations context-free language model due cost paper presents model structure suffer drawbacks dyck model highly precise context-sensitive program representation runtime behavior slightly worse cheap imprecise regular language model dyck model powerful expressive full pda model early result chomsky proved context-free language homomorphism intersection dyck language regular language chomsky result implies dyck model powerful pda model ciency gains observe loss correctness dyck model detect broad class attacks generally model detects attacks execute arbitrary code code match expected behavior process host-based intrusion detection includes attempts exercise race condition invalid control repeatedly execute code sequence attempts bypass security checks impossible paths appendix attempts execute programs command insertion unsanitized arguments subshells changing symbolic link target exec call buffer overruns heap ows format string attacks force jump injected code dyck model suited remote intrusion detection detection technique identi hostile manipulation remotely executing programs send system calls local machine execution successful remote manipulation means local system executes malicious system calls stronger threat model host-based intrusion detection setting attackers exploit vulnerabilities speci points execution replace entire image remote process attack tool arbitrary execution point modeling remote job dyck model monitoring stream remote system calls arriving local machine detect remote manipulation produces invalid call sequences paper makes primary contributions dyck model enabling cient context-sensitive program modeling dyck model represents substantial improvement statically constructed program models dyck model exposes call stack monitor model operation highly cient monitor explores exact call path application experiments bear claims test programs show order magnitude improvement precision dyck model contextinsensitive model model precision procmail improved context-insensitive model dyck model measured average branching factor metric excluding recursive call sites impossible paths exist dyck model sequences system calls accepts program produce null call squelching dynamic method limit null call generation developed null call squelching prevent excessive null call generation reducing security squelching combines static dynamic techniques generate null calls provide context system call squelching enabled worst-case number null calls generated system call bounded diameter program call graph present dyck model null call squelching section ciency gains demonstrate squelching previous experiments context-sensitive pda completed model update failed terminate reasonable time dyck model operational cost nears context-insensitive nondeterministic nite automaton nfa model data analyses counter mimicry attacks interprocedural data analysis model arguments passed return values received system calls combination analyses hinder mimicry evasion attacks restricting paths program model accept attack sequence discuss data analysis section related work human-speci model-based intrusion detection security analyst manually speci correct behavior program interest annotates source code describe security properties runtime monitor enforces manually model alternative systems check behavior speci cation malicious activity systems reasonable small programs programs grow human speci cation overly tedious static dynamic program analysis scale automatically constructing models wagner dean statically analyzed source code extract contextinsensitive context-sensitive models cost operate precise context-sensitive abstract stack model prohibitively high unsuitable practical observed similar expense context-sensitive push-down automata constructed static analysis sparc binary code papers recommended imprecise context-insensitive models achieve reasonable performance dyck model presented paper signi cantly improves works providing precise context-sensitive model excellent performance characteristics wagner dean introduced impossible path exploit context-insensitive model includes paths originating function call site returning call site correctly executing program follow path due call stack attacker force impossible control exploit dyck model context-sensitive detects impossible path exploits dynamic analysis based seminal work forrest constructs program models observed behavior repeated training runs feng extended work sekar learn sequences system calls calling contexts vtpath program model database pairs sequential system calls stack occurring pair collected numerous training runs vtpath language regular language expansion context-free language bounded stack equivalent dyck model stack bound maximum depth program call graph ignoring recursion work differs feng important aspects dyck model fundamentally expressive vtpath ciency dyck model treats recursion regular limitation model dyck model correctly express context-sensitive recursive calls accept strictly context-free language vtpath model recursion recursive depths learned training accept regular language dyck model null 
spring weekly summary summary week lecture finished requisite math background starting public-key cryptography covered phi-function fermat theorem flt chinese remainder theorem crt covered public-key system rsa date lecture covered idea groups discrete log problem discussed elgamal crypto system diffie-hellman key exchange protocol discussed man-in-the-middle attack diffie-hellman key exchange protocol date 
spring weekly summary summary week lecture covered basics block cipher design covered fiestel cipher discussed simplified des des covered ecb mode operation date lecture finished discussion modes operation cbc ofb cfb ctr covered des des discussed meet-in-the-middle attack des discussed extended gcd algorithm date reading assignment read output feedback mode mode familiar gcd algorithm 
spring weekly summary summary week lecture started discussing macs hash functions discussed properties hash functions one-way weak collision resistance discussed model hash functions random oracles date note instructor town 
spring weekly summary summary week lecture discussed attack hash functions based birthday paradox covered iterated hash function mddate lecture briefly covered hash function shahmac discussed covered authentication protocols based symmetric encryption needham-schroeder public-key encryption denning date reading assignment sections book 
spring weekly summary summary week lecture lecture discussed overview schedule importance information security discussed date lecture discussed terms information security chosen plaintext attacks discussed one-time pads puedo-random number generators prngs specifically discussed linear congruential generator lcg blub-blum-shub bbs prngs reading assignments chapter stallings book date handbook refers alfred menezes paul van oorschot scott vanstone handbook applied cryptography crc press book found online link provided class homepage blum blum shub simple unpredictable psuedo-random generator siam journal computing pages 
spring weekly summary summary week lecture covered digital signature algorithm dsa discussed one-time password scheme leslie lamport construction mechanism called hash chains covered bit committment scheme based discrete log algorithm started discussion kerberos date lecture finished discussion kerberos version started discussing date 
spring weekly summary summary week lecture finished discussion key points authentication certificate chains discussed solution solving millionaire problem started investigating oblivious transfer protocols date lecture finished discussion oblivious transfer protocols rest lecture spent reviewing midterm date 
spring weekly summary summary week class day instructor sore throat date lecture guest lecture mihai christodorescu network-based attacks slides lecture found date 
spring weekly summary summary week lecture covered threshold cryptography discussed questions midterm date lecture anuj desai law school gave guest lecture copyright laws dmca connection laws security date 
spring weekly summary summary week lecture david parter gave guest lecture firewalls slides lecture found date lecture covered basic ssl handshake notes handed ssl protocol date 
call instrumentation detects attacks vtpath null calls reduce non-determinism enabling monitor track process execution appendix presents static analyzer constructing dyck model analyzes system call arguments return values prevent mimicry attacks dyck model includes restrictions valid arguments acceptable execution directions based system call return values vtpath model learned model ignore arguments return values context-free dyck model compact program representation worst case regular language expansion bounded context-free language vtpath grow exponentially large view static dynamic analysis techniques complementary static analysis overapproximates acceptable program behaviors generates model miss attacks conversely dynamic analysis underapproximates acceptable behaviors leading high false alarm rate ultimately hybrid model based approaches advantageous minimizing drawbacks technique chose present dyck model context static analysis appears equally suited dynamic analysis hybrid approach model construction infrastructure completeness presentation included summary infrastructure work area readers familiar work skip paper major contributions dyck model section mimicry attack defenses section tool features components binary analyzer runtime monitor analyzer reads sparc binary program static program analysis construct model program additionally rewrites binary program code enable precise cient modeling user executes rewritten binary security-critical environment runtime monitor tracks execution rewritten binary ensure analyzer constructed model deviation model security violation occurred program model nite state machine language nes sequences system calls application generate correct execution model construction progresses stages read binary program construct control graph cfg procedure application cfg represents control ows procedure convert control graph nondeterministic nite automaton nfa models correct call sequences function produce compose collection local automata points internal user function calls form single interprocedural automaton modeling entire application runtime monitor enforces program model operating interprocedural automaton runtime figure sparc assembly code functions system calls boldface figure presents nfa constructed function note system call transitions include arguments analyze data program reconstruct expression graph argument simulating execution machine instructions expression graph analyzer recovers statically argument values func save sethi file file call open mov mov mov cmp bge mov call action mov add call writewrap nop mov call action mov ret restore static char file filename void func int open file rdwr int action writewrap action action cmp ble mov sethi buf jmp read buf retl nop static char buf void action int filedes int size filedes read filedes buf size writewrap sethi root root jmp write mov static char root root void writewrap int filedes write filedes root figure sparc assembly code source code functions func action writewrap analyze binary code include source code aid comprehension code behavior recovery prevents attacker passing arbitrary arguments system calls observe rst argument read figure descriptor returned open dynamic statically recovered technique section presents technique recovery values automata desirable property system call modeling absence indirect function calls model safe exists input underlying function produces sequence calls language automaton accepts sequence monitor raise false alarms maintain safety property indirect call sites rst attempt argument recovery jump register targets test programs section analysis recovers indirect targets remaining cases mark call-site targeting function address call-site replacement constructs model entire application splicing local automata function call edges models program execution points function calls control shifts called procedure previous work constructed nfa pda global model model satisfactory nfa model figure imprecise cient context-insensitive model nfa offers excellent runtime performance suffers impossible path exploits impossible paths exist multiple call sites target procedure exist language accepted model superset program actual language includes paths actual program execution paths important attacker existence edges attack process detection bold path figure impossible path accepting repeated read write calls pda model adds context-sensitivity greater precision suffers extremely high runtime overheads figure shows pda includes model program call stack monitor traverse matching call return transitions impossible paths exist model stack model adds complexity operation pda straightforward execution fails presence left recursion post algorithm designed terminate left recursive grammar worst-case complexity cubic number aubuf action write root read func action writewrap open file action writewrap figure local function models write root read buf func open file writewrap action figure nfa program model bold cycle impossible path tomaton states leads unreasonably high runtime overheads binary rewriting mitigate cost pda operation null call insertion null calls dummy system calls observed monitor path execution process limits runtime exploration pda states dominated null call transition naive null call insertion shortcomings statically compute cost null call insertion point possibly leading high cost execution context information accurate attacker takes control application dyck model addresses shortcomings providing attack-resilient context-sensitive model dynamically controls null call cost write root read buf func open file pop push push pop writewrap action push pop pop pop figure pda program model func open write read writewrap action figure dyck model squelching dyck model developed dyck model rst cient statically-constructed context-sensitive model dyck model achieves greater ciency pda limiting state exploration pda dyck model includes stack record function call return locations dyck model stack update transitions symbols automaton alphabet monitor updates dyck stack precisely update ects actual program behavior produce stack update symbols insert null calls selected function call sites program precall immediately function call noti monitor calling location call returns program generates postcall null calls inserted call site call return path target function distinguishable postcall matching precall invoid func int open file rdwr int null call action null call null call writewrap null call null call action null call figure code dyck instrumen tation inserted null calls bold face user call null call indicating call return line numbers correspond figure gure shows code readability instrument sparc binary code dicates program attempting force execution impossible path language accepted dyck model bracketed context-free language originally developed ginsberg harrison precall postcall inserted call site correspond parenthesis symbols language form dyck language monitor accepts sequences correctly match paired preand postcalls note forced pairing stricter null calls previous work prevents introduction impossible paths attack attacker free insert change null calls wishes manipulations match correct program execution path figure shows dyck model null calls link entry exits target function model call sites function edges labeled precalls insert dyck stack edges labeled postcalls pop reaching state dyck model monitor follow transition observed symbol call stream conversely operating pda monitor replicate state follow stack 
spring weekly summary summary week lecture covered intrusion detection systems slides lecture found date lecture guest lecture mihai christodorescu malicious code slides lecture found jake rosin gave short presentation support code project date 
push transitions states suffering greater overhead figure shows program rewriter inserts dyck null calls existing program recall instrument binary code precall postcall inserted immediately call site appendix formal nition dyck model selecting instrumentation points naive instrumentation lead excessive run-time overhead program execution generates null call func open write read writewrap action figure dyck model squelching high frequency recursion loops exacerbate number null calls produced cases execution backedge function control graph program call graph leads repeated null call site execution execution patterns correspond backedge traversal affect rate execution encounters null call insert dyck calls naively selection algorithm statically chooses function call sites avoid instrumenting instrument recursive call sites strongly connected component scc program call graph represents recursive cycle rule attens scc single node lose context sensitivity points recursion limit cost instrumentation instrument call sites execute system call note function execute system call entire subgraph program call graph rooted reaches system call prunes portions call graph uninteresting system call monitoring monitor follow program execution functions generate system call null call squelching strictly static technique adequately address looping problem developed null call squelching dynamic technique restricts null call generation squelching produces meaningful null calls indicating call stack state reaching system call null calls function call returns generating system call provide security information discarded show important results rst number null calls generated bounded diameter program call graph number system calls generated show model resists attacker manipulation begin describing squelching algorithm change selection null call instrumentation points modify semantics instrumentation create squelch stack program data space precall instrumentation pushes call site identi squelch stack send identi monitor modify system call sites send squelch stack system call precall identi ers squelch stack represent calling context system call squelch stack cleared postcall code examines state squelch stack stack empty system call site symbols monitor including precall call site postcall meaningful monitor stack empty call site generated system call application pops top element call stack inserting irrelevant null calls call stream algorithm discards slight expense stack activity application note postcall pops element match popped element mismatch program manipulation visible monitor occurred program kill attacker prevent termination observe manipulation uninteresting generated system calls squelch stack entered bad state revealed system call event squelching table line shows path dyck model figure null call squelching function call generate system call produces matched dyck pair call stream pairs provide system call context removed line shows call string pairs removed remaining dyck pair envelops system call application stack context point system call squelching runtime cost null call insertion notably reduced loss security change model construction incorporate null call squelching precall-postcall sequence converted -transition describe language transformation language accepted dyck model null call squelching language accepted squelching replace precall-postcall strings denoting recursive calls terminating precallpostcall strings exist generates squelched language figure shows dyck model transformed accept squelched language note pair replaced -transition directly nally show null call squelching imposes strict upper bound cost instrumentation theorem call graph program denote graph obtained strongly connected component collapsed single state maximum diameter generates true system calls execution worst-case number null calls generated proof appendix resilience attacker manipulation dyck model relies state application squelch stack rewritten call sites produce null calls state memory image process monitor attacker arbitrarily modify state claim dyck model resilient modi cation modi cations successful represent possibly legitimate program behavior attacker modify stack monitor detect added elements system call call path represented stack legitimate argument element deletion detected attempts introduce impossible path note denial-of-service attack releasing memory stack produce memory fault stack process killed myriad simpler means attacker modify code attacker prevent null call generation generate large number null calls send erroneous null calls equivalent stack manipulations previously discussed detected attempt introduce impossible path generating large number null calls terminate process squelch stack space exhausted monitor stores program model separate process space attacker modify model simply put modi cations state application produce valid call sequences accepted monitor attacker gains modifying state data flow analysis designed advanced data analyses counter mimicry evasion attacks recent literature papers stress monitor system call arguments return values prevent attacker system calls nops mimicry attack added object analysis infrastructure enables analyses data number monitored call string null calls open read read write open read read write table system call strings accepted dyck model strings correspond paths figure figure path accepted context free dyck model string null call squelching note large drop observed null calls dependence graph ddg represents complex interprocedural data ows appendix section presents argument capture method recover statically-known arguments branch analysis explained section ddg identify branch conditions dynamically set system call return values argument branch analysis reduce opportunities successful mimicry attack argument capture prevent attacker manipulating arguments passed system call ddg recover statically-known arguments analysis recovers statically-known data values step process paths data dependence graph collect expression graph simulates execution instructions expression graph determine analysis reliably construct expression graph statically analyzer marks unknown multiple execution paths set arguments differently recover sets integers set regular expressions string arguments dependencies return previous system call interprocedural approach general constant-valued intraprocedural capture previous work restricting possibilities successful attacker manipulation importantly argument recoveries prevent mimicry evasion attacks read system call transition figure argument recovery replace transition read buf read open buf rst argument return fromopen argument set values attacker transform read call nop argument recovery prevents manipulation branch analysis mimicry attack works attacker easily generate nop system calls steer model operation needed nop calls invalid arguments force call fail change system state failed system calls return error indicator legitimate programs corrective action monitor track return values system call arguments unknown attacker undetectably system calls fail branch analysis detects manipulation analysis determines expected subsequent process execution based return system call insert predicate transitions automaton control dependencies return values runtime monitor records return values traverses edge predicate evaluates true -transition ignores edge evaluating false attacker nop call steer execution call system calls match error case behavior actual application ddg reveals branch instruction line figure based return open insert predicate transitions action model branch behavior figure attacker open call nop invalid argument monitor detect intrusion read 
ps-adobecreator dvips copyright radical eye software title hwdvi pages pageorder ascend boundingbox documentfonts times-bold times-roman cmmi cmr cmsy cmex cmmi times-italic documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips hw-o hwps dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def atan neg atan def atan parameter div dup pop div ifelse def control division net neg exch neg exch def change coordinate system negative pyth dup mul exch dup mul add sqrt def pythagoras epects parameter ptoc copy cos mul roll sin mul def polar cartesian ----------------hv added --------------pi def twopi def euler def radtodeg mul div def convert radian degrees degtorad mul div def viceversa ----------------hv pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def -------------dg begin patch --------------dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dashline dup def pathlength exch div pop def pathlength ifelse add add add def coef mul mul div round mul mul mul add exch div def coef mul def coef mul def coef mul def coef mul def mul ifelse setdash stroke def -------------dg end patch --------------dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill -----------patch ------------gsave abs hatchwidthinc abs hatchsepinc abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop itransform pathbbox div ceiling cvi div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add mul moveto rlineto stroke add hatchwidthinc clw add def hatchsepinc hatchwidthinc hatchsepinc add def clw hatchwidthinc add slw repeat grestore pop pop def gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray holds coordinates top stack showpoints boolean counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch 
logic file systems muthian sivathanu andrea arpaci-dusseau remzi arpaci-dusseau somesh jha google computer sciences department wisconsin madison muthian google fdusseau remzi jhag wisc abstract years innovation systems highly successful improving performance functionality cost complicating interaction disk variety techniques exist ensure consistency integrity system data precise set correctness guarantees provided technique unclear making hard compare reason absence formal framework hampered detailed veri cation system correctness present logical framework modeling interaction system storage system show apply logic represent prove correctness properties demonstrate logic main bene enables reasoning existing system mechanisms allowing developers employ aggressive performance optimizations fear compromising correctness logic simpli introduction adoption system functionality facilitating rigorous proof correctness finally logic helps reason smart storage systems track semantic information system key aspect logic enables incremental modeling signi cantly reducing barrier entry terms actual system designers general framework transforms hitherto esoteric error-prone art system design readily understandable formally veri process introduction reliable data storage cornerstone modern computer systems file systems responsible managing persistent data essential ensure function correctly modern systems evolved extremely complex pieces software incorporating sophisticated performance optimizations features disk key bottleneck system performance optimizations aim minimizing disk access cost complicating interaction system storage system early systems adopted simple update policies easy reason modern systems signi cantly complex interaction disk stemming asynchrony updates metadata work wisconsin-madison reasoning interaction system disk paramount ensuring system corrupts loses data complex update policies precise set guarantees system obscured reasoning behavior translates manual intuitive exploration scenarios developers hoc exploration arduous possibly error-prone recent work found major correctness errors widely systems ext reiserfs jfs paper present formal logic modeling interaction system disk formal modeling show reasoning system correctness simple foolproof formal model illustrated existence similar frameworks areas correctness paramount existing models authentication protocols database reliability database recovery examples general theories modeling concurrent systems exist frameworks general model systems effectively domainspeci logic greatly simpli modeling logic systems serves important purposes enables prove properties existing system designs resulting understanding set guarantees enabling aggressive performance optimizations preserve guarantees signi cantly lowers barrier providing mechanisms functionality system enabling rigorous reasoning correctness absence framework designers tend stick time-tested alternatives finally logic helps design functionality class storage systems facilitating precise characterization proof properties key goal logic framework simplicity order general system designers barrier entry terms applying logic low logic achieves enabling incremental modeling complete model system starting logic simply model piece functionality mechanism isolation prove properties case studies demonstrate utility cacy logic reasoning system correctness properties represent prove soundness important guarantees provided existing techniques system consistency soft updates journaling logic prove linux ext system needlessly conservative transaction commits resulting sub-optimal performance case study demonstrates utility logic enabling aggressive performance optimizations illustrate utility logic developing system functionality propose system mechanism called generation pointers enable consistent undelete les prove correctness design incremental modeling mechanism logic demonstrating simplicity process implement mechanism linux ext system verify correctness logic empirically show inconsistency occur undeletes absence mechanism rest paper organized rst present extended motivation background systems present basic entities logic formalism represent common system properties logic logic prove consistency properties existing systems prove correctness unexploited performance optimization ext reason technique consistent undeletes apply logic semantic disks finally present related work conclude extended motivation systematic framework reasoning interaction system disk multifarious benets describe key applications framework reasoning existing systems important usage scenario logic model existing systems key bene modeling enables clear understanding precise guarantees mechanism assumptions guarantees hold understanding enables correct implementation functionality system layers disk system ensuring adversely interact system assumptions write-back caching disks results reordering writes media negate assumptions journaling based logic enables aggressive performance optimizations reasoning complex interactions hard system developers tend conservative perform unnecessarily waits logic helps remove barrier enabling developers aggressive performance optimizations con dent correctness section analyze real opportunity optimization linux ext system show logic framework prove correctness nal bene logic framework potential implementation-level model checkers clear model expected behavior validate existing system enable comprehensive cient model checking current technique relying fsck mechanism expensive cost fsck explored state limits scalability model checking building system functionality recovery consistency traditionally viewed tricky issues reason classic illustration view arises database recovery widely aries algorithm pointed correctness issues earlier proposals ironically success aries stalled innovation database recovery due dif culty proving correctness techniques innovation system deals interaction disk correctness implications inertia changing time-tested alternatives sti incorporation functionality systems systematic framework reason piece functionality greatly reduce barrier entry section propose system functionality logic prove correctness illustrate cacy logic reasoning functionality examine section common system feature journaling show starting simple logical model journaling systematically arrive corner cases handled involve complex interactions developers linux ext designing semantically-smart disks logic framework signi cantly simpli reasoning class storage systems called semantically-smart disk systems provide enhanced functionality inferring system operations inferring information accurately underneath modern systems complex dependent dynamic system properties section show logic simplify reasoning semantic disk turn enable aggressive functionality background system organizes disk blocks logical les directories order map blocks logical entities les system tracks forms metadata section rst describe forms metadata systems track discuss issue system consistency finally describe asynchrony systems major source complexity interaction disk file system metadata file system metadata classi types directories directories map logical perle metadata mapped directory directories enable hierarchy les user opens path system locates perle metadata reading directory path required file metadata file metadata information speci examples information set disk blocks comprise size systems fat metadata embedded directory entries systems metadata stored separately inodes pointed directory entries pointers metadata disk blocks indirected indirect pointer blocks case large les allocation structures file systems manage resources disk set free blocks allocated les track resources systems maintain structures bitmaps free lists point free resource instances addition systems track metadata super block focus types file system consistency proper operation internal metadata system data blocks consistent state metadata consistency state metadata structures obeys set invariants system relies directory entry point valid metadata structure directory points metadata uninitialized marked free system inconsistent systems provide metadata consistency crucial correct operation stronger form consistency data consistency system guarantees data block contents correspond metadata structures point discuss issue section modern systems linux ext 
ps-adobecreator dvips copyright radical eye software title hwdvi pages pageorder ascend boundingbox documentfonts times-bold times-roman times-italic cmmi cmr cmr cmmi cmr cmsy cmsy documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips hw-o hwps dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def atan neg atan def atan parameter div dup pop div ifelse def control division net neg exch neg exch def change coordinate system negative pyth dup mul exch dup mul add sqrt def pythagoras epects parameter ptoc copy cos mul roll sin mul def polar cartesian ----------------hv added --------------pi def twopi def euler def radtodeg mul div def convert radian degrees degtorad mul div def viceversa ----------------hv pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def -------------dg begin patch --------------dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dashline dup def pathlength exch div pop def pathlength ifelse add add add def coef mul mul div round mul mul mul add exch div def coef mul def coef mul def coef mul def coef mul def mul ifelse setdash stroke def -------------dg end patch --------------dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill -----------patch ------------gsave abs hatchwidthinc abs hatchsepinc abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop itransform pathbbox div ceiling cvi div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add mul moveto rlineto stroke add hatchwidthinc clw add def hatchsepinc hatchwidthinc hatchsepinc add def clw hatchwidthinc add slw repeat grestore pop pop def gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray holds coordinates top stack showpoints boolean counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll 
reiserfs provide data consistency file system asynchrony important characteristic modern systems asynchrony exhibit updates data metadata updates simply buffered memory written disk delay interval reordering writes asynchrony crucial performance complicates consistency management due asynchrony system crash leads state arbitrary subset updates applied disk potentially leading inconsistent on-disk state asynchrony updates principal reason complexity interaction system disk raison etre logic basic entities notations section basic entities constitute system logic present notations section build entities present formalism operation system basic entities basic entities model containers pointers generations system simply collection containers containers linked pointers system differs exact types containers nes relationship container types abstraction based containers pointers general describe system containers system freed reused container considered free pointed container live instance container reuse free called generation generation speci incarnation container generations reused container reused previous generation container freed generation container life generation fully ned container logical generation number tracks times container reused note generation refer contents container abstraction current incarnation contents change affecting generation illustrate notion containers generations simple typical unix-based system system xed set designated inodes inode slot container point inode slot inode generation corresponds speci deleted inode generation deleted forever inode container simply marked free created reuse inode container logically inode generation note single container inode point multiple containers data blocks single container pointed multiple containers hard links unix systems notations notations depict basic entities relationships listed table note notations table ned section containers denoted upper case letters generations denoted lower case letters entity description represents container generation symbol description set entities point container set entities pointed container jaj container tracks container live set entities point generation set entities pointed generation denotes container pointer denotes entity points kth epoch container type kth epoch container generation kth epoch container container generation generation container table notations containers generations pointer denoted symbol container pointer container paper pointers containers live section relax assumption introduce notation pointers involving dead containers attributes containers make logic expressive modern systems extend vocabulary attributes container generation attributes container epoch epoch container ned time contents container change memory epoch incremented system sets elds inode step results epoch inode container system batch multiple contents due buffering set epochs visible disk subset total set epochs container denote epoch superscript notation denotes kth epoch note nition epoch expressivity logic imply system tracks epoch note distinction epoch generation generation change occurs reuse container epoch change contents container reused type containers type type container static change lifetime system dynamic container belong types points time ffsbased systems inode containers statically typed block containers change type data directory indirect pointers denote type container notation shared unshared container pointed container called shared container container pointer leading unshared default assume containers shared denote unshared containers operator unshared note unshared property container type system ensures container belonging type unshared pointer pointing systems designate data block containers unshared memory disk versions containers system manage structures domains volatile memory disk accessing contents container system read on-disk version container memory subsequently system makes modi cations inmemory copy container modi contents periodically written disk system writes modi container disk contents container memory disk formalism present formal model operation system rst formulate logic terms beliefs actions introduce operators logic proof system basic axioms logic beliefs state system modeled beliefs belief represents state memory disk statement enclosed represents belief beliefs memory beliefs disk beliefs denoted fgm fgd bgm belief system memory container points memory bgd means disk belief timing belief begins hold determined context formula logic describe subsection terms timing belief ned relative beliefs actions speci formula isolated belief temporal dimension memory beliefs represent state system tracks memory on-disk beliefs ned belief holds disk time crash system conclude belief purely based scan on-disk state time ondisk beliefs solely dependent on-disk data system manages free reuse containers beliefs terms generations fak bjgm valid note refers generation container on-disk beliefs deal containers generation information lost disk sections propose techniques expose generation information disk show enables improved guarantees actions component logic actions result system state actions alter set beliefs hold time actions ned logic read operation system read contents on-disk container current generation memory system container memory modify read contents memory on-disk fagm fagd write operation results ushing current contents container disk operation contents memory on-disk fagd fagm ordering beliefs actions fundamental aspect interaction system disk ordering actions ordering actions determines order beliefs established order actions resulting beliefs operators means occurred time note ordering beliefs notation indicating event creation belief state existence belief belief agm represents event system assigns pointers special ordering operator called precedes belief left operator operator ned means belief occurs means belief holds occurs implies intermediate action event invalidates belief operator transitive imply belief hold necessarily note simply shortcut note implies beliefs grouped parentheses semantics precedes group beliefs precedes belief belief parentheses precedes belief proof system primitives sequencing beliefs actions rules formulas logic terms implication event sequence sequence traditional operators implication double implication logical combine sequences logical rule notation means time event action occurs event occurs point occurrence rule occurs absolute time occur order occurs rule valid occurred general left hand side rule involves complex expression disjunction components belief rhs holds point occurrence rst event makes lhs true occurrence makes sequence true rule rule denotes time occurs occurred note rule event occurs sides event constitutes temporal point referring time instant lhs rhs temporal interpretation identical events crucial rule serving intended implication rhs refer instant rules logical proofs event sequence substitution rule subsequence occurs sequence events logically implies event apply rule event sequence replacing subsequence matches left half rule half rule postulate proof system enables deriving invariants system building basic axioms basic axioms subsection present axioms govern transition beliefs memory disk container points memory current generation points memory fbx agm agm points memory write lead disk belief points agm write agd converse states disk belief implies belief rst occurred memory agd agm agd similarly points disk read result system inheriting belief agd read agm on-disk contents container pertain epoch generation pointed generation memory write converse holds faygd write faygd akgm write faygd note refers generation rule generation 
points akg ajg hold memory points time container freed instants akgm ajgm akgm ajgm note rule includes scenario intermediate generation occurs container pointed disk subsequently system removes pointer memory write lead disk belief point agd bgm write bgd unshared container write lead disk belief container points free agd write dynamically typed container type instants freed xgm ygm xgm ygm completeness notations notations discussed section cover wide range set behaviors model system means complete set notations model aspect system show section section speci system features require notations main contribution paper lies putting framework formally reason system correctness notations introduced speci system features framework apply modi cation connections temporal logic logic bears similarity linear temporal logic syntax linear temporal logic ltl dened formula ltl formula set atomic propositions ltl formulas ltl formulas nition time future release temporal operators formalism fragment ltl set atomic propositions consists memory disk beliefs actions temporal operators allowed formalism equivalent execution sequence states ltl formula denotes true execution system satis ltl formula executions satisfy precise semantics satisfaction relation meaning found chapter semantics formalism standard semantics ltl proof system set axioms section desired property data consistency property section prove axioms denoted system satis properties set satisfy property file system properties systems provide guarantees update behavior guarantee translates rules logical model system complement basic rules reasoning system section discuss properties container exclusivity system exhibits container exclusivity guarantees on-disk container dirty copy container contents system cache requires system ensure in-memory contents container change container written disk systems bsd ffs linux ext vfat exhibit container exclusivity journaling systems ext exhibit property equations refer containers memory refer latest epoch container memory case systems obey container exclusivity means time container latest epoch memory points similarly write means latest epoch time written referring speci version epoch notation container exclusivity holds epoch container exists memory container exclusivity stronger converse agd agm agd assume unshared stronger equation equation disk belief agd hold written system note containers typical systems data blocks unshared agd agm write agd reuse ordering system exhibits reuse ordering ensures reusing container commits freed state container disk pointed generation memory freed generation made point freed state container generation pointer removed written disk reuse occurs agm agm write agm reuse results commit freed state extend rule agm agm write agm ffs soft updates linux ext examples systems exhibit reuse ordering pointer ordering system exhibits pointer ordering ensures writing container disk system writes containers pointed agm write agm write write ffs soft updates system exhibits pointer ordering modeling existing systems ned basic formalism logic proceed logic model reason system behaviors section present proofs properties important system consistency discuss data consistency problem system model journaling system reason non-rollback property journaling system data consistency rst problem data consistency system crash data consistency contents data block containers consistent metadata data blocks words end data system recovers crash assume metadata container pointers data blocks respective data block container disk belief points holds on-disk contents written generation epoch pointed time past kth generation memory generation rule summarizes fbx agd faygd fbx akgm fbx agd prove system exhibits reuse ordering pointer ordering suffers data consistency violation show system obey ordering data consistency compromised crashes simplicity make assumption data containers system nonshared les share data block pointers assume system obeys container exclusivity property modern systems ext vfat properties block exclusivity fbx agd fbx agm fbx agd rewrite rule fbx akgm fbx agd faygd rule hold means represented generation points generation contents written generation case data corruption show rule hold assume negation prove reachable sequence valid system actions faygd write event sequences implied lhs fbx akgm fbx agd write order prove prove interleaving sequences clause invalid disprove prove interleavings valid fbx akgm fbx agd event occur events due container exclusivity unshared similarly fbx akgm occur write interleavings fbx akgm fbx agd write write fbx akgm fbx agd case applying akgm fbx agd write applying akgm fbx agd write step valid sequence system execution generation freed due delete represented generation subsequent generation block reallocated represented generation memory shown violation occur assume system obeys reuse ordering equation additional constraint equation imply akgm fbx agd write write akgm fbx agd write facgd contradiction initial assumption started bgd reuse ordering shown scenario arise case write fbx akgm fbx agd applying write akgm fbx agd eqn write akgm fbx agd valid system sequence generation pointed data block generation generation deleted generation container assigned generation consistency violation occur scenario interestingly apply write write akgm fbx agd apply case belief agd hold rule led belief immediately write belief overwritten fbx agd sequence invalidate sequence reuse ordering guarantee data consistency case make assumption system obeys pointer ordering assume unshared container exclusivity holds apply equation write akgm write fbx agd applying pointer ordering rule eqn write akgm write write fbx agd agm write faygd write fbx agd faygd fbx agd contradiction implies contents disk belong generation started assumption reuse ordering pointer ordering system suffers data consistency violation system obey ordering ext data consistency compromised crashes note inconsistency fundamental xed scan-based consistency tools fsck veri inconsistency occurs practice reproduce case experimentally ext system modeling system journaling extend logic rules behavior journaling system model reason key property journaling system journaling technique commonly systems ensure metadata consistency single system operation spans multiple metadata structures system groups transaction guarantees transaction commits atomically preserving consistency provide atomicity system rst writes writeahead log wal propagates actual on-disk location transaction committed log transaction committed logged special commit record written log indicating completion transaction system recovers crash checkpointing process replays belong committed transactions model journaling logical transaction object determines set log record containers belong transaction logically pointers log copies containers modi transaction denote log copy journaled container symbol top container container log journal system note assume physical logging block-level logging ext physical realization transaction object commit record logically points containers changed transaction wal property hold commit container written log copy modi containers transaction points written commit container wal property leads rules axgm write axgm write write axgm write axgm write write rst rule states transaction committed commit record written containers belonging transaction 
formalizing sensitivity static analysis intrusion detection henry hanping feng jonathon gif yong huang somesh jhay wenke leez barton millery department electrical computer engineering massachusetts amherst fhfeng yhuangg ecs umass ycomputer sciences department zcollege computing wisconsin madison georgia institute technology fgif jha bartg wisc wenke gatech abstract key function host-based intrusion detection system monitor program execution models constructed static analysis highly desirable feature produce false alarms miss attacks prior work shown trade-off ciency precision accurate models based pushdown automata pda inef cient operate due non-determinism stack activity paper present techniques determinizing pda models rst provide formal analysis framework pda models introduce concepts determinism stack-determinism present vpstatic model achieves determinism extracting information stack activity program dyck model achieves stack-determinism transforming program inserting code expose program state results show run-time monitoring models slow execution test programs shows reasonable ciency sacri ced model precision compare models discover deterministic pda cient stack-deterministic pda require memory introduction typical host-based intrusion detection system hids monitors execution process identify potentially malicious behavior anomaly detection hids identi variations preconstructed model normal program behavior system interposes monitor process operating system events system calls program operating system validated model events conform model rejected monitor figure shows typical hids architecture techniques construct program model anomaly detection hids learning-based techniques construct program model training set execution traces speci cation program provided domain expert program model paper focuses program models constructed static analysis context static analysis trade-off ciency precision non-deterministic nite automaton nfa models cient operate introduce impossible paths model call-return semantics program pushdown automaton pda models eliminate impossible paths incorporating program stack inef cient operate inefciency pda models occurs stack activity program hidden model results non-determinism state space pda model prohibitively large operation call curse non-determinism paper formally presents techniques handle problem speci cally make contributions formal framework formal models intrusion detection research received scant attention address shortcoming investigating formalisms drives discovery program models exhibit reasonable performance primary purpose formally analyze recently proposed models insystem calls model rejected monitor model call system system call operating system program monitor figure architecture host-based intrusion detection system troduce all-new models commonality models exposure process execution state simple system call stream sekar proposed program counter information feng gif exposed stack activity program show context-free language cfl homomorphic deterministic cfl proof result similar chomsky intuition techniques expose program state non-determinism stack activity major factor contributing time space complexity operating pda models motivated observation stack-deterministic pda model stack activity deterministic section discusses formalisms model determinizing techniques techniques determinizing pda models essentially incorporate additional program state program counter stack activity model describe techniques incorporating additional state program observational technique monitor extracts relevant information program monitor extract information stack activity program walking call stack vpstatic model statically-constructed variant vtpath model implements technique rewriting instrumentation technique transforms program introduce additional code exposes program state additional system calls introduced call function model call happen recent dyck model implements approach compare observational rewriting approaches determinizing pda model sections present models evaluation results show formalisms deterministic stack-deterministic push-down automata enable construction context-sensitive program models suitable online security monitoring vpstatic automaton operation slows execution test programs unoptimized stack walking algorithm adds additional overhead dyck model slightly efcient due state non-determinism overheads dyck model compact representation requiring memory program instrumentation state machine results vindicate context sensitive models showing reasonable ciency sacri ced model precision complete results section related work signi intrusion detection systems research focused static dynamic analysis techniques automatically generate program models wagner produced models static analysis source code precise abstract stack model non-deterministic pushdown automaton pda due stack state maintained pda model captured precise call return behavior function calls runtime automaton operation monitor prohibitively high programs reaching tens minutes transaction observed similar results pda models extracted static binary analysis sparc executables papers concluded imprecise context-insensitive models reasonable performance context-sensitive models pda detect impossible path exploits wagner attacks force control enter function call site return call site portion program code suitable attack context-sensitive model detects illicit control modeling state program call stack experience severe non-determinism stack state major contributing factor time space complexity pda operation dyck model proved eliminating non-determinism stack transitions context-sensitive model ciently operated paper formalizes dyck model proves stack deterministic pda improve model eliminating additional system calls required previous model construction vpstatic model fully deterministic pda requires modi cations original analyzed binary dynamic analysis extends original work forrest constructs program model based observed system call traces numerous training runs sekar showed learning deterministic automaton associating system call program counter model monitor context information miss attacks due imprecision miss attacks dynamically linked libraries due oversimplied handling dynamic objects previous vtpath model improved precision dynamically constructed models model additionally monitors return addresses call stack vpstatic model natural extension vtpath constructed static analysis techniques add formalism previous work vtpath model calculates adhoc virtual path call stacks adjacent system calls veri validity path vpstatic provably deterministic pda automaton localizes transitions states making vpstatic precise vpstatic model suffer false alarms vtpaths due conservative static analysis pioneered work static dynamic analysis approaches monitor execution based speci cations system calls expected program behavior provided domain expert speci cations enhance quality automatically generated models vpstatic model anomaly recovery property considered previous approaches anomaly occurs uniquely determine expected state stack context valid system call monitoring program counter call stack continue operate automaton potentially detect attacks root-level exploit probe greater variety security policies enabling system fail anomalous system call continue execution terminate program monitor terminates network daemon anomalous system call denial service attack prevent anomalous call process execution monitoring continue formal models begin formally describing pushdown automata deterministic pushdown automata stack-deterministic pushdown automata nite state machines underlying constructs program models intrusion detection nition pda dpda pushdown automaton pda -tuple set states input alphabet stack alphabet transition relation mapping nite subsets unique initial state initial stack start symbol set accepting states types transitions input consumption transition top stack stack contents change represents transition consumes input state consume input move state push transition pushes stack explanation pushed stack pop transition pops stack explanation popped stack pda called deterministic transition relation satis conditions condition nonempty empty 
written disk rule states on-disk home copy container written transaction container modi committed disk note unlike normal pointers considered point containers generations pointers container rules point epochs epoch pointers commit record speci epoch snapshot container replay checkpointing process depicted rules axgd ftgd write faxgd axgd aygd write faygd rst rule container part transaction transaction committed disk on-disk copy container updated logged copy pertaining transaction rule container part multiple committed transactions on-disk copy container updated copy pertaining transactions belief transitions hold bxgm fbx agm write fbx agd axgm write faxgd rule states points belongs transaction commit leads disk belief fbx agd rule disk belief faxgd holds immediately commit transaction part creation belief require checkpoint write happen disk belief pertains belief system reach start current disk state journaling systems containers types journaled updates containers directly disk transaction machinery proofs cases complete journaling containers journaled selective journaling containers type selective case address possibility container changing type journaled type non-journaled type vice versa container belongs journaling type converse equation fbx agd bxgm fbx agm write fbx agd show complete journaling data inconsistency occurs omit due space constraints non-rollback property introduce property called non-rollback pertinent system consistency rst formally property reason conditions required hold journaling system non-rollback property states contents container disk overwritten older contents previous epoch property expressed faxgd faygd faxgm faygm rule states on-disk contents move epoch logically imply epoch occurred epoch memory non-rollback property crucial journaling systems absence property lead data corruption proof logically derive corner cases handled property hold show journal revoke records effectively ensure disk believes xth epoch possibilities type journaled type belonged transaction disk observed commit record transaction belief faxgd occurs immediately commit point actual contents written system part checkpoint propagation actual on-disk location re-establishing belief faxgd set journaled types faxgd jgm faxgm axgm write faxgd write faxgd possibility type journaled case disk learnt prior commit faxgd jgm faxgm write faxgd journaled rst assume belong journaled type prove non-rollback property lhs faxgd faygd journaled sequence events led beliefs faxgm axgm write faxgd write faxgd faygm aygm write faygd write faygd omitting write actions sequences simplicity sequences events faxgm faxgd faxgd faygm faygd faygd note sequence instances disk belief created rst instance created transaction committed instance checkpoint propagation time snapshot-based coarse-grained journaling systems ext transactions committed order epoch occurred committed rst instance faxgd occur rst instance faygd property true journaling checkpointing in-order committed transactions copies data version pertaining transaction propagated checkpoint sequences events lead interleavings depending epoch occurs epoch vice versa ordering epoch xed rest events constrained single sequence interleaving faxgm faygm faxgd faygd faygd faxgm faygm interleaving faygm faxgm faygd faxgd faxgd faygd faxgd interleaving results contradiction initial statement started faxgd faygd rst interleaving legal sequences events combined rst interleaving implies faxgm faygm proved epochs journaled non-rollback property holds journaled case type epochs belongs journaled type start statement faxgd faygd equations sequences events faygm aygm write faygd write faygd faxgm write faxgd omitting write actions sake readability sequences faygm faygd faygd faxgm faxgd prove non-rollback property show interleaving sequences faygm faxgm results contradiction co-exist faxgd faygd interleavings faygm faxgm faygm faxgm faxgd faygd faygd faygm faygd faxgm faxgd faygd faygm faygd faygd faxgm faxgd faygm faxgm faygd faxgd faygd faygm faxgm faygd faygd faxgd faygm faygd faxgm faygd faxgd scenarios imply faygd faxgd invalid interleavings scenarios valid interleavings contradict initial assumption disk beliefs time imply faygm faxgm scenarios violate non-rollback property dynamic typing journaling mechanism guarantee nonrollback due violation contents corrupted stale metadata generations scenario occur checkpoint propagation earlier epoch journaled occurs overwritten non-journaled epoch prevent impose checkpoint propagation container context transaction happen on-disk contents container updated commit journal revoke records ext precisely guarantee revoke record encountered log replay pre-scan log block propagated actual disk location scenario epoch committed disk transaction modi earlier epoch committed prevent form reuse ordering imposes container type reused memory transaction freed previous generation committed transactions commit order freeing transaction occur transaction guarantee jgm jgm faygm faxgm faygm write faxgm rule scenario handled revoke record solution properties non-rollback property holds redundant synchrony ext examine performance problem ext system transaction commit procedure arti cially limits parallelism due redundant synchrony disk writes ordered mode ext guarantees newly created point stale data blocks crash ext ensures guarantee ordering commit procedure transaction committed ext rst writes disk data blocks allocated transaction waits writes complete writes journal blocks disk waits complete writes commit block inode container data block container transaction commit container commit procedure ext expressed equation fix fkgm ixgm write fix fkgm ixgm write write write examine condition ensure no-stale-data guarantee rst formally depict guarantee ext ordered mode seeks provide equation fix fkgm fix fgd ffygd fix fgd equation states disk acquires belief fix contents data container disk pertain generation pointed memory note ext obeys reuse ordering ordered mode guarantee cater case free data block container allocated prove equation examining conditions hold equation true lhs equation fix fkgm fix fgd applying equation fix fkgm ixgm write fix fgd applying equation fix fkgm ixgm write write write fix fgd equation fix fkgm ixgm ygd write write fix fgd ygd fix fgd current ext commit procedure equation guarantees no-stale-data property waits procedure required reorder actions write write fix fkgm ixgm write write write fix fgd applying equation ygd fix fgd ordering actions write write inconsequential guarantee ext ordered mode attempts provide conclude wait ext employs write data blocks redundant unnecessarily limits parallelism data journal writes severe performance implications settings log stored separate disk illustrated previous work speci points general problem system design developers rigorous frameworks reason correctness tend conservative conservatism translates unexploited opportunities performance optimization systematic framework enables aggressive optimizations ensuring correctness support consistent undelete section demonstrate logic enables quickly formulate prove properties system features mechanisms explore functionality traditionally considered part core system design ability undelete deleted les consistency guarantees ability recover deleted les demonstrated large number tools purpose tools rebuild deleted les scavenging on-disk metadata extent systems freed metadata containers simply marked free unix system block pointers deleted inode blocks belong deleted existing tools undelete guarantee consistency assert recovered contents 
mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def arcadjust target length targetlength initial angle angle stack angle cos angle sin angle computes angle distance targetlength point cos sin note absolute angle added substracted angle contrary tvz code achieve iterates process start angle compute point distance targetlength semi-line angle aligned difference tvz code add defined add side move initialisation angle iteration input stack target length initial angle variables add targetlength angle angle cos mul def angle sin mul def angle distance targetlength point cos sin initialisation angle order approx tvz code targetlength mul angle sin mul dup mul angle cos mul dup mul add sqrt div initialisation angle large degrees set degrees ellipse curved point draw arrow degrees avoid wrong side degrees bad attractive point degrees dup pop angle exch maximum number times iterate iterative procedure iterative procedure takes angle top stack computes angle put top stack dup compute distance dup cos mul dup mul exch sin mul dup mul add sqrt equals targetlength stop dup targetlength abs pop exit stack compute point distance targetlength semi-line targetlength targetlength exch dup cos mul exch sin mul stack index div targetlength mul add div exch index div targetlength mul add div stack compute remove stack atan exch pop repeat don happened targetlength greater diameter ellipse final angle angle treat pathological case iteration stack angle tail arrow give back result angle relative angle add line angle exch def ellipticarcarrow add arrow procedure angle gsave newpath moveto clip set clippath arrow newpath draw arrow determine length grestore length arrow top stack numbers junk exch arcadjust angular position base arrow pop pop pop cos mul add sin mul add cos mul add sin mul add arrow tip coor base coor stack pop pop pop pop draw arrow discard coordinates clw div change test def add def ifelse arcadjust resets original def add def ifelse adjust angle give overlap def -----------------tvz end ------------------rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage 
condition element deterministic pda abbreviated dpda nition stack symbol pushed popped stack general nition pda found stack symbol pushed stack easy pda general nition converted pda conforms nition construction essentially transforms pushing symbols stack sequence pushes symbol pda con guration tuple current state string stack symbols representing stack contents con gurations transformed sequence transitions pda consuming input relation extended words con gurations transformed sequence transitions pda consuming input string clear context simply write language accepted dened fwj pdas accept context free languages cfl language accepted dpda called deterministic context free language dcfl theorem proves cfl homomorphic dcfl proof theorem procedure determinizing pda expanding input alphabet proof similar chomsky theorem cfl exists dcfl homomorphism proof pda accepting construct input alphabet types symbols input input symbol input symbol represents consuming input transitioning state push input symbol input symbol represents consuming input pushing stack transitioning state pop input symbol input symbol represents consuming input popping stack transitioning state construct dpda notice components input alphabet transition relation transition relation dpda ned transition transition transition transition transition transition easy deterministic homomorphism language accepted dpda construction proof theorem expands input alphabet exposing stack operations target state transition input symbol dpda consume input push stack transition state suppose pda models program case dpda models program internal state program stack activity exposed words exposing program state corresponds input alphabet expansion theorem intrusion detection pdas dpdas model-based intrusion detection constructs model program figure generates sequence symbols sequence system calls receiving symbol program model determines exist transitions symbol exist transition input symbol monitor reports intrusion model processes symbol updates state pda models suppose model pda state model set con gurations model initial state set con gurations processing sequence symbols suppose symbol generates state program succ represents con gurations result con gurations processing input formally succ ned succ empty monitor reports intrusion state model succ processing continues general state model nite suppose model state receives symbol assume model transitions easy succ nite set notice niteness arises rule corresponds left recursion program turns state model set con gurations regular represented nite-state automaton time space complexity updating state model receiving symbol cubic size model wagner dean concluded operating pda model intrusion detection prohibitively expensive dpda models suppose model dpda input symbol con guration dpda exists con guration easy monitoring set con gurations conguration time space complexity updating state model receiving symbol stack-deterministic pda models experience nondeterminism stack activity major contributing factor time space complexity operating pda models motivates nition stack-deterministic pda model non-determinism requires state stack left unchanged points nondeterminism formally pda called stack-deterministic pda sdpda satis conditions condition stack activity -transitions push pop transition condition stack activity depends input symbol top stack exist states necessarily assume sdpda model program intrusion detection set con urations obtained processing sequence symbols conditions con gurations stack formally set states stack alphabets model size jqj time space complexity processing symbol language accepted sdpda called stack-deterministic context free language sdcfl theorem appendix proves language accepted sdpda dcfl sdpda fundamentally powerful dpda theorem cfl exists sdcfl homomorphism proof pda accepting construct set input symbols types symbols input simply input alphabet pda push input symbol input symbol represents consuming input pushing stack pop input symbol input symbol represents consuming input popping stack construct sdpda psd notice components psd input alphabet transition relation transition relation sdpda psd ned transition transition transition transition transition transition easy psd stack-deterministic homomorphism psd language accepted psd psd construction proof theorem expands input alphabet exposing stack operations input alphabet sdpda consume input push stack recall proof theorem expanded input alphabet expose stack activity target transition consume input push stack transition state constructing sdpda exposed stack activity pda target transition table summarizes time space complexity processing symbol models size input alphabet models shown theorems clear size input alphabets dpda sdpda models larger pda model time complexity space complexity input alphabet size pda dpda knr sdpda table time space complexities processing input symbol models number states transitions model denoted size input stack alphabets pda denoted connection existing techniques authors proposed exposing program state improve precision models sekar propose program counter information equivalent expanding input alphabet expose target transition gif feng expose stack activity program context equivalent expanding input alphabet exposing stack activity similar homomorphism demonstrated proof theorem formal framework pda dpda sdpda homomorphisms systematic understanding evaluating techniques expose additional program state vpstatic model determinizing stack exposure vpstatic model statically-constructed variant context-sensitive vtpath model dynamic counterpart stackwalks execution determine call stack state monitored process combined program counter monitoring produces extra symbols fully determinize model model generation static analysis vpstatic model generated statically analyzing binary executable program rst introduce notation function entry state entry exit state exit function executable system call state system call instruction call site entry state state call exit state state return function call site addr addr addr denote address system call function call instruction addr addr func function instruction address states char filename pid pid int prepare int index entry prepare char buf pid index getpid getpid strcpy buf filename return open buf rdwr open exit prepare void action entry action uid uid getuid getuid int handle uid handle prepare read handle read handle prepare write handle write close handle close exit action figure simple code fragment simple program fragment shown figure running automaton left side list transitions figure describe non-deterministic pda program similar callgraph model callgraph model system call numbers observed inputs simulate automaton commonly place holder transitions system call pda non-deterministic exposed stack activities targets transitions make pda deterministic extract address information binary expose internal state automaton side list transitions figure describe nal dpda input symbols dpda forms proof theorem slight modi cations system call call site states addr expose state address information extract program counter call stack dynamically monitoring program executions addr means automaton consumes input symbol pops stack transitions state equivalent transition proof theorem symbols similarly explained forms input symbols figure formal models section proved pushdown automaton deterministic detailed description model appendix online detection dynamic monitoring pro generated simulate automaton online program monitoring sysentry action getuid read write close exit action entry 
valid undelete fundamentally best-effort les recovered blocks subsequently reused user trustworthy recovered contents demonstrate logic existing systems consistent undelete impossible provide simple solution prove solution guarantees consistent undelete finally present implementation solution ext undelete existing systems model undelete logic express pointers containers holding dead generation introduce notation pointer call dead pointer operator container denotes set dead live entities pointing container undel undelete action container undelete process summarized equation undel fbx agd fbggd fbx agd fby agd words dead free container points disk container alive dead pointing undelete makes generation live makes point guarantee hold consistency dead pointer brought alive ondisk contents time pointer brought alive correspond generation epoch originally pointed memory similar data consistency formulation fbx akgm fbx agd fby agd fbx agd fazgd note clause required lhs cover case generation brought life true undelete show guarantee hold necessarily negation rhs fazgd show condition co-exist conditions required undelete equation words show undel fbx agd fbggd fazgd arise valid system execution utilize implications proof fbx agd fbx akgm write fazgd write interleaving event sequences write fbx akgm write valid system sequence represented generation points written disk block freed killing generation generation allocated generation deleted written disk disk beliefs fbx agd fazgd initial state disk sequence simultaneously lead disk belief fbggd shown conditions fbx agd fbggd fazgd hold simultaneously undelete point lead violation consistency guarantee associate stale generation undeleted shown reuse ordering pointer ordering guarantee consistency case undelete generation pointers propose notion generation pointers show pointers consistent undelete guaranteed assumed pointers disk point containers discussed section pointer pointed speci generation leads set system properties implement generation pointers on-disk container generation number incremented time container reused addition on-disk pointer embed generation number addition container generation pointers on-disk contents container implicitly generation fbkgd valid belief means disk contents belong generation generation pointers criterion undelete undel fbx akgd fakgd fbx akgd fby akgd introduce additional constraint fazgd left hand side equation previous subsection fbx akgd fakgd fazgd denote on-disk container holds generation number fahgd equation fbx akgd fakgd fahgd contradiction means ondisk container generations simultaneously undelete occur scenario alternatively agged inconsistent undeletes occurring generation pointers consistent implementation undelete ext proof consistent undelete implemented generation pointer mechanism linux ext block generation number incremented time block reused generation numbers maintained separate set blocks ensuring atomic commit generation number block data straightforward data journaling mode ext simply add generation update create transaction block pointers inode extended generation number block implemented tool undelete scans on-disk structures restoring les undeleted consistently speci cally restored generation information metadata block pointers match block generation data blocks ran simple microbenchmark creating deleting directories linux kernel source tree observed roughly deleted les les roughly detected inconsistent undeletable remaining les successfully undeleted illustrates scenario proved section occurs practice undelete tool generation information wrongly restore les corrupt misleading data application semantic disks interesting application logic framework systems enables reasoning recently proposed class storage systems called semanticallysmart disk systems sds sds exploits system information storage system provide functionality admitted authors reasoning correctness knowledge tracked semantic disk hard formalism memory disk beliefs sds model extra system state tracked sds essentially disk belief section rst logic explore feasibility tracking block type semantic disk show usage generation pointers system simpli information tracking sds block typing important piece information required semantic disk type disk container identifying type statically-typed containers straightforward dynamically typed containers hard deal type dynamically typed container determined contents parent container indirect pointer block identi observing parent inode block indirect pointer eld tracking dynamically typed containers requires correlating type information typedetermining parent information interpret contents dynamic container accurate type detection sds guarantee hold kgd kgm words disk interprets contents epoch belonging type contents belonged type memory guarantees disk wrongly interpret contents normal data block container indirect block container note equation impose guarantee disk identies type container states association type contents correct prove rst state algorithm disk arrives belief type sds snoops metadata traf type-determining containers inodes container written observes pointers container concludes type pointers assume pointer type points container disk examines container written time freed interprets current contents belonging type written time contents type equation kgd fby agd faxgd words interpret belonging type disk container points current on-disk epoch type function abstracts indication disk contents epoch order associate contents type explore logical events led components side equation applying fby agd fby agm fby agd fby agm kgm fby agd similarly component faxgd faxgd write faxgd verify guarantee equation assume hold observe leads valid scenario add clause jgm equation equation prove fby agd faxgd jgm event sequences fby agm kgm fby agd jgm write type epoch unique write container implies type jgm write jgm write sequences interleaved ways epoch occurs epoch kgm interleaving fby agm kgm fby agd jgm write fby agm kgm fby agd jgm write valid sequence container freed disk acquired belieffb agand version written actual type changed memory leading incorrect interpretation belonging type order prevent scenario simply reuse ordering rule rule sequence imply fby agm kgm fby agd write jgm write fby agm kgm fby agd jgm write written disk treating free wrongly associate type interleaving proceeding similarly interleaving epoch occurs assigned type arrive sequence jgm write fby agm kgm fby agd simply applying reuse ordering rule prevent sequence stronger form reuse ordering freed state includes containers pointed allocation structure jaj tracking liveness rule sequence jgm write write jaj fby agm kgm fby agd add behavior sds states sds observes allocation structure indicating free inherits belief free write jaj applying sds operation eqn jgm write fby agm kgm fby agd sequence sds observe write treated free associate type subsequently written shown sds accurately track dynamic type underneath system ordering guarantees shown system exhibits strong form reuse ordering dynamic type detection made reliable sds utility generation pointers subsection explore utility systemlevel generation pointers context sds illustrate utility show tracking dynamic type sds straightforward system tracks generation pointers generation pointers equation kgd fby aggd faggd causal event sequences explored previous subsection fby aggm kgm fby aggd jgm write sequences imply generation types violates rule straightaway arrive contradiction proves violation 
rule occur related work previous work recognized modeling complex systems formal frameworks order facilitate proving correctness properties logical framework reasoning authentication protocols proposed burrows related work spirit paper authors formulate domain-speci logic proof system authentication showing protocols veri simple logical derivations domain-speci formal models exist areas database recovery database reliability body related work involves generic frameworks modeling computer systems wellknown tla framework automaton framework frameworks general model complex systems generality curse modeling aspects system extent paper tedious generic framework tailoring framework domain-speci knowledge makes simpler reason properties framework signi cantly lowering barrier entry terms adopting framework speci cations proofs logic lines contrast thousands lines tla speci cations automated theorem-proving model checkers bene generic framework tla previous work explored veri cation correctness system implementations recent body work model checking verify implementations body work complementary logic framework logic framework build model invariants hold model implementation veri finally system properties listed section identi previous work soft updates recent work semantic disks conclusions dependability computer systems important essential systematic formal frameworks verify reason correctness systems critical component system dependability formal veri cation correctness largely making systems vulnerable hidden errors absence formal framework sti innovation skepticism correctness proposals proclivity stick time-tested alternatives paper step bridging gap system design showing logical framework substantially simplify systematize process verifying system correctness acknowledgements lakshmi bairavasundaram nathan burnett timothy denehy rajasekar krishnamurthy florentina popovici vijayan prabhakaran vinod yegneswaran comments earlier drafts paper anonymous reviewers excellent feedback comments greatly improved paper work sponsored nsf ccrccr- ccrngs- itribm network appliance emc attie lynch dynamic input output automata formal model dynamic systems acm podc jfs overview ibm developerworks library jfs html bjorner browne colon finkbeiner manna sipma uribe verifying temporal properties reactive systems step tutorial formal methods system design fmsd burrows abadi needham logic authentication acm sosp pages clarke grumberg peled model checking mit press ganger mckusick soules patt soft updates solution metadata update problem file systems acm tocs hadzilacos theory reliability database systems acm hagmann reimplementing cedar file system logging group commit sosp nov kuo model veri cation data manager based aries acm trans database systems lamport temporal logic actions acm trans program lang syst mckusick joy lef fabry fast file system unix acm transactions computer systems august mogul update policy usenix summer boston june mohan haderle lindsay pirahesh aries transaction recovery method supporting finegranularity locking artial rollbacks write-ahead logging acm tods march musuvathi park chou engler dill cmc pragmatic approach model checking real code osdi dec pnueli temporal semantics concurrent programs theoretical computer science tcs prabhakaran arpaci-dusseau arpaci-dusseau analysis evolution journaling file systems usenix r-undelete r-undelete file recovery software http undelete reiser reiserfs namesys restorer restorer data recovery software http bitmart net sivathanu bairavasundaram arpaci-dusseau arpaci-dusseau life death block level osdi pages san francisco december sivathanu prabhakaran arpaci-dusseau arpaci-dusseau improving storage system availability graid fast tweedie future directions ext filesystem freenix monterey june tweedie ext journaling file system http olstrans sourceforge net release ols -ext ols ext html july yang twohey engler musuvathi model checking find file system errors osdi dec manolios lamport model checking tla specications lecture notes computer science 
prepare getpid exit prepare open getuid addr getuid addr addr read addr read write addr write close addr close close addr close exit action getpid addr getpid open addr open exit prepare entry prepare addr entry prepare addr addr addr addr addr getuid read write close close getpid open push addr push addr pop addr pop addr figure pda vpstatic dpda generated code exit func exit func exit func entry func entry func entry func figure vpstatic input symbol sequence generated system call tem call made extract call site addresses functions returned virtual stack list vsl ordered outermost function innermost function nition vsl similar assume virtual stack lists current system calls assume current system call address current program counter system call address suppose rst index items equal current system call generate sequence input symbols feed automaton input symbol sequence generated shown figure assume ordinary user root executes program runs getpid line figure virtual stack list pre addr pre sequence addresses functions lead toaction system call getpid program executes open virtual stack list call stack change system call open figure symbol sequence generated open addr sopen successfully leads automaton state sopen attacker ows buffer strcpy change return address prepare addr gain unauthorized write access prepare returns case virtual stack list pre addr addr addr figure symbol sequence generated exit prepare addr addr addr entry prepare addr open addr sopen state sgetpid transition exit prepare alarm triggered intrusion detected input symbols generated system call processed current state state system call current automaton stack context vsl system call current state stack context uniquely decided valid system call transition follow input symbol anomalous execution indicative intrusion attempt occurred action prepare getuid getpid openprepareprepare writeread close figure local dyck models dyck model determinizing instrumentation shown section adding stack determinism pda requires additional alphabet symbols make stackmodifying transitions deterministic statically constructed program models pda stack model running process call stack stack operations occur function call sites returns dyck model binary rewriting insert code function call site generate extra symbols needed stackdeterminism static model construction dyck static analyzer reads binary program image produces dyck model instrumented version binary requires steps function construct control graph cfg convert cfg local model nondeterministic nite automaton accepts sequences function calls kernel traps function generate correct execution classify function calls insert code function call sites generate symbols stackdeterminism instrumentation adds events call stream update local models match combine collection modi local models single sdpda modeling entire rewritten program recall figure shows code functions prepare action show source code readability analyze sparc binary code convert function cfg local model straightforward cfg non-deterministic nite state machine edges unlabeled basic block user call kernel trap site label outgoing void action uid uid getuid int handle uid precall handle prepare postcall read handle precall handle prepare write handle close handle postcall figure code dyck instrumentation inserted code appears boldface edges block call label edges convert basic blocks automaton states -reduced minimized local automata code shown figure appendix formal nition local model add edges local models function call transitions model call stack occurring runtime edge call transition pushes unique identi pda stack runtime monitor edge call pops identi call site unique push pop symbol monitor differentiate call sites function nfa local models pdas add stack-determinism pda models add symbols event stream distinguish stack operation analyzer rewrites binary image program inserting history stack program data space adding code immediately call site history stack records stack occurring kernel trap precall code call site pushes symbol history stack call generates kernel trap returning monitor reads collected symbols history stack identify execution path program call returns generating kernel trap postcall code pops history stack discards adds symbol history stack figure shows rewritten code action instrumented call sites prepare adding code instrumentation recursive call sites potentially high runtime cost add stack transitions local models code binary image call sites recurse lastly compose collection modi local automata points function calls form global model action prepare getuid getpid open writeread close figure dyck model entire program analyzer replaces function call transition -edges entering returning model target function figure shows completed dyck model functions note similarity vpstatic model earlier input symbol additionally pushes identi pda stack symbol input symbol pops appendix formally nes model language theory dyck model sdpda appendix runtime monitoring user executes rewritten binary securitycritical environment runtime monitor tracing execution system calls monitor enforces model guaranteeing process execution deviate sequences system call streams dyck model operation straightforward vpstatic operation model pda monitor pda stack due stack-determinism traced process generates kernel trap monitor reads saved symbols process history stack symbol input automaton modi stack state corresponds return call function symbols equivalent virtual path symbols calculated stack walks vpstatic model monitor processes kernel trap symbol permitting execution symbol valid transition model performance measurements compare performance vpstatic dyck models measured costs execution monitoring measured increase execution time monitoring calculated increased memory due program models dyck instrumentation analyzed performance test programs tools build models statically-linked programs result set test programs representative greatest security concern mix computation-intensive syscallintensive programs table lists programs workloads statistics htzipd proprietary implementation httpd httpd implementation successfully compiled statically solaris execution time overheads calculated subtracting base execution time monitored execution time times averaged runs execution times include setup time monitor program model read disk current implementation vpstatic dyck monitors execute user space detect system call events solaris process tracing evaluate cost operating model base execution time measured process tracing enabled system call stop monitor resume execution stopped process difference base time monitored time captures overhead model operation calculated memory usage similarly interest increase state required process static code monitoring process meaning shared audited processes vpstatic model compute process state taking difference memory full auditing enabled empty pro loaded auditing disabled memory dyck model includes cost binary code inserted original application section include measurements previously average branching factor metric metric poorly suited measurements context-sensitive languages stack transitions entering system call wrapper functions obscure reachable system calls lacking metric rely theoretical discussions previous sections evaluation strength models strength metrics applied future research develops reasonable measurement algorithms 
execution time overhead results table execution time overheads vpstatic dyck models base execution times presented differences monitor implementations result base times due high cost stack walk operation vpstatic model separate model runtime components time operate automaton time perform stack walk dyck model walk call stack separation presented program workload instructions functions call sites htzipd service client requests transferring total gzip compress tar cat concatenate les totalling table test programs workloads statistics vpstatic dyck program untraced base automaton stackwalk base automaton htzipd gzip cat table model execution times seconds base execution time includes system call tracing automaton operation percentages compare base execution program vpstatic dyck htzipd gzip cat table average system call veri cation time microseconds table shows average monitor execution time microseconds system call event received system call requires monitor update calling context information verify system call valid operation program model times perform operations remained constant number stack symbols read monitored process changed outlying points occur tables show interesting results deterministic stack-deterministic models cient operate automaton operations deterministic vpstatic model extremely fast vpstatic model cient operate dyck model result occurs reasons illustrates operational differences deterministic stack-deterministic automata dpda vpstatic model operates constant time sdpda underlying dyck model requires linear time operation table effect visible respective runtimes models dyck model additional execution function call sites due injected code cost arises process execution path generate system calls vpstatic model incurs monitoring cost system call events memory overhead results table presents memory execution monitoring models divide memory costs dyck model cost current rewriting infrastructure doubles size program code segment cost code insertions state machine representation infrastructure cost excessive signi cantly reduced shifting efcient rewriter vpstatic state machine cost greater dyck models highlights differences dpda sdpda models automaton allowing non-determinism state transitions naturally compact representation dyck model produce smaller automaton structures vpstatic model optimized vpstatic model size remove function entry exit nodes techniques similar automaton reduction dyck model original format model recent development conceptually clearer discussion draw primary conclusions work formalisms deterministic stack-deterministic push-down automata result highly accurate highly cient program models non-deterministic contextsensitive models produced overheads orders magnitude worse base execution suitable real-world operation automaton operation overheads low show context-sensitivity precise program models sacri ced performance differences models suggests hybridization construction monitoring techvpstatic dyck program unmonitored state machine infrastructure instrumentation state machine htzipd gzip cat table memory due monitoring percentages increases unmonitored execution niques bene cial dyck model produces context information points recursion dynamic linking non-instrumented binaries vpstatic model identify missing information inspecting existing program state instrumented libraries dyck model easily libraries runtime memory offsets return addresses issue dyck model successfully reveal context information optimized binaries stack walking difcult impossible hand binary rewriting occasionally fail rely stack walk technique recover state information likewise limit instrumentation set critical program points rely stack walking hybrid model combine state recovery mechanisms capture complete context system call hybrid gain strengths models minimizing drawbacks limitations approaches produce sensitive accurate models approaches limitations documented attackers exploit weaknesses limitations intrusion detection models avoid detection short complete instrumentation amounts essentially interpreting program statically-generated models complete information state executing program attacker exploit incomplete information model evade hids incomplete sensitivity models discussed paper incorporate information stack activity program models context sensitive model track predicates branches path sensitive incompleteness result model allowing extraneous behavior code fragment char str user str char calloc user char calloc strncmp user admin sys sys strcpy str someinput strncmp user admin sys sys system call sequences code fragment sys sys sys sys sequences correspond predicate strncmp user admin true false notice predicates branches models track values branch predicates sequences sys sys sys sys sys sys sys sys attacker exploit limitation avoid detection attack large someinput strcpy str heap change user user guest strcpy user admin illegal sequence sys sys executed accepted model attack detected incomplete set events events monitored model system calls pointed wagner soto tan attacker evade detection generates sequence events accepted model previously presented attack code segment system calls buffer-overflow occurs program jumps regular user return super user privileges execve bin attack buffer force program jump illegally obtain root shell inserting code instrumentation models miss attack system call code segment call words matter program control illegally modi code segment observable events models code instrumentation added call attack detected model attack evade detection simply replaces system call parameters recover arguments system calls static analysis system calls incomplete information arguments playing inside sandbox mimicry attacks assume attackers complete knowledge model-construction algorithm mimicry attacks adversary transforms attack resulting sequence accepted detection model attacker mimic legal program behavior generating legal system calls inserting original attack sequence attacker attack sequence semantically equivalent original attack sequence attacks easily evade simple detection models n-gram model proposed incorporating additional information program model makes dif cult mount mimicry attacks models monitors information system calls program counter call stack mount successful mimicry attack adversary required produce correct call stack program counter information sequence system calls equivalent attack conclusions formally statically-constructed contextsensitive program models host-based intrusion detection seeking add ciency precision models examined deterministic pdas introduced stack-deterministic pdas proofs language equivalence homomorphic image dcfl sdcfl cfl give rise monitoring techniques make models vpstatic model walks process call stack harvest return addresses revealing context information enabling deterministic model program instrumentation dyck model eliminates stack non-determinism experiments demonstrate contextsensitivity ciency coexist program models bene ting intrusion detection systems acknowledgments anonymous referees comments members wisa security group wisconsin provided ongoing feedback work acknowledge weibo gong massachusetts discussion support prahlad fogla oleg kolensnikov georgia institute technology provided ongoing feedback work eel analyze sparc binary code work supported part army research ofce contract daad naval research grant nsf grants ccrand ccrand department energy grants defg de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices xed thereon views conclusions contained authors interpreted necessarily representing cial policies endorsements expressed implied government agencies government chomsky context-free grammars pushdown storage quarterly progress report pages massachusetts institute technology research laboratory electronics april feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland california forrest hofmeyr somayaji longstaff sense unix processes ieee 
copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def arcadjust target length targetlength initial angle angle stack angle cos angle sin angle computes angle distance targetlength point cos sin note absolute angle added substracted angle contrary tvz code achieve iterates process start angle compute point distance targetlength semi-line angle aligned difference tvz code add defined add side move initialisation angle iteration input stack target length initial angle variables add targetlength angle angle cos mul def angle sin mul def angle distance targetlength point cos sin initialisation angle order approx tvz code targetlength mul angle sin mul dup mul angle cos mul dup mul add sqrt div initialisation angle large degrees set degrees ellipse curved point draw arrow degrees avoid wrong side degrees bad attractive point degrees dup pop angle exch maximum number times iterate iterative procedure iterative procedure takes angle top stack computes angle put top stack dup compute distance dup cos mul dup mul exch sin mul dup mul add sqrt equals targetlength stop dup targetlength abs pop exit stack compute point distance targetlength semi-line targetlength targetlength exch dup cos mul exch sin mul stack index div targetlength mul add div exch index div targetlength mul add div stack compute remove stack atan exch pop repeat don happened targetlength greater diameter ellipse final angle angle treat pathological case iteration stack angle tail arrow give back result angle relative angle add line angle exch def ellipticarcarrow add arrow procedure angle gsave newpath moveto clip set clippath arrow newpath draw arrow determine length grestore length arrow top stack numbers junk exch arcadjust angular position base arrow pop pop pop cos mul add sin mul add cos mul add sin mul add arrow tip coor base coor stack pop pop pop pop draw arrow discard coordinates clw div change test def add def ifelse arcadjust resets original def add def ifelse adjust angle give overlap def -----------------tvz end ------------------rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict 
start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc tex base encoding revision psencodingfile author rahtz mackay alan jeffrey horn berry schmidt lehman version date october filename enc tex-fonts tug docstring encoding vector type truetype fonts tex file part psnfss bundle version idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin windows ansi including euro symbol macroman extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting dotlessj ffi ffl hyphen appears compatibility ascii windows euro assigned windows ansi missing characters macroman encoding incorporated postscript macroman texbase --------------------------- -------------notequal infinity lessequal greaterequal partialdiff summation product integral omega radical approxequal delta lozenge texbase encoding notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef zcaron zcaron caron dotlessi dotlessj ffi ffl notequal infinity lessequal greaterequal partialdiff summation product grave quotesingle space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef euro integral quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft omega radical approxequal notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright delta lozenge ydieresis notdef exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset aae enc thomas esser dec public domain encoding cmmi cmmi cmmi cmmi cmmi cmmi cmmi cmmib texaae encoding gamma delta theta lambda sigma upsilon phi psi omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda rho sigma tau upsilon phi chi psi omega epsilon theta rho sigma phi arrowlefttophalf arrowleftbothalf arrowrighttophalf arrowrightbothalf arrowhookleft arrowhookright triangleright triangleleft zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle period comma slash greater star partialdiff flat natural sharp slurbelow slurabove lscript dotlessi dotlessj weierstrass vector tie psi notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space gamma delta theta lambda sigma upsilon phi psi notdef notdef omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda rho sigma tau upsilon phi chi psi tie notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset enc thomas esser dec public domain encoding cmb cmbx cmbx cmbx cmbx cmbx cmbx cmbx cmbxsl cmdunh cmr cmr cmr cmr cmr cmr cmr cmsl cmsl cmsl cmsl cmss cmss cmss cmss cmss cmssbx cmssdc cmssi cmssi cmssi cmssi cmssi cmssq cmssqi cmvtt texf encoding gamma delta theta lambda sigma upsilon phi psi omega ffi ffl dotlessi dotlessj grave acute caron breve macron ring cedilla germandbls oslash oslash suppress exclam quotedblright numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon exclamdown equal questiondown question bracketleft quotedblleft bracketright circumflex dotaccent quoteleft endash emdash hungarumlaut tilde dieresis suppress notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space gamma delta theta lambda sigma upsilon phi psi notdef notdef omega ffi ffl dotlessi dotlessj grave acute caron breve macron ring cedilla germandbls oslash oslash suppress dieresis notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef 
symbol failed open call blocks path read call return branch analysis helps prevent development successful attacks evaluation evaluate program models criteria precision ciency precise models present attacker opportunity insert malicious system calls cient model adds small runtime overhead existing process execution cient models deployed precise models add security precise models generally higher runtime overhead demonstrate dyck model squelching presents excellent tradeoff precision ciency metrics standard techniques measure criteria average branching factor metric originally developed wagner dean measures model precision average branching factor dynamic measure adversary opportunity insert dangerous system calls running process call stream monitor operates call sites program workload functions instructions system user procmail filter message local mailbox gzip compress text eject open cd-rom drive tray fdformat format high-density oppy disk report process status processes cat concatenate les totaling table test programs workloads statistics open open action read figure model action branch analysis automaton model records potentially dangerous system calls accept call average branching factor total number calls divided number automaton updates performed monitor low average branching factor attacker opportunity undetectably insert malicious system calls call stream ciency measurements straightforward forms time length process execution model operation measure process runtime memory usage increase due binary code instrumentation model state monitor experimental design include precision ciency results test programs table shows workloads program note experiments reproducible execution depends constantly changing system state table statistics binary code program number user function call sites level interprocedural control transfers worst-case number dyck instrumentation points analyze statically-linked binaries statistics include linked library code test programs runtime monitor run solaris sun ultra mhz workstation procmail gzip eject fdformat cat average branching factor nfa dyck squelched dyck figure nfa dyck precision lower bars greater precision ram monitor test processes run simultaneously machine implemented support kernel trap monitoring application communicates monitor shared message queue purposes experimentation collection solaris libc kernel trap wrapper functions nes set system call events measured precision ciency programs monitor calculates average branching factor test program method determine runtime overheads unix time program measure wall time elapsed execution test program test program monitor execute machine time includes test process execution monitor execution operates automaton context switches processes time include setup time monitor parses program model measure memory usage recording maximum process image size observed return brk kernel trap ran experiments lightly loaded multi-user machine active users effects dyck model analyzed dyck model uenced precision ciency compared dyck model program base nfa dyck squelched dyck procmail gzip eject fdformat cat table program execution times seconds base execution time automaton operation percentages compare base execution models argument recovery branch analysis program unmonitored infrastructure instrumentation state machine increase procmail gzip eject fdformat cat table memory due instrumentation monitoring unmonitored base case ecution unmodi programs columns show additional due rewriting infrastructure instrumentation state machine structure monitor column shows percentage increase compared base case squelching nfa model previous work figure shows precision models test programs note dyck models improve precision order magnitude procmail improves average branching factor nfa model squelched dyck model squelched model appears slightly precise unsquelched dyck model side effect average branching factor calculation recall monitor divides number potentially dangerous system calls accepted execution number automaton operations average branching factor inversely proportional number events passed monitor squelched program generate fewer null calls unsquelched program leading slight increase average branching factor table presents execution times models measurement noise accounts slight timing variations note marked improvement dyck model includes squelching squelched dyck model produced times system calls nfa model depending program exception cat performance impact additional calls signi system-call-bound program cat additional time consumed null calls noticeable expect performance markedly improved batching dyck calls sending actual system calls minimize number user-to-kernel transitions squelching critical unsquelched gzip model generated times system calls base execution due loop iteration measured memory overhead monitoring squelched dyck model table overhead parts memory monitor process increased size instrumented executable monitor processes differing state machine read monitor code static data one-time cost shared multiple executions approximately code resides shared libraries processes system state machines shared memory sizes shown column instrumented binaries additional memory reasons program size increases artifact current rewriting infrastructure column overhead disappear transition rewriting environment areas project null call insertion adds code program shown column column shows percentage increase due instrumentation state machine structure monitor memory demands critical monitor large numbers processes system identi areas make substantial optimizations memory usage column reduced cient encodings state machines unaware published memory related projects results compare favorably procmail gzip eject fdformat cat average branching factor capture intraprocedural analysis constant values interprocedural analysis general values figure effects argument capture lower bars greater precision bars squelched dyck model black bars correspond black bars figure note average branching factor scale changed order magnitude figure effects argument capture squelched dyck model represents tradeoff precision ciency model investigate effects improved argument capture tested argument capture forms argument capture turned recovered arguments set intraprocedurally single constant previous work finally enabled complete recovery technique interprocedural analysis recover general representations call arguments figure shows model precision level capture test programs data flow analysis support mimicry tack detection mimicry evasion attacks exploit ciency program model monitor accepts attack system call sequence valid tan wagner soto stress monitor system call arguments return values mimicry attack prevention rst hardening mimicry attacks implemented branch analysis extended argument capture general values passed interprocedurally figure shows argument capture improvement table shows results branch analysis average branching factor poorly suited measurement branch analysis number call sites affecting branching advisory results promising system call sites set branches return affects program control branch analysis identi system call sites program affecting branches procmail gzip eject fdformat cat table branch analysis results table lists total number system call sites pro gram data size subset system call sites return affects program branching system calls test programs constantvalued intraprocedural argument capture corresponds previous work capture recovers general arguments passed interprocedurally stronger analysis recovers arguments depending test program partial results providing early indication effectiveness mimicry attacks current work mimicry attack detection prevention based analyzing attacks language containment problem formally language system call sequences accepted monitor determine attack sequences study 
homework introduction information security due date march tuesday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free question ofb mode points questions output feedback mode ofb part prove encrypt decrypt stages ofb mode work correctly obtains plaintext decryption prove stage prove general i-th stage part explain quote book advantage ofb method bit errors transmission propagate question meet-in-the-middle attack points assume oscar pairs plain cipher texts explain meet-in-the-middle attack des context compute probability oscar succeeds finds correct key pair des question points problem stallings book question points suppose triple des performed choosing keys computing note order keys modified usual two-key version triple des show attack modified version meet-in-themiddle attack question block ciphers points part problem stallings book part problem stallings book question number theory basics part points group people arranging parade line row person left line row people left line row people left smallest number people smallest number hint interpret problem terms chinese remainder theorem crt part points divide remainder hint fermat theorem flt question des points extra credit find key desk des key called weak key weak keys find called weak menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
requires investigation component continuing research conclusions dyck model cient context-sensitive program representation experiments show contextsensitive models signi cantly improve strength intrusion detection system null call squelching dyck model operates ciency slightly worse imprecise context-insensitive nfa makes context-sensitive models usable lastly interprocedural argument capture branch analysis based system call return values limit attacker manipulation reducing opportunities successful attacks acknowledgements anonymous referees members wisa security group wisconsin valuable feedback suggestions ashcraft engler programmer-written compiler extensions catch security holes ieee symposium security privacy oakland california chomsky context-free grammars pushdown storage quarterly progress report pages massachusetts institute technology research laboratory electronics april chomsky schcurrency utzenberger algebraic theory context-free languages braffort hirschberg editors computer programming formal systems studies logic foundations mathematics pages north-holland publishing company amsterdam esparza hansel rossmanith schwoon efcient algorithms model checking pushdown systems conference computer aided veri cation cav lncs pages chicago illinois july springer-verlag feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland california ferrante ottenstein warren program dependence graph optimization acm transactions programming languages systems july forrest hofmeyr somayaji longstaff sense unix processes ieee symposium security privacy oakland california garvey lunt model-based intrusion detection national computer security conference ncsc baltimore maryland june ghosh schwartzbard schatz learning program behavior pro les intrusion detection usenix workshop intrusion detection network monitoring santa clara california april gif jha miller detecting manipulated remote call streams usenix security symposium san francisco california august ginsberg harrison bracketed context-free languages journal computer system sciences hofmeyr somayaji forrest intrusion detection system sequences system calls journal computer security ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march fink levitt automated detection vulnerabilities privileged programs execution monitoring annual computer security applications conference acsac orlando florida december kuck kuhn padua leasure wolfe dependence graphs compiler optimizations acm symposium principles programming languages popl pages williamsburg virginia january lane brodley temporal sequence learning data reduction anomaly detection acm transactions information system security august lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy oakland california lindqvist porras expert-bsm host-based intrusion detection solution sun solaris annual computer security applications conference acsac pages orleans louisiana december lunt automated audit trail analysis intrusion detection survey national computer security conference ncsc baltimore maryland october maheshwari traversal marker placement problems np-complete technical report cu-csdepart- ment computer science colorado boulder colorado ottenstein data-flow graphs intermediate program form dissertation purdue august schwoon model-checking pushdown systems dissertation technische universitcurrency mcurrency unchen june sekar bendre bollineni dhurjati fast automaton-based method detecting anomalous program behaviors ieee symposium security privacy oakland california sekar uppuluri synthesizing fast intrusion prevention detection systems high-level speci cations usenix security symposium washington august sekar venkatakrishnan basu bhatkar duvarney model-carrying code practical approach safe execution untrusted applications acm symposium operating system principles sosp bolton landing york october tan killourhy maxion undermining anomaly-based intrusion detection system common exploits recent advances intrusion detection raid lncs pages zurich switzerland october springer-verlag tan maxion ning operational limits stide anomaly based intrusion detector ieee symposium security privacy pages oakland california tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding lncs noordwijkerhout netherlands october springerverlag teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy oakland california von dyck gruppentheoretische studien mathematische annalen wagner static analysis computer security techniques software assurance dissertation california berkeley fall wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wagner soto mimicry attacks host based intrusion detection systems acm conference computer communications security ccs washington november warrander forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy oakland california wespi dacier debar intrusion detection variable-length audit trail patterns recent advances intrusion detection raid lncs pages toulouse france october springer-verlag vtpath attack vtpath model fails detect impossible path attacks based non-determinism dyck model detect due null call insertion code figure function security check veri current process root user access denies access function log writes activity log buffer overrun line attack works attacker root privilege enters log call buffer log set return address return line log return line execute privileged actions vtpath detect attack vtpath observes return addresses system call point return address modi line point non-determinism leading vtpath incorrectly call log originated line push-down automaton model similarly miss attack dyck model detects attack calls log instrumented preand postcalls point buffer overrun correct return address stored null calls call site aid attack detection reducing nondeterminism coding patterns arise note vtpath model detect attack learned behavioral database program dyck instrumentation previously inserted formal nitions proofs definition denote local nfa models ranges functions program entry point function set system calls set user functions called dyck model iqi iqi set states input alphabet stack alphabet transition relation unique entry state initial stack conguration set accepting states system call transition precall pushes stack entry state postcall pops stack models system call sequences generates application bracketed context-free language subsequences consisting symbols form dyck language lemma squelched dyck model postcall true system call postcall proof suppose postcall precall top application squelch stack construction squelching removes call stream lemma observed sequence calls true system call true system call null calls rst precall precall proof suppose rst postcall precall contradicting lemma theorem call graph program denote graph obtained strongly connected component collapsed single state maximum diameter generates true system calls execution worst-case number null calls generated proof lemmas observed call pattern repeating sequence string precalls system call string postcalls claim precall string postcall string length system call suppose precall string length exists directed path length occur suppose postcall string length exists directed reverse path length similarly occur number null calls generated system call data dependence graph data dependence graph ddg common program analysis structure representing interprocedural ows data program ddg subgraph void security check char file uid uid getuid uid log accessing file restricted access file log invalid access file exit security error void log char msg char file char buf sprintf buf msg file buffer write log buf strlen buf figure code vtpath attack passargs argspass register condition code passargs condition coderegister sethi 
file file call open mov mov mov bge mov mov sethi buf sethi root ble cmp mov call action add call writewrap call action mov action entry cmp mov jmp read buf writewrap entry root jmp write mov figure data dependence graph analysis constructs data dependence graph code figure shaded numbers correspond line numbers figure sparc code rightmost register instruction written register registers call arguments return call program dependence graph includes data dependence edges graph abstracts procedure basic block boundaries instruction node graph edges data owing instruction write data location instructions read exists def-clear path respect convenience edge label data location creating dependency ddg includes interprocedural data edges interprocedural edges data dependencies nition arguments entry point function arguments exit point function return definition set instructions program set function entry points data dependence graph def-clear path respect figure shows ddg constructed program code figure shaded node numbers correspond line numbers figure sparc delay slots unwound node precedes node graph ddg argument capture straightforward subgraph ddg rooted system call instruction reachable reverse edges dependent data location expression graph setting argument argument register read instruction node nodes expression graph simulating execution instructions identify buffer passed toread similarly expression graph argument register read includes nodes note represents interprocedural data simulated execution recovers values argument branch analysis argument capture system call return values requires slight change procedure discovery expression graph stops return system call expression graph argument register read instruction node reaches back node analysis recognizes open system call marks argument open return analysis branch node proceeds similarly expression graph reveals return open node compared node branch condition branch equal predicates added program model open branch-taken control path open fall-through path shown figure 
ps-adobecreator dvips copyright radical eye software title hwdvi pages pageorder ascend boundingbox documentfonts times-bold times-roman cmmi cmsy times-italic courier cmr cmmi cmsy cmr cmmi cmmi cmr cmsy documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips hw-o hwps dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def atan neg atan def atan parameter div dup pop div ifelse def control division net neg exch neg exch def change coordinate system negative pyth dup mul exch dup mul add sqrt def pythagoras epects parameter ptoc copy cos mul roll sin mul def polar cartesian ----------------hv added --------------pi def twopi def euler def radtodeg mul div def convert radian degrees degtorad mul div def viceversa ----------------hv pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def -------------dg begin patch --------------dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dashline dup def pathlength exch div pop def pathlength ifelse add add add def coef mul mul div round mul mul mul add exch div def coef mul def coef mul def coef mul def coef mul def mul ifelse setdash stroke def -------------dg end patch --------------dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill -----------patch ------------gsave abs hatchwidthinc abs hatchsepinc abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop itransform pathbbox div ceiling cvi div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add mul moveto rlineto stroke add hatchwidthinc clw add def hatchsepinc hatchwidthinc hatchsepinc add def clw hatchwidthinc add slw repeat grestore pop pop def gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray holds coordinates top stack showpoints boolean counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse 
homework introduction information security due date feb monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply warm-up homework attended lectures problems easy homework stallings book refers handbook refers linked handbook class homepage download free question points problem stallings book question points problem stallings book question points integers mod combination hill affine ciphers represent block plaintext pair mod ciphertext parenleftbigg parenrightbigg mod describe carry chosen plaintext attack system goal finding key state explicitly plain-texts choose recover keys question linearity points function takes input n-bit vector returns m-bit vector write formally type part define means linear part give linear non-linear function question lfsr-based stream cipher points part assume -stage lfsr shown figure starts initial state generate key stream length show steps part relationship i-th key previously generated keys lfsr relationship linear justify answer part alice bob communicating stream cipher key stream generated -stage lfsr oscar crack stream cipher remember oscar bad guy plaintext attack long plaintext ciphertext oscar justify answer part plaintext attack part depends linearity lfsr solution non-linear generator keys read alternating-step generator handbook page describe words answer question alternating-step generator linear stage stage stage stage figure -stage lfsr menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
symposium security privacy pages los alamitos california garvey lunt model-based intrusion detection national computer security conference ncsc baltimore maryland june ghosh schwartzbard schatz learning program behavior pro les intrusion detection usenix workshop intrusion detection network monitoring santa clara california april gif jha miller detecting manipulated remote call streams usenix security symposium san francisco california august gif jha miller cient context-sensitive intrusion detection annual network distributed systems security symposium ndss san diego california february hofmeyr somayaji forrest intrusion detection system sequences system calls journal computer security hopcroft motwani ullman introduction automata theory languages computation addisonwesley edition ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march fink levitt automated detection vulnerabilities privileged programs execution monitoring annual computer security applications conference acsac orlando florida december lane brodley temporal sequence learning data reduction anomaly detection acm transactions information system security august larus schnarr eel machine independent executable editing sigplan conference programming language design implementation pldi jolla california june lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy oakland california lunt automated audit trail analysis intrusion detection survey national computer security conference ncsc baltimore maryland october paxson bro system detecting network intruders real-time computer networks december ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks january http aciri vern ptacek-newsham-evasionps schwoon model-checking pushdown systems dissertation technische universitcurrency mcurrency unchen june sekar bendre bollineni dhurjati fast automaton-based method detecting anomalous program behaviors ieee symposium security privacy oakland california tan killourhy maxion undermining anomaly-based intrusion detection system common exploits recent advances intrusion detection raid lncs pages zurich switzerland october springer-verlag tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding lncs noordwijkerhout netherlands october springer-verlag teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy oakland california wagner static analysis computer security techniques software assurance dissertation california berkeley fall wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wagner soto mimicry attacks host-based intrusion detection systems acm conference computer communications security ccs november warrander forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy oakland california wespi dacier debar intrusion detection variable-length audit trail patterns recent advances intrusion detection raid lncs pages toulouse france october springer-verlag proof section theorem language accepted sdpda dcfl proof remove transitions sdpda recall sdpda stack activity -transitions states stack symbol exists -transition exive transitive closure notice computed polynomial time standard graph reachability algorithms transform transition relation remove transitions nontransitions transition remove state non-determinism due step assume sdpda -transitions remove state non-determinism standard subset construction determinizing nfa sdpda -transitions construct dpda subsets ned set recall condition nition sdpda stack activity completely determined input top stack nition ned easy dpda accepts language sdpda nition vpstatic model expand notation section syscall system call made target target target function call site computation model dpda simple program fragment shown figure running automaton shown figure set states program states note kinds states automaton function entry states entry action entry prepare function exit states exit action exit prepare system call states getuid read call site entry states call site exit states input alphabet input symbols dpda forms proof theorem slight modi cations system call call site states addr expose state addr means automaton consumes input symbol pops stack transitions state equivalent transition proof theorem symbols similarly explained proof theorem online detection monitor call stack program counter expose address information addr placeholder system call involved transition forms input symbols figure stack alphabet model faddr function call site stateg initial stack start symbol automaton stack dpda simulate program call stack start state entry state program entry function set accepting states require program exit set states exit system calls program killed anytime set states program program fragment start accept state set shown figure transition function automaton constructed interconnecting transformed control graph function states connected transition function call intra-function transition call inter-function transition intra-function transitions marked input symbols form deal automaton stack figure transition close addr close means current state read program issues system call close observe program counter addr close current state moved close inter-function transitions modify automaton stack exist call site entry state target function entry state target function exit state call site exit state call site entry state target function entry state add transition label addr means program calling function push address call site automaton stack figure transitions belong case call site exit state target function exit state add transition label addr addr means follow transition address call site program returning matches top symbol automaton stack pop address figure transitions belong case completes model nition formal models section proved pushdown automaton deterministic note recursive function call return transitions handled non-recursive nitions proofs section nition dyck model set system call sites traps operating system set function call sites denote target function call site note call sites unique nition local model control graph program vertex call site local model function unique cfg entry state cfg exit nition simply labels cfg edges section local models -reduced minimized reduce storage requirements nition global dyck model depends classi cation function call sites partition recurse generate system call returning recurse conditionally generate system call returning recurse generate system call returning recurse write denote nition dyck program model range functions entry point function symbols proof theorem dyck model exists -reduction properties nition require explanation property adds push pop symbols alphabet system calls property maintains system call transition property local automata system call modify stack state property adds -edges call sites generate system call properties link automata recursive call sites -edges edges update pda stack properties describe transitions precalls postcalls modify stack state stack-determinism dyck model theorem dyck model sdpda proof dyck model pda sdpda condition satis suppose proof contradiction cases property property property sdpda condition holds 
div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def arcadjust target length targetlength initial angle angle stack angle cos angle sin angle computes angle distance targetlength point cos sin note absolute angle added substracted angle contrary tvz code achieve iterates process start angle compute point distance targetlength semi-line angle aligned difference tvz code add defined add side move initialisation angle iteration input stack target length initial angle variables add targetlength angle angle cos mul def angle sin mul def angle distance targetlength point cos sin initialisation angle order approx tvz code targetlength mul angle sin mul dup mul angle cos mul dup mul add sqrt div initialisation angle large degrees set degrees ellipse curved point draw arrow degrees avoid wrong side degrees bad attractive point degrees dup pop angle exch maximum number times iterate iterative procedure iterative procedure takes angle top stack computes angle put top stack dup compute distance dup cos mul dup mul exch sin mul dup mul add sqrt equals targetlength stop dup targetlength abs pop exit stack compute point distance targetlength semi-line targetlength targetlength exch dup cos mul exch sin mul stack index div targetlength mul add div exch index div targetlength mul add div stack compute remove stack atan exch pop repeat don happened targetlength greater diameter ellipse final angle angle treat pathological case iteration stack angle tail arrow give back result angle relative angle add line angle exch def ellipticarcarrow add arrow procedure angle gsave newpath moveto clip set clippath arrow newpath draw arrow determine length grestore length arrow top stack numbers junk exch arcadjust angular position base arrow pop pop pop cos mul add sin mul add cos mul add sin mul add arrow tip coor base coor stack pop pop pop pop draw arrow discard coordinates clw div change test def add def ifelse arcadjust resets original def add def ifelse adjust angle give overlap def -----------------tvz end ------------------rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore 
start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc tex base encoding revision psencodingfile author rahtz mackay alan jeffrey horn berry schmidt lehman version date october filename enc tex-fonts tug docstring encoding vector type truetype fonts tex file part psnfss bundle version idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin windows ansi including euro symbol macroman extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting dotlessj ffi ffl hyphen appears compatibility ascii windows euro assigned windows ansi missing characters macroman encoding incorporated postscript macroman texbase --------------------------- -------------notequal infinity lessequal greaterequal partialdiff summation product integral omega radical approxequal delta lozenge texbase encoding notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef zcaron zcaron caron dotlessi dotlessj ffi ffl notequal infinity lessequal greaterequal partialdiff summation product grave quotesingle space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef euro integral quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft omega radical approxequal notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright delta lozenge ydieresis notdef exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset aae enc thomas esser dec public domain encoding cmmi cmmi cmmi cmmi cmmi cmmi cmmi cmmib texaae encoding gamma delta theta lambda sigma upsilon phi psi omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda rho sigma tau upsilon phi chi psi omega epsilon theta rho sigma phi arrowlefttophalf arrowleftbothalf arrowrighttophalf arrowrightbothalf arrowhookleft arrowhookright triangleright triangleleft zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle period comma slash greater star partialdiff flat natural sharp slurbelow slurabove lscript dotlessi dotlessj weierstrass vector tie psi notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space gamma delta theta lambda sigma upsilon phi psi notdef notdef omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda rho sigma tau upsilon phi chi psi tie notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset enc thomas esser dec public domain encoding cmb cmbx cmbx cmbx cmbx cmbx cmbx cmbx cmbxsl cmdunh cmr cmr cmr cmr cmr cmr cmr cmsl cmsl cmsl cmsl cmss cmss cmss cmss cmss cmssbx cmssdc cmssi cmssi cmssi cmssi cmssi cmssq cmssqi cmvtt texf encoding gamma delta theta lambda sigma upsilon phi psi omega ffi ffl dotlessi dotlessj grave acute caron breve macron ring cedilla germandbls oslash oslash suppress exclam quotedblright numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon exclamdown equal questiondown question bracketleft quotedblleft bracketright circumflex dotaccent quoteleft endash emdash hungarumlaut tilde dieresis suppress notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space gamma delta theta lambda sigma upsilon phi psi notdef notdef omega ffi ffl dotlessi dotlessj grave acute caron breve macron ring cedilla germandbls oslash oslash suppress dieresis notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef 
notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde dfbb dab ddd acb ccd cbfdf aff ecc ccad fcbe eddb fcb ccc add bcbc cdcb dda ebc efd aed accca fff ddde fbc aef efaa fcfb ccde daa cea bec ebe cefd ffdc eaff abbae cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd cdd dcdf bcdfad fce fcf ede fec dfa ccd ebe bef adffaa cdb cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa eced bafcfaad cae dcd cba afff ecee bfb ecbf cdc ccc efc cbed dddf bbc fef cdece fca aea baf dff ffa cbae dfb adc dda bccf cbaf cef acf adf bfc bda ccfe eba eac efe aab bff bda daa bef ffa fadd dbd bdff debe ebd bef bbc fdf eaa afeac dee caa effeb ffd aceb fba cfd adc afcdc fce bfd fde bdbbec faff ccabf cfd faba ddff bdbebbdfa def acea cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dbdc caa edc ddf aceda fec afb dcee faa ced ddb bcbb adf afd dec cbbb bdf facf ebe baf beec aefecf cbba bcb ebc eba cda bdabb fae cce bab dcca eeebb aba bacb dded fba ede ffb fbc bbd abb dbf deef cbddff ecda dfde dbf caee bcf beac dcd ffb dcc efeaa abde cbac cccd ffb bcc ebcfc ccd daca fcff faf ace ebd ddf ede fae dce cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa eced bafcfaad cae dcd cba daa ece ebad bfcf edea efbbf cdcbe ffeec afcd acd eea dcd dbde ffed bcd eeeec fee acc bed bfaad fad fff afe dccf eda fca bcf fad befe aef aea dac aab bdcf aaced bdc ecd eafe bbd befa bffd cdd dbd fdd fdeaa bbad eec caebbb cba cbdfc afee fbfe bdef bcf bbe caac dbb cfb dcca bef ecac debdb baff aef fefcc bebd bfb abae abbbf bbccd ceab dacc ece afc cbb feadf feb acb cedcefc edad bcff dbe adc bbca acad bbfe cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup 
project design document introduction information security due date april tuesday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade final code worth entire project grade putting lot emphasis design document length design document pages long remember design document basis implementation describing entities section describe entities system bank customer merchant assign short names identifiers bank customer merchant identifiers protocol description page chapter flow messages protocol show flow messages protocol make format messages flow depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system flow messages diagram presents view system follow kerberos overview page figure chapter design review team assigned mentor graduate student working security make mentor reviews document submit incorporate suggestions mentor menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa eced bafcfaad cae dcd cba dabb eecba abd bdc bbf dde cae cdfc ebb daa eaa ccc eed cdcf afabb bae eea ddb ecfef ddc fda ecf eab dbff bcc eabbb eecbc eaa edd aaf ddb bfc adada cbe ffdeb bcc ecaaf eecdf ccaa dbf cee cea fab abcf ebceb daa ecc bdd bff cafeb ffd ebe dfc ddec eaafc cddfccf aea ecc daaabedea ffab eab fcfd fec dea cfa aff cbb bcc baddbfd acce ecf ccc ccb aac cbdc eefbc efc ebe fdfb dfb ebfc ffe aff ecfde ddc bbdfd daadacbb cda fbd cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dbdc caa edc dcc fbe ccacab eed fbb eac faf cbc dcd ead afda afbf bdcc cfc cea bcd bdaa feb fbf cec dee cbb fcbe acde ffb fdc dcf abb dbe debd ffb cadc aaa bfe eef cce bbbf bfac ccb eece cde aac bedbc cde cea fcfe eeb cefb dfe eae fac bcf cdd afc ebda afd daab faf afa acb aba fdd fbe eab abb bfc acf becf ecd afb eee afa eaab ffd ead cdab effc cccbc edfe bdc bbe fcf bdba efe afb fbad eed ded bfcc bce cfc aec cafb acfddddae abeeef dcf fcf bbd bfa dcee cafd ece aab cea bcfb bfe cbbf abdeafb aff cdcecf dbc fabdd ecb bea afff cec faf dfe cea faad dcca cdcece eba eab febbb cfa fba ffbb fcec dbcdea efed cdce efe dbde ecb aeba cae fae cda eecce adcb ddc ffe ebfd cce faab abd abc bcc cac cdda faac dcec ffc ffa dee cbdfb fdf bddd aba eca acad adf cef dba cced dad fbde ddc bfef adfbede fcacf aad cdb dabba eadb fda afd fbee ccf bab dfb aca efbb cece dfa bcbb adc fec faf cfe acbe dce eac fbd ade fca abe ace aed decaa bee bccd bcf deff bae aea cefe ebf aba cadbb fbe ebb cleartomark endfont texdict begin hwdvi start texbase encoding reencodefont times-bold texbbad fencoding reencodefont cmsy texbbad fencoding reencodefont cmsy texf encoding reencodefont cmr texaae encoding reencodefont cmmi texf encoding reencodefont cmr texf encoding reencodefont cmr texaae encoding reencodefont cmmi texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold end endprolog beginsetup feature resolution dpi texdict begin end endsetup page texdict begin bop homew ork intr oduction inf ormation security due date mar uesday note talk classmates instructor problems stated problems written indi vidually uni ersity isconsin rules academic misconduct apply home ork stallings book refers handbook refers link handbook class homepage wnload free question ofb mode points follo wing questions output feedbac mode ofb art pro encrypt decrypt stages ofb mode ork correctly obtains plainte decryption pro rst stage pro general -th stage art explain follo wing quote book advanta ofb method bit err ansmission opa gate question meet-in-the-middle attack points assume oscar pairs plain cipher xts explain meet-in-the-middle attack des conte compute probability oscar succeeds nds correct pair des question points problem stallings book question points suppose riple des performed choosing computing note order modi usual o-k ersion riple des sho attack modi ersion meet-in-they middle attack question block ciphers points art problem stallings book art problem stallings book question number theory basics art points group people arranging themselv parade line person left line people left line people left smallest number people smallest number hint interpret problem terms chinese remainder theorem art points vide remainder hint fermat theorem question des points extra edit find eop end page texdict begin bop called weak man weak called weak refer ences menezes oorschot anstone handbook applied crypto aphy crc press illiam stallings crypto aphy network security principles actice prentice hall eop end trailer userdict end-hook end-hook eof 
cash digital cash project based protocol number schn nbsp pick handout basically protocol implements electronic cash system digital cash copied reused privacy customer identity guaranteed implementation system money transaction parties customer merchant bank electronic cash ecash transactions document amount transaction involved uniqueness string number identity strings identity customer information remains secret customer ecash illicitly bank signature customer ecash services provided party customer generates orders money order customer make assigns random uniqueness string number ecash money orders implements secret splitting bit commitment protocols generate identity strings describe customer address piece identifying information bank implements blind signature protocol money orders automatically complies reveal half identity string chosen merchant merchant verification legitimacy bank signature random generator selector string determines half identity string customer required reveal bank random choice money orders customer remain unopened algorithm certifies money orders filled valid information procedure certify orders received merchants previously storage uniqueness string identity strings orders database file measures reuse ecash excerpt schn describes anonymous digital cash protocol nbsp recommended read chapter discussion background protocol alice prepares anonymous money orders amount nbsp money orders random uniqueness string long make chance identical negligible nbsp money order pairs identity bit strings pairs check nbsp pairs generated alice creates string address piece identifying information bank nbsp splits pieces secret splitting protocol section nbsp commits piece bit commitment protocol alice blinds money order blind signature protocol nbsp bank bank asks alice unblind money orders random confirms formed nbsp bank checks amount uniqueness string asks alice reveal identity strings bank satisfied alice make attempts cheat signs remaining blinded money order nbsp bank hands blinded money order back alice deducts amount account alice unblinds money order spends merchant merchant verifies bank signature make money order legitimate merchant asks alice randomly reveal left half half identity string money order nbsp effect merchant alice random -bit selector string nbsp alice opens left half half depending alice complies merchant takes money order bank bank verifies signature checks database make money order uniquenes string previously deposited nbsp hasn bank credits amount merchant account nbsp bank records uniqueness string identity information database uniqueness string database bank refuses accept money order nbsp compares identity string money order stored database nbsp bank merchant copied money order nbsp bank person bought money order copied nbsp merchant accepted money order handed alice selector string merchant bank finds bit position merchant alice open left half merchant alice open hald nbsp bank xors halves reveal alice identity system implemented choice java nbsp microsoft net thinking nbsp consist independant programs communicate network xml based protocol nbsp programs simulates bank nbsp program simulates merchant nbsp remaining program simulates user interfaces user traditional gui program web server serving html pages nbsp communications secured ssl resources visit resources page schn applied cryptography bruce schneier john wiley sons new-york interesting article digital cash france http cnn tech ptech cash smart index html 
userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc tex base encoding revision psencodingfile author rahtz mackay alan jeffrey horn berry schmidt lehman version date october filename enc tex-fonts tug docstring encoding vector type truetype fonts tex file part psnfss bundle version idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin windows ansi including euro symbol macroman extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting dotlessj ffi ffl hyphen appears compatibility ascii windows euro assigned windows ansi missing characters macroman encoding incorporated postscript macroman texbase --------------------------- -------------notequal infinity lessequal greaterequal partialdiff summation product integral omega radical approxequal delta lozenge texbase encoding notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef zcaron zcaron caron dotlessi dotlessj ffi ffl notequal infinity lessequal greaterequal partialdiff summation product grave quotesingle space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef euro integral quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft omega radical approxequal notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright delta lozenge ydieresis notdef exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset aae enc thomas esser dec public domain encoding cmmi cmmi cmmi cmmi cmmi cmmi cmmi cmmib texaae encoding gamma delta theta lambda sigma upsilon phi psi omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda rho sigma tau upsilon phi chi psi omega epsilon theta rho sigma phi arrowlefttophalf arrowleftbothalf arrowrighttophalf arrowrightbothalf arrowhookleft arrowhookright triangleright triangleleft zerooldstyle oneoldstyle twooldstyle threeoldstyle fouroldstyle fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle nineoldstyle period comma slash greater star partialdiff flat natural sharp slurbelow slurabove lscript dotlessi dotlessj weierstrass vector tie psi notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space gamma delta theta lambda sigma upsilon phi psi notdef notdef omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda rho sigma tau upsilon phi chi psi tie notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset enc thomas esser dec public domain encoding cmb cmbx cmbx cmbx cmbx cmbx cmbx cmbx cmbxsl cmdunh cmr cmr cmr cmr cmr cmr cmr cmsl cmsl cmsl cmsl cmss cmss cmss cmss cmss cmssbx cmssdc cmssi cmssi cmssi cmssi cmssi cmssq cmssqi cmvtt texf encoding gamma delta theta lambda sigma upsilon phi psi omega ffi ffl dotlessi dotlessj grave acute caron breve macron ring cedilla germandbls oslash oslash suppress exclam quotedblright numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon exclamdown equal questiondown question bracketleft quotedblleft bracketright circumflex dotaccent quoteleft endash emdash 
voting virtual election booth project implements secure election protocol schn voting central facilities theoretical discussion found salo implementation provide secure people vote online eliminates hassle physically present designated election locations computerized voting replace general elections protocol maintains individual privacy prevents cheating ideal protocol meet requirements authorized voters vote vote determine voted duplicate votes voter make vote account final tabulation voted didn nbsp design central facilities central tabulating facility ctf central legitimization agency cla cla main function certify voters voter send message cla validation number cla return random validation number cla retains list validation numbers list validation numbers recipients prevent voter voting cla completes task sending list validation number ctf ctf main function count votes ctf checks validation number list received cla validation number ctf crosses prevent voting ctf adds identification number list people voted candidate adds tally votes received ctf publishes outcome protocol excerpt schn describes secure voting protocol nbsp recommended read chapter discussion background protocol central legitimization agency cla vertify voters seperate ctf count votes voter sends message cla validation number cla sends voter back random validation number nbsp cla maintains list validation numbers nbsp cla list validation number recipients case vote cla sends list validation numbers ctf voter chooses random identification number nbsp creates message number validation number received cla vote nbsp sends number ctf ctf checks validation number list received cla step nbsp validation number ctf crosses prevent voting nbsp ctf adds identification number list people voted candidate adds tally votes received ctf publishes outcome lists identification numbers owners voted system implemented choice java nbsp dot net thinking nbsp consist independant programs communicate network xml based protocol programs implement cla ctf nbsp user interface nbsp implemented traditional gui program web server serving html pages nbsp communications secured ssl resources visit resources page schn applied cryptography bruce schneier john wiley sons new-york salo public-key cryptography arto salomaa springer verlag new-york 
poker secure poker project implements poker internet accept players players spread deck player public private key play account house startup coordinated players session keys established house players session key encrypt players cards players sign bets house responsible totaling pot announcing bets players tracking players banks session keys destroyed players leaves current session rules poker found websites books nbsp site nbsp site links on-line casinos implementation house authenticates players nbsp player function create authorization information first-time player track cards player hand amount money player game player bet total amount pot informs player turn time receives plays user validates play legality player program user interface human player receives messages server presents info user collects users decision communicates back server manages player authentication keys session keys server signing bets plays behalf user system implemented choice java nbsp net thinking nbsp consist independant programs communicate network xml based protocol programs simulates house nbsp program user prgogram interfaces user traditional gui program web server serving html pages nbsp communications secured ssl resources visit resources page 
resources project resources standard libraries provide basic security functions start investigating nbsp users openssl library found http openssl widely toolkit providing encryption authentication key management ssl functionality nbsp java programmers jsse standard package java similar functionality nbsp sun jsse guide details basic understanding xml nbsp project protocol based xml messages nbsp project groups project work standardize protocol nbsp significantly increase testability projects turn increase quality nbsp house team poker project accept players team implementation nbsp variety xml parsers languages found http xml apache information xml support built java found student provided link net security information nbsp mind largely implementation choose net 
project notes maintainer-info background-color eeeeee color font-size smaller font-family sans-serif padding margin-top maintainer-info color background-color inherit text-align center table important border-bottom solid black padding-left padding-right project hand-in important dates friday alpha-version review project mentors wednesday project due friday -minute demonstrations turn items due wednesday wait week started readme file describes submitted file release notes include instructions building testing short writeup summarizing structure code features unfinished remaining bugs reason mentioned documented problems penalized undocumented problems final version design document make includes threat model section explains project secure kinds attacks man middle replay important xml dtds protocol commented code build files documentation program command-line syntax implemented gui web form based interface important gui intuitive test cases major feature test cases include support files required run test cases completion important turn-in procedure create tarball tar file zip archive files resulting archive -teamn tar -teamn zip team number refer earlier messages find team number resulting archive jake rosin address rosin wisc demonstration team schedule time slot demonstration sign form demonstration show working program action demonstrating major features prepared answer questions code design demonstration influence project grade significantly prepared copyright copy louis kruger mihai christodorescu jake rosin rights reserved modified jake rosin version maintained mihai christodorescu http wisc mihai created thu apr modified tue apr cdt 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic courier cmsy cmmi documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round 
notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true def end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy def end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true def normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage setpagedevice pop copypage def macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage setpagedevice pop copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dbdc caa edc ddf aceda fec afb dcee faa ced ddb bcbb adf afd dec cbbb bdf facf ebe baf beec aefecf cbba bcb ebc eba cda bdabb fae cce bab dcca eeebb aba bacb aeb eab cadb accbbe fbfb adb fca daaf ddc cbdbc ccbe dbb fde aaec eccbb dbd fadb fcc dea ffb ded fcf eaf cfe dbd eebe dfc cceb fdb ddd aed adaa afe bfd cbf fdd dcebd bee bbdde ece acb deb ced aded daa fadfdcf add eefc dad dda bcddb dbeb fcdbefdcc cfee bcef dbc edc cfb efe cleartomark endfont beginfont cmex ps-adobefontcmex creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmex readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmex def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup parenleftbigg put dup parenrightbigg put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa cac beb ffaf cacc bdda fdb abdfc ebca febc bed eacb eabe bab faac cae eaf efba acc cbc ddd aba 
tool catalog analysis software artifacts fall notes home detailed content notes assignments tools project messages lectures devoted overview dates lecture covered model checking basics document model checking basics interesting site specification patterns date lecture continued model checking basics examples ctl specifications covered ctl ltl duality equations discussed date note describing specification agfp lectures continued model checking covered fixed-points semantics ctl discussed binary decsion diagrams dates lectures devoted model checker smv dates document describing smv examples class semaphore smv vending-machine smv lecture devoted model checker spin discussed fundamentals class additional details refer paper model checker spin holzmann ieee transactions software engineering vol date lectures part lecture devoted verisoft discussed fundamentals class recommend reading papers verisoft site dates part part lecture lecture part lecture devoted model checking real time systems introduced real-time ctl discussed min max delay algorithms dates part lecture devoted nitpick relation language expressing software designs discussed model checking suitable proving properties data structures dates note nitpick pdf lectures devoted nitpick discussed relational languages object modeling setup alloy dates lecture finished nitpick started discussing alloy nitpick html run nitpick date lecture devoted alloy discussed abstract model file system download alloy run file-system date lecture discussed data flow analysis concepts data flow analysis white-box testing explored connections data flow analysis model checking date lecture discussed steps software process discussed types testing unit function system testing relate steps software process discussed testing terminology white-box black-box testing date lectures devoted coverage criteria white-box testing coverage criteria discussed statement decision condition multipl-condition coverage white-box testing based data flow analysis discussed great detail dates recommended paper selecting software test data data flow information rapps weyuker ieee transactions software engineering vol seno april lectures devoted markov chains random testing date recommended paper markov analysis software specifications whittaker poore acm transactions software engineering methodology vol january 
tool catalog analysis software artifacts fall assignments home detailed content notes assignments tools project messages homework due date oct wed homework pdf due date oct wed homework pdf smv basis code due date nov mon homework pdf due date nov wed 
cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc psencodingfile author rahtz mackay alan jeffrey horn berry version date july filename enc tex-fonts tug docstring encoding truetype type fonts tex idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends notdef notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch 
tool catalog analysis software artifacts fall tools home detailed content notes assignments tools project messages alloy specification automatic analysis object models developed mit alloy page bandera program analysis tool java programs developed kansas state bandera page cia program analysis tool programs developed bell labs cia page chava program analysis tool java programs developed bell labs chava page codesurfer commercial program analysis tool developed grammatech codesurfer page daikon automatically extracts invariants programs developed washington daikon page ladybug explicit state exploration tool relational calculus developed cmu ladybug page lclint developed mit virginia lclint page spin linear time model checker developed bell labs spin page smv symbolic branching time model checker developed cmu nusmv page verisoft automatic testing state enumeration tool programs developed bell labs verisoft page webciao analysis tool html code developed bell labs webciao page womble automatically extracts object models java byte code developed mit womble page formal methods homepage home page interesting links related formal methods links analysis tools found oxford formal methods page 
class project analysis software artifacts fall messages home detailed content notes assignments tools project messages suggestions projects read research papers sub-area related topics covered class present summary suggested papers apply tools covered class larger present case study explore tool cover class present experience report tools related links found oxford formal methods page general guidelines project report presentation 
tool catalog analysis software artifacts fall messages home detailed content notes assignments tools project messages important announcements area important announcements message archive message arhive class mailing list 
def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup star put readonly def fontbbox readonly def uniquexx def currentdict end currentfile eexec fba cdfdddf bfbbfcb fdc add fbd efe fceb dacfdcd bdd fcd dcfbae bef dad bcb ded aae aaca abd afbfded fcf bcbe fdb abf ebd ceb eba babe dfe bca cea ecd fbbbfb addc baa ccee ddb bed dbb aac feac bbc bff aededa abfa afc ace eae dde afaf ddfd eaf fadc bec bffc efc faa acdaca dda deec ccc ace cec cadef edb cea dbb bee bed dbeba dada fbbdd dff caa edafceafdc ebcbaa ede cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup similar put readonly def fontbbox readonly def uniquexx def currentdict end currentfile eexec bac ced ecf dcecec ccde cdf dcefcdbd baffaeb ffb fbefc bca ddd fcd aaec fce dae eba fcc dfff efec fef dffa bbf dbd edb fec ecc feb dabb bce afa ade edec acff efa fcc edc cleartomark endfont texdict begin course-document dvi start cmmi cmsy texbase encoding reencodefont courier texbase encoding reencodefont times-bold texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin papersize letter endsetup page bop document analysis softw artif acts somesh jha computer science department uni ersity isconsin madison jha wisc view softw engineering process eral phases requirements design prototyping implementation testing artif acts message sequence charts state machines code test plans produced phase process purpose pro vide analysis techniques analyzing arious artif acts produced process concentrate techniques formal automated schedule analysis state machines state machines modeling distrib uted concurrent systems statecharts malism part uml essentially state machines model hec king technique erifying properties state machines initially model checking erifying hardy designs recently researchers started estigating applications model checking softw refer ences model hec king clark grumber peled mit press model chec spin holzmann ieee ransactions softw engineering tse pages model chec king amming langua erisoft godefroid proceedings symposium principles programming languages popl pages aris january ools eop page bop lecture date day subject ervie ervie model checking basics model checking basics model checking basics model checking basics introduce smv introduce smv model check ers model check ers model checking real-time systems model checking real-time systems figure schedule analysis state machines smv model check uilt rst carne gie mellon uni ersity reengineered smv called nusmv eloped itc-irst website http sra itc tools nusmv spin widely distrib uted softw package supports formal eri cation disy trib uted systems softw eloped bell labs formal methods eriy cation group starting website http netlib bell-labs net lib spin ispin htm erisoft tool softw elopers testers concurrent reacti real-time systems website http bell-labs proje eriso schedule figure note class important usiness analysis abstract data structur adts ormalisms based state machines modeling concurrent distrib uted sysy tems formalisms ery suitable xpressing abstract data structures adts modeling abstract stack operations ormal languages based relations purpose formal language called nitpic short tool ladyb checking properties designs pressed xplored alloy relational language xpressing object oriented designs allo inspired uml xplore alloy constr aint analyzer tool erifying designs xpressed allo refer ences eop page bop lecture date day subject nitpick nitpick ladyb allo allo alcoa figure schedule analysis adts elements style analyzing softwar design eatur counter xample detector daniel jackson craig damon proceedings international symposium softw esting analysis isst san die january alloy lightweight object modeling notation daniel jackson july website http sdg lcs mit dnj public ation loy ools ladyb tool analyzing designs written website http cmu nitpick lad ybug html alloy object modelling notation compatible elopment approaches uml catalysis fusion omt syntrop simple ascii xtual notation subset xpressed graphically alloy constr aint analyzer tool analyzing allo models fers fully automatic animation generate states satisfy ariants ecutions operations countere xamples claimed properties model website http sdg lcs mit alloy schedule figure esting assumed nished requirements design phase start coding testing phase starts major forms testing blac box white box testing black box testing tester ignores internals program tester access code simply compares output program tested speci cation white box testing tester inspects code designs tests esting metrics measure test suite primarily white box testing testing metrics refer ences selecting softwar test data data information rapps yuk ieee ransactions softw engineering tse seh april pages eop page bop lecture date day subject data flo analysis data flo analysis esting metrics esting metrics mark chains mark chains usage based testing usage based testing figure schedule testing mark analysis softwar speci cations whittak poore ransacy tions softw engineering methodology osem january art softwar esting myers john ile sons ools schedule figure ogram understanding assumed program constructed scratch programs gac code xisting code project frequently understand gac code construct model process called ver engineering part concentrate tools program 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi 
div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc psencodingfile author rahtz mackay alan jeffrey horn berry version date july filename enc tex-fonts tug docstring encoding truetype type fonts tex idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends notdef notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch def 
privacy preserving clustering jha kruger mcdaniel computer sciences department wisconsin madison usa jha lpkruger wisc computer science engineering pennsylvania state park usa mcdaniel cse psu abstract freedom transparency information flow internet heightened concerns privacy set data items clustering algorithms group similar items clustering applications customerbehavior analysis targeted marketing forensics bioinformatics paper present design analysis privacy-preserving k-means clustering algorithm cluster means steps algorithm revealed participating parties crucial step privacy-preserving k-means privacy-preserving computation cluster means present protocols based oblivious polynomial evaluation based homomorphic encryption privacy-preserving computation cluster means java implementation algorithm implementation performed evaluation privacy-preserving clustering algorithm data sets evaluation demonstrates privacy-preserving clustering feasible homomorphic-encryption based algorithm finished clustering large data set approximately seconds introduction ease transparency information flow internet heightened concerns personal privacy web surfing services constantly leak information care accepted privacy lost exchange benefits digital services domains privacy important protection federally mandated technologies protecting privacy emerging response growing concerns recently emphasis preserving privacy user-data aggregations databases personal information access collections enormously balance privacy utility area privacy preserving data-mining emerged unsupervised learning deals designing classifiers set unlabeled samples common approach unsupervised learning cluster group unlabeled samples sets samples similar clusters constructed design classifiers cluster standard techniques decision-tree learning clusters identify features classification significant research privacy-preserving algorithms designing classifiers paper addresses problem privacy-preserving algorithms clustering assume alice bob unlabeled samples assume sample attributes data sets horizontally partitioned alice bob cluster joint data set revealing individual items data sets alice obtains clusters data set paper assume clustering joint data set results individually clustering large data set networking domain demonstrate clustering joint data set results significantly clusters individually clustering data sets end section details present privacy-preserving version k-means algorithm cluster means steps algorithm revealed alice bob applications clustering application clustering privacy concerns candidate privacy-preserving clustering algorithm suppose network traffic collected isps isps cluster joint network traffic revealing individual traffic data algorithm obtain joint clusters respecting privacy network traffic isps application clustering network intrusion detection presented marchette clustering forensics root-cause analysis alarms clustering bioinformatics dhillon clustering predict gene function privacy-preserving clustering bioinformatics data sets owned separate organizations reveal individual data sets paper makes contributions present design analysis privacy-preserving k-means clustering algorithm horizontally partitioned data section crucial step algorithm privacy-preserving cluster means present protocols privacy-preserving computation cluster means protocol based oblivious polynomial evaluation homomorphic encryption protocols detail section java implementation algorithm modular design implementation enable researchers implementation clustering tool request evaluated privacy-preserving clustering algorithms real data sets conclusion privacy-preserving clustering feasible large data set samples features speech recognition domain homomorphicencryption-based algorithm approximately seconds observed bandwidth efficiency execution overhead algorithms based homomorphic encryption performed based oblivious polynomial evaluation detailed discussion evaluation section related work privacy issues statistical databases investigated recently privacy-preserving data mining active area research initial focus area construction decision trees distributed data sets significant body research privacy-preserving mining association rules focus existing work privacy-preserving clustering general approaches designing privacy-preserving machine learning algorithms approach transformations perturb data set algorithm applied approach designing privacy-preserving clustering algorithms researchers approach designing privacy preserving algorithms algorithms secure-multiparty computation literature advantage approach perturbation approach formal guarantees privacy algorithms paper takes approach vaidya clifton work closest presented paper vaidya clifton present privacy-preserving k-means algorithm vertically-partitioned data sets pointed introduction paper considers clustering horizontally-partitioned data vaidya clifton algorithm based secure-permutation algorithm atallah vaidya clifton algorithm execute atallah protocol item data set algorithm practical large data sets vaidya clifton perform experimental evaluation algorithm contrast complexity algorithm depends number steps means algorithm dimension data items distributed clustering algorithms goal reduce communication costs distributed clustering algorithms privacy interesting investigate algorithms made privacy preserving implementation approximate real numbers intervals appendix finite-precision approximation functions leak information feigenbaum show approximations functions made private adding noise k-means clustering algorithm k-means algorithm shown figure assume samples sample m-dimensional vector real numbers number clusters algorithm maintains means initially assume means assigned arbitrary values sample deemed cluster closest cluster distance m-dimensional vectors bysummationtextmj j-th element vector distance metrics chapter scatter metrics distance metric mentioned iteration k-means algorithms recomputes means reclassifies samples algorithm terminates detects change means precise definition change depends specific metric assume initial cluster means chosen randomly research picking initial cluster means techniques picking initial cluster means easily incorporated algorithm issue discussed paper algorithm k-means clustering begin initialize classify samples nearest recompute change return end fig k-means clustering algorithm distributed k-means assume alice party samples xna bob party samples xna party jointly cluster samples revealing private information assuming clustering union samples parties desirable clustering samples individually assume trusted party ttp perform iterations locally iteration cluster means computed communicating ttp cai cbi cluster sends c-pairs ttp summationtextxj cai sum samples cluster cai number samples cluster cai analogously sends c-pairs ttp summationtextxj cbi ttp computes means sends dibi call algorithm distributed k-means dk-means assumptions goal design privacy-preserving k-means ttp present algorithm state assumptions made design privacypreserving algorithm number parties paper present party case adversary model assume semi-honest adversary called honest curious adversary model standard constructions transform protocol secure semi-honest model produce protocol secure general malicious model constructions called semi-honest malicious compilers details constructions found information disclosure privacy-preserving algorithm discloses cluster means steps parties computation classifying samples nearest cluster means performed locally complexity privacy-preserving algorithm depends number steps k-means algorithm number features size data desirable property data sets clustered large privacy-preserving k-means order create privacy-preserving version k-means ttp devise privacy-preserving protocol compute cluster means computation single cluster recall distributed k-means party sends ttp computes dibi precisely function devise privacy-preserving protocol problem formally defined definition weighted average problem wap defined party pair real number positive integer similarly party pair jointly compute words privacypreserving protocol functionality mapsto notation shown means party provide inputs protocol parties receive output notice wap classical problem computing averages parties number jointly compute average revealing individual numbers classical problem number parties parties wap number points secret pwap privacy-preserving protocol solving wap protocols wap presented section privacy-preserving k-means algorithm denoted ppk-means pwap trusted party ttp compute cluster means algorithm shown fig show part algorithm executing alice party side bob party execute similar algorithm side note suppose initial clusters picked randomly privacy-preserving algorithm protocol parties 
dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup bullet put readonly def fontbbox readonly def uniquexx def currentdict end currentfile eexec bac ced ecf dcecec ccde cdf dcefcdbd baffaeb ffb fbefc bca ddd fcd aaec fce dae eba fcc dfff efec fef dffa bbf dbd edb fec ecc feb dabb bdf fbde bfc ffe cdfddafc eed baaf cdfe dfa bff cba bdb faa bfd fed cleartomark endfont texdict begin course-document dvi start texbase encoding reencodefont courier texbase encoding reencodefont times-bold cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin papersize letter endsetup page bop document introduction information security somesh jha computer science department uni ersity isconsin madison jha wisc view shared resources internet created global information infrastructure hand shared resources creates risks due intentional unintentional malicious bey vior information security area deals protection detection malicious acti vity study fundamentals information security focus breadth student good idea acets information security syllab basic cryptographic primiti part focus cryptographic primiti follo wing topics great detail symmetric-k encryption str eam ciphers linear non-linear feedback shift gisters chapter block ciphers modes operations des chapter public-k encryption rsa elgamal public-k encryption chapter hash functions data integrity basic properties hash functions section unk hash functions mdc shag section eop page bop hash functions based block stream ciphers based mdcs section digital signatur classi cation digital signatures section digital signatures related rsa section digital signature algorithm dsa section otocols section focus protocols arious purposes protocols cryptographic primiti discussed rst part protocols discuss establishment otocols erberos dif e-hellman secret sharing chapter security secure sock ets layer ssl chapter secur payment otocols cybercash chapter digital money digicash section system security part focus system security common system vulnerabilities attacks focus tcp syn ooding denial-of-service attacks rele ant material pro vided lecture time list vulner abilities maintained cer coordination center web-page cert located softw engineering institute carne gie mellon uni ersity fir ewalls discuss architecture alls fire alls discussed books required class notes suf cient time permits discuss linux ipc hains great detail extensi documentation ipchains found follo wing website http netfilter filewatcher ipcha ins intrusion detection systems arious classes intrusion detection systems disy cussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort smartcards time remaining discuss architecture applications smartcar card technology vironment uilding smart card applications eop page bop grading criteria homew orks paper views short home orks assigned class handout reading assignments reading assignment short report written structure report pro vided resear paper esentation eport research paper detailed report paper required depending time constraints class short preseny tation paper required ulnerability analysis esentation eport students pick common sysy tem vulnerability analyze depth short presentation material class students students pick vulnerability consult kno database vulnerabilities cert oject signi project related security ideally students pick interested suggest projects detailed report presentation required project prefer projects implementation component refer ences chen ava car hnolo smart car hitectur ammer guide addison esle publishing compan cheswick bello vin walls internet security repelling ily hac addison-w esle publishing compan menezes oorschot anstone handbook applied crypto aphy crc press northcutt network intrusion detection analyst handbook riders publishhing sharif otocols secur electr onic commer crc press illiam stallings crypto aphy network security principles actice prentice hall zwick cooper chapman russell building internet walls reilly associates eop trailer end userdict end-hook end-hook eof 
jointly pick common random vector protocol called coin-tossing based commitment schemes section proof privacy section provide proof privacy protocol shown figure proof semi-honest adversary model notice distributed k-means algorithm dk-means parties input output definition privacy based intuition parties learn messages privacy-preserving protocol messages received party execution privacy-preserving protocol effectively computed knowing input output idea formalized algorithm ppk-means privacy-preserving k-means clustering begin initialize classify samples nearest step cai i-th cluster compute summationtextx cai cai recompute invoking protocol pwap change return end fig privacy-preserving k-means clustering algorithm definition inputs parties desired functionality party compute compute two-party protocol compute view party participated protocol denoted view random bits generated party sequence messages received party participating protocol view view party defined analogous manner privately computes exists probabilistic polynomial-time algorithms ppta denoted view view equation denotes statistically indistinguishable probability ensembles indexed statistically indistinguishable negligible function mapsto summationdisplay function mapsto called negligible positive polynomial sufficiently large weaker notion indistinguishability called computationally indistinguishable statistical indistinguishability paper results hold weaker notion indistinguishability detailed definitions concepts found privacy-preserving k-means algorithm privacy-preserving protocol pwap wap assume parties invoke protocol pwap oracle parties write respective inputs case invoke oracle returns result case recall distributed k-means algorithms parties learn cluster means steps oracle calls compute cluster means parties learn cluster means views cases identical conditions definition trivially satisfied additional messages exchanged protocol pwap compute cluster means ensure learned messages privacy protocol shown figure composition theorem stated algorithm shown figure protocol pwap solve wap section theorem composition theorem semi-honest model suppose privately reducible exists protocol privately computing exists protocol privately computing privacy-preserving protocol weighted average problem weighted average problem wap find privacy-preserving protocol functionality mapsto recall protocol wap privacy-preserving k-means algorithm figure simple strategy address problem approximate function circuit standard constructions construct privacypreserving protocol protocols constructed strategy high computational overhead malkhi considered cost implementing protocols work fairplay system found protocol feasible small circuits single -gate implemented milliseconds complex integer numerical functions implemented order seconds showed runtimes protocols grow quickly size input complexity implemented function complex function discussed authors computed median ten-element integer input sets function seconds execute lan environment seconds wan environment circuit computing significantly complex non-trivial data set single computation cluster means minutes compute note underlying costs fairplay artifacts design simply cost implementing standard protocols reported costs completely dominated circuit setup oblivious transfers section present privacy-preserving protocols wap efficient standard protocols protocol based oblivious polynomial evaluation homomorphic encryption similarity wap problem occurs protocols generation shared rsa keys discussed appendix protocol based oblivious polynomial evaluation give privacy-preserving protocol general problem end subsection demonstrate construct privacy-preserving protocol wap problem definition finite field party polynomials coefficients party points parties compute words privately compute functionality mapsto call problem private rational polynomial evaluation prpe protocol pprpe protocol oblivious polynomial evaluation defined definition finite field oblivious polynomial evaluation ope problem defined alice polynomial finite field bob element executing protocol implementing ope protocol solve ope naor pinkas pope denote privacy-preserving protocol ope provide protocolpprpe prpe pope oracle protocol shown figure step party picks random element computes polynomials words party blinds polynomials step party computes invoking protocol ope invokes protocol pope pope step party computes computing sends party fig protocol prpe theorem protocol pprpe shown figure privacy-preserving protocol prpe proof views parties viewpprpe viewpprpe view party consists input output prove definition identity function input output party show ppta viewpprpe statistically indistinguishable random element defined easy ensembles statistically indistinguishable reason random element random element ratio fourth elements view party output element view determine fourth element view recall pprpe protocol pope composition theorem conclude pprpe privacy preserving protocol wap show protocolpprpe prpe solve wap recall wap party party inputs invocation pprpe party constructs polynomials party sets output parties receive equal desired output proof privacy protocol theorem composition theorem protocol based homomorphic encryption encryption scheme function generate public parameters encryption decryption functions message space properties encryption scheme semantically secure essentially encryption scheme semantically secure adversary gains extra information inspecting ciphertext formally defined appendix definition implies encrypting message probabilistic encryption function yield ciphertext denotes set ciphertexts obtained encrypting computable function messages property holds successfully decrypt messages sets disjoint encryption scheme properties mentioned implementation dense probabilistic encryption dpe scheme benaloh semantic security scheme provided benaloh based intractability deciding prime residuosity party pair messages parties jointly compute privacy-preserving assume party sets probabilistic encryption scheme publishes public parameters assume probabilistic encryption scheme satisfies properties beginning section protocol wap shown figure step party encrypts sends encrypted values party step party computes random message encrypts obtain party computes messages sends party note implementation homomorphic-encryption scheme multiplication step properties probabilistic encryption scheme party compute compute party sends party fig protocol wap based homomorphic encryption theorem assume probabilistic encryption scheme properties mentioned beginning sub-section privacypreserving protocol compute proof theorem straightforward appendix basic intuition party difference encryption arbitrary messages complexity encryption decryption operations scheme depends size message space order complexity low important size message space small order achieve adequate precision message space large chinese remainder theorem crt perform computation smaller spaces reconstruct result larger message space small primes parties execute protocol zpm party receives modulo crt party reconstruct modulo producttextmi technique gilboa experimental evaluation section feasibility solution evaluating cost protocol real data-sets goal study establish cost privacy-preserving clustering algorithms real applications principally seek understand performance privacy tradeoffs inherent operation protocols evaluated clustering algorithms simple scheme baseline experiments protocol implements k-means clustering algorithm section algorithm privacy-preserving protocols represents nominal cost clustering present means clustering approach independent privacy implemented section features refer dimension vectors clustered iteration k-means algorithm referred round privacy-preserving protocol referred ope oblivious polynomial evaluation protocol detail section oblivious polynomial evaluation protocol presented naor pinkas privacy-preserving protocol referred dpe homomorphic encryption scheme benaloh protocol detail section implementation system consists approximately lines java code split number self-contained modules k-means algorithm module implements actual clustering computations section iteration module calls protocol module compute cluster means dimension cluster protocol module sets framework communication calls specific protocol handlers common interface depending protocol selected simple handler alice sends bob computes cluster sends alice ope dpe protocol handlers implement protocols sections central results uncovered investigation include clustering dpe orders 
tool catalog introduction information security spring notes home detailed content notes assignments links project messages list provide information class lectures 
tool catalog introduction information security spring assignments home detailed content notes assignments links project messages list homeworks reading assignments 
tool catalog introduction information security spring links home detailed content notes assignments links project messages snort open-source intrusion detection system snort page ipchains open-source firewall linux ipchains page freefire words freefire project founded summer bernd eckenfels beeing starting-point web seeking free security solutions main goal project support developers designers security experts usage free software freefire homepage smartcards information smart cards smart card homepage 
class project introduction information security spring messages home detailed content notes assignments links project messages project information 
tool catalog introduction information security spring messages home detailed content notes assignments links project messages important announcements area important announcements message archive message arhive class mailing list 
homework introduction information security due date april tuesday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply long homework points higher weight start early homework stallings book refers handbook refers linked handbook class homepage download free stated part question equal weight question hash algorithms points part points problem stalling book part points problem stalling book question specific hash algorithms points part points problem stallings book part points problem stallings book question authentication protocols points part problem stallings book part problem stallings book question dsa points part assume alice random number sign messages demonstrate oscar signatures derive private key part show knowing random number equivalent knowing random number oscar find vice-versa part problem stallings book question kerberos points question read explanation kerberos version appendix stallings book read note interrealm authentication kerberos version part problem stallings book part problem stallings book part suppose trust relationship realms biology department bob user realm access server biology realm show steps required bob authenticate question points part problem stallings book part cas arranged hierarchy shown figure show certificates navigate hierarchy demonstrate chain validates public key alice bob vice-versa engls ece alice bob figure hierarchy certificate authorities interrealm authentication kerberos version scenario assume user realm access server realm path realm conceptually edge represents trust relationship realm means shared key realms initial request requests ticket-granting ticket tgt kdc realm denote kdc realm forwardableflag set trust relationship issues tgt tgt realm forwardableflag set assuming mechanism realm discover path realm note assuming servers issue tickets policy kdc issues tgt forwardable flag policy implicit document walking path tgt tgt requests tgt realm ticket granting server tgs denoted tgs realm tgt issued tgs denoted tgt forwardable forwarded flags tgt address agent handling behalf user process repeated reaches realm tgt tgt issued tgs realm accessing tgt tgt presented tgs tgs obtain service-granting ticket sgs sgt server sgs access server general entity indexed realm pertains ticket-granting ticket tgt issued realm realm denoted tgt menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
understanding process understanding xisting code refer ences ciao aphical navigator softwar document repositories chen wler outso allach dynamically disco vering lik ely variants support evolution ernst cockrelly grisw notkin submitted ieee ransactions softw engineering tse ools cia customizable xtensible vigator allo users query analyze visualize track structures arious softw document repositories cia instantiy ated html ksh documents eral usiness repositories website http research att ciao daik named asian radish prototype implementation ariant detection front ends xist lisp daik research prototype rocky solid intended commercial website http sdg lcs mit mernst dai kon eop page bop lecture date day subject call graphs extracting ariants extracting ariants figure schedule testing lecture date day subject safety checking machine code deli lecture secure information flo secure information flo figure schedule code safety schedule figure code safety adv ent orld ide henceforth referred foreign untrusted code routinely ecuted computer code safety ery important issue part focus analyzing code ensure safety refer ences safety chec king mac hine code miller reps proceedings sigy plan conference programming language design implementation pldi june otecting privacy decentr alized label model myers lisk ransactions softw engineering methodology osem ools schedule figure closing esentations ote lectures closing comments rest lectures oted student presentations refer ences applicable ools applicable schedule figure note thanksgi ving break eop page bop lecture date day subject closing comments comments session figure schedule closing grading xams gular home orks class home orks account percent class students complete project class project guidelines class homepage project account percent class refer ences booch jacobson james rumbaugh jim rumbaugh uni modeling lany gua user guide addison-w esle object hnolo series addison-w esle october chan anderson beame burns modugno notkin reese model checking lar softw speci cations ieee ansactions softwar engineering july james corbett matthe dwyer john hatclif sha laubach corina asareanu robby hongjun zheng bandera extracting nite-state models source code oceedings international confer ence softwar engineering icse june harel politi modeling reactive systems ith statec harts statemate appr oac mcgra hill october eop trailer end userdict end-hook end-hook eof 
fcc bce cdde efde aaaa cdef ceccc efbc addd bac eeeecdff edf ade ead dce bed dad faeab afbeefbbecb effab ffa baa bcaff cffb abe daf bfc cda cbd bda cbc bfb aec aec fedfb fbdbeb ccb fbae bbb cfb ecab ebe edcff eceb dfbf feedb cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd ccf faca ecdc abd dae ebda ebf dfb aca cfc deee aba dbdec bcadd bcce dad cff ebd fcf aaccfb dcf dfa dcba dff fcde cfe bea aab dce cafc cda caaf afadd ece edb eea bfd ded cbda efe ece daa fcbcc ebe ebe acdcb bda cbb fda aad ebeae fff cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa eced bafcfaad cae dcd cba dabb eecba abd bdc bbf dde cae cdfc ebb daa eaa ccc eed cdcf afabb bae eea ddb ecfef ddc fda ecf eab dbff bcc eabbb eecbc eaa edd aaf ddb bfc adada cbe ffdeb bcc ecaaf eecdf ccaa cebd bcaca abf ffdbae afcba fdb aee adfc aaab dccdc ffbab ebeccf aebc dda eed faa aea eecb febe bbb ccc eba cdaf edaf cad cdcb fbed ebde beccd aeb aabe cbeb dfcca afca dea bbbd edf acf cbfaf daf caedcc baf aad efa debe ffa cefb aaba effc eeafdaa cca efbcf ecd bbcbfe bfd bdc ccb bef dacf fdd dcdb daa dbad ead fdd eff ada cbe ffc ade aaad cea abba ebe bfb eecc efb cfa bffd faa dbac bbea bdb baed eddc abe bbc bfac acd feda bee abeddd aee adf edac aadcc ecdc edf beb afe deb bbca dca cdd fbc edb fddf cab dddf cef bcb dbaaa ebc cdd bed fdff aaf bfcc fbc aebcd bffdc cafd aff eccc edebe acf cedcee bbe adaf edd fbb dfcdd dbf fedd aeadfc cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dbdc caa edc dcc fbe ccacab eed fbb eac faf cbc dcd ead afda afbf bdcc cfc cea bcd bdaa feb fbf cec dee cbb fcbe dcc dbd eac efaa cdd dce fff fca bef dbc aca efbd efe edc bda bcff adbf bbca deb cdd fdcfde bddaae fcc beef fee ddd faf bde cde dab babbb efc faf ded eef dfc cdcf eed aca bfa cec cea ecf ffdd efc fbf abf baec cfe baac ddc fbb aefa cee fefb fdf cfeaf cdadaf cbd eaa eafcfe cfb becc adb bab dfbc ede aeae dfcfc bdb cdeff dfe aafca dabaca fefa eedd dfbebcac fae ccbc cdb bdb ffaeb bec dacf daaada faac cfddccb def abffa ecf acd ffd dccf cfb eaa fddf fcf fedba fcb eadf dbf fbc dfdf fec edca cabec bccd ffbee ecd afa fcca adf bfa bfa cae cecb dfb aef ece efb aded dcf ecb bec ebe ebb cdcc febd fde fec beba fcc bcd bcd aeba eff cea fbfc befe fcbf fff edd cff ece ddc eca ffdb ffa aea ffc ffd feda bcd acdc cdfc aadbe cebd eec bba fdc aee dad efc bdc aec fbba dae aaacb bad ffa aab edaa dbba aae eee bfb edcce eeeb aeb eefb ffd bdeab abcffcda bacb fdce bbd beb eff ada abf ede ffba cdf beb beb bddfa ada bff bfdbc eef fbf fce accaebd bde aea aaf abb aea fdcb dce dab cbc eeef adecf ebea ffa dcd ebce eff eea bfdf efcaf ffb dfe cef ffaa acc aafe cfd ddab ebf cde eddb fba bbdae afa dbb cee dcb abdd bac daa aeb ded cfa dee abc bdd dbb baca fac ebac cfd fee ded cbcb efda fef cleartomark endfont texdict begin hwdvi start texbase encoding reencodefont times-bold texbase encoding reencodefont times-italic texaae encoding reencodefont cmmi cmex texbbad fencoding reencodefont cmsy texf encoding reencodefont cmr texaae encoding reencodefont cmmi texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold end endprolog beginsetup feature resolution dpi texdict begin end endsetup page texdict begin bop homew ork intr oduction inf ormation security due date monday note talk classmates instructor problems uny stated problems written indi vidually uni ersity isconsin rules academic misconduct apply arm-up home ork attended lectures problems ery easy home ork stallings book refers handbook refers link handbook class homepage wnload free question points problem stallings book question points problem stallings book question points inte gers mod follo wing combinay tion hill ciphers represent block plainte pair cipherte describe carry chosen plainte attack system goal nding state xplicitly plain-te xts choose reco question linearity points function tak input -bit ector returns -bit ector write formally type 
art means linear art xample linear non-linear function question lfsr-based str eam cipher points art assume -stage lfsr sho figure starts initial state generate stream length sho steps art relationship -th pre viously generated lfsr relationship linear justify answer art alice bob communicating stream cipher stream generated -stage lfsr oscar ants crack stream cipher remember oscar ays bad guy kno plainte attack long plainte cipherte oscar justify answer art kno plainte attack art depends linearity lfsr solution non-linear generator read alternating-step ener ator handbook page describe ords answer follo wing question alternating-step generator linear eop end page texdict begin bop beginspecial llx lly urx ury rwi setspecial begindocument lfsr eps ps-adobeepsf- title lfsr fig creator transfigd exe fig dev version patchlevel creationdate mon feb jha krishna wisc somesh jha boundingbox magnification endcomments psdict dict def psdict begin psdict mtrx matrix put colsetgray bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def end save newpath moveto lineto lineto lineto closepath clip newpath translate scale closepath bind def eofill bind def grestore bind def gsave bind def save bind def restore bind def lineto bind def moveto bind def rmoveto bind def newpath bind def stroke bind def show bind def slc setlinecap bind def slj setlinejoin bind def slw setlinewidth bind def srgb setrgbcolor bind def rot rotate bind def scale bind def setdash bind def findfont bind def setfont bind def scf scalefont bind def stringwidth bind def translate bind def tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind def shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind def drawellipse endangle exch def startangle exch def yrad exch def xrad exch def exch def exch def savematrix mtrx currentmatrix def xrad yrad startangle endangle arc closepath savematrix setmatrix def psbegin psdict begin psenteredstate save def def psend psenteredstate restore end def psbegin setmiterlimit fig objects follow slw ellipse drawellipse col shd col ellipse drawellipse col shd col ellipse drawellipse col shd col ellipse drawellipse col ellipse drawellipse col polyline col polyline col polyline col polyline col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col shd col arrowhead setgray col polyline clippath eoclip col arrowhead setgray col polyline clippath eoclip col arrowhead setgray col polyline clippath eoclip col arrowhead setgray col polyline clippath eoclip col arrowhead setgray col polyline col polyline col polyline col polyline col polyline clippath eoclip col arrowhead setgray col helvetica-boldoblique scf col helvetica-boldoblique scf col helvetica-boldoblique scf col helvetica-boldoblique scf col bookman-demiitalic scf stage col bookman-demiitalic scf stage col bookman-demiitalic scf stage col bookman-demiitalic scf stage col bookman-demiitalic scf col bookman-demiitalic scf col bookman-demiitalic scf col times-bolditalic scf col psend enddocument endspecial figure -stage lfsr refer ences menezes oorschot anstone handbook applied crypto aphy crc press illiam stallings crypto aphy network security principles actice prentice hall eop end trailer userdict end-hook end-hook eof 
tool catalog analysis software artifacts fall assignments home detailed content notes assignments tools project messages homework pdf due date monday sept homework pdf vending machine code found due date wed oct homework pdf due date wed oct homework pdf due date wed nov 
tool catalog analysis software artifacts fall tools home detailed content notes assignments tools project messages alloy specification automatic analysis object models developed mit alloy page bandera program analysis tool java programs developed kansas state bandera page cia program analysis tool programs developed bell labs cia page chava program analysis tool java programs developed bell labs chava page codesurfer commercial program analysis tool developed grammatech codesurfer page daikon automatically extracts invariants programs developed washington daikon page ladybug explicit state exploration tool relational calculus developed cmu ladybug page lclint developed mit virginia lclint page spin linear time model checker developed bell labs spin page smv symbolic branching time model checker developed cmu nusmv page verisoft automatic testing state enumeration tool programs developed bell labs verisoft page webciao analysis tool html code developed bell labs webciao page womble automatically extracts object models java byte code developed mit womble page formal methods homepage home page interesting links related formal methods links analysis tools found oxford formal methods page 
tool catalog analysis software artifacts fall messages home detailed content notes assignments tools project messages important announcements area important announcements message archive message arhive class mailing list 
class project analysis software artifacts fall messages home detailed content notes assignments tools project messages project guidelines project large component class divided groups group assigned mentor programming assignment details project document read document carefully project document directions preparing document found 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy cmr courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi 
magnitude bandwidth efficient ope executes times time largely due bandwidth computational costs oblivious transfers ope protocols clustering perfect fidelity clusters resulting algorithms identical reported k-means algorithm privacy reasonable parameter choices small medium large data-sets clustered efficiently costs scale linearly feature rounds number samples affects runtime increases number rounds convergence protocol parameters affect bandwidth usage constant factor exponential increases security supported message space result linear increases execution run-times begin section exploring real data-sets representative expected environments experimental data validity experimental approach partially dependent realism test data reason obtained collection externally provided datasets representing diverse applications experiments section synthetic river robot speech data-sets detailed selected elements synthetic data-set enable testing measure startup costs data set includes points uniformly distributed dimensional space design data clusters quickly natural clusters rounds k-means algorithm experiments originally computation intelligence learning coil competition river data-set describes measurements river chemical concentrations algae densities river data ascertain summer algae growth river water temperate climates clustered data inform relationship presence concentrations chemicals public waterways algae growth river samples features sample robot data-set continuous senor readings pioneermo- bile robot testing computer learning conceptual development approaches samples features sensor arrays pioneermobile robot samples reflect movements changing environment robot tested data clustered prior recognize experiences common outcomes speech data-set documents measured voice characteristics spoken japanese vowels male speakers uttered japanese vowels repeatedly sampled khz utterances resulted features samples large data-set context experiments evaluate degree proposed protocols scale size input data similar data-sets clustered frequently guide speech recognition software data-sets represents singular corpus contrast protocols targeted applications clustering parties model party case randomly subdividing samples equal sized subsets assigning party real environments size sets vastly approximation approach ensures kind asymmetry transparent parties execution performance performance algorithm largely independent number samples number features tremendous effect cost clustering data set called ping data-set collected purpose collecting data fold test clustering algorithm large data set construct data set naturally partitioned demonstrate jointly clustering data sets produce significantly results individually clustering setup hosts referred measure icmp ping round-trip times ping targets located world ping targets subnet host host ping target pings grouped blocks block -tuple consisting values generated average time live ttl average round-trip time rtt fraction lost packets drop collected data period hours generated data set consisting data points evenly divided host ran clustering algorithm joint data set data sets hosts experimental setup architecture code earlier experiments experiments executed pair ghz machines gigabyte physical memory experimental application running sun microsystems java virtual machine version tao linux version operating system protocols executed mbps unloaded lan measured round-trip time milliseconds experiments profile additional cost providing privacy clustering sensitive data end focus metrics cost utility communication overhead delay precision communication overhead records amount additional network bandwidth privacy schemes simple schemes delay measures additional time required complete clustering precision measure degree approximated clustering diverge reported simple k-means algorithm calculated sample data set clustered clustering simple algorithm clustering returned ope algorithm dpe metric defined similarly obvious manner pair error occurs cluster clusters cluster clusters total number errors denoted maximum number errors precision ope dpe unique parameters dictate performance security protocol performance dpe effected size primes select homomorphic encryption keys small primes cryptanalyzed large unnecessarily increase bandwidth computational costs rsa linear increases size primes result exponential security improvements interval arithmetic approximate real numbers appendix size message space dpe finite-field ope chosen achieve desired precision benaloh encryption scheme denotes size message space efficiency reasons choose details crucial parameters oblivious polynomial evaluation protocol naor pinkas degree masking polynomial total number points details algorithm found sender masking polynomial degree degree polynomial evaluated security parameter algorithm polynomial evaluated linear security parameter simply increasing strengthens sender security points needed interpolate receiver sends pairs values sender set pairs related point polynomial evaluated values random -outofm oblivious transfer protocol denoted otm repeated times learn required increasing strengthens receiver security selected brevity results battery tests broadly profile performance ope dpe shown table striking characteristic experiments demonstrate ope protocols consume orders magnitude network resources dpe protocols costs directly attributed oblivious transfer algorithms primitive cryptographic operations require transfer polynomials hosts total bandwidth costs scaled linearly ope dpe bandwidth costs feature round constant data sets observed variance scaled bandwidth usage ope dpe note bandwidth ultimately limited interest worst case experiment consumes megabytes bandwidth half minutes protocols visible impact slowest busiest networks chief feature illustrated timing measurements dpe time bandwidth efficient ope surprisingly dpe times faster data-sets selected parameters reasons underlying oblivious transfers incur large message exchanges parties experiments limiting factors bandwidth computation efficiency dpe respect ope shows fixed costs startup likewise dominated underlying privacy preservation operations bandwidth costs execution algorithm scale linearly number features rounds early implementations protocols limited latency caused individual round-trips protocol optimized parallelizing exchanges vastly improved protocol performance direct result bandwidth computation emerged limiting factors communications overhead delay test rounds bytes percent milliseconds percentbytes feature rnd increase milliseconds feature rnd increase synthetic samples features simple ope dpe river samples features simple ope dpe robot samples features simple ope dpe speech samples features simple ope dpe ping samples features simple ope dpe table experimental results resource precision results experiments data sets feature round statistics show costs feature clustering single round k-means algorithm single execution privacy preserving wap protocol feature round requires milliseconds ope dpe complete cost privacy-preservation large data-set clustering noticeable large data-set samples features takes dpe seconds cluster opposed seconds required simple k-means counterpart experiment dpe algorithm incurs slowdown factor expensive ope factor results applications bounds acceptable performance encouraging face past attempts circuit implementations vastly simpler operations averaging small collections data points tens seconds complete fairplay compared protocols wap simple strategy approximating function circuit standard constructions fairplay securely evaluate circuit fairplay support division implemented circuit division implementation division standard long division method expected privacy-preserving clustering algorithm fairplay slow experimental results confirmed intuition ping data set clustering fairplay milliseconds recall clustering dpe milliseconds parameters selected precision privacy-preserving algorithms dpe ope reasons two-fold parameter choices dpe resulted message space values allowed map cluster means decimal places data range small data-sets error roundindiv round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc psencodingfile author rahtz mackay alan jeffrey horn berry version date july filename enc tex-fonts tug docstring encoding truetype type fonts tex idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends notdef notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch def 
dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup bullet put readonly def fontbbox readonly def uniquexx def currentdict end currentfile eexec bac ced ecf dcecec ccde cdf dcefcdbd baffaeb ffb fbefc bca ddd fcd aaec fce dae eba fcc dfff efec fef dffa bbf dbd edb fec ecc feb dabb bdf fbde bfc ffe cdfddafc eed baaf cdfe dfa bff cba bdb faa bfd fed cleartomark endfont texdict begin course-document dvi start texbase encoding reencodefont courier texbase encoding reencodefont times-bold cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin papersize letter endsetup page bop document introduction information security somesh jha computer science department uni ersity isconsin madison jha wisc view shared resources internet created global information infrastructure hand shared resources creates risks due intentional unintentional malicious bey vior information security area deals protection detection malicious acti vity study fundamentals information security student good idea eral acets information security syllab basic cryptographic primiti part focus cryptographic primiti follo wing topics detail symmetric-k encryption str eam ciphers linear non-linear feedback shift gisters block ciphers modes operations des public-k encryption rsa elgamal public-k encryption hash functions data integrity basic properties hash functions unk hash functions mdc shay hash functions based block stream ciphers based mdcs eop page bop digital signatur classi cation digital signatures digital signatures related rsa digital signature algorithm dsa otocols section focus protocols arious purposes protocols cryptographic primiti discussed rst part protocols discuss establishment otocols erberos dif e-hellman secret sharing security secure sock ets layer ssl secur payment otocols cybercash digital money digicash system security part focus system security common system vulnerabilities attacks focus tcp syn ooding denial-of-service attacks rele ant material pro vided lecture time list vulner abilities maintained cer coordination center web-page cert located softw engineering institute carne gie mellon uni ersity fir ewalls discuss architecture alls fire alls discussed books required class notes suf cient time permits discuss linux ipc hains great detail extensi documentation ipchains found follo wing website http netfilter filewatcher ipcha ins intrusion detection systems arious classes intrusion detection systems disy cussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort smartcards time remaining discuss architecture applications smartcar card technology vironment uilding smart card applications eop page bop grading criteria finalized homew orks paper views short home orks assigned class handout reading assignments reading assignment short report written structure report pro vided exams xams mid-term nal xams equal weight ulnerability analysis esentation eport students pick common sysy tem vulnerability analyze depth short presentation material class students students pick vulnerability consult kno database vulnerabilities cert oject signi project related security ideally students pick interested suggest projects detailed report presentation required project prefer projects implementation component refer ences chen ava car hnolo smart car hitectur ammer guide addison esle publishing compan cheswick bello vin walls internet security repelling ily hac addison esle publishing compan menezes oorschot anstone handbook applied crypto aphy crc press northcutt network intrusion detection analyst handbook riders publishing zwick cooper chapman russell building internet walls reilly associates eop trailer end userdict end-hook end-hook eof 
hungarumlaut tilde dieresis suppress notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef space gamma delta theta lambda sigma upsilon phi psi notdef notdef omega ffi ffl dotlessi dotlessj grave acute caron breve macron ring cedilla germandbls oslash oslash suppress dieresis notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginprocset special pro texdict begin sdict dict sdict begin specialdefaults hsc vsc ang clip rwiseen false rhiseen false letter note legal scaleunit hscale scaleunit div hsc vscale scaleunit div vsc hsize clip vsize clip clip clip hoffset voffset angle ang rwi div rwi rwiseen true rhi div rhi rhiseen true llx llx lly lly urx urx ury ury magscale true def end macsetup userdict userdict type dicttype userdict begin length add maxlength dup length add dict copy def end begin letter note legal txpose mtx defaultmatrix dtransform atan newpath clippath mark transform itransform moveto transform itransform lineto roll transform roll transform roll transform itransform roll itransform roll itransform roll curveto closepath pathforall newpath counttomark array astore xdf pop put courier fnt invertflag paintblack txpose pxs pys scale ppr aload pop por noflips pop neg pop scale xflip yflip pop neg rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop neg pop rotate ppr ppr neg neg yflip xflip ppr neg ppr neg noflips pop pop rotate scale xflip yflip pop pop rotate scale ppr ppr neg neg ppr ppr neg neg xflip yflip pop pop rotate ppr ppr neg neg yflip xflip pop pop rotate ppr ppr neg neg ifelse scaleby ppr aload pop roll add div roll add div copy dup scale neg neg pop pop showpage restore end normalscale resolution div vresolution div neg scale magscale dvimag dup scale setgray psfts div starttexfig psf savedstate save userdict maxlength dict begin magscale true def normalscale currentpoint psf ury psfts psf urx psfts psf lly psfts psf llx psfts psf psfts psf psfts currentpoint psf psf psf psf psf urx psf llx div psf psf psf ury psf lly div psf psf scale psf psf div psf llx psf psf div psf ury showpage erasepage setpagedevice pop copypage def macsetup doclip psf llx psf lly psf urx psf ury currentpoint roll newpath copy roll moveto roll lineto lineto lineto closepath clip newpath moveto endtexfig end psf savedstate restore beginspecial sdict begin specialsave save gsave normalscale currentpoint specialdefaults count ocount dcount countdictstack setspecial clip newpath moveto rlineto rlineto neg rlineto closepath clip hsc vsc scale ang rotate rwiseen rwi urx llx div rhiseen rhi ury lly div dup ifelse scale llx neg lly neg rhiseen rhi ury lly div dup scale llx neg lly neg ifelse clip newpath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath clip showpage erasepage setpagedevice pop copypage newpath endspecial count ocount pop repeat countdictstack dcount end repeat grestore specialsave restore end defspecial sdict begin fedspecial end lineto rlineto rcurveto savex currentpoint savey setlinecap newpath stroke savex savey moveto fil fill savex savey moveto ellipse endangle startangle yrad xrad savematrix matrix currentmatrix xrad yrad scale startangle endangle arc savematrix setmatrix end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda fac cdf bca eca fdd dfd cdfdf daa dcd dab bdd bdc eef bcdc bdf facf cdd eedafc fce cad bcb eecccac cfc cfa eca cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa feca ffc ddea fadb bafdd dfdd ded faff dddfe becd ccbec dfb abedfd fdb aab fbb aab ecbf bfedb eace bdf aebd ecf dbf cbe bfd cbe aec bef bcc cbd cec adf dfdf dba fca dfecf dcd bcbb cade fcf cbf abb eda bba efb edfa ccb acf ccaed abe cdd bed bbc add cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi 
readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dbdc caa edc ddf ffa bbd fac bdce feb fbdc efeec edb dbf bcd fda ade dbfa cfd ecd bafc cfbd aee feb cef fbf abad eba bdb ead eae cba cea cca cef aebd eba bfc cfbb beed caefab facad ffdbb fbd edf ffb cbe addef eeb cdfa dfb fefb ada cce accea adf dbbb eeb dee cae baebf dbb aedc ccdb cfbea efe bec fedcbb eea dce cefd eec dad dfc bfc fcad bdb fcc cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dfc fed ade bed cfdb bfe fbdf ccd beaacf fef aeb fad dddefbd dff aeeb dbfd bafcd fafde bca ddafca bacd bde aab aab ecb bbbf acfb bffd bfff eca dacc bacfe fad abecbab adfad dab adbae fbbfd fed dcc dbf fab edec cfd dbd bfe fbb bff dceaafca ead bccb cfae dab dcfbe fddc ffb aabe bba aed cfa eaffa acd beadb bac ccabd aaff bdf aeac eaade febf bbc fba dbdfa fcaaa ffe bdca ffe dfd dfea fca abaeb dcb cfb ffb fcd dfb eafb deaad def eee bbb daf ebaf bbfbdaa bcb fddf beb aaf aac affa bacd cdf cleartomark endfont beginfont cmr ps-adobefontcmr creationdate feb copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa feca ffc ddea fac afeea eafe dfcd cbf bbb acbc bfea fed ccfb bcc aaf eca fda aabc fcf dbf baea cbfc ecc eeea ccd addaf aaac bdd abff bfc aef bff bbfadb dcf eae ecc adc fbbb afd faf dad eca fdfe bfc bcbf dca abef bef abb ffaed bfd cff cfbba bec bbe aaa cfc effe dcd acf ccd aeb cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd aaea cfd ead ccf edd dcb decc aec cda ecc dffe bdef cbd abf bdfbeef eeec aee fec aff bbc dba fabc fbb dbdecc aaae bdec fcef ceeb eff ace cbf cfd cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dbdc caa edc ddf aceda fec afb dcee faa ced ddb bcbb adf afd dec cbbb bdf facf ebe baf beec aefecf cbba bcb ebc eba cda bdabb fae cce bab dcca eeebb aba bacb dfae ecf eace afa cdc baa dfb eecd abfa eba bdaabdb fae eabd faf fff dbc cbcad eebda fccef cddd eede abf ebeeaecd fdb dbe ffd ddd efef dab fecfaea deb fca fdc feb fdf bcf eca dbda abeaeeedb fbd fbf ced ecc cfb afa faeee dde cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec adeb faab abc fee fbbb decba eba ddcf bdbf fbc faa eced bafcfaad cae dcd cba daa ece ebad bfcf edea efbbf cdcbe ffeec afcd acd eea dcd dbde ffed bcd eeeec fee acc bed bfaad fad fff afe dccf eda fca bcf fad befe aef aea dac aab bdcf aaced bdc afff dbe acda eab facf fbe bfc daaa aabe eea bdea ddc adc bdfebe aae dac acb cfcdbd ddecb dbf ccdcf cdce dab cda dee ebc bda ede bde dbd dddaff bad ecb efea afb dff cae dff baf bfd ffc cdecd bba ffb cleartomark endfont beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly 
assignments introduction information security spring assignments home detailed content notes assignments links project messages list homeworks reading assignments homework pdf due date feb thursday homework pdf due date feb wednesday homework pdf due date march monday homework pdf due date march tuesday homework pdf due date april friday note read note interrealm authentication kerberos version answer part question pdf homework pdf due date thursday 
links introduction information security spring links home detailed content notes assignments links project messages snort open-source intrusion detection system snort page ipchains open-source firewall linux ipchains page freefire words freefire project founded summer bernd eckenfels beeing starting-point web seeking free security solutions main goal project support developers designers security experts usage free software freefire homepage smartcards information smart cards smart card homepage 
class project introduction information security spring messages home detailed content notes assignments links project messages project information documentation project guidelines creating design document pdf documentation digital cash project documentation poker project documentation electronic voting project document general resources found documentation code handin procedure information sample code found 
important messages introduction information security spring messages home detailed content notes assignments links project messages important announcements area important announcements message archive message arhive class mailing list 
def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde dfbb dab ddd acb ccd cbfdf aff ecc ccad fcbe eddb fcb ccc add bcbc cdcb bef ceffc ceed ece fef abe dda cefbfc ddcc aaedeb ddde fdca bab decbce cdc cde deb aea dfda efd cleartomark endfont beginfont cmmi ps-adobefontcmmi creationdate jul copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmmi readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmmi def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ccbe eebde bad befda fdf fcde fbb cbfaec ddd bdc dfc dee baaa abf dfbfb def bfef beb dce eac bde acb faf dab eda eec bac acb baba cbdf fcaacf fba fbcbfc aef fed feff eff ddc bda ebf afc fdf cba bbda aeea fbbbb acc bdc fcafa dbd ecd cae eaf cbeb fef ecdd ffb fda dcaa ceee eedd cbe cdb dfc eef fbc ecee bbf bce eefbed dfed abbf aded add bebd eeb cbdaa abde ebb dfe ccd aeefebb cef dbacb bfcc fdc acf cfba bdf dcc def bfe bec edd bbaa dccb dbd bce beabe ffffde ccf feaaa cbf aea dee efb abd faa ebdaa fefe dec bac dacc adb cdd aeed aca bcc afea efd daa fcc bbc fad fcd afe ebe eaa fbb baa fda febd fea aca aabfa cdd eab aeb aac acece ded ecd cdee fef dbda aff ffff dea aac ccacc aaf dfb cffdce ffd bebb bef dedf bfd adcc bcdf bfc cce abcbadce bdae adaabfab bad faaab ccc eca afad dca eccd decce afa cade aee aeaba ecce cca dfe ebd adf cacdcbfa cdfce aec ead fdee dfdfab cbca dce aacddd cce ebbf cead dea efeeed aeb dbfdc ebd cce efdde eff abc bffe dbe cbfcc eebf dad cab eab baf ccbd bee ced ecfaf cdafd ddf abb aad dcb ddbe cff daf aea aabd bebb aca cfa bda dddb dbba efbe bff cca beeb cbc cfda cdf ccd cba aced bdd adb ffac ddff abe abc daf dfeebb bba eff cdf cbea eac eeca bed efef cbd bfe eedf bcd adfb bcaa abf eba dce dcd fdf ffd dced bba dbe edc ebf adc eba ffa cbd fad fab ebcf bda cleartomark endfont texdict begin hwdvi start texbbad fencoding reencodefont cmsy texf encoding reencodefont cmr texaae encoding reencodefont cmmi texaae encoding reencodefont cmmi texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman texf encoding reencodefont cmr texbbad fencoding reencodefont cmsy texaae encoding reencodefont cmmi texf encoding reencodefont cmr texbase encoding reencodefont times-bold texbase encoding reencodefont courier texbase encoding reencodefont times-italic texbbad fencoding reencodefont cmsy texaae encoding reencodefont cmmi texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold end endprolog beginsetup feature resolution dpi texdict begin end endsetup page texdict begin bop homew ork intr oduction inf ormation security due date pril uesday note talk classmates instructor problems stated othy erwise problems written indi vidually uni ersity isconsin rules academic misconduct apply long home ork points higher weight start early home ork stallings book refers handbook refers link handbook class homepage wnload free stated part question equal weight question hash algorithms points art points problem stalling book art points problem stalling book question speci hash algorithms points art points problem stallings book art points problem stallings book question uthentication otocols points art problem stallings book art problem stallings book question dsa points art assume alice random number sign messages demonstrate oscar kno signatures deri pri ate art sho kno wing random number equivalent kno wing random number oscar kno vice-v ersa art problem stallings book question erber points question read xplanation erberos ersion appendix stallings book moreo read note interrealm authentication erberos ersion art problem stallings book art problem stallings book art suppose trust relationship realms biology department bob user realm ants access serv biology realm sho arious steps required bob authenticate question points art problem stallings book art cas arranged hierarchy sho figure sho arious certi cates vigate hierarchy demonstrate chain alidates public alice bob vice-v ersa eop end page texdict begin bop beginspecial llx lly urx ury rwi setspecial begindocument ca-hier eps ps-adobeepsf- title ca-hier fig creator transfigd exe fig dev version patchlevel creationdate tue apr jha krishna wisc somesh jha boundingbox magnification endcomments psdict dict def psdict begin psdict mtrx matrix put colsetgray bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def col srgb bind def end save newpath moveto lineto lineto lineto closepath clip newpath translate scale closepath bind def eofill bind def grestore bind def gsave bind def save bind def restore bind def lineto bind def moveto bind def rmoveto bind def newpath bind def stroke bind def show bind def slc setlinecap bind def slj setlinejoin bind def slw setlinewidth bind def srgb setrgbcolor bind def rot rotate bind def scale bind def setdash bind def findfont bind def 
g caused interval arithmetic inconsequential note environments message space required smaller performance reasons 
range data values large precision errors introduced costs ope grow slightly increases experimented varied parameters equal non-synthetic data-sets total experiments cases increased cost nominal parameter sets slowed performance algorithm baseline experiment costs direct reflection costs underlying oblivious transfer shown bandwidth costs dpe scale constant factor proportional illustrated figure increases size product primes dpe modest affect performance protocols exponential increases result linear increases message size network limiting factor increases shown reflected linear slowdowns large intervals high precision clustering supported small increases bandwidth consumption ope bandwidth costs dpe scale constant factor experiments protocol exchange increases directly proportion size primes ping data set clustering algorithm generated clusters correspond target hosts centers clusters shown figure results clusters found algorithm joint data set significantly clusters found individual data sets milliseconds log river robot japanese fig dpe runtime costs message space milliseconds time cluster sample data-sets widths message spaces goal estimate rtt ttl drop target hosts networking applications routing clustering joint data set desirable cluster centers joint fig ttl rtt drop centers clusters conclusion presented privacy-preserving k-means algorithms implemented algorithm performed evaluations algorithms avenues research perform optimizations tool reduce execution bandwidth overheads explore privacy-preserving versions clustering algorithms interested hierarchical clustering algorithms acknowledgments dan boneh pointing connection weighted average problem generation shared rsa keys congress public law health insurance portability accountability act august adam wortmann security-control methods statistical databases comparative study acm computing surveys agrawal srikant privacy-preserving data mining proceedings acm sigmod conference management data pages dallas bardley fayyad refining initial points k-means clustering proceedings international conference machine learning icml pages benaloh dense probabilistic encryption workshop selected areas cryptography pages boneh franklin efficient generation shared rsa keys journal acm jacm canetti security composition multi-party cryptographic protocols journal cryptology lorrie cranor marc langheinrich massimo marchiori martin presler-marshall joseph reagle platform privacy preferences specification recommendation april lorrie faith cranor internet privacy communications acm denning security model statistical database problem acm transactions database systems tods dhillon marcotte roshan diametrical clustering identifying anticorrelated gene clusters bioinformatics dhillon modha data-clustering algorithm distributed memory multiprocessors proceedings large-scale parallel kdd systems workshop acm sigkdd august atallah privacy-preserving cooperative statistical analysis annual computer security applications conference acsac pages orleans louisiana usa december duda hart stork pattern classification john wiley sons evfimievski srikant agrawal gehrke privacy preserving mining association rules eighth acm sigkdd international conference knowledge discovery data mining pages edmonton alberta canada july feigenbaum ishai malkin nissim strauss wright secure multiparty computation approximations international colloquium automata languages programming icalp crete greece july niv gilboa party rsa key generation advances cryptology crypto santa barbara california usa august ian goldberg david wagner eric brewer privacy-enhancing technologies internet proc ieee spring compcon ieee computer society press february goldreich foundations cryptography volume basic tools cambridge press goldreich foundations cryptography volume basic applications cambridge press goldreich micali wigderson play mental game completeness theorem protocols honest majority symposium theory computer science pages goldreich micali wigderson proofs yield validity languages zero-knowledge proof systems journal acm goldreich petrank quantifying knowledge complexity computational complexity volume pages goldwasser micali probabilistic encryption journal computer systems science tao linux user group tao linux version http taolinux november information computer science pioneermobile robot data california irvine november http kdd ics uci databases pioneer pioneer html information computer science coil competition data uci kdd archive california irvine october http kdd ics uci databases coil coil html information computer science japanese vowels california irvine june http kdd ics uci databases japanesevowels japanesevowels html julisch clustering intrusion detection alarms support root analysis acm transactions information system security tissec november kargupta huang sivakumar johnson distributed clustering collective principal component analysis knowledge information systems november klusch lodi gianluca moro distributed clustering based sampling local density estimates proceedings eighteenth international joint conference artificial intelligence ijcai pages kudo toyama shimbo multidimensional curve classification passingthrough regions pattern recognition letters lindell pinkas privacy preserving data mining advances cryptology crypto pages august llyod squares quantization pcm ieee transactions information theory itdahlia malkhi noam nisan benny pinkas yaron sella fairplay secure two-party computation system proceedings usenix security symposium pages usenix september san diego marchette statistical method profiling network traffic workshop intrusion detection network monitoring pages merugu ghosh privacy-preserving distributed clustering generative models proceedings ieee international conference data mining icdm pages mitchell machine learning mcgraw-hill naccache stern public key cryptosystem based higher residues proceedings acm conference computer communications security ccs san francisco california naor pinkas oblivious transfer polynomial evaluation symposium theory computer science pages atlanta oliveira zaiane privacy preserving clustering data transformation xviii simp osio brasileiro bancos dados outubro sbbd pages paillier public-key cryptosystems based composite degree residuosity classes proceedings advances cryptology eurocrypt pouget dacier honeypot-based forensics proceedings auscert asia pacific information technology security conference auscert brisbane australia quinlan induction decision trees machine learning rind kohane szolovits safran chueh barnett maintaining confidentiality medical records shared internet world wide web annals internal medicine july rizvi harista maintaining data privacy association rule mining proceedings international conference large data bases vldb hong kong august sun microsystems sun java virutal machine version http java sun november humphrey taylor people privacy pragmatists concerned privacy trade benefits harris poll march joseph turow americans online privacy system broken technical report annenberg public policy center june vaidya clifton privacy preserving association rule mining vertically partitioned data eighth acm sigkdd international conference knowledge discovery data mining pages edmonton alberta canada july vaidya clifton privacy-preserving k-means clustering vertically partitioned data proceedings ninth acm sigkdd international conference knowledge discovery data mining pages yao generate exchange secrets ieee symposium foundations computer science pages definitions proofs definition assume message space sampled polynomial time exists probabilistic polynomial time algorithm takes input generates message function thought information message iff message substring bob games game adversary informed choose message sampling algorithm adversary asked guess game addition information game told encryption message adversary asked guess encryption function called semantically secure difference probabilities adversary succeeding games negligible probability computed message space proof theorem view parties shown viewph viewph message uniformly chosen define easy viewph statistically indistinguishable proof similar proof theorem section recall semantically secure party gain extra information encrypted values words randomly chosen messages adversary distinguish viewph negligible 
cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc psencodingfile author rahtz mackay alan jeffrey horn berry version date july filename enc tex-fonts tug docstring encoding truetype type fonts tex idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends notdef notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg metrics exch 
probability privacy party respect party generation shared rsa keys wap assume elements drawn finite field suppose party pair numbers privately compute words privately compute functionality mapsto problem crucial steps protocol sharing rsa keys psk protocol solving problem show psk design protocol pwap solving wap section description problem protocol pwap works party party generate random elements chosen uniformly parties invoke protocol psk inputs party obtains parties invoke protocol psk inputs party obtains parties obtain computing argue pwap privacy preserving views parties protocol view view random element defined fix pick uniformly random element distributed uniformly overf view statistically indistinguishable random element defined easy view statistically indistinguishable composition theorem privacy pwap approximating reals assume real numbers occur interval divide interval sub-intervals size i-th sub-interval bracketleftbigg parenrightbigg denote sub-interval real number lies real numbers lie sub-interval lies sub-interval rest sub-section approximate real numbers interval lie protocol party obtains random number simple arithmetic deduce lies interval quotient divided integers shown algorithms large space operations calculate exact wrap integers bounded size field greater equal 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi 
notes lectures introduction information security spring notes home detailed content notes assignments links project messages weekly summaries week week week week week week week week week week week week week week notes papers links 
def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup bullet put dup similar put readonly def fontbbox readonly def uniquexx def currentdict end currentfile eexec bac ced ecf dcecec ccde cdf dcefcdbd baffaeb ffb fbefc bca ddd fcd aaec fce dae eba fcc dfff efec fef dffa bbf dbd edb fec ecc feb dcc dafacb eef fce deee aad feb eae aeed ddaabdb cab dda aee acd add dcd adaad efb aec faea cce ffc bbea cceca abf cleartomark endfont beginfont cmr ps-adobefontcmr creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmr readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmr def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup put readonly def fontbbox readonly def uniquexx def currentdict end currentfile eexec bacdd abda cfc dfaeb aacdc cbbc aad fbfee fddf bef fbd ebed bbec ece bcf cac edad ebc dcce fedf bdd dbde dce acd cbeecc acb cdd dcb ccad aed baeb bad cadde dae eddec aadc cae cac aae bafc dffa dbc bcb cfea bcf cec ffee aeefefcf cbce cfbe cad eba efd ebf caa ddb efb daefb cbdb cba ecb dcf ccd aef fbfe efff dbfe aab faf ffd cleartomark endfont texdict begin course-document dvi start cmsy texbase encoding reencodefont courier texbase encoding reencodefont times-bold cmr cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin papersize letter endsetup page bop document analysis softw artif acts somesh jha computer sciences department uni ersity isconsin madison jha wisc view softw engineering process eral phases requirements design prototyping implementation testing artif acts message sequence charts state machines code test plans produced phase process purpose pro vide techniques analyzing arious artif acts produced softw process concentrate techniques formal automated ollowing books equir cour books mentioned document optional copies papers mentioned document handed class link printable ersion paper pro vided model hec king clark grumber peled mit press uni modeling langua user guide addison-w esle object hnolo sey ries booch jacobson james rumbaugh jim rumbaugh addisony esle october schedule analysis based state machines state machines modeling distrib uted concurrent systems statec harts formalism part uml bjrr essentially state machines model hec king technique erifying properties state machines initially model checking erifying hardw designs recently researchers started estigating applications model checking softw cab cdh dhj bmmr refer ences model hec king clark grumber peled mit press eop page bop model chec spin holzmann ieee ransactions softw engineering tse model chec king amming langua erisoft godefroid proceedings symposium principles programming languages popl pages aris january ool-supported abstr action inite-state eri cation matthe dwyer john hatclif roby joehanes sha laubach corina asareanu illem isser hongjun zheng proceedings international conference softw engineering icse utomatic edicate abstr action ams ball majumdar millstein rajamani pldi sigplan notices ools smv model check rst implemented carne gie mellon uni ersity reengineered smv called nusmv eloped itc-irst italy website http sra itc nus spin widely distrib uted softw package supports formal eri cation disy trib uted systems softw eloped bell labs formal methods eriy cation group starting website http netlib spi pin erisoft tool softw elopers testers concurrent reacti real-time systems website http bell eri goal bandera project inte grate xisting programming language processing techniques wly eloped techniques pro vide automated support xtraction safe compact nite-state models suitable eri cation source code ultimate goal fully-automated model xtraction broad class softw systems approach tak guidance softw analyst rey quired website http cis ant slam project microsoft research estigates relationships softw speci cations languages analysis model checking goal check softw satis critical beha vioral properties interf aces aid softy engineers designing interf aces softw ensure reliable correct functiony ing slam project fort softwar oductivity ools resear oup website http resea oso lam schedule figure eop page bop lecture date day subject ervie project ervie model checking basics model checking basics model checking basics model checking basics introduce smv introduce smv model check ers model check ers model check ers model check ers model checking real-time systems model checking real-time systems figure schedule analysis state machines analysis abstract data structur adts ormalisms based state machines modeling concurrent distrib uted sysy tems formalisms suitable xpressing abstract data structures adts modeling abstract stack operations ormal languages based relations purpose formal language called nitpic short tool ladyb checking properties designs xpressed xplored alloy relational language xpressing object oriented designs allo inspired uml xplore alloy constr aint analyzer tool erifying designs xpressed allo refer ences elements style analyzing softwar design eatur counter xample detector daniel jackson craig damon proceedings international symposium softw esting analysis isst san die january alloy lightweight object modeling notation daniel jackson july website http sdg lcs lic tml ools ladyb tool analyzing designs written website http lad alloy object modeling notation compatible elopment approaches uml catalysis fusion omt syntrop simple ascii xtual notation subset xpressed graphically alloy constr aint analyzer tool eop page bop lecture 
notes summaries analysis software artifacts fall notes home detailed content notes assignments tools project messages weekly summaries week week week week week week week week week week week week week week notes papers links note model checking note model checker nusmv slides patrice godefroid microsoft research slam project ballista homepage slides hierarchical gui testing found atif memon maryland making slides 
assignments introduction information security spring assignments home detailed content notes assignments links project messages list give homeworks reading assignments homework pdf due date feb friday homework pdf due date march homework pdf due date april 
notes lectures introduction information security spring notes home detailed content notes assignments links project messages list provide information class lectures 
links introduction information security spring links home detailed content notes assignments links project messages snort open-source intrusion detection system snort page ipchains open-source firewall linux ipchains page freefire words freefire project founded summer bernd eckenfels beeing starting-point web seeking free security solutions main goal project support developers designers security experts usage free software freefire homepage smartcards information smart cards smart card homepage 
important messages introduction information security spring messages home detailed content notes assignments links project messages important announcements area important announcements message archive message arhive class mailing list 
notes lectures introduction information security spring notes home detailed content notes assignments links project messages weekly summaries week week week week week week week week week week week week week week week week notes papers links class talked algorithms rsa diffie-hellman key exchange supposedly discovered links related topic link link link 
div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc psnfss encoding vector type truetype fonts tex file part psnfss bundle version authors rahtz mackay alan jeffrey horn berry schmidt idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida euro character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows euro assigned windows ansi texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends euro notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus 
class project introduction information security spring project home detailed content notes assignments links project messages project information documentation project guidelines creating design document pdf documentation digital cash project documentation poker project documentation electronic voting project document general resources found information important due dates code handin procedure project demos implementation notes sample code found 
assignments introduction information security spring assignments home detailed content notes assignments links project messages list give homeworks reading assignments homework pdf due date feb friday homework pdf due date march friday 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def -------------dg begin patch --------------dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dashline dup def pathlength exch div pop def pathlength ifelse add add add def coef mul mul div round mul mul mul add exch div def coef mul def coef mul def coef mul def coef mul def mul ifelse setdash stroke def -------------dg end patch --------------dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def 
class project introduction information security spring project home detailed content notes assignments links project messages project information documentation project guidelines creating design document found documentation digital cash project documentation poker project documentation electronic voting project document general resources found information important due dates code handin procedure project demos implementation notes sample code found 
links introduction information security spring links home detailed content notes assignments links project messages snort open-source intrusion detection system snort page ipchains open-source firewall linux ipchains page freefire words freefire project founded summer bernd eckenfels beeing starting-point web seeking free security solutions main goal project support developers designers security experts usage free software freefire homepage smartcards information smart cards smart card homepage 
important messages introduction information security spring messages home detailed content notes assignments links project messages important announcements area important announcements message archive message arhive class mailing list 
exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc tex base encoding revision psencodingfile author rahtz mackay alan jeffrey horn berry schmidt lehman version date october filename enc tex-fonts tug docstring encoding vector type truetype fonts tex file part psnfss bundle version idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin windows ansi including euro symbol macroman extra characters lucida character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting dotlessj ffi ffl hyphen appears compatibility ascii windows euro assigned windows ansi missing characters macroman encoding incorporated postscript macroman texbase --------------------------- -------------notequal infinity lessequal greaterequal partialdiff summation product integral omega radical approxequal delta lozenge texbase encoding notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef zcaron zcaron caron dotlessi dotlessj ffi ffl notequal infinity lessequal greaterequal partialdiff summation product grave quotesingle space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef euro integral quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft omega radical approxequal notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright delta lozenge ydieresis notdef exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla 
setfont bind def scf scalefont bind def stringwidth bind def translate bind def tnt dup dup currentrgbcolor roll dup exch roll mul add roll dup exch roll mul add roll dup exch roll mul add srgb bind def shd dup dup currentrgbcolor roll mul roll mul roll mul srgb bind def drawellipse endangle exch def startangle exch def yrad exch def xrad exch def exch def exch def savematrix mtrx currentmatrix def xrad yrad startangle endangle arc closepath savematrix setmatrix def psbegin psdict begin psenteredstate save def def psend psenteredstate restore end def psbegin setmiterlimit fig objects follow slw ellipse drawellipse col ellipse drawellipse col ellipse drawellipse col ellipse drawellipse col ellipse drawellipse col polyline col polyline col polyline col polyline col polyline col polyline col times-bolditalic scf eng col times-bolditalic scf col times-bolditalic scf col times-bolditalic scf col times-bolditalic scf ece col courier-boldoblique scf alice col courier-boldoblique scf bob col psend enddocument endspecial figure hierarchy certi cate authorities interr ealm uthentication erber ersion scenario assume user realm ants access serv realm path realm conceptually edge represents trust relationship realm means shared realms initial equest requests tic et-gr anting tic tgt kdc realm denote realm forwardable set trust relationship issues tgt realm forwardable set assuming mechanism realm disco path realm note assuming serv ers issue tick ets polic allo xample issues tgt forwardable polic allo implicit document alking path tgt requests tgt realm tic anting server tgs denoted realm tgt issued denoted forwardable forwarded ags dif ferent address agent handling behalf user process repeated reaches realm tgt issued realm accessing tgt presented tgs obtain service-gr anting tic sgs serv sgs access serv general entity inde realm pertains tick et-granting tick tgt issued realm realm denoted eop end page texdict begin bop refer ences menezes oorschot anstone handbook applied crypto aphy crc press illiam stallings crypto aphy network security principles actice prentice hall eop end trailer userdict end-hook end-hook eof 
survivability analysis networked systems somesh jha computer sciences department wisconsin madison jha wisc jeannette wing school computer science carnegie mellon pittsburgh wing cmu abstract survivability ability system continue operating presence abnormal events failures intrusions ensuring system survivability increased importance critical infrastructures heavily dependent computers paper present systematic method performing survivability analysis networked systems architect injects failure intrusion events system model visualizes effects injected events form scenario graphs method enables global analyses reliability latency cost-benefit analyses mathematical techniques domains combined systematic manner illustrate ideas abstract model united states payment system introduction motivation increasingly critical infrastructures heavily dependent computers examples infrastructures domains including medical power telecommunications finance automation society advantages efficient communication information sharing pervasive continuous computers exposes critical infrastructures wider variety higher likelihood accidental failures malicious attacks disruption services caused undesired events catastrophic effects including loss human life survivability ability system continue operating presence accidental failures malicious attacks term fault accidental failures disk crash malicious attacks denial-ofservice attack precise semantics continuous operation application dependent related critical services system check clearing critical service banking system survivable banking system continue providing service presence faults paper present method analyzing networked system survivability networked system conthis research sponsored part defense advanced research projects agency sists nodes links connecting nodes communication nodes occurs passing messages links event system user event user issues check internal event user account debited communication event sending message banks fault bank malicious attack service start event user issues check end event check clears start event end event correspond service issued service finished main goal provide information system architect design phase early planning stage software lifecycle information architect weigh pros cons decisions related survivability method present paper suitable post facto analysis existing systems method general support types analysis paper focus specific kinds questions question effect fault imagine architect designing power grid effect outage power plant located upstate york customers living hundreds miles western pennsylvania answer fault-effect analysis method architect visualize global effect local fault data structure call scenario graph method automatically generate scenario graphs model checking question reliability latency service reliability defined probability service issued finish latency measures expected time takes service finish suppose architect designing banking system find probability check issued clears answer reliability latency analysis find reliability banking system respect check clearing service query annotated scenario graph architect identifies set critical elements network nodes links failures severe effect provision service question assigns probabilities fault failure node link method automatically compute reliability latency network question cost constraints network nodes links upgraded maximize benefit reliability suppose architect allowed spend newly allocated funds upgrade fraction network links newer links faster reliable constraints imposed manager limited budget links choose upgrade maximize network reliability answer cost-benefit analysis perform costbenefit analysis extend annotated scenario graphs additional cost information related upgrading links automatically compute maximize benefit set cost constraints survivability analysis fundamentally analysis properties found areas algorithm analysis fault-tolerant distributed systems reliability analysis hardware systems security analysis computer systems survivability analysis handle broader range faults areas minimally handle accidental failures malicious attacks achieve goal method architect incorporate arbitrary type fault system model distinctions faults assigning weights probability occurring cost repair fault events dependent fault events contrast ease analysis work fault-tolerant literature makes independence assumption assume abnormal events independent make assumption analyzing systems survivability server crashes easier malicious intruder spoof crashed server chance intruder succeed spoofing server depends event server crashes attacker learns compromise disk replicated server easily compromise replicas chance bringing entire service depends likelihood success original attack method users express dependencies representing dependence events model phenomena correlated attacks local attacks succeed occur tandem succession severe effect system distributed denial-of-service attacks correlated attack cert advisory ca- representing dependence handle cascading effects fault triggers triggers cleaner design system avoid cascading effects strict locking protocol avoid cascading aborts transactional database practice impossible anticipate faults induced system environment violates assumptions made system original designer survivability concern building systems systems system architects face possibility cascading effects analysis survivability analysis service dependent architect banking system choose focus check clearing service critical banking system services accounting auditing cash distribution analysis cash distribution critical service focus taking consideration specific service system provide enables targeted analysis amenable fully automated support method focuses architect attention specific services general system design appreciated understood end customer cares reliability applications services analyses method driven properties architect specifies relate critical service finally survivability analysis deals multiple dimensions simultaneously deals functional correctness modeling service fault-tolerance modeling effects accidental failures security modeling effects malicious attacks reliability likelihood service finishing performance network latency cost achieve goal analytical approach paper combines kind analysis techniques framework section introduces constrained markov decision processes form basis reliability latency cost-benefit analysis general overview method appears section describe small based united states payment system section running remainder paper section additional details related step method section briefly describes prototype tool trishul implemented based method briefly describes case studies performed sections discuss related work conclusions model computation formal model based constrained markov decision processes simply cmdps cmpds generalization markov chains transition probabilities depend past history cmdps enable model history dependent transition probabilities provide framework perform cost-benefit analysis exposition cmdps based altman cmdp -tuple finite state space finite set actions state set actions state transition probabilities psas probability moving state action chosen cost denotes cost choosing action state cost related function minimized k-dimensional vector costs related cost constraints markov decision process mdp cmdp component history time denoted sequence states encountered actions time policy takes account history determines action time specifically ajht probability taking action history policy defines function expected cost actions cmpd policy starts state cost define expected cost technical definition found analogously starting state expected costs policy denoted result k-dimensional vector k-dimensional vector real numbers assume k-dimensional vector cost constraint i-th component aim find policy minimizes function constraint imposed vector initial state find policy minimizes subject remark confuse markov process markov policy policy probability action depends current state cmdp entire history imagine bakery customers waiting time time bakery manager option servers counter state cmdp corresponds number servers counter number customers waiting action state decide servers counter figure show transitions transition state action 
egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd becd aad affbf dcc abc bff eaeee bed fbffc cdbf cdeb def cleartomark endfont texdict begin course-document dvi start texbase encoding reencodefont courier texbase encoding reencodefont times-bold texbbad fencoding reencodefont cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin end endsetup page texdict begin bop document introduction information security somesh jha computer sciences department uni ersity isconsin madison jha wisc view shared resources internet created global-information infrastructure hand shared resources create risks due intentional unintentional malicious beha ior information security area deals protection detection malicious acti vity study fundamentals information security student good understanding eral acets information security syllab basic cryptographic primiti part focus cryptographic primiti follo wing topics detail symmetric-k encryption str eam ciphers linear non-linear feedback shift gisters block ciphers des modes operations public-k encryption rsa elgamal public-k encryption hash functions data integrity basic properties hash functions unk hash functions mdc shay eop end page texdict begin bop hash functions based block stream ciphers based mdcs digital signatur classi cation digital signatures digital signatures related rsa digital signature algorithm dsa otocols section focus protocols arious purposes protocols cryptographic primiti discussed rst part protocols discuss establishment otocols erberos dif e-hellman secret sharing security secure sock ets layer ssl secur payment otocols cybercash digital money digicash system security part focus system security common system vulnerabilities attacks focus tcp syn ooding denial-of-service attacks rele ant material pro vided lecture time list vulner abilities maintained cer coordination center web-page cert located softw engineering institute carne gie mellon uni ersity fir ewalls discuss architecture alls fire alls discussed books required class notes suf cient intrusion detection systems arious types intrusion detection systems discussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort special opics time remaining discuss adv anced topics elliptic-curve crypto aphy ecc smartcar eop end page texdict begin bop book required class belo stallings crypto aphy network security principles actice prentice hall ourth edition hand xtra articles reading material class progresses grading criteria finalized homew orks short home orks assigned class exams xams mid-term nal xams equal weight oject signi project related security students pick projects pro vide refer ences cheswick bello vin rubin walls internet security repelling ily hac addison esle publishing compan northcutt network intrusion detection analyst handbook riders publishing zwick cooper chapman russell building internet walls reilly associates eop end trailer userdict end-hook end-hook eof 
label transition manager decided switch servers counter probability waiting customer leaves order number servers number waiting customers figure bakery depending servers counter notice probability customer serviced higher servers counter transition state probability rest transitions similar explanation state action probability customer serviced time period determines cost function cost state action pair action chosen state expected number customers serviced time step notice negative cost determines throughput expected number customers serviced time period number servers counter determines cost function servers cost aim manager maximize expected throughput minimize expected cost related constraint wages servers achieving goal easily problem maximization cost constraints naturally fits cmdp framework optimal policy cmdp bakery manager change number servers counter general method section provide overview method section details techniques implementation steps model network inject faults model survivability-related properties steps analyze effects faults perform reliability latency analysis cost-benefit analysis parallel answering kinds questions posed introduction step model network architect models networked system formalisms choose state machines model network nodes links shared variables represent communication state machines step inject faults links nodes faulty state machine model networked system make distinction nodes links faults link simply node passes data nodes injecting fault requires representing fault occurred determining behavior faulty node kind fault occur exact behavior faulty node architect depends application represent faults method state machine representing node introduce special variable called fault range user-specified set symbolic values declaration states modes operation node representing normal mode operation failed compromised intruder fault normal failed intruded simple representation choose precise behavior node mode operation state machine makes transition normal mode operation abnormal modes failed intruded state machine transition occurs option leaving state transitions completely nondeterministic step survivability properties architect specifies properties related survivability kind formal logic method temporal logic called computation tree logic ctl temporal logics linear time logic paper focus classes survivability properties fault service related class captures properties networked system scrutiny enters faulty state class captures properties specific system services step generate scenario graphs state machine model networked system injected faults survivability property generate scenario graph concise representation set traces respect fault properties fault scenario graph represents system traces end faulty state service properties service success fail scenario graph represents system traces issued service successfully finishes fails finish architect scenario graphs visualize effects injected faults service operational security literature scenario graphs similar attack state graphs step reliability latency analysis scenario graph perform analyses reliability latency analysis architect specifies probabilities events interest faults system assume independence events formalism based bayesian networks conditional probabilities events combine probabilities scenario graph obtain mdp readily compute reliability latency solving optimal policies relevant cost functions reliability analysis cost function identically latency analysis function times making state transitions advantage method architect probabilities events mdp probabilistic nondeterministic transitions step cost-benefit analysis step transform mdp step cmdp enhance mdp set actions actions decisions architect make additional actions correspond upgrading links produce reliable faster system architect decide links upgrade added action cost architect simultaneously minimize cost maximize benefit reliability associate costs actions provide constraints costs function definition cmdps optimal policy cmdp constructed architect optimal decision cost constraints simplified model united states payment system depicted figure levels institutions federal reserve banks top money centers middle small banks bottom banks connected money center transactions handled money center federal reserve banks detailed description system illustrate architecture suppose customer writes check customer check source address bank-a destination address bank-c steps occur issued check clear bank-a bank-c connected money center check money center connected bank-a case choose money center mcthe check transferred federal reserve bank closest mcin case frbthe check transferred federal reserve bank jurisdiction bank-c case frbthe check finally makes bank-c money center mcin figure path check shown dot-dashed lines detailed description present details step method detail illustrating check clearing step model network model node link system finite state machine entire networked system composition machines implementation model checker nusmv nusmv input language describe state machines representing system off-the-shelf model checker makes convenient steps method perform global analyses nusmv output lets automatically derive information reconstruct banking state machines model banks money centers federal reserve banks links element banking infrastructure banks mcmc- frbfrb- frbmc- path check bank-a bank-b bank-c link-alink-a- link-blink-b- link-ccenters money federal reserve banks figure united states payment system corresponds module description nusmv communication achieved parameter passing make simplifying assumptions model system user issues checks source destination address checks decided nondeterministically source address banks similarly destination check active time exact amount check irrelevant step inject faults inject faults model including special state variable fault state machine mode operation modify specification state machine consideration faulty modes operation banking faults inject handle model based assumptions network elements faulty links banks money centers small banks representing penetration malicious intruder occurred fault intruded links institutions faulty banks fail accidentally link faulty blocks messages message reaches recipient links faulty time finite state machine model link nondeterministic transition state fault equal failed intruded variable fault case banks sense faulty link route checks assumptions show consideration semantics application implicitly assuming federal reserve banks impenetrable links highly reliable secure model reflects behavior normal mode operation bank receives check nondeterministically issued user source address depending destination address issued check bank clears locally routes money center check source address destination address issued money center mcand bank hand check source address destination address clear federal reserve banks figure bank faulty checks routed arbitrarily intruder ignoring check destination address bank time nondeterministically transition normal mode fault normal intruded mode fault intruded bank faulty stays state forever precise behavior faulty node depends application types behaviors failure conditions common case stuck-at fault node stuck accepts input channel produces output node byzantine fault exhibits completely nondeterministic behavior accepts inputs produces arbitrary outputs byzantine fault model intruded node step survivability properties step survivability properties ctl logic chosen convenience model checker accepts ctl specifications ctl rich logic express variety properties focus classes survivability properties fault service related fault related properties suppose express property node reach unsafe state network starts initial states precise semantics unsafe state depends application atomic proposition unsafe represent property node unsafe state express desired property ctl unsafe states reachable set initial states 
true reach state unsafe true negation property unsafe true exists state reachable initial state unsafe true words network starts initial states reach unsafe state atomic proposition unsafe stand property complex desire critical node entered undesirable state critical valve open nuclear power plant unauthorized operation occurred critical node node represents computer protecting critical resource represent fact authority logged computer precise nature faulty state depends hand service related properties networked systems built distributed applications cases make node issues service service eventually finishes executing atomic proposition start express service started nished express transaction finished temporal logic formula expresses states service starts paths starting state exists state service finishes words service issued eventually finishes start nished banking verify check issued eventually cleared expressed ctl checkissued checkcleared analyze effect compromised node suppose modeled effect malicious attack node discussion injecting faults check desired properties true modified networked system property turns true network resistant malicious attack node type analysis determining vulnerable critical nodes network respect service analysis node found vulnerable critical service complete system administrator deploy sophisticated intrusion detection algorithms node bolster security infrastructure analysis identify critical nodes networked system determine survivable respect desired properties service step generate scenario graphs automatically construct scenario graphs model checking property true model model checker produce counterexample trace scenario leads final state satisfy property details model checking needed understand method exploit functionality model checkers generate scenario graphs scenario graph compact representation traces counterexamples property suppose check execution networked system event buffer overflow property true buffer overflow happen scenario graph encapsulates sequences states transitions lead system state buffer overflow occurs scenario graphs depict ways network enter unsafe state ways service fail finish scenario graphs encapsulate effect local faults global behavior network architect models malicious attacks scenario graph compact representation threat scenarios network set sequences intruder actions lead network unsafe state fault scenario graphs recall express property absence unsafe reachable state unsafe formula true means states reachable initial state faulty briefly describe construction scenario graph assume verify model checking specification network satisfies unsafe step model checking determine set states reachable initial state determined set reachable states algorithm determines set reachable states sunsafe path unsafe state set states sunsafe computed fix-point equations transition relation network iff transition state network identifying fragment ctl counterexamples formulas fragment form finite graph trivial problem fortunately types formulas property restricting domain range sunsafe obtain transition relation encapsulates edges scenario graph scenario graph sunsafe sunsafe represent nodes edges graph symbolic model checkers nusmv transition relation sets states represented binary decision diagrams bdds compact representation boolean functions operations easily performed bdds bdd transition relation succinct representation edges fault scenario graph bdds capable representing large number nodes large scenario graphs computed method service success fail scenario graphs case services interested verifying service started eventually finishes recall express property ctl start nished nodes faulty experience find time property fails hold interestingly model checking procedure derive graphs service success scenario graph service fail scenario graph success scenario graph captures traces service finishes fail scenario graph traces service fails finish scenario graphs constructed procedure similar fault scenario graphs banking issuing check corresponds start service scenario graph shown figure shows effect link failures check clearing service check issued source address bank-a destination address bank-c start event labeled issuecheck bank-a bank-c figure event sending check location denoted sendcheck predicates linka- link-aindicate link-ais recall links fail nondeterministically event sendcheck bank-a mcis performed link-ais link-ais pre-condition event sendcheck bank-a mcif pre-condition shown assumed true note fault link construed intruder taking link shutting graph easy check clears link-aand link-care link-ais link-aand link-care modified model checker nusmv produce scenario graphs automatically realistic examples scenario graphs extremely large feasible enumerate scenarios traces scenario graph developed querying process architect select subset scenarios architect identifies events interest network events alphabet symbols architect regular expression traces interest scenario graph shown figure regular expression alphabet sendcheck frbfrb- query captures architect interest traces check transferred frbto frbas denoted event sendcheck frbfrb- trace satisfies regular expression shown dotted line figure step reliability latency analysis generated scenario graphs perform reliability latency analysis incorporate probabilities events scenario graph produce mdp mdp compute reliability latency calculating function optimal policy explain analysis banking provide formal explanation boolean state variable link-ais corresponds link-as analogously boolean variables link-as link-cs general event boolean variable negation variable denote event occur boolean variable event represents synonymously event corresponds link-as explain handle dependencies events assume event dependent dependencies probabilities link-aand link-cbeing probability event depends event give conditional probability reflecting link-ais link-awill general event depends set events akg probability case set events akg depends aja aja aja aja technique bayesian network formalism compute probability events events correspond events link-aand link-aup link-ain scenario graph probabilities events derived add probabilities shown inside boxes relevant edges scenario graph figure assign probabilities events typically faults obtain structure combination purely nondeterministic probabilistic transitions banking architect assign probabilities events faults user banking system nondeterministically issues checks intuitively nondeterministic transitions actions environment user probabilistic transitions correspond moves adversary view nondeterministic transitions actions structure obtained incorporating probabilities scenario graph mdp distributed algorithms literature structures combination nondeterministic probabilistic transitions called concurrent probabilistic systems explain algorithm compute reliability latency property services recall interested property start finished service success scenario graph property suppose edge cost goal environment assumed malicious devise optimal policy equivalently choose nondeterministic transitions order minimize reliability maximize latency function assigns state scenario graph describe algorithm compute function optimal policy algorithm called policy iteration mdp literature explain function interpreted worst case reliability latency initial step states satisfy property finished states assume state called probabilistic transitions state probabilistic state called nondeterministic probabilistic simplify analysis issuecheck bank-a bank-c sendcheck bank-a mcsendcheck mcfrb- sendcheck frbfrb- sendcheck frbmc- sendcheck mcbank-c debitaccount sendcheck bank-a mcsendcheck mcfrb- sendcheck frbfrb- link-aup link-aup link-cup link-afigure simple scenario graph modify scenario graph change meaning ensure state probabilistic nondeterministic emanating state transitions states satisfy finished states function updated nondeterministic min succ probabilistic succ equations succ set successors state probability transition state intuitively speaking nondeterministic move corresponds environment choosing action minimize probabilistic state expected successors starting initial state function updated equations convergence algorithm converges end desired function initial state 
efficient filtering publish-subscribe systems binary decision diagrams alexis campailla microsoft corporation microsoft redmond usa alexisca microsoft sagar chaki edmund clarke carnegie mellon school computer science forbes avenue pittsburgh chaki emc cmu somesh jha computer science department wisconsin madison usa jha wisc helmut veith vienna technology database group favoritenstr vienna austria veith dbai tuwien abstract implicit invocation publish-subscribe important architectural style large-scale system design evolution publish-subscribe style facilitates developing large-scale systems composing separately developed components style permits loose coupling components major bottlenecks publish-subscribe systems large scale systems efficiency filtering incoming messages matching published events event subscriptions challenging problem realistic publishsubscribe system number subscriptions large paper present approach matching published events subscriptions scales large number subscriptions approach binary decision diagrams compact data structure representing boolean functions successfully verification techniques model checking experimental results demonstrate efficiency approach keywords publish subscribe systems binary decision diagrams introduction major goals software engineering develop architectural styles facilitate composing separately designed developed components large-scale system architectural styles developed achieve goal familiar styles include based remote procedure calls shared variables asynchronous message passing important architectural style system composition implicit invocation publish-subscribe referred pub-sub pub-sub style components interact publishing messages subscribing classes messages pub-sub system types components clients publishers subscribers exchange messages server call broker components draft paper submitted icse clients events messages synonymously paper common scenario publishers subscribers reciprocal knowledge major advantages pub-sub style clients loosely coupled publishers connect broker publish events make world aware subscribers connect broker establish subscriptions set messages interested receiving job broker match published messages subscriptions deliver subscribers messages interest subscriber selection criteria evaluated incoming messages broker behalf subscribers algorithm matching incoming messages selection criteria subscribers called filtering algorithm component implements filtering algorithm called filtering engine pub-sub brokers combination efficient reliable multicast delivery advanced filtering capabilities applications pub-sub systems numerous systems financial data news dissemination process monitoring distributed event notification core technology enable event-driven distributed web applications pub-sub style programming environments operating systems call back mechanism signal handling operating systems classic pub-sub style mechanisms support pub-sub style found commercial toolkits softbench tooltalk decfuse communications standards corba integration frameworks javabeans programming environments sun recently announced specification messaging service called java message service jms jms supports primitives support pub-sub style abstracting application pub-sub systems broad scope major advantages pub-sub paradigm filtering capabilities subscriber receive messages satisfy criteria event broadcast system information broadcast consumers makes poor network resources system filtering subscriber approach feasible high-speed dedicated network attractive network resources primary bottlenecks case beneficial perform filtering close information source source specific interests subscribers buildingsystems scale impossible main focus paper filtering algorithm recall filtering algorithm matches incoming message selection criteria subscribers order determine set subscribers interested message goal provide filtering algorithms deployed large scale pub-sub systems pub-sub systems content distribution web provide examples typical pub-sub style based typical examples derive functional requirements design goals filtering engine financial data advanced pub-sub systems today electronic trading floors delivery financial data stock quotes company news order confirmation events systems historically deployed high-speed private networks beginning massively internet application high volumes published messages number subscriptions moderate intranet scenarios high internet scenarios pubsub applications extensive filtering capabilities bring additional services offering features customers subscribe stock symbol advanced criteria notification price hits threshold news dissemination e-commerce general application pub-sub news dissemination e-magazines broadcast information updates topics users select topics interested significant case falls category e-commerce oriented news dissemination e-commerce sites users subscribe news products interested scenario comprised small number publishers magazine e-commerce site high number subscribers functional requirements filtering engine matching published events subscriptions filtering engine evaluate set subscriptions incoming stream messages subject requirements expressivity language expressing subscription criteria rich language expressing subscription criteria detail jms efficiency matching extremely efficiently real time scalability matching handle large numbers subscriptions add remove subscriptions filtering engine add remove subscriptions set existing subscriptions design goals main goal paper design filtering engine efficient scalable realistic system number subscriptions large hundred thousand message published client interested subscribers quickly notified typically arriving messages satisfy subscription criteria financial data provided earlier suppose message ibm arrives total number subscribers large typically small fraction subscribers interested specific stock ibm call irrelevance property leverage irrelevance property pub-sub systems design filtering algorithm goal match messages subscriptions real-time matching algorithms scalable handle hundred thousand subscriptions cost adding removing updating subscriptions addressed performance operations critical frequent arrival messages strategies distributing filtering load pub-sub server multiple hosts addressed paper strategies load distribution place efficient filtering engine matches incoming messages subscription criteria subscribers overview major contributions binary decision diagrams bdds compact data structures representing boolean functions bdds successfully verification methods model checking bdds design fast filtering algorithm section overview approach atomic formula client subscription criteria subscription ibm della assigned boolean variable notice subscription boolean function boolean variables atomic formulae subscription represented bdd intuitively subscriptions pub-sub system share common sub-expressions pattern subscription criteria called message selectors jms parlance subscriptions representing subscriptions bdds exploit commonality shared sub-subscriptions subscriptions published message simply partial assignment boolean variables atomic formulas message arrives set subscriptions match message found backward traversal algorithm bdds efficiency method stems fact common subexpressions bdd nodes evaluated paper makes major contributions provide precise semantics message matches subscription trivial task language describing subscriptions rich partial messages messages refer subset attribute variables present efficient scalable filtering algorithm based bdds experimental results demonstrate filtering algorithm scalable related work applications pub-sub systems earlier content-based pub-sub systems intended content distribution distributed network contentbased pub-sub systems subscription criteria filter messages based content hand channelbased pub-sub systems subscription criteria filters messages based channels ports originate benefits filtering algorithm apparent number subscribers large typical case content-based pub-sub systems techniques presented paper suitable content-based pubsub systems notice examples presented earlier fall category knowledge important contentbased pub-sub systems gryphon siena elvin keryx subscription languages mentioned content-based pub-sub systems fairly similar subscription language presented paper work focuses filtering algorithm suitable content-based pub-sub systems techniques presented paper applied improve existing pub-sub systems rest section compare approach filtering engines gryphon siena elvin keryx bdd-based filtering techniques incorporated existing systems filtering engines filtering engine gryphon similar based parallel search trees essentially decision trees labelled atomic formulas optimization procedures 
scenario graph cost edges worst case reliability metric property worst case probability service issued eventually finish cost edges correspond negative latency corresponds worst case latency service worst case expected finishing time service notice setting minimizing cost corresponds maximizing latency scenario graph shown figure worst case reliability algorithm worst case probability check issuedby bank-a bank-c cleared latency daysfor events shown figure inside square brackets latency event sendcheck frbmc- days compute latency node labeled sendcheck frbmc- finally worst case latency initial node days step cost-benefit analysis finally add cost information extend mdp cmdp explain analysis running suppose architect upgrade links improve robustness system links link-alink-a- link-care candidates upgraded assume link-aand link-care upgraded probabilities increase link-ais upgraded probability link-abeing links upgraded probabilities change addition actions nondeterministic transitions extra actions upgrading link-alink-a- link-care added action set mdp constructed previously assume architect cost constraint links upgraded case obtain cmdp cost upgrading links expressed cost function section algorithms finding optimal policies case cmdps exist complicated fortunately problem easier decisions upgrade links static depend state system case optimal decision found solving auxiliary integer programming problem links link-alink-a- link-cwe associate variables intuitively link-ahas upgraded worst case reliability function denote rel aim maximize worst case reliability rel subject constraint links upgraded non-linear integer programming problem problem full generality hard heuristics solving class problems studied figure lists worst-case reliability cases clear option upgrade link-aand link-cxa figure table cases status built tool trishul based ideas presented paper implemented basic algorithms finishing graph visualization component customized editor finished major case studies extended banking system bond trading floor model banking system complicated simplified presented paper handle protocols fedwire swift transfer funds transmitting financial messages show entire banking system model lines nusmv code scenario graph nodes computing reliability latency takes minutes modeled analyzed system architecture bond trading floor major investment company york model lines nusmv code state variables tool found attacks attacks considered architects attack enabled junior trader acquire head trader password attack enabled junior trader obtain sensitive information company database junior trader find nature pending trades surprisingly gained valuable experience case study cumbersome part modeling process fault injection phase nature faults injected heavily dependent security policies technologies deployed node plan automate fault injection process future related work software engineering institute method analyzing survivability network architectures called sna conducted case study system medical information management sna methodology informal meant provide general recommendations practices organization make systems secure reliable contrast method formal leverages automatic verification techniques model checking research operational security ortolo deswarte kaaniche closest step method attack state graphs similar scenario graphs symbolic model checking generate scenario graphs represented bdds handle extremely large graphs method scenario graph corresponds service contrast graph corresponds global model entire system investigating incorporate concepts analysis techniques presented paper method fault injection well-known technique fault tolerance community hazard analysis joe ahearn csfb clarifying details protocols due propriety nature case study process sanitizing model publish results date designer kind fault wider class faults fault events dependent model correlated attacks computing reliability vast amount literature verifying probabilistic systems algorithm computing reliability draws work recently work verifying concurrent probabilistic systems algorithms data-structures developed domain potentially efficiently computing reliability novelty work systematic combination techniques method summary contributions future work survivability increasingly important society increased dependence critical infrastructures run computers paper presented single framework systematic method analyzing networked system survivability fundamental contribution work constrained markov decision processes sole underlying mathematical model framework contribution natural integration set analysis techniques disparate communities framework model checking popular computeraided verification bayesian network analysis popular artificial intelligence probabilistic analysis popular hybrid systems queueing systems cost-benefit analysis popular decision theory combination techniques provide multi-faceted view networked system holistic view system core achieving survivability system critical services directions future work plan finish prototype tool supports method working case studies including protocols electronic commerce system real systems scenario graphs large plan improve display query capabilities tool architects easily manipulate output finally make fault injection process systematic investigating integrate operational security analysis tools cops method survivability young emerging discipline view distinct traditional areas security fault-tolerance borrows heavily view work step formalizing models identifying properties analyzing systems survivability means work definitive work progresses hope clarify makes survivability distinct fault-tolerance security nusmv symbolic model checker http afrodite itc nusmv altman constrained markov decision processes chapman hall baier kwiatkowska model checking probabilistic branching time logic fairness distributed computing bryant graph-based algorithms boolean function manipulation ieee trans comput aug clarke grumberg peled model checking mit press courcoubetis yannakakis complexity probabilistic verification journal acm alfaro kwiatkowska norman parker segala symbolic model checking concurrent probabilistic processes mtbdds kronecker representation proceedings tacas international worskshop tools algorithms construction analysis systems ellison fisher linger lipson longstaff mead survivable network systems emerging discpline technical report cmu sei- software engineering institute carnegie mellon pittsburgh november ellison linger longstaff mead survivability network system analysis case study ieee software july august farmer spafford cops security checker system proceedings summer usenix conference proceedings information survivability workshop boston october information survivability workshop isw october http cert research isw html knight elder flinn marx summaries critical infrastructure applications technical report cs- department computer science virginia charlottesville december leveson safeware system safety computers addison-wesley lynch saias segala proving time bounds randomized distributed algorithms proceedings podc pages ortalo deswarte kaaniche experimenting quantitative evaluation tools monitoring operational security ieee transactions software engineering sept oct pearl probabilistic reasoning intelligent systems networks plausible inference morgan kaufmann pnueli temporal logic concurrent programs theoretical comput sci schrijver theory linear integer programming john wiley sons 
decrease redundancy search trees details provided authors mention optimizations transform search tree acyclic graph appears subset bdd operations reinvented parallel search trees disadvantage gryphon restricted subscription language consists conjunctions impressive complexity results matching time sublinear number subscriptions natural properties bdd data structure gryphon restriction conjunctions forces user express natural filters submitting exponential number subscriptions subscription requires gryphon-like subscriptions contrast disjunctive subscriptions naturally handled bdds experiments section demonstrate filtering engine competitive comparison gryphon expect routing techniques developed gryphon readily extended bdds siena subscriptions partially ordered respect subsumption information pre-filter events forward filtering engines elaborate automata-based matching algorithm akin gryphon implementation aware similar gryphon siena conjunctive subscription language contrast systems siena pattern concept relating messages techniques developed gryphon complementary techniques siena filtering engine adapted siena recently filtering algorithm system subscribe presented indexing techniques fast matching atomic formulas clusters subscriptions minimize cache failures clustering matching methods subscribe restricted conjunctive subscriptions similar gryphon siena subscription language elvin expressive previous extends subscription language ability regular expressions string attributes elvin filtering engine similar gryphon bdd-based approach easily extended handle complicated atomic properties elvin regular expressions bdd filtering engine context elvin keryx java notification service distributed architecture similar usenet subscription language dfl keryx lisp-like formalism makes hard devise efficient filtering techniques future research investigate bdd-based methods dfl fragment thereof subscription subsumes subscription set messages superset set messages general observation trade-off expressive subscription languages highly efficient filtering engines characteristic existing systems work bdd-based filtering engines helps alleviate problem subscription query language languages describe subscription criteria subscriptions called subscription query languages query languages short section describe query languages sisl stsl desl submit subscriptions framework query languages made expressive language jms expressing subscriptions message selectors jms parlance extent expressiveness query languages independent bdd-based implementation system messages attributes event set attributes distinguish types attributes integer double string fix finite sequence attributes variables attribute type domain constants tuple called event schema current implementation attributes interpreted bit integers attributes interpreted bit double precision floating point numbers attributes ascii strings arbitrary length easy extend methodology larger number attribute types message simply assigns values necessarily attributes formally message partial assignment attributes mapping attribute define message total defines attributes sales announcements suppose event schema practice messages simple xml-style documents message company ibm company product mhz ram product price price document describes total message ibm mhz ram document describes message total attributea defined languages expressing subscriptions resemble database query languages company future company product ghz super product synopsis query languages describe subscription query languages increasing complexity simple subscription language sisl settings messages total sisl simple powerful tool select messages format typically non-distributed setting specialized applications strict subscription language stsl requires order match stsl query message define attributes occur query filtering engine presented paper efficient stsl case default subscription language desl attributes initialized default values updated message default test individual attributes defined message desl extends functionality sisl heterogeneous message formats case distributed settings semantics called null semantics queries provided jms default subscription language model null semantics jms sisl simple subscription language total messages sisl queries subscriptions atomic properties event attributes boolean combinations thereof formally sisl defined attribute type formulas atomic formulas atomic formulas defined analogously string atomic formulas denotes substring set atomic formulas denoted query boolean combination atomic formulas set attributes occurring set atomic formulas occurring abbreviations query language abbreviation abbreviation abbreviation sales announcements ctd sisl query matches announcements mhz pcs manufactured ibm dell siemens cost instantiation query message denoted formally define query obtained replacing variables sisl query total message matches evaluates true formally write describe extensions sisl handle non-total messages stsl strict subscription language language simplest extension sisl message adequate query defines variables occurring holds note total messages adequate arbitrary queries define matches strict semantics iff adequate write denote matching stsl semantics remark note notion adequateness based syntactic properties query alternative semantics query adequate attributes query depends defined call notion semantic adequacy respect semantic adequacy queries treated prefer syntactic notion simpler user detecting irrelevant variables hard problem avoids paradox outlined semantic adequacy suppose alice subscribes messages bob subscribes messages decide join efforts subscribe disjunction equivalent true semantic adequacy alice bob receive messages price frustrated alice bob figure receive messages defined kind paradox reappear technical level connection bdd restrictions defined desl default subscription language attribute fix default message attribute default formally default extension total message defined matches default semantics symbols evaluates true string attribute natural define empty string integer double values denote absence valid attribute mentioned desl test attribute defined followingway extend domain element set default attributes easy formula expresses attribute defined proposition easy prove proposition total messages sisl stsl desl equally expressive binary decision diagrams section formally describe ordered binary decisions diagrams bdds standard algorithms bdds bdds set propositional variables linear order referred variable ordering ordered binary decision diagram bdd acyclic graph non-terminal vertices nodes labeled variables edges terminal nodes labeled non-terminal node out-degree outgoing edges labeled low edge else-edge labeled high edge then-edge label successors labeled words path sequence labels path strictly increasing respect bdd node represents boolean function terminal nodes represent constant functions labels non-terminal node label successors high low edges defines function denote boolean function bdd figure represents boolean function variable ordering size bdd number nodes bdd well-known variable ordering sequence boolean functions exists unique minimal bdd distinguished output nodes represent boolean functions called shared bdd bdd output nodes denoted computable figure bdd function figure shared bdd shared bdd polynomial time bdd non-terminal nodes nodes describe boolean function shared bdd figure figure bdd nodes identified natural numbers output nodes encircled thick line root nodes represent functions node represents function size general depends variable ordering exponential effective algorithms computing handling bdds literature operations boolean functions efficiently performed bdds main advantage representing boolean functions shared bdds possibility representing shared subfunctions important bdd filtering engine paper case unique root bdd shows output node incoming edges assume bdds shared stated bdd data structure evaluation represent bdd nodes graph vertices natural numbers adjacency relation array size -th element array record denotes low successor denotes algorithm evalbdda downto terminal output figure bdd evaluation algorithm high successor denotes label node store 
results bdd evaluation assume natural order nodes consistent order variables non-terminal nodes nodes topologically sorted respect variable order truth assignment mapping boolean function denotes output assignment algorithm evalbdd figure computes node assignment write denote component element array proposition sequence boolean functions binary decision diagram assignments bdd restrictions bdds intended represent boolean functions situations bdd correct inputs external constraint enforces inputs occur boolean function bdd boolean function evaluates input input relevant bdd replaced possibly smaller bdd equivalent inputs satisfying bdd called restriction state-of-the-art bdd packages employ heuristics compute small restriction bdds note thata general represents boolean function formally bdds denote boolean function tautologically true called restriction vice versa intuitively anda required equivalent assignments denotes set restrictions bdds equivalent remark note restriction case replaced bdd evaluates inputs satisfy general yield small restriction larger filtering engine section describe principles bdd filtering engine basic algorithms query bdds basic idea query bdds represent large number queries subscriptions shared bdd nodes correspond atomic subformulas queries messages matched queries bdd evaluation algorithms formally sequence queries set attributes set atomic subformulas queries set propositional variables associate propositional variable query corresponds propositional formula obtained replacing occurrences atomic subformulas propositional variables linear order denotes bdd boolean formulas discuss choose variable ordering query denotes output node suppose alice bob subscriptions set bdd variables choose variable ordering bdd shown figure message defines partial assignment bdd variables natural define variable ina total true note canonical bdd bdds ina represent functions figure query bdd atoms write denote message makes true makes true note represented bdd variables semantically related section deal question remove redundancy bdd eliminating redundancies query bdds note atoms semantically related information attribute unrelated bdd bdd variables point view bdd related hand definition guarantees messages semantic relation bdd variables formally expressed dependency function dependency function restriction function bdds bdd based query matching section treat simpler case total messages proposed semantics coincide show bdd evaluation algorithm applied evaluate queries describe bdd restrictions improve algorithm finally describe evaluation strategies semantics sisl semantics procedure evalbdd query matching assume sequence queries subscriptions total message assignment message execute procedure evalbdd parameters query considered matched bdd node evaluates procedure evalbdd works backward sharing bdds algorithm evaluates bdd algorithm mvevalbdda downto terminal output figure three-valued bdd evaluation algorithm node words sub-query bdd node evaluated query bdd replaced arbitrary bdd set dependency function bdd called dependency restriction bdd packages good heuristics compute small restrictions section restricted bdds significantly improves performance filtering engine correctness algorithm easily semantics desl shown section default semantics essentially amounts handling total messages message received extended total message operation implemented effectively default template attributes changed incoming message default semantics handled algorithm evalbdd stsl strict semantics present bdd-based evaluation algorithm performs significantly faster ordinary evaluation algorithm recall strict semantics message matches subscription query iff adequate attributes occurring ina defined satisfies main idea undefined atom renders subformulas occurs undefined evaluation algorithm treat denoting undefined label encountered algorithm mvevalbdd figure moves node truth node computed successors function coincides boolean inputs evaluates experiments section show mvevalbdd outperforms algorithms semantics significantly explained evalbdd loops nodes step accesses nodes node access operations mvevalbdd hand access successor nodes undefined node messages defines attributes nodes accessed case partial messages constant factor algorithm improved iii importantly node access operations equally expensive long bdd traversed node node consecutive memory parts copied cache memory cache failures occur consecutive node access operations fast contrast successor nodes node cache access operations successor nodes average expensive expected cost operation line program code figure higher expected cost operation line program number defined attributes message correlated frequency executing lines constant factor mvevalbdd small messages attributes experiments section confirm intuitions easy prove correctness algorithm interpreted false optimization section investigate natural optimization issues critical parts bdd filtering engine bdd restriction bdd variable ordering bdd evaluation algorithm bdd restriction colorado bdd package restriction procedure compute restricted bdd note procedure heuristic necessarily compute smallest restriction bdd performance restriction procedure depends strongly size restricting formula experiments shown feasible dependency function dependency functions query separately perform iterative restrictions dependency functions experiments demonstrate effectiveness procedure bdd variable ordering well-known general bdds variable order tremendous influence bdd size problem finding optimal variable ordering np-hard bdd packages complicated heuristics determine variable order user choose variable ordering experiments shown filtering engine application variable ordering strong influence bdd size apparently boolean functions shallow structurally simple numerous natural variable ordering bdd variables attribute close variables ordered frequency give good results show significant improvement random orders stability algorithm respect variable ordering important feature filtering engine shared bdd extended online time subscription arrives extremely expensive adapt variable order subscription bdd evaluation algorithm recall major advantage mvevalbdd evalbdd avoidance costly cache failures principle change enumeration order bdd nodes number cache misses minimized large number bdd nodes optimal solution problem obtained practice simple scheduling heuristics changing enumeration order bdd significant performance improvements achieved apparent reason cache size standard architectures small purpose experimental results experiments carried mhz pentiumpro machine ram running redhat linux kernel implementation filtering engine colorado bdd package cudd version query generation queries produced automatic query generator internally developed microsoft query generator outputs queries basis input grammar file grammar extended bnf form user associate probabilities production rules queries generated application rules non-deterministic choices selected accordance probabilities experiments ten attribute variables variables type integer variables type double variables type string integer double variables combined integer double constants relational operators string variables combined string constants relational operators substring superstring total atomic formulas note executed entire experiment times results follow report averages runs query characteristics memory requirements set queries atomic formulas relational operators average table shows average number bdd nodes obtained queries applying restriction optimization section significant reduction effectiveness restriction optimization note number bdd nodes determines memory consumption highly optimized bdd packages cudd package node requires bytes memory table number bdd nodes scales linearly number queries state art bdd packages capable managing billions nodes number queries technique handle scalable bottleneck queries nodes nodes factor restriction restriction improvement message generation messages generated randomly assigning values messages variables numeric attribute variables values chosen randomly range string variable values selected randomly set twenty alternatives varying 
date day subject nitpick nitpick ladyb allo allo alcoa figure schedule analysis adts analyzing allo models fers fully automatic animation generate states satisfy ariants ecutions operations countere xamples claimed properties model website http sdg lcs llo schedule figure note class esting assumed nished requirements design phase start coding testing phase starts major forms testing blac box white box testing black box testing tester ignores internals program tester access code simply compares output program tested speci cation white box testing tester inspects code designs tests esting metrics measure test suite primarily white box testing testing metrics refer ences selecting softwar test data data information rapps yuk ieee ransactions softw engineering tse seh april mark analysis softwar speci cations whittak poore ransacy tions softw engineering methodology osem january art softwar esting myers john ile sons incr emental testing dependence aphs bates horwitz conference record wentieth symposium principles programming languages popl january hier hical gui est case gener ation utomated planning memon pollack sof ieee ransactions softw engineering february eop page bop lecture date day subject cfgs pdgs data flo analysis data flo analysis esting metrics esting metrics mark chains mark chains usage based testing esting guis mps esting pdgs figure schedule testing ools schedule figure ollo wing abbre viations contr flow aphs abbre viated cfgs dependence aphs abbre viated pdgs aphical user interfaces abbre viated guis ogram understanding ackling legacy code assumed program constructed scratch programs gac code xisting code project frequently understand gac code construct model process called ver engineering part concentrate tools program understanding process understanding xisting code refer ences ciao aphical navigator softwar document repositories chen wler outso allach dynamically disco vering lik ely variants support evolution ernst cockrelly grisw notkin ieee ransactions softw engineering february step owar utomated detection buf fer overrun ulner abilities agner oster bre wer aik proceedings netw ork distrib uted system security symposium ndss february eop page bop lecture date day subject call graphs cfkw cgk extracting ariants ecgn extracting ariants ecgn slicing specialized analysis ecch specialized analysis ecch wfb specialized analysis wfb figure schedule program understanding chec king system rules system speci ammer -written compiler extensions engler chelf chou hallem proceedings ourth symposium operating systems design implementation osdi san die october ools cia customizable xtensible vigator allo users query analyze visualize track structures arious softw document repositories cia instantiy ated html ksh documents eral usiness repositories website http resea daik named asian radish prototype implementation ariant detection front ends xist lisp daik research prototype rocky solid intended commercial website http sdg lcs dai schedule figure note class due thanksgi ving break closing esentations ote lectures closing comments rest lectures oted student presentations refer ences applicable ools applicable schedule figure grading xams gular home orks class home orks account percent class students complete project class project guidelines class homepage project account percent class acti participation class project account percent eop page bop lecture date day subject closing comments comments session figure schedule closing refer ences bates horwitz incremental program testing program dependence graphs confer ence recor wentieth symposium principles amming langua popl january bjrr booch jacobson james rumbaugh jim rumbaugh uni modely ing langua user guide addison-w esle object hnolo series addisony esle october bmmr ball majumdar millstein rajamani automatic predicate aby straction programs pldi sigplan notices olume pages ball rajamani automatically alidating temporal safety properties interf aces spin orkshop model chec king softwar lncs pages cab chan anderson beame burns modugno notkin reese model checking lar softw speci cations ieee ansactions softwar engiy neering july cdh james corbett matthe dwyer john hatclif sha laubach corina asareanu hongjun zheng bandera extracting nite-state models source code oceedings international confer ence softwar engineering icse june cfkw chen wler outso allach ciao graphical vigator softw document repositories oceedings international confer ence softwar maintenance icsm pages cgk chen gansner outso data model supporting reachability analysis dead code detection oceedings eur opean softwar engineer ing confer ence sigsoft symposium oundations softwar engineering esec fse september dhj matthe dwyer john hatclif roby joehanes sha laubach corina asarey anu illem isser hongjun zheng ool-supported program abstraction nite-state eri cation oceedings international confer ence softy war engineering icse eop page bop ecch engler chelf chou hallem checking system rules system speci programmer -written compiler xtensions oceedings ourth symy posium oper ating systems design implementation osdi san die october ecgn ernst cockrell grisw vid notkin dynamically disco ering lik ely program ariants support program olution ieee ansactions softwar engineering feb harel politi modeling reactive systems ith statec harts statemate appr oac mcgra hill october horwitz reps program dependence graphs softw eny gineering oceedings ourteenth international confer ence softwar engineering icse pages mps memon pollack sof hierarchical gui test case generation automated planning ieee ansactions softwar engineering february surv program slicing techniques ournal amming langua wfb agner oster bre wer aik rst step ards automated detection fer errun vulnerabilities oceedings network disy trib uted system security symposium ndss february eop trailer end userdict end-hook end-hook eof 
length evaluation carried experiments sisl stsl semantics recall sisl requires messages total hand stsl handle partial messages typical case realistic pub-sub systems table shows average time seconds required match messages numbers queries message densities message density measure total message number attribute variables message defines column shows time seconds required match total messages sisl semantics table partial messages matched quickly message density sisl queries performance stsl algorithm scales linearly message density expected total messages performance sisl semantics stsl semantics main reason mvevalbdd algorithm inspect children bdd node visited evalbdd algorithm inspect child partial messages common case realistic pub-sub systems experiments show modern servers hosting filtering engine capable matching messages queries seconds assuming modern server ghz clock memory typical message densities conclusion major contributions paper provide semantics message matching query subscription semantics differ expressiveness efficiency filtering algorithm bdd filtering engine supports semantics presented filtering algorithm based bdds suitable large scale content-based pub-sub systems demonstrated experimental results filtering algorithm easily handle half million subscriptions plan extend work directions extensible markup language xml increasingly de-facto standard exchanging data internet applications extend algorithm pub-sub systems based xml related technologies specifically messages xml instances subscriptions expressed xml query language xql current requirements xql found http xmlquery-req xql expressive query language presented paper plan implement significant infrastructure enable perform experiments realistic settings acknowledgments authors thankful greg zelesnik jianjun chen comments draft paper yuan poul williams contributed discussions initiatingthis work aguilera strom sturman astley chandra matching events content-based subscription system acm symposium principles distributed computing podc banavar chandra mukherjee nagarajarao strom sturman information flow based event distribution middleware middleware workshop international conference distributed computing banavar chandra mukherjee nagarajarao strom sturman efficient multicast protocol content-based publish-subscribe systems ieee international conference distributed computing systems icdcs bollig wegener improving variable ordering obdds np-complete ieee transactions computers bryant graph-based algorithms boolean function manipulation ieee transaction computers bryant complexity vlsi implementations graph representations boolean functions application integer multiplication ieee transaction computers carzaniga rosenblum wolf interfaces algorithms wide-area event notification service colorado dept technical report cu-cs- carzaniga rosenblum wolf achieving scalability expressiveness internet-scale event notification service nineteenth acm symposium principles distributed computing podc carzaniga rosenblum wolf content-based addressing routing general model application colorado dept technical report cu-cs- clarke grumberg peled model checking mit press consortium extensible markup language xml http rec-xml february common object request broker architecture specification omg document number december revision draft coudert madre unified framework formal verification sequential circuits ieee international conference computer-aided design iccad pages fitzpatrick mansfield kaplan arnold phelps segall augmenting workaday world elvin sixth european conference computer supported cooperative work ecscw garlan kaiser notkin tool abstraction compose systems ieee computer june gerety softbench generation software development tools technical report sesd- hewlett-packard software engineering systems division fort collins colorado november gough smith efficient recognition events distributed system australasian computer science conference acsc gryphon homepage http research ibm gryphon jubin javabeans upper saddle river prentice hall keryx homepage http keryxsoft hpl low integrating communication services ieee communications magazine sun microsystems java message service version http javasoft november pereira fabret llirbat shasha efficient matching web-based publish subscribe systems int conf cooperative information systems coopis reiss connecting tools message passing field program development environment ieee software july segall arnold elvin left building publish subscribe notification service quenching auug fabio somenzi cudd decision diagram package http vlsi colorado fabio sullivan notkin reconciling environment integration component independence acm transactions software engineering methodology july sunsoft tooltalk users guide november 
circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def uniqueid def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd becd aad affbf dcc abc bff eaeee bed fbffc cdbf cdeb def cleartomark endfont texdict begin course-document dvi start texbase encoding reencodefont courier texbase encoding reencodefont times-bold texbbad fencoding reencodefont cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin papersize letter end endsetup page texdict begin bop document introduction information security somesh jha computer sciences department uni ersity isconsin madison jha wisc view shared resources internet created global-information infrastructure hand shared resources create risks due intentional unintentional malicious beha ior information security area deals protection detection malicious acti vity study fundamentals information security student good understanding eral acets information security syllab basic cryptographic primiti part focus cryptographic primiti follo wing topics detail symmetric-k encryption str eam ciphers linear non-linear feedback shift gisters block ciphers des modes operations public-k encryption rsa elgamal public-k encryption hash functions data integrity basic properties hash functions unk hash functions mdc shay eop end page texdict begin bop hash functions based block stream ciphers based mdcs digital signatur classi cation digital signatures digital signatures related rsa digital signature algorithm dsa otocols section focus protocols arious purposes protocols cryptographic primiti discussed rst part protocols discuss establishment otocols erberos dif e-hellman secret sharing security secure sock ets layer ssl secur payment otocols cybercash digital money digicash system security part focus system security common system vulnerabilities attacks focus tcp syn ooding denial-of-service attacks rele ant material pro vided lecture time list vulner abilities maintained cer coordination center web-page cert located softw engineering institute carne gie mellon uni ersity fir ewalls discuss architecture alls fire alls discussed books required class notes suf cient intrusion detection systems arious types intrusion detection systems discussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort special opics time remaining discuss adv anced topics elliptic-curve crypto aphy ecc smartcar eop end page texdict begin bop grading criteria finalized homew orks short home orks assigned class exams xams mid-term nal xams equal weight oject signi project related security students pick projects pro vide refer ences cheswick bello vin rubin walls internet security repelling ily hac addison esle publishing compan northcutt network intrusion detection analyst handbook riders publishing zwick cooper chapman russell building internet walls reilly associates eop end trailer userdict end-hook end-hook eof 
homework analysis software artifacts due date nov monday note homework question gave question considerable amount time change smv speci cations directions earlier homework start changing smv model write design document outline design strategy design document detailed show design document fellow student reviewer mention reviewer document design document consistent speci cation submit modi smv speci cation design document homework grading homework completing homework note base design smv provided homework design consistent start code base question modeling points smv speci cation provide solution homework enhance speci cation part multiple priorities users levels priority high low assume users priority users priority round-robin scheduling policy users erent priorities waiting user higher priority machine part coins assume drink costs fty cents user deposits dimes quarters user vending machine deposited coins worth greater equal fty cents drink discuss round-robin scheduling lectures vending machine return spare change hints extra variable called amount-accrued track user deposited vending machine variable called amount-returned equal spare change gure values variables amount-accrued amount-returned arithmetic smv track amount-accrued amount-returned explicit transitions simulate addition amount-accrued twenty user deposits dime amount-accrued thirty step 
published proceedings usenix security symposium security pages august washington usa static analysis executables detect malicious patterns mihai christodorescu somesh jha mihai wisc jha wisc computer sciences department wisconsin madison abstract malicious code detection crucial component defense mechanism paper present unique viewpoint malicious code detection regard malicious code detection game malicious code writers researchers working malicious code detection malicious code writers attempt obfuscate malicious code subvert malicious code detectors anti-virus software tested resilience commercial virus scanners code-obfuscation attacks results surprising commercial virus scanners subverted simple obfuscation transformations present architecture detecting malicious patterns executables resilient common obfuscation transformations experimental results demonstrate efficacy prototype tool safe static analyzer executables introduction interconnected world computers malicious code omnipresent dangerous threat malicious code infiltrate hosts variety methods attacks software flaws hidden functionality regular programs social engineering devastating effect malicious code cyber infrastructure identifying malicious programs important goal detecting presence malicious code host crucial component defense mechanism malicious code classified propagation method goal categories viruses programs self-replicate host attaching programs documents carriers malicious code worms self-replicate network trojan horses masquerade programs malicious code attack system leak data back doors open system external entities subthis work supported part office naval research contracts government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government verting local security policies remote access control network spyware software package transmits private user data external entity combining malicious code categories lead powerful attack tools worm payload installs back door remote access worm replicates system means back door installed system providing attacker quick easy gain access large set hosts staniford demonstrated worms propagate extremely quickly network potentially cripple entire cyber infrastructure recent outbreak sapphire sql slammer worm reached peak infection rate minutes launch doubling seconds backdoor tool gains large installed base attacker compromised hosts launch coordinated attack distributed denial-of-service ddos attack paper develop methodology detecting malicious patterns executables method general initially focused attention viruses computer virus replicates inserting copy code viral code host program user executes infected program virus copy runs infects programs original program continues execute casual user perceived difference clean infected copies program virus activates malicious payload classic virus-detection techniques presence virus-specific sequence instructions called virus signature inside program signature found highly probable program infected chernobyl cih virus detected checking hexadecimal sequence cfa corresponds iainstruction sequence constitutes part virus body call pop ebx lea ecx ebx push ecx push eax push eax sidt esp pop ebx add ebx cli mov ebp ebx classic detection approach effective virus code change significantly time detection easier viruses originate source code minor modifications updates virus signature common virus variants chernobyl cih versions differ trigger date malicious code active effectively detected scanning single signature shown virus writers antivirus software developers engaged game virus writers obfuscate vanilla virus signatures antivirus software detect morphed viruses detect obfuscated virus virus scanners undo obfuscation transformations virus writers game virus writers obfuscators researchers working malicious code detection deobfuscators method detect malicious code resistant common obfuscation transformations paper introduces method main contributions paper include game attacks commercial virus scanners view malicious code detection obfuscationdeobfuscation game virus writers researchers working detect malicious code background common obfuscation techniques virus writers section developed obfuscator executables surprisingly commercial virus scanners considered easily thwarted simple obfuscation transformations section cases norton antivirus scanner detect insertions nop instructions general architecture detecting malicious patterns executables introduce general architecture detecting malicious patterns executables overview architecture features section external predicates uninterpreted symbols important elements architecture external predicates summarize results static analyses points-to live-range analysis external predicates referred abstraction patterns describe malicious code uninterpreted symbols patterns makes method resistant renaming common obfuscation transformation key components architecture program annotator malicious code detector sections prototype executables implemented prototype detecting malicious patterns executables tool called static analyzer executables safe successfully safe multiple viruses brevity report experience specific viruses experimental results section demonstrate efficacy safe interesting directions intend pursue future work summarized section extensibility analysis safe depends heavily static analysis techniques result precision tool directly depends static analysis techniques integrated words safe good static analysis techniques built safe result points-to analysis track values memory absence pointsto analyzer safe makes conservative assumption memory access memory location points designed safe static analysis techniques readily integrated simple static analysis techniques implemented safe related work theoretical discussion theoretical limits malicious code detection specifically virus detection focus researchers cohen chess-white showed general problem virus detection undecidable similarly important static analysis problems undecidable computationally hard problem considered paper slightly considered cohen chess-white assume vanilla virus malicious sequence instructions obfuscated versiono virus problem find exists sequence instructions prime ino semantically equivalent recent result vadhan proves general program obfuscation impossible leads computationally bounded adversary obfuscate virus completely hide malicious behavior explore theoretical issues future detection techniques work closely related previous results static analysis techniques verifying security properties software larger context work similar existing research software verification important differences viewing malicious code detection game unique viewpoint lead explore obfuscation attacks commercial virus scanners knowledge existing work static analysis techniques verifying security properties analyze source code hand analysis technique works executables contexts virus detection source code finally uninterpreted variables specification malicious code unique section currie looked problem automatically checking equivalence dsp routines context verifying correctness optimizing transformations approach similar impose set simplifying assumptions simulation tool execute reasonable performance feng approach step theorem prover determine unroll loops cases scope problem limited vliw dsp code limited support userspecified analyses work applied iaassembly full advantage static analyses user safe tool necula adopts similar approach based comparing transformed code sequence original code sequence setting verifying correctness gnu compiler knowledge transformations performed compiler equivalence compiler input compiler output proven simulation relation work require priori knowledge obfuscation transformations performed unrealistic expect information presence malicious code plan enhance framework ideas existing work type systems assembly code investigating morrisett typed assembly language apply simple type system section binaries analyze manually inserting type annotations unaware compiler produce typed assembly language plan support external type annotations enhance power static analysis dynamic monitoring malicious code detection cohen chess-white propose virus detection model executes code 
sandbox approach rewrites binary introduce checks driven enforceable security policy inline monitor irm approach static analysis improve efficiency dynamic analysis techniques static analysis remove redundant checks irm framework construct models executables similar work specification-based monitoring apply detection algorithm context-insensitive fashion research context-sensitive analysis employing push-down systems pdss analyses model checking algorithms pushdown systems verify security properties programs data structures interprocedural slicing interprocedural dfa boolean programs hierarchically structured graphs translated pushdown systems obfuscators deciding initial obfuscation techniques focus influenced existing tools mistfall mbie library binary obfuscation specifically written blend malicious code host program encrypt morph blend virus code host program binary obfuscator similar mistfall successfully morph binaries mistfall perform direct comparison obfuscator mistfall burneye teso linux binary encapsulation tool burneye encrypts binary possibly multiple times packages binary extraction tool paper considered encryption based obfuscation techniques future incorporate encryption based obfuscation techniques tool incorporating extending existing libraries background obfuscating viruses detect obfuscated viruses antivirus software complex section discusses common obfuscation transformations virus writers antivirus software historically dealt obfuscated viruses polymorphic virus multiple techniques prevent signature matching virus code encrypted small in-clear routine designed decrypt code running virus polymorphic virus replicates infecting program encrypts virus body newlygenerated key decryption routine generating code obfuscate decryption routine transformations applied include nop-insertion code transposition changing order instructions placing jump instructions maintain original semantics register reassignment permuting register allocation transformations effectively change virus signature figure inhibiting effective signature scanning antivirus tool obfuscated code figure behave manner nop instruction effect incrementing program counter signature changed analysis detect simple obfuscations nop-insertion regular expressions fixed signatures catch nop insertions signature number nops instruction boundaries figure fact modern antivirus software regular expressions virus signatures antivirus software deals polymorphic viruses performing heuristic analyses code checking program locations virus code polymorphic viruses attach beginning end executable binary emulating program sandbox catch virus action emulation technique effective point execution infected program virus body appears decrypted main memory ready execution detection frequently scanning in-memory image program virus signatures program executes metamorphic viruses attempt evade heuristic detection techniques complex obfuscations replicate viruses change code variety ways code transposition substitution equivalent instruction sequences register reassignment weave virus code host program making detection traditional heuristics impossible virus code mixed program code virus entry point longer beginning program designated entry point obscuring epo viruses virus writers employ complex obfuscation techniques heuristic virus-detection techniques bound fail perform deeper analysis malicious code based sophisticated static-analysis techniques words inspection code detect malicious patterns structures closer semantics code purely syntactic techniques regular expression matching longer adequate suite viruses analyzed multiple viruses tool discuss paper descriptions viruses detailed description viruses chernobyl cih symantec antivirus reseach center sarc chernobyl cih virus infects bit windows executable files user executes infected program windows virus resident memory virus resident cih infects files accessed infected files size original files cih unique mode infection virus searches empty unused spaces file breaks smaller pieces inserts code unused spaces chernobyl payloads overwrites hard disk random data starting beginning disk sector infinite loop payload permanent damage computer corrupting flash bios zombieb mbieb virus includes interesting feature polymorphic engine hides piece virus virus code added infected file chain differently-sized routines making standard signature detection techniques useless virus polymorphic engine combined epo technique hide entry point kaspersky labs infected file run virus code gains control searches portable executable files system directories infects infecting virus encrypts polymorphic loop writes result end file gain control infected file run virus modify program start address writes jmp virus entry instruction middle file original code obfuscated code call call pop ebx pop ebx lea ecx ebx lea ecx ebx push ecx nop push eax push ecx push eax push eax sidt esp push eax pop ebx nop add ebx sidt esp cli pop ebx mov ebp ebx add ebx nop cli mov ebp ebx signature signature cfa figure original code obfuscated code chernobyl cih signatures newly added instructions highlighted figure extended signature catch nop-insertion hare finally hare virus infects bootloader sectors floppy disks hard drives executable programs payload triggered virus overwrites random sectors hard disk making data inaccessible virus spreads polymorphically changing decryption routine encrypting main body hare chernobyl cih viruses antivirus community presence wild peaking spite discovered current commercial virus scanners detect slightly obfuscated versions viruses obfuscation attacks commercial virus scanners tested commercial virus scanners common obfuscation transformations test resilience commercial virus scanners common obfuscation transformations developed obfuscator binaries obfuscator supports common obfuscation transformations dead-code insertion code transposition register reassignment instruction substitution generic obfuscation techniques preferred malicious code writers possibly implementing easy add memory footprint common obfuscation transformations dead-code insertion trash insertion dead-code insertion adds code program modifying behavior inserting sequence nop instructions simplest interesting obfuscations involve constructing challenging code sequences modify program state restore immediately code sequences designed fool antivirus software solely rely signature matching detection mechanism code sequences complicated make automatic analysis timeconsuming impossible passing values memory registers stack requires accurate pointer analysis recover values shown figure clarify code marked easily eliminated automated analysis hand insertions marked cancel analysis complex obfuscator supports dead-code insertion dead-code sequence detected eliminated problem reduces program equivalence code sequence equivalent empty program undecidable common dead-code sequences detected eliminated acceptable performance quote documentation rpme virus permutation engine rash make program complex detecting algorithm written difference nop complex trash detection tool safe identifies kinds dead-code segments code transposition code transposition shuffles instructions order binary image execution order order instructions assumed signature antivirus software achieve variation randomly reorder instructions insert unconditional branches jumps restore original control-flow variation swaps instructions interdependent similar compiler code generation goal randomizing instruction stream versions obfuscation technique differ complexity code transposition technique based unconditional branches easy implement technique interchanges independent instructions complicated independence instructions ascertained analysis side code transposition complicate matters human automatic analysis tools including intermediate representation control flow graph cfg program dependence graph pdg sensitive superfluous control flow note optimizer acts deobfuscator case finding unnecessary unconditional branches removing program code obfuscator supports code transposition based inserting unconditional branches register reassignment register reassignment transformation replaces usage register specific live range technique exchanges register names effect program behavior register ebx dead 
live range register eax replace eax live range cases register reassignment requires insertion prologue epilogue code live range restore state registers binary obfuscator supports code transformation purpose transformation subvert antivirus software analyses rely signaturematching real obfuscatory gained process conceptually deobfuscation challenge equally complex register reassignment instruction substitution obfuscation technique dictionary equivalent instruction sequences replace instruction sequence transformation relies human knowledge equivalent instructions poses toughest challenge automatic detection malicious code iainstruction set rich ways performing operation coupled architecturally ambivalent features memory-based stack accessed stack dedicated instructions memory area standard memory operations iaassembly language ample opportunity instruction substitution handle obfuscation based instruction substitution analysis tool maintain dictionary equivalent instruction sequences similar dictionary generate comprehensive solution cope common cases case iathe problem slightly simplified simple intermediate language unwinds complex operations iain- struction cases theorem prover simplify pvs prove sequences instructions equivalent testing commercial antivirus tools tested commercial virus scanners obfuscated versions viruses earlier results surprising combination nop-insertion code transposition create obfuscated versions viruses commercial virus scanners detect norton antivirus software detect obfuscated version chernobyl virus nopinsertions safe resistant obfuscation transformations results summarized table antivirus software detected virus means software detect virus note unobfuscated versions viruses detected tools architecture section overview architecture safe figure subsequent sections provide detailed descriptions major components safe detect malicious patterns executables build abstract representation malicious code virus abstract representation generalization malicious code incorporates obfuscation transformations superfluous code obfuscated code obfuscated code obfuscated original code dead-code insertion code transposition instruction substitution call call call call pop ebx pop ebx pop ebx pop ebx lea ecx ebx lea ecx ebx jmp lea ecx ebx push ecx nop push eax esp push eax nop push eax sidt esp push eax push ecx sidt esp add esp sidt esp push eax jmp mov ebx esp pop ebx eax add ebx esp add ebx push eax jmp cli cli dec esp lea ecx ebx mov ebp ebx mov ebp ebx dec eax push ecx sidt esp jmp pop ebx pop ebx add ebx cli cli jmp mov ebp ebx mov ebp ebx figure examples obfuscation dead-code insertion code transposition instruction substitution newly added instructions highlighted norton mcafee command safeantivirus virusscan antivirus chernobyl original obfuscated mbieb original obfuscated original obfuscated hare original obfuscated obfuscations considered nop-insertion form dead-code insertion code transposition table results testing virus scanners obfuscated viruses control flow register reassignments similarly construct abstract representation executable find malicious pattern generalization malicious code abstract representation executable created detect malicious code executable describe component safe generalizing malicious code building malicious code automaton malicious code generalized automaton uninterpreted symbols uninterpreted symbols section provide generic representing data dependencies variables specifically referring storage location variable pattern-definition loader component takes library abstraction patterns creates internal representation abstraction patterns alphabet symbols malicious code automaton executable loader component transforms executable internal representation collection control flow graphs cfgs program procedure executable loader figure off-the-shelf components ida pro codesurfer ida pro datarescue commercial interactive disassembler codesurfer grammatech program-understanding tool performs variety static analyses codesurfer api access structures cfgs call graph results variety static analyses points-to analysis collaboration grammatech developed connector transforms ida pro internal structures intermediate form codesurfer parse annotator component inputs cfg executable set abstraction patterns produces annotated cfg abstract representation program procedure annotated cfg includes information specific abstraction pattern found executable annotator runs procedure program transforming cfg section describes annotator detail binaryexecutable annotatedcfgdefinitions pattern static analyzer executables safe maliciousautomatoncode patternsintermediate form executablecfg trace found program malicious codeno loaderexecutable patternloaderdefinition annotator detector figure architecture static analyzer executables safe ida pro connector codesurfer executable loader figure implementation executable loader module detector component computes malicious code represented malicious code automaton appears abstract representation executable created annotator component algorithm based language containment unification details found section rest paper malicious code fragment shown figure running code fragment extracted chernobyl virus version obtain obfuscated code fragment depicted figure applied obfuscation transformations dead-code insertion code transposition register reassignment incidentally commercial antivirus software norton mcafee command detected original code fragment shown obfuscated version detected commercial antivirus software program annotator section describes program annotator detail data structures static analysis concepts detection algorithm program annotator inputs cfg executable set abstraction patterns outputs annotated cfg annotated cfg associates node cfg set patterns match program point node precise syntax abstraction original code wvctf mov eax mov ebx eax mov edi eax lowvctf pop ecx jecxz sfmm mov esi ecx mov eax pop edx pop ecx call edi jmp lowvctf sfmm pop ebx pop eax stc pushf figure original code fragment chernobyl virus version pattern semantics matching provided section figure shows cfg simple annotated cfg obfuscated code figure note node annotated cfg correspond nodes original cfg nodes annotated irrelevantinstr corresponds nop instructions annotations figure intuitive formulating static-analysis framework requires formal definitions enhance safe framework type system based typestate system type systems designed assembly languages typed assembly language safe framework definitions patterns matching procedure sections obfuscated code wvctf mov eax jmp loc loc mov edi eax lowvctf pop ecx jecxz sfmm nop mov esi ecx nop nop mov eax jmp loc loc mov ebx eax jmp loc loc pop edx pop ecx nop call edi jmp lowvctf sfmm pop ebx pop eax push eax pop eax stc pushf figure obfuscated version based code figure basic definitions section formal definitions rest paper program points instruction function application type system preclude higher-order functions function composition important note assembly languages including support concepts program sequence instructions program execution instructions processed sequential order program exception control-flow instructions change sequential execution order index instruction program sequence called program point program counter denoted function defined def set program points program programpoints def function total ordering set program instructions control flow graph basic block maximal sequence instructions control-flow instruction end execution basic block definition sequential set basic blocks program set control flow transitions basic blocks edge marked condition true false edge unconditional jumps outgoing edges marked directed graph cfg called control flow graph predicates predicates mechanism incorporate results static analyses live range points-to analysis predicates definition abstraction patterns table lists predicates system code program points verified dead-code section checking variable live program range 
markov chains classifiers intrusion detection jha tany maxiony abstract paper presents statistical anomaly detection algorithm based markov chains algorithm directly applied intrusion detection discovering anomalous activities framework constructing anomaly detectors general researchers constructing markov-chain-based anomaly detectors present performance metrics evaluating effectiveness anomaly detectors extensive experimental results demonstrate effectiveness algorithm discuss future directions research based framework presented paper introduction intrusion detection system ids system identifies intrusions intrusion defined misuse unauthorized authorized users external adversaries surveys intrusion detection systems found classification intrusion detection systems appears section paper intrusion detection systems based anomaly detection objective anomaly detection establish profiles normal system activity traces system activity deviate profiles considered anomalous alarm raised classes anomaly-detection-based ids signature pattern based ids internal table anomalous patterns ongoing activity matches pattern table alarm raised table patterns represent system traces common attacks examples signature-based intrusion detection systems snort bro advantages signaturebased ids commonly potential low false alarm rates information impart computer sciences department wisconsin madison yschool computer science carnegie mellon pittsburgh system security officer detected attack information encoded rules patterns central functionality systems information invaluable initiating preventive corrective actions signature-based ids disadvantages set anomalous patterns based attacks attacks discovered systems attack discovered patterns attack manually constructed signature-based ids easily fooled sophisticated attacker attacker mix normal activity real attack trace match pre-defined patterns statistical anomaly-detection-based ids henceforth referred statistical ids devised address shortcomings signature-based ids denning nuemann presented detailed discussion statistical anomaly detection algorithm ides prototypical statistical ids statistical ids model normal behavior user constructed statistical model construct classifier discriminate normal anomalous traces techniques presented paper fall category describe procedure generating anomalous patterns statistical model techniques presented paper automatically generate patterns signature-based systems important question anomaly-detection based intrusion detection systems trace system activity represented sequence system calls process trace activity knowledge proposed approach general types traces system activity audit trails statistical approach intrusion detection adheres general strategy set normal traces statistical model constructed statistical model construct classifier discriminate normal abnormal traces key observation statistical model accurate predictor normal behavior on-going activity accurately predicted model anomalous general strategy depicted figure approach general road-map set normal traces construct markov chain markov chain construct classifier main contributions paper provide formal framework constructing classifiers based markov chains investigate applications classifiers intrusion detection provide metrics evaluating effectiveness classifiers context intrusion detection metrics researchers framework general construct classifiers based markov chains outline paper section general outline algorithm detailed description algorithm section section describes algorithm generating set anomalous patterns markov chains algorithm suitable generating anomalous patterns systems snort bro experimental results section section describes related work future work concluding remarks provided section outline methodology section provide step-wise description methodology technical details section assume suites traces tan recall case trace simply sequence system calls generated process suite consists traces normal activity tan consists traces anomalous activity attacks step construct test suite step split suite suite ttr called training suite constructing classifiers suite tte called test suite testing classifiers tuning parameters decide ratio call testing ratio random sampling construct ttr tte trace generate random number uniformly distributed range trace added tte added ttr roughly speaking denotes fraction traces test suite tte step construct classifier training suite ttr construct markov chain turned classifier traces classifier constructed suite normal traces discriminate normal anomalous traces details construction found section step tuning parameters exogenous parameters construction classifier define performance metrics classifier metrics computed suites tte tan exogenous parameters tuned performance metrics detailed description denote set alphabets symbols alphabets symbols synonymously paper trace finite sequence alphabets set finite traces denoted empty trace denoted set traces length denoted trace denotes length trace trace positive integer denote prefix consisting alphabets i-th symbol concatenation traces denoted denotes binary alphabet set definition classifier alphabet set total function suite subset experiments types suites training suite ttr training test suite tte testing anomalous suite tan set anomalous traces training suite set normal traces construct classifier test suite set normal traces test tune classifier anomalous suite set anomalous abnormal traces note reader interpret bad good context intrusion detection classifier outputs reading trace interpreted alarm anomalous happening hand normal behavior general classification problem finite number classes universe objects classified classifier function context intrusion detection classify traces normal anomalous intrusion detection on-line activity alarms raised real-time purposes intrusion detection unacceptable watch entire sequence activities equivalently scan entire trace classify sequence formalize sample normal behavior statistical model classifiertrace processbehavior normal anomalous alarms figure general strategy intrusion detection means classifier on-line intuitively on-line classifier efficiently classify trace length based history classifier prefix symbols definition classifier called on-line exists efficiently computable functions equations hold equations length trace denoted types functions easily inferred equations notice function trace depends function symbols trace sense depends history efficiently computed loosely speaking function markov depends history current state assume finite set traces classifier outputs scanning trace suffix set classifier outputs words classifier outputs alarm detects pattern set faaa baag classifier outputs scanning acaaa acbaaa classifiers model signature-based intrusion detection systems set finite traces compiled deterministic precise definition efficiently computable depends statistical model case efficiently computable means polynomial number states markov chain finite state automata observation easily signature based ids corresponds online classifier finite table patterns regular language alphabet trace iff suffix trace deterministic finite state automata definition next-state transition function automata transition function extended traces standard manner identifier state initial state automata function simply mimics next-state transition function equality assume state automate identifier real number function maps identifier final state automata rest real numbers mapped easy verify required properties efficiently computable constructing markov chains assume training suite ttr suite ttr construct markov chain subsection demonstrate construct classifier markov chain construction markov chain parametrized window size augment alphabet set special null symbol provide background markov chains paper interested readers consult standard text probability theory required background describe algorithm construct markov chain suite ttr define primitive operations state markov chain trace length alphabet transition pair states pair denotes transition state transition counter maintain hash table visited states hash function hash table crucial description algorithm primitive operation shift shifts trace left appends alphabet end shift aba equal bac initial state markov chain denoted initialstate 
trace length consisting null symbols initial state trace operation returns symbol trace left shifts position abc returns updates trace trace ttr execute steps alphabets scanned set next-state shift current-state increment counter state current-state transition current-state next-state update current-state next-state traces suite ttr processed state transition positive integer probability transition counters transition words probability transition ratio frequency transition frequency source suite ttr assume training suite ttr faabc abcbcg structure constructed scanning traces training suite ttr shown figure figure shows counters states transitions markov chains classifiers assume markov chain training suite ttr window size constructed denote markov chain -tuple set states denotes transition probabilities initial state probability transition denoted order valid measure equality hold states succ succ denotes set successors trace length state denotes recall trace initial state trace consisting null alphabets trace recall denotes alphabet trace initial trace trace initial state trace scanning symbol shift trace obtained scanning k-th symbol recursively defined shift trace defines sequence traces trace length define metric trace metric based markov chain computed iteratively initially equal equal execute steps cases case valid transition states markov chain update equations case state valid transition update equations increment metric defined end procedure procedure outlined defines function intuitively metric measures markov chain predicts trace lower markov chain predicts trace notice parametrized functions number choices result classifiers aab abc bcb cbc figure markov structure assume threshold classifier constructed metric manner words trace classified bad metric threshold note easily classifier on-line definition define function variables defined procedure computing function definition easily derived description procedure compute function classifier construct on-line classifier complexity functions linear number states markov chain discussion trace metric depends entire trace recall procedure maintains cumulative values metric defined call metric global classifier based global metric called global describe local classifier recall trace corresponds sequence traces trace length positive integer scanning i-th symbol trace history size minimum history size corresponds vectors defined valid transition states markov chain case defined state case defined local metric trace defined yip min words local metric computed history past symbols classifier based local metric called local classifier implemented local classifiers system experiments global classifiers consistently out-performed local counterparts presented results local classifiers discuss common functions depending choice functions obtain classifiers miss-probability metric case functions defined succ succ function adds probabilities transitions state equal words scanning trace low probability transition higher miss-rate metric pmax max succ pmax case transition equal maximal transition transition maximum probability penalized equally local-entropy-reduction metric state local entropy state denoted succ log entropy markov chain steady state probability state descriptions markov chains entropy found functions case defined log transition expression log evaluates succ log words denotes residual local entropy state deleting transition local entropy reduction due taking transition performance metrics section discuss performance metrics evaluating effectiveness classifier assume constructed classifier training suite ttr tte tan denote test anomalous suite trace number alarms classifier generates denoted alarm expression words number alarms number classifier generates scanning trace test suite tte consists normal traces percentage false alarms test suite tte classifier expression tte alarm tte percentage false alarms classifier generates test suite tte denoted tte high percentage false alarms undesirable alarm ids attended system administrator experience system administrator encounters high percentage false alarms turn ids anomalous traces good classifier generate alarm quickly anomalous traces define time alarm mtfa anomalous trace classifier generate alarm scanning dmtfa symbols classifier trace alarm defined minfijf words scanning trace classifier generates alarm reading alarm -th symbol mtfa anomalous suite tan classifier denoted mtfa tan expression tan alarm jtanj expression jtanj denotes number traces tan size suite intuitively speaking metric mtfa measures fast classifier detects anomalous trace generalize metric mtfa time k-th alarm mtka time classifier generates k-th alarm paper mtfa tuning parameters recall method exogenous parameters constructing classifier training suite ttr parameters window size functions real number threshold assume functions real number determined discuss decide values parameters window size increases markov chain constructed model training suite ttr large markov chain models training suite classical over-fitting problem statistics metric defined earlier intuitively measure discrepancy markov chain trace lower denotes fit discrepancy ttt entire test suite ttt ttt ttt discrepancy tan anomalous suite tan defined similar manner increasing window size separation tan ttt anomalous test suites threshold means classifier discriminate anomalous normal traces provide detailed account experimental section assume window size determined describe set threshold threshold low anomalous trace classifier generate alarm quickly low means lower mtfa lower threshold generates false alarms normal traces inconvenient system administrator tradeoff setting threshold low set threshold percentage false alarms test suite mtfa anomalous suite acceptable level details tuning parameters found experimental section generating anomalous patterns classifiers intrusion detection systems commercially signature-based systems recall signature-based ids relies table anomalous patterns suffix trace activity matches pattern table alarm raised patterns table correspond common attacks simply patterns represent normal behavior system classifiers constructed markov chains discussed section general simply table patterns fit current architecture systems section address mis-match describe algorithm constructs table anomalous patterns markov chain constructed training suite ttr recall markov chain -tuple set states denotes transition probability initial state reader refer subsection explanation terms metric defines total order traces procedure computing metric subsection procedure subsection started initial state procedure started state markov chain defines metric intuitively defines metric initial state markov chain recall state unique trace length state trace synonymously section xmg alphabet set context system calls suites algorithm based function pattern function returns set trace satisfy conditions trace length equal number traces equal traces exists trace words represents set traces length equal highest s-value represent worse traces length equal give recursive definition function pattern recursion parameter base case case pattern words set traces patterns empty trace recursion state trace shift words trace constructed shifting trace appending i-th alphabet assume set traces pattern computed states give definition set pattern terms sets pattern pattern sake brevity denote set pattern suppose transition corresponds alphabet trace shift trace state construct set formally defined fxi wig words add front trace compute metric trace sets construct set traces expression pattern traces sorted values function intuitively sort traces denotes markov chain model trace traces 
bad fits set pattern defined traces sorted order correctness trace thatj pattern prove exists trace pattern prove result induction result obvious trace length empty trace assume result true induction hypothesis exists pattern notice construct set pattern sorting set metric pattern exists trace pattern result proved suppose alphabet state shift set pattern suffix starting symbol induction hypothesis cases case pattern trace set pattern set sorted metric result case pattern case exists pattern nature metric inequality easily notice set result improving efficiency notice efficiently computed metrics paper time transition probabilities transition corresponds alphabet recall procedure computing metric suppose trace initial state information computed -time values trace initial state valid transition markov chain values trace metric trace simply trace set pattern values traces recursive step efficient compute pattern store re-use called memeoazation number traces denoted length alphabet easily checked algorithm modifications runs nlk steps step log time notice worst case complexity algorithm exponential size alphabet suspect practice algorithm run faster computational complexity problem heuristics improving efficiency left future work algorithm generates set anomalous traces markov chain trained suite normal traces suppose train markov chain mcan suite anomalous traces case generate set patterns traces fit markov model mcan easily variant algorithm sorting descending order metric sort ascending order obtain traces low -value fit markov model mcan experimental results suites study obtained large body work performed researchers computer science department mexico evaluating anomaly-detection algorithms original experiments employed suites results published data consists traces privileged unix programs trace operating anomalydetector called stide trace sequence system calls issued single process execution privileged programs targeted monitoring misuse greatest harm host noted system calls recorded traces parameters passed system calls datasets comprises data obtained wide variety circumstances data obtained monitoring normal usage program field data obtained monitoring programs run daemons programs vary widely size complexity kinds intrusions importantly provide insight algorithm perform field body data consists combination live synthetic traces live defined traces programs collected normal usage production computer system synthetic defined traces collected production environments running prepared script program options chosen solely purpose exercising program meet real user requests anomalous data obtained recording system calls monitored programs intrusion present intrusions obtained public advisories posted internet detailed information kinds intrusions dataset found table shown figure lists programs monitored normal behavior names intrusions deployed obtain intrusive data figures show difference discrepancy anomalous test suite classifiers column table corresponds number suite subsequent columns show results window sizes construct markov chain column shows results window size construct markov chain component entry corresponds test suite component shows results anomalous suite set window size classifier discrepancy test anomalous suites suites normal trace leave traces construct test suite cases mark component test suite dan dtt discrepancy test anomalous suite ideally dan dtt large means classifier test suite worse anomalous suite observing data points made suites start observing difference discrepancies suite difference discrepancies pronounced window size suite difference significant window size classifiers based miss-probability miss-rate metric outperform based local-entropy metric results classifiers based missprobability miss-rate comparable suite set window size difference discrepancies dan dtt acceptable level set window size suite suites window size set initially threshold set dan dtt average discrepancies anomalous test suites suites normal trace case dtt cases set initial threshold dan conducted experiments thresholds initial threshold lower threshold means mtfa anomalous suite low generate alarm earlier anomalous trace lower threshold means percentage false alarms test suite large tradeoff setting threshold conducted extensive experiments thresholds sake brevity report results threshold values classifier based miss-probability metric figure shows experimental results initial threshold observations made data percentage false alarms decreases threshold increases time alarm mtfa increases threshold increases suites show mentioned behavior results suite dataset system normal anomalous intrusion synthetic xlock linux traces traces buffer overflow calls calls live xlock linux trace traces buffer overflow calls calls live named linux traces traces buffer overflow calls calls live login linux traces traces trojanized login calls calls program live linux traces traces trojanized calls calls program live inetd linux traces traces denial calls calls service live lpr mit sunos traces traces symbolic link calls calls attack live lpr unm sunos traces traces symbolic calls calls attack live stide linux traces traces denial calls calls service figure explanation data sets false alarm rates suites low recall suite difference discrepancies large remark classifier generates alarm scanning anomalous trace trace classified anomalous hit rate classifier defined percentage traces anomalous suite tan classified anomalous experiments discovered hit rate close hit rate good metric classifiers considered paper percentage false alarms time alarm measures effectiveness devising metrics quantifying classifiers received scarce attention intrusion detection literature related work compare work intrusion detection schemes based statistical anomaly detection pointed intrusion detection system ides ides large scale system considered classes events considered traces system calls direct comparison ides technique compare technique recent statistical anomaly detection schemes nassehi describes anomaly detection scheme based markov chains anomaly detection algorithm presented paper nassehi constructs markov chain window size vector normalized frequencies transitions markov chain based sample training ongoing activity traced markov chain maintaining history window vector normalized frequencies transitions history alarm raised condition holds matrix threshold detail number transitions states markov chain time symbol scanned time required prohibitively expensive large intrusion detection systems contrast anomaly detection scheme requires constant time symbol scanned warrender hidden markov models hmms underlying model results reported comparable presented paper training algorithm hmms expensive runs time number states hmm size trace contrast training time markov chains symbol case system call method takes time anomaly detector takes constant time process symbol generate alarms faster undertaken rigorous study hmms anomaly detection work ongoing report results future date instance learning based algorithm anomaly detection algorithm masquerade detection user acting user started investigating techniques extending algorithm masquerade detection applications anomaly detection uncovering stealthy portscans devising algorithm similar presented paper detecting stealthy port scans section describes algorithm generating anomalous patterns markov models implemented algorithm provide detailed comparison algorithm algorithms data mining based technique generating anomalous patterns rules intrusion detection system based information retrieval techniques approach discovering anomalous patterns rules based inductive learning presented implementation algorithm finished perform detailed comparison approach techniques 
buffer overrun detection linear programming static analysis vinod ganapathy somesh jha wisconsin-madison jha wisc david chandler david melski david vitek grammatech ithaca chandler melski dvitek grammatech abstract paper addresses issue identifying buffer overrun vulnerabilities statically analyzing source code demonstrate light-weight analysis based modeling string manipulations linear program present fast scalable solvers based linear programming demonstrate techniques make program analysis context sensitive based techniques built prototype identify vulnerabilities popular security critical applications categories subject descriptors language constructs features constraints optimization linear programming software engineering testing debugging general terms algorithms languages reliability security keywords buffer overruns static analysis linear programming introduction buffer overruns exploited class security vulnerabilities study sans institute buffer overruns rpc services ranked top vulnerability unix systems simple mistake part careless programmer security problem consequences remote user acquiring root privileges vulnerable machine add problem vulnerabilities easy exploit cookbooks construct exploits observed researchers highly vulnerable library functions manipulate buffers unsafe approaches proposed mitigate problem range dynamic techniques prevent attacks based buffer overruns static techniques work supported part nsf grant ccrand onr contracts permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee ccs october washington usa copyright acm examine source code eliminate bugs code deployed unlike static techniques dynamic techniques eliminate bugs typically undesirable effect causing application crash attack discovered paper describe design implementation tool statically analyzes source code detect buffer overrun vulnerabilities paper demonstrates static analysis model string manipulations linear program design implementation fast scalable solvers based techniques linear programming literature solution linear program determines buffer bounds techniques make program analysis context sensitive efficacy program analysis techniques static slicing understand eliminate bugs source code principle design goals make tool scale large real world applications tool audit popular commercially packages tool identified previously unknown buffer overruns wu-ftpdsection addition vulnerabilities applications rest paper laid discuss related research section description tool section section describes constraint resolution techniques tool section describes techniques make program analysis context-sensitive section experimental results section concludes related work techniques proposed mitigate problem buffer overruns dynamic techniques stackguard rad detect prevent stack smashing attacks protecting return address stack propolice generalizes techniques protecting entities frame pointers local variables function arguments pointguard protects pointer accesses encrypting pointers stored memory decrypting loaded registers safe languages java introduce runtime array bounds checks preserve type-safety redundant runtime checks impose performance overhead tools abcd aim eliminate redundant checks ccured tool static analysis judiciously insert runtime checks correctness pointer manipulations create type-safe version program techniques prevent attacks based unsafe memory accesses fail eliminate bugs source code paper focuses static analysis techniques examine source code presence buffer overruns developer eliminating overrun source code deployed static analysis tools proposed tools broadly classified annotation driven tools tools symbolic analysis tools extract model source code detect presence bugs cssv splint annotation driven tools tools user-supplied annotations preand post-conditions function aid static analysis cssv aims find buffer overflows false alarms basic idea convert program integer program correctness assertions included conservative static analysis algorithm detect faulty integer manipulations directly translate bugs source code analysis performed per-procedure basis annotations called contracts make analysis inter-procedural number false alarms generated tool depends accuracy contracts analysis cssv check correctness integer manipulations heavyweight scale poorly large programs instance cssv seconds analyze string manipulation program total lines code splint hand sacrifices soundness completeness light-weight static analysis detect bugs source code splint flow-sensitive intra-procedural program analysis user supplied preand post-conditions make analysis inter-procedural archer tool functions symbolically executing code maintaining information variables database execution proceeds current state program values database execution program statements potentially change state program statements access buffers archer checks database access bounds array flags error rugina rinard describe tool geared specifically detect out-of-bounds errors race conditions small divide conquer programs determine symbolic bounds array indices information detect illegal accesses larson austin propose testing tool detect input related faults tool actual program execution test input enhances bug coverage maintaining information values variables path test input techniques advantage detect array bounds accesses demonstrated analysis path sensitive actual program path false alarm rates low disadvantage coverage tools limited set program paths examined boon tool extracts model source code tools model strings abstract data types transform buffer overrun detection problem range analysis problem boon employ precise pointer analysis algorithms analysis flowand contextinsensitive tool builds seminal ideas introduced boon precise pointer analysis algorithms enhances program analysis make context-sensitive additionally tool employs algorithms based linear programming constraint resolution opposed custom built range solver employed boon tool equips user static analysis algorithms static slicing enable user understand reason bug tool architecture tool components figure remainder section section describes code understanding tool codesurfer codesurfer constraint sdg pdgs constraintgenerator taintanalyzer constraintsolver detectorfront end sdg pdgs linear constraints linearconstraints warnings rangesranges solverschoice source codesurfer figure architecture buffer overrun tool main int argc char argv char header buf ptr int counter file ptr fgets header copy buffer header counter counter counter ptr fgets buf copy buffer buf char copy buffer char buffer char copy copy char malloc strlen buffer strcpy copy buffer return copy figure running generator detector front-end gui user examine potential overruns section describes constraint generation section presents taint analysis identifies removes unconstrained constraint variables section overviews constraint resolution section explains solution constraint system detect potential buffer overruns program figure serve running codesurfer constraint generator detector front-end developed plug-ins codesurfer codesurfer code understanding tool originally designed compute precise interprocedural slices codesurfer builds program representation includes system dependence graph composed program dependence graphs procedure interprocedural control-flow graph abstract syntax trees asts program expressions side-effect information points-to information codesurfer presents user gui exploring internal program representations queries codesurfer supports include forward backward slicing program point precise inter-procedural chopping program points finding data control dependence predecessors successors program point examining points-to set program variable codesurfer presents user listing source code hot user click program point code queries listed codesurfer primary tool constraint generator codesurfer plug-in makes codesurfer asts pointer analysis based andersen analysis constraint stmt header max header min buffer max buf max buffer 
obvious connections hypothesis testing intrusion detection markov model constructed test suite trace testing hypothesis generated distribution implied markov model reject hypothesis trace anomalous trace algorithm hypothesis testing apriori bound number trials sequential probability ratio test developed abraham wald plan investigate literature hypothesis testing detail order find connections algorithm future work directions future work improve space time efficiency algorithms methodology investigate computation complexity algorithm generating anomalous patterns section devise heuristics improving efficiency algorithm generate models traces system calls investigate events related system activity audit trail data network traffic markov-chain based classifier paper implemented part library developed wisconsin innumber figure results miss-probability metric number figure results miss-rate metric number figure results local-entropy-reduction metric number mtfa mtfa mtfa figure results thresholds corporate statistical models hidden markov models library goal incorporate wide variety classification techniques test effectiveness context intrusion detection plan implement algorithms existing intrusion detection systems snort bro interested investigating specialized applications statistical anomaly detection algorithm detecting stealthy port scans conclusion paper presented anomaly detection algorithm based markov chains presented general framework constructing classifiers markov chains presented specific classifiers based framework performance metrics test classifiers defined experimental results demonstrated effectiveness approach classifiers easily incorporated intrusion detection system paper creates avenues future work previous section pursuing directions acknowledgement referees csfw helpful comments thankful referee pointed connection hypothesis testing allen christie fithen mchugh pickel stoner state practice intrusion detection technologies technical report cmu sei-tr- software engineering institute carnegie mellon january anderson khattak information retrieval techniques intrusion detection proceedings international workshop recent advances intrusion detection raid september cormen leiserson rivest introduction algorithms mit press cover thomas elements information theory john wiley sons denning nuemann requirements model ides real-time intrusion detection expert system technical report technical report csl sri international august devroye gyorfi lugosi probabilistic theory pattern recognition springer verlag durrett probability theory examples duxbury press edition elliott aggoun moore hidden markov models estimation control springer verlag forrest hofmeyr somayaji longstaff sense unix processes ieee symposium security privacy pages hogg tanis probability statistical inference prentice hall ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march lane brodley temporal sequence learning data reduction anomaly detection acm transactions information system security august lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy lunt automated audit trail analysis intrusion detection survey proceedings -th national computer security conference baltimore pages october lunt tamaru gilham jagannathan neumann javitz valdes garvey real-time intrusion detection expert system ides -final technical report technical report technical report computer science laboratory sri international menlo park california february mcauliffe schaefer wolcott haley kalem hubbard computer misused proceedings sixth computer security applications conference pages december mukherjee heberlein levitt network intrusion detection ieee network june nassehi anomaly detection markov models technical report tech report ibm research division zurich research laboratory march northcutt network intrusion detection analyst handbook riders nuemann compartive anatomy computer system network anomaly detection technical report csl sri bnmenlo park paxon bro system detecting network intruders real-time proceedings -th usenix security symposium san antonio texas roesch snortlightweight intrusion detection networks proceedings usenix lisa conference november staniford hoagland mcalerney practical automated detection stealthy portscans proceedings acm ccs ids workshop november teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy pages wald sequential analysis john wiley sons warrender forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy pages 
point point change program points denoted delta implemented polyhedral analysis explanations static analysis predicates shown table standard found compiler textbook instructions data types type constructors build simple integer types listed ground class types array types variations pointer-to-startof-array type type structures unions pointers functions special types andlatticetop complete type system lattice andlatticetop represent types stored bits specific type latticetop specific type table describes constructors allowed type system type represents type field member structure field type independent types fields structure offset uniquely determines location field structure label identifies field structure cases label undefined physical subtyping takes account layout values memory type physical subtype prime denoted prime memory layout type prime prefix memory layout type describe rules physical subtyping refer reader thesis detailed account typestate system mov eax jmp mov ebx eax mov edi eax loop pop ecx jecxz nop pop ebx mov esi ecx nop nop mov eax jmp pop edx jmp pop ecx nop call edi jmp loop pop eax push eax pop eax stc pushf mov eax jmp assign eax mov ebx eax irrelevantjump jmp assign ebx eax irrelevantjump mov edi eax assign edi eax loop pop ecxloop pop ecx jecxz ecx nop pop ebx irrelevantinstr mov esi ecxassign esi ecx nopirrelevantinstr nop mov eax hassign eax jmp irrelevantjump pop edxpop edx pop ecxpop ecx nopirrelevantinstr call ediindirectcall edi jmp loopgoto loop pop ebx pop eaxpop eax push eaxirrelevantinstr pop eax stcassign carry pushfpush flags figure control flow graph obfuscated code fragment annotations dominators set basic blocks dominate basic block postdominators set basic blocks dominated basic block pred set basic blocks immediately precede succ set basic blocks immediately follow instruction basic block instruction basic block previous bprime pred prime iprime iprime bprime succ prime iprime iprime kills true instruction program point kills variable true instruction program point variable alias true variable alias program point liverangestart set program points start live range includes liverangeend set program points end live range includes delta difference integer variables program point delta change program points pointsto true variable points location program point table examples static analysis predicates ground ground types pointer base array type size pointer middle array type size ptr pointer structure product types union function latticetop top type bits bottom type bits type bits member labeled type offset ground int uint table simple type system including subtyping rules type int represents signed integer covers wide variety values storage locations parametrized parameters represents number highest bits number middle bits represent sign number lowest bits represent type int total bits bracehtipupleft bracehtipupright bracehtipupleft bracehtipupright sign bracehtipupleft bracehtipupright typeuint represents unsigned integer variation int middle sign bits set notation int separation data storage location type assembly languages storage location larger required data type stored byte stored right-aligned -bit word type int means instruction xor significant byte -bit word preserve leftmost bits -bit word instruction addresses memory -bit word boundary separation data storage location raises issue alignment information computer systems require prefer data memory address aligned data size -bit integers aligned -byte boundaries drawback accessing unaligned -bit integer leads slowdown due aligned memory accesses exception requires handling software presently alignment information provide significant covert changing program flow figure shows types operands section code chernobyl cih virus table illustrates type system intel iaarchitecture iadata types covered table including bit strings byte strings -bit packed simd types bcd packed bcd formats code type call pop ebx ebx lea ecx ebx ecx ebx ptr push ecx ecx push eax eax push eax eax sidt esp pop ebx eax add ebx ebx int cli mov ebp ebx ebp ebx ptr figure inferred types chernobyl cih virus code ialogical address combination -bit segment selector -bit segment offset type cross product -bit unsigned integer -bit pointer abstraction patterns abstraction pattern -tuple list typed variables sequence instructions boolean expression combining static analysis predicates program points formally pattern -tuple defined boolean expression involving static analysis predicates logical operators instruction sequence number arguments argument literal free variable write denote pattern free variables pattern shown int int pop add afh liverangestart pattern represents instructions pop register stack add constant note uninterpreted symbol pattern uninterpreted symbols pattern match multiple sequences instructions patterns shown matches instantiation pattern assigned specific register type int represents integer bits storage sign bit define binding set pairs variable formally binding defined prime prime pair occurs binding write bindings compatible bind variable values compatible def union compatible bindings includes pairs bindings incompatible bindings union operation returns empty binding def compatible compatible matching abstraction pattern sequence instructions unification bind free variables actual values function unify opi returns general bindingbif instruction sequence opi unified sequence instructions pattern instruction sequences unified unify returns false definitions algorithms related unification standard found annotator operation annotator associates set matching patterns node cfg annotated cfg program procedure respect set patterns denoted assume node cfg corresponds program point instruction annotator attempts match possibly interprocedural instruction sequence previous previous patterns set cfg node labeled list pairs patterns bindings satisfy condition annotation unify unify returns false unification node annotated note pattern times albeit bindings annotation pair unique annotation set node iadatatype type expression byte unsigned int uint word unsigned int uint doubleword unsigned int uint quadword unsigned int uint double quadword unsigned int uint byte signed int int word signed int int doubleword signed int int quadword signed int int double quadword signed int int single precision float float double precision float float double extended precision float float pointer pointer logical address uint uint eax ebx ecx edx esi edi ebp esp eip int table iadatatypes expression type system table detector detector takes inputs annotated cfg executable program procedure malicious code automaton malicious pattern malicious code automaton found annotated cfg detector returns sequence instructions exhibiting pattern detector returns malicious pattern found annotated cfg malicious-code automaton intuitively malicious code automaton generalization vanilla virus malicious code automaton represents obfuscated strains virus formally malicious code automaton mca ais -tuple set typed variables finite alphabet patterns parametrized variables finite set states transition function non-empty set initial states non-empty set final states mca generalization ordinary finite-state automaton alphabets finite set 
min buf min buffer alloc max buf alloc max buffer alloc min buf alloc min copy buffer return alloc max copy alloc max copy buffer return alloc min copy alloc min copy buffer return max copy max copy buffer return min copy min max copy buffer return max min copy buffer return min alloc max copy buffer return alloc max alloc min copy buffer return alloc min counter max counter max counter max counter max counter min counter min counter min counter min figure constraints running detector front-end codesurfer plug-in codesurfer gui order display potential overruns information potential overruns linked codesurfer internal program representation user make codesurfer features slicing order examine potential overruns constraint generation constraint generation tool similar approach proposed boon points-to information returned codesurfer allowing precise constraints pointer buf character buffer modeled constraint variables buf alloc max buf alloc min denote maximum minimum number bytes allocated buffer buf max buf min denote maximum minimum number bytes buffer integer variable modeled constraint variables max min represent maximum minimum program statements operate character buffers integer variables modeled linear constraints constraint variables constraints model program flowand context insensitive manner exception library functions manipulate character buffers flow-insensitive analysis ignores order statements context-insensitive analysis differentiate multiple call-sites function function call library function manipulates strings strcpy strlen generate constraints model effect call functions constraint model context-sensitive section show extended model make constraints context-sensitive user defined functions constraints generated single pass program statements program statements result constraint generation buffer declarations assignments function calls return statements buffer declaration aschar buf results constraints buf size statement assigns character buffer buf results constraints reflect effect assignment buf max buf min assignment integer results constraints max min mentioned function call library function manipulates string buffers modeled constraints summarize effect call strcpy statement line figure results constraints copy max buffer max copy min buffer min user-defined function foo constraint variables foo formal parameters integers strings foo returns integer string constraint variables copy buffer return max function return call user-defined function modeled constraints passing actual parameters assignment function return boon constraints pointers character buffers character buffers means aliasing character buffers modeled constraints false negatives result chose follow boon regard interested improving precision context sensitive program analysis section context-sensitive pointer analysis scale context-insensitive pointer analysis undermine aim performing context-sensitive buffer overrun analysis discovered make pointer analysis eliminate false negatives instance statement strcpy buf point structure constraints generated statement relate constraint variables buf results pointer analysis handle arbitrary levels dereferencing constraint generation makes pointer information integers figure shows constraints program figure program statement generated constraints self-explanatory comments order model control flow ignore predicates constraint generation figure predicate counter line statement counter interesting generating linear constraints linear constraint counter max counter max interpreted linear program solver model statement treating pair statements counter counter counter counter constraints capture fact counter incremented translated constraints acceptable linear program solver resulting linear program infeasible section program variable acquires environment user input unguarded manner considered unsafe instance statement getenv path returns search path return arbitrarily long string reflect fact string arbitrarily long generate constraints getenv return max getenv return min similarly integer variable accepted user input rise constraints max min taint analysis linear constraints pass taint analysis module main goal taint analysis module make constraints amenable solvers presented section solvers linear programming work finite values requires remove variables obtain infinite values section demonstrate importance max variables finite lower bounds min variables finite upper bounds taint analysis aims identify remove variables infinite mentioned section constraint variables var constraints form var var taint analysis identifies constraint variables directly indirectly set removes set constraints identify remove uninitialized constraint variables system constraints examined max constraint variables finite lower bound min constraint variables finite upper bound refer constraint variables satisfy requirement uninitialized constraint variables fail satisfy requirement program variables correspond initialized source code program statements affect program variables captured constraint generator case arise constraint generator model library function affects program variable important realize analysis meant capture uninitialized program variables meant capture uninitialized constraint variables constraints obtained program figure variables removed taint analysis module assuming modeled library functions strlen fgets strcpy correctly taint analysis algorithm presented detail constraint solving constraints remain taint analysis solved linear programming developed solvers linear programming obtain values constraint variables goal solvers obtain estimate number bytes allocated buffer execution program buffer pointed buf finding number bytes corresponds finding tightest range buf min buf max finding lowest highest values constraint variables buf max buf min satisfy constraints similarly find tightest range number bytes allocated buffer finding lowest highest values buf alloc max buf alloc min program figure constraint variables values shown figure explain detail section values obtained detecting overruns based values inferred solver values inferred taint analysis module detector decides overrun buffer heuristics give judgment explain context values figure solver found buffer pointed header bytes allocated length bytes scenario buffer overrun occur buffer pointed header flagged safe true buffer pointed buf buffer pointed ptr found bytes allocated bytes note ptr part assignment statements assignment statement make ptr point buffer long bytes statement make ptr point buffer long bytes flow insensitivity analysis means differentiate program points infer ptr bytes long scenario ptr max bigger ptr alloc min smaller equal ptr alloc max conservatively conclude overrun result false positive due flow insensitivity analysis cases program variable copy observe copy alloc max copy max run program bytes written buffer hold conclude overrun buffer variable min max header header alloc buf buf alloc alloc ptr ptr alloc alloc buffer buffer alloc copy copy alloc counter figure values constraint variables developed gui front end enables end-user surf warnings warning linked back source code line refers user exploit program slicing capabilities codesurfer verify real overruns constraint resolution linear programming section describes solvers based linear programming tool solve set generated constraints chose linear programming reasons linear programming model arbitrary linear constraints solver automatically evolves handle kinds constraints tools specialized solvers generation kinds constraints solvers specially adapted deal commercial implementations linear program solvers scale efficiently millions constraints developed theory helped easily reason correctness solvers finally working dual linear program diagnostic 
patterns defined set typed variables bindingbfor variables finite-state automaton obtained substituting inais denoted byb note thatb vanilla finite-state automaton explain mcaashown figure automata obtained acorresponding bindingsb andb shown figure uninterpreted variables mca introduced handle obfuscation transformations based register reassignment malicious code automaton code fragment shown figure chernobyl virus depicted figure move move pop pop mov esi ecx mov eax pop edx pop ecx esi ecx eax edx mov esi eax mov ebx pop ecx pop eax esi eax ebx ecx figure malicious code automaton chernobyl virus code fragment instantiations register assignments shown respective bindings irrelevantjump move irrelevantjump move irrelevantjump move irrelevantjump pop irrelevantjump jumpifecxiszero jumpifecxiszero irrelevantjump move irrelevantjump move irrelevantjump pop irrelevantjump pop irrelevantjump indirectcall jump irrelevantjump irrelevantjump pop irrelevantjump pop irrelevantjump setcarryflag irrelevantjump pusheflags irrelevantjump figure malicious code automaton code fragment figure detector operation detector takes inputs annotated cfg program procedure malicious code automaton mca note set patterns construct annotated cfg alphabet malicious code automaton intuitively detector determines exists malicious pattern occurs inaand formalize intuitive notion annotated cfg finite-state automaton nodes states edges represent transitions node entry point initial state node final state detector determines language empty parenleftbigg uniondisplay ball parenrightbigg expression language annotated cfg andball set bindings variables set words detector determines exists bindingbsuch intersection languages andb non-empty detection algorithm similar classic algorithm determining intersection regular languages non-empty due presence variables perform unification algorithm algorithm figure combines classic algorithm computing intersection regular languages unification implemented algorithm data-flow analysis node annotated cfg associate pre post lists lpren lpostn element list pair state mcaaandbis binding variables intuitively lpren forawith binding forb state node initial condition initially lists nodes start node empty pre list start node list pairs initial state mca post list start node empty do-until loop do-until loop updates pre post lists nodes end loop worklist set nodes pre post information changed loop executes pre post information nodes change fixed point reached join operation computes lprei takes list state-binding pairs lpostj sets program points preceding copies lprei repeated states case repeated states conflicting pairs merged single pair bindings compatible bindings incompatible pairs thrown diagnostic feedback suppose algorithm returns non-empty set meaning malicious pattern common annotated cfg mca case return sequence instructions executable malicious pattern achieved keeping additional structure algorithm time post list node updated taking transition ina statement figure store predecessor added state added lpostn add edge bindingbs structure suppose detect lpostn state final state mca traceback structure reach initial state ofa storing instructions occurring experimental data major goals experiments measure execution time tool find false positive negative rates constructed ten obfuscated versions viruses denote k-th version i-th virus obfuscated versions created varying obfuscation parameters number nops inserted jumps i-th virus denoted vanilla unobfuscated version virus malicious code automata viruses testing environment testing environment consisted microsoft windows machine hardware configuration included amd athlon ghz processor ram codesurfer version patchlevel ida pro version testing malicious code describe testing respect virus testing viruses analogous ran safe versions virus malicious code automaton experiment gave false negative rate pattern detected versions virus annotator detector avg std dev avg std dev chernobyl mbieb hare table safe performance checking obfuscated viruses false negatives executed safe versions viruses malicious code automaton negationslash helped find false positive rate safe experiments found safe false positive negative rate measured execution times run ida pro codesurfer implemented measure execution times components report average standard deviation execution times tables annotator detector avg std dev avg std dev mbieb hare table safe performance checking obfuscated viruses false positives chernobyl cih virus testing benign code considered suite benign programs section descriptions benign program executed safe malicious code automaton viruses detector reported negative case false positive rate average variance execution times reported table results cases execution times unacceptably large address performance enhancements safe future descriptions benign executables tiffdither exe command line utility cygwin toolkit version unix environment windows developed red hat input list patterns malicious code automaton annotated cfg output true program infected false maliciouscodechecking lpren entry node foreach lpren foreach lpostn wsold foreach update pre information lpren negationslash uniontextm previous lpostm lpren uniontextm previous lpostm foreach update post information newlpostn foreach lpren foreach annotation follow transition compatible add newlpostn lpostn negationslash newlpostn lpostn newlpostn return lpostn figure algorithm check program model malicious code specification winmine exe microsoft windows minesweeper game version spyxx exe microsoft visual studio spy utility querying properties monitoring messages windows applications executable tested marked version quicktimeplayer exe part apple quicktime media player version conclusion future work presented unique view malicious code detection game viewpoint explore obfuscation attacks commercial virus scanners found popular virus scanners susceptible attacks presented static analysis framework detecting malicious code patterns executables based framework implemented safe static analyzer executables detects malicious patterns executables resilient common obfuscation transformations future work investigate theorem provers construction annotated cfg instance slam theorem prover simplify predicate abstraction programs detection algorithm context insensitive track calling context executable investigate push-down systems make algorithm context sensitive existing pds formalism uninterpreted variables extended context availability safe prototype remains development distributing time contact mihai christodorescu mihai wisc updates acknowledgments thomas reps jonathon giffin providing invaluable comments earlier drafts paper members collaborators wisconsin safety analyzer wisa http wisc wisa research group insightful feedback support development work ashcraft engler programmer-written compiler extensions catch security holes executable text procedure annotator detector size size count avg std dev avg std dev tiffdither exe winmine exe spyxx exe quicktimeplayer exe table safe performance seconds checking clean programs chernobyl cih virus ieee symposium security privacy oakland pages ball rajamani automatically validating temporal safety properties interfaces proceedings international spin workshop model checking software spin volume lecture notes computer science springer-verlag barak goldreich impagliazzo rudich sahai vadhan yang possibility obfuscating programs advances cryptology crypto volume lecture notes computer science pages springer-verlag august bishop dilger checking race conditions file accesses computing systems cert coordination center denial service attacks june http cert tech tips denial service html accessed aug chandra reps physical type checking acm sigplan sigsoft workshop program analysis software tools engineering paste pages acm press september chen wagner mops infrastructure examining security properties software acm 
conference computer communications security ccs acm press november chess improving computer security extending static checking ieee symposium security privacy oakland pages chess white undetectable computer virus proceedings virus bulletin conference cohen computer viruses theory experiments computers security collberg thomborson low taxonomy obfuscating transformations technical report department computer science auckland zealand july collberg thomborson low manufacturing cheap resilient stealthy opaque constructs proceedings annual acm sigplansigact symp principles programming languages popl acm press january corbett dwyer hatcliff pasareanu robby laubach zheng bandera extracting finitestate models java source code proceedings international conference software engineering icse pages acm press cousot halbwachs automatic discovery linear restraints variables program proceedings annual acm sigplan-sigact symp principles programming languages popl pages acm press january currie rajan automatic formal verification dsp software proceedings annual acm ieee conf design automation dac pages acm press detlefs nelson saxe simplify theorem prover http research compaq src esc simplify html erlingsson schneider irm enforcement java stack inspection ieee symposium security privacy oakland pages esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proceedings international conference computer-aided verification cav volume lecture notes computer science pages springer-verlag july feng alan automatic formal verification scheduled vliw code proceedings joint conf languages compilers tools embedded systems software compilers embedded systems lctes scopes pages acm press fitting first-order logic automated theorem proving springer-verlag giffin jha miller detecting manipulated remote call streams proceedings usenix security symp security usenix association august hopcroft motwani ullman introduction automata theory languages computation addison wesley horwitz reps binkley interprocedural slicing dependence graphs acm transactions programming languages systems toplas january grammatech codesurfer code analysis understanding tool http grammatech products codesurfer index html accessed feb jensen metayer thorn verification control flow based security properties ieee symposium security privacy oakland kaspersky virus list encyclopaedia chapter ways infection viruses entry point kaspersky labs http viruslist eng viruslistbooks asp key accessed feb kaspersky labs http kasperskylabs accessed feb landi undecidability static analysis acm letters programming languages systems loplas december levitt olsson mcf malicious code filter computers society mcgraw morrisett attacking malicious code report infosec research council ieee software september october moore paxson savage shannon staniford weaver spread sapphire lammer worm technical report cooperative association internet data analysis caida february http caida outreach papers sapphire sapphire html accessed feb morrisett crary glew walker stackbased typed assembly language xavier leroy atsushi ohori editors workshop types compilation volume lecture notes computer science pages springer-verlag march morrisett walker crary glew system typed assembly language proceedings annual acm sigplan-sigact symp principles programming languages popl pages acm press january muchnick advanced compiler design implementation morgan kaufmann myers precise interprocedural data flow algorithm conference record annual acm sigplan-sigact symp principles programming languages popl pages acm press january nachenberg polymorphic virus detection module united states patent december nachenberg polymorphic virus detection module united states patent october necula translation validation optimizing compiler proceedings acm sigplan conf programming language design implementation pldi pages acm press june owre rajan rushby shankar srivas pvs combining specification proof checking model checking proceedings international conference computer-aided verification cav volume lecture notes computer science pages springer-verlag august reps horwitz sagiv precise interprocedural dataflow analysis graph reachability proceedings acm sigplan-sigact symposium principles programming languages popl pages acm press january samamura expanded threat list virus encyclopaedia chapter cih symantec antivirus research center http securityresponse symantec avcenter venc data cih html accessed feb datarescue ida pro interactive disassembler http datarescue idabase accessed feb staniford paxson weaver internet spare time proceedings usenix security symp security pages usenix association august ferrie hunting metamorphic proceedings virus bulletin conference pages september teso burneye elf encryption program https teso scene accessed feb wagner dean intrusion detection static analysis ieee symp security privacy oakland wang flash pan virus bulletin july virus analysis library safety-checking machine code phd thesis wisconsin madison mbie automated reverse engineering mistfall engine http mbie host autorev txt accessed feb mbie rpme mutation engine http mbie host rpme zip accessed feb mbie mbie homepage http mbie host accessed feb notes note subroutine address computation updated account nops trivial computation implemented adding number inserted nops initial offset hard-coded virus-morphing code executable formats require sections executable file start aligned addresses respect target platform idiosyncrasies extra space end section beginning padded nulls one-way matching simpler full unification note instruction sequence variables instantiate variables pattern match terms instruction sequence 
information investigating dual linear program produce program path leads statement overflow information valuable tells user tool overrun overview solver linear program optimization problem expressed minimize ctx subject matrix constants vectors constants andxis vector variables equivalent system inequalities variables required find values variables constraints system satisfied objective function ctx takes lowest important note form numerous ways linear program expressed comprehensive view linear programming linear programming works finite real numbers variables vector allowed finite real values optimum objective function exists guaranteed finite linear programming studied literature well-known techniques solve linear programs simplex popular techniques interior point methods work polynomial time commercially solvers solving linear programs soplex cplex implement related methods set constraints obtained program analysis linear constraints formulate problem linear program goal obtain values buf alloc min buf alloc max buf min buf max yield tightest ranges number bytes allocated buffer pointed buf constraints satisfied formally interested finding lowest values buf alloc max buf max highest values ofbuf alloc minandbuf min subject set constraints obtain desired bounds buffer buf solving linear programs constraints objective functions minimize buf alloc max maximize buf alloc min minimize buf max maximize buf min shown proof scope paper kind constraints generated tool max variables finite lower bounds min variables finite upper bounds values obtained solving linear programs values optimize linear program set constraints subject objective function minimize pbuf buf alloc max buf alloc min buf max buf min note objective function combines constraint variables buffers taint analysis ensures max variables finite lower bounds min variables finite upper bounds solve linear program obtain bounds buffers noted interested obtaining integer values forbuf alloc max buf max buf alloc min buf min problem finding integer solutions linear program called integer linear programming np-complete problem approach approximation real problem finding integer solutions satisfy constraints handling infeasible linear programs glance method give desired buffer bounds work cases optimal solution linear program exist describe briefly problems faced linear programming based approach determining buffer bounds linear program feasible find finite values variables constraints satisfied linear program variables assignment vector inrn called feasible solution linear program feasible solution optimal maximizes minimizes objective function linear program unbounded feasible solution exists solution optimizes objective function instance maximize subject feasible solution linear program finite optimizes objective function finally linear program infeasible feasible solutions infeasible linear program shown figure minimize counter max subject counter max counter max counter max counter max figure infeasible linear program formulation linear program optimal solution buffer bound linear programs case unbounded constraints examined taint analyzer ensure max variables finite lower bounds minimize max variables objective function max variables finite lower bounds lowest max variable obtain finite similarly min variables finite upper bounds maximize min variables highest values obtain finite taint analysis essential step ensure approach works correctly linear program infeasible assign finite values variables feasible solution result obtain values buffer bounds case safe option set max variables min variables information virtually useless user tool false alarms linear program infeasible due small subset constraints scenario setting variables infinite values overly conservative instance constraints figure infeasible constraints generated statement counter developed approach remove small subset original set constraints resultant constraint system feasible fact problem correcting infeasible linear programs make feasible studied problem operations research approach identify irreducibly inconsistent sets called iis iis minimal set inconsistent constraints constraints iis infeasible subset constraints iis form feasible set instance constraints linear program figure constitute iis removal constraints makes linear program feasible efficient algorithms detect iiss set constraints elastic filtering algorithm elastic filtering algorithm takes input set linear constraints identifies iis constraints exists infeasible linear program iiss elastic filtering algorithm guaranteed find iiss produce feasible linear program infeasible linear program required run elastic filtering algorithm times run identifies removes iis produces smaller linear program examined presence iiss figure pictorially shows approach obtain set feasible linear constraints set infeasible linear constraints examine input set depicted find feasible iiss set constraints linear program formulation turns infeasible means subset forms iiss subset depicted figure elastic filtering algorithm runs identifies set obtained removing removal results inthe set constraints set tainted denotes set iiss elastic taint filtering analysisc figure making infeasible set constraints amenable linear programming removes subset set constraints resultant set feasible set values max min variables appearing infer values variables linear programming setting variables infinite values conservative approach variables values infinite set constraints scenario similar taint analysis constraint variables values infinite identify remove constraint variables tainted infinite variables apply taint analysis algorithm identify tainted variables remove constraints step results removal constraints depicted figure subset set constraints removal denoted figure satisfies property max variables appearing finite lower bounds min variables finite upper bounds feasible yield optimal solutions solved linear program objective functions earlier solve linear program set constraints algorithm presented detail implemented approach extending commercially package soplex soplex linear program solver extended adding iis detection taint analysis practice linear program solvers work faster constraints presolved presolving method constraints simplified passed solver techniques literature incorporated solver solving constraints hierarchically approach presented fast approximation algorithm algorithm remove constraints required make constraints feasible result constraint variables set values address imprecision designed implemented hierarchical solver idea solver decompose set constraints smaller subsets solve subset separately constructing directed acyclic graph dag vertices represents set constraints constraint vertex dag dag constructed defining notion dependency pair constraints topological order dag naturally defines hierarchy vertices set constraints vertex solved linear programming shown approach mathematically precise sets fewest number constraint variables produces precise ranges omitted details due space considerations consult details adding context sensitivity constraint generation process section context-insensitive generated constraints function considered call-site assignment actual-in variables formal-in variables return function assignment formal-out variables actual-out variables result merged information call-sites making analysis imprecise section describe techniques incorporate context sensitivity constraint inlining similar spirit inlining function bodies call-sites observe context-insensitive approach lost precision treated call-sites function identically assigning actual-in variables call-site formal parameter constraint inlining alleviates problem creating fresh instance constraints called function call-site call-site function produce constraints called function local variables formal parameters renamed uniquely call-site illustrated shows constraints copy buffer figure specialized call-site line copy alloc max buffer max copy max buffer 
formal analyses attack graphs jha computer sciences department wisconsin madison e-mail jha wisc sheyner wing computer science department carnegie mellon pittsburgh e-mail fsheyner wingg cmu abstract attack graph succinct representation paths system end state intruder successfully achieved goal today red teams determine vulnerability networked systems drawing gigantic attack graphs hand constructing attack graphs hand tedious error-prone impractical large systems viewing attack violation safety property off-the-shelf model checking technology produce attack graphs automatically successful path intruder viewpoint counterexample produced model checker paper present algorithm generating attack graphs model checking subroutine security analysts attack graphs detection defense forensics paper present minimization analysis technique analysts decide minimal set security measures guarantee safety system provide formal characterization problem prove polynomially equivalent minimum hitting set problem present greedy algorithm provable bounds present reliability analysis technique analysts perform simple costbenefit trade-off depending likelihoods attacks interpreting attack graphs markov decision processes iteration algorithm compute probabilities intruder success attack graph keywords attack graph model checking minimization analysis reliability analysis markov decision processes network vulnerability security jha supported office naval research contracts shyener wing supported defense advanced research projects agency army research office aro contract daad views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied dod aro onr government motivation networks hosts continue grow evaluating vulnerability attacks increasingly important automate evaluating security network presence absence isolated vulnerabilities large network builds multiple platforms diverse software packages supports modes connectivity inevitably network security holes escaped notice diligent system administrator evaluate vulnerability network hosts security analyst account effects interactions local vulnerabilities find global vulnerabilities introduced interconnections typical process vulnerability analysis network shown figure scanning tools determine vulnerabilities individual hosts local vulnerability information information network connectivity hosts analyst produces attack graph path attack graph series exploits call atomic attacks leads undesirable state state intruder obtained administrative access critical host attack graphs intrusion detection attack graphs serve basis detection defense forensic analysis motivate study attack graphs attack graph generation algorithms discuss potential applications attack graphs areas security detection system administrators increasingly deploying intrusion detections systems idss detect combat attacks network systems depend software sensor modules detect suspicious events activity issue alerts setting sensors involves trade-off figure vulnerability analysis network sensitivity intrusions rate false alarms alert stream sensors set report suspicious events sensors frequently issue alerts benign background events results administrators turning ids hand decreasing sensor sensitivity reduces ability detect real attacks deal problem intrusion detection systems employ heuristic algorithms correlate alerts large pool heterogeneous sensors valdes skinner describe probabilistic approach alert correlation successful correlation multiple alerts increases chance suspicious activity alerts fact malicious attack graphs enhance heuristic probabilistic correlation approaches graph describing attacks sequences attacker actions ids match individual alerts attack edges graph matching successive alerts individual paths attack graphs dramatically increases likelihood network attack on-line vigilance ids predict attacker goals aggregate alarms reduce volume alert information analyzed reduce false alarms rates knowledge attacker goals steps helps guide defensive response defense benefit attack graphs analyze potential effectiveness intrusion detections systems offline section show attack graphs generated automatically models network show incorporate security policy intrusion detection system model generate attack graphs specific network configurations attack graphs enable administrator perform kinds analysis assess security marking paths attack graph ids detect determining position ids components coverage exploring trade-offs security policies software hardware configurations identifying worst-case scenarios prioritizing defense forensics break-in forensic analysis find probable attacker actions assess damage legal action desired analysts seek evidence sequence sensor alerts comprises coherent attack plan series isolated benign events task harder intruders obfuscate attack steps slowing pace attack varying specific steps suggested convincing argument malicious intent intruder actions constructed matching data extracted ids logs formal model based attack graphs contributions constructing attack graphs crucial part performing vulnerability analysis network hosts red teams produce attack graphs hand drawing gigantic diagrams floor-to-ceiling whiteboards hand tedious error-prone impractical attack graphs larger hundred nodes demonstrated earlier work model checking applied automatically generate attack graphs paper show attack graphs produced method exhaustive covering attacks succinct relevant states section provide formal detailed explanation model definitions based finite-state model network state transitions standard preand post-conditions state transition corresponds single atomic attack intruder state model represents state system atomic attacks typical transition state state corresponds atomic attack preconditions satisfied effects hold state attack sequence state transitions culminating intruder achieving goal entire attack graph representation ways intruder succeed discussed attack graphs perform variety analysis specifically attack graphs answer questions interest system administrator question successful attacks undetected ids question measures set implemented network safe secure question set measures smallest subset measures implementation makes network safe answers questions analyst network administrator choosing upgrade strategy questions addressed section modeling system operating uncertain environment transitions model represent system reaction environment transitions system control occur triggered environment empirical information relative likelihood environment-driven transitions model nondeterministic choices made environment vulnerabilities data estimating probabilities empirical data make assign probabilities environment-driven transitions advantage information quantify probabilistic behavior attack graphs context system administrator interested question question deployment security measure increase likelihood thwarting attacker answer question provided section system administrator answer question perform quantitative evaluation security fixes main contributions paper earlier work paper explores semantics network model formally earlier work proved finding minimum set atomic attacks removed thwart intruder np-complete paper explore complexity problem section proves problem polynomially equivalent minimum hitting set problem collection sets represented labeled directed graph reduction additional insight enabled find greedy algorithm provable bounds answer questions paper presents algorithm compute reliability defined likelihood intruder succeeding network desirable feature algorithm incomplete information probabilities transitions provided knowledge previous metrics area security require complete information related work provided section section describes model model checking based algorithm generate attack graphs network presented section section describes network model detail network paper illustrative purposes section present analysis helps answers questions section describes probabilistic attack graphs algorithm compute reliability answer question provided section proof correctness algorithm compute reliability based markov decision processes presented companion technical report finally directions future work concluding remarks presented section related work phillips swiler propose concept attack graphs similar attack-centric view system work general input language model seemingly benign system events failure link user errors attacks 
occur simultaneously attack graphs general proposed phillips swiler based ideas tool generating attack graphs presented tool constructs attack graph forward exploration starting initial state symbolic model checker nusmv works backward goal state construct attack graph major advantage backward algorithm vulnerabilities relevant safety property goal intruder explored result significant savings space fact swiler refer advantages backward search paper model checking leverage sophisticated reduction techniques developed area post-facto analysis suggested phillips swiler presented paper plan incorporate analysis tool dacier proposes concept privilege graphs node represents set privileges owned user arcs represent vulnerabilities privilege graphs explored construct attack state graphs represents ways intruder reach goal root access host based attack state graphs metric called effort failure metf proposed experimental evaluation framework orlato surface notion attack graphs similar proposed dacier case phillips swiler dacier takes attack-centric view world pointed earlier attack graphs general experiments conducted orlato appears small examples space required construct attack state graphs prohibitive model checking made significant advances representing large state spaces basing algorithm model checking leverage advances hope represent large attack graphs analytical analysis proposed dacier performed attack graphs constructed tool plan conduct experimental evaluation similar performed orlato ritchey amman model checking vulnerability analysis networks unmodified model checker smv obtain counter-example attack intruder goal contrast modified model checker nusmv produce complete attack graphs represents attacks analysis performed attack graphs analysis techniques meaningfully performed single attacks generating attack graphs model checking formally define attack graphs data structure represent attacks networked system restrict attention attack graphs representing violations safety properties definition set atomic propositions attack graph tuple set states transition relation set initial states set success states labeling states set propositions true state intuitively denotes intruder goals obtaining root access critical host stated assume transition relation total define execution fragment finite sequence states execution fragment liveness properties section execution execution final state attack execution corresponds sequence atomic attacks leading intruder goal state turn attention algorithms automatic generation attack graphs starting description network model security property task construct attack graph representing executions violate successful attacks kinds attack graph analysis suggested section essential graphs produced algorithms exhaustive succinct attack graph exhaustive respect model correctness property covers attacks leading violation succinct states system state violating reachability analysis restrict safety properties attack graph constructed performing simple statespace search starting initial states model graph traversal procedure depth-first search find reachable success states safety property violated attack graph union paths initial states success states algorithm advantage simplicity handles safety properties run state explosion problem non-trivial models model checking dealt issues success algorithms based technology model checking algorithm model checking technique checking formal model system satisfies property work model checker nusmv model finite labeled transition system property expressed computation tree logic ctl safety properties ctl form agf agf formula propositional logic model satisfies property nusmv reports true satisfy nusmv produces counter-example single counterexample shows execution leads violation property section explain construct attack graphs safety properties model checking attack graphs depict ways system reach unsafe state equivalently successful state intruder express property unsafe state reached unsafe property false unsafe states reachable initial state precise meaning input set states transition relation set initial states labeling states propositional formulas unsafe safety property output attack graph sunsafe sps algorithm generateattackgraph model checking find set states sunsafe violate safety property unsafe sunsafe modelcheck restrict transition relation states set sunsafe sunsafe sunsafe sunsafe sps fsjs sunsafe unsafeg return sunsafe sps figure algorithm generating attack graphs unsafe depends application network security section property express privilege level intruder host index root administrative privilege network adversary privilege network priv root briefly describe algorithm constructing attack graphs property unsafe step determine set states reachable initial state algorithm computes set reachable states sunsafe path unsafe state set states sunsafe computed iterative algorithm derived fix-point characterization operator transition relation model transition state restricting domain range sunsafe obtain transition relation represents edges attack graph attack graph sunsafe sps sunsafe represent set nodes edges graph sunsafe set initial states sps fsjs sunsafe unsafegis set success states algorithm figure symbolic model checkers nusmv transition relation sets states represented bdds compact representation boolean functions efficient bdd algorithms operations algorithm shown figure attack graph properties show attack graph generated algorithm figure exhaustive lemma succinct respect states edges lemma proof lemma straightforward definitions lemma properties attack graph true exhaustive execution input model violates property unsafe attack attack graph sunsafe sps succinct respect states state input model attack graph attack succinct respect edges edge input model attack graph attack includes simple intrusion detection network shown figure target hosts firewall separating rest internet shown host running services ftp sshd database intrusion detection system ids monitors network traffic target hosts figure network world atomic attacks identified numerically sshd buffer overflow ftp rhosts remote login local buffer overflow atomic attack detectable intrusion detection system trigger alarm attack stealthy ids misses ftp rhosts attack find target host vulnerabilities writable home directory executable command shell assigned ftp user local buffer overflow exploits vulnerable version xterm executable section construct finite state model network state transition corresponds single atomic attack intruder state model represents state system atomic attacks typical transition state state corresponds atomic attack preconditions satisfied effects hold state intruder launches attack starting single computer ipa lies firewall eventual goal disrupt functioning database intruder root access database host states finite state machine model network model network set facts represented relational predicate state network specifies services host vulnerabilities connectivity remote login trust relationship hosts boolean variables host modeled services running vulnerabilities present host variable meaning sshh ssh service running host ftph ftp service running host datah database running host wdirh ftp home directory writable host fshellh ftp user executable shell host xtermh xterm executable vulnerable overflow host connectivity expressed ternary relation host host port means host reachable host port constants refer specific ports ssh ftp services slightly abusing notation write network route similarly model trust binary relation rshtrust host host rshtrust user log host host authentication host trusts host intruder function plvla hosts fnone user rootg level privilege intruder host total order privilege levels user root state variables attack intruder attempt variable meaning attack attack 
type source source host target target host strain stealthy detectable attack intrusion detection system atomic attacks classified detectable stealthy respect intrusion detection system ids attack detectable trigger alarm executed host network segment monitored ids attack stealthy ids detect ids function ids host host attack ids attack detectable executed source host target host ids attack stealthy executed source host target host ids attack detectable stealthy strains success detecting attack depends strain refer host ids specifies intrusion detection system component located host refer hosts ids specifies intrusion detection system component monitoring network path addition global boolean variable specifies ids alarm triggered previously executed atomic attack initial states initially trust hosts trust relation empty connectivity relation shown table entry table corresponds pair hosts entry triple boolean values connected physical link connect ftp port connect sshd port ipa ipa connectivity relation reflect firewall rule sets existence physical links table firewall open place restrictions flow network traffic initially intruder root privileges machine ipa privileges hosts paths ipa ipa monitored single network-based ids path monitored hostbased intrusion detection components ids detects remote login attack detectable strains sshd buffer overflow attack transitions model nondeterministic state transitions current state network satisfies preconditions atomic attack rule intruder nondeterministically chooses attacks state effects clause chosen attack rule intruder repeats process goal achieved model atomic attacks description designate source host target host denotes host reachable host port sshd buffer overflow remote-to-root attack immediately remote user root shell target machine attack sshd-buffer-overflow intruder preconditions user-level privileges host plvla user root-level privileges host plvla root network preconditions host running sshd ssht host reachable port intruder effects root-level privileges host plvla root network effects host running sshd ssht end ftp rhosts ftp vulnerability intruder creates rhosts file ftp home directory creating remote login trust relationship machine target machine attack ftp-rhosts intruder preconditions user-level privileges host plvla user network preconditions host running ftp ftpt host reachable port ftp directory writable host wdirt ftp user assigned valid shell host fshellt rsh trust host rshtrust intruder effects network effects rsh trust hosts rshtrust end remote login existing remote login trust relationship machines intruder logs machine user shell supplying password operation legitimate action performed regular users intruder viewpoint atomic attack attack rsh-login intruder preconditions user-level privileges host plvla user privileges host plvla network preconditions rsh trust rshtrust host reachable intruder effects user-level privileges host plvla user network effects end local buffer overflow intruder acquired user shell target machine step exploit buffer overflow vulnerability setuid root file gain root access attack intruder preconditions user-level privileges host plvla user network preconditions vulnerable xterm executable xtermt intruder effects root-level privileges host plvla root network effects end easy atomic attack strictly increases intruder privilege level target host remote login trust hosts means attack graph cycles finite model automatically construct attack graphs demonstrate intruder violate security properties suppose generate attacks demonstrate intruder gain root privilege host remain undetected ids ctl formula expresses safety property intruder host privilege level root detected expressed ctl property network adversary privilege network priv rootj network detected figure shows attack graph produced tool property node labeled attack number corresponds atomic attack attempted flag attack stealthy detectable intrusion detection system numbers source target hosts ipa corresponds host number path graph root node leaf node shows sequence atomic attacks intruder employ achieve goal remaining undetected instance path highlighted double-boxed nodes consists sequence atomic attacks overflow sshd buffer host overwrite rhosts file host establish rsh trust hosts log rsh host host finally overflow local buffer host obtain root privileges expanded adding additional hosts additional atomic attacks vulnerabilities flexible firewall configurations larger attack graph nodes edges figure attack graph figure attack graph analysis minimization analysis attack graph generated specific network respect safety property utilize analysis analyst faced choice deploying additional network attack detection tools prevention techniques analyst set measures deploying additional network detection tools upgrading software section answers questions posed section question successful attacks undetected ids answer answer question modify model slightly making subset atomic attacks intruder simplicity nondeterministically decide subset initially attack begins choice made subset atomic attacks fixed attack ran model checker modified model invariant property intruder obtains root privilege host network adversary privilege network priv root post-processor marked states intruder detected ids result shown figure white rectangles states attacker detected intrusion detection system black rectangles states intrusion detection system sounded alarm white leaf nodes desirable attacker objective achieved detection black leaf nodes desirable attacker achieves objective alarm resolution atomic attacks intruder circular nodes root graph transition root initial state picks subset attacks intruder child root node root disjoint subgraph subset atomic attacks chosen child note number subgraphs descending root node corresponds number subsets atomic attacks intruder successful model checker determines subset successful sequence atomic attacks root graph figure subgraphs subsets atomic attacks intruder succeed left subgraph sshd buffer overflow attack intruder readily intruder succeed remaining undetected ids subgraph attacks entire attack graph implies atomic attacks sshd attack indispensable intruder succeed analyst information guide decisions network defenses profitably upgraded white cluster middle figure isomorphic attack graph presented figure shows attacks intruder achieve objective detection paths intruder reaches white leaf graph proceed provide answers questions define attack graph edges labeled atomic attacks produced postprocessor attack graph perform analysis answer questions assume produced attack graph safety property unsafe set atomic attacks attack graph set states set edges initial state success state intruder gis labeling function edge corresponds atomic attack edges labeled represent system transitions correspond atomic attack demonstrated additional edges introduced construction loss generality assume single initial success state attack graph multiple initial states success states sus add initial state success state -labeled edges sts suppose finite set measures mkg function covers atomic attack covers adopting measure removes atomic attack question measures set implemented network safe secure answer network administrator find adopting measures set make network safe question answered linear time attack graph define covers ass covers remove edges gsuch covers network safe iff success state reachable initial state simple reachability question answer time linear size graph question set measures smallest subset measures implementation makes network safe answer network administrator wishes find subset 
modular verification software components sagar chaki edmund clarke alex groce carnegie mellon fchaki emc agroceg cmu somesh jha univ wisconsin jha wisc helmut veith vienna veith dbai tuwien abstract present methodology automatic verification programs finite state machine specifications approach compositional naturally enabling decompose verification large software systems subproblems manageable complexity decomposition reflects modularity software design weak simulation notion conformance program specification abstractverify-refine paradigm tool magic extracts finite model source code predicate abstraction theorem proving subsequently simulation checked reduction boolean satisfiability magic interface publicly theorem provers sat solvers report experimental results procedures linux kernel openssl toolkit introduction state machines recognized repeatedly cardinal point software development process fact variants state machines proposed virtually software engineering methodologies including notably statecharts uml sustained success state machines software engineering derives fact state machines provide concise mathematical theory intuitive semantics system behavior naturally visualization hierarchy abstraction traditionally state machines design phase software life-cycle intended guide constrain implementation test phase research supported nrl-onr grant nsf grant ccrccr- ccrby army-aro grant daad austrian science fund project -inf research training network games graduate student fellowships microsoft nsf opinions findings conclusions recommendations expressed material authors necessarily reflect views nsf united states government reused documentation purposes cases assertion state machine safely abstracts existing implementation implicit informal rise internet-based technologies significance state machines increased security protocols communication protocols naturally terms state machines similar applications state machines found safety-critical domains including medicine aerospace dramatic change focus monolithic systems highly distributed heterogeneous systems development cycles interdependent calls specification methodologies august ibm microsoft bea announced specifications ws-coordination ws-specification bpel collectively describe reliably define create connect multiple business processes web services environment foresee state machines contracts describing software capabilities cases protocol specification distributed computation observe state machines longer tools internal increasingly introduced public domain paper describe tool magic modular analysis programs capable verifying state machine precisely labeled transition system safe abstraction procedure procedure turn invoke procedures terms state machines approach number tangible benefits utility capability magic verify formally correctness state-machine specifications closes evident gap software development methodologies notably security-related system features future envision tools based ideas magic assist contracting process party software providers compositionality magic verification early development cycle specifications plugged missing system components compositionality evidently fosters concurrent development independent groups developers complexity state-space explosion remains bottleneck automated verification tools due compositionality size individual system parts verified magic remains manageable demonstrated experiments verification process magic reduced computing simulation relation finite state systems provide highly efficient algorithms flexibility internally magic theorem provers sat solvers open design magic facilitates easy integration improved tools quickly developing area magic tools potential indispensable software engineering process rest section describe technical contributions paper labeled transition systems specification mechanism literature variants state machines investigated purely state-based formalisms kripke structures model systems magic framework employ labeled transition systems lts similar kripke structures fact state transitions labeled actions theoretical point view presence actions increase expressive power lts experience natural designers software engineers express desired behavior systems combination states actions fact lock acquired released expressed naturally lock unlock actions absence actions natural alternative introduce variable indicating status lock update lts approach intuitive simpler theory easier specification process simple lts shown left part figure formal definition section magic framework actions denote externally visible behaviors system analyzed acquiring lock actions atomic distinguished simply names presence action behavior achieved subprocedure implementation analyze procedural language model termination procedure return procedure special class actions called return actions return action unique return retval return values integers void actions return actions called basic actions ltss motivated work concurrency process algebras ccs csp -calculus widely reason formally message passing concurrent systems formalisms actions crucial modeling sending receiving messages channels process algebras lead naturally ltss analyze sequential programs ltss facilitate smooth transition concurrent message-passing programs future procedure abstractions goal magic verify implementation system safely abstracted specification end magic verifies individual procedures respective lts implementation handle group procedures tree-like call graph single inlining simplicity speak single procedures paper figure describes simple case procedure proc lts proc running spec state machine code analysed return return lock int proc mspec stopreturn lock return figure mspec proc practice single procedures perform tasks settings parameters approach phenomenon accounted allowing multiple ltss represent single procedure selection ltss achieved guards formulas describe conditions procedure parameters lts applicable rise notion procedure abstraction formally procedure proc tuple declaration proc appears header file finite list hgn mni guard formula ranging parameters proc lts single initial state procedure abstraction expresses proc conforms lts chosen precisely proc conforms guard evaluates true actual arguments passed proc require guard formulas mutually exclusive choice unambiguous goal magic prove user-defined proc valid role pas process twofold target describe desired behavior procedure proc assist verification process employ valid pas called assumption pas library routines proc pas conclusions assumptions verification process methodology yields scalable compositional approach verifying large software systems figure illustrates depicting call graph implementation verification steps note due compositionality order steps required loss generality assume paper target guard gspec lts mspec achieve result full generality algorithm iterated guard mspec foo bar baz verify baz verify foo verify bar call graph target paother library routines assumption verification steps figure compositional verification algorithms tool description magic tool well-known abstract verify refine paradigm step model creation extract lts mimp proc assumed pas guard gspec magic model computed control flow graph cfg program combination abstraction method called predicate abstraction decide properties equivalence predicates theorem provers details step section step verification check mspec safely abstractsmimp case verification successfully terminates extract diagnostic feedback perform step magic verification step amounts checking simulation relation holds mspec mimp section reduce simulation satisfiability boolean formula deferring solution highly efficient sat procedures details step section step refinement diagnostic feedback determine reason failure safe abstraction property bug proc property fails mimp sufficiently precise model proc case return step compute improved mimp current stage development magic performs steps automatically step manually guided input magic consists set preprocessed ansi-c files representing proc set specification files textual descriptions mspec gspec predicates predicate abstraction textual descriptions ltss extended version fsp notation magee kramer lts shown figure textually mylock lock return stop return stop schematic figure explains software 
weighted pushdown systems trust-management systems somesh jha stefan schwoon hao wang thomas reps computer science department wisconsin madison hbwang jha reps wisc institut formale methoden der informatik universit stuttgart universit atsstr stuttgart germany schwoosn fmi uni-stuttgart abstract authorization problem decide security policy principal allowed access resource trustmanagement system spki sdsi security policy set certificates proofs authorization form certificate chains problem discover proof authorization request algorithms spki sdsi investigated researchers variant certificate-chain discovery problem certificates distributed number servers cooperate identify proof authorization request propose protocols purpose protocols based distributed model-checking algorithms weighted pushdown systems wpdss protocols handle cases certificates labeled weights multiple certificate chains combined form proof authorization implemented protocols prototype report preliminary results evaluation introduction access control shared computing resources authorization problem addresses question security policy principal allowed access specific resource trust-management systems spki sdsi security policy set signed certificates proof authorization consists set certificate chains spki sdsi principals public keys identity principal established checking validity public key spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations problem discover set certificate chains proof authorization request principal access resource efficient algorithm spki sdsi presented clarke improved algorithm presented jha reps algorithm based translating spki sdsi certificates rules pushdown system demonstrated translation enables questions answered security policy expressed set certificates algorithms presented assume proof authorization consists single certificate chain general proof authorization spki sdsi requires set certificate chains proves part required authorization algorithms presented incomplete observation basis observation mitchell -tuple reduction rule incomplete schwoon introduced algorithm certificate-chain discovery translates spki sdsi certificates rules weighted pushdown system wpds algorithm presented schwoon discover proofs authorization consist multiple certificate chains algorithm presented addresses issues trust privacy recency context authorization spki sdsi paper translate spki sdsi certificates rules wpds authorization specifications certificates translated weights rules translation wpds yields complete algorithm section algorithms assume set certificates relevant request single site compute answer authorization problem principal resource practice central authority certificates held number sites subset certificates principal site access resource site certificate chain authorizing involve certificates ands possibly number sites instance computer sciences department wisconsin part college letters sciences department college sites sense grant access resource faculty members issuing authorization certificate actual principals authorized access certificates declare faculty members declare faculty members list faculty members members access chain certificates sites certificates involved paper makes major contributions present distributed model-checking algorithm wpdss algorithm develop distributed algorithm spki sdsi certificates distributed sites background trust-management system spki sdsi section distributed algorithm spki sdsi section implemented prototype algorithm experimental results presented section demonstrate algorithm incurs moderate overhead related work algorithm spki sdsi proposed clarke improved based theory pushdown systems presented jha reps earlier algorithms centralized assume proof authorization consists single certificate chain pca framework appel felten client theorem prover twelf construct proof authorization client presents server assume logical facts theorem prover reside single server presented distributed algorithm trust-management system algorithm certificates distributed proof authorization maintained site spki sdsi subset spki sdsi equivalent role intersection distributed algorithm sites summarize part proof authorization sending sites proof authorization distributed summarizing intermediate results privacy implemented algorithm trust-management server knowledge implement algorithm bauer present algorithm assembling proof request satisfies access-control policy expressed formal logic bauer advocate lazy strategy party enlists prove subgoals precise relationship distributed algorithm bauer algorithm presented paper explored future semantics spki sdsi widely studied context work relevant mitchell pointed -tuple reduction rule incomplete general proof authorization require multiple certificate chains algorithm suffer problem due translation wpds work jim suciu successor qcm related trust-management system based datalog algorithms distributed evaluation authorization queries author claims express roughly policies sdsi claim substantiated true differences set work describes generic evaluation algorithm instantiation corresponds strategy distributing computation propose concrete evaluation strategies argue strategies advantages respect efficiency privacy provide concrete encoding spki sdsi comparison relative merits encoding bound speculative site-safety requirement limit evaluation forward mode algorithms search forward backward explained section unlike framework certificates weights pointed solution situations proofs authorization require multiple certificate chains prove part authorization solves problem semantic incompleteness pointed mitchell pointed weights address issues privacy recency validity trust weighted pushdown systems weighted pushdown systems introduced short pushdown system defines infinite-state transition system states involve stack unbounded length weighted pushdown system rules values domain weights weight domains interest bounded idempotent semirings defined defn definition bounded idempotent semiring quintuple set elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal iff infinite descending chains definition pushdown system triple finite sets called control locations stack alphabet elements conf called configurations finite number rules form arrowhookleft pprime pprime define transition relation configurations arrowhookleft pprime wprime pprime wwprime wprime write cprime express exists rule cprime omit subscript understood reflexive transitive closure denoted set configurations define pre def cprime cprime post def cprime cprime sets configurations reachable backwards forwards elements single step pre def cprime cprime post def cprime cprime configuration reachable backwards forwards arbitrarily steps called regular language regular definition weighted pushdown system triple pushdown system bounded idempotent semiring function assigns rule sequence rules associate define def configurations cprime path cprime denote set rule sequences transform cprime cprime definition set configurations forwards resp backwards dag edge-labeled directed acyclic graph conf vertex incoming edges incoming edges circleplustextki forwards -dag circleplustextki backwards -dag call forwards backwards -dag witness dag finite vertex outgoing edges notice extender operation calculate path set paths computed combiner operation existence witness dag considered proof exists set paths vice versa combined defn identify finite witness dag set paths exists results briefly review results weighted pushdown systems pushdown system regular subset conf sets pre post regular effectively computable form finite automaton results show result extended generalized pushdown reachability gpr problems weighted pushdown systems definition weighted pushdown system regular set configurations generalized pushdown predecessor gpp problem find pre def circleplustext path cprime cprime backwards witness dag generalized pushdown successor gps problem find post def circleplustext path cprime cprime forwards witness dag solutions gps gpp computed form annotated finite automata describe gpp case gps case analogous modulo details sake keeping presentation simple concentrate computation 
architecture magic model creation handled stage program stage input files parsed control flow graph cfg program constructed simplifications made resulting cfg simple statements side-effect free expressions relevant predicates control location computed cfg annotated stage mimp extracted annotated cfg assumed pas gspec predicates process requires theorem provers magic interact public domain theorem provers simplify cvc ics cprover verification performed stage iii mentioned simulation reduced boolean satisfiability magic interface publicly sat solvers chaff fgrasp sato efficient sat solver implementation leverages specific nature sat formulas arise stage deliver performance public domain solvers magic generate diagnostic feedback support automatic model annotated cfg lts descriptions files spec files implementation lts specification lts sat solvers diagnostic feedback stage stage stage iii chaff fgrasp sato implementation predicates guard simplify cvc ics cprover decision procedures assumed pas figure architecture magic refinement significant area future research related work years advances verification methodology computing power promoted renewed interest software verification resulting systems notably bandera java pathfinder esc java slam blast increasingly handle industrial software mentioned systems focus java deal java verification object orientation garbage collection logical memory model require specific analysis methods verification tools stands meta-compilation distinguished place amounts form pattern matching source code surprisingly good results scanning simple errors large amounts code slam blast closely related tools technical flavor akin slam primarily optimized analyse device drivers included windows development cycle contrast slam symbolic algorithms blast onthe-fly reachability analysis tool magic tool lts specification formalism simulation notion conformance choice reflects area security primary application domain mentioned tools based variations model checking require abstraction methods alleviate state explosion problem notably data abstraction general predicate abstraction abstraction method slam blast closest due compositionality afford invest computing power computing abstractions improve cartesian abstraction generally form compositionality provided magic unique existing software verification systems virtually systems abstraction interface theorem provers purposes software architecture magic designed facilitate integration theorem provers addition magic tool area attempts transfer enormous success sat procedures hardware verification software transition systems simulation labeled transition system lts -tuple act finite non-empty set states set initial states iii act set actions act transition relation assume distinguished state stop outgoing transitions stop addition assume presence distinguished action set act denote referred a-transition denoted bys ifsis reachable -transitions denote relation defined iff exist conformance simulation context lts simulation natural notion conformance specification lts implementation lts simulation notion conformance specification lts program compared conformance notions based trace containment simulation additional advantage computationally expensive check technical variants simulation choose weak simulation limited form asynchrony ltss step specification lts simulate multiple steps implementation feature weak simulation crucial approach step mspec typically corresponds multiple steps mimp weak simulation act act ltss relation called weak simulation iff exists implies actions act exists lts weakly simulates denoted exists weak simulation relation rest paper convention terms simulation simulates weak simulation weakly simulates algorithm computing weak simulation existence simulation relation checked efficiently reducing problem instance boolean satisfiability interestingly sat instances produced method belong restricted class sat formulas weakly negated horn formulas contrast general sat polynomial time algorithm satisfiability weakly negated horn formulas solved linear time part magic implemented online linear time hornsat algorithm based magic interface public domain general sat solvers chaff fgrasp sato model creation mspec sspec spec actspec tspec assumption pas fpa pakg section show extract mimp proc assumption pas guard gspec predicates extraction mimp relies principles state mimp models state execution proc state composed control component data component control components intuitively represent values program counter formally obtained cfg proc data components abstract representations memory state proc abstract representations obtained predicate abstraction transitions states inmimp derived transitions control flow graph taking account assumption pas predicate abstraction process involves reasoning expressions require theorem prover rest section describe steps detail control flow graph cfg proc finite graph describing flow control proc nodes cfg called control locations intuitively correspond values program counter edges denote transfer control ordinary code nested procedure calls expressions side-effects similar constructs make difficult construct precise cfgs order alleviate problem tool performs set natural simplifications proc constructing cfg simplified procedure body normal assignments call assignments foo branches gotos returns return left hand side assignments variable single address dereference note resulting program loop statements substituted goto statements assume variable unique scope procedure terminates explicit return statements preprocessing steps complicated omitted cfg proc shown figure dreturn finale true false return expanded cfg return return return return lock cfg figure cfg expanded cfg control locations simplification definition control locations straightforward normal assignment call assignment goto return statement rise control location unique successor contrast branch yields control location successors assume control location cfg conditions statements addition introduce unique final control location make unique successor return control locations depending statement control location referring speak normal assignment locations branch locations formally denotes set control locations proc expanding control flow graph cfg simplest reasonable finite model proc verification purposes cfg imprecise models control flow ignores data memory hand computationally unfeasible model memory explicitly show incorporate abstract memory state information cfg end set properties control location properties expressions similar branching conditions data properties true false control location corresponds states model valuation properties considered intuitively construction lts mimp proceeds stepwise construct cfg construct expanded cfg mexp sexp exp actspec texp control location include states sexp state combination control location valuation considered properties edge cfg thenc andc correspond states sexp correspond transitions texp included transitions consistent abstract memory state information theorem prover determine transitions admissible rule transitions admissibility disproved theorem prover mexp precise model proc cfg model behavior library routines called proc achieve incorporate assumption pas mexp step requires theorem prover lts obtained incorporating assumption pas mimp sections describe step process detail section explain step predicate abstraction predicate abstraction approach model abstractly state system set logical predicates predicate abstraction techniques model memory state aim verify programs natural express properties pure side-effect free boolean expressions assumed scope variable unique definition unambiguous expressions quantifier-free order formulas conceptual proximity logical connectives equivalents order describe abstract memory states fix setp pkgof expressions call predicates note float string constants predicates current stage implementation concrete memory state predicate satisfies iff evaluates true nonzero numerical execution proc memory 
smallest size adopting measures set make network safe problem np-complete develop good approximation algorithms proceed steps step finding small set atomic attacks step find set atomic attacks removal makes network safe checking subset attacks exponential number attacks related paper show finding minimum set atomic attacks removed thwart intruder fact np-complete demonstrated minimal set found polynomial-time paper explore complexity problem section proves problem finding minimum set attacks polynomially equivalent minimum hitting set problem collection sets represented labeled directed graph reduction additional insight enabled find greedy algorithm provable bounds step finding small set measures assume find set atomic attacks removal makes network safe equivalently thwarts intruder recall mkg set measures covers function covers represents set atomic attacks removed adopting measure attack set associate set measures isfmi covers set attacks defines collection subsets find smallest subset exists covers equivalently minimum hitting set problem np-complete good approximation algorithms exist solve problem section minimum critical attack sets minimum hitting set problem section addresses step answer question assume attack graph set states set edges initial state success state intruder labeling function state set attacks critical respect intruder reach goal attacks removed arsenal equivalently critical respect path success state edge labeled attack critical set state minimum denoted critical set general multiple minimum sets state minimum critical sets size critical set attack graph defined critical set initial state minimum critical set attacks mcsa problem problem finding minimum critical set attacks decision version problem defined attack graph positive integer critical set attacks asuch thatjaj assume give attack graph path sequence states complete path starts initial state ends success state label path abusing notation denote subset set attacksa gnf represents set atomic attacks path set attacks ais called realizable attack graph iff exists complete path words intruder set attacks start initial state reach success state set realizable sets attack graph denoted rel lemma easy prove straight definitions lemma assume give attack graph set attacks critical iff rel words realizable sets non-empty intersection critical set ssw qqs xxxx xxz figure attack graph representing exponential number realizable sets definition hitting set problem instance collection subsets finite set positive integer jsj question subset withjs element subset discussion appendix proves problem finding critical sets attack graph polynomially equivalent finding hitting sets collection caveat collection sets represented attack graph attack graph exponentially succinct representation collection sets figure shows attack graph linear size set realizable sets power set sng minimum critical set problem polynomially equivalent hitting set problem collection sets represented labeled directed graph greedy algorithm describe greedy algorithm greedyhitting-set minimum hitting set problem instance hitting set problem initially empty set greedy algorithm executes steps pick element set sns covers maximum number sets collection cnc element cover set iff element picked previous step collection sets covered update fsg d-th harmonic number pdi number sets collection covered element lemma greedy-hitting-set polynomialtime -approximation algorithm maxs sfjc proof lemma equivalence minimum hitting set minimum cover problem proof approximation factor greedy algorithm minimum cover problem equivalence problems finding minimum critical set minimum hitting set construct greedy procedure called greedycritical-set finding critical set attack graph assume attack graph set states set edges initial state success state intruder labeling function assume compute polynomial time function number realizable sets attack graph attack formally equal jfa rel initially empty set greedy algorithm greedy-critical-set executes steps empty pick element setana maximizes element picked previous step update fag remove edges labeled lemma greedy-critical-set polynomialtime -approximation algorithm maxa explore conditions function computed polynomial time assume attack graph dag argument section assume atomic attack path initial state success state unreasonable assumption attack graph edges labeled instantiations attack templates shown section local-setuid-bufferoverflow attack hosts distinct attack graph attack graphs called dags lemma easy prove lemma attack graph dag function computed time linear size attack graph probabilistic analysis attack graphs incorporate probabilities attack graphs choose subset states make transitions states probabilistic suppose graph state outgoing transitions regular attack graph choice transition system state nondeterministic empirical data enables estimate system state average transitions times ten transition remaining times place probabilities edges attack graph intuitively probability transition represents likelihood atomic attack transition succeed call state probabilities outgoing transitions probabilistic assigned probabilities left attack graph probabilistic nondeterministic states call mixed attack graphs probabilistic attack graphs probabilistic attack graphs evaluate reliability network note probabilities transitions lack data type atomic attack attack graph includes states transitions lead success states excludes transitions exist complete model excluded transitions non-zero probability sum probabilities transitions probabilistic state address problem model rest add catch-all escape state attack graph probabilistic state attack graph transition transition state attack graph probability minus sum probabilities states transitions self-loop preserves totality transition relation attack graph escape state attacks allowed terminate call escape attacks attacks pre-empted intruder reached goal definition probabilistic attack graph pag tuple set nondeterministic states set probabilistic states nondeterministic escape state set states transition relation transition probabilities set initial states set success states labeling states set propositions true state probabilistic attack graph pag distinguishes nondeterministic states set probabilistic states set sets nondeterministic probabilistic states disjoint function specifies probabilities transitions probabilistic states transitions viewed probability distribution states intuitively system nondeterministic state information relative probabilities transitions system probabilistic state choose state probability distribution complete probability case assume transition attack graph assigned probability nondeterministic states attack graph function assigns probabilities transitions probabilities loosely interpreted probability atomic attack transition succeeding interested finding reliability attack graph probability intruder succeed view markov chain state space transition probability steady state probability markov chain definitions technical conditions case reliability attack graph expression words reliability probability long run markov chain state set perform similar analysis probabilistic attack graphs presence nondeterministic states reliability assume pag intuitively interested finding probability intruder reach success state starting initial states recall absence nondeterministic states compute metric steady state probabilities markov chain presence nondeterministic states intruder choose transitions order maximize probability succeeding intruder reaches nondeterministic state transitions choose transition state maximize probability reaching success state idea formalized concepts theory markov decision processes state set successors denoted succ formally succ equal define function states nss function iterated equations convergence max succ snnssp succ sqnss function convergence intuitively probability intruder 
state valuation forp vector boolean values expresses boolean denotes set valuations set abstract memory states intuitively concrete memory state modeled satisfies iff true valuation typically models concrete memory states set characterized formula called concretization expresses truth falsity involved properties natural valuation concretization defined asv equal true equal false describes property captured valuation memory states modeled satisfy single predicate valuations true false true false true models concrete memory states variable equal false models concrete memory states variable equal state space ofmexp combine control flow graph predicate abstraction obtain state space sexp mexp state mexp pair models execution states proc control location memory state modeled section show compute transitions states sexp section show extend mexp incorporate specification pas give details theorem provers application theorem provers theorem provers reason expressions expressions involve integer boolean arithmetic importantly pointer arithmetic logic involved complicated undecidable important approach theorem prover conservatively assume logical relationships theorem prover prove section describe principles usage theorem provers give intuition approach logical intricacies involved including uninterpreted function symbols model heap handled tool exceed scope paper omitted construction abstract transition relation determine expressions mutually exclusive end theorem prover compute meta-predicate properties ifa false provably mutually exclusive ifa true theorem prover prove mutually exclusive mutually exclusive proving mutual exclusiveness capabilities theorem prover meta-predicateahas crucial role definition transition relation definition aensures abstraction safe illustrate ofaby important expression normal assignment define weakest precondition respect denote intuitively expression denotes weakest assumption true execution order true execution computed assignment statement thenwp obtained replacing occurrences assignment statement form account aliasing possibilities expression thenwp famous negative solution hilbert tenth problem checking equivalence expressions undecidable simple integer arithmetic restrict range variables bit question computationally hard asgn set normal assignments relation update asgn denotes normal assignments affect valuations defined update asgng intuitively update means proc memory state modeled assignment statement executed admit possibility memory state abstracted reached transition relation texp ready define transition relation texp sexp actspec sexp mexp states mexp state models concrete states proc control component data component modeled denote concrete states modeled concrete transition include transition texp approach guarantees mexp sound model proc rest section describes procedure decide include transition texp make case distinction type final location outgoing transitions types type separately goto letc unique successor control location ofc include intexp change control state program flow data state unaltered normal assignment assignment statement unique successor control location valuation update include texp control state change control flow program data state change disproved theorem prover branch recall cfg branch successors letebe branching condition letc true false successors ifa include texp ifa include texp successor control state provably impossible data state unchanged return return expression return location root unique successor location note final location return actions actspec retval return action possibly equal returned include texp return action actspec include texp call assignment incorporate specification pas stage include transitions originating call assignment locations transitions explained section initial states initial states states consistent guard gspec ecfg set states wherea gspec initial location cfg expanded cfg shown figure valuations states control location actual cfg control locations states mexp color marked letter addition state valuation marked written inlining specification pas section show conclude construction mimp incorporating assumption pas mexp recall purpose step model calls made proc library routines intuitively achieved inline copies ltss call assignment locations respective successors cfg mimp obtained mexp adding states transitions state call assignment unique successor cfg lib call assignment statement assume proc function pointer deal special case hgn pni guard lts list assumption lib guard obtained replacing parameter lib argument passed ifa proceed move guard acti state stop introduce state simp states represent inlined states add transition timp transition connects call location state initial inlined state transition stop add transition timp transition stop return action true add timp transition stop return action thatupdate retval true add timp lib function pointer repeat construction target lib listed user assumption lts lock shown top figure mimp obtained incorporating lts lock mexp figure shown bottom states mexp mimp colored identically similarly states lts lock inlined states mimp identical colors clear mimp simulated mspec figure return return return return lock lock lock implementation lts assumption lts lock stop return return inlined states inlined states figure lts lock mimp enhancements implementation issues describe enhancements basic framework implemented magic omitted presentation simple making predicate abstraction efficient set valuations exponential number predicates magic theorem prover group predicates mutually exclusive predicate group true time number valuations group equal size group reduces size state space dramatically suppose predicates originally formed groups predicates number valuations reduces sixteen assumed fixed set predicates discussion magic sets predicates predicates abstracted control locations indiscriminately inefficient similar method blast automatic predicate discovery effectiveness predicate abstraction relies critically set predicates model extraction process requires predicates supplied externally directed magic discover suitable sets predicates discuss full details predicate discovery process paper experiments magic manages automatically discover good predicate sets correctly prove disprove simulation property interfacing theorem provers explained construction mimp efficient theorem provers integrated magic publicly theorem provers cases simplify cvc ics version software command line arguments run separate processes interface standard inputs outputs cases cprover software libraries well-defined apis link directly magic cases cache results avoid redundant calls theorem prover case studies experiments guided general goals wanted assure correctness tool experimenting examples correct outcome wanted evaluate relative performances publicly software theorem provers sat solvers integrated system wished validate usefulness tool handling large real life examples regression tests goals achieved suite regression tests small size tests derived actual linux kernel code figure describes source test briefly loc number post-processed lines procedure analysed italics description modified procedure means source code changed longer safely abstracted specification lts library procedure belongs brackets procedure regression loc description lock-y pthread mutex lock pthread unlock-y pthread mutex unlock pthread socket-y socket socket sock alloc-y sock alloc socket sys send-y sys send socket sock sendmsg-y sock sendmsg socket lock-n modified pthread mutex lock unlock-n modified pthread mutex unlock sock alloc-n modified sock alloc sock sendmsg-n modified sock sendmsg figure descriptions regression tests verifying openssl achieve goal opted work openssl open source implementation publicly ssl specification protocol 
client typically web browser server establish secure socket connection malicious network public symmetric key cryptography critical component protocol handshake verified opensslc implementation server side handshake conforms specification implementation encapsulated single procedure lines constructed target lts mspec manually reading ssl specification lts states transitions total predicates pas library routines supplied externally carried experiments correct target lts modified target lts size correct implementation longer simulated repeated identical experiments client side implementation encapsulated single procedure lines target lts states transitions total predicates pas library routines supplied externally lock-y unlock-ysocket-ysock alloc-ysys send-ysock sendmsg-ylock-n unlock-nsock alloc-nsock sendmsg-n regression test time construct implementation lts simplify ics cvc cprover figure time construct mimp regression test results experiments ghz amd athlon machine ram running redhat linux figure summarizes performance results theorem provers obtained regression suite y-axis drawn log scale shows time needed constructmimp milliseconds clear indicator performance theorem prover similarly figure summarizes performance results sat solvers obtained regression suite y-axis time milliseconds needed check simulation step sat solver openssl results case openssl server experiments fact correct specification lts safely abstracts openssl implementation proved tool seconds memory tool successfully verified modified specification lts safely abstract implementation seconds memory client experiments figures seconds seconds owing compositionality verify validity assumption pas experiments comparison theorem provers sat tools closer bar graphs reveal consistent trends purposes tool theorem provers arranged decreasing order efficiency simplify ics cvc cprover theorem provers comparable efficiency superior cprover sat solvers arranged decreasing order efficiency lock-y unlock-ysocket-ysock alloc-ysys send-ysock sendmsg-ylock-n unlock-nsock alloc-nsock sendmsg-n regression test time check simulation horn chaff fgrasp sato figure time check simulation horn chaff fgrasp sato external solvers chaff easily matching hornsat based implementation fgrasp sato easily distinguishable difference performance general sat solvers hornsat solver implemented prominent larger openssl time required checking simulation openssl server experiment openssl client experiment seconds seconds hornsat solver comparison figures chaff seconds seconds negative results reported figures obtained user supplied predicates repeated experiments automatically discovered predicates higher execution times observed reason automatic predicate discovery process yields predicates leads larger number states mimp greater execution times improving predicate discovery technique good area research future work enormous potential extending basic framework implemented magic conclusion list notable areas future research generation diagnostic feedback automatic model refinement abstraction techniques precise modeling heap iii extending magic infrastructure languages java handling concurrency automatic predicate discovery bandera http cis ksu santos bandera blast http www-cad eecs berkeley rupak blast business process execution language web services http oasis-open cover bpel html esc-java http research compaq src esc java pathfinder http ase arc nasa gov visser jpf openssl http openssl slam http research microsoft slam ssl specification http netscape eng ssl unified modeling language http uml ausiello italiano on-line algorithms polynomially solvable satisfiability problems journal logic programming january ball majumdar millstein rajamani automatic predicate abstraction programs sigplan conference programming language design implementation pages ball podelski rajamani boolean cartesian abstraction model checking programs lecture notes computer science ball rajamani automatically validating temporal safety properties interfaces lecture notes computer science biere cimatti clarke zhu symbolic model checking bdds lecture notes computer science clarke emerson sistla automatic verification finite-state concurrent systems temporal logic specifications acm transactions programming languages system toplas april clarke grumberg jha veith counterexample-guided abstraction refinement computer aided verification pages clarke grumberg long model checking abstraction acm transactions programming languages system toplas september clarke grumberg peled model checking mit press das dill park experience predicate abstraction computer aided verification pages dowling gallier linear time algorithms testing satisfiability propositional horn formula journal logic programming dwyer hatcliff joehanes laubach pasareanu zheng visser tool-supported program abstraction finite-state verification international conference software engineering pages ieee computer society engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions symposium operating systems design implementation filliatre owre ruess shankar ics integrated canonizer solver computer-aided verification hallem chelf xie engler system language building system-specific static analyses sigplan conference programming language design implementation harel statecharts visual formalism complex systems science computer programming june havelund pressburger model checking java programs java pathfinder international journal software tools technology transfer henzinger jhala majumdar sutre lazy abstraction symposium principles programming languages pages hoare communicating sequential processes communications acm cacm august kroening application specific higher order logic theorem proving autexier mantel editors proc verification workshop verify pages july magee kramer concurrency state models java programs wiley marques-silva sakallah grasp search algorithm satisfiability ieee acm international conference computer-aided design november matiyasevich hilbert tenth problem mit press milner communication concurrency prentice-hall milner communicating mobile systems calculus cambridge press moskewicz madigan zhao zhang malik chaff engineering efficient sat solver design automation conference june nelson techniques program verification phd thesis stanford graf saidi construction abstract state graphs pvs grumberg editor computer aided verification volume pages springer verlag shukla uniform approaches verification finite state systems phd thesis suny albany stump barrett dill cvc cooperating validity checker conference computer-aided verification zhang sato efficient propositional prover conference automated deduction 
max copy min buffer min copy buffer return max copy max copy buffer return min copy min context-sensitivity obtained modeling call-site function set assignments renamed instances formal variables actual-in variables assigned renamed formal-in variables renamed formal-out variables assigned actual-out variables result assignment renamed formal-in parameter function alleviates problem merging information calls function approach constraint generation obtain range forcc allocandcc usedrespectively alloc obtain improvement values reported figure note constraint inlining approach obtain variable calling context calling context encoded implicitly renamed variable price exponential number calling contexts constraint system large number variables result large number constraints approach work recursive function calls drawbacks overcome summary information approach inter-procedural dataflow analysis suggested sharir pnueli summary obtained function foo summary information callsite foo simulate effect call case function summarized generating summary constraints summarize effect function terms constraint variables representing global variables formal parameters function equivalent finding projection constraints generated function global variables formal parameters function problem well-known solutions function generates difference constraints problem finding summary constraints reduces instance all-pairs shortest path algorithm efficient algorithms general kinds constraints fourier-motzkin variable elimination algorithm instance constraints generated copy buffer function modify global variables obtain summary constraints shown projecting constraints formal parameters function copy buffer return alloc max buffer max copy buffer return max buffer max copy buffer return alloc min buffer min copy buffer return min buffer min obtain context sensitivity constraints callsite copy buffer formal parameters appearing summary constraints replaced actuals constraints generated line replacing constraint variables buffer copy buffer return summary constraints constraint variables header similarly relationship buf line obtained substituting place copy buffer return buffer summary constraints note retain assignment actual variable formal-in parameter obtain values constraint variables local variables called function approach efficient constraint inlining approach increase number constraint variables precise constraint inlining reason observe constraint inlining variables renamed callsite enabling examine values due calling context hand summary constraints approach values variables merged calling contexts leading loss precision instance program figure values alloc alloc obtained constraint inlining values copy alloc copy values variables obtained due calls line line merged constraint inlining approach returns values copy alloc copy due call line returns due call line approach capable handling recursive function calls simplicity attempt summarize recursive function calls prototype implementation experience tool tested prototype implementation popular commercially programs case tool produced warnings warnings combined codesurfer features slicing check real overruns tested tool discovered overruns documented public databases bugtraq cert checked overruns previously unreported discovered report experience wu-ftpd sendmail results packages experiments performed ghz pentiumxeon processor machine ram running debian gnu linux codesurferfor experiments gcccom- piler building programs codesurfer implements pointer analysis algorithms case performed experiments field-sensitive version andersen analysis common-initial-prefix technique yong horwitz deal structure casts configured tool hierarchical solver section constraint resolution values obtained precise produce constraints context-insensitive fashion section discusses effects context-sensitive constraint generation wu-ftp daemon tested versions wu-ftp daemon popular file transfer server version older version vulnerabilities cert advisories ca- ca- ca- version current version security patches address vulnerabilities wu-ftpdwu-ftpd- lines code produced warnings examined tool examining warnings found previously unreported overruns describe detail tool reported potential overrun buffer pointed accesspath procedure read servers line file rdservers bytes copied buffer bytes allocated figure shows code snippet read servers line responsible overrun int read servers line file svrfp char hostaddress char accesspath static char buffer bufsiz fgets buffer bufsiz svrfp gethostbyname hcp struct addr memmove hph addr sizeof strcpy hostaddress inet ntoa strcpy hostaddress hcp strcpy accesspath acp figure code snippet wu-ftpdthe fgets statement copy bufsiz bytes buffer processed function result processing acp hcp point locations inside buffer choice contents buffer make acp hcp point string buffer long bytes result overflow buffer pointed accesspath hostname procedure read servers line called places code instance called main procedure ftprestart read servers line called local buffers hostaddress configdir allocated bytes bytes call reads contents file path ftpservers typically privileged access non-standard unusual configurations system path ftpservers written local user result buffers hostaddress configdir overflow based carefully chosen input string possibly leading local exploit strncpy strlcpy statement unsafe strcpy read servers line rectifies problem overruns detected tool unchecked sprintf main file ftprestart result bytes written local buffer allocated bytes unchecked sprintf main file ftprestart result bytes written local buffer allocated bytes unchecked strcpy main file ftprestart result bytes written local buffer allocated bytes cases carefully chosen string file path ftpaccess overrun path ftpaccess typically privileged access written local user non-standard configurations contacted wu-ftpd developers acknowledged presence bugs code process fixing bugs time writing paper wu-ftpdwu-ftpd- lines code analyzed tool produced warnings analyzed warnings check widely exploited overrun reported cert advisory ca- buffer overflow globally declared buffer mapped path procedure elem file ftpd noted overrun due statement strcat mapped path dir variable dir derived indirectly user input result overflow mapped path bytes allocated tool reported range mapped path mapped path alloc call strcat dst src modeled linear constraints tool dst max dst max src max dst max dst max dst min dst min src min dst min dst min constraints make linear program infeasible explained section result dst max set wu-ftpdmapped path max set tool reported range absence overrun codesurfer program slicing feature confirm dir derived user input found procedure elem parameters dir called proceduremapping chdir function turn called procedure cmd input arguments controlled user shows importance providing end user program analysis features features program slicing control data dependence predecessors part codesurfer aid user tool understand source code locate source vulnerability sendmail sendmail popular mail transfer agent analyzed sendmailan version released code audit version version vulnerabilities analyzed sendmailin march buffer overrun vulnerabilities reported latest version sendmail sendmailand sendmailare vulnerable overruns sendmailsendmail- lines code analyzed tool produced warnings due large number warnings focused scanning warnings detect overruns wagner boon report off-by-one bug sendmailwhere bytes returned functionqueuename written byte arraydfname tool identified program points sendmailwhere return queuename copied strcpy statements buffers allocated bytes tool reported return queuename bytes long manual analysis required decipher fact off-by-one bug minor off-by-one bug reported tool programmer mistakenly allocated bytes buffer delimbuf stored nnnt bytes long including end string character sendmailsendmail- significantly larger version lines code 
ran tool produced warnings examined warnings check tool discovered vulnerabilities reported march vulnerabilities function crackaddr file headers parses incoming e-mail address string function stores address string local static buffer called buf declared maxname bytes long performs boundary condition checks buf overflow condition handles angle brackets address string imprecise leading overflow tool reported pointer buffer buf function alloc max max raising warning reason alloc max max set pointer arithmetic statements body function statement bp-resulted alloc max max warning existed boundary condition checks correct note bug hard track precisely flow-insensitive analysis discovered control dependence information associates statement predicate decides statement executed crucial detecting overruns reliably working enhancing infrastructure support features performance table representative numbers experiments wu-ftpdand sendmailall timings obtained unix time command codesurfer denotes time codesurfer analyze program generator denotes time constraint generation taint denotes time taint analysis constraints produced resolved ways rows lpsolve hiersolve report time iis detection based approach wu-ftpdsendmail- codesurfer sec sec generator sec sec taint sec sec lpsolve sec sec hiersolve sec sec total hier sec sec number constraints generated pre-taint post-taint table performance tool hierarchical solves approach section number constraints output constraint generator reported row pre-taint post-taint denotes number constraints taint-analysis noted earlier iis detection based approach efficient mathematically precise hierarchical solver mathematically precise found solution produced iis detection based approach good approximation solution obtained hierarchical solver case wu-ftpdfewer constraint variables case sendmailfewer constraint variables obtained imprecise values iis detection based approach found imprecision significantly affect number warnings case wu-ftpdand sendmailthe iis based approach resulted warnings warnings false alarms shows practice faster iis detection based approach loss precision adding context sensitivity report experience context-sensitive analysis wuftpdusing constraint inlining approach summary constraints approach note adding context sensitivity find overruns adding context sensitivity constraints generated precisely reflect call-return semantics functions result expect precise values constraint solvers measure effectiveness approach count number range variables refined comparison ranges obtained context-insensitive analysis recall range variable var constraint variables var min var max var min var max chose metric explained section detector values ranges produce diagnostic information precise ranges precise diagnostic information context-insensitive analysis wuftpdyields values range variables summary constraints approach found range variables obtained precise values note approach number constraint variables number range variables context-insensitive analysis number constraints change observed increase number constraints change attributed fact summarization introduces constraints summaries removes constraints call-site assignment constraints constraint inlining approach hand leads increase number constraints increase number constraint variables number range variables attributed fact inlining based approach specializes set constraints callsite observed range variables context-insensitive analysis specialized range variables based calling context count number range variables obtained precise values ways specialized range variables range variables obtained precise values unspecialized range variables unspecialized range variables range variables obtained precise values calling context noted earlier constraint inlining approach returns precise information summary constraints based approach concrete program variable msgcode integer formal parameter function mesg file access wu-ftpdthe function mesg called places code values parameter msgcode summary constraints approach results range variable msgcode constraint inlining refines ranges instance infer mesg called function pass file ftpd effects pointer analysis observed section reduce false negatives pointer analysis tool capable handling arbitrary levels dereferencing instance points pointer structure pointer analysis algorithms correctly infer fact similarly type char point-to pointers buffers constraints statement strcpy correctly modeled terms points-to sets recall generated constraints terms pointers buffers buffers observe benefits pointer analysis generated constraints pointer analysis algorithms turned fewer constraints generated expect fewer warnings absence warnings false negatives result observed concrete case case sendmailwhen generated constraints including results pointer analysis algorithms tool output warnings opposed warnings method resulted warning array dfname suppressed tool missed off-by-one bug earlier closer procedure queuename revealed absence points-to facts tool failed generate constraints statement snprintf buf sizeof buf type body queuename points facts variable pointer structure generated note boon identified off-by-one bug simple assumption made model effect pointers boon assumes pointer structure type point structures type technique effective discovering bugs lack precise points-to information lead larger number false alarms shortcomings found prototype implementation tool audit real world applications noted shortcomings working overcoming limitations flow insensitivity analysis meant false alarms slicing weed false alarms manual painstaking procedure benefits observed adding context-sensitivity limited flow insensitivity analysis transitioning static single assignment ssa representation program add limited form flow sensitivity program ssa representation result large number constraint variables fortunately observed solvers readily scale large linear programs thousand variables modeling constraints terms pointers buffers buffers miss overruns leading false negatives reason pointer analysis algorithms flowand context-insensitive generating constraints terms buffers resulted large number constraints large number false alarms transitioning pointer analysis algorithms model constraints terms buffers eliminating false negatives conclusions demonstrated light-weight technique analyze source code detect buffer overrun vulnerabilities shown efficacy technique applying real world examples identifying vulnerabilities popular security critical package techniques ideas linear programming literature provide enhance context sensitivity output tool coupled program understanding features codesurfer static slicing aid user comprehend eliminate bugs source code acknowledgments members wisconsin safety analyzer research group michael ferris aditya rao anonymous reviewers suggestions bugtraq securityfocus cert advisories cert advisories twenty critical internet security vulnerabilities sans top aleph-one smashing stack fun profit nov phrack magazine technical analysis remote sendmail vulnerability securityfocus archive andersen program analysis specialization programming language phd thesis diku univ copenhagen diku report anderson anderson presolving linear programming mathematical prog bodik gupta sarkar abcd eliminating array-bounds checks demand acm conf prog lang design impl pldi chinnek dravinieks locating minimal infeasible constraint sets linear programs orsa journal computing t-c chiueh f-h hsu rad compile-time solution buffer overflow attacks intl conf distributed computing systems icdcs condit harren mcpeak necula weimer ccured real world acm conf prog lang design impl pldi cormen lieserson rivest stein introduction algorithms mit press cowan beattie r-f day wagle walthinsen automatic detection prevention buffer overflow attacks usenix sec symp cowan beattie johansen wagle pointguardtm protecting pointers buffer overflow vulnerabilities usenix sec symp cytron ferrante rosen wegman zadeck efficiently computing static single assignment form control dependence graph acm trans prog lang systems toplas dantzig curtis eaves fourier-motzkin elimination dual journal combinatorial theory dor rodeh sagiv cssv realistic tool statically detecting buffer overflows 
acm conf prog lang design impl pldi etoh yoda protecting stack-smashing attacks trl ibm projects security ssp main html ganapathy jha chandler melski vitek buffer overrun detection linear programming static analysis uw-madison comp sci tech report ftp ftp wisc pub tech-reports reports horwitz reps binkley interprocedural slicing dependence graphs acm transactions prog lang systems toplas horwitz reps sagiv rosay speeding slicing acm symp foundations soft engg fse pages york larochelle evans statically detecting buffer overflow vulnerabilities usenix sec symp larson austin high coverage detection input related security faults usenix sec symp necula mcpeak weimer ccured type-safe retrofitting legacy code acm conf principles prog lang popl cplex optimizer cplex rugina rinard symbolic bounds analysis pointers array indices accessed memory regions acm conf prog lang design impl pldi schrijver theory linear integer programming wiley sharir pnueli approaches interprocedural dataflow analysis prentice hall wagner static analysis computer security techniques software assurance phd thesis berkeley dec wagner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed system security ndss wright primal-dual interior-point methods siam philadelphia wunderling paralleler und objektorientierter simplex-algorithmus phd thesis konrad-zuse-zentrum fur informationstechnik berlin zib paperweb abstracts tr- xie chou engler archer symbolic path-sensitive analysis detect memory access errors european soft engg conf acm symp foundation soft engg esec fse yong horwitz reps pointer analysis programs structures casting acm conf prog lang design impl pldi 
reach success state resolves nondeterminism maximize probability succeeding worst case reliability network algorithm iteration justification iteration algorithm presented companion technical report implemented iteration algorithm attack graph post-processor ran slightly modified version intrusion detection section modified attack detectable stealthy variants intruder chooses atomic attack probability picking stealthy detectable variant assigned imaginary probabilities picking stealthy attack variant sshd buffer overflow ftp rhosts remote login local buffer overflow intruder goal obtain root access host remaining undetected states goal achieved assigned benefit setup computed probability intruder success strategy attempt sshd buffer overflow host conduct rest attack host possibility detection sshd buffer overflow attack ids activity hosts context system administrator question question deployment security measure increase likelihood thwarting attacker answer installing additional ids component monitor network traffic hosts reduces probability intruder remaining undetected installing host-based ids host reduces probability things equal indication remedy effective summary contributions future work foremost contribution automatic generation attack graphs key insight attack equivalent counterexample produced off-the-shelf model checkers attack counterexample witness violation safety property small critical enhancement existing model checker easily produce attack graphs automatically graphs succinct exhaustive by-product part work showing level abstraction modeling attacks simple state machine specifications model intruder behavior set atomic attacks normal system behavior system administrator recovery actions connectivity communication subsystems important contribution support range formal analyses attack graphs security analysts attack graphs informally attack detection defense forensics paper explain minimization analysis technique attack graphs precisely answer questions security measure deploy order thwart set attacks set security measures deploy guarantee safety system explain briefly text detail technical report probabilities perform reliability analysis annotating attack graphs probabilities interpret markov decision processes mdp mdp algorithms iteration security analysts precisely answer questions attack incur damage system deploying intrusion detection system increase decrease likelihood thwarting type attack theoretical front plan exploit full power model checking exploring handle liveness properties safety properties property states user access file server violated server disabled due denial-of-service attack practical front plan conduct larger case studies illustrate usefulness automatically generating attack graphs intend build tool merges work attack graphs existing intrusion detection technologies tool intended security analysts evaluate enhance security network altman constrained markov decision processes chapman hall crc ausiello atri protasi structure preserving reductions convex optimization problems journal computational system sciences jcss bryant graph-based algorithms boolean function manipulation ieee trans comput aug clarke grumberg peled model checking mit press cormen leiserson rivest introduction algorithms mit press dacier quantitative evaluation computer security phd thesis institut national polytechnique toulouse december durrett probability theory examples duxbury press edition garey johnson computers intractibility freeman company jha sheyener wing formal analyses attack graphs technical report cmu-cs- carnegie mellon february nusmv symbolic model checker http afrodite itc nusmv ortalo deswarte kaaniche experimenting quantitative evaluation tools monitoring operational security ieee transactions software engineering sept oct phillips swiler graph-based system network vulnerability analysis acm security paradigms workshop pages puterman markov decision processes-discrete stochastic dynamic programming john wiley sons york ritchey ammann model checking analyze network vulnerabilities proceedings ieee symposium security privacy pages sheyner haines jha lippmann wing automated generation analysis attack graphs proceedings ieee symposium security privacy smv symbolic model checker http wwwcs cmu modelcheck stephenson formal methods forensic analysis intrusion events preliminary examination white paper http imfgroup document library html swiler phillips ellis chakerian computer-attack graph generation tool proceedings darpa information survivability conference exposition june valdes skinner probabilistic alert detection recent advances intrusion detection raid appendix section assume attack graph suppose compute set realizable sets rel lemma proves problem finding attack graph critical set size hitting set problem rel suppose instance hitting set problem construct attack graph set attacks attack graph set realizable sets rel graph collection critical set size attack graph hitting set collection describe construction cmg collection sets sngbe set make copies set set elements denoted byfsi sing set states attack graph initial state final state set edges labeling function defined edge state set label edge edge sij sij label edge sij sij edge state set smngto state labels edges sizes sets attack graph easy rel equal critical set attack graph iff hitting set collection size polynomial size instance hitting set problem hitting set problem np-complete mcsa problem np-hard lemma proves mcsa mcsa np-complete illustrates construction note discussion proves problem finding minimum set measures adoption make network safe np-complete simply set measures set attacks give short illustrate reduction set suppose collection consists subsets attack graph problem shown figure set attacks set realizable sets rel collection set attacksfs gis critical path success state edge label setfs gis hitting set collection figure attack graph collection 
values method computing witness dags straightforward transfer distributed case input weighted pushdown systemw wherep regular set configurations output pre general infinitely configurations pre finite hope compute solution symbolically annotated finite automata purpose definition p-automaton quintuple finite set states set transitions final states initial states control locations sequence transitions reads configuration arbitrary states sequence accepting iff final state configuration denote acca set accepting transition sequences accepted acca non-empty note set configurations regular accepted p-automaton fixed omit prefix speak simply automata convenient property regular sets configurations closed forwards backwards reachability words automaton accepts set construct automata accept sets configurations forward backwards reachable additional labelings transitions computed solve gpp gps problems assigns weight automaton transition compute compute function mentioned earlier omit labeling sake simplicity loss generality assume henceforth rule arrowhookleft pprime restrictive pushdown system simulated obeys restriction larger constant factor present abstract version procedure designed centralized computation proceed give implementation distributed case abstract algorithm p-automaton accepts set configurations loss generality assume transition leading initial state initially set transition updated action add set update gpp add transitions saturation rule arrowhookleft pprime rule sequence reads ends state update procedure terminates saturation rule longer applied fixed point reached concrete algorithm concrete implementation reproduced figure iteration loop starting line executes applications saturation rule computation finished resulting automaton accepts configurations pre circleplustextt acc aprime time complexity gpp algorithm figure stated lscript lscript length longest descending chain space complexity determined number transitions final automaton algorithm input weighted pushdown system automaton accepts transitions states output automaton aprime accepts pre annotation function procedure update begin newvalue newvalue negationslash workset workset newvalue end workset arrowhookleft pprime update pprime workset negationslash remove transition qprime workset arrowhookleft update qprime arrowhookleft tprime qprime qprimeprime update qprimeprime tprime arrowhookleft pprime tprime pprime update qprime tprime return fig algorithm creating weighted automaton gpp problem distributed algorithm discuss computation distributed rules distributed set sites servers section discuss gpp gps case give concrete implementation gpp gps similar fix weighted pushdown system regular set configurations solution discuss distributes workload servers control locations control location server responsible precisely make assumptions exists mapping sites assigns control locations sites rule arrowhookleft pprime stored site gps problem pprime gpp problem stating assumption differently working collection sites weighted pushdown systems differ rules set satisfies assumption rule arrowhookleft pprime boundary rule pprime assigned sites boundary rule exists call sites responsible pprime neighboring sites definition -dag sites edge vprime called boundary edge boundary rule vprime called boundary node site denote configurations begin control locations site responsible s-region subgraph vprime informally s-region subgraph induced nodes configurations sis responsible fringe subgraph boundary edges originating target nodes abstract algorithm give abstract description gpp gps algorithms site computes set cpre def pre pre gpp case cpost def post post gps case write cpre cpost depending context intuitively speaking site computes partition pre post set configurations control locations responsible extended configurations reached boundary rules note set configurations generated rules stored idea site involved gpp gps computation discovered negationslash initially site starts set boundary rule site discover configurations belongs sprime site sprime negationslash send configurations sprime sprime continues gpp gps computation configuration concrete algorithm concrete level description site computes automaton accepts labeling functions witness dags basically distributed algorithm straightforward extension non-distributed case site runs gpp gps algorithm similar figure main complication parts automata shared sites precise automaton accepts initially automaton accepts constructed taking states transitions reachable initial states site carries algorithm figure sprime neighboring sites stage computation automaton accept configurations sprime configurations maintained sprime sprime set transitions uniontextc sprime accas transitions form part accepting path configurations detects transition belongs sprime update transition automaton sends sprime site ends automaton accepts configurations site computes information construct function witness dags notice vertices s-region -dag labeled configurations edges region labeled rules stored information needed construct s-region precisely information needed construct s-region generated annotation automaton maintained function computed form annotation labels automaton transitions semiring values sending transition site semiring values configuration obtained evaluating automaton afs shown section figure shows made algorithm implement approach figure shows algorithm point view site algorithm maintains mapping sites sites sprime sites current automaton path leads initial state sprime state means transitions form qprime part accepting paths configurations sprime consequence transition generated updated sprime qprime added sites sprime algorithm consist parts procedure update replaced version additional procedure add recursive couple lines added beginning main procedure lines main procedure initialize sites function update function extended lines lines send updated transition sites required sending transition site sprime represented updatesprime thought remote procedure call function update site sprime adds worklist sprime finally target state added sites sprime procedure add recursive takes care sending additional transitions sprime required algorithm running site input weighted pushdown system automaton accepts transitions states output automaton aprimes accepts cpre annotation function replacement update procedure procedure update begin newvalue newvalue negationslash workset workset newvalue assume sprime sites updatesprime add recursive sprime end procedure add recursive procedure add recursive sprime begin sprime sites return sites sites sprime tprime prime qprime updatesprime tprime tprime add recursive qprime sprime end additions main procedure sites arrowhookleft pprime negationslash sites sites fig modification algorithm distributed gpp complexity state complexity algorithm run site main procedure unchanged runs lscript time lscript longest descending chain additional work required sending receiving transitions neighboring sites suppose neighboring sites sites send transitions send receive action perform constant amount work note bounded transition received lscript times effort received transitions lscript practice expect lower worst case send transitions neighbors lscript times lscript expect number lower practice background spki sdsi spki sdsi principals represented public keys principal public key principal individual process host entity denotes set public keys specific keys denoted kprime identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates spki sdsi types certificates certs certificates certs cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier 
homework due date tuesday warning assignment construct launch attacks vulnerable computer network network administrators aware homework exercise expect attacks machine techniques homework attack machine network greater internet root-level access target machine launch attacks head criminal repercussions activity homework assumes not-insignificant level experience comfort unix linux shell furthemore assignment emphasizes research experimentation start work assignment early wily hacker assignment guides steps attacker launching attack network end goal retrieve password file shadow specific machine located building password file readable root gain root access machine multi-stage attack requires significant effort part reach password file remotely scan machine run remote buffer overrun exploit run local format string exploit break chroot jail difficulty successfully completing stages attack provide alternate instructions bypass stage complete continue assignment alternate instructions solve stages orders solve stages complete attack alternate routes worth points follow alternate instructions solve stage receive points stage receive points questions answer writeup lengthy homework problem requires tools unfamiliar google things understand allowed online resources point deduction final homework writeup cite urls programs run installed lab machines mihai public target machine address machine running ubuntu linux kernel network access blocked internet reach victim machine inside networks work home non-cs computer lab ssh computer lab run attacks lab machine attack work remotely portscan machine find vulnerable network service construct buffer overflow exploit run vulnerable http server gain user-level access remote machine server runs chroot jail limited filesystem access stage bypass instructions build successful overflow exploit gain root access constructing format string attack vulnerable setuid-root program running chroot jail stage bypass instructions build successful format string attack root break chroot jail gain full filesystem access copy password file shadow csl lab account hand tarball zip file buffer overflow exploit format string exploit source code jailbreak program shadow file retrieved typed write-up solutions questions tarball zip file mihai wisc due date direct questions assignment mihai christodorescu mihai wisc contact difficulties crashed follow directions listed things work exploit valid work started spring homework page stage exploration portscan learn services running scan program nmap feel free scan types provided nmap limit scans code nmap scana nmap starting nmap insecure nmap interesting ports nmap results follow services running open filtered closed ports nmap identify port open filtered closed simple http server running server buffer overflow vulnerability point entry system stage verify server correctly delivers files opening http index html favorite web browser stage gain remote user access portscan shown running http server server buffer overflow vulnerability input processing exploit gain access machine stage build buffer trigger vulnerability eventually send buffer attack convert web server shell process allowing execute arbitrary commands victim machine review buffer overflow vulnerabilities continuing source code web server running file httpd located mihai public httpd review source code answer questions explain buffer overflow bug httpd bug propose source code patch remove vulnerability construct exploit vulnerability compiled httpd running located mihai public httpd grab copy work exploit locally attack exploit works local httpd spring homework page httpd simple reads http request standard input writes output standard output takes single command-line parameter specifies root directory code sample execution httpd programa echo cshrc httpd http content -type text html content -length connection close file cshrc read comments explain output continues construct buffer exploits overflow vulnerability test buffer simply feeding httpd input unix pipe redirected input build buffer writing text file specifies byte buffer two-character hexadecimal duplet byte sequence listed text file program mihai public make bin read text file input output file binary representation hex duplets file overflow bin input httpd code make bin hex generatora make bin overflow hex overflow bin httpd overflow bin alternatively set pipe chain code make bin pipe chaina cat overflow hex make bin httpd provided file mihai public segfault hex httpd segfault task create overflow hex file exploits buffer overflow vulnerability httpd execute shell process overflow inject shellcode program shellcode instructions appeared original program written shellcode file mihai public shellcode assembly-language instructions syntax making shellcode mihai public shellcode hex hexadecimal representation shellcode analyze assembly code mihai public shellcode code approach build exploit buffer suggest spring homework page figure manipulate return address stack start segfault hex find place buffer overwrites return address computing size stack frame simply manipulating values segfault hex buffer memory values written figure address choosing figure include shellcode buffer hexadecimal-encoded shellcode mihai public shellcode hex figure put shellcode buffer identify address shellcode memory buffer overrun make buffer overwrite return address result function returns program execution jump shellcode special note correct exploit segfault tested csl lab machines correct exploit overwrites return address stack shellcode resides csl machines security restriction place instructions stack execute program reads overwritten return address attempts execute code stack segfault machine restriction test exploit csl lab machine debugger gdb return instruction return address top stack exploit work run httpd inside debugger insert breakpoint return instruction clobbered return address run program exploit buffer input breakpoint check return address targets shellcode buffer exploit successful run remotely executing httpd weird syntax command sends exploit connection open sending exploit code code buffer-overflow attacka make bin overflow hex overflow bin cat overflow bin cat exploit successful receive bash-shell prompt remote machine logout successful attack type exit close bash prompt type control-d close locally-executing cat process include overflow hex file tarball zip file hand alternative instructions stage unable construct buffer successfully triggers overflow vulnerability give shell connect ssh continue homework assignment level access equivalent access gained successful exploit spring homework page ssh username student password student worth points connecting successful overflow alternate instructions type whoami note root access filesystem bit strange commands bin usr bin isn kernel shadow wrong reason filesystem empty exploited process executing inside chroot jail discussed stage full filesystem break jail breaking requires root privilege gain stage hints stage stack stabilizing macro httpd relevant overflow vulnerability simply present make exploit construction easier completely ignore macro find overflow httpd compiling program gcc test exploit precompiled httpd provide test httpd compile offsets program change successful exploit recompiled httpd successful httpd running processor endian affects values overwrite return address stage gain remote root access escalate privilege user root exploit 
vulnerability setuid-root program user installed program programs run privilege user executing program setuid programs run privilege owner program owner root execute root privilege program unix switch user command program run root switch user system including root verifying password switching user executes shell process privilege user machine vulnerable program accessible chroot jail program vulnerable format string attack programs written unix linux output functions make format string printf good attacker format string passed function printf provide string printf write arbitrary values arbitrary memory locations source code mihai public binary program mihai public spring homework page identify explain format string bug propose source code patch remove vulnerability create format string attack attack buffer overflow exploit insert shellcode format string overwrite return address return address program execution bypass code performs safety checks password verification execute shell root privilege format string attacks exceptionally complicated written entire format string task address overwrite existing return address analyze code find existing instruction return instruction jump identify address generate format string command make string located mihai public make string create format string overwrite return address address main function code creating format stringa make string format bin test format string local copy mihai public code performing format-string attacka grave cat format bingrave successful exploit start shell process local copy setuid shell root-level format string produced make string attack work meaning bizarre format string string return address overwritten special note correct exploit segfault tested csl lab machines machine restriction sufficient identify instruction return instruction jump test exploit debugger gdb run inside debugger set breakpoint instruction identified exploit correct execution stop instruction format string executes shell locally attack remote process connect back buffer overflow alternate instructions move directory home student make directory upload format string directory scp student account upload format string file losing points run attack successful attack give bash prompt root privileges spring homework page code format-string attacka bin grave cat home student myname format bingrave weird output bash whoami root clean removing directory files added attack successful include format string tarball zip file hand alternative instructions stage unable construct format string successfully triggers vulnerability gain root access executing bin make-me-root worth points inside chroot jail limited filesystem access privileges break jail hints stage stack stabilizing macro relevant format string attack present make exploit construction easier completely ignore macro stage chroot jailbreak processes exploited executing inside chroot jail chroot jail security feature limits filesystem access processes process exploited stages attacker limited access underlying system linux kernel data structure process executing system data structure includes field specifies process root directory processes root matches actual filesystem root process inside chroot jail root directory files reachable process root directory accessed process rest filesystem unreachable attacker full access filesystem break chroot jail resetting root directory actual filesystem root task stage write program break chroot jail textbook online resource break jail make cite source writeup writing compiling program connect root access create subdirectory home student upload jailbreak program directory scp student account upload format string file losing points run program break chroot jail spring homework page break successful access entire filesystem include source code jailbreak program tarball zip file hand explain break chroot jail chroot jail insecure allowed break jail made secure attacked programs bin httpd bin inside chroot jail complete path programs actual filesystem root directory stage root-level activity run arbitrary commands root privilege destructive severely unhappy reinstall operating system midway assignment full access filesystem copy real shadow csl account include shadow tarball zip file hand spring homework page 
homework due date november somesh jha computer science department wisconsin madison november question points part express relations figure relations class operators give short justi cation answer part cousinsfatherside cousinsmotherside cousins set cousins separated n-steps father side mother side father mother side write recursive expression relations express relations parameter terms relations parameter basic relations introduced fatherinlaw people males sisterinlaw people females firstcousinsfatherside people people firstcousinsmotherside people people firstcousins people people secondcousinsfatherside people people secondcousinsmotherside people people secondcousins people people figure relations class question points establish equations relations true justify answer enter equations ladybug play assume relations types note symbol denotes empty relation question points question write speci cation problem aim model library types persons books function issued books persons set library set books book issued person issued library represents set books library set books reserve set reserve set books operations issue book operation issues book person book reserve issued issued return book operation models act person returning book adding book library operations models book added library putting book reserve operations models book put reserve book issued put reserve taking book reserve operation models book reserve claims assertions alloy issuing book returning results state book reserve issued claim true operation part write mathematical description operations claims explain answer part write speci cation ladybug part express design alloy part based experience part compare ladybug alloy question points data problem upward exposed analysis determines variables points reached nitions variable basic block nitions reach path nition nition killed setup data problem model checking problem steps outlined class setup model write ctl expression provide xpoint equations provide informal reasoning answer correct give formal proof question points note part form team person implementor tester implementor implement quick sort routine read quick sort algorithm favorite algorithms book description standard library function qsort tester write standard tests test basic functionality quick sort standard test cases write unit testing tester devise test cases meet statement decision coverage criteria notice deriving test cases meet statement decision coverage criteria construct program graph quick sort code comment results note turn code test cases program graph 
subject term intuitively additional meaning local validity specification certificate takes form interval cert valid time inclusive authorization certificates auth certs auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert subject term delegation bit turned subject receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert labeled rewrite rule pair component rewrite rule component authorization specification notational convenience write labeled rewrite rule treat certs labeled rewrite rules cert written labeled rewrite rule latticetop latticetop authorization specification authorization specifications latticetop latticetop latticetop write latticetop simply rewrite rule form implicit label latticetop auth cert written square squareif delegation bit turned written square squaresolid authorization labeled rewrite rules paper refer rewrite rules simply rules term appearing rule viewed string alphabet elements beginning uniformity refer strings form square squaresolid terms assume labeled rewrite rule corresponds authorization problems valid certificates validity specification certificate included rule issue intersection union authorization specifications discussed detail cert term case labeled rewrite rule applied term denoted yields term rule viewed function terms terms rewrites left prefix argument bob bob myfriends myfriends rules tprime addition assume prefix exists composition rule tprime rules friends bob myfriends bob tprime composition friends tprime myfriends rules called compatible composition defined authorization problem spki sdsi assume set certs principal access authorization specification authorization question granted access resource certificate chain sequence certificates certificate chain defines transformation label denoted label assume authorization specification unique principal viewed owner resource refers set certificates authorization specification principal algorithm finite set certificate chains prove principal allowed make access formally certificate-chain discovery attempts find finite set chm certificate chains chi square square squaresolid uniontextmi chi clarke presented algorithm certificate-chain discovery spki sdsi time complexity number keys sum lengths right-hand sides rules algorithm solved restricted version certificate-chain discovery general composition operator associative compatible compatible exist exist exists expressions equal defined omit parentheses assume associative solution consist single certificate chain instance certificate set dir read dir write suppose alice makes request dir set read write case chain authorizes alice read directory separate chain authorizes write prove read write privileges certificates removed certificate set prior running certificate-chain discovery algorithm clarke read negationslash set read write write negationslash set read write proof authorization alice request found schwoon presented algorithms full problem based solving reachability problems weighted pushdown systems formalization proof authorization consist set certificate chains paper wpds-based algorithm introduced weighted pushdown systems spki sdsi section show wpdss tool solving problems related certificate-chain discovery spki sdsi definitions largely correspondence spki sdsi pushdown systems presented finite set certificates keys identifiers set authorization specifications drawn latticetop intersection union auth specs discussed forms semiring domaint associate withc weighted pushdown systemwc wherepc square squaresolid keys ofc control locations identifiers form stack alphabet rule set defined set labeled rewrite rules derived auth certs shown section maps rule authorization specification usefulness correspondence stems simple observation configuration reach configuration kprime prime chain certificates kprime prime label certificate chain precisely solving gpp gps problem find set certificate chains prove principal kprime allowed access resource principal solution problem identifies set certificate chains union labels maximal respect semiring ordering subsetsqequal authorization problem set certs principal resource pds context access resource authorization specification iff statement true gpp problem square squaresolid holds square subsetsqequal equivalently gps problem square square squaresolid subsetsqequal distributed certificate-chain discovery algorithms gpr problems proposed work assumption pushdown rules certificates resp stored centrally site carries computation real-world setting certificates issued principals centralized storage site desirable propose versions algorithms solve problems distributed environment finite set certificates wpds section details section assume rules certificates distributed set servers function describes distribution principals sites assume certificate rule stored site responsible issuer subject remainder section distributed solutions distributed problem aforementioned assumptions principal resource principal client public keys set certificate chains access combined problem equivalent problems wpds setting gpp problem square squaresolid square compute backwards witness dag gps problem square square squaresolid compute forwards witness dags sections propose protocols communication client resource servers co-operate solve distributed access problem propose protocols based gpp formulation problem gps formulation protocols assume algorithms solving gpp gps distributed setting provided section relative merits protocols security privacy-related issues discussed section gps protocol distributed certificate-chain discovery distributed setting multiple access requests happen time unique request ids distinguish gps variant protocol consists phases initialization initialization consists steps client sends message resource requesting access message public key client resource responds sending unique request identifier reqid distinguish request requests progress client sends message site called client site denoted message key request reqid iii so-called client certificate request signed client client site checks contents signature client certificate match expectations check successful client site tells client certificate discovery begin client asks resource initiate search resource sends message site called resource site written public key request reqid request initiate certificate discovery search resource site initiates gps query singleton set square reqid distinguish query servers work multiple requests time query resolved servers details search algorithm section crucial points starts local gps computation notices post intersects site boundary certificate asked participate search site computation contact sites site constructs set cpost maintains information construct s-region required witness dags verification earlier communication client client site square squaresolid targets search client site finished search reached complete algorithm result reported resource verification phase direction flow information contrary search phase client site starts constructing sc-region witness dags sends sub-dag starting boundary nodes upstream neighboring sites neighboring sites information complete sub-dags send upstream full witness dags result reported resource communications phase accompanied client certificate mentioned earlier resource verifies result checks integrity dag signatures certificates dags client certificate matches reqid signature matches client depending outcome access allowed denied client verification complete dag place great workload resource alternative sending complete sub-dags sites report sum paths inside dags result resource consists certificates issued resource combined values paths reduces amount network traffic gpp protocol distributed certificate-chain discovery setting search started client site comparison section flow information sites reversed initialization client sends message resource requesting access resource generates reqid sends pair reqid resource site notify incoming search acknowledged receipt 
cient type matching somesh jha wisconsiny jens palsberg purdue universityz tian zhao purdue universityz september abstract palsberg zhao presented time algorithm matching recursive types paper present nlog algorithm problem algorithm works reducing type matching problem well-understood problem nding size-stable partition graph result improve systems polyspin mockingbird designed facilitate interoperability software components discuss applications algorithm java issues related subtyping recursive types discussed introduction interoperability fundamental problem software engineering interoperability issues arise contexts software reuse distributed programming legacy components integration software components developed erent organizations interoperability software components address fundamental problems matching bridging matching deals determining components compatible bridging component interface ned component matching common technique facilitating matching associate signatures components signatures keys retrieve relevant components existing library components nite types signatures rst proposed rittri zaremski wing similar approach retrieving components ml-like functional library emphasized exibility support user-de ned types bridging multi-lingual context bridge code gluing components written erent languages java developed corba polyspin mockingbird composing components implemented erent languages software components considered kinds objects provide palsberg supported nsf career award ccr ibm ycomputer sciences department wisconsin madison jha wisc zdept computer science purdue lafayette fpalsberg tzhaog purdue public interfaces clients invoke methods objects services provided objects corba corba approach utilizes separate nition language called idl objects language-independent interfaces ned idl interfaces translated language client translated interface enables clients call objects idl interfaces translated languages type system restrictive idl interfaces lack expressive power intuitively speaking type system idl intersection type system language supports restrictions corba-style approaches interoperability articulated polyspin mockingbird polyspin mockingbird approaches require common interface language idl approaches clients objects written type systems operation crosses language boundary supported bridge code automatically generated systems polyspin mockingbird support seamless interoperability programmer burdened writing interfaces language idl corba polyspin supports nite types mockingbird hand supports recursive types including records linked lists arrays type system mockingbird called mockingbird signature language mocksl problem deciding type equivalence mocksl remains open paper type system related mockingbird megaprogramming techniques suitable large software systems major goal software engineering term megaprogramming introduced darpa motivate goal roughly speaking megaprogramming megamodules provide higher level abstraction modules components megamodule encapsulate entire logistics ground transportation major city megaprogramming explained detail interoperability issues arise megaprograms constructed megamodules section framework presented paper address mismatch interfaces megamodules problem assume types signatures components type matching problem reduces problem determining types equivalent previous work type focuses non-recursive types paper equivalence recursive types equality subtyping recursive types studied amadio cardelli kozen palsberg schwartzbach brandt henglein jim palsberg papers concentrate case types considered equal nite unfoldings identical type equivalence decided time notion subtyping ned amadio cardelli decided time product-type constructor associative commutative recursive types considered equal nite unfoldings identical alternatively product type multiset associativity commutativity obtained free exibility advocated auerbach barton raghavachari palsberg zhao presented nition type equivalence supports idea presented time algorithm deciding notion type equivalence result present log time algorithm deciding type equivalence palsberg zhao algorithm works reducing type matching problem well-understood problem nding size-stable partition graph rest paper section recall notions terms term automata state nitions types type equivalence paper palsberg zhao section prove main result applications java implementation algorithm discussed section subtyping recursive types discussed section concluding remarks future directions section nitions section relevant nitions term automata representation types subsection nition type equivalence recursive types terms bisimualtion give subsection cient algorithm determining types equivalent section terms term automata give general nition possibly nite terms arbitrary nite ranked alphabet terms essentially labeled trees represent partial functions labeling strings natural numbers elements denote set elements arity denote set natural numbers denote set nite-length strings alphabet term partial function satisfying properties domain nonempty pre x-closed domain term partial function nonempty domain term called subterm position term regular nitely distinct subterms nite set regular term nite ranked alphabet nite representation terms special type automaton called term automaton term automaton tuple nite set states start state partial function called transition function total labeling function state nedg partial function extends naturally inductively-de ned partial function domain partial function nonempty pre x-closed condition existence i-successors nition term automata partial function term term automaton term represented term term representable intuitively determined starting start state scanning input transitions scan i-transition exist unde ned hand scans entire input ends state straightforward show term regular representable term regular nite set equations involving operator recursive types type equivalence type regular term ranked alphabet set base types binary arity type write type write type palsberg zhao presented equivalent nitions type equivalence work based idea bisimilarity relation types called bisimulation satis conditions exists bijection bisimulations closed union exists largest bisimulation bisimulation straightforward show equivalence relation types equivalent denoted cient algorithm type equivalence assume types represented term automata lemma proves exive bismulation initial states term automata related lemma essentially reduces problem nding exive bisimualtion nding size-stable coarsest partition theorem algorithm paige tarjan determine log time sum sizes term automata exists exive bisimulation section denote term automata alphabet assume denotes disjoint union functions bisimular exists relation called bisimulation exists bijection notice bisimulations closed union exists largest bisimulation straightforward show identity relation bisimulation exive bisimulation equivalence relation largest bisimulation equivalence relation lemma types represented term automata exive bisimulation proof suppose straightforward show bisimulation omit details conversely exive bisimulation straightforward prove bisimulation omit details bisimulation conclude partitioned graph -tuple set nodes edge relation partition partition set pairwise disjoint subsets union elements called blocks partitions nement block contained block partition set characterized equivalence relation block equivalence class set equivalence relation denote partition equivalence classes partition size-stable blocks set fyj repeatedly characterization size-stable partitions lemma equivalence relation size-stable exists bijection proof suppose size-stable block block block construct bijection bijections merged single bijection desired property conversely suppose exists bijection exists bijection element mapped element element image element conclude restricted bijection term automata partitioned graph ned ned ned graph node state transition transition mapped edges graph construction ensures node graph corresponds state labeled node distinct successors graph convenient establishing bijection successors nodes labeled equivalence relation creates distinction successors node corresponds state labeled ensuring convenient establishing bijection successors nodes labeled lemma exists exive bisimulation exists size-stable nement belong block proof exive 
bisimulation equivalence relation belong block show size-stable nement lemma cient show exists bijection cases suppose ned ned cases desired bijection trivially exists desired bijection finally ned ned bijection desired bijection constructed suppose desired bijection exists suppose desired bijection exists conversely size-stable nement belong block belong block notice exive show bisimulation suppose nement suppose nition size-stable lemma exists bijection bijection nition size-stable conclude suppose nition ned ned notice size-stable lemma exists bijection derive bijection nitions size-stable conclude size term automata sum number states transitions automata theorem types represented term automata size decide log time proof lemma exive bisimulation lemma exists exive bisimulation exists size-stable nement belong block paige tarjan give log algorithm coarsest size-stable nement size size universe algorithm rst constructs runs paige-tarjan algorithm coarsest size-stable nement nally checks belong block size size size total running time algorithm log logn applications implementation straightforward map java type type form considered paper collection method signatures mapped product type single method signature mapped function type case method argument list arguments mapped product type recursion direct indirect expressed operator section java interfaces illustration algorithm interface oat int interface oat oat figure interfaces interface oat oat interface int oat figure interfaces suppose sets java interfaces shown figures interface structurally equal matches interface notion equality interface names method names matter order methods interface order arguments method matter notice interface recursively ned method takes argument type returns oating point number names interfaces methods stand type structures type method expressed oat symbol stands function type constructor similarly type int capture structure conventional -notation recursive types oat int symbol type variable bound type symbol interface type product type symbol type constructor methods interface unordered write structure int oat oat oat structures interfaces oat oat int oat trees types shown figures interface types equivalent exists one-to-one mapping bijection methods methods pair methods bijection relation type types methods equal types arguments return types equal equality interface types determined orderings methods interface comparing types form nite float int float float figure trees interfaces float float int float figure trees interfaces automata case orderings number methods large methods arguments approach time consuming number orderings grows exponentially illustrate algorithm determines equivalence types details algorithm found types ned earlier set types interfaces int oatg int oatg figure shows steps algorithm blocks rst row based labels states labeled block step block methods split based type result method methods return oat block step row block split nal partition block split shown fourth row float int float int float intm int floatn figure blocks types algorithm tuned speci user account simply modifying nition equivalence relation suppose user cares order arguments method means components product type models argument list allowed shu type matching prevent shu ing employing technique current nition function types idea insist component types matched component index tunability algorithm involves modi ers java suppose programmer developing product multi-threaded case programmer match synchronized methods synchronized methods handled easily framework changing method types matched synchronized hand user working single-threaded product keyword synchronized observation applies modi ers static implementation implemented algorithm java current version based code written wanjun wang implementation documentation freely http purdue homes tzhao matching matching htm current version graphical user interface users input type nitions written restrictions type isomorphism suppose java interfaces interface oat int int interface oat oat interface oat oat interface int oat int implementation illustrated figure read parse input transform type nitions partitions numbers type nition dummy type assigned unique number partitions ned paige-tarjan algorithm size-stable ned paper finally read results nal partitions types isomorphic numbers assigned partition implementation give output -input -restrictions transform type sets partitions paige-tarjan algorithm partitions parsers forgraphical interface -input window -restriction window -output window -focus window figure schematic diagram implementation figure screen shot types interfaces isomorphic method types match suppose additional information method types method isomorphic types restrict type matching adding restrictions window user interface matching result illustrated screen shot gure note focus matching interface types focus windows gure matched methods matched interface real boolean boolean figure interface interface int boolean figure interface subtyping recursive types section discuss subtyping formalize simulation relation discuss reasons algorithm section applicable subtyping recursive types assume object implements interface shown figure user interface form shown figure interfaces mapped recursive types real boolean boolean int boolean assuming int subtype real coerce integers reals subtype user interface points notice context subtyping kinds products models collection methods models sequence parameters user speci type method subtyping algorithm method parameters method modeled products types product type constructors type systems subtyping rule types products erent stated type regular term ranked alphabet roughly speaking model collection parameters methods assume subtyping relation base types subtype write relation called simulation types satis conditions fqn exists bijection suppose exists assume case exists one-to-one function notice rule ignoring components case bisimulations simulations closed union exists largest simulation denoted denote term automata assume denotes disjoint union functions simulates denoted exists relation called simulation relation fqn exists bijection suppose exists assume case exists one-to-one function notice simulations closed union exists largest simulation proof lemma similar proof lemma omitted lemma assume types represented term automata exists simulation largest simulation term automata greatest x-point sim predicate sim conjunction conditions nition simulation relation automata size term automata bound size number iterations computing greatest x-point bounded general relation matter simulation relation symmetric hand bisimulation relation equivalence relation represented partition set words partitions give representation equivalence relation linear sum sizes set states paige-tarjan algorithm partition representation equivalence relation symmetric equivalence relation represented partition crucial reason previous algorithm subtyping conclusion paper addressed problem matching recursive types present algorithm log time complexity determines types equivalent knowledge cient algorithm problem results applicable problem matching signatures software components core algorithm required systems polyspin mockingbird applications java discussed issues related subtyping recursive types addressed directions future work applications type matching algorithm explore information generated algorithm ciently generating bridge-code components investigate cient algorithms subtyping recursive types roberto amadio luca cardelli subtyping recursive types acm transactions programming languages systems proceedings popl joshua auerbach charles barton mukund raghavachari type isomorphisms recursive types research report ibm research division watson research center yorktown 
heights august joshua auerbach mark chu-carroll mockingbird system compiler-based approach maximally interoperable distributed programming research report ibm research division watson research center yorktown heights february daniel barrett alan kaplan jack wileden automated support seamless interoperability polylingual software systems acm sigsoft fourth symposium foundations software engineering san francisco california october boehm scherlis megaprogramming proceedings darpa software technology conference april meridien corporation arlington michael brandt fritz henglein coinductive axiomatization recursive type equality subtyping proceedings tlca international conference typed lambda calculus applications kim bruce roberto cosmo giuseppe longo provable isomorphisms types mathematical structures computer science roberto cosmo isomorphisms types -calculus information retrieval language design birkh auser trevor jim jens palsberg type inference systems recursive types subtyping manuscript dexter kozen jens palsberg michael schwartzbach cient recursive subtyping mathematical structures computer science preliminary version proceedings popl twentieth annual sigplan sigact symposium principles programming languages pages charleston south carolina january paliath narendran frank pfenning richard statman uni cation problem cartesian closed categories proceedings eighth annual ieee symposium logic computer science pages ieee computer society press omg common object request broker architecture speci cation technical report object management group version robert paige robert tarjan partition nement algorithms siam journal computing december jens palsberg tian zhao cient exible matching recursive types information computation preliminary version proceedings lics fifteenth annual ieee symposium logic computer science pages santa barbara california june mikael rittri retrieving library identi ers equational matching types stickel editor proceedings international conference automated deduction volume lnai pages kaiserslautern frg july springer verlag mikael rittri types search keys function libraries journal functional programming mikael rittri retrieving library functions unifying types modulo linear isomorphism rairo theoretical informatics applications sergei soloviev category nite sets cartesian closed categories journal soviet mathematics wiederhold wegner ceri megaprogramming paradigm component-based programming communications acm november zaremski wing signature matching tool software libraries acm transactions software engineering methodology april zaremski wing speci cation matching software components proceedings acm sigsoft symposium foundation software engineering pages 
message resource sends reqid client client contacts client site asks initiate gpp computation request sends reqid client certificate section client site checks correctness client certificate correct begins search search search stage analogous gps protocol started client site set squaresolid square site involved search pre intersects communications sites tagged reqid client certificate verification end search resource site search reqid target square determine reachable generate complete witness dag request sites downstream regions witness dag pass complete dag client certificate resource verify successful grant access client alternative solution report resource certificates issued resource combined values paths case communication sites rules shown square arrowhookleft kuw facultysquaresolid kuw faculty arrowhookleft kls faculty kls faculty arrowhookleft kcs faculty kls faculty arrowhookleft kbio faculty kcs faculty arrowhookleft kbob latticetop assume sites bio sitemap kuw equal kls equal kbio equal bio kcs kbob equal case section suppose bob site access resource site site starts search kbob square kbob squaresolid discovers pre intersects site involved notices site part search automata computed shown figure notice site bio involved end computation site sees square accepted automaton auw weight result reported resource kuw kbob faculty kcs faculty kls faculty fig pre automata square computed sites weights transitions shown parentheses discussion discuss privacy security-related topics compare protocols discuss improvements privacy search parties involved learn resource client client asked access resource resource site request made resource client site client made request sites request made surmise nature request judging identifiers transitions direction query direction confirmation observe communication neighbor sites privacy access request ensured search witness dag constructed construction phase sites learn identity client avoided alternative method values paths dag transmitted sites alternative solution prevents unnecessary spread certificates sites sensitive information security attacks spoofing eavesdropping assume parties involved search communicate securely identification spoofing place trusting sites main part computation carried sites protocols potentially susceptible malicious behavior sites malicious site invent ignore certificates ignoring certificates detriment users site responsible concern inventing certificates problem verification stage constructs full witness dag case certificates signed issuers supplied alternative solution values reported problematic essence reporting paths sub-dag rooted node amounts issuing confirmation principal certificate chain client alternative solution requires trust site certificates truthfully note boundary certificates subjects direct control respective site operator problem client certificate resource verify reported result valid client initiated request verification stage constructs full witness dags straightforward maximal nodes dags refer client alternative solution verification client certificate serves purpose provided resource client site verify correctness comparison protocols gpp-based protocol search starts client site gps-based protocol starts resource site site responsible popular resource gps-based protocol put workload denial-of-service attacks conceivable malicious client large number gps computations identities doomed fail gpp-based protocol happen workload fall client site assumed relationship client site client company isp social safeguard denial-ofservice attacks construction complete witness dags omitted gpp-based solution require separate verification stage reasons gpp-based solution advantages gps-based solution carry precise investigation issue improvements caching results notice methods describe carried time client access resource contact client resource outcome successful resource remember grant access full search time caching sites site client site resource site request result local search independent request identifier sites cache recent results reuse identical request modulo reqid guided search protocols sets pre post intersect domains sites request involve sites relevant search increases length computation amount network traffic protocol improved limiting scope search client idea allowed access resource possibility client client site suggest set sites suitable certificates termination distributed gpp gps computation standard terminationdetection algorithm applied determine search terminated entails additional time communication overhead search terminated relevant certificate chains found client site gps case resource site gpp case discovered paths tentative larger respect ordering goal search establish larger threshold information terminate search early computation limited timeout implementation implemented prototype distributed algorithm figure shows site organized spki sdsi site consists spki sdsi server wpds server spki sdsi server deals spki sdsi certificates interface clients perform requests authorization wpds server implements distributed certificate-chain discovery algorithm solving reachability problems weighted pushdown systems wpds clients interact directly wpds servers typical authorization-request scenario client initiates request contacting spki sdsi server spki sdsi server parses request sends wpds server site point wpds server starts distributed process contacts wpds servers proof authorization found verified client granted access resource request denied examples illustrate system works examples graph illustrate configuration sites graph shaded nodes represents distinct sites distributed spki sdsi system labels fig architecture diagram inside site represent cross-boundary spki sdsi certificates nodes symbol denote resource spki sdsi auth certs issued dashed lines denote certificate chain discovered algorithms bob requests access resource case case demonstrates basic idea distributed certificatechain discovery assume hierarchical structure shown figure site represents level site denotes top level wisconsin denotes colleges college letters sciences bio represent departments sites linked spki sdsi certificate refers sites instance site issued certificates respect site auth cert square kuw faculty squaresolid grants access kuw faculty cert kuw faculty kls faculty states kls faculty kuw faculty assume bob requests access service located process starts continues hierarchy reaches bob granted access rights note individual site sufficient knowledge decide authorization request certificates path show bob required permissions case case demonstrates basic idea distributed certificate-chain discovery case illustrates situation certificates multiple paths combined obtain required authorization specifications access permission instance continuing case add joint department bcs formed bio departments structure shown figure issues authorization certificates distinct authorization specifications bio suppose bob bcs access request granted paths separately wpds approach solves issue combining authorizations paths bcs grant authorization bob case case shown figure builds top demonstrates complex environment case constructed purposes demonstrate scalability wpds algorithm study performance respect certificate-chain length measure computation time length chains section performance analysis section report performance implementation examples discussed response time perspective clients performance metrics resources perform real-world test tests conducted simulated environment site runs separate machine local area network timing results reflect network latency real distributed environment test machines mhz pentium iii processors ram running tao linux version experiment configurations base simple complex comparison purposes collected performance data running certificate-chain discovery centralized mode certificates stored single site complex configuration base configuration base bare minimum number certificates required tests shown figures number certificates 
relational modeling somesh jha computer science department wisconsin madison introduction model checking verifying concurrency aspects system distributed system admits deadlock model checking expressing invariants data structures list sorted talking data structures relational calculus suitable formalism discuss language called nitpick based relational calculus ladybug tool checks specifications written nitpick operators semantics types relational calculus language types signify domain kind people type denotes set people type domain overloading type denote domain people denotes set people clear context talking types domain basic types entities relational language scalars type simply takes domain type sets types values power set domain relation talk relationships types relation type type type function type type written function special case relation relation type function iff element element related running explain operations nitpick basic types people males females set natural numbers notice relationships hold domains types male person males subset people males people notice talking domain types types relations shown figure frequently type father people males mother people females wife males females husband females males age people brother people males sister people females friend people people figure primitive relations functions depict relation type drawing columns left column corresponds column corresponds edge element represents relation figure shows fragment relation brother edge relation p-related bob snake trent hugh alice wilma marvin figure sample relation note describe operators relational calculus symbol ladybug tool provided set operators relation operators type relation type operators apply sets union ladybug elements -related iff p-related q-related define relation parent parent father mother recall type father people males type mother people females order perform union relations interpreted type people people fortunately function relation males people females people intersection ladybug elements -related iff p-related q-related define relation friendlybrother friendlybrother brother friend difference elements -related iff p-related q-related define relation unfriendlybrother unfriendlybrother brother nfriends subset ladybug notice logical formula evaluates true false formula states elements type p-related q-related logical-formula friendlybrother brother proper subset ladubug logical formula states p-related q-related exists elements q-related p-related exists brother unfriendly siblings friendlybrother brother exclusive set operators scalar set ladybug formula true set scalar set ladybug formula true set relational operators universal relation ladybug cartesian product tuples identity relation ladybug identity relation relates elements domain domp ladybug dom faj set people parents denoted not-orphans equation not-orphans dom parent range range ladybug ran fbj parents set people parents parents set parents range parent domain restriction ladybug set pja domain restricted set item range restriction ladybug set pjb range restricted set denote set numbers equation young dom age based set young derived sets youngwives dom young husband younghusbands range young husband negative domain restriction ladybug set force domain set equation oldwives dom young husband negative range restriction ladybug set pjb force range set set people age equation dom age relational override ladybug dom relational override works domain related elements q-related elements domain related elements p-related succinctly speaking composition ladybug equation dom wife husband marriedmales transpose ladybug tilde character husband wife transitive closure ladybug relation composed times friendoffriend friend reflexive transitive closure ladybug friend friendoffriend friend application single father bob father bob image set range father fbob aliceg fathers bob alice functional domain fdom ladybug fdom fajjp find elements domain related element siblings brother sister singlesibling fdom siblings function predicate fun ladybug fun predicate fun returns true iff relation function element p-related element injection predicate inj predicate true iff transpose function surjection predicate sur range element exists element p-related totality predicate tot domp predicate true iff element element p-related singleton predicate set jsj predicate true iff set element nitpick ladybug ladybug-an improved version nitpick written java ladybug developed craig damon describe small suppose types phones numbers imagine relation called phones numbers function net numbers phones called number called net number relation connection type phones numbers semantics connection called relationship connections called net suppose call number connection made called operation join written range called called called called relation called state assuming net constant function net connection state equation connection called net make calling transpose relation connection function receive call properties listed invb dom connection range connection invc fun connection make invariants true join operation true operation written join invb invb join invc invc exercise expressioninvb short hand expression toinvbwhere connection connection expand expression invb terms called net definition join ladybug ladybug num switch called num denoting entity state prime pretty common formal methods const net num conns conns called net join num switch ran called called called invb switch dom conns ran conns invc switch fun conns invb preserved num join invb invb invc preserved num join invc invc note claims invb invc true ladybug produces counter-example log file produced ladybug shown ladybug beta release copyright loaded phone-modified select claim schema choose check menu double click claim schema completed translation invb preserved required starting found counterexample claim invb preserved called num called num conns conns num net numph found counterexamples checked cases values covered total assignment space required starting completed translation invc preserved required starting found counterexample claim invc preserved called num called num conns conns num net numph found counterexamples checked cases values covered total assignment space required starting exercise explain counter-examples produced ladybug fix specification explain fix properties section discusses properties relational operators properties writing simplifying specifications reflexive relation called reflexive element element related transitive relation called transitive implies symmetric relation called symmetric implies exercise prove properties relational operators associativity monotonicity distributive commutativity transpose closure describe small ladybug illustrates features idiosyncratic modeling language ladybug types relations basic types date basic function book date derived set set satisfies equation dom book writing state variables specifications explicitly cumbersome ladybug macro feature called schemas bundle declarations assertions place schemas referred schemas assertions recursion allowed ladybug fragment types relation defined date book book date set dom book notice book schema defines book relationship book interpret types entities relations functions sets relationships entities corresponds entity-relationship diagram shown figure diagrams depicting basic types relationships names date book dom book figure entity relationship diagram operations insert operation takes date inserts book operation defined mathematically insert date book book schema ladybug insert date book book book notice 
schema insert includes schema book defined supposebookalready pair perform operation insert operation valid delete operation delete set names birthday book operation define delete set book book schema operation ladybug delete set book book book deleteimplicit expressing delete operation deleteimplicit set book book book ladybug schema operation deleteimplicit set book book book book notice ladybug implicit conjunction assertions find find operation finds birthday person find date book book fng schema ladybug find date const book book book notice statement const book means entities inside schema book held constant operation find claims delete undoes insert claim asserts insert operation delete operation results state started deleteundoesinsert date book insert delete book book notice claim indication ladybug deleteundoesinsert claim deleteimplicit implies delete stronger thandeleteor post-condition deleteimplicit stronger delete set book deleteimplicit delete inserting makes assertion states insert operation makes inserting insertmakesknown date book insert inserting means find claim states inserting birthday book means find insertworks date book insert find counter state book perform operation insert case book state performing delete results book book equal book ladybug beta release copyright loaded birthday-book select claim schema choose check menu double click claim schema completed translation deleteundoesinsert required starting found counterexample claim deleteundoesinsert book namedate book namedate date set set found counterexamples checked cases values covered total assignment space required starting entire program entire program shown version spivey birthday book date book book date set dom book insert date book book book delete set book book book deleteimplicit set book book book book find date const book book book deleteundoesinsert date book insert delete book book set book deleteimplicit delete insertmakesknown date book insert insertworks date book insert find 
ranges certs tests results configuration baseline test cases simple configuration real-world scenario site certificates simple configuration adds certificates base configuration site added number additional certificates students staff kuw student kls student kcs faculty kprofa complex configuration measure system scales tested case certificates table shows performance results configurations expect certificates system longer takes perform certificate-chain discovery time takes perform certificate-chain discovery increases lower rate compared increase number certificates data shows insignificant base configuration simple configuration shows small increase average simple complex figure illustrates data case addition table shows performance difference running certificate-chain discovery distributed centralized mode significant instance case distributed certificate-chain discovery ten times long centralized version distributed certificate-chain discovery significant percentage time spent network-related operations sending receiving messages expect reduce network overhead optimizations reduce number messages exchanged certificate-chain discovery bundling messages totwo cases tested showed similar results omitted square faculty squaresolid kuw faculty kls facultyd kls faculty kcs faculty faculty kbio faculty kcs faculty kbob bio fig case grants read permission directory faculty tag dir read bob requests read access directory kuw faculty kls faculty square faculty squaresolid square bio faculty squaresolid kcs faculty kbcs faculty bio kbio faculty kbcs facultyd kbio faculty kalice bcs kbcs faculty kbob fig case authorization multiple paths grants read privilege directory faculty tag dir read write privilege bio faculty tag dir write bob requests read write directory nsf square knsf programs squaresolid knsf kedu square knsf gov programs squaresolid knsf gov kgov kedu programs kmanagera programs kedu schools faculty kedu schools kwisc schools gov kgov programs kgov schools faculty kgov schools kwisc schoolsd kgov programs kmanagerb wisc kwisc schools kuwd kuw faculty kchancellor kuw faculty kls faculty kls faculty kcs faculty kls faculty kbio faculty kcs faculty kbob bio fig case authorizes nsf programs apply funda tag funda apply nsf gov programs apply fundb tag fundb apply bob attempts apply funda gether sending bundle packet part planned future work table performance results time distributed centralized client request base simple complex complex case figure bob dir read case figure bob dir read bob dir write bob dir read write alice dir write case figure managera funda apply managerb fundb apply chancellor funda apply bob funda apply bob fundb apply performance data case illustrates area future work reducing response time long certificate chains define length certificate chain number distinct sites request site resource site manager chain length site hop resource site nsf illustrated ascending line top figure length certificate chain great impact performance longer chain longer takes service request comparison purposes flat line shows response time centralized certificates location time reflects cost running gps algorithm site network overhead investigating techniques improve average performance long certificate chains instance section discussed possibility caching reduce discovery time abadi sdsi linked local spaces journal computer security appel felten proof-carrying authentication conf comp commun sec nov bauer garriss reiter distributed proving access-control systems proceedings ieee symposium security privacy pages blaze feigenbaum ioannidis keromytis role trust management distributed systems security vitek jensen editors secure response time certificates manager funda apply manager fundb apply changellor funda apply alice funda apply alice fundb apply fig response time certificates case response time chain length manager funda apply manager fundb apply changellor funda apply alice funda apply alice fundb apply distributed centralized fig response time chain length case complex configuration internet programming security issues mobile distributed objects pages lncs blaze feigenbaum ioannidis keromytis keynote trustmanagement system version rfc sept bouajjani esparza maler reachability analysis pushdown automata application model-checking proceedings concur volume lecture notes computer science pages springer bouajjani esparza touili generic approach static analysis concurrent programs procedures proceedings popl clarke elien ellison fredette morcos rivest certficate chain discovery spki sdsi journal computer security ellison frantz lampson rivest thomas onen rfc spki certificate theory internet society september esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems emerson sistla editors proceedings cav volume lecture notes computer science pages springer july finkel willems andp wolper pushdown systems elec notes theor comp sci halpern van der meyden logical reconstruction spki proceedings ieee computer security foundations workshop pages ieee computer society press howell kotz formal semantics spki technical report department computer science dartmouth college hanover mar jha reps analysis spki sdsi certificates model checking proceedings ieee computer security foundations workshop csfw pages ieee computer society june jha reps model checking spki sdsi journal computer security jim trust management system certified evaluation proceedings ieee symposium security privacy page ieee computer society jim suciu dynamically distributed query evaluation pods proceedings twentieth acm sigmod-sigact-sigart symposium principles database systems pages acm press lampson abadi burrows wobber authentication distributed systems theory practice acm transactions computer systems november mitchell understanding spki sdsi first-order logic proceedings ieee computer security foundations workshop csfw ieee computer society winsborough mitchell distributed credential chain discovery trust management journal computer security february pfenning sch urmann system description twelf meta-logical framework deductive systems ganzinger editor int conf auto deduc pages springer-verlag lnai july reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis proceedings internation static analysis symposium sas san diego june reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis science computer programming october schwoon jha reps stubblebine generalized authorization problems proceedings ieee computer security foundations workshop csfw pages ieee computer society june weeks understanding trust management systems proceedings ieee symposium research security privacy research security privacy oakland ieee computer society technical committee security privacy ieee computer society press 
analysis spki sdsi certificates model checking jha reps computer sciences department wisconsin dayton street madison e-mail fjha repsg wisc abstract spki sdsi framework expressing naming authorization issues arise distributed-computing environment paper establish connection spki sdsi formalism pushdown systems pdss show spki sdsi-to-pds connection framework formalizing variety certificate-analysis problems connection computational significance analysis problems solved efficiently time polynomial size certificate set existing algorithms model checking pushdown systems keywords spki sdsi model checking pushdown system naming authorization certificate-chain discovery certificate-set analysis introduction systems shared resources access-control mechanisms protection fundamental problems access control authorization enforcement authorization addresses problem request specific principal allowed enforcement addresses problem enforcing authorization execution centralized system authorization based closed-world assumption parties trusted distributed system work supported part national science foundation grant ccrby office naval research contracts alexander von humboldt foundation government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government closed-world assumption valid trust management systems solve authorization problem distributed systems defining formal language expressing authorization access-control policies rely algorithm determine specific request allowable survey trust management systems formal framework understanding presented prominent trust management systems keynote spki sdsi spki sdsi framework expressing naming authorization issues kind arise distributedcomputing environment spki sdsi certificates define names issuer local space spki sdsi authorization certificates grant authorizations delegate ability grant authorizations clarke considered problem discovering certificate chain authorization respect set spki sdsi certificates certificate chain proof client public key keys authorized access resource directly transitively name-definition authorizationdelegation steps paper studies problem certificate analysis context spki sdsi establish connection spki sdsi formalism pushdown systems pdss work stems simple observation set spki sdsi authorization certificates defines pds significance connection contributions made paper summarized spki sdsi-to-pds connection framework formalizing variety certificate-set analysis problems certificate-set analysis problem model checking pushdown systems analysis flavors model checking henceforth otherproblems stated precisely standard formalisms posing model-checking queries problems include authorization problem addressed clarke authorized access resource principal authorized access questions interested respect certificate set authorized access resource necessarily principal authorized access authorized access resource names necessarily principals authorized access shared access resources principals access shared access principals resources accessed compromisation assessment resources principal gained access solely due presence maliciously accidentally issued certificate set compromisation assessment principals gained access resource solely due presence maliciously accidentally issued certificate set expiration vulnerability resources principal prevented accessing certificate set expires expiration vulnerability principals excluded accessing resource certificate set expires universally guarded access case authorizations issued resource involve certificate signed principal universally guarded access case authorizations grant principal access resource involve certificate signed wise noted term model checking refers model checking pushdown systems background problem section general infinite set shown answer form finite-state automaton accepts names authorized access analysis problems listed solved efficiently time polynomial size certificate set existing model-checking algorithms pdss case certificate-chain discovery show operation subroutine algorithms model checking pdss algorithm problem special-purpose algorithm certificate-chain discovery developed clarke worst-case asymptotic running time algorithm clarke improved handling tabulated data lead asymptotic improvement family examples clarke illustrate worst-case upper bound tight constant factor family examples algorithm exhibit worst-case behavior section addition annotating data-structures labels lattice enables answer additional questions section specific authorization expire section show algorithm adapted answer authorization questions distributed manner distributed algorithm framework provided clarke remainder paper organized section introduction spki sdsi describes algorithm certificate-chain discovery section appendix provide background model checking pushdown systems section discusses applications formal machinery certificate-set analysis problems section discusses related work appendix details certificate-chain reconstruction appendix presents definitions pertaining lattices section paper structured self-contained deals problem domains kinds arrows denote relationships kinds objects summarized table readers familiar skip sections minor notational differences papers footnotes background spki sdsi spki sdsi principals represented public keys principal individual process host active entity spki sdsi make distinction principal public key principal public key denotes set public keys specific keys denoted data-structure issues rek spki sdsi cert spki sdsi auth cert delegation bit spki sdsi auth cert delegation bit transition rule pds immediate-successor relation pds transitive closure immediate-successor relation pds reflexive transitive closure immediate-successor relation pds reachability relation states configuration automaton relation configuration automaton table kinds arrows paper lated representation keys found identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys locals names extended names local form identifier bob local local names important spki sdsi create decentralized space set local names denoted local space local names form denoted extended form sequence identifiers length greater faculty extended set extended names denote set extended names beginning key set names space key set terms certificates spki sdsi types certificates certs type certificate called certs definitions local names authorizations authorization certs auth certs short certificates cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification information validity certificate validity specification takes form interval cert valid time inclusive validity specification form on-line check performed complete explanation validity specifications context authorization problem generally ignore validity specification assume working exclusively valid certificates extensions handle types validity specifications discussed section authorization certificates auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert issuer granting specific authorization subject term delegation bit turned key receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert treat certs rewrite rules cert written auth cert written delegation bit turned written faculty faculty bob bob alice alice figure complete set certs pair auth cert refers resource primarily interested questions resources questions individually generally write auth cert general resources denoted authorization section describe authorization illustrative purposes paper traditional discretionary access control protected resource access-control list acl describing principals permissions access resource auth cert viewed acl entry keys principals represented subject permission access resource instance suppose alice login host resource initially monitor denies access reports acl entry written auth cert alice faculty set certs shown figure alice prove authorized access name-reduction closure describe algorithm 
reader referred additional details define concept closure set certificates term appearing rules viewed string alphabet elements beginning uniformity refer strings form terms assume rewrite rule cert term case rewrite rule applied term denoted yields term rule viewed function terms terms bob bob myfriends myfriends term rule called compatible form give set certificates term define set compatible define composition rewrite rules rules assume prefix exists composition rules rule rules friends bob myfriends bob composition previous rules rule friends myfriends rules called compatible composition defined set certificates closure denoted smallest set certificates includes closed composition general infinite computed directly set certificates closure set set certificatesc defined words set keys obtained rewrite rules set certs applications granted authorization key indirectly granted authorization instance authorization section shown faculty alice authorized login host closure set certs infinite concept name-reduction closure introduced rule application write composition write finally faculty faculty faculty figure additional rules added namereduction closure reducing cert form reduction composition compatible rules reducing cert name-reduction closure set certificates defined smallest set certificates closed reduction set certs equality proved words safe inspect name-reduction closure order find set keys correspond return authorization describe four-step procedure determining principal authorized access resource set certificates remove useless certificates auth certificates removed set auth certs authorization tag refer resource removed reduction compute name-reduction closure set name-reduction closure set shown figure yields additional certs shown figure depth-first search remove rules form rules remain step remove rules form construct graph vertex key edge rule form edges fourth perform depthfirst search determine path path alice key alice granted permission login host reconstruct certificate chain information previous steps create certificate chain proves principal authorized access desired resource certificate chain proves alice authorized login host certificate-chain reconstruction requires additional information stored algorithm perform name-reduction closure smallest size certificate chain exponential number certs desirable report certificate chains factored form chapter discuss time space complexity namereduction closure set certificates number keys occurring typical certificate form reduction obtain rule form reductions obtain rules form kiai reductions obtain rule form possibilities keys nkm possibilities rules generated jcj sum lengths right-hand sides rules occur maximum number rules produced nkjcj rule compatible reducing certs rule result work time complexity name-reduction closure kjcj number nodes edges graph constructed depth-first-search step bounded time complexity depthfirst search authorization procedure time complexity name-reduction closure step dominates running time procedure number rules produced bounded nkjcj space complexity procedure nkjcj term appears depth-first search data structures representing certs discussed detail elien thesis background model checking pushdown systems section background model checking pushdown systems pdss material paper largely based paper esparza detailed treatment model checking pdss including computational complexity problems found pushdown system triple finite set control locations finite stack alphabet finite set transition rules write pushdown systems similar pushdown automata unlike pushdown automata input alphabet pdss viewed language recognizers mechanisms possibly infinite-state transition systems configuration pair control location represents stack contents set configurations denoted surface configuration pair configuration predecessor wvi wvi successor denoted wvi reflexive transitive closure reachability relation transitive closure immediate-successor relation denoted run sequence configurations predecessor set configurations set predecessors denoted pre reflexive transitive closure pre denoted pre pre set successors post set configurations defined similarly reflexive transitive closure post denoted post understood write pre pre post post computing pre assume pushdown system regular set configurations ofp represented finite-state automaton called configuration automaton ofp input alphabet isp stack alphabet symbol denotes reflexive transitive closure predecessor relation predecessor relation reflexive transitive closure figure automaton accepts fhp formally configuration automaton automaton finite set states set locations subset set transitions set initial states set final states configuration automaton reachability relation denoted defined smallest relation satisfying henceforth refer configuration automaton simply automaton automaton accepts recognizes configuration set configurations recognized automaton denoted conf pds consists transition rules automaton shown figure recognizes set configurations fhp assume regular set configurations accepted automaton shown set configurations pre regular automaton recognizing pre constructed adding transitions saturation rule add transitions automaton added current automaton add transition ppp ppp ppp ppp pppq figure automaton accepts pre fhp fhp theorem pds configuration automaton exists automatonapre recognizes pre conf apre constructed time nqn space jqj sum lengths right-hand sides transition rules length right-hand side transition rule maxf jwjg pds recall automaton figure recognizes set configurations fhp automaton recognizes pre shown figure transition rule self-loop added transition rule fact holds transition added transition rule fact holds transition added automaton shown figure accepts set configurations fhp fhp computing post pds regular set configurations represented automaton assume transition rulehp satisfies jwj assumption involves loss generality pds satisfy constraint converted suppose general pds transition rule add control locations replace original rule transition rules hpi hpi hpk assume regular set configurations automaton construct automaton apost accepts post automaton apost obtained phases phase transition rule form add state transition phase saturation phase phase transitions added automaton rules added symbol denotes relation rules adding transitions current automaton add transition ifhp current automaton add transition current automaton add transition theorem pushdown system configuration automaton exists automaton apost recognizing post conf apost constructed time space jpj jqj note complexities mentioned theorems refer improved versions algorithms presented pds transition rules figure automaton accepts fhp figure automaton accepts post fhp automaton shown figure accepts set configurations fhp automaton post shown figure states labeled correspond transition rules label automaton shown figure accepts set configurations fhp model checking linear-time logics finite set atomic propositions ltl formula atomic propositions reader consult chapter syntax semantics ltl pds labeling function associates set atomic propositions surface configurationhp extension set atomic propositions hold configuration interested model-checking problem configuration ltl formula determine satisfies summary ltl model-checking procedure found appendix spki sdsi pdss section explores connection spki sdsi pdss demonstrates authorization problem variety certificate-set analysis problems viewed model-checking problems pdss assume set certs set keys identifiers resources denoted construct pds set locations key resource represents control location stack alphabet stack alphabet set identifiers filled unfilled squares encode delegation bits set transition rules rule iff certs correspond transition rules assume set certs term term corresponds configuration ami pds lemma establishes correspondence closure set certs reachability relation pds lemma assume 
set certs pds term terms words equality post set certificates suppose interested determining principal authorized access resource options solve authorization problem pre post proof authorization run pds starts configurationhr ends configurations set fhkp hkp terms pre post condition formalized pre fhkp hkp post fhr fhkp hkp algorithms based conditions referred apre apost spki sdsi algorithm section referred aspki sdsi based lemma theorem easy prove theorem principal granted authorization access resource algorithm aspki sdsi iff algorithm apre grants authorization access principal granted authorization access resource algorithm aspki sdsi iff algorithm apost grants authorization access algorithm apre works construct pds set certs set configurations fhkp hkp construct automaton fsg fsg conf algorithm section create automaton pre grant authorization iffhr iis accepted automaton pre complexity algorithm apre analyzed case single resource number states automaton one-to-one correspondence transition rules certs set equal jcj number transitions automaton invoking theorem obtain time space complexity apre kjcj nkjcj notice asymptotic complexity clarke obtain algorithm aspki sdsi section set configurations shown figure pds case control locations stack alphabet sets frh kag fuw faculty bob alice hrh faculty uwi csi facultyi bobi bobi hkb hkb alice alicei hka figure set transition rules transition rules shown figure interested authorization alice key set configurations fhka hka configuration automaton accepts defined fsg fsg automaton constructed pre shown figure note configuration hrh accepted automaton principal alice authorized login host describe detail algorithm apost construction post suppose interested determining principal authorized access resource set certificates algorithm solving authorization problem construct pds set certs set configurations fhr construct automaton fsg fsg conf computing post transform pds transition rules satisfy jwj add state transition rule form add transition automaton finally complete construction automaton post repeatedly applying saturation rule grant authorization iff hkp hkp accepted automaton post analyze complexity algorithm case single resource number states automaton theorem obtain time space complexity apost jcj ppp ppp ppp ppp ppppq faculty alicebob figure automaton accepts set configurations pre fhka hka set certs shown figure pds set certs explicitly constructed recall post algorithm assumes transition rule satisfies jwj rule satisfy constraint hrh faculty transform pds adding locations adding rules iii deleting rule hrh faculty facultyi facultyi csi csi original transition rules pds stack symbols right-hand side hkb alice configuration automaton accepts set fhrh defined fsg fsg phase construction section automaton components fsg set shown figure automaton constructed post shown figure note configuration hka accepted automaton principal alice authorized login host certificate-chain reconstruction threshold subjects describe augment automaton constructed algorithm apre extra information purpose certificate-chain reconstruction apost augmented similarly faculty alice figure set transitions automaton pre created adding transitions saturation rule transitions added current automaton add transition transition automaton associate set identifiers transition rules initially set empty transitions automaton intuitively set represents transition rules caused transition added transition rule fact holds automaton transition added automaton identifier transition rule added set identifiers transition completion pre construction certificate chain reconstructed starting identifier transition tracing back tracing-back procedure conceptually simple details provided appendix threshold subjects handled framework introducing extra keys section certificate-set analysis problems section discusses applications model checking specific certificate-set analysis problems sso faculty faculty bob alice figure automaton accepts set configurations post show model checking furnishes algorithms analysis problems listed introduction term model checking problem checking pds satisfies ltl formula problem answering simple forward backward reachability queries stated terms set-former expressions basic automaton-building operations pre post set certs set configurations write pre pre similarly post written post authorized access resource principal authorized access pre fhk alternatively fhk post fhr authorized access resource authorized access pre alternatively post fhr authorized access resource names authorized access post fhr shared access resources principals access post fhr post fhr shared access principals resources accessed pre fhk pre fhk compromisation assessment resources principal gained access solely due presence maliciously accidentally issued certificate set pre fhk pre fhk compromisation assessment principals gained access resource solely due presence maliciously accidentally issued certificate set post fhr post fhr expiration vulnerability resources principal prevented accessing certificate set expires compromisation assessment expiration vulnerability principals excluded accessing resource certificate set expires compromisation assessment universally guarded access case authorizations issued resource involve certificate signed principal ltl model checking labeling defined surface configurations involve location labeled atomic proposition surface configurations labeled atomic proposition configurationhr satisfies ltl formula universally guarded access case authorizations grant principal access resource involve certificate signed ltl formula case labeling defined surface configurations involve location labeled atomic proposition surface configurations labeled atomic proposition surface configuration satisfies ltl formula efficiency automaton representation clarke give worst case name-reduction-closure algorithm illustrate efficiency automaton representation set configurations set certificates mod rule represents string length name-reduction closure yields rules pds set certificates true post fhk cig equal set configurations fhki akbji size set post fhk cig automaton representation post fhk cig size basic idea pair keys stack configuration hki post fhk cig iff hkj automaton representation commonalities captured means sharing automaton accepting set configurations post fhk cig states represent stack configurations akbj locations representing keys -edges a-edges pointing shared states lattice labellings section describes annotating pds configuration automaton labels lattice answer questions long specific authorization trust level authorization definitions related lattices found appendix cert set annotated label lattice pds transition rule pds label cert recall algorithm apre constructs automaton pre set configurations fhkp hkp start automaton accepts set configurations transition automaton labeled element lattice denoted initially transitions automaton labeled add transitions automaton saturation rule current automaton add transition label transition computed transition labelings individual transitions extended labelings paths taking meet labels transitions path labeling composite transitions obtained join labels paths interval lattice lattice intervals form non-negative integers current time represent interval top bottom elements intervals meet join intervals minfi maxfi label cert interval representing validity period label transition automaton produced algorithm apre authorization valid time case alice authorized login host monitor information log-off alice time units lattice trust levels lattice ordered bottom top elements lattice intuitively lattice represents trust levels low medium high trust levels denoted meet join elements assume cert labeled element lattice assigned label principal assigns high level trust cert case label transition automaton constructed 
algorithm apre represents trust level alice authorization label exists certificate chain labels label justifies granting authorization alice trust level monitor making authorization decisions distributed authorization computer sciences department uwmadison college letters sciences departments biology assume resource accessible faculty department belongs system administrator issue set certs cls kls faculty kls faculty kcs faculty kls faculty kbio faculty certs departments system administrator issue set certs ccs kcs faculty certs faculty members kcs students certs students determine principal authorized access resource clarke setting compute name-reduction closure set certs cls ccs proceed realistic setting sizes sets ccs cls large computing closure union require significant time space algorithms presented authorization question determined distributed manner work partitioned compute sets post cls fhr pre ccs fhkb hkb intersection non-empty standard operation automata granted authorization similar operation answer authorization questions departments bio notice name-reduction closure cls ccs yield certificates procedure proposed clarke provide basis distributed authorization-resolution procedure related work clarke considered problem discovering certificate chains spki sdsi algorithm based idea computing name-reduction closure certificate set problem model checking pushdown systems addressed present paper shown techniques papers solve problem discovering certificate chains provide answers broad array questions pose set spki sdsi certificates pds-based authorization algorithms compute actual closure certificate set namereduction closure fair amount research exists formal semantics spki sdsi research geared giving formal semantics local spaces tuple-reduction rules spki sdsi spki sdsi-to-pds connection presented paper alternative semantics spki sdsi names spki sdsi space identified configurations transition system defined pds compared existing work spki sdsi-to-pds connection advantages invent logic semantic account number aspects spki sdsi leverages substantial body research exists subject model-checking pdss parin general technical conditions hold approach correct principal refer local domain certs organized hierarchically ticular immediately obtains polynomial-time algorithms number certificate-set analysis problems benedikt showed pushdown systems equivalent unrestricted version hierarchical state machines hsms introduced restricted form alur yannakakis hierarchical means system consists state machines call unrestricted hsms recursive calls machines submitted icalp reviews contained remark submission contributions conceptual identifies unrestricted hierarchical state machines pushdown systems valuable pushdown systems existence fact class infinite-state systems model checking decidable knew potential practical present paper demonstrates pushdown systems clear practical set spki sdsi certificates pushdown system note construction section transliteration spki sdsi terminology pds terminology keys resources locations identifiers stack symbols certificates transition rules gave correspondence theorems demonstrated pdss indirect exist present paper shows pdss direct exist model-checking problem context-free processes addressed context-free processes viewed pushdown systems single control location benedikt addressed problem ltl ctl model checking unrestricted hsms similar algorithms ltl model checking developed independently contemporaneously alur abadi sdsi linked local spaces journal computer security alur etessami yannakakis analysis recursive state machines proc computer-aided verif july alur yannakakis model checking hierarchical state machines volume softw eng notes pages york nov acm press benedikt godefroid reps model checking unrestricted hierarchical state machines icalp blaze feigenbaum ioannidis keromytis keynote trust-management system version rfc sept blaze feigenbaum ioannidis keromytis role trust management distributed systems security vitek jensen editors secure internet programming security issues mobile distributed objects pages lncs bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur volume lec notes comp sci pages springer-verlag burkart steffen model checking context-free processes proc concur volume lec notes comp sci pages clarke elien ellison fredette morcos rivest certificate chain discovery spki sdsi jcs clarke elien ellison fredette morcos rivest certficate chain discovery spki sdsi http theory lcs mit rivest nov clarke grumberg peled model checking mit press elien certificate discovery spki sdsi certificates master thesis massachusetts institute technology ellison frantz lampson rivest thomas ylonen spki certificate theory rfc sept esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proc computer-aided verif volume lec notes comp sci pages july gerth peled vardi wolper simple onthe-fly automatic verification linear temporal logic protocol specification testing verification pages warsaw poland chapman hall halpern meyden logical reconstruction spki proceedings ieee computer security foundations workshop pages ieee computer society press howell kotz formal semantics spki technical report department computer science dartmouth college hanover mar knoop demand-driven model checking context-free processes thiagarajan yap editors proc asian comp sci conf volume lec notes comp sci pages dec local names spki sdsi proceedings ieee computer security foundations workshop july weeks understanding trust management systems proceedings ieee symposium research security privacy research security privacy oakland ieee computer society technical committee security privacy ieee computer society press details model checking pdss head transition rule surface configuration suppose set pre fhp vig equivalently case path transition system defined pds head repeating vii identifying repeating heads crucial ltl model checking pdss generalize slightly concept illustrated definition assume pds set locations configurations path passes configuration location set transition rule head called g-repeating exists set heads g-repeating heads pds set locations denoted theorem assume pds set locations set repeating heads computed time space jpj uchi automata -tuple alphabet set states transition relation initial state set final states set infinite words alphabet denoted infinite word alphabet accepted exists sequence states state appears infinitely sequence sequence states called accepting run language accepted uchi automata assume configuration ltl formula ltl formula atomic propositions exists uchi automaton alphabet accepts regular language efficient algorithms translate ltl formula uchi automaton uchi automaton ltl formula product pds produces uchi pushdown system ltl model-checking problem reduces accepting-run problem configuration satisfies iff exist accepting run starting configurationh run visits infinitely configurations control locations g-repeating heads proved configuration accepting run starting set non-empty post pre set configurations reachable fromh post set pre denotes set configurations run leading configuration repeating head details certificate-chain reconstruction transition configuration automaton associate structure components integer identifier list transitions suppose transition added due pds transition rule fact composite transition holds automaton composite transition comprised sequence transitions structure transition identifier pds transition rule denoted explain construction structures transitions shown figure empty structure empty list represented null tracing back structure transition obtain certificate chain proves authorization alice idempotent commutative associative absorption figure properties operators transition structure alice null bob null null null faculty figure structures transitions automaton shown figure background lattices lattice set binary meet join operators idempotent commutative associative figure elements form 
partially ordered set ordered defined ways iff iff write assume lattices bottom element top element chain sequence elements height length longest chain 
architecture generating semantics-aware signatures vinod yegneswaran jonathon giffin paul barford somesh jha computer sciences department wisconsin madison vinod giffin jha wisc abstract identifying intrusions developing effective signatures detect essential protecting computer networks present nemean system automatic generation intrusion signatures honeynet packet traces architecture distinguished emphasis modular design framework encourages independent development modification system components protocol semantics awareness construction signatures greatly reduce false alarms building blocks architecture include transport service normalization intrusion profile clustering automata learning generates connection session aware signatures demonstrate potential nemean semantics-aware resilient signatures prototype implementation datasets evaluate system production dataset false-alarm evaluation honeynet dataset measuring detection rates signatures generated nemean netbios exploits false-positive rate false-negative rate introduction computer network security multidimensional activity continues grow importance prevalence attacks internet ability selfpropagating worms infect millions internet hosts documented developing techniques tools enable precise rapid detection attacks presents significant challenges research operational communities network-security architectures include network intrusion detection systems nids monitor packet traffic networks raise alarms malicious activity observed nids employ misusedetection compare traffic hand-built database signatures patterns identify previously documented attack profiles effectiveness misuse-detector tightly linked quality signature database competing requirements make generating maintaining nids signatures difficult hand signatures specific identify characteristics specific attack profiles lack specificity leads false alarms major problems nids today sommer paxson argue including context victim response nids signatures reduces false alarm rates hand signatures general match variants specific attack profiles signature account transport application-level semantics lead false alarms balance specificity generality important objective signatures present design implementation architecture called nemean automatic generation signatures misuse-detection nemean aims create signatures result lower false-alarm rates balancing specificity generality achieve balance including semantics awareness ability understand session-layer application-layer protocol semantics examples session layer protocols include netbios rpc application layer protocols include smb telnet ntp http increasingly preprocessors protocols integral parts nids argue capabilities essential automatic signature generation systems reasons semantics awareness enables signatures generated attacks exploit small part entire payload semantics awareness enables signatures generated multi-step attacks exploit occur step semantics awareness weights assigned portions payload timestamps sequence numbers proxy-cache headers based significance semantics awareness helps produce generalized signatures small number input samples semantics awareness results signatures easy understand validate architecture components data abstraction component normalizes packets individual sessions renders semantic context signature generation component groups similar sessions machine-learning techniques generate signatures cluster signatures produced suitable deployment nids address specificity producing connection-level session-level signatures address generality learning signatures transport-normalized data consideration application-level semantics enables variants attacks detected argue nemean generates balanced signatures present nemean goal provide automated mechanism build accurate signatures pace exploits network viruses released everyday meant automate real-time deployment signatures discuss issue greater detail section input nemean set packet traces collected honeynet deployed unused address space data observed honeynet anomalous mitigating problem privacy problem separating malicious normal traffic assume honeynet subject attack traffic standard hosts discuss ramifications assumption section evaluate nemean architecture developed prototype implementation component implementation enables automated generation signatures honeynet packet traces developed simple alert generation tool off-line analysis compares packet traces signatures demonstrate current implementation extremely effective modular design architecture enables individual components easily replaced expect developments tune expand individual components resulting timely precise effective signatures broader perspective results demonstrate importance nemean capability comprehensive security architecture section describes architecture sections present prototype implementation nemean performed evaluations prototype calculated detection misdiagnosis counts packet traces collected unused address ranges total addresses distinct class networks allocated campus collected sessionlevel data exploits targeting ports http netbios smb section describes data collection environment packet trace data input nemean produce comprehensive signature set target ports section describe major clusters signatures produced data set leave-out testing results system generates accurate signatures common intrusions including code red nimda popular exploits detected http exploits netbios exploits misdiagnoses validated signatures testing false alarms packet traces http traffic collected department border router nemean produced false alarms data set comparison snort generated false alarms data set results suggest smaller signature set nemean achieves detectability rates par snort identifying attacks superior precision fewer false alarms related work sommer paxson proposed adding connectionlevel context signatures reduce false positives misuse-detection handley transportlevel evasion techniques designed elude nids normalization methods disambiguate data comparison signature similar work common http evasion techniques standard url morphing attacks vigna mutations demonstrated widely deployed misuse-detectors susceptible mutations works handley vigna highlight importance incorporating semantics signature generation process honeypots excellent source data intrusion attack analysis levin honeypots extract details worm exploits analyzed generate detection signatures signatures generated manually automated signature generation systems proposed table summarizes differences nemean signature-generation systems systems proposed honeycomb developed kreibich crowcroft nemean honeycomb generated signatures traffic observed honeypot implementation honeyd plugin heart honeycomb longest common substring lcs algorithm longest shared byte sequences pairs contraffic source generates contextual semantics signature generation target signatures aware algorithm attack class nemean honeypots generates connectionand msg clustering general sessionlevel signatures automata learning autograph dmz generates copp partitioning worm byte-level signatures content blocks earlybird dmz generates measuring worm byte-level signatures packet-content prevalence honeycomb honeypots generates pairwise lcs general byte-level signatures connections figure comparison nemean signature-generation systems nections honeycomb protocol semantics pairwise lcs algorithm outputs large number signatures frequently distracted long irrelevant byte sequences packet payloads reducing capability identifying attacks small exploit strings exemplified protocols netbios discuss greater detail section kim karp autograph system automated generation signatures detect worms unlike honeycomb nemean autograph input packet traces dmz includes benign traffic content blocks match suspicious flows input copp algorithm based rabin fingerprints searches repeated byte sequences partitioning payload content blocks honeycomb autograph protocol semantics argue approaches attractive principle viable limited spectrum observed attacks prone false positives makes autograph susceptible mutation attacks finally unlike byte-level signatures produced autograph nemean produce connection-level session-level signatures system developed generate signatures worms earlybird measured packet-content prevalence single monitoring point network dmz counting number distinct sources destinations strings repeat payload earlybird distinguished benign repetitions epidemic content autograph earlybird produced byte-level signatures aware protocol semantics earlybird disadvantages compared nemean autograph pouget dacier analyzed honeypot traffic identify root frequent processes observed honeypot environment organized observed traffic based port sequence data clustered association-rules mining resulting clusters refined phrase distance pouget dacier technique semantics aware julisch clustered alarms 
purpose discovering root-cause alarm clustering alarms julisch technique generated generalized alarm cluster intuitively generation generalized alarms similar automata-learning step algorithm goals techniques work julisch christodorescu presented semanticsaware methodology detect malicious traits binaries approach semantics aware algorithm incorporates semantics instructions executed contrast nemean incorporates semantics protocols parsing application level packet content malware-detection algorithm presented signature-generation algorithm nemean semantics levels anomaly detection alternative approach malicious traffic identification nids anomaly detectors construct model acceptable behavior flag deviations model suspicious anomalydetection techniques detecting port scans explored balancing specificity generality proven extraordinarily difficult anomaly-detection systems systems high false-alarm rate paper focuses misuse-detection discuss anomaly-detecting techniques nemean architecture shown figure nemean architecture divided components data abstraction component signature generation component input nemean packet trace collected honeynet deployed small address space addresses honeynet provide large volume data significant privacy false positives concerns data abstraction component data abstraction component dac aggregates transforms packet trace well-defined data structure suitable clustering generic clustering module specific knowledge transport protocol application-level semantics call aggregation units semi-structured session trees ssts connection clusters session clusters automata learning service specification servicenormalization normalization transport session trees flow aggregation generalization rules packet trace sessions semi structured connection clusteringpackets signatures connection session session clustering data abstraction component signature generation component figure components data flow description nemean architecture components dac thought terms data flow module shown figure built dac module principle implemented extension standard nids bro policy script transport normalization disambiguates obfuscations network transport layers protocol stack dac reads packet traces libpcap library run online offline tcpdump traces step considers transport-specific obfuscations fragmentation reassembly duplicate suppression checksums describe greater detail section aggregation step groups packet data hosts sessions normalized packet data composed stored flows periodically dac expires flows converts connections flow expired reasons connection initiated pair hosts ports flow inactive time period greater user defined timeout hour experimental setup flows composed packets connections composed request-response elements connection stored part session session sequence connections host pairs service-specific information sessions normalized clustering reasons classification sessions robust clustering algorithms independent type service space ambiguities large produce signature encoding attacks decoding service-specific information canonical form normalization enables generation compact signature set detection system decode attack payloads signature matching strategy consistent employed popular nids describe normalizations performed greater detail section dac finally transforms normalized sessions xml-encoded ssts suitable input clustering module step assigns weights elements sst highlight important attributes url http request deemphasize important attributes encrypted fields proxy-cache headers http packets nemean current weight assignment simply based expert knowledge protocols prevalent attacks noted weights tuned reflect specific attack meant sufficiently general reflect high level behavior drawn large class attacks expect periodically adjusted accommodate significant exploit patterns signature-generation component clustering module groups sessions connections similar attack profiles similarity metric assume sessions grouped correspond single attack type variants well-known attack disparate clusters represent distinct attacks attack variants differ significantly original attack effective clustering requires properties attack data data correspond attack variants measurably similar clustering algorithm classify data belonging attack data attacks measurably dissimilar clustering algorithm separate data required properties hold data sets include significant quantities nonmalicious normal traffic properties normal traffic vary greatly make effective clustering difficult additional discrimination metrics conversely malicious data identifiable structure presence obfuscation limited polymorphism nemean honeynet data enables reasonable number meaningful clusters produced cluster ideally set sessions connections attack presume data minor obfuscations sequential structure data correspond attacker attempts evade detection variations provide basis signature generation component automata learning module constructs attack signature cluster sessions generator implemented target intrusion detection system produces signatures suitable system component ability generate highly expressive signatures advanced systems regular expression signatures session-level context suitable bro clusters nonuniform sessions interest differences obfuscation transformations modify attack change made existing attack produce variant signature generation component generalizes transformations produce signature resilient evasion attempts generalizations enable signatures match malicious sequences observed training set current limitations worms viruses variants existing malware internet everyday standard collections signatures pace goal nemean address gap automating signature generation nemean address automating real-time deployment signatures emphasis accurate efficient signatures timeliness current nemean design includes simple manual selection process selecting generated session connection-level signatures cluster multistep attacks welchia benign connection request precedes attack sequence case operator simply chooses connection signatures steps welchia session signature whitelists signature benign step provide results connection session-level signatures attack evaluation remove benign connection welchia issue attacks sanity check ensure signature corresponds attack cluster misconfiguration intentional data pollution issue evaluation dataset operational deployment interesting aspects semantics-aware approach results signatures semantic context easily parsed misconfiguration separated picking clusters large number sources large number destinations fully-automating nemean making immune data pollution remains area future work reason requirement unlike systems earlybird autograph target attacks seek address broader flash worms includes everyday targeted attacks viruses spreading network shares botnet sweeps occur noise thresholds similar misconfiguration expect intentional data pollution large botnets issue aforementioned systems dac implementation implemented prototypes nemean component nemean design flexibility handle protocol focus discussion specific protocol implementations http port netbios smb ports services exhibit great diversity number types exploits transport-level normalization transport-level normalization resolves ambiguities introduced network transport tcp layers protocol stack check message integrity reorder packets needed discard invalid duplicate packets importance transport layer normalizers addressed literature building normalizer perfectly resolves ambiguities complicated endeavor ambiguities operating system dependent constrain set normalization functions reasons traffic honeynets perfect knowledge host environment environment remains constant worry ambiguities introduced due dhcp network address translation nat nemean current implementation analyzes network traces off-line relaxes state holding requirements makes vulnerable resource-consumption attacks attacks attempt evade nids introducing ambiguities packets examples attacks include simple insertion attacks dropped real systems evaluated nids evasion attacks reverse nemean obtains traffic promiscuously packet sniffer real nids ambiguities resolved focus common techniques attackers elude detection invalid field protocol header nids handle packet differently destination machine handling invalid protocol fields packets involves steps recognizing presence invalid fields understanding operating system handle implementation performs validations build multiset normalized connections cluster exclusive partitions produce connection-level signature cluster generalizing cluster data build multiset sessions session sequence identifiers denoting connection clusters connection session cluster partitions produce session-level signature cluster generalizing observed connection orderings produce nids signature signature hierarchical automaton transition 
session-level signature requires connection-level signature identified connection cluster accepts figure multi-level signature generalization msg algorithm section complete details drop packets invalid checksum length field attacker fragmentation present data nids destination fragmentation introduces problems correctly reordering shuffled packets resolving overlapping segments operating systems address problems ways adopt alwaysfavor-old-data method microsoft windows live deployment periodically perform activemapping match rules passive operating system fingerprinting logic applies fragmented overlapping tcp segments incorrect understanding tcp control block tcb tear-down timer nids improperly maintain state closes connection early lose state likewise retaining connections long prevent detection legitimate connections implementation maintains connection state hour session closed sessions closed reset replaced earlier connection setup observed host port pairs service-level normalization provide discussion implementation service normalizers popular protocols http netbios smb ambiguities http sessions primarily introduced due invalid protocol parsing invalid decoding protocol fields improper url decoding point vulnerability intrusion detection systems modern web servers substitution encoded characters ascii characters url exploited means evasion common nids signatures dac correctly decodes observed encodings hex encoding variants utfencoding bare-byte encoding microsoft unicode encoding encoding dac presents canonical url ascii format clustering module implementation handle obvious http obfuscations process pipelined http requests requests broken multiple connections analysis plan incorporate functionality system future netbios session-layer service enables machines exchange messages names addresses port numbers smb server message block transport-independent protocol file directory services microsoft windows machines netbios exchange smb file requests netbios smb signature evasion techniques studied possibly due lack good nids rules detection full treatment netbios smb ambiguities exceeds scope paper multi-level signature generalization designed multi-level signature generalization msg algorithm automatically produce signatures normalized session data signatures balance specificity exploits observed data generality ability detect attack variants previously observed machine-learning algorithms including clustering finite state machine generalization produce signatures well-balanced due hierarchical nature session data construct signatures connections sessions separately cluster connections irrespective sessions generalize cluster produce signature connection cluster cluster sessions based constituent connections generalize clusters finally combine session connection signatures produce hierarchical automaton signature connection session signature match connection signature figure presents high-level overview algorithm steps generating connection clusters multiset normalized sessions produced data abstraction component denote session ordered list connections cns conn multiset connections unionmultitexts sconn multiset connections normalized data denotes multiset union exclusive clustering clusters clustering inserts element partition sounionmultitextmi exclusive clustering requires partitions overlap forinegationslash immediately exists welldefined function defined returns cluster section presents implementation clustering algorithm step building connection-level signatures learning algorithms generalize data cluster produce signatures match previously unseen connections alphabet network events comprising connection data learning algorithm function learn takes set strings hatwider uniontextc returns regular language hatwider section presents generalization algorithms work recognize regular automaton connection-level signature cluster steps generating session clusters rewrite existing sessions produce set unionmultidisplay cns bracketleftbigs cns bracketrightbig implementation perspective rewritten session simply integer index indicating connection cluster original connection intuitively connection comprising part session replaced connection identified clustering similar clustering steps building session-level signatures connection-level generalization construct regular language cluster accepts sessions variants sessions recognize language finite automaton connection cluster identifiers label transitions session-level automata resulting signature hierarchical traversing transition session signature requires connection data matching signature connection cluster star clustering implementation cluster connections sessions algorithm implemented on-line star clustering algorithm clusters documents based similarity metric algorithm advantages commonly-known techniques k-means family algorithms star clustering robust data ordering conversely k-means produces clusters depending order data read priori start search end search aaaaaaaaaaaaa search aaaaaaaaaaaaa search search aaaaaaaaaaaaa search aaaaaaaaaaaaa figure welchia session level signature brevity label single transition request reply clusters expected suitable make claims star optimal clustering algorithm purposes expect algorithms future work star clustering builds star cover partiallyconnected graph nodes graph represent items semantically equivalent data arbitrarily choose item node representative item link exists nodes similarity representative items designated threshold star cluster collection nodes graph node connects cluster center node edge star cover collection star clusters covering graph cluster centers connecting edge original algorithm non-center node edges multiple center nodes multiple clusters implemented modified algorithm inserts node cluster strongest similarity produce exclusive clustering item similarity determines edges graph implemented similarity metrics test sensitivity cosine similarity hierarchical edit distance cosine similarity metric lower computational complexity hierarchical edit distance experiments section cosine similarity computes angle vectors representing items comparison connection build vector giving distribution bytes request types response codes appeared network data sessions vector distribution connection cluster identifiers angle vectors representing items cos dbbardbld abardblbardbldbbardbl represents product bardblvbardbl vector start winnt system cmd exe dir end start post scripts nsiislog dll end start session request session response negotiate request negotiate response session setup andx request tree connect andx request admin ipc session setup andx reply tree connect andx reply session setup andx reply tree connect andx reply tree connect andx request create andx request end system psexesvc exe figure nimda windows media player exploit deloder connection level signatures transitions nimda signature match norm vector values non-negative cos similarity items cos cos indicating equality hierarchical-edit distance variation traditional edit-distance metric measures cost transforming string insert delete replace operations contrast traditional editdistance metric hierarchical-edit distance metric preserves connection ordering information session differentiates data fields connection believed properties hierarchical-edit distance metric make similarity metric clustering cosine metric experiments revealed distance metrics work cosine sensitive threshold parameters partitioning clusters cosine distance paper experiments describe hierarchical edit distance metric expanded technical report similarity metric construct partiallyconnected similarity graph edge connects pair nodes similarity representative sessions threshold build star cover similarity graph star cluster group similar sessions variants exploit cluster set passed generalization module produce automaton signature cluster generalization signature generation signature generation devises nids signature cluster similar connections sessions generalize variations observed cluster data assuming effective clustering variations correspond obfuscation attempts differences variants attack generalizing differences produce resilient signature accepts data necessarily observed training period signature finite state automaton construct probabilistic finite state automaton pfsa accepting event sequences contained cluster edge weights number times edge traversed accepting cluster data pfsa learning algorithms stochastic measures generalize data variations observed cluster work generalized http connection-level signatures sk-strings method algorithm merges states probabilistically indistinguishable session-level clusters generalized beam search algorithm sk-strings simulated beam annealing generalize netbios 
signatures generalizations add transitions state machine accommodate variations data reordering alteration characters attack string likewise repeated strings generalized number repeats generalize signatures points high data variability subsequence creation converts signature matches sequence session data signature matches subsequence data inserting gaps accept sequence arbitrary symbols insert gaps observing patterns common prefix common suffix dissimilar data element signature accepts avb awb axb ayb replace sequences regular expression intuitively identified portion signature exhibiting large variation vary arbitrarily final signature nemean generalized signatures detect variations observed attacks figure shows session-level signature welchia worm exploits buffer overflow nemean generalization produced signature matches wide class welchia scans losing essential buffer overflow information characteristic worm figure shows connection-level signatures nimda windows media player exploit deloder netbios worm connection-level nimda signature signature exploit high diversity note subsequence creation generalization signature match wide class nimda attacks windows media player exploit representative http exploit size exploit url small previous signature generation techniques honeycomb fail small urls deloder signature demonstrates capability nemean generate signatures exploits complex protocols netbios smb data collection data evaluation sources honeypot packet traces collected unused address space build signatures evaluate detection capability nemean packet traces collected departmental border router test resilience signatures false positives production traffic obtaining packet traces live network traffic challenge due privacy concerns network operators amenable sharing flow level summaries anonymizing payloads remains unsolvable problem hard obtain packet traces application payloads obtain access data department border router network sparsely allocated managed network approximately web servers clients passively monitor outgoing incoming http packets network hour period table summary dataset honeypot traffic traffic unused address blocks totaling addresses address ranges allocated routed honeynet monitoring environment normalize traffic received infrastructure simple sourcefiltering rule employed destination address source connections additional destination addresses dropped filter filtered packets subsequently routed systems based type-of-service http requests forwarded fully patched windows server running vmware netbios smb traffic routed virtual honeypot system similar honeyd routed netbios smb packets active responder masquerading end host offering netbios services windows server reasons fully patched windows server rejected disconnected session information classify attack vector accurately due invalid netbios names user password combinations active responder accepted netbios names user password combinations windows servers limit number simultaneous network share accesses inhibit connection requests succeeding collected sets traces short term training set days longer testing set days evaluate nemean detection capability summarized table reduction volume port traffic moving -day -day dataset uncommon honeynets due bursty nature traffic botnet activity evaluation tested effectiveness nemean http netbios signatures examined session clusters produce signatures section reveals major classes attacks recorded data quantitatively measures clusters produced clustering module performed evaluation detection false positive rates nemean signatures compare results snort http capabilities finally provide qualitative discussion experience honeycomb evaluating clusters http clusters figure overview major http clusters learning data set webdav scans account majority attacks data set webdav collection http extensions users collaboratively edit mandata flow clients servers sessions connections internal clients external servers external clients internal servers table production data summary http hours learning data days test data days port packets sources connections sessions packets sources connections sessions table honeypot data summary age documents remote web servers popular webdav methods exploits include options search propfind supported microsoft iis web servers scans exploits webdav vulnerabilities gaining popularity worms welchia nimda attacks provide great diversity number attack variants http url obfuscation techniques attacks exploit directory traversal vulnerabilities iis servers access cmd exe root exe figure connection-level signature nimda generated nemean details observed exploits frontpage web crawlers open-proxy provided netbios clusters worms typically viruses dominate netbios clusters viruses scan open network shares behavior dominated observed traffic broadly classified types hidden open share exploits includes viruses including lovgate navsvc deloder brute force password attacks open folders deposit virus binaries startup folders ms-rpc query exploits microsoft windows ability remotely access msrpc services named pipes epmapper rpc endpoint mapper srvsvc windows server service samr windows security account manager viruses connect msrpc services guest users proceed query system additional information lead privileged user access connecting samr service attacker obtain enumeration domain users ms-rpc service buffer overflow exploits well-known exploits epmapper service access rpc-dcom exploit blaster recent lsarpc exploit sasser provide details technical report cluster quality quantitatively evaluated quality clusters produced star clustering algorithm common metrics precision recall precision proportion positive matches elements cluster recall fraction positive matches cluster positive matches data set intuitively precision measures relevance cluster recall penalizes redundant clusters manually tagged session conjectures shown figure conjectures identified sessions attack types session marked multiple conjectures important note conjectures clustering served simply evaluation aids estimate quality clusters conjectures compute weighted precision weighted recall clustering sessions tagged multiple conjectures weight measurements based total number conjectures cluster sessions compute values set clusters set conjectures set elements clusterclabeled conjecture count number elements cluster conjecture cluster unique client ips sessions identified options cluster unique client ips sessions identified nimda identified code blue cluster unique client ips sessions identified welchia identified search cluster unique client ips sessions identified search identified web crawler cluster unique client ips sessions identified nimda cluster unique client ips sessions identified propfind identified options cluster unique client ips sessions identified nimda cluster unique client ips sessions identified windows media exploit cluster unique client ips sessions identified search cluster unique client ips sessions identified code red retina identified search cluster unique client ips sessions identified propfind identified options cluster unique client ips sessions identified propfind identified options cluster unique client ips sessions identified propfind identified options cluster unique client ips sessions identified frontpage exploit cluster unique client ips sessions identified kazaa cluster unique client ips sessions identified web crawler cluster unique client ips session identified real media player cluster unique client ips session identified propfind identified options cluster unique client ips session identified open proxy figure http port cluster report formulas summationtextk andsummationtext sessions multiple conjectures figure presents graphs indicating precision recall vary clustering similarity threshold recall star clustering algorithm edge added sessions graph sessions similarity threshold true netbios data similarity threshold significant impact quality resulting clustering clustering precision drops threshold nears star graph fully connected algorithm select suitable cluster centers recall cluster 
centers share edge clusters merge low threshold values clustering threshold experiments precision scores perfect perfect signature effectiveness intrusion detection signatures satisfy basic properties high detection rate miss real attacks generate false alarms results show nemean detection rate false alarms additional metrics evaluate quality alarms raised ids precision empirically evaluates alarms specificity attack producing alarm noise level counts number alarms incident penalizes redundant alarms tests snort baseline comparison simply widely adopted intrusion detection system latest version snort time snortwith http pre-processor enabled complete ruleset sense snort strawman well-known susceptibility false-positives inability compare honeycomb section source code publicly earlybird autograph detection rate evaluated detection rate nemean signatures leave-out testing common technique machine learning honeynet data set table automatically create connection-level session-level signatures clusters identified training data set measured detection rate signatures running signature matching data trace collected network table connection-level http signatures detected attacks present restrictive session-level signatures detected evaluate session-level signatures nimda extreme variability nimda attacks made signatures inappropriate table shows number occurrences http attacks number detected nemean signatures comparison provide detection counts snort running up-to-date signature set snort detected attacks detection rate netbios attacks similarly high detected attacks present table detection rates netbios smb signatures snort limited detection capability netbios attacks comparison infeasible signatures connection-level defining characteristic attack string contained single connection structure connections session irrelevant attacks misdiagnoses false alarms qualify incorrect alerts honeynet data misdiagnoses shown table nemean http signatures generated misdiagnoses honeynet trace misdiagnosis counts netbios smb honeynet data shown table measured false alarm counts nemean http signatures packet-level traces collected department border router hour time period traces contained inbound outbound http traffic evaluated nemean snort dataset similarity threshold port precision recall similarity threshold port precision recall similarity threshold port precision recall figure effect clustering similarity threshold weighted precision weighted recall note y-axis begins nemean signature present conn sess snort options nimda propfind welchia win media player code red retina kazaa table session-level http signature detection counts nemean signatures snort signatures show exploits occurring training test data signature present detected misdiagnoses srvsvc samr epmapper nvcpldmn deloder lovegate table detection misdiagnosis counts connection-level nemean netbios signatures data includes port port traffic nemean results highly encouraging false alarms snort generated alarms dataset false alarms snort false alarms produced collection overly general signatures fairness note snort larger signature set made prone false positives snort signature set included signatures nemean database http netbios signatures contained connection-level session-level signatures snort high signature count meant detect classes attacks besignature alerts non-rfc http delimiter bare byte unicode encoding apache whitespace tab web-misc doc access non-rfc defined character double-decoding attack iis unicode codepoint encoding table snort false alarm summary http sessions collected department border router alert category signatures alerts web-misc web-cgi web-iis web-attacks web-php web-frontpage crawlers table summary remaining snort alerts yond honeynets table summary snort alarms generated hour trace overwhelmingly benign http traffic collected department border router reducing snort alarm rate require reengineering signatures additionally overly general signature specific information type exploit occurring assume real network deployment snort noisy signatures table disabled reasonable estimate expected false alarm rates obtained remaining alerts shown table remaining alerts signatures responsible alerts excluding inspect individually true positives due privacy concerns dataset sampling revealed false alarms traffic classified legitimate alerts fired benign traffic traffic web crawlers filters netbios traffic campus border unable obtain netbios data experiment highly specific alarms decision ultimately subjective signatures generate alerts empirically alerts produced packet-level systems snort typical snort alerts bare byte unicode encoding non-rfc http delimiter highly revealing report underlying symptom triggered alert high-level reason symptom present problem netbios alerts popular worms viruses generate virtually set alerts call weak alerts describe detail technical report nemean connection-level session-level signatures larger perspective host intentions result generate alerts specific worms exploits low noise due session-level signatures nemean control level noise alarms packet-level detection systems snort raise alerts multiple packets comprising attack security administrator flurry alerts incident nimda attack encoded url generate url decoding alarms snort alerts web-iis cmd exe access sophisticated url decoding attacks misdiagnosed nimda alerts filtered administrators normalizer converts url canonical form accurately detect nimda attacks nemean aggregates information connections sessions generates alerts aggregated data number alerts incident reduced summation results demonstrate strength nemean achieves detection rates similar snort dramatically fewer false alarms alerts produced nemean exhibit high quality attack detected keeping detection noise small signature generation efficiency current implementation operates offline collected data sets intend nemean online signature generation online systems efficient signatures rapidly constructed attacks begin system operate network speeds low computational demands figure shows nemean overheads -day training data set http packets netbios packets total data processing time divided stages data abstraction clustering automaton generalization additional preprocessing step translated ssts produced dal input format clustering module http connectionlevel automaton generalization step sk-strings algorithm session-level generalization beam search cost arising cluster nimda sessions packets cost session-level generalization seconds netbios signature generalization simulated beam annealing connection-level construction session-level signatures nemean efficient generate signatures days worth netbios data totaling million packets seconds expensive operation session-level generalization http data required minutes computation design system helps costs low processing data collected honeynet volume data significantly reduced deploying nemean online signature generator require limited system resources easily operate speeds incoming data honeycomb comparison honeycomb efforts address problem automatic signature generation honeypot traces performed comparison nemean honeycomb identical traces means understand benefits semantics awareness automated signature generators evaluation complicated issues transformed honeycomb honeyd plug-in implementation standalone application feeding input traffic pcap loop honeycomb developed proof-ofconcept tool turned incapable processing large traces experience honeycomb processing time grows quadratically connection performs pairwise comparison connections running small trace packets hours high performance workstation result evaluation qualitative comparison honeycomb signatures performance small trace http connections honeycomb produced signatures input trace perfectly functional signatures surprisingly large number benign strings identified lcs algorithm small strings number packets thousands seconds data abstraction preprocessing clustering generalizationconnection http sessiongeneralization number packets millions seconds netbios data abstraction preprocessing clustering generalizationconnection figure time construct signatures http netbios data based number packets data set note scales differ graphs preprocessing data file translation step converting ssts input format clustering module http session-level signature 
generalization required seconds packets honeycomb signature exploit deficiency msadc root exe dir http nimda redundant host connection close root exe dir http host connection close search http host webdav restrictive connection keep-alive benign http table signatures produced honeycomb http trace connections http impractical happened longest common substring unrelated sessions communication honeycomb author revealed part normal operation typical suppress whitelist signatures smaller length longer strings signature set proxy-headers represent real attack signatures avoid kinds problems manual grooming signatures expert protocol knowledge noted nemean requires sanity check process affects honeycomb greater extent tendency generate large number signatures summary comparison signatures produced honeycomb versus produced nemean honeycomb produces large number signatures lack specificity due pairwise connection comparison nemean algorithm generalizes cluster includes connections resulting smaller balanced signature set pairwise lcs employed honeycomb leads redundant non-identical signatures generate multiple alarms attack nemean algorithm generalizes clusters semantics awareness makes prone redundant signature production honeycomb signatures restrictive result require restrictive signatures capture instances attack lead false negatives nemean generation balanced signatures make susceptible false negatives honeycomb lack semantics awareness leads signatures consisting benign substrings lead false positives explains honeycomb unable produce precise signatures protocols netbios ms-sql http attacks nimda exploit content small portion entire attack string nemean semantics awareness addresses issue benign substrings present examples signatures obtained honeycomb demonstrate weaknesses table discussion potential vulnerability nemean honeynets data source attackers aware attempt evade monitor pollute irrelevant traffic resulting unnecessary signatures evasion complicated periodic rotation monitored address space intentional pollution problem automated signature generation method intend address future work issues arise deploying nemean live network live networks real traffic assume observed sessions malicious produce signatures live traffic traces mixed malicious normal traffic separate normal traffic malicious flow-level anomaly detection packet prevalence techniques identify anomalous flows complete traffic traces simple techniques flag sources horizontally sweep address space vertically scan ports machine count number rejected connection attempts nemean generate meaningful signatures snort bro nids snort utilizes http preprocessor detect http attacks provide support regular expressions converting nemean signatures bro signatures straightforward bro creation policy scripts support regular expressions focus current implementation limited manual selection required suggests automating deployment nemean signatures realizable resiliency nemean signatures false positives makes attractive means automate defense flash worms propagate rapidly data abstraction component modules work live traces star clustering algorithm designed perform incremental clustering work online fashion anomaly detection techniques employed parallel nemean flag compelling clusters worm outbreaks automatically generated nemean signatures clusters rapidly propagated nids defend emergent worms conclusions design implementation nemean system automated generation balanced nids signatures primary objectives system reduce false alarm rates creating signatures semantics aware nemean architecture comprised major components data-abstraction component signature-generation component modular design supports encourages independent enhancement piece architecture nemean packet traces collected honeynets input provide unfettered view wide range attack traffic evaluated prototype implementation nemean data collected unused subnets collected packet traces services developed service normalizers http netbios smb running nemean data resulted clusters wide variety worms exploits evaluation suggests simple similarity metrics cosine metric provide clusters high degree precision demonstrated signature generation capability system discussed optimizations automata learning module structure abstraction subsequence creation showed nemean generated accurate signatures extremely low false alarm rates wide range attack types including buffer overflows welchia attacks large diversity nimda attacks complicated protocols netbios smb future work intend hone on-line capabilities nemean assess performance longer periods time live deployments continue evaluate methods clustering learning objective fine tuning resulting signature sets acknowledgements work supported part army research office grant daad office naval research grant national science foundation grant cnsthe author supported part lawrence landweber ncr graduate fellowship distributed systems author supported part cisco systems distinguished graduate fellowship government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government csl providing access traces dave plonka geoff horne bill jensen michael hare support isink project finally vern paxson shepherd fabian monrose anonymous reviewers insightful comments greatly improved presentation paper agrawal imielinski swami mining association rules sets items large databases acm sigmod international conference management data aslam pelekhov rus practical clustering algorithm static dynamic information organization acmsiam symposium discrete algorithms soda baltimore maryland january caswell roesch snort network intrusion detection system http snort april christodorescu seshia jha song bryant semantics-aware malware detection ieee symposium security privacy oakland california conneff hllw lovgate removal tool http securityresponse symantec avcenter venc data hllw lovgate removal tool html april handley paxson kreibich network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington august honeynet project http project honeynet april julisch clustering intrusion detection alarms support root analysis acm transactions information system security tissec november jung paxson berger balakrishnan fast portscan detection sequential hypothesis testing ieee symposium security privacy oakland california kim karp autograph automated distributed worm signature detection usenix security symposium san diego california august kreibich crowcroft honeycomb creating intrusion detection signatures honeypots workshop hot topics networks hotnets-ii cambridge massachusetts november lai deloder worm trojan analysis http wwwklcconsulting net deloder worm htm april levine labella owen contis culver honeynets detect exploited systems large enterprise networks ieee workshop information assurance west point york june lloyd squares quantization pcm ieee transactions information theory itmicrosoft security bulletin http microsoft technet security bulletin asp april pang yegneswaran barford paxson peterson characteristics internet background radiation acm sigcomm usenix internet measurement conference patrick raman andreae beam search algorithm pfsa inference pages springer-verlag london edition paxson bro system detecting network intruders real time usenix security symposium san antonio texas january pouget dacier honeypot-based forensics auscert asia pacific information technology security conference auscert brisbane australia provos virtual honeypot framework usenix security symposium san diego august ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks january puppy whisker anti-ids tactics http wiretrip net rfp txt whiskerids html april raman patrick beam search simulated beam annealing technical report department information systems massey palmerston north zealand raman patrick sk-strings method inferring pfsa international conference machine learning icml nashville tennessee july sasser worm http securityresponse symantec avcenter venc data sasser worm html shankar paxson active mapping 
resisting nids evasion altering traffic ieee symposium security privacy oakland california singh estan varghese savage automated worm fingerprinting symposium operating systems design implementation osdi december sommer paxson enhancing byte-level network intrusion detection signatures context acm conference computer communication security ccs washington october staniford hoagland mcalerney practical automated detection stealthy portscans journal computer security staniford paxson weaver internet spare time usenix security symposium aug vigna kemmerer netstat network-based intrusion detection system journal computer security vigna robertson balzarotti testing networkbased intrusion detection signatures mutant exploits acm conference computer communication security acm ccs washington october yegneswaran barford plonka design internet sinks network abuse monitoring recent advances intrusion detection sophia antipolis france sept yegneswaran barford ullrich internet intrusions global characteristics prevalence acm sigmetrics san diego california june yegneswaran giffin barford jha architecture generating semantic-aware signatures technical report wiscsonsin http wisc vinod nemean-tr pdf notes labor greek hero heracles rid nemean plain fierce creature nemean lion slaying beast heracles wore pelt impenetrable armor future labors honeynet network high-interaction honeypots negligible amount non-malicious traffic honeynet caused misconfigurations easily separated malicious traffic honeyd popular open-source low-interaction honeypot tool simulates virtual machines unused address space check destinations avoids hotspot misconfiguration observation confirmed personal communication kreibich authors honeycomb signature general version signature redundant host field signature miss attacks sources prefixes 
firewalls david parter wisconsin computer sciences department computer systems lab dparter wisc april topics firewall basics types firewalls deployment scenarios related technologies real world experience summary questions resources firewalls internet security repelling wily hacker cheswick bellovin rubin building internet firewalls zwicky chapman cooper firewall-wizards mailing list http honor icsalabs mailman listinfo firewall-wizards firewall basics security model types firewalls firewall rules security model perimeter security guard gate checking badges assumes inside trusted larger area inside perimeter complexity weaker security smaller perimeter specific security applies predefined access rules firewall protect vulnerable services poorly designed protocols poorly implemented protocols services protect vulnerable computers devices poorly configured configured patched firewall protect appliance protect system upgraded version upgrade restrictions vendor printers data acquisition devices scientific instruments devices customized embedded versions popular operating systems devices embedded web servers configuration control firewall defeat denial service dos attacks firewall bandwidth considered easy solution satisfy check-box requirements deal security place advantage total security point view perimeter security defense depth improved security reduced perimeters types firewalls basic technology options basic technology options packet filtering screening application proxy factors statefull stateless router bridge configuration security model packet filtering acts router bridge modify network connections packet headers deny packets based packet data deny packets based input output interface shorthand source destination deny packets based packet data layer source destination mac addresses layer source destination addresses ports protocol protocol details disallow source routing disallow icmp redirect packets disallow common malicious packet signatures deny packets based packet data layer service-specific url packet filtering packet filtering rules typically applied specific order match applies filter rule default rule default deny safest warning implied default rule deny packet filtering rules protect network cisco router access control lists apply rules top bottom deny permit tcp permit tcp permit tcp deny icmp redirect log permit icmp echo deny icmp echo log deny log packet filtering rules protect network openbsd block log block log quick campus pass quick campus proto tcp port pass quick proto tcp state packet filtering advantages strategic locations internet internal network border router isolate critical servers efficient simple concept packet filtering advantages widely implemented routers firewall appliances open source operating systems software specialized network interface cards filtering capabilities download rules packet filtering disadvantages hard configure rules complex hard test verify rules incomplete implementations bugs fail unsafe unintended traffic pass packet filtering disadvantages reduces router performance policies don map packet filtering proxy firewalls specialized application handle specific traffic protocol gateways creates network connection forwards data inside connection apply service-specific rules policies transparent proxies visible sender receiver implement intercepting redirecting traffic specific ports complicate debugging user problems proxy isn visible users non-transparent proxies visible sender receiver rewrites headers requires client reconfiguration require reconfiguration end change access lists proxy web caches proxies semi-transparent proxies visible client client reconfiguration visible end connections proxy address web caches load balancers problems servers restrict access state shared remote address proxy firewall proxy advantages intelligent filtering perform user-level authentication information connection packet stream protect weak faulty implementations separate network connections source destination proxy advantages provide application service-specific services actions data caching data connection logging data filtering selection server selection based source destination status visible proxy add apply routing bandwidth policy proxy disadvantages write install proxy service lag time develop proxy service dedicated proxy servers service cooperation clients servers dealing connections typical scenario restrict incoming connections specific services servers traffic public web site inbound e-mail mail gateway unlimited outgoing connections employees browse web send e-mail tcp connections outbound connections dynamic unpredictable source port firewall rule based source port destination well-known port tcp connections destination move dynamic port connection establishment issues multi-homed servers make services listening replying correct address policy based inbound packet destination address tcp connection setup src port abc dst port syn src port xyz dst port abc syn acksrc port abc dst port xyz ack src port xyz dst port abc ack udp connections udp stateless connection session implied packets src dst packets back well-known port port original traffic udp session dns query src port abc dst port src port xyz dst port abc src port xyz dst port abc tcp connections state detect established tcp connections keeping state established connections ack flag set established keyword stateless firewalls incoming packets ack flag set exploited faking packets ack flag set udp connections state keeping state stateless firewalls easy implement memory cpu requirements low routing impact act information packet keeping state statefull dynamic firewalls information decision making keeping state complicated proxy firewalls state packet filtering firewalls statefull state information tcp track outbound tcp packets match existing session update session data session setup packet syn ack create session state table session ended session shutdown packet delete session state table state information tcp inbound tcp packets match existing tcp session packet reject packet track tcp session state delete session state table finished state information udp track outbound udp packets match existing session update session data create session state table session state time interval inbound udp packets match existing session packet reject packet state information udp works typical same-port scenario reply outbound traffic port outbound traffic complicated session-setup protocols won work distributed firewalls firewalls share load redundancy event hardware routing failure rules synchronized state synchronized routing firewalls firewall devices act routers interface address packet processing filters applied stack traversed ttl decremented packet routed delivery destination routing firewalls visible network routing table neighbors shows traceroute bridging firewalls bump road interfaces addresses packet processing filters applied stack firewall path ttl decremented packet forwarded destination bridging firewalls visible network neighbor configuration visible traceroute debugging difficult layered security model cisco pix multiple layers security networks organized strict linear order network secure previous secure networks access secure networks secure networks access higher networks configured conduits layered security model easy implement internal firewalls difficult implement security models layered conduit firewall firewall deployment scenarios screening router screening router bastion host screened subnet dmz internal firewalls host-based firewalls multiple variations screening router screening router bastion host screened subnet dmz internal firewalls gaining popularity larger organizations safe assume bad guys prevent accidents isolate damage apply security policies 
weighted pushdown systems application interprocedural dataflow analysisa thomas repsa stefan schwoona somesh jhaa comp sci dept wisconsin reps jha wisc fakult inf universit stuttgart schwoosn informatik uni-stuttgart abstract recently pushdown systems pdss extended weighted pdss transition labeled goal determine meet-over-allpaths paths meet criterion paper shows weighted pdss yield algorithms classes interprocedural dataflow-analysis problems introduction paper explores connection interprocedural dataflow analysis model checking pushdown systems pdss connections dataflow analysis model checking established past work exception past work shed light relationship model checking bit-vector dataflow-analysis problems live-variable analysis partial-redundancy elimination contrast results presented paper apply bit-vector problems non-bit-vector problem addressed iii dataflow-analysis problems expressed bit-vector problems linear constant propagation general approach applied distributive dataflow-analysis problem domain transfer functions infinite descending chains safe solutions obtained problems monotonic distributive paper makes recent result extends pdss weighted pdss transition labeled goal determine meetover-all-paths paths meet criterion paper shows weighted pdss yield algorithms classes interprocedural dataflowanalysis problems ideas illustrated application weighted pdss linear constant propagation contributions paper summarized conventional dataflow-analysis algorithms merge values states program point states calling context dataflow-analysis algorithm obtained weighted pdss dataflow queries posed respect regular language stack configurations conventional merged dataflow information obtained issuing queries approach strictly richer framework interprocedural dataflow analysis provided conventional interprocedural dataflowanalysis algorithms algorithm solving path problems weighted pdss provide witness set paths provide explanation answer dataflow query reported algorithms paper implemented library solves reachability problems weighted pdss library create prototype implementations context-sensitive interprocedural dataflow-analysis algorithms linear constant propagation detection affine relationships supported onr contract library internet parties creation dataflow-analysis tools remainder paper organized section introduces terminology notation paper defines gpr framework section presents algorithm solving gpr problems section presents contribution paper application gpr framework interprocedural dataflow analysis section discusses related work appendix describes enhancement algorithm section generate witness set answer gpr problem terminology notation section introduce terminology notation paper pushdown systems pushdown system transition system states involve stack unbounded length definition pushdown system triple finite sets called control locations stack alphabet configuration pair finite number rules form define transition relation configurations write express exists rule omit index understood reflexive transitive closure denoted set configurations define sets configurations reachable backwards forwards elements transition relation loss generality assume henceforth restrictive pushdown system simulated obeys restriction larger constant factor pushdown systems infinitely configurations symbolic means represent sets configurations finite automata purpose definition pushdown system -automaton quintuple finite set states set transitions final states initial states control locations configuration accepted ifa final state set configurations regular recognized -automaton frequently omit prefix simply refer automata understood convenient property regular sets configurations closed forwards backwards reachability words automaton accepts set construct automata accept general idea algorithm pushdown system automaton accepting set configurations loss generality assume transition leading initial state obtained language automaton derived saturation procedure procedure adds transitions rule current automaton add transition efficient implementation procedure requires time space procedure implementation presented constructing -automaton accepts section develop generalizations procedures present extensions basic idea applies omitted lack space weighted pushdown systems weighted pushdown system pushdown system rules values domain weights weight domains interest bounded idempotent semirings defined definition definition bounded idempotent semiring quintuple set elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring function assigns rule sequence rules associate define configurations denote set rule sequences transform definition weighted pushdown systema wherea regular set generalized pushdown reachability gpr problem find witness set paths notice extender operation calculate path set paths computed combiner operation general fora finite set paths values minimal elements minimal respect partial order defined definition solving generalized pushdown reachability problem section presents algorithm solving gpr problems entire section denote fixed weighted pushdown system denote fixed regular set configurations represented -automaton transition leading initial state gpr problem multi-target meet-over-all-paths problem graph vertices graph configurations edges defined transition relation target vertices vertices graph set target vertices infinite built-in structure regular set gpr problem concerns infinite graphs infinite set paths differs work meet-over-all-paths problems ordinary pushdown-reachability problem infinite nature gpr problem addressed reporting answer indirect fashion form annotated automaton answer automaton annotations identical automaton created algorithm values read annotations accepting paths automaton values algorithm presented stages define language characterizes sequences transitions made pushdown system automaton turn weighted pushdown systems gpr problem language characterizations transition sequences previously results kind grammar problem obtain solution gpr problem solution based grammars inefficient improve performance specialize computation case ending algorithm creating annotated automaton similar thea algorithm languages characterize transition sequences section make definitions aid reasoning set paths lead configuration configurations regular set call set reachability witnesses fora respect reachabilitywitnessesa convenient pds anda -automatona combined sequence create combined pds call states rules ofa augmented rule transition transition set configuration accepted path configuration note transitions leading initial states behavior accepting run divided phases transitions mimics transitions mimics reaches state perform sequence pops possibly reaching state run reach state terms features original phase corresponds automaton accepting configuration reached starting configuration words accepts configuration iff language define characterizes pop sequences pop sequence sequence transitions starts configuration ends configuration iii transition sequence stack form non-empty sequence step stack shrinks remains unchanged pop sequence pop sequences canonical form start configuration end configuration pop sequences characterized complete derivation trees derived nonterminal psa grammar shown figure production psa psa psa fig context-free language pop sequences rules correspond production theorem pds pop sequence iff nonterminal psa grammar shown figure complete derivation tree derivation tree root psa preorder listing derivation tree production instances figure defines correspondence productions pds rules sequence rules pop sequence sequence rules derivation tree root psa proof sketch shrink stack removing stack symbol left-hand side rule transition sequence removes symbols stack component rule right-hand side words pop sequence left-hand-side stack symbol involve pop sequence right-hand-side stack symbol left-hand right-hand sides productions figure reflect popsequence obligations incurred rule capture set reachabilitywitnessesa recognized automaton define context-free language set productions acceptinga psa psa psa accepteda acceptinga language captures ways pds accept set reachability witnesses corresponds complete derivation trees derivable nonterminal accepteda subtree rooted psa pop 
selected servers areas operation internal firewalls separate internal operations isolated network purchasing accounts payable parts organization relationships groups groups competitors require isolation host-based firewalls typically implemented part visible network internal bridge typically provide packet-filtering provide logging packet capture facilities host-based firewalls pros provide additional line defense narrow perimeter network segment single host diversity firewall implementation cover errors gaps firewall implementation diversity security policy expression cover errors gaps expressing security policy restating policy firewall configuration language host-based firewalls cons host compromised local firewall users access host services host access points relies code base rest library bugs impact firewall host-based firewalls cons complexity managing per-host configurations tens hundreds thousands automated depending site related technologies network address translation virtual private networks active defenses network address translation specialized proxy rewrites addresses ports map private addresses public addresses conserve address space rfc virtual servers load balancing network address translation protects unmapped inside addresses visible addresses network address translation implemented home broadband routers address broadband network multiple computers addresses inside home network limited capability inside addresses ports expose network address translation network address translation virtual private networks vpns tunnel traffic host network host network encapsulate ssh includes encryption authentication block external traffic public services vpn traffic internal services virtual private networks vpns danger vpn traffic bypasses firewall vpn traffic bypass firewall systems home incorrectly route vpn lower inside security standard home systems patched active defenses intrusion detection systems respond observed traffic generate spontaneous fin kill bad tcp session generate feedback firewall block traffic bad sites requires well-tuned ids active monitoring staff avoid mitigate false positives real world experience firewall home firewalls border firewall trip curb stub toe kick rules complex curb taller solid screening packet filtering firewall statefull openbsd bridging firewall border firewall input rules default block problem ports block unneeded services potential problems nfs rpc netbios block forged malformed packets inbound src address inbound unroutable src addresses border firewall input rules enforce policies smtp mail gateways virus scanning web servers inbound packets established connections sessions statefull block traffic special networks border firewall output rules block forged malformed packets outbound src address block traffic special networks border firewall steps switch default deny analysis tools firewalls un-patched experimental network reach networks send receive inside crash-and-burn network reach networks services restricted firewalls wireless laptop network dns authenticated install network csl installing computers isolated internet prevent attacks installation patching complete home firewalls strongly advised high-speed internet connection dsl cable modem simple nat packet filtering appliances netgear linksys build linux openbsd firewall strengths inexpensive deploy easy understand idea maps simple business requirements inside identifiable security point limits exposure firewall strengths weaknesses find good firewall implementations firewall weaknesses interferes internet protocols designed work interrupt service delay introducing services ignores internal threats entry points firewall weaknesses complicated manage complicated environments kind tunneling vpn ssh bypass firewall potential false sense security summary firewalls effective tool understand limitations review configuration policy regular basis internal firewalls gaining hold security tools complete security policy questions 
sequence performs consume symbol reachability witnesses complete derivation trees root accepteda weighted pdss abstract grammar problems turning weighted pdss weighted version denoted weighted pds combined rule derivation tree complete terminal symbol leaf added due transition transition set assigned weight reason semiring sums weights paths characterized context-free grammars defined concept definition semilattice abstract grammar collection context-free grammar productions productiona form parentheses commas production terminal symbols productiona functiona string terminal symbols derived grammar yield complete derivation tree denotes composition functions corresponds unique ina call simply whena understood leta denote strings terminals derivable nonterminal abstract grammar problem compute nonterminal complete derivation trees root accepteda encode transition sequences accepts cast gpr grammar problem attach production functions productions rule sequence derivation tree yield havea figure note functionsa anda place beginning semiring-product expression corresponds preorder listing derivation tree production instances theorem production accepting fora anda accepted accepting fig abstract grammar problem gpr problem solve gpr problem appeal theorem theorem abstract grammar problem solved iterative computation finds maximum fixed point conditions hold semilattice infinite descending chains production functiona ina distributive arbitrary non-empty finite index sets production functiona ina strict argument abstract grammar problem figure meets conditions theorem definition operator associative commutative idempotent semilattice definition infinite descending chains distributivity production functions arbitrary non-empty finite index sets repeated application definition production functionsa strict argument annihilator respect definition production functionsa anda constants functions arguments meet required condition trivially algorithm solving gpr problem weighted pds initial configuration regular set represented automaton create combined weighted pds define abstract grammar problem schema shown figure solve abstract grammar problem finding maximum fixed point chaotic iteration nonterminal fixed-point-finding algorithm maintains current estimate maximum fixed-point solution initially values set updated right-hand side production left-hand-side nonterminal efficient algorithm gpr problem approach previous section efficient configuration takes time space create grammar productions figure left-hand-side nonterminal acceptinga improve algorithm previous section instantiations productions listed figure relevant final solution prevent algorithm exploring useless nonterminals grammar shown figure gpr questions respect target-configuration set involve subgrammar nonterminals ordinary pushdownreachability problem information complete derivation tree root nonterminal psa exists psa productive nonterminal precomputed returned form annotated automaton size exploring subgrammar lazily saves construct entire subgrammar productive nonterminals represent automaton transitions productions involve transition constructed on-the-fly algorithm shown figure straightforward algorithm solves grammar problem subgrammar figure set transitions algorithm input weighted pushdown system -automaton accepts transitions states output -automaton accepts function maps ofa psa abstract grammar problem defined figure procedure update begin changed end select remove transition return fig on-the-fly algorithm solving grammar problem subgrammar figure nonterminals updated considered line values set function call updatea computes transition created rule transitions ordered list lines process rules types lines represent fixed-point-finding loop line simulate processing rules types involve transitiona right-hand side line corresponds invocations production functionsa anda note line change smaller iterations continue values transitions stabilize empty fact algorithm simply expressing grammar problem subgrammar algorithm terminates computes desired result operations algorithm remarkably similar algorithm major difference transitions stored workset processed multiple times transition processed time complexity increases complexity unweighted case factor length maximal-length descending chain semiring annotated automaton configuration read automaton paths accepted accumulating path taking meet resulting set value-accumulation step performed straightforward extension standard algorithm simulating nfa algorithm algorithm determininga appendix describes extend algorithm additional annotations transitions path set obtained applications interprocedural dataflow analysis section describes application weighted pdss interprocedural dataflow analysis shows algorithm section generalize previously frameworks interprocedural dataflow analysis running section illustrates application approach linear constant propagation balakrishnan approach implement interprocedural dataflow-analysis algorithm due uller-olm seidl determines program point set affine relations hold program variables executed interprocedural dataflow analysis supergraphs exploded supergraphs interprocedural dataflow-analysis problems defined terms program supergraph shown figure supergraph consists int void main return void return emain call ret xmain call ret call ret fig program fragment supergraph environment transformer unlabeled edges collection control-flow graphs procedure represents program main procedure flowgraph procedure unique enter node denoted unique exit node denoted nodes flowgraph represent statements conditions program usual procedure call program represented supergraph nodes call node return-site node node-pairs figure addition ordinary intraprocedural edges connect nodes individual control-flow graphs procedure call represented call node return-site node supergraph edges intraprocedural call-to-return-site edge interprocedural call-to-enter edge enter node called procedure interprocedural exit-to-return-site edge exit node called procedure definition path length nodea node possibly empty sequence edges denoted source isa target target edge source edge path concatenation denoted notion interprocedurally valid path capture idea paths supergraph represent potential execution paths valid path respects fact procedure returns site recent call distinguish same-level valid path path starts ends procedure call return vice versa valid path path include unmatched calls definition sets same-level valid paths valid paths supergraph defined inductively empty path same-level valid path valid path path valid path exit-to-return-site edge valid path exit-to-return-site edge same-level valid path valid path source node call node matches return-site node target path same-level valid path ifa same-level valid path supergraph shown figure path same-level valid path path non-same-level valid path call-to-start edge matching exit-to-return-site edge path valid path exit-to-return-site edge correspond preceding call-to-start edge context-sensitive interprocedural dataflow analysis analysis called procedure sensitive context called context-sensitive nodes flowgraph represent individual statements conditions alternatively represent basic blocks analysis captures fact calls procedure arrive calling contexts sets execution states arise entry procedure precisely goal context-sensitive analysis find nodes supergraph remainder section considers interprocedural distributive environment ide framework context-sensitive interprocedural dataflow analysis applies problems dataflow information program point represented finite environment mapping finite set symbols finite-height domain values effect program operation captured environmenttransformer function supergraph edge transformer functions assumed distribute meet operation environments ide problems decidable variants constant-propagation problem copy-constant propagation linear-constant propagation interprets assignment statements form interprets statements form means explosion transformation ide problem transformed path problem program supergraph path problem graph larger edge labeled simpler edge function so-called micro-function micro-function edge captures effect symbol argument environment symbol result environment figure shows exploded representations environment-transformer functions linear constant propagation figure fig exploded representations environment-transformer functions linear constant propagation shows identity function represented figure figure show representations functions dataflow functions assignment statements vertices represent effects function independent argument environment graph includes edge form 
labeled edges needed capture function composition properly figure shows exploded supergraph corresponds program figure linear constant-propagation problem exploded supergraphs weighted pdss show solve linear constant-propagation problems context-sensitive fashion defining generalized pushdown reachability problem paths infinite-state transition system correspond valid paths exploded supergraph encode exploded supergraph weighted pds weights drawn semiring set set functions anda emain call xmain ret ret ret call call fig exploded supergraph program figure linear constantpropagation problem micro-functions function represented triple component needed meet functions represented details semiring semiring identity function representation denote identity function convention constant function represented operations defined assumed case combiner operator obtained equating terms taking solution provided integral control locations correspond program variables stack symbols correspond nodes supergraph exception edge exploded supergraph corresponds rule weighted pds encoding terms kinds edges occur supergraph weighted pds rules exploded intraprocedural edges intraprocedural edges main intraprocedural edges rule component tuple implies active procedure rest stack changed call site pds rule encodes edge exploded representation call-to-enter edge stack symbols right-hand side symbol return-site node pushed stack transitions call site transitions call site transitions call site process returning encoded popping topmost stack symbols stack transitions return obtaining dataflow information exploded supergraph weighted pds linear constant propagation interested generalized reachability problem configuration obtain dataflow information exploded supergraph weighted pds perform steps define regular language configurations interest creating automaton giving edge automaton weight apply algorithm create weighted automaton inspect -automaton find transition return weight transition answer write regular expression set configurations language stack contents defined bya query semiring configuration means program variable entered stack form main called called recursively arbitrary number times alternating recursive call sites witness-path set configuration singleton set consisting path semiring configuration rule rule weight configuration accepted query automaton situation stack form main calls calls finally calls case stack expected query semiring configuration case witness-path set configuration singleton set consisting path semiring configuration rule rule weight configuration accepted query automaton notice witness-path set configuration complicated case query case query involves regular operator conventional dataflow-analysis algorithms merge meet values program point calling context machinery paper strict generalization conventional dataflow analysis merged information obtained issuing query instance algorithms obtain tuple obtained query perform query semiring configuration means program variable entered stack form situation witnesspath set configuration consists paths share configurations semiring semiring configuration rule rule weight configuration accepted query automaton configuration accepted query automaton complexity dataflow-analysis algorithm denote number edges supergraph denote number symbols domain environment encoding exploded supergraph pds leads pds control locations rules regular language configurations interest assume encoded weighted automaton states transitions denote maximal length descending chain semiring formed micro-functions cost query obtain dataflow information worse time space results section clients dataflow analysis advantage machinery algorithm construction provide algorithm interprocedural dataflow analysis demonstrated examples weighted-pds machinery dataflow queries posed respect regular language initial stack configurations strict generalization kind queries posed ordinary interprocedural dataflow-analysis algorithms clients interprocedural dataflow analysis program optimizers tools program understanding offers ability provide features previously unavailable program optimizer make query dataflow values pattern inline expansions optimizer determine performing explicit expansion inline expansion produce favorable dataflow values code optimized tool program understanding users pose queries dataflow information respect regular language initial stack configurations possibilities illustrated figure shows transformed version program figure transformed program takes advantage information obtained figure entered stack form transformed program calls mimic calling pattern original program replaced calls copy inlined simplified recursive call site calling pattern fails mimic original procedure called related work connections dataflow analysis model checking established past work present paper continues line inquiry makes contributions previous work addressed relationship model checking bit-vector dataflow-analysis problems live-variable analysis partial-redundancy elimination paper show technique inspired developed model-checking community generalized original form applied dataflow-analysis problems expressed bit-vector problems previous work temporal-logic expressions dataflow-analysis problems paper results based basic model-checking primitive approach extends ideas illustrated applying linear constant propagation expressible bit-vector problem int void main return void return void inlined call end inlined call return fig transformed version program figure takes advantage fact figure entered stack form bouajjani esparza toulli independently developed similar framework queries pushdown systems weights drawn semiring solve overapproximations reachability questions concurrent communicating pushdown systems method obtaining weights automaton transitions significantly differs deriving weights directly obtained fixpoint computation matrix entries transitions automaton obtain weights semiring infinite descending chains provided extender operator commutative leads efficient solution finite-chain case case terms section algorithm time complexity proportional semirings finite descending chains algorithm applies cases efficient solution closely related papers dataflow-analysis literature address demand-driven interprocedural dataflow analysis reps presented algorithms solve demand versions interprocedural analysis problems obtained automatically exhaustive counterparts expressed logic programs making magicsets transformation general transformation developed logicprogramming deductive-database communities creating efficient demand versions bottom-up logic programs tabulation method efficiently evaluating recursive queries deductive databases approach obtain demand algorithms interprocedural bit-vector problems subsequent work reps horwitz sagiv extended logic-programming approach class ifds problems gave explicit demand algorithm ifds problems rely magic-sets transformation exhaustive demand algorithms solving class ide problems presented relationship algorithms paper similar relationship exhaustive demand algorithms ifds problems fourth approach obtaining demand versions interprocedural dataflowanalysis algorithms investigated duesterwald gupta soffa approach query collection dataflow equations set flow graph edges reversed flow functions reverse graph approximate inverses forward flow functions equations solved demand-driven fixed-point-finding procedure demand algorithms support ability answer query respect user-supplied language stack configurations previous work dataflow analysis algorithms merge meet values program point calling context addition past work demanddriven dataflow analysis examined issue providing witness set paths show answer dataflow query configuration reported ifds framework extended ability answer query respect language stack configurations applying reachability algorithms unweighted pdss graphs approach work general ide framework paper shown extend ide framework answer query respect language stack configurations recent generalization pds reachability algorithms weighted pdss noted algorithms algorithm solving gpr problems section guaranteed terminate ide problems algorithms terminate problems problems general problems set micro-functions infinite descending chains asymptotic cost algorithm paper cost demand algorithm solving ide problems algorithm strictly general algorithm presented application theory pdss interprocedural dataflow analysis proposed esparza knoop considered bit-vector problems faint-variables problem ifds problem appendix problems solved certaina anda queries respect work extension pdss weighted pdss approach solve 
general class dataflow-analysis problems esparza knoop techniques handle witness-set generation algorithm extend algorithms esparza knoop bit-vector problems flow-graph systems parallelism addressed uller-olm seidl interprocedural dataflow-analysis algorithm determines program point set affine relations hold program variables executed method re-cast solving logic-programming terminology exhaustive algorithm straightforward implementation logic program demand algorithm obtained applying magic-sets transformation gpr problem asymptotic complexity balakrishnan created prototype implementation method wpds library model checking pdss previously verifying security properties programs methods paper permit powerful security-verification algorithms developed weighted pdss obtain broader class interprocedural dataflow information verification process acknowledgments seidl making aho sethi ullman compilers principles techniques tools addisonwesley bancilhon maier sagiv ullman magic sets strange ways implement logic programs proceedings acm symposium principles database systems york acm press bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur volume lec notes comp sci pages springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures proc symp princ prog lang pages chen wagner mops infrastructure examining security properties software conf comp commun sec november cousot cousot temporal abstract interpretation symp princ prog lang pages duesterwald gupta soffa demand-driven computation interprocedural data flow symp princ prog lang pages york acm press esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proc computer-aided verif volume lec notes comp sci pages july esparza knoop automata-theoretic approach interprocedural data-flow analysis proceedings fossacs volume lncs pages springer esparza cera schwoon model-checking ltl regular valuations pushdown systems proceedings tacas volume lncs pages springer horwitz reps sagiv demand interprocedural dataflow analysis proceedings acm sigsoft symposium foundations software engineering pages york october acm press jensen metayer thorn verification control flow based security properties ieee symposium security privacy jha reps analysis spki sdsi certificates model checking ieee comp sec found workshop csfw ieee computer society press knoop steffen interprocedural coincidence theorem int conf comp construct pages moencke wilhelm grammar flow analysis alblas melichar editors attribute grammars applications systems volume lec notes comp sci pages prague czechoslovakia june springer-verlag uller-olm seidl computing interprocedurally valid relations affine programs tech rep comp sci dept univ trier trier ger january ramalingam bounded incremental computation volume lec notes comp sci springer-verlag reps demand interprocedural program analysis logic databases ramakrishnan editor applications logic databases kluwer academic publishers reps solving demand versions interprocedural analysis problems fritzson editor proceedings international conference compiler construction volume lec notes comp sci pages edinburgh scotland april springer-verlag reps horwitz sagiv precise interprocedural dataflow analysis graph reachability symp princ prog lang pages york acm press reps sagiv horwitz interprocedural dataflow analysis graph reachability tech rep datalogisk institut univ copenhagen http wisc wpis papers diku-tr sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci schmidt data-flow analysis model checking abstract interpretations symp princ prog lang pages york january acm press schwoon wpds library weighted pushdown systems http tum schwoon moped wpds schwoon jha reps stubblebine generalized authorization problems comp sec found workshop wash ieee comp soc sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs steffen data flow analysis model checking int conf theor aspects comp softw volume lec notes comp sci pages springer-verlag steffen generating data flow analysis algorithms modal specifications sci comp prog warren memoing logic programs communications acm march generation witness sets section efficient algorithm determining section addresses question obtaina problem examining infinite graph nodes pairs configuration edge labeled configuration finding means identifying set paths path leads words proves computed algorithm note properties general larger situation paths values single path small witness set paths set witness set indirectly form annotation called transitions data structures called wnode wstruc transition holds wnode denote entity wnode set wstruc items wstruc item form back rule algorithm procedure update begin return create create end fig modified update procedure sequence wnodes indicating missing extend algorithm idea execution item ina denotes suppose accepting path starting witha configuration accepted path pushdown system path family paths path starts accepting path successor configuration constructed replacing transitions wnodes concrete modifications algorithm line set line create wnode set figure shows revised update procedure line figure computes newly discovered transition line records path discovered line update change line addition strictly smaller path path incomparable line creates set consisting previous paths path incomparable approximate elements procedure minimize shown removes fairly straightforward information contained reconstruction witness set involving wnode created execution wnodes created earlier process reconstructing witness set decoding wnode wstruc information eventually terminate configuration execution modified algorithm wnodes transitiona created referenced moment wnodes referenced transitions garbage collector track remove nodes longer chain transition 
intro networking insufficiently paranoid mihai christodorescu spring mihai wisc original slides jonathon giffin march mihai christodorescu spring internet attack defenses makes communication easier faster makes attacks easier faster today topics short introduction networking network-level attacks network-level defenses march mihai christodorescu spring switched networks nodes connected link networks connected nodes network defined recursively march mihai christodorescu spring layering motivation abstractions hide complexity abstraction naturally lead layering alternative abstractions layer request reply channel message stream channel application programs hardware host-to-host connectivity march mihai christodorescu spring -layer architecture early inter-networks result gluing dissimilar networks international standards organization model describing interconnect networks open systems interconnect application presentation session transport end host network data link physical march mihai christodorescu spring physical layer raw bits communications link examples ethernet electrical connector wireless ieeea cable modem dsl application presentation session transport end host network data link physical ethernet card cable vendor-specific apis software hardware march mihai christodorescu spring data link layer frames data device directly-attached device ethernet frames collision detection flow control discovery devices application presentation session transport end host network data link physical frames cable modem payload frame preamble framecrc ethernet address multi-hop single-hop march mihai christodorescu spring network layer packets delivered multiple hops addressed globally-unique aggregatable address routed hop application presentation session transport end host network data link physical payload ipheader typical ipv address packet web server computer reliable effort march mihai christodorescu spring transport layer end-to-end in-order delivery copy message tcp retransmits lost packets tcp holds received packets requested application udp examples tcp udp application presentation session transport end host network data link physical tcp payload packet web server computer tcp header connection message march mihai christodorescu spring session layer initiates monitors sessions translates host names host addresses allocates ports sockets application presentation session transport end host network data link physical user kernel march mihai christodorescu spring presentation layer translates standard network data representation local handles encryption compression osspecific transmogrifications application presentation session transport end host network data link physical app library march mihai christodorescu spring application layer requestor network service examples bittorrent ftp firefox sims online quake aim sendmail application presentation session transport end host network data link physical march mihai christodorescu spring typical routed delivery path application presentation session transport end host nodes network network data link physical network data link physical network data link physical application presentation session transport end host network data link physical logical messages control messages march mihai christodorescu spring packet header connectionless datagram-based best-effort delivery unreliable service packets lost packets delivered order duplicate copies packet delivered packets delayed long time datagram format version hlen tos length ident flags offset ttl protocol checksum sourceaddr destinationaddr options variable pad variable data march mihai christodorescu spring application process write bytes tcp send buffer segment segment segment transmit segments application process read bytes tcp receive buffer tcp overview byte-stream app writes bytes tcp sends segments app reads bytes march mihai christodorescu spring tcp protocol header connection oriented reliable delivery flow control sender overrunning receiver congestion control sender overrunning network options variable data checksum srcport dstport hdrlen flags urgptr advertisedwindow sequencenum acknowledgment march mihai christodorescu spring normal connection establishment server sets retransmission timers allocates receive buffers imagine web server handle connections process fails timeout occurs seconds freeing resources note syn packets small bandwidth graphics http grc dos drdos htm march mihai christodorescu spring connected waiting connection connected closed listen syn rcvd syn established close wait ackclosing time wait fin wait fin wait passive open close send syn syn syn ack syn ack ack syn syn ack ack close fin fin ackclose fin fin acka timeout segment lifetimes fin ack ack ack ack close fin close closed active open syn state transition diagram tcp handshake closing connection march mihai christodorescu spring attack syn flood syn creates half-open connection half-open connections minutes time-out servers finite connection tables perpetrator easily caught source sourceip spoofed cert advisory ca- http cert advisories ca- html syn packets fits kbps graphics http grc dos drdos htm march mihai christodorescu spring spoofed address syn ack delivered fake spoofed address attacker doesn doesn care backscatter graphics http grc dos drdos htm march mihai christodorescu spring syn flood attacks february victims included cnn ebay yahoo amazon attackers allegedly simple readily tools script-kiddies law enforcement unable unwilling under-age perpetrators blanket immunity october root dns servers servers brought march mihai christodorescu spring march mihai christodorescu spring attack distributed dos filling connection table fill bandwidth infect innocent bystanders zombies zombies listen irc channel attack command simply attack attacker high bandwidth connection typical program evilgoat evilbot graphics http grc dos drdos htm march mihai christodorescu spring distributed dos attack attacks days attack lasted hours infected windows zombies billion malicious packets graphics http grc dos grcdos htm legitimate throughput time march mihai christodorescu spring flood-based distributed dos attacks coordinate zombies attack big packets last-hop bandwidth last-hop router discards packets indiscriminately zombies spoof addresses graphics http grc dos drdos htm march mihai christodorescu spring recent twist reflection routers accept connections port border gateway protocol big server port listens work send syn server claiming victim server send syn ack victim re-transmit times giving typically march mihai christodorescu spring reflection mechanism graphics http grc dos drdos htm march mihai christodorescu spring mounting ddos attack build base attack bots trigger bots attack exploration network mapping remote identification remote service identification gain root access vulnerable box exploit remote root vulnerability exploit remote non-root vulnerability local root vulnerability installing irc bot launching ddos attack march mihai christodorescu spring exploration port scanning find machines active services listening ports open ports reveals running machines reveals vulnerable services nmap http insecure nmap portscans fingerprinting graphic grc march mihai christodorescu spring port scanning locate exploitable machines horizontal scan scan port multiple machines idea attacker exploit service cecil wisc open bobby wisc closed ross wisc closed joyce wisc open ssh port march mihai christodorescu spring port scanning locate exploitable service vertical scan scan multiple ports single machine idea vulnerable service specific box foundry wisc tcp open telnet tcp filtered smtp tcp filtered sunrpc tcp filtered printer march mihai 
christodorescu spring half-open syn scan open port closed port rst graphics grc march mihai christodorescu spring stealth scans attempt avoid server logging send invalid tcp packets synfin scan xmas scan fin scan windows susceptible scan network stack broken surprise null scan march mihai christodorescu spring closed listen syn rcvd syn established close wait ackclosing time wait fin wait fin wait passive open close send syn syn syn ack syn ack ack syn syn ack ack close fin fin ackclose fin fin acka timeout segment lifetimes fin ack ack ack ack close fin close closed active open syn stealth scans march mihai christodorescu spring ident scans identify services running root crash wisc port state service owner tcp open telnet root tcp open smtp root tcp open finger root tcp open http apache tcp open sunrpc rpc tcp open auth march mihai christodorescu spring fingerprinting identification operating system running remote machine kernels perform differently tcp options initial sequence number icmp error messages fragment overlap openbsd solaris march mihai christodorescu spring mounting ddos attack build base attack bots trigger bots attack exploration network mapping remote identification remote service identification gain root access vulnerable box exploit remote root vulnerability exploit remote non-root vulnerability local root vulnerability installing irc bot launching ddos attack march mihai christodorescu spring rooting box exploit vulnerability remote service result remote root shell exploits commonly posted online free download stay tuned details thursday march mihai christodorescu spring include stdio include windows include string int main void char eip char exploitcode xec xfa xfb xfc xfd xba xff xec xff xfc xfd xfe xfc xec xba xba xff xfc file printf printf winhlpadd exploits buffer overrun winhlp exe printf version runs service pack machines printf assumes msvcrt dll version printf printf david litchfield mnemonix globalnet printf fopen wordpad cnt remainder code omitted march mihai christodorescu spring root box scp evil attacker net trojan gcc bin gcc useradd blackhat passwd echo apache html index html install spam zombie store mpeg files disk space march mihai christodorescu spring attacker uploads irc bot builds bot network bot process starts boots sends message private irc channel indicating active passively listens channel attack command graphic grc march mihai christodorescu spring march mihai christodorescu spring mounting ddos attack build base attack bots trigger bots attack exploration network mapping remote identification remote service identification gain root access vulnerable box exploit remote root vulnerability exploit remote non-root vulnerability local root vulnerability installing irc bot launching ddos attack march mihai christodorescu spring fire attacker notifies bot attack server bot begin traffic flood target graphic grc march mihai christodorescu spring result victim falls internet graphic grc march mihai christodorescu spring fun smurf attack traffic amplification requests broadcast subnet answered computers subnet traffic victim higher traffic attacker icmp echo reply src victim dst march mihai christodorescu spring fun land attack send tcp syn packet source destination addresses set destination machine destination machine freeze seconds replaying packet network collapse discovered years ago windows server vulnerable clients connected attacked server freeze windows vulnerable firewall disabled finally fixed windows vista march mihai christodorescu spring fun motivated attacker automated tools clean logs install method legitimately connect machine future bypass firewalls launch attacks inside network march mihai christodorescu spring installing trojan horses scp evil attacker net trojan gcc bin gcc inserts backdoor program compiles inserts backdoor-inserter recompiled login march mihai christodorescu spring march mihai christodorescu spring trojan internet explorer install trojan online updates delivered updates delivered trojaned control future updates bart miller idea march mihai christodorescu spring detection prevention exploration firewalls port scan detection exploit detection network intrusion detection host-based intrusion detection remote auditing remove vulnerabilities code audits code patching syn flood protection march mihai christodorescu spring firewalling application presentation session transport attacker nodes network network data link physical network data link physical network data link physical application presentation session transport victim network data link physical march mihai christodorescu spring classical port scan detection window schemes events time typically measure hits closed ports heuristics hits empty addresses problems classic detection approaches slow scan evade window-based schemes high traffic noise levels lead high false alarm rates legal recourse march mihai christodorescu spring network intrusion detection signature based approach alert administrators content matches exploit patterns low false alarm rate detect attacks fails encrypted channels operate network speed snort jfke aljk falj fadsjkldf fjkalsd flk fjk ekzkleizieqjn fjiellwq pzkj faj ueuuuu cgi-bin exe aaaaa zjkjef fjadsjkleklw alarm march mihai christodorescu spring network intrusion detection anomaly detection approach alert administrators traffic patterns deviate expected behavior high false alarm rate designed detect unknown attacks works encrypted channels expected observed traffic rate time sending rate host march mihai christodorescu spring host-based intrusion detection observation execution behavior process exploit monitor processes running machine detect deviation expected behavior intrusion march mihai christodorescu spring masquerade detection apply host-based intrusion detection ideas human users build statistical profiles user behavior detect deviations profile attacker masquerading user march mihai christodorescu spring remote auditing store audit logs locally intruder modify logs secure transmission update mechanism append-only log read logs occasionally march mihai christodorescu spring code audits manually review code discover vulnerabilities attackers openbsd change unsafe coding practices march mihai christodorescu spring aggressive patching vendors release patches vulnerabilities system date code red virus july infected machines year admin unpatched machine liable machine stepping stone march mihai christodorescu spring defense syn flood increase size connection table add servers trace attack back source isp filter malicious packets add firewall typically syn proxy partial solution syn-cookies reply syn syn-cookie allocate resources syn-cookie returned egress filtering restricts spoofed addresses march mihai christodorescu spring potential places stop flood graphics http grc dos drdos htm march mihai christodorescu spring detection isps egress filtering isps stop spoofed syn packets left home egress filtering isps prevent spoofed addresses traversing internet flagging multiply-tried failed syn acks discover victims filter attack march mihai christodorescu spring conclusions understand layers attack develop layered defense firewalls scan detection network intrusion detection host-based intrusion detection auditing march mihai christodorescu spring conclusions systems date history program developers choose run programs developers good track record preventing vulnerabilities choose 
run programs developers rapidly patch newly discovered vulnerabilities caution operating online security settings 
homework analysis software artifacts due date oct wednesday question review points question review speci cations class attended class easy part explain speci cation setup started setupustarted proposition setup models fact setup transaction proposition started denotes start transaction part explain speci cations afp part show model states efp true afp false model part state-machine model model afp true efp false justify answer part write ctl rtctl speci cations property transaction issued state cycles time-steps transaction issued assume atomic propositions issued issued transaction issued question smv points modify vending machine provided class multiple users model users speci cation add additional state waiting signi user waiting vending machine module description user users simply instantiations module users simultaneously waiting vending machine vending machine non-deterministically picks user indecisive user user change mind middle process depositing coins case vending machine return coins dispense drink speci cation express property ctl user waiting eventually drink mind middle checking smv check speci cation true speci cation true explain counter-example logistics start changing smv model write design document outline design strategy design document detailed show design document fellow student reviewer mention reviewer document design document consistent speci cation submit modi smv speci cation design document homework grade homework homework 
malicious code fun profit mihai christodorescu mihai wisc march march mihai christodorescu syn cookies cont syn cookies choices initial tcp sequence numbers tcp servers server sequence number client sequence number mod top bits max segment size bit port srv srv port march mihai christodorescu malicious code viruses worms trojans code breaks security policy characteristics attack vector payload spreading algorithm march mihai christodorescu outline attack vectors payloads spreading algorithms case studies march mihai christodorescu attack vectors social engineering make run vulnerability exploitation force system piggybacking make run programs run march mihai christodorescu social engineering suggest user executable game desirable picture movie important document security update microsoft security update department spoofing sender helps march mihai christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies march mihai christodorescu vulnerability exploitation make flaws software input handling sample techniques buffer overflow attacks format string attacks return-to-libc attacks sql injection attacks march mihai christodorescu basic principles buffer overflow occurs data stored past boundaries array string additional data overwrites nearby program variables result attacker controls takes running process buffer overflows march mihai christodorescu expected input hostname path buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return process request tux usr foo txt process request aaabbbcccdddeeefffggghhh bar bad march mihai christodorescu stack frame procedure call program stack buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request strcpy march mihai christodorescu stack frame procedure call program stack buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request strcpy march mihai christodorescu stack frame procedure call program stack buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request strcpy arg req march mihai christodorescu stack frame procedure call program stack buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request strcpy arg req return address frame pointer march mihai christodorescu stack frame procedure call program stack buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request strcpy arg req return address frame pointer local host march mihai christodorescu stack frame procedure call program stack buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request strcpy arg req return address frame pointer local pos local host march mihai christodorescu normal execution buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request arg req return address frame pointer local host local pos process request tux usr foo txt march mihai christodorescu normal execution buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request arg req return address frame pointer local host process request tux usr foo txt local pos tux march mihai christodorescu overflow execution buffer overflows void process request char req hostname char host int pos find char req strcpy host substr req pos return main process request arg req return address frame pointer local host process request bar local pos aaab bbcc cddd eeef ffgg iiij characters overwrite return address march mihai christodorescu attacker chance gain control craft input string return address overwritten pointer malicious code malicious code inside input string smashing stack buffer overflows malicious code create root shell executing bin march mihai christodorescu shell code arg code arg arg pointer buffer overflows code exec bin mov edx arg mov ecx arg mov ebx bin mov eax int pointer overwriting return address march mihai christodorescu defense stack-smashing attacks bounds-checking protection libraries non-executable stack setuid chroot avoid running programs root address randomization behavioral monitoring thicker armor buffer overflows march mihai christodorescu info smashing stack fun profit aleph stackguard rad pax aslr cert march mihai christodorescu format string attacks illegally control program values flaws design printf printf format strings march mihai christodorescu printf operation printf format strings foo printf format string ptr march mihai christodorescu attack read code printf str programmer meant printf str str format strings secret key ptr format string ptr march mihai christodorescu attack write address code printf str str format strings return address format string ptr march mihai christodorescu defenses printf format string formatguard format strings march mihai christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies march mihai christodorescu piggybacking malicious code injected benign program data file host file executable document executable content word documents macros march mihai christodorescu piggybacking executables modify program disk jmp evil code variations jump malicious code actions spread malicious code program march mihai christodorescu piggybacking documents documents macros microsoft office supports documents macros scripted visual basic vba macro triggered document open document close document save send document march mihai christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies defenses march mihai christodorescu payload target interesting data passwords financial data user behavior user attention keylogger screen scraper spyware adware march mihai christodorescu keylogger march mihai christodorescu screen scraper march mihai christodorescu payload ideas victim machines pawns larger attack botnets distributed denial service ddos spam proxies anonymous ftp sites irc servers march mihai christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies defenses march mihai christodorescu spreading methods depends attack vector email-based addresses vulnerability-based addresses hosts running vulnerable service piggybacking files infect march mihai christodorescu spreading malware internet html files cache windows address book outlook express folders outlook folders march mihai christodorescu vulnerable target discovery find internet addresses scanning target list passive contagion worms random sequential bandwidth-limited pre-generated externally-generated metaserver worms internal target list topological worms march mihai 
christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies march mihai christodorescu types malicious code virus self-replicating infects programs documents chernobyl cih melissa elkern worm self-replicating spreads network iloveyou code red agle witty mcgraw morrisett attacking malicious code report infosec research council sept oct march mihai christodorescu types malicious code trojan malware hidden inside programs noupdate killav bookmarker backdoor tool allowing unauthorized remote access backorifice sdbot subseven march mihai christodorescu types malicious code spyware secretly monitors system activity ispynow keyloggerpro adware monitors user activity advertising purposes wildtangent gator bargainbuddy march mihai christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies sobig march mihai christodorescu sobig worm mass-mailing network-aware worm multi-stage update capabilities launch deactivation sobig jan sobig sobig june sobig june july sobig june july sobig aug sept march mihai christodorescu e-mail network shares sobig attack vector big boss subject support microsoft combill microsoft comadmin support comsupport yahoo compressed executable attachment renamed extension attachment zip file march mihai christodorescu sobig payload geocities web page trojan web server stage backdoor lala keylogger stage proxy wingate march mihai christodorescu sobig payload hacked dsl cable hosts trojan web server march mihai christodorescu sobig spreading algorithm e-mail addresses extracted files disk network shares automatically discovered march mihai christodorescu sobig numbers august courtesy ssag abs march mihai christodorescu outline attack vectors social engineering vulnerability exploitation piggybacking payloads spreading algorithms case studies sobig blaster march mihai christodorescu blaster worm multi-stage worm exploiting windows vulnerability july august microsoft releases patch lsd research exploit released cert advisory blaster appears million hosts infected metasploit refined exploit frb atlanta dmv bmw scandinavian bank closes branches march mihai christodorescu blaster attack vector microsoft windows rpc dcom vulnerability coding flaw rpc service passes part request function getmachinename getmachinename copies machine fixed -byte buffer march mihai christodorescu blaster attack vector exploit tftp msblast exe tftp server msblast exe start msblast exe march mihai christodorescu blaster payload worm installs start automatically infected hosts perform ddos windowsupdate syn flood attack spoofed source aug dec months march mihai christodorescu blaster effect local host rpc dcom disabled inability cut paste inability move icons add remove programs list empty dll errors microsoft office programs generally slow unresponsive system performance march mihai christodorescu blaster spreading algorithm build address list chance start local address chance generate random address probe ips time exploit type windows windows march mihai christodorescu blaster infection rate march mihai christodorescu future threat superworm curious yellow coordinated worm design brandon wiley fast replication adaptability pre-scan network targets worm instances communicate coordinate infection process attack vectors updated worm code mutates march mihai christodorescu conclusions vulnerabilities left unpatched attackers sophisticated understand attackers perspective 
homework analysis software artifacts due date sept mon question review points give english description path operators modalities path quanti ers express operator quanti terms duality equations path operators path quanti ers question review points part classify formula ctl ctl ltl give short justi cation answer afp egq part path formula fuwg called weak true path remains true true false entire path express weak combination globally question modeling points express english descriptions ctl write negation formula provide english description part reach state faulty atomic proposition faulty true part transaction started denoted truth atomic proposition started nishes denoted truth atomic proposition nished things load nusmv web-site provided home page start examples provided nusmv distribution 
homework analysis software artifacts due date oct wednesday question review points question review speci cations class attended class easy part explain speci cation setup started setupustarted proposition setup models fact setup transaction proposition started denotes start transaction part explain speci cations afp part show model states efp true afp false model part state-machine model model afp true efp false justify answer part write ctl rtctl speci cations property transaction issued state cycles timesteps transaction issued assume atomic propositions issued issued transaction issued question smv points modify vending machine provided class multiple users model users speci cation add additional state waiting signi user waiting vending machine module description user users simply instantiations module users simultaneously waiting vending machine vending machine non-deterministically picks user indecisive user user change mind middle process depositing coins case vending machine return coins dispense drink speci cation express property ctl user waiting eventually drink mind middle checking nusmv check speci cation true speci cation true explain counter-example logistics start changing smv model write design document outline design strategy design document detailed show design document fellow student reviewer mention reviewer document design document consistent speci cation submit modi smv speci cation design document homework grade homework homework 
homework analysis software artifacts due date oct wed note homework teams students earlier homework start changing nusmv model write design document outline design strategy design document detailed show design document fellow student reviewer mention reviewers document design document consistent speci cation submit modi nusmv speci cation design document homework grading homework completing homework note base design nusmv provided homework design consistent start code base follow procedure question number question modeling points enhance speci cation part multiple priorities users levels priority high low assume users priority users priority round-robin scheduling policy users erent priorities waiting user higher priority machine part coins assume drink costs fty cents user deposits dimes quarters user vending machine deposited coins worth greater equal fty cents drink vending machine return spare change hints extra variable called amount-accrued discuss round-robin scheduling lectures track user deposited vending machine variable called amount-returned equal spare change gure values variables amount-accrued amount-returned arithmetic nusmv track amount-accrued amount-returned explicit transitions simulate addition amount-accrued twenty user deposits dime amount-accrued thirty step question modeling spin points explain mars path nder glitch detail construct toy model relevant portions mars path nder promela input language spin model check design speci cations absence priority inversion ltl speci cations documents provided usual write detailed design document 
homework due date november somesh jha computer sciences department wisconsin madison november question points part express relations figure relations class operators give short justi cation answer part cousinsfatherside cousinsmotherside cousins set cousins separated n-steps father side mother side father mother side write recursive expression relations express relations parameter terms relations parameter basic relations introduced fatherinlaw people males sisterinlaw people females firstcousinsfatherside people people firstcousinsmotherside people people firstcousins people people secondcousinsfatherside people people secondcousinsmotherside people people secondcousins people people figure relations class question points establish equations relations true justify answer enter equations ladybug play assume relations types note symbol denotes empty relation question points question write speci cation problem aim model library types persons books function issued books persons set library set books book issued person issued library represents set books library set books reserve set reserve set books operations issue book operation issues book person book reserve issued issued return book operation models act person returning book adding book library operations models book added library putting book reserve operations models book put reserve book issued put reserve taking book reserve operation models book reserve claims assertions alloy issuing book returning results state book reserve issued claim true operation part write mathematical description operations claims explain answer part write speci cation ladybug part express design alloy part based experience part compare ladybug alloy 
detecting manipulated remote call streams abstract internet mobile code ubiquitous includes examples browser plug-ins java applets document macros paper address important vulnerability mobile code security exists remote execution systems condor globus seti home systems schedule user jobs execution remote idle machines send important system calls back local machine execution evil process remote machine manipulate user job send destructive system calls back local machine developed techniques remotely detect manipulation job submitted remote execution construct model user binary program static analysis binary analysis applicable commodity remote execution systems applications remote job execution model checks system calls arriving local machine execution allowed continue model remains valid begin finite-state machine model accepts sequences system calls build optimizations model improve precision efficiency propose program transformations renaming null call insertion significant impact precision efficiency desirable side-effect techniques obfuscate program making harder adversary reverse engineer code implemented simulated remote execution environment demonstrate optimizations transformations binary program increase precision efficiency test programs unoptimized models increase run-time moderate levels optimization run-time increases precision gains reaching introduction code moves internet forms including browser plug-ins java applets document macros operating system updates device drivers remote execution systems condor globus seti home mobile code traditionally raises basic trust issues code imported machine perform malicious actions remotely running code execute malicious modification addressing important variant case safety code executes remotely makes frequent service requests back local machine figure case concerned remotely executing process subverted make malicious requests local machine popular condor remote scheduling system remote execution environment condor user submit job program possibly jobs condor run idle machines local environment machines scattered worldwide condor jobs execute compatible machine special privilege jobs send file-access critical system calls execute home machines home local machine acts remote procedure call rpc server remote job accepting remote call requests processing call context user local system type remote execution frequent interactions machines differs execution mobile agents remote job executes completion attempting contact report back local machine remote job subverted request local machine perform dangerous destructive actions system calls subverting remote job idea quickly easily tools paper describe techniques detect remote job making requests differ intended behavior jonathon giffin somesh jha barton miller computer sciences department wisconsin madison giffin jha bart wisc work supported part office naval research grant department energy grants de-fg de-fg lawrence livermore national lab grant nsf grant eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government addressing issue local host safety protecting remote job inappropriate access data detecting modification calculated result inappropriate remote system calls local machine accepts calls valid verifying remote job generated calls correct execution vulnerable maliciously generated calls conventional authentication methods secret data fail inherently risky environment attacker present remote code including authentication mechanism key manipulate code local machine distrust calls remotely executing code ability validate requests vulnerability exists thousands machines worldwide running condor globus java applets similar systems techniques address deficiency basic approach detecting malicious system call streams perform pre-execution static analysis binary program construct model representing remote call streams process generate process executes remotely local agent operates model incrementally ensuring call received remains model call fall set expected calls determined model remote process manipulated precise model closely mirror execution behavior application noticed specification program intended behavior host-based intrusion detection approach brings benefits intrusion detection systems direct operation binary code automated construction specifications elimination false alarms protection types attacks address important source vulnerabilities request verification cryptographic authentication mechanisms trusted program model representing sequences remote system calls valid previous model construction techniques include human specification dynamic analysis dynamic analyzer completes training runs multiple execution traces build probability distributions indicating likelihood call sequence false alarms occur training runs exercise program control flows static analysis produces non-probabilistic models representing control flow paths executable models conservative producing false alarms potentially accepting attack sequence valid models finite-state machines control flow graphs generated binary code analysis construct non-deterministic finitestate automaton push-down automaton mirror flow control executable automata natural structures represent sequences remote call names push-down automata precise develop optimizations increase precision maintaining run-time efficiency evaluate program models metrics precision efficiency precision measures tightly model fits application represents improving precision reduces opportunity attack accepted valid model efficiency rates runtime impact model operation evaluate techniques models built prototype static analyzer model builder simulated remote execution environment read binary programs sparc solaris machines produce model operation simulated local agent agent receives notifications application system calls encountered execution operates model models efficient non-deterministic finitestate automaton nfa models add run-times test applications precise nfa models optimizations invaluable moderate optimization levels improve precision keeping run-time overheads optimized push-down automaton models precise overheads low precision values optimized models approach indicating opportunity adversary begin attack strategies counter mobile code manipulation exploits generally orthogonal finds greatest security level incorporating components areas solution replication form byzantine agreement remote call accepted genuine majority replicated processes executing machines generate identical call figure remote execution system calls executed home local machine local agent local host remote host remote system calls application process verify results returned mobile agents techniques limited environment frequent system call interactions wide network obfuscation program transformed operationally equivalent difficult analyze applying variant techniques improve ability construct precise state machines hamper adversary ability understand semantics program popular recent years discount obfuscation based barak section discuss theoretical results directly apply context sandboxing running program environment harm dates back early days multics operating system project crisis maintains per-process permissions limit system access webos techniques considered variety sandboxing based strong analysis binary program construction verifying model support analysis paper makes contributions areas binary analysis target commodity computational grid environments availability source code analysis assumed analysis restricted source language techniques wide applicability model optimizations develop techniques increase precision finite-state machines generate limiting opportunities attacker exploit weakness model reduce number spurious control flows generated models dead automata removal automata inlining bounded stack model hybrid model argument recovery reduces opportunities exploit present linear time -reduction algorithm simplify non-deterministic state machines reduced model non-determinism obfuscatory benefits call sites program generate requests opens technique call site renaming great 
ability reduce non-determinism models uniquely naming call site program rewriting executable insert null calls dummy remote system calls points high non-determinism provide degree context sensitivity model call site renaming null call insertion additionally obfuscate code remote call stream binary rewriting obfuscation techniques likewise context-free language approximations general language generated execution trace program context-free push-down automaton finitestate machine includes run-time stack defines context-free language automata prohibitively expensive operate incrementally stack growth potentially consumes system resources stack abstractions over-approximate context-free language regular language push-down automata bounded run-time stack expensive operate require finite resources provide background condor system remote execution computational grid environment security exploits section section presents analysis techniques algorithmic fashion experimental results found section comparison previous work section related work found section conclude section descriptions areas continuing work threats remote execution common scenario important class remotely executing jobs require communication path back local machine originated job job sends critical system calls file access network communication back local machine execute context submitting user type remote execution occurs condor distributed scheduling system globus computational grid infrastructure java applets implementation research takes place context condor condor schedules jobs hosts originator organization machines belonging organizations addition scheduling remote jobs condor checkpoints migrates jobs reliability performance reasons job figure grid environment exploit lurker process attaches remote job inserting code takes control network link local agent application process local host remote host malicious remote calls lurker execute times hosts administrative domains condor prevalent execution environment scientific research year researchers condor solve -year-old unsolved combinatorial optimization problem called nug remote jobs ran processors united states italy administrative control program authors network path remote process originating host included public internet links malicious party access execution machines network links manipulated originating machine detail remote system calls condor simply variant remote procedure call rpc client stub library linked application program standard system call library stub functions library package parameters call message send message network submitting machine await result local agent submitting machine services calls unpacking request executing call packaging sending result back remote machine rpc model exposes submitting machine vulnerabilities vulnerabilities common characteristic malicious entity remote machine control job control remote system call stream malicious system call stream variety bad things submitting user simplest case malicious remote host host owner administrative privileges takes control remote job complex harder-to-track cases caused previous malicious remote jobs previously discovered vulnerability condor characteristic remote job executes typically run common low privilege user malicious user submit job forks creates process terminates child process remains running appears condor job terminated job scheduled run host lurking process detects newly arrived job dynamically attaches job takes control lurker generate malicious remote calls executed detriment machine originated innocent job figure similar results unusual attacks call stream crosses network secure machine network impersonate application process generating spoofed calls treated local host genuine imposter applets successfully impersonation attacks servers original applets communicate generating models static analysis start binary program submitted execution execution analyze program produce components checking agent modified application figure checking agent local agent incorporates model application agent receives remote system calls execution verifies authenticity call operating model execution continues model remains valid state modified application original program binary code rewritten improve model precision offering modicum obfuscation modified application executes remotely transmitting remote system calls checking agent models finite-state machines nondeterministic finite automata nfa push-down automata pda edge automaton labeled alphabet symbol identity remote system call automaton final states states operation automaton successfully cease ordered sequences symbols connected sequences edges entry state final state define language accepted automaton application language defined perfect model application precisely sequences remote system calls generated program correct execution arbitrary input construction automaton modeling application progresses stages control flow graph cfg built procedure binary cfg represents execution paths procedure figure static analyzer reads binary program produces local checking agent modified application executes remotely checking agent incorporates model application analyzer binary program checking agent modified application convert collection cfgs collection local automata local automaton models streams remote system calls generated single procedure compose automata points function calls internal application producing interprocedural automaton modeling application interprocedural automaton model incorporated checking agent figure shows language program writes string standard output main function translates sparc code figure compiled include code solely reader ease remainder section demonstrates analysis binary code compiler assembler produces source program binary code cfgs standard tool read binary code generate cfgs executable editing library eel abstract interface parse edit rewrite sparc binary executables eel builds objects representing binary analysis including cfg procedure call graph representing interprocedural calling structure program nodes cfg basic blocks linear sequences instructions edges blocks represent control main int argc char argv argc write argv line end write close line int write end int line close main save cmp ble main mov call write mov call line mov call end mov main nop main sethi dnone dnone call write mov call close mov main ret restore figure code code writes stdout command line argument text string argument provided sparc assembly code main show assembly code line end figure control flow graph main control transfers sparc code delay slot outgoing edges basic block labeled call block cfg entry save cmp ble mov call write mov call line mov call end mov nop ret restore cfg exit sethi dnone dnone call write mov call close mov close write write line end flow paths branches figure shows cfg main figure cfgs local automata procedure cfg construct nfa representing sequences calls procedure generate natural translation cfg nfa retains structure cfg labels outgoing edges basic block function call block call exists outgoing edges blocks function call labeled automaton mirrors points control flow divergence convergence cfg streams calls arise traversing flow paths formally convert control flow graph nfa set states input alphabet transition relation unique entry state set accepting states reduce space requirements nfa reduced minimized classical -reduction algorithm simultaneously determinizes automaton exponential process develop linear time reduction algorithm shown determinize automaton algorithm recognizes set states strongly connected component made -edges reachable consuming input symbol collapses single state resultant graph reduced automaton figure standard algorithms data structures reduction procedure runs linear 
time automaton minimization recognizes equivalent states equivalence sequences symbols accepted states identical states collapsed reducing size complexity automaton nlogn algorithm exists minimize deterministic automata easily abstracted nfa prototype version algorithm suitable nfa figure local automata local automata functions figure -reduction unique cfg entry line end main line close writeline close write write end gve call labeled fvv cfg exit call call labeled ste figure final nfa model automaton produced call site replacement -reduction performed dotted line represents path present original program accepted model abstract automaton directed graph -edges calculate strongly connected components graph states strongly connected component reach sequence -transitions states collapsed directed acyclic graph dag collapsed states remaining -edges connect strongly connected components non-edges originating state dag add copies originating states reaches sequence -edges remove -edges connect strongly connected components remove unreachable states edges graph line end main close write close write write local automata interprocedural automaton constructing interprocedural nfa extend notion single procedure nfa model model entire application local automata composed form global nfa call site replacement replace edge representing procedure call control flow automaton modeling callee common technique construct system dependence graphs wagner dean work edge representing called function control flows model function recursion handled function call call site replacement reintroduces -edges automaton reduced figure presents final automaton -reduction clarity replication automata call site replacement links multiple call sites procedure local automaton final state called automaton -edges returning call sites impossible paths exist control flow enter automaton call site return -edge figure behavior impossible actual program execution malicious user manipulating executing program edges model exploit applications thousands procedures thousands call sites imprecision addressed constructing interprocedural pda introduction impossible paths classical program analysis problem arising context insensitive analysis push-down automaton eliminates impossible paths additionally modeling state application run-time stack executing application follow impossible path return site location stored run-time stack pda context sensitive including model stack precisely mirror state running application interprocedural change construct local automata -edges added call site replacement identifier uniquely call edge return state figure -edge linking source function call edge entry state called automaton pushes return state identifier pda stack executing program pushes return address run-time stack -edges returning control flow callee pop identifier pda stack mirroring application pop return address run-time stack pop edge traversed identifier edge matches symbol top stack identifiers edges define matched sets edges return edges correspond entry edge traversed exiting called automaton pda tracks calling context impossible paths exist link local automata modified call site replacement formally interprocedural pda set states input alphabet stack alphabet transition relation unique entry state initial stack configuration set accepting states local nfa models add -edge source state call edge entry state called automaton add -edges final state called automaton back destination state call edge remove original call edge figure pda model -edges called automaton paired return edge edge traversed call initiation uniquely mark local automaton state target non-system call edge non-system call edge steps add -edge source state edge entry state destination automaton label -edge push identifier target call edge add -edge final state destination automaton target call edge label -edge pop identifier step delete original call edge line end main close write close write write pop pop pop push push cpush procedures pda program initially executed automaton denoted modeling function operating system transfers control start main pda viable model operational setting straightforward operation automaton run-time stack grow consumes system resources stack size infinite presence left recursion counter left recursion challenges wagner dean operate pda algorithm similar post algorithm context model checking push-down systems demonstrate algorithm prohibitively expensive addressing imprecision requires reasonable approach optimizations address sources imprecision imprecisions models arise impossible paths context insensitive analysis malicious argument manipulation develop optimizations target sources imprecision maintaining efficiency impossible paths discarding push-down automata viable requires impossible paths readdressed impossible paths arise final states automata spliced multiple call sites -return edges introduce divergent control flow divergence exists application developed nfa model optimizations reduce effect return edges paths model dead automata removal aleaf automaton local automaton function call edges leaf automaton remote system call edges dead models control flow interest local automaton call edge dead leaf replace call edge -edge continues recursively backward call chain eliminate impossible paths introduced linking dead automaton insert dependency calculation step prior call site replacement automata inlining recall call site replacement calls function linked local automaton borrowing suitable phrase compilers automata inlining replace call site splice unique copy called automaton impossible paths removed call site expense larger global automaton theory global automaton smaller dense false edges introduced impossible paths present generally found state space automaton increase significantly practice single-edge replacement inlining special case single-edge replacement lightweight inlining technique called automaton edge function call edge simply replaced copy edge callee inexpensive inlining states -edges added model realizes inlining gains bounded stack model revisiting idea pda model find problems infinite left recursion generally unbounded stacks solved simply limiting maximum size run-time stack model top elements stack pop edges traversed stack empty state space runtime automaton finite requiring finite memory resources correspondingly language accepted bounded-stack pda regular closely approximates context-free language regular nfa bounded stack introduces problem points left recursion recursion deeper maximum height stack destroys context sensitivity stack fills recursive symbol unwinding recursion clears stack stack symbols prior entering recursion lost hybrid model recursion effect opposite desired programs recursion typically involves minority functions initially executed automaton final states initially executed automaton remote call procedure call identified procedure call identified destination identifier call edge pid irs irs precise discard recursive symbols symbols prior entering recursion hybrid model nfa pda edges interprocedural construction accomplish call site replacement simple -edges procedure call recursive cycle stack symbol call recursive recursion adds symbols pda stack leaving previous context sensitivity intact bounded-stack pda hybrid automaton defines regular language overapproximates context-free grammar accepted true pda context insensitivity technique construct interprocedural model analysis basis local models context insensitive control flow paths equally irrespective previous execution flow evaluate predicates points divergence straightforward analysis leads degree nondeterminism local automata seek reduce reducing non-determinism decreases size frontier current states automaton run-time turn fewer outgoing edges frontier 
improving efficiency precision renaming program analysis remote call site assigned randomly generated produce stub function random behaves original call rewrite binary program randomly named function called calling remote system call stub named write call stub named essentially passing call site names onetime encryption function key stored checking agent submitting machine translates random back original call execution call sites differentiated separate calls function calls functions random names label edges automaton serve input symbol model runtime renaming reduces non-determinism model precisely program execution received call comparing figure figure automaton main fully deterministic renamed call sites alphabet change moving symbols indicating call names potentially larger set symbols defining individual call sites attacker attacks randomly generated alphabet requiring analysis recover transformations remote calls program attack renamed calls generated call sites blocking unused remote call stub linked application call site renaming produces equivalent human-readable program text acting simplistic obfuscation technique checking agent maintains transformations recovery malicious individual requires program analysis remote call names context call program rewrite binary code obfuscation techniques applicable arguments reordered mixed dummy arguments per-call-site basis general methods obscure control flow similarly pursued techniques recent paper barak presents complexity-theoretic argument proves impossibility specific class obfuscating transformations define obfuscated program virtual black box property computed analyzing obfuscated program computed input-output behavior program contrast work require computationally hard adversary recover original system calls renamed calls computationally hard adversary invert renaming function obfuscation requirement weaker virtual blackbox requirement imposed barak claiming theoretical guarantees strength obfuscation transformation observing theoretical results presented barak directly apply context null calls insertion null calls dummy remote system calls translate null operations checking agent similar effects place calls application execufigure automaton main call site renaming edges labeled function calls internal application renamed edges splice points call site replacement main line end tion context checking agent reducing nondeterminism null calls immediately call site frequently called function recall introduce impossible paths call site replacement specifically link final states local automaton function call return states inserting null calls function call return sites distinguishes return locations true return path symbol null call true return site transmitted impossible paths exiting called automaton broken run-time element renaming null call insertion reducing non-determinism paths automaton remain unchanged labeled differently attacker knowledge transformations attacks transformed automaton equivalent original provided attacker takes control call stream remote calls occur attacker assumes control remote calls restricted operation model point precise argument manipulation remote system call exists calling context influences degree manipulation malicious process call site open malicious process alter file passed argument call model checks names calls call stream accept open call valid maliciously altered context open call present additional evidence checking agent enables argument modifications detected prevented argument recovery local automata constructed recover statically determined arguments backward slicing sparc argument registers backward register slicing iterate previous instructions affect register essentially finding instructions comprise expression tree simulate instructions software recover result argument call successfully recover numeric arguments statically strings resident data space application checking agent stores recovered arguments unavailable manipulation figure backward slice register point call write function main iterates instructions affect emphasized instructions inspected instructions affect case dnone static memory location indicating data space string resides recover string simulating instructions sethi software compute memory address reading string data space similar analysis determine targets indirect calls indirect call site linked function program address identify functions slicing backward register written program point determine written entry address register slicing intraprocedural making reasonable computation unresolved issues dynamic linking dynamically linked application loads shared object code remote machine address space code non-local fairly assume remote machine standard libraries ensure correct execution remote jobs analysis local standard libraries provide accurate models dynamically linked functions straightforward implemented support dynamically linked applications libraries solaris libnsl indirect calls extensively improve handling indirect calls expect handle applications signal handling execution receipt signal control flow jump signal handler previous execution state entry exit undetectable checking agent save alarms generate instrument binary expect insert null calls entry exit points signal handlers act out-of-band notifications signal handler activity instrumentations implemented multithreading kernel user level thread swaps invisible checking agent thread swaps run-time model fail remains area future research user level thread scheduling instrumentation scheduling routines checking agent swap model thread kernel scheduling figure register slicing iterate backwards instructions modify register prior call site sethi dnone call write dnone monitor require kernel modifications consideration interpreted languages programs written languages sml java compiled intermediate form native binary code execute program native-code run-time interpreter reads intermediate representation data executes specific binary code segments based input binary code analysis build model interpreter accepts sequences remote calls generated compiled program precise model specific application built knowledge intermediate representation interpreted run-time component partial evaluation interpreter program compiled native code execution common java virtual machine implementations techniques construct program-specific models execution experimental results evaluate techniques criteria precision efficiency precise model incorporates sequences calls generated application sequences efficient model adds small run-time overhead efficient models deployed precise models security interest section prototype tool evaluate techniques models examine metrics measure precision propose method identify unsafe states automaton tests show null call insertion markedly improves precision models care additional calls overwhelm network finally examine optimizations including renaming argument recovery stack abstractions improve quality models experimental setup implemented analyzer run-time monitor simulated remote execution environment test precision efficiency automaton models analyzer examines submitted binary program outputs automaton modified binary automaton read operated stand-alone process monitor acts checking local agent communicating modified program message-passing inter-process communication monitor rpc server verifies system call encountered program accepted model monitor successfully updates automaton original system call proceeds rewritten application analyzer simulated execution environment run sun ultra mhz workstation ram running solaris simulate wide-area network add delay received remote system call equivalent round trip time computer madison wisconsin computer bologna italy include delay data transfer statically volume data transferred null calls require reply delay added null call average time call send byte buffer argument evaluation collection solaris libc kernel trap wrapper functions defines set remote system calls present analysis results test programs table program descriptions workloads table statistics workloads default program options command line switches implemented general support dynamically linked 
functions statically link programs network libraries libresolv dynamically linked solaris machines analyze libraries techniques application program store generated automata analysis program procmail finger reveals call dynamically linked function read stored local automaton continue ignore indirect calls dynamically linked library functions monitor generates error run-time indirect call location metrics measure precision efficiency analyze precision models efficiency monitor operate precision dictates degree adversary limited attacks usefulness model counter-measure efficient operation requirement deployment real remote execution environments comparison measure automaton precision wagner dean dynamic average branching factor metric metric partitions system calls sets dangerous safe application execution model operation number dangerous calls accepted model counted operation total count averaged number operations model smaller numbers favorable adversary small opportunity exploit efficiency measurements straightforward unix utility time measure application execution time simulated environment operating model baseline measure indicating delay due simulated network transit overhead equivalent remote execution environment run-time conditions turn checking optimizations measure overhead introduced checking agent find nfa model efficient operate bounded pda disappointingly slow extra precision gained inclusion null calls bounded pda model dramatically improves efficiency nfa model evaluate models test programs respect precision efficiency baseline analyzer includes renaming argument recovery dead automaton removal single-edge replacement nfa model compare results null call placement strategies baseline trade-off performance efficiency due null call insertion null call placement strategies calls inserted calls inserted entry point function fan-in functions called functions application insert calls entry point function fan-in greater fourth instrument functions fan-in placement strategies found occasionally introduced glut null calls overwhelm network adding calls functions recursive cycles functions program description workload entropy calculates conditional probabilities packet header fields tcpdump data compute conditional probability data records random generates randomized sequence numbers seed values randomize numbers gzip compresses decompresses files compress single text file gnu finger displays information users computer display information users bart jha giffin finger displays information users computer display information users bart jha giffin procmail processes incoming mail messages process single incoming message table test program descriptions test workloads program source language lines code source compiler number functions binary instructions binary entropy gcc random fortran gzip gcc gnu finger finger gcc procmail table test programs statistics source code line counts include library code statistics binary programs include code statically linked libraries program model null calls increase null calls fan-in increase null calls fan-in increase null calls fan-in increase entropy gzip random gnu finger finger procmail table nfa run-time overheads absolute overheads execution time seconds modeling automaton entry state final state ensuring call chain generates symbol functions fan-in expected sequence greater instrumentation increases precision quality automata negatively impacting performance extra calls require additional network activity generally problem selecting good null call insertion points similar selecting optimal locations insert functions program tracing topic previous research investigate selection algorithms future implementations found null call insertion dramatically improved precision figure shows dynamic average branching factor test programs null call placement strategies instrumenting maximum level improves precision non-instrumented models order magnitude null call insertion adds edges local automata observe number edges final automaton significantly lower indicating call site replacement introduces fewer impossible paths edge count procmail model drops order magnitude state count increases modestly results demonstrate great potential introducing null calls unfortunate null call insertion expected detrimental effect application run-times null call encountered execution drops call network relay checking agent application wait response call expensive kernel trap adds network traffic table shows additional execution time resulting operation models null calls table lists bandwidth requirements insertion level null calls consume bytes bandwidth make primary observations results nfa model incredibly efficient operate run-time null calls inserted inserting null calls functions fan-in greater good balance precision gain additional overhead test programs programs require moderate bandwith instrumentation level varying bandwidth test programs due part naive null call insertion strategies expect algorithm developed ball larus reduce bandwidth requirements improve consistency collection programs effects optimizations analyzed procmail evaluate renaming argument recovery stack abstractions analyze automaton inlining surprisingly proved inefficient optimization inlining added significant overhead model construction delivered gain precision similarly found run-time characteristics hybrid model identical bounded pda examine inlining hybrid model greater detail effects renaming argument recovery selectively turned optimizations graph figure measures average branching factor dependent call site renaming argument recovery program procmail expected renaming argument recovery reduced imprecision model reduction produced renaming solely due reduction non-determinism argument recovery reduces imprecision removing arguments manipulation adversary renaming argument recovery reduce imprecision optimization figure nfa precision models included baseline optimizations entropy gzip random gnu fingerfinger procmail average branching factor nfa precision null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in program null calls fan-in null calls fan-in null calls fan-in entropy gzip random gnu finger finger procmail table null call bandwidth requirements kbps programs nfa models baseline optimizations glance counter-intuitive argument recovery reduce imprecision greater degree renaming argument recovery subset renaming static arguments distinguish call site attacker manipulate recovered argument system calls dangerous unknown arguments threat argument recovery analyzed bounded pda model procmail stack bounds figure shows average branching factors pda varying levels null call instrumentation bounded stack depth figures show run-time overheads models time scales null call insertion surprising effect operation bounded stack models added precision null calls decreases run-time overheads surprised discover cases boundedstack pda null call instrumentation efficient operate nfa model higher level precision observe higher levels null call instrumentation reduce execution times operation models precise increasing stack size produces similar effect plots instrumentation functions fan-in figure functions fan-in figure show common pattern stack bound size model efficiency improves execution context retained fewer paths model state grows past bound cost increased state begins dominate finding transition important area future research discussion metrics measuring precision dynamic average branching factor metric ignores important considerations attack consists sequence system calls single call isolation call dangerous combined calls attacker steer execution safe system calls reach portion model accepts attack sequence typical run program reach area model dangerous edges dynamic average branching factor safe edges cover potential attack downstream remote call sequence obvious dynamic metric easily overcomes objections straightforward static analogue dynamic average branching factor static average branching factor count averaged entire 
automaton states weighted equally prior complaints remain unsatisfied propose metric combines static dynamic measurements average adversarial opportunity metric requires stages computation automaton modeling application composed set attack automata identify model states attack potential monitor maintains count dangerous states encountered runtime attack potential attack beginning current state state reachable locating positions model adversary successfully insert attack counting visits states run-time comparison existing work measured dynamic average branching factor execution overhead comparison earlier work wagner dean compare nfa model model work common analyzed programs procmail finger intersect experimental set version finger wagner dean compared numbers analysis gnu finger call site renaming argument recovery single-edge replacement results wagner dean include argument recovery analogue renaming edge replacement programs observed significant discrepancy reported precision values generate investigation appears figure precision improvements renamed call sites argument recovery rename arg capture average branching factor nfa precision effects optimizations procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in figure effect stack depth null call insertion pda precision baseline optimizations figure effect stack depth null call insertion pda run-time overhead time scale baseline optimizations time scale shows trends null call insertion fan-ins figure effect stack depth null call insertion pda run-time overhead time scale source data identical figure time scale shows trends null call insertion insertion fan-in stack bound average branching factor pda precision effect stack depth procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in stack bound overhead seconds pda overhead effect stack depth sec time scale procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in sec stack bound overhead seconds pda overhead effect stack depth sec time scale procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in sec caused differences library code respective test platforms wagner dean analyzed programs compiled red hat linux solaris solaris older operating system includes extensive library code standard libraries solaris libc structured differently glibc linux includes functionality found glibc differences compare figure automaton socket system call glibc figure automaton function solaris libc case solaris socket function includes code maintaining backwards compatibility earlier method resolving device path networking protocol socket greatest difference functions inspected found numerous library functions similar characteristic simply linux solaris library code found solaris code complex understand influence library code base identified functions solaris libc differed significantly equivalent function glibc instrumented code identified functions generates remote system call event manner similar glibc expected average branching factor model dropped significantly figure intentionally instrument library functions incorrectly model generated semantically invalid change precision values reinforces hypothesis figure socket model solaris libc figure socket model linux glibc entry exit socket figure comparison baseline nfa models prior results wagner dean finger procmail average branching factor precision full solaris libc glibc emulation wagner dean finger procmail overhead seconds efficiency nfa model wagner dean model operation improves significantly work wagner dean figure shows overheads programs attributed model operation gain partly due implementation wagner dean wrote monitor java code runs natively highly efficient introducing negligible delay related work areas techniques goals similar considered paper applications static analysis intrusion detection statistical anomalydetection-based intrusion detection secure agentry compare techniques presented paper existing research areas work applies extends techniques wagner dean knowledge propose static analysis intrusion detection analyzed source code modifying compiler linker construct application models analysis performed binaries independent source language compiler removing user burden supply source code propose optimizations program transformations improve model precision efficiency optimizations proposed paper important contributions researchers working area vast body work applying dynamic analysis intrusion detection statistical anomalydetection-based intrusion detection systems ides statistical model normal behavior constructed collection dynamic traces program sequence system calls produced utilities strace truss generate statistical model program forrest behaviors deviate statistical model flagged anomalous guarantee manipulation theoretically statistical program model checking agent practically models suffer false alarm rates reject sequences system calls represent acceptable infrequent program behavior human inspection jobs flagged anomalous inappropriate setting pursue approach literature safe execution mobile agents malicious hosts secure agentry vast reader referred excellent summary techniques area secure agentry schneider exploring techniques area replication setting future work continue progressing number fronts foremost working expand infrastructure base static analysis techniques include points-to analysis binaries regular expression construction arguments standard points-to analysis algorithms designed higher-level source language rely datatype properties evident syntax code adapt algorithms weaklytyped sparc code arguments envision stronger slicing techniques build regular expressions arguments statically determined code analyses produce precise models research areas targeting run-time overhead reductions complex models reduce impact null call insertions investigate adaptations ball larus algorithm identify optimal code instrumentation points minimum-cost code profiling reduce overhead pda models collapse run-time values automaton state single dag representing stack configurations traversing outgoing edges single update dag equivalent individual update previous stack hope make complex precise models attractive real environments add general support dynamically linked applications signal handlers analysis engine enabling analysis larger test programs measure attack opportunities afforded models implement average adversarial opportunity metric create collection attack automata accurate measure danger inherent automaton enables develop strategies mitigate harm acknowledgments david wagner patiently answering questions work providing specification dangerous system calls david melski pointed relevance ball larus research insightful discussions tom reps static analysis hong lin initially researched solutions remote code manipulation vulnerability glenn ammons provided helpful support eel members wisa security group wisconsin valuable feedback suggestions lastly anonymous referees comments availability research tool remains development distributing time contact jonathon giffin giffin wisc updates status alexandrov ibel schauser scheiman superweb global web-based parallel computing infrastructure ieee international parallel processing symposium geneva switzerland april anstreicher brixius goux linderoth solving large quadratic assignment problems computational grids international symposium mathematical programming atlanta georgia august appel macqueen standard jersey international symposium programming language implementation logic programming passau germany august appears maluszynski wirsing eds programming language implementation logic programming lecture notes computer science springer-verlag york ball larus optimally profiling tracing programs acm transactions programming languages systems july barak goldreich impagaliazzo rudich sahai vadhan yang possibility obfuscating programs annual international cryptography conference santa barbara california august appears kilian advances cryptology crypto lecture notes computer 
science springer-verlag york belani vahdat anderson dahlin crisis wide area security architecture seventh usenix security symposium san antonio texas january chow johnson zakharov approach obfuscation control-flow sequential computer programs information security conference malaga spain october collberg thomborson low breaking abstractions unstructuring data structures ieee international conference computer languages chicago illinois denning neumann requirements model ides real-time intrusion detection system technical report sri international august esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems conference computer aided verification chicago illinois july appears emerson sistla eds computer aided verification lecture notes computer science springer-verlag york fagg moore dongarra scalable networked information processing environment snipe supercomputing san jose california november forrest hofmeyr somayaji longstaff sense unix processes ieee symposium research security privacy oakland california foster kesselman globus metacomputing infrastructure toolkit international journal supercomputer applications high performance computing summer foster kesselman eds grid blueprint computing infrastructure morgan kaufmann san francisco ghosh schwartzbard schatz learning program behavior profiles intrusion detection usenix workshop intrusion detection network monitoring santa clara california april giffin lin exploiting trusted appletserver communication unpublished manuscript http wisc giffin hohl model attacks malicious hosts mobile agents ecoop workshop mobile object systems secure internet computations brussels belgium july hopcroft log algorithm minimizing states finite automaton theory machines computations academic press york hopcroft motwani ullman introduction automata theory languages computation addison wesley boston horwitz reps program dependence graphs software engineering international conference software engineering melbourne australia jones gomard sestoft partial evaluation automatic program generation prentice hall international series computer science prentice hall englewood cliffs jersey fink levitt automated detection vulnerabilities privileged programs execution monitoring annual computer security applications conference orlando florida logic induction valid behavior specifications intrusion detection ieee symposium security privacy oakland california lamport shostak pease byzantine generals problem acm transactions programming languages systems july larus schnarr eel machineindependent executable editing sigplan conference programming language design implementation jolla california june litzkow livny mutka condor hunter idle workstations international conference distributed computer systems san jose california june miller christodorescu iverson kosar mirgorodskii popovici playing inside black box dynamic instrumentation create security holes parallel processing letters june september appears los alamos computer science institute symposium sante october reps program analysis graph reachability information software technology november december saltzer protection control information sharing multics communications acm july sander tschudin protecting mobile agents malicious hosts vigna mobile agents security lecture notes computer science springer-verlag york schneider fault-tolerant secure agentry international workshop distributed algorithms saarbrucken germany september seti home search extraterrestrial intelligence home january http setiathome ssl berkeley sun microsystems java virtual machines http java sun docs guide tip survey program slicing techniques journal programming languages september vahdat anderson dahlin belani culler eastham yoshikawa webos operating system services wide area applications seventh international symposium high performance distributed computing chicago illinois july wagner static analysis computer security techniques software assurance dissertation california berkeley fall wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wang davidson hill knight protection software-based survivability mechanisms international conference dependable systems networks goteborg sweden july warrender forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy oakland california 
homework introduction information security due date feb wednesday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free question ofb mode points questions output feedback mode ofb part prove encrypt decrypt stages ofb mode work correctly obtains plaintext decryption prove stage prove general i-th stage part explain quote book advantage ofb method bit errors transmission propagate question meet-in-the-middle attack points assume oscar pairs plain cipher texts explain meet-in-the-middle attack des context compute probability oscar succeeds finds correct key pair des question sdes points part problem stallings book part problem stallings book question des points part problem stallings book part problem stallings book menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date feb thursday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply warm-up homework attended lectures problems easy homework stallings book refers handbook refers linked handbook class homepage download free question playfair cipher points problem stallings book question hill cipher points problem stallings book note typo message phrase read ten louis kruger point question one-time pad points problem stallings book question lfsr-based stream cipher points part assume -stage lfsr shown figure starts initial state generate key stream length show steps part relationship i-th key previously generated keys lfsr part alice bob communicating stream cipher key stream generated -stage lfsr oscar crack stream cipher remember oscar bad guy plaintext attack long plaintext ciphertext oscar justify answer part plaintext attack part depends linearity lfsr solution non-linear generator keys read shrinking generator handbook page describe words stage stage stage stage figure -stage lfsr menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date march monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free stated part question equal weight question fermat theorem flt points problem stalling book question chinese remainder theorem crt points part problem stalling book part problem stalling book question rsa points part points problem stallings book part points problem stallings book part points prove rsa insecure chosen plaintext attack specifically ciphertext describe choose knowledge plaintext computed hint multiplicative property rsa mod mod question el-gamal diffie-hellman points part problem stallings book part assume alice sends message bob el-gamal remember oscar public key ciphertext reason oscar algorithm finding plaintext solve diffie-hellman problem dhp note converse statement proved class menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date march tuesday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question networking basics points part syn-cookies protect server spoofed addresses part distributed-re ected denial-of-service attack address source-ip syn address source-ip syn ack explain answer terminology malicious flood generator ection server innocent bystander victim attack question hash algorithms points part points problem stalling book part points problem stalling book part points choose random sets persons probability atleast person set shares birthday person set give formula justify answer plot question speci hash algorithms points part points problem stallings book part points problem stallings book mov menezes van oorschot vanstone handbook applied cryptography crc press sta william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date april friday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply long homework points higher weight start early homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question authentication protocols points part points problem stallings book part points problem stallings book question dsa points part points assume alice random number sign messages demonstrate oscar signatures derive private key part points show knowing random number equivalent knowing random number oscar find vice-versa part points problem stallings book question kerberos points question read explanation kerberos version appendix stallings book read note interrealm authentication kerberos version part points problem stallings book part points problem stallings book part points suppose trust relationship realms biology department bob user realm access server biology realm show steps required bob authenticate question points part points problem stallings book part points cas arranged hierarchy shown figure show certificates navigate hierarchy show chain validates public key alice bob vice-versa mov menezes van oorschot vanstone handbook applied cryptography crc press engls ece alice bob figure hierarchy certificate authorities sta william stallings cryptography network security principles practice prentice hall 
interrealm authentication kerberos version somesh jha computer sciences department wisconsin madison april scenario assume user realm access server realm path realm conceptually edge represents trust relationship realm means shared key realms initial request requests ticket-granting ticket tgt kdc realm denote kdc realm forwardable flag trust relationship issues tgt tgt realm forwardable flag assuming mechanism realm discover path realm note assuming servers issue tickets policy kdc issues tgt forwardable flag policy implicit document walking path tgt tgt requests tgt realm ticket granting server tgs denoted tgs realm tgt issued tgs denoted tgt forwardable forwarded flags tgt address agent handling behalf user process repeated reaches realm tgt tgt issued tgs realm accessing tgt tgt presented tgs tgs obtain servicegranting ticket sgs sgt server sgs access server critique interrealm authentication kerberos subsection describes shortcomings interrealm authentication kerberos implicit trust relationships implicit trust relationships realms kerberos context manifests sharing keys realms realm issues tgt realm abstractly denotes trusting authenticating user make trust relationships explicit general entity indexed realm pertains ticket granting ticket tgt issued realm realm denoted tgt closed-world assumption imagine realms realms correspond biology computer science department professor biology department provide access server group members belong project clonesheep computer science current scheme group members project words professor identity group members clonesheep violates closed-world assumption ideally professor server accessible group members clonesheep authorization happen seamlessly advantage group member leaves authorization decision seamlessly incorporate information explicit change acls claim trust management conjunction distributed authentication service kerberos address shortcomings 
homework introduction information security due date thursday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question ssl points part points problem stallings book part points problem stallings book question malicious code points contact mihai christodorescu atmihai wisc parts drew bernat bernat wisc edushould contacted part part points propagation methods morris worm slammer worm differ part points development viruses malicious codes correlates general history computing factors helped supported rapid evolution malicious code part points list methods defeat stack-based buffer overflow attack question network attacks points wily hacker problem guides steps attacker launching attack network end goal run specific program root privileges machine located building direct questions problem jonathon giffin giffin wisc scripted series steps reach goal experiments designed run tux lab run attack nova lab responsible acquiring network tools listed providing linux versions run attack labs target machine unreachable network target vulnerability wisc running default installation recent linux distribution running experiments target machine csl machine targeted expects attacks held accountable attacks machines network internet programs experiments ping telnet scp standard unix utilities provided tux machines csl read man pages unfamiliar programs nmap nmap installed lab machines copy giffin public nmap run nmap arguments command line options attack attack exploits programming fault windows program giffin public attack compile attack program experiments produce errors destination host unreachable vulnerability crashed giffin wisc restart machine good reason wait minute homework problem problem parts submit answers parts part make target machine running address part nmap learn ports open target scan tcp ports polite scan rate provided nmap note scan minutes complete write nmap command line include command-line arguments list open ports find part open port signify part port listed filtered feel free play command line options nmap provided target machine vulnerability scan rate faster polite part network programs advertise version numbers vulnerability running ssh daemon telnet determine version numbers ssh openssh list version numbers part version number attacker part exploit ssh telnet daemon interesting usernames passwords clear logs wily hacker sniff packets network find username billg logs password trustworthy opening connect vulnerability stolen login connected type whoami prompt username write current username run program root prog fail billg permissions execute programs directory root part program attack exploits vulnerability windows programs linux release determine target vulnerable linux kernel version running linux distribution version running determine information part verify process called running target machine running attack work determine information part read source code attack attack falls category attacks outcome successful attack attack work attack program local exploit run target machine make subdirectory access upload attack program directory created unix scp command compile attack needed figure attack program part vulnerable setuid root program dangerous attackers exploit program gain root privileges machine find windows program vulnerability setuid root run attack program target program found attack successful funny command prompt vulnerable program machine program exploit username exploit part run arbitrary commands vulnerability destructive unhappy reinstall operating system clean garbage hard drive type root prog permissions run prog part write hex numbers output prog verification completed experiments time clean exit current shell run billg delete attack program uploaded directory created disconnect target machine mov menezes van oorschot vanstone handbook applied cryptography crc press sta william stallings cryptography network security principles practice prentice hall 
project design document introduction information security due date april tuesday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade nal code worth entire project grade putting lot emphasis design document describing entities section describe entities system bank customer merchant assign short names identi ers bank customer merchant identi ers protocol description page chapter flow messages protocol show messages protocol make format messages depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system messages diagram view system follow kerberos overview page figure chapter design review pick team class call team design-review team make designreview team reviews document submit incorporate suggestions mention design-review team design document menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date march monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free question ofb mode points questions output feedback mode ofb part prove encrypt decrypt stages ofb mode work correctly obtains plaintext decryption prove stage prove general i-th stage part explain quote book advantage ofb method bit errors transmission propagate question meet-in-the-middle attack points assume oscar pairs plain cipher texts explain meet-in-the-middle attack des context compute probability oscar succeeds finds correct key pair des question sdes points part problem stallings book part problem stallings book question des points part problem stallings book part problem stallings book question des points extra credit find key desk des key called weak key weak keys find called weak menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date feb friday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply warm-up homework attended lectures problems easy homework stallings book refers handbook refers linked handbook class homepage download free question hill cipher points problem stallings book note typo message phrase read ten louis kruger point question hill cipher points problem stallings book question one-time pad points problem stallings book question linearity points function takes input n-bit vector returns m-bit vector write formally type part define means linear part give linear non-linear function question lfsr-based stream cipher points part assume -stage lfsr shown figure starts initial state generate key stream length show steps part relationship i-th key previously generated keys lfsr relationship linear justify answer part alice bob communicating stream cipher key stream generated -stage lfsr oscar crack stream cipher remember oscar bad guy plaintext attack long plaintext ciphertext oscar justify answer part plaintext attack part depends linearity lfsr solution non-linear generator keys read alternating-step generator handbook page describe words answer question alternating-step generator linear menezes van oorschot vanstone handbook applied cryptography crc press stage stage stage stage figure -stage lfsr william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date april monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question fermat theorem flt points problem stalling book question chinese remainder theorem crt points part problem stalling book part problem stalling book question rsa points part points problem stallings book part points problem stallings book part points explain low exponent attack rsa question based paper handed class part points prove rsa insecure chosen plaintext attack specifically ciphertext describe choose negationslash knowledge plaintext computed hint multiplicative property rsa mod mod question el-gamal diffie-hellman points part problem stallings book part assume alice sends message bob el-gamal remember oscar public key ciphertext reason oscar algorithm finding plaintext solve diffie-hellman problem dhp note converse statement proved class question networking basics points part syn-cookies protect server flooding attacks part distributed-reflected denial-of-service attack address source-ip syn address source-ip syn ack explain answer terminology malicious flood generator reflection server innocent bystander victim attack question hash algorithms points part points problem stalling book part points problem stalling book part points choose random sets persons probability atleast person set shares birthday person set give formula justify answer plot question specific hash algorithms points part points problem stallings book part points problem stallings book kaliski robshaw secure rsa technical newsletter rsa laboratories cryptobytes mov menezes van oorschot vanstone handbook applied cryptography crc press sta william stallings cryptography network security principles practice prentice hall 
project design document introduction information security due date draft mentors april monday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade final code worth entire project grade putting lot emphasis design document length design document pages long remember design document basis implementation describing entities section describe entities system bank customer merchant assign short names identifiers bank customer merchant identifiers protocol description page chapter flow messages protocol show flow messages protocol make format messages flow depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system flow messages diagram presents view system follow kerberos overview page figure chapter design review pick team class call team design-review team make designreview team reviews document submit incorporate suggestions mention design-review team design document menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
november note non-secret encryption cocks implementation suggested ellis proposed method encryption involving sharing secret information key lists machine set-ups pluggings sender receiver note non-secret encryption ellis describes theoretical method encryption necessitate sharing secret information sender receiver describes implementation receiver picks primes satisfying conditions divide divide transmits sender sender message consisting numbers sends encoded cin reduced modulo decode receiver finds euclid algorithm numbers satisfying mod mod dip mod diq mod calculated processes involved algorithm involving work order log test prime works fail give answer density primes log picking primes process order log small integer computing cin mod order log computation dip diq smaller coding decoding process requiring work order log factorising process requiring work order log small integer alternatively computing mod requires work order factorization decoding interceptor communication process order possibility non-secret digital encryption ellis cesg research report january note loss security transmitting enemy guess crib crthis information decoding case provide pairs pleases encryption process transmitter 
homework introduction information security due date feb friday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply warm-up homework attended lectures problems easy homework stallings book refers handbook refers linked handbook class homepage download free question points problem stallings book question points problem stallings book question points integers mod combination hill affine ciphers represent block plaintext pair mod ciphertext parenleftbigg parenrightbigg mod describe carry chosen plaintext attack system goal finding key state explicitly plain-texts choose recover keys question linearity points function takes input n-bit vector returns m-bit vector write formally type part define means linear part give linear non-linear function question lfsr-based stream cipher points part assume -stage lfsr shown figure starts initial state generate key stream length show steps part relationship i-th key previously generated keys lfsr relationship linear justify answer part alice bob communicating stream cipher key stream generated -stage lfsr oscar crack stream cipher remember oscar bad guy plaintext attack long plaintext ciphertext oscar justify answer part plaintext attack part depends linearity lfsr solution non-linear generator keys read alternating-step generator handbook page describe words answer question alternating-step generator linear stage stage stage stage figure -stage lfsr menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date march monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free question ofb mode points questions output feedback mode ofb part prove encrypt decrypt stages ofb mode work correctly obtains plaintext decryption prove stage prove general i-th stage part explain quote book advantage ofb method bit errors transmission propagate question meet-in-the-middle attack points assume oscar pairs plain cipher texts explain meet-in-the-middle attack des context compute probability oscar succeeds finds correct key pair des question points problem stallings book question points suppose triple des performed choosing keys computing note order keys modified usual two-key version triple des show attack modified version meet-in-themiddle attack question block ciphers points part problem stallings book part problem stallings book question des points extra credit find key desk des key called weak key weak keys find called weak menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
project design document introduction information security due date april monday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade final code worth entire project grade putting lot emphasis design document length design document pages long remember design document basis implementation describing entities section describe entities system bank customer merchant assign short names identifiers bank customer merchant identifiers protocol description page chapter flow messages protocol show flow messages protocol make format messages flow depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system flow messages diagram presents view system follow kerberos overview page figure chapter design review team assigned mentor graduate student working security make mentor reviews document submit incorporate suggestions mentor menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date feb friday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply warm-up homework attended lectures problems easy homework stallings book refers handbook refers linked handbook class homepage download free question hill cipher points problem stallings book note typo message phrase read ten louis kruger point question hill cipher points problem stallings book question one-time pad points problem stallings book question linearity points function takes input n-bit vector returns m-bit vector write formally type part define means linear part give linear non-linear function question lfsr-based stream cipher points part assume -stage lfsr shown figure starts initial state generate key stream length show steps part relationship i-th key previously generated keys lfsr relationship linear justify answer part alice bob communicating stream cipher key stream generated -stage lfsr oscar crack stream cipher remember oscar bad guy plaintext attack long plaintext ciphertext oscar justify answer part plaintext attack part depends linearity lfsr solution non-linear generator keys read alternating-step generator handbook page describe words answer question alternating-step generator linear menezes van oorschot vanstone handbook applied cryptography crc press stage stage stage stage figure -stage lfsr william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date april monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question fermat theorem flt points problem stalling book question chinese remainder theorem crt points part problem stalling book part problem stalling book question rsa points part points problem stallings book part points problem stallings book part points explain low exponent attack rsa question based paper handed class part points prove rsa insecure chosen plaintext attack specifically ciphertext describe choose negationslash knowledge plaintext computed hint multiplicative property rsa mod mod question el-gamal diffie-hellman points part problem stallings book part assume alice sends message bob el-gamal remember oscar public key ciphertext reason oscar algorithm finding plaintext solve diffie-hellman problem dhp note converse statement proved class question networking basics points part syn-cookies protect server flooding attacks part distributed-reflected denial-of-service attack address source-ip syn address source-ip syn ack explain answer terminology malicious flood generator reflection server innocent bystander victim attack question hash algorithms points part points problem stalling book part points problem stalling book part points choose random sets persons probability atleast person set shares birthday person set give formula justify answer plot question specific hash algorithms points part points problem stallings book part points problem stallings book kaliski robshaw secure rsa technical newsletter rsa laboratories cryptobytes mov menezes van oorschot vanstone handbook applied cryptography crc press sta william stallings cryptography network security principles practice prentice hall 
project design document introduction information security due date april monday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade final code worth entire project grade putting lot emphasis design document length design document pages long remember design document basis implementation describing entities section describe entities system bank customer merchant assign short names identifiers bank customer merchant identifiers protocol description page chapter flow messages protocol show flow messages protocol make format messages flow depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system flow messages diagram presents view system follow kerberos overview page figure chapter design review team assigned mentor graduate student working security make mentor reviews document submit incorporate suggestions mentor menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework due date november somesh jha computer sciences department wisconsin madison november question points part express relations figure relations class operators give short justi cation answer part cousinsfatherside cousinsmotherside cousins set cousins separated n-steps father side mother side father mother side write recursive expression relations express relations parameter terms relations parameter basic relations introduced fatherinlaw people males sisterinlaw people females firstcousinsfatherside people people firstcousinsmotherside people people firstcousins people people secondcousinsfatherside people people secondcousinsmotherside people people secondcousins people people figure relations class question points establish equations relations true justify answer enter equations ladybug play assume relations types note symbol denotes empty relation question points question write speci cation problem aim model library types persons books function issued books persons set library set books book issued person issued library represents set books library set books reserve set reserve set books operations issue book operation issues book person book reserve issued issued return book operation models act person returning book adding book library operations models book added library putting book reserve operations models book put reserve book issued put reserve taking book reserve operation models book reserve claims assertions alloy issuing book returning results state book reserve issued claim true operation part write mathematical description operations claims explain answer part write speci cation ladybug part express design alloy part based experience part compare ladybug alloy 
homework analysis software artifacts due date oct wednesday question review points question review speci cations class attended class easy part explain speci cation setup started setupustarted proposition setup models fact setup transaction proposition started denotes start transaction part explain speci cations afp part show model states efp true afp false model part state-machine model model afp true efp false justify answer part write ctl rtctl speci cations property transaction issued state cycles timesteps transaction issued assume atomic propositions issued issued transaction issued question smv points modify vending machine provided class multiple users model users speci cation add additional state waiting signi user waiting vending machine module description user users simply instantiations module users simultaneously waiting vending machine vending machine non-deterministically picks user indecisive user user change mind middle process depositing coins case vending machine return coins dispense drink speci cation express property ctl user waiting eventually drink mind middle checking nusmv check speci cation true speci cation true explain counter-example logistics start changing smv model write design document outline design strategy design document detailed show design document fellow student reviewer mention reviewer document design document consistent speci cation submit modi smv speci cation design document homework grade homework homework 
homework analysis software artifacts due date oct wed note homework teams students earlier homework start changing nusmv model write design document outline design strategy design document detailed show design document fellow student reviewer mention reviewers document design document consistent speci cation submit modi nusmv speci cation design document homework grading homework completing homework note base design nusmv provided homework design consistent start code base follow procedure question number question modeling points enhance speci cation part multiple priorities users levels priority high low assume users priority users priority round-robin scheduling policy users erent priorities waiting user higher priority machine part coins assume drink costs fty cents user deposits dimes quarters user vending machine deposited coins worth greater equal fty cents drink vending machine return spare change hints extra variable called amount-accrued discuss round-robin scheduling lectures track user deposited vending machine variable called amount-returned equal spare change gure values variables amount-accrued amount-returned arithmetic nusmv track amount-accrued amount-returned explicit transitions simulate addition amount-accrued twenty user deposits dime amount-accrued thirty step question modeling spin points explain mars path nder glitch detail construct toy model relevant portions mars path nder promela input language spin model check design speci cations absence priority inversion ltl speci cations documents provided usual write detailed design document 
ps-adobecreator dvips copyright radical eye software title course-document dvi pages pageorder ascend boundingbox documentfonts times-roman times-bold times-italic cmsy courier documentpapersizes letter endcomments dvipswebpage radicaleye dvipscommandline dvips course-document course-document dvipsparameters dpi dvipssource tex output beginprocset tetex texmf dvips pstricks pstricks pro postscript prologue pstricks tex version patch distribution pstricks tex dict dict def dict begin adict dict def matrix currentmatrix bind def slw setlinewidth load def clw currentlinewidth load def currentpoint load def exch def bind def lineto load def translate load def tmatrix def rangle def atan atan load stopped pop pop def div dup pop div ifelse def net neg exch neg exch def pyth dup mul exch dup mul add sqrt def ptoc copy cos mul roll sin mul def pathlength pyth add def def def def pathlength flattenpath def def def pathlength def def pathlength pathforall load stopped pop pop pop pop def stp dup scale def stv sdict begin normalscale end stp def dashline dup def pathlength exch div pop def pathlength ifelse add def mul mul div round mul mul mul add exch div dup mul mul mul ifelse setdash stroke def dotline pathlength def clw def add def div def def add def ifelse ifelse div round div dup pop div neg ifelse setdash setlinecap stroke def linefill gsave abs clw add dtransform round exch round exch copy idtransform exch atan rotate idtransform pop modification begin dec patch itransform translate pathbbox div ceiling cvi itransform pathbbox div ceiling cvi modification end div cvi def clip newpath setlinecap systemdict setstrokeadjust true setstrokeadjust add modification begin jun patch michael vulis mul moveto rlineto stroke add def repeat grestore def mul moveto rlineto stroke add def repeat grestore pop pop def modification end beginarrow adict begin mtrx def gsave copy index neg exch index exch atan rotate newpath def endarrow mtrx setmatrix grestore end def arrow clw mul add dup div mul dup mul scale neg moveto neg neg rlineto gsave fill grestore def tbar clw mul add div clw div moveto rlineto stroke clw moveto def bracket clw mul add dup clw div mul clw add clw div def neg moveto neg clw div clw div stroke clw moveto def roundbracket clw mul add dup div mul mtrx def clw div mul scale moveto curveto curveto mtrx setmatrix stroke clw moveto def arc fill def enddot def def ifelse clw add clw div moveto def shadow moveto load lineto load curveto load closepath load pathforall load stopped pop pop pop pop moveto load cvx newpath roll exec def narray aload length div dup dup cvi exch pop exch cvi def def narray counttomark div dup cvi exch pop aload points mul add roll pop ifelse def line narray def arrowa def lineto repeat roll arrowb pop pop def arcto roll cvx def arcto load stopped ifelse pop repeat def checkclosed dup mul index index mul add index pop pop def def polygon narray def pop pop repeat checkclosed mul roll add div def add div def moveto def lineto repeat roll lineto lineto pop pop closepath ifelse def diamond mtrx def rotate dup pop clw mul neg atan def sin div add def cos div add def ifelse mark div div neg neg div div arrowa moveto def arrowb def false line closepath mtrx setmatrix def modification begin jan triangle mtrx def translate rotate div dup pop clw mul atan sin div def atan div dup cos exch sin div mul def ifelse mark neg arrowa moveto def arrowb def false line closepath mtrx setmatrix def triangle mtrx def translate rotate div dup clw mul atan sin div def atan div dup cos exch sin div mul def mark neg arrowa moveto def arrowb def false line closepath mtrx modification begin jun patch michael vulis setmatrix def setmatrix pop def modification end cca copy pyth def def cca copy pyth def def def def def def def cca exp mul exp mul add def exp mul exp mul add def atan atan div cos abs exp mul pyth div div def mul mul def mul mul def mul mul neg def mul mul neg def def add def def def ifelse mul div cos exp div def cca def def def boc arrowa roll curveto def curveto def eoc roll arrowb copy curveto def bac moveto arrowa def nac curveto def eac arrowb curveto pop pop def opencurve narray pop pop repeat boc def repeat eoc ifelse def altcurve false narray mul roll mul roll aload points mul roll false narray ifelse pop pop repeat bac def nac repeat eac ifelse def closedcurve narray pop pop repeat checkclosed copy mul add roll moveto repeat closepath pop pop ifelse def moveto neg neg neg neg fill def moveto neg fill def gsave moveto rotate repeat fill grestore def fontdot mul dup matrix scale matrix concatmatrix exch matrix rotate matrix concatmatrix exch findfont exch makefont setfont def rect add div moveto lineto lineto lineto lineto closepath def ovalframe pop pop moveto abs abs copy exch pop pop ifelse div exch dup roll mul exch copy pop exch pop ifelse add div moveto arcto arcto arcto arcto pop repeat closepath ifelse def frame clw mul roll copy exch add copy exch add index pop pop rect ovalframe ifelse def beziernarray counttomark div dup cvi exch pop neg mod add mod add def repeat aload points mul add roll pop ifelse def openbezier beziernarray pop pop arrowa idiv roll roll curveto repeat roll roll arrowb curveto ifelse def closedbezier beziernarray pop pop moveto idiv roll roll curveto repeat closepath ifelse def beziershowpoints gsave points aload length div cvi moveto lineto repeat clw div slw setdash stroke grestore def parab exch def exch def exch def exch def div def div def add arrowa add add mul arrowb curveto points mul def def grid newpath string def cvi dup pop div dup pop div dup pop div round mul div round mul div round cvi div round cvi div round cvi 
homework introduction information security due date thursday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question ssl points part points problem stallings book part points problem stallings book question malicious code points contact mihai christodorescu atmihai wisc parts drew bernat bernat wisc edushould contacted part part points propagation methods morris worm slammer worm differ part points development viruses malicious codes correlates general history computing factors helped supported rapid evolution malicious code part points list methods defeat stack-based buffer overflow attack question network attacks points wily hacker problem guides steps attacker launching attack network end goal run specific program root privileges machine located building direct questions problem jonathon giffin giffin wisc scripted series steps reach goal experiments designed run tux lab run attack nova lab responsible acquiring network tools listed providing linux versions run attack labs target machine unreachable network target vulnerability wisc running default installation recent linux distribution running experiments target machine csl machine targeted expects attacks held accountable attacks machines network internet programs experiments ping telnet scp standard unix utilities provided tux machines csl read man pages unfamiliar programs nmap nmap installed lab machines copy giffin public nmap run nmap arguments command line options attack attack exploits programming fault windows program giffin public attack compile attack program experiments produce errors destination host unreachable vulnerability crashed giffin wisc restart machine good reason wait minute homework problem problem parts submit answers parts part make target machine running address part nmap learn ports open target scan tcp ports polite scan rate provided nmap note scan minutes complete write nmap command line include command-line arguments list open ports find part open port signify part port listed filtered feel free play command line options nmap provided target machine vulnerability scan rate faster polite part network programs advertise version numbers vulnerability running ssh daemon telnet determine version numbers ssh openssh list version numbers part version number attacker part exploit ssh telnet daemon interesting usernames passwords clear logs wily hacker sniff packets network find username billg logs password trustworthy opening connect vulnerability stolen login connected type whoami prompt username write current username run program root prog fail billg permissions execute programs directory root part program attack exploits vulnerability windows programs linux release determine target vulnerable linux kernel version running linux distribution version running determine information part verify process called running target machine running attack work determine information part read source code attack attack falls category attacks outcome successful attack attack work attack program local exploit run target machine make subdirectory access upload attack program directory created unix scp command compile attack needed figure attack program part vulnerable setuid root program dangerous attackers exploit program gain root privileges machine find windows program vulnerability setuid root run attack program target program found attack successful funny command prompt vulnerable program machine program exploit username exploit part run arbitrary commands vulnerability destructive unhappy reinstall operating system clean garbage hard drive type root prog permissions run prog part write hex numbers output prog verification completed experiments time clean exit current shell run billg delete attack program uploaded directory created disconnect target machine mov menezes van oorschot vanstone handbook applied cryptography crc press sta william stallings cryptography network security principles practice prentice hall 
project design document introduction information security due date draft mentors april monday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade final code worth entire project grade putting lot emphasis design document length design document pages long remember design document basis implementation describing entities section describe entities system bank customer merchant assign short names identifiers bank customer merchant identifiers protocol description page chapter flow messages protocol show flow messages protocol make format messages flow depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system flow messages diagram presents view system follow kerberos overview page figure chapter design review pick team class call team design-review team make designreview team reviews document submit incorporate suggestions mention design-review team design document menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date march monday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free question ofb mode points questions output feedback mode ofb part prove encrypt decrypt stages ofb mode work correctly obtains plaintext decryption prove stage prove general i-th stage part explain quote book advantage ofb method bit errors transmission propagate question meet-in-the-middle attack points assume oscar pairs plain cipher texts explain meet-in-the-middle attack des context compute probability oscar succeeds finds correct key pair des question points problem stallings book question points suppose triple des performed choosing keys computing note order keys modified usual two-key version triple des show attack modified version meet-in-themiddle attack question block ciphers points part problem stallings book part problem stallings book question des points extra credit find key desk des key called weak key weak keys find called weak menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
div round cvi ifelse def ifelse def div clw div add def helvetica findfont scalefont setfont mul clw div add def systemdict setstrokeadjust true setstrokeadjust def transform round add exch round add exch itransform bind def ifelse gsave setlinecap div div div setdash setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop mul dup moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup moveto stroke add def repeat grestore gsave modification begin nov patch setlinecap div div div setdash setlinecap div div div setdash modification end setlinecap ifelse def mul div div mul def mul div div mul add def mul add dup pop newpath mul dup exch moveto gsave cvs dup stringwidth pop add neg ifelse neg ifelse rmoveto show grestore dup exch moveto exch stroke add def repeat grestore def arcarrow gsave newpath moveto clip newpath grestore mul pop pop pop ptoc add exch add exch ptoc add exch add exch pop pop pop pop clw div mul neg def ellipse mtrx def scale roll arc mtrx setmatrix def rot translate roll neg rotate net def rotbegin dict tmatrix tmatrix def rangle def tmatrix tmatrix cvx def rot rangle rangle dup add cvx def def rotend tmatrix tmatrix setmatrix cvx def rangle rangle pop cvx def def putcoor gsave stv exch exec moveto setmatrix grestore def putbegin tmatrix tmatrix cvx def roll moveto def putend tmatrix tmatrix setmatrix cvx def moveto def uput add div div sin def cos def abs abs copy dup pop exch pop ifelse def div mul def div mul def abs dup mul abs abs dup mul abs ifelse def uuput abs div mul abs div mul abs ifelse mul mul mul add sqrt add div div ifelse abs ifelse ptoc add exch add exch def beginol dup exch theol ifvisible visible ifvisible true def ifvisible invisible ifvisible false def ifelse def initol olunit matrix defaultmatrix dtransform cvx def visible olunit idtransform moveto def invisible olunit neg exch neg exch idtransform moveto def bol beginol def ifvisible true def def end end pstricks pro endprocset beginprocset tex pro texdict dict def texdict begin def def bind def exch dup translate isls false vsize mul hsize mul landplus false def rigin isls landplus ifelse concat resolution div vresolution div neg scale isls landplus vresolution div vsize mul exch resolution div hsize mul ifelse resolution vresolution vsize div add mul matrix currentmatrix round abs round forall round exch round exch setmatrix landscape isls true manualfeed statusdict manualfeed true put copies copies fmat fbb ien ctr df-tail dict begin fonttype fontmatrix fntrx fontbbox fbb string base array bitmaps buildchar charbuilder encoding ien end foo setfont array copy cvx load put ctr fntrx fmat df-tail dfs div fntrx neg df-tail pop definefont setfont length length length length cdx length type stringtype ctr ctr ctr add charbuilder save roll base index bitmaps pop ctr cdx add setcachedevice true imagemask restore type stringtype base ctr put bitmaps ctr length index div put put ctr ctr add add bop userdict bop-hook bop-hook save rigin moveto matrix currentmatrix mul exch mul add ifelse load def pop pop eop restore userdict eop-hook eop-hook showpage start userdict start-hook start-hook pop vresolution resolution div dvimag ien array string ien add index cvrs cvn put pop div vsize div hsize show rmat bdot string statusdict begin product pop false display laserwriter length product length length product exch exch getinterval pop true exit pop ifelse forall false ifelse end gsave scale false rmat bdot imagemask grestore gsave scale false rmat bdot imagemask grestore ifelse gsave newpath transform round exch round exch itransform moveto rlineto neg rlineto neg rlineto fill grestore moveto delta tail delta rmoveto delta add tail tail rmoveto rmoveto roll bos save eos restore end endprocset beginprocset enc file enc psnfss encoding vector type truetype fonts tex file part psnfss bundle version authors rahtz mackay alan jeffrey horn berry schmidt idea characters included type fonts typesetting effectively characters adobe standard encoding iso latin extra characters lucida euro character code assignments made windows ansi characters windows ansi positions windows users easily reencode fonts makes difference systems windows ansi characters make sense typesetting rubout decimal nobreakspace softhyphen quotesingle grave moved irritation tex positions remaining characters assigned arbitrarily lower part range avoiding case meet dumb software lucida bright includes extra text characters hopes postscript fonts created public consumption include included starting remaining positions left undefined upward-compatible revisions someday characters generally hyphen appears compatibility ascii windows euro assigned windows ansi texbase encoding encoded characters adobe standard windows notdef dotaccent fraction hungarumlaut lslash lslash ogonek ring notdef breve minus notdef remaining unencoded characters include zcaron zcaron caron dotlessi unusual tex characters lucida bright dotlessj ffi ffl notdef notdef notdef notdef notdef notdef notdef notdef contentious painful quoteleft quoteright move things found grave quotesingle ascii begins space exclam quotedbl numbersign dollar percent ampersand quoteright parenleft parenright asterisk comma hyphen period slash colon semicolon equal greater question bracketleft backslash bracketright asciicircum underscore quoteleft braceleft bar braceright asciitilde notdef rubout ascii ends euro notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand scaron guilsinglleft notdef notdef notdef notdef notdef notdef quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright notdef notdef ydieresis notdef nobreakspace exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen windows softhyphen registered macron degree plusminus twosuperior threesuperior acute paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis multiply oslash ugrave uacute ucircumflex udieresis yacute thorn germandbls agrave aacute acircumflex atilde adieresis aring ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis def endprocset beginprocset bbad enc thomas esser dec public domain encoding cmsy cmsy cmsy cmsy cmsy cmsy texbbad fencoding minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus 
circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft arrowright arrowup arrowdown arrowboth arrownortheast arrowsoutheast similarequal arrowdblleft arrowdblright arrowdblup arrowdbldown arrowdblboth arrownorthwest arrowsouthwest proportional prime infinity element owner triangle triangleinv negationslash mapsto universal existential logicalnot emptyset rfractur ifractur latticetop perpendicular aleph union intersection unionmulti logicaland logicalor turnstileleft turnstileright floorleft floorright ceilingleft ceilingright braceleft braceright angbracketleft angbracketright bar bardbl arrowbothv arrowdblbothv backslash wreathproduct radical coproduct nabla integral unionsq intersectionsq subsetsqequal supersetsqequal section dagger daggerdbl paragraph club diamond heart spade arrowleft notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef minus periodcentered multiply asteriskmath divide diamondmath plusminus minusplus circleplus circleminus notdef notdef circlemultiply circledivide circledot circlecopyrt openbullet bullet equivasymptotic equivalence reflexsubset reflexsuperset lessequal greaterequal precedesequal followsequal similar approxequal propersubset propersuperset lessmuch greatermuch precedes arrowleft spade notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef notdef def endprocset beginprocset texps pro texdict begin findfont dup length add dict begin index fid index uniqueid def pop pop ifelse forall index roll exec exch roll vresolution resolution div mul neg fonttype metrics exch def dict begin encoding exch dup type integertype pop pop dup pop ifelse fontmatrix div metrics div def ifelse forall metrics metrics currentdict end def index type nametype exit exch pop loop ifelse index currentdict end definefont roll makefont setfont cvx cvx def def obliqueslant dup sin cos div neg slantfont index mul add def extendfont roll mul exch def reencodefont charstrings rcheck encoding false def dup exch dup charstrings exch pop notdef encoding true def forall encoding exch pop cleartomark ifelse encoding exch def def end endprocset beginfont cmsy ps-adobefontcmsy creationdate aug copyright american mathematical society rights reserved dict begin fontinfo dict dup begin version readonly def notice copyright american mathematical society rights reserved readonly def fullname cmsy readonly def familyname computer modern readonly def weight medium readonly def italicangle def isfixedpitch false def end readonly def fontname cmsy def painttype def fonttype def fontmatrix readonly def encoding array index exch notdef put dup notdef put readonly def fontbbox readonly def uniqueid def currentdict end currentfile eexec ade eaa acb dfe abf bef ded dde eecdda cbf abf ddd ffe efa bbc ecc eeb ccd becd aad affbf dcc abc bff eaeee bed fbffc cdbf cdeb def cleartomark endfont texdict begin course-document dvi start texbase encoding reencodefont courier texbase encoding reencodefont times-bold texbbad fencoding reencodefont cmsy texbase encoding reencodefont times-italic texbase encoding reencodefont times-roman texbase encoding reencodefont times-bold texbase encoding reencodefont times-bold texbase encoding reencodefont times-roman texbase encoding reencodefont times-roman end endprolog beginsetup feature resolution dpi texdict begin papersize letter end endsetup page texdict begin bop document introduction information security somesh jha computer sciences department uni ersity isconsin madison jha wisc view shared resources internet created global-information infrastructure hand shared resources create risks due intentional unintentional malicious beha ior information security area deals protection detection malicious acti vity study fundamentals information security student good understanding eral acets information security syllab basic cryptographic primiti part focus cryptographic primiti follo wing topics detail symmetric-k encryption str eam ciphers linear non-linear feedback shift gisters block ciphers des modes operations public-k encryption rsa elgamal public-k encryption hash functions data integrity basic properties hash functions unk hash functions mdc shay eop end page texdict begin bop hash functions based block stream ciphers based mdcs digital signatur classi cation digital signatures digital signatures related rsa digital signature algorithm dsa otocols section focus protocols arious purposes protocols cryptographic primiti discussed rst part protocols discuss establishment otocols erberos dif e-hellman secret sharing security secure sock ets layer ssl secur payment otocols cybercash digital money digicash system security part focus system security common system vulnerabilities attacks focus tcp syn ooding denial-of-service attacks rele ant material pro vided lecture time list vulner abilities maintained cer coordination center web-page cert located softw engineering institute carne gie mellon uni ersity fir ewalls discuss architecture alls fire alls discussed books required class notes suf cient intrusion detection systems arious types intrusion detection systems discussed intrusion detection systems discussed detail book required time permits discuss open-source intrusion detection system snort great detail information snort found snort special opics time remaining discuss adv anced topics elliptic-curve crypto aphy ecc smartcar eop end page texdict begin bop grading criteria finalized homew orks short home orks assigned class exams xams mid-term nal xams equal weight oject signi project related security students pick projects pro vide refer ences cheswick bello vin rubin walls internet security repelling ily hac addison esle publishing compan northcutt network intrusion detection analyst handbook riders publishing zwick cooper chapman russell building internet walls reilly associates eop end trailer userdict end-hook end-hook eof 
project design document introduction information security due date april tuesday document stallings book refers handbook refers linked handbook class homepage download free reading assignment read section section describes design kerberos authentication system section template design document design document sections project grading design document worth entire project grade nal code worth entire project grade putting lot emphasis design document describing entities section describe entities system bank customer merchant assign short names identi ers bank customer merchant identi ers protocol description page chapter flow messages protocol show messages protocol make format messages depicted showing protocol follow shown page table chapter show format message rationale message follow page table chapter architecture diagram diagram shows components system messages diagram view system follow kerberos overview page figure chapter design review pick team class call team design-review team make designreview team reviews document submit incorporate suggestions mention design-review team design document menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
november note non-secret encryption cocks implementation suggested ellis proposed method encryption involving sharing secret information key lists machine set-ups pluggings sender receiver note non-secret encryption ellis describes theoretical method encryption necessitate sharing secret information sender receiver describes implementation receiver picks primes satisfying conditions divide divide transmits sender sender message consisting numbers sends encoded cin reduced modulo decode receiver finds euclid algorithm numbers satisfying mod mod dip mod diq mod calculated processes involved algorithm involving work order log test prime works fail give answer density primes log picking primes process order log small integer computing cin mod order log computation dip diq smaller coding decoding process requiring work order log factorising process requiring work order log small integer alternatively computing mod requires work order factorization decoding interceptor communication process order possibility non-secret digital encryption ellis cesg research report january note loss security transmitting enemy guess crib crthis information decoding case provide pairs pleases encryption process transmitter 
homework introduction information security due date march tuesday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers sta handbook refers mov linked handbook class homepage download free stated part question equal weight question networking basics points part syn-cookies protect server spoofed addresses part distributed-re ected denial-of-service attack address source-ip syn address source-ip syn ack explain answer terminology malicious flood generator ection server innocent bystander victim attack question hash algorithms points part points problem stalling book part points problem stalling book part points choose random sets persons probability atleast person set shares birthday person set give formula justify answer plot question speci hash algorithms points part points problem stallings book part points problem stallings book mov menezes van oorschot vanstone handbook applied cryptography crc press sta william stallings cryptography network security principles practice prentice hall 
homework introduction information security due date feb thursday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply warm-up homework attended lectures problems easy homework stallings book refers handbook refers linked handbook class homepage download free question playfair cipher points problem stallings book question hill cipher points problem stallings book note typo message phrase read ten louis kruger point question one-time pad points problem stallings book question lfsr-based stream cipher points part assume -stage lfsr shown figure starts initial state generate key stream length show steps part relationship i-th key previously generated keys lfsr part alice bob communicating stream cipher key stream generated -stage lfsr oscar crack stream cipher remember oscar bad guy plaintext attack long plaintext ciphertext oscar justify answer part plaintext attack part depends linearity lfsr solution non-linear generator keys read shrinking generator handbook page describe words stage stage stage stage figure -stage lfsr menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
homework due date november somesh jha computer science department wisconsin madison november question points part express relations figure relations class operators give short justi cation answer part cousinsfatherside cousinsmotherside cousins set cousins separated n-steps father side mother side father mother side write recursive expression relations express relations parameter terms relations parameter basic relations introduced fatherinlaw people males sisterinlaw people females firstcousinsfatherside people people firstcousinsmotherside people people firstcousins people people secondcousinsfatherside people people secondcousinsmotherside people people secondcousins people people figure relations class question points establish equations relations true justify answer enter equations ladybug play assume relations types note symbol denotes empty relation question points question write speci cation problem aim model library types persons books function issued books persons set library set books book issued person issued library represents set books library set books reserve set reserve set books operations issue book operation issues book person book reserve issued issued return book operation models act person returning book adding book library operations models book added library putting book reserve operations models book put reserve book issued put reserve taking book reserve operation models book reserve claims assertions alloy issuing book returning results state book reserve issued claim true operation part write mathematical description operations claims explain answer part write speci cation ladybug part express design alloy part based experience part compare ladybug alloy question points data problem upward exposed analysis determines variables points reached nitions variable basic block nitions reach path nition nition killed setup data problem model checking problem steps outlined class setup model write ctl expression provide xpoint equations provide informal reasoning answer correct give formal proof question points note part form team person implementor tester implementor implement quick sort routine read quick sort algorithm favorite algorithms book description standard library function qsort tester write standard tests test basic functionality quick sort standard test cases write unit testing tester devise test cases meet statement decision coverage criteria notice deriving test cases meet statement decision coverage criteria construct program graph quick sort code comment results note turn code test cases program graph 
homework introduction information security due date feb wednesday note talk classmates instructor problems stated problems written individually wisconsin rules academic misconduct apply homework stallings book refers handbook refers linked handbook class homepage download free question ofb mode points questions output feedback mode ofb part prove encrypt decrypt stages ofb mode work correctly obtains plaintext decryption prove stage prove general i-th stage part explain quote book advantage ofb method bit errors transmission propagate question meet-in-the-middle attack points assume oscar pairs plain cipher texts explain meet-in-the-middle attack des context compute probability oscar succeeds finds correct key pair des question sdes points part problem stallings book part problem stallings book question des points part problem stallings book part problem stallings book menezes van oorschot vanstone handbook applied cryptography crc press william stallings cryptography network security principles practice prentice hall 
relational modeling somesh jha computer science department wisconsin madison introduction model checking verifying concurrency aspects system distributed system admits deadlock model checking expressing invariants data structures list sorted talking data structures relational calculus suitable formalism discuss language called nitpick based relational calculus ladybug tool checks specifications written nitpick operators semantics types relational calculus language types signify domain kind people type denotes set people type domain overloading type denote domain people denotes set people clear context talking types domain basic types entities relational language scalars type simply takes domain type sets types values power set domain relation talk relationships types relation type type type function type type written function special case relation relation type function iff element element related running explain operations nitpick basic types people males females set natural numbers notice relationships hold domains types male person males subset people males people notice talking domain types types relations shown figure frequently type father people males mother people females wife males females husband females males age people brother people males sister people females friend people people figure primitive relations functions depict relation type drawing columns left column corresponds column corresponds edge element represents relation figure shows fragment relation brother edge relation p-related bob snake trent hugh alice wilma marvin figure sample relation note describe operators relational calculus symbol ladybug tool provided set operators relation operators type relation type operators apply sets union ladybug elements -related iff p-related q-related define relation parent parent father mother recall type father people males type mother people females order perform union relations interpreted type people people fortunately function relation males people females people intersection ladybug elements -related iff p-related q-related define relation friendlybrother friendlybrother brother friend difference elements -related iff p-related q-related define relation unfriendlybrother unfriendlybrother brother nfriends subset ladybug notice logical formula evaluates true false formula states elements type p-related q-related logical-formula friendlybrother brother proper subset ladubug logical formula states p-related q-related exists elements q-related p-related exists brother unfriendly siblings friendlybrother brother exclusive set operators scalar set ladybug formula true set scalar set ladybug formula true set relational operators universal relation ladybug cartesian product tuples identity relation ladybug identity relation relates elements domain domp ladybug dom faj set people parents denoted not-orphans equation not-orphans dom parent range range ladybug ran fbj parents set people parents parents set parents range parent domain restriction ladybug set pja domain restricted set item range restriction ladybug set pjb range restricted set denote set numbers equation young dom age based set young derived sets youngwives dom young husband younghusbands range young husband negative domain restriction ladybug set force domain set equation oldwives dom young husband negative range restriction ladybug set pjb force range set set people age equation dom age relational override ladybug dom relational override works domain related elements q-related elements domain related elements p-related succinctly speaking composition ladybug equation dom wife husband marriedmales transpose ladybug tilde character husband wife transitive closure ladybug relation composed times friendoffriend friend reflexive transitive closure ladybug friend friendoffriend friend application single father bob father bob image set range father fbob aliceg fathers bob alice functional domain fdom ladybug fdom fajjp find elements domain related element siblings brother sister singlesibling fdom siblings function predicate fun ladybug fun predicate fun returns true iff relation function element p-related element injection predicate inj predicate true iff transpose function surjection predicate sur range element exists element p-related totality predicate tot domp predicate true iff element element p-related singleton predicate set jsj predicate true iff set element nitpick ladybug ladybug-an improved version nitpick written java ladybug developed craig damon describe small suppose types phones numbers imagine relation called phones numbers function net numbers phones called number called net number relation connection type phones numbers semantics connection called relationship connections called net suppose call number connection made called operation join written range called called called called relation called state assuming net constant function net connection state equation connection called net make calling transpose relation connection function receive call properties listed invb dom connection range connection invc fun connection make invariants true join operation true operation written join invb invb join invc invc exercise expressioninvb short hand expression toinvbwhere connection connection expand expression invb terms called net definition join ladybug ladybug num switch called num denoting entity state prime pretty common formal methods const net num conns conns called net join num switch ran called called called invb switch dom conns ran conns invc switch fun conns invb preserved num join invb invb invc preserved num join invc invc note claims invb invc true ladybug produces counter-example log file produced ladybug shown ladybug beta release copyright loaded phone-modified select claim schema choose check menu double click claim schema completed translation invb preserved required starting found counterexample claim invb preserved called num called num conns conns num net numph found counterexamples checked cases values covered total assignment space required starting completed translation invc preserved required starting found counterexample claim invc preserved called num called num conns conns num net numph found counterexamples checked cases values covered total assignment space required starting exercise explain counter-examples produced ladybug fix specification explain fix properties section discusses properties relational operators properties writing simplifying specifications reflexive relation called reflexive element element related transitive relation called transitive implies symmetric relation called symmetric implies exercise prove properties relational operators associativity monotonicity distributive commutativity transpose closure describe small ladybug illustrates features idiosyncratic modeling language ladybug types relations basic types date basic function book date derived set set satisfies equation dom book writing state variables specifications explicitly cumbersome ladybug macro feature called schemas bundle declarations assertions place schemas referred schemas assertions recursion allowed ladybug fragment types relation defined date book book date set dom book notice book schema defines book relationship book interpret types entities relations functions sets relationships entities corresponds entity-relationship diagram shown figure diagrams depicting basic types relationships names date book dom book figure entity relationship diagram operations insert operation takes date inserts book operation defined mathematically insert date book book schema ladybug insert date book book book notice 
schema insert includes schema book defined supposebookalready pair perform operation insert operation valid delete operation delete set names birthday book operation define delete set book book schema operation ladybug delete set book book book deleteimplicit expressing delete operation deleteimplicit set book book book ladybug schema operation deleteimplicit set book book book book notice ladybug implicit conjunction assertions find find operation finds birthday person find date book book fng schema ladybug find date const book book book notice statement const book means entities inside schema book held constant operation find claims delete undoes insert claim asserts insert operation delete operation results state started deleteundoesinsert date book insert delete book book notice claim indication ladybug deleteundoesinsert claim deleteimplicit implies delete stronger thandeleteor post-condition deleteimplicit stronger delete set book deleteimplicit delete inserting makes assertion states insert operation makes inserting insertmakesknown date book insert inserting means find claim states inserting birthday book means find insertworks date book insert find counter state book perform operation insert case book state performing delete results book book equal book ladybug beta release copyright loaded birthday-book select claim schema choose check menu double click claim schema completed translation deleteundoesinsert required starting found counterexample claim deleteundoesinsert book namedate book namedate date set set found counterexamples checked cases values covered total assignment space required starting entire program entire program shown version spivey birthday book date book book date set dom book insert date book book book delete set book book book deleteimplicit set book book book book find date const book book book deleteundoesinsert date book insert delete book book set book deleteimplicit delete insertmakesknown date book insert insertworks date book insert find 
markov chains classifiers intrusion detection jha tany maxiony abstract paper presents statistical anomaly detection algorithm based markov chains algorithm directly applied intrusion detection discovering anomalous activities framework constructing anomaly detectors general researchers constructing markov-chain-based anomaly detectors present performance metrics evaluating effectiveness anomaly detectors extensive experimental results demonstrate effectiveness algorithm discuss future directions research based framework presented paper introduction intrusion detection system ids system identifies intrusions intrusion defined misuse unauthorized authorized users external adversaries surveys intrusion detection systems found classification intrusion detection systems appears section paper intrusion detection systems based anomaly detection objective anomaly detection establish profiles normal system activity traces system activity deviate profiles considered anomalous alarm raised classes anomaly-detection-based ids signature pattern based ids internal table anomalous patterns ongoing activity matches pattern table alarm raised table patterns represent system traces common attacks examples signature-based intrusion detection systems snort bro advantages signaturebased ids commonly potential low false alarm rates information impart computer sciences department wisconsin madison yschool computer science carnegie mellon pittsburgh system security officer detected attack information encoded rules patterns central functionality systems information invaluable initiating preventive corrective actions signature-based ids disadvantages set anomalous patterns based attacks attacks discovered systems attack discovered patterns attack manually constructed signature-based ids easily fooled sophisticated attacker attacker mix normal activity real attack trace match pre-defined patterns statistical anomaly-detection-based ids henceforth referred statistical ids devised address shortcomings signature-based ids denning nuemann presented detailed discussion statistical anomaly detection algorithm ides prototypical statistical ids statistical ids model normal behavior user constructed statistical model construct classifier discriminate normal anomalous traces techniques presented paper fall category describe procedure generating anomalous patterns statistical model techniques presented paper automatically generate patterns signature-based systems important question anomaly-detection based intrusion detection systems trace system activity represented sequence system calls process trace activity knowledge proposed approach general types traces system activity audit trails statistical approach intrusion detection adheres general strategy set normal traces statistical model constructed statistical model construct classifier discriminate normal abnormal traces key observation statistical model accurate predictor normal behavior on-going activity accurately predicted model anomalous general strategy depicted figure approach general road-map set normal traces construct markov chain markov chain construct classifier main contributions paper provide formal framework constructing classifiers based markov chains investigate applications classifiers intrusion detection provide metrics evaluating effectiveness classifiers context intrusion detection metrics researchers framework general construct classifiers based markov chains outline paper section general outline algorithm detailed description algorithm section section describes algorithm generating set anomalous patterns markov chains algorithm suitable generating anomalous patterns systems snort bro experimental results section section describes related work future work concluding remarks provided section outline methodology section provide step-wise description methodology technical details section assume suites traces tan recall case trace simply sequence system calls generated process suite consists traces normal activity tan consists traces anomalous activity attacks step construct test suite step split suite suite ttr called training suite constructing classifiers suite tte called test suite testing classifiers tuning parameters decide ratio call testing ratio random sampling construct ttr tte trace generate random number uniformly distributed range trace added tte added ttr roughly speaking denotes fraction traces test suite tte step construct classifier training suite ttr construct markov chain turned classifier traces classifier constructed suite normal traces discriminate normal anomalous traces details construction found section step tuning parameters exogenous parameters construction classifier define performance metrics classifier metrics computed suites tte tan exogenous parameters tuned performance metrics detailed description denote set alphabets symbols alphabets symbols synonymously paper trace finite sequence alphabets set finite traces denoted empty trace denoted set traces length denoted trace denotes length trace trace positive integer denote prefix consisting alphabets i-th symbol concatenation traces denoted denotes binary alphabet set definition classifier alphabet set total function suite subset experiments types suites training suite ttr training test suite tte testing anomalous suite tan set anomalous traces training suite set normal traces construct classifier test suite set normal traces test tune classifier anomalous suite set anomalous abnormal traces note reader interpret bad good context intrusion detection classifier outputs reading trace interpreted alarm anomalous happening hand normal behavior general classification problem finite number classes universe objects classified classifier function context intrusion detection classify traces normal anomalous intrusion detection on-line activity alarms raised real-time purposes intrusion detection unacceptable watch entire sequence activities equivalently scan entire trace classify sequence formalize sample normal behavior statistical model classifiertrace processbehavior normal anomalous alarms figure general strategy intrusion detection means classifier on-line intuitively on-line classifier efficiently classify trace length based history classifier prefix symbols definition classifier called on-line exists efficiently computable functions equations hold equations length trace denoted types functions easily inferred equations notice function trace depends function symbols trace sense depends history efficiently computed loosely speaking function markov depends history current state assume finite set traces classifier outputs scanning trace suffix set classifier outputs words classifier outputs alarm detects pattern set faaa baag classifier outputs scanning acaaa acbaaa classifiers model signature-based intrusion detection systems set finite traces compiled deterministic precise definition efficiently computable depends statistical model case efficiently computable means polynomial number states markov chain finite state automata observation easily signature based ids corresponds online classifier finite table patterns regular language alphabet trace iff suffix trace deterministic finite state automata definition next-state transition function automata transition function extended traces standard manner identifier state initial state automata function simply mimics next-state transition function equality assume state automate identifier real number function maps identifier final state automata rest real numbers mapped easy verify required properties efficiently computable constructing markov chains assume training suite ttr suite ttr construct markov chain subsection demonstrate construct classifier markov chain construction markov chain parametrized window size augment alphabet set special null symbol provide background markov chains paper interested readers consult standard text probability theory required background describe algorithm construct markov chain suite ttr define primitive operations state markov chain trace length alphabet transition pair states pair denotes transition state transition counter maintain hash table visited states hash function hash table crucial description algorithm primitive operation shift shifts trace left appends alphabet end shift aba equal bac initial state markov chain denoted initialstate 
trace length consisting null symbols initial state trace operation returns symbol trace left shifts position abc returns updates trace trace ttr execute steps alphabets scanned set next-state shift current-state increment counter state current-state transition current-state next-state update current-state next-state traces suite ttr processed state transition positive integer probability transition counters transition words probability transition ratio frequency transition frequency source suite ttr assume training suite ttr faabc abcbcg structure constructed scanning traces training suite ttr shown figure figure shows counters states transitions markov chains classifiers assume markov chain training suite ttr window size constructed denote markov chain -tuple set states denotes transition probabilities initial state probability transition denoted order valid measure equality hold states succ succ denotes set successors trace length state denotes recall trace initial state trace consisting null alphabets trace recall denotes alphabet trace initial trace trace initial state trace scanning symbol shift trace obtained scanning k-th symbol recursively defined shift trace defines sequence traces trace length define metric trace metric based markov chain computed iteratively initially equal equal execute steps cases case valid transition states markov chain update equations case state valid transition update equations increment metric defined end procedure procedure outlined defines function intuitively metric measures markov chain predicts trace lower markov chain predicts trace notice parametrized functions number choices result classifiers aab abc bcb cbc figure markov structure assume threshold classifier constructed metric manner words trace classified bad metric threshold note easily classifier on-line definition define function variables defined procedure computing function definition easily derived description procedure compute function classifier construct on-line classifier complexity functions linear number states markov chain discussion trace metric depends entire trace recall procedure maintains cumulative values metric defined call metric global classifier based global metric called global describe local classifier recall trace corresponds sequence traces trace length positive integer scanning i-th symbol trace history size minimum history size corresponds vectors defined valid transition states markov chain case defined state case defined local metric trace defined yip min words local metric computed history past symbols classifier based local metric called local classifier implemented local classifiers system experiments global classifiers consistently out-performed local counterparts presented results local classifiers discuss common functions depending choice functions obtain classifiers miss-probability metric case functions defined succ succ function adds probabilities transitions state equal words scanning trace low probability transition higher miss-rate metric pmax max succ pmax case transition equal maximal transition transition maximum probability penalized equally local-entropy-reduction metric state local entropy state denoted succ log entropy markov chain steady state probability state descriptions markov chains entropy found functions case defined log transition expression log evaluates succ log words denotes residual local entropy state deleting transition local entropy reduction due taking transition performance metrics section discuss performance metrics evaluating effectiveness classifier assume constructed classifier training suite ttr tte tan denote test anomalous suite trace number alarms classifier generates denoted alarm expression words number alarms number classifier generates scanning trace test suite tte consists normal traces percentage false alarms test suite tte classifier expression tte alarm tte percentage false alarms classifier generates test suite tte denoted tte high percentage false alarms undesirable alarm ids attended system administrator experience system administrator encounters high percentage false alarms turn ids anomalous traces good classifier generate alarm quickly anomalous traces define time alarm mtfa anomalous trace classifier generate alarm scanning dmtfa symbols classifier trace alarm defined minfijf words scanning trace classifier generates alarm reading alarm -th symbol mtfa anomalous suite tan classifier denoted mtfa tan expression tan alarm jtanj expression jtanj denotes number traces tan size suite intuitively speaking metric mtfa measures fast classifier detects anomalous trace generalize metric mtfa time k-th alarm mtka time classifier generates k-th alarm paper mtfa tuning parameters recall method exogenous parameters constructing classifier training suite ttr parameters window size functions real number threshold assume functions real number determined discuss decide values parameters window size increases markov chain constructed model training suite ttr large markov chain models training suite classical over-fitting problem statistics metric defined earlier intuitively measure discrepancy markov chain trace lower denotes fit discrepancy ttt entire test suite ttt ttt ttt discrepancy tan anomalous suite tan defined similar manner increasing window size separation tan ttt anomalous test suites threshold means classifier discriminate anomalous normal traces provide detailed account experimental section assume window size determined describe set threshold threshold low anomalous trace classifier generate alarm quickly low means lower mtfa lower threshold generates false alarms normal traces inconvenient system administrator tradeoff setting threshold low set threshold percentage false alarms test suite mtfa anomalous suite acceptable level details tuning parameters found experimental section generating anomalous patterns classifiers intrusion detection systems commercially signature-based systems recall signature-based ids relies table anomalous patterns suffix trace activity matches pattern table alarm raised patterns table correspond common attacks simply patterns represent normal behavior system classifiers constructed markov chains discussed section general simply table patterns fit current architecture systems section address mis-match describe algorithm constructs table anomalous patterns markov chain constructed training suite ttr recall markov chain -tuple set states denotes transition probability initial state reader refer subsection explanation terms metric defines total order traces procedure computing metric subsection procedure subsection started initial state procedure started state markov chain defines metric intuitively defines metric initial state markov chain recall state unique trace length state trace synonymously section xmg alphabet set context system calls suites algorithm based function pattern function returns set trace satisfy conditions trace length equal number traces equal traces exists trace words represents set traces length equal highest s-value represent worse traces length equal give recursive definition function pattern recursion parameter base case case pattern words set traces patterns empty trace recursion state trace shift words trace constructed shifting trace appending i-th alphabet assume set traces pattern computed states give definition set pattern terms sets pattern pattern sake brevity denote set pattern suppose transition corresponds alphabet trace shift trace state construct set formally defined fxi wig words add front trace compute metric trace sets construct set traces expression pattern traces sorted values function intuitively sort traces denotes markov chain model trace traces 
bad fits set pattern defined traces sorted order correctness trace thatj pattern prove exists trace pattern prove result induction result obvious trace length empty trace assume result true induction hypothesis exists pattern notice construct set pattern sorting set metric pattern exists trace pattern result proved suppose alphabet state shift set pattern suffix starting symbol induction hypothesis cases case pattern trace set pattern set sorted metric result case pattern case exists pattern nature metric inequality easily notice set result improving efficiency notice efficiently computed metrics paper time transition probabilities transition corresponds alphabet recall procedure computing metric suppose trace initial state information computed -time values trace initial state valid transition markov chain values trace metric trace simply trace set pattern values traces recursive step efficient compute pattern store re-use called memeoazation number traces denoted length alphabet easily checked algorithm modifications runs nlk steps step log time notice worst case complexity algorithm exponential size alphabet suspect practice algorithm run faster computational complexity problem heuristics improving efficiency left future work algorithm generates set anomalous traces markov chain trained suite normal traces suppose train markov chain mcan suite anomalous traces case generate set patterns traces fit markov model mcan easily variant algorithm sorting descending order metric sort ascending order obtain traces low -value fit markov model mcan experimental results suites study obtained large body work performed researchers computer science department mexico evaluating anomaly-detection algorithms original experiments employed suites results published data consists traces privileged unix programs trace operating anomalydetector called stide trace sequence system calls issued single process execution privileged programs targeted monitoring misuse greatest harm host noted system calls recorded traces parameters passed system calls datasets comprises data obtained wide variety circumstances data obtained monitoring normal usage program field data obtained monitoring programs run daemons programs vary widely size complexity kinds intrusions importantly provide insight algorithm perform field body data consists combination live synthetic traces live defined traces programs collected normal usage production computer system synthetic defined traces collected production environments running prepared script program options chosen solely purpose exercising program meet real user requests anomalous data obtained recording system calls monitored programs intrusion present intrusions obtained public advisories posted internet detailed information kinds intrusions dataset found table shown figure lists programs monitored normal behavior names intrusions deployed obtain intrusive data figures show difference discrepancy anomalous test suite classifiers column table corresponds number suite subsequent columns show results window sizes construct markov chain column shows results window size construct markov chain component entry corresponds test suite component shows results anomalous suite set window size classifier discrepancy test anomalous suites suites normal trace leave traces construct test suite cases mark component test suite dan dtt discrepancy test anomalous suite ideally dan dtt large means classifier test suite worse anomalous suite observing data points made suites start observing difference discrepancies suite difference discrepancies pronounced window size suite difference significant window size classifiers based miss-probability miss-rate metric outperform based local-entropy metric results classifiers based missprobability miss-rate comparable suite set window size difference discrepancies dan dtt acceptable level set window size suite suites window size set initially threshold set dan dtt average discrepancies anomalous test suites suites normal trace case dtt cases set initial threshold dan conducted experiments thresholds initial threshold lower threshold means mtfa anomalous suite low generate alarm earlier anomalous trace lower threshold means percentage false alarms test suite large tradeoff setting threshold conducted extensive experiments thresholds sake brevity report results threshold values classifier based miss-probability metric figure shows experimental results initial threshold observations made data percentage false alarms decreases threshold increases time alarm mtfa increases threshold increases suites show mentioned behavior results suite dataset system normal anomalous intrusion synthetic xlock linux traces traces buffer overflow calls calls live xlock linux trace traces buffer overflow calls calls live named linux traces traces buffer overflow calls calls live login linux traces traces trojanized login calls calls program live linux traces traces trojanized calls calls program live inetd linux traces traces denial calls calls service live lpr mit sunos traces traces symbolic link calls calls attack live lpr unm sunos traces traces symbolic calls calls attack live stide linux traces traces denial calls calls service figure explanation data sets false alarm rates suites low recall suite difference discrepancies large remark classifier generates alarm scanning anomalous trace trace classified anomalous hit rate classifier defined percentage traces anomalous suite tan classified anomalous experiments discovered hit rate close hit rate good metric classifiers considered paper percentage false alarms time alarm measures effectiveness devising metrics quantifying classifiers received scarce attention intrusion detection literature related work compare work intrusion detection schemes based statistical anomaly detection pointed intrusion detection system ides ides large scale system considered classes events considered traces system calls direct comparison ides technique compare technique recent statistical anomaly detection schemes nassehi describes anomaly detection scheme based markov chains anomaly detection algorithm presented paper nassehi constructs markov chain window size vector normalized frequencies transitions markov chain based sample training ongoing activity traced markov chain maintaining history window vector normalized frequencies transitions history alarm raised condition holds matrix threshold detail number transitions states markov chain time symbol scanned time required prohibitively expensive large intrusion detection systems contrast anomaly detection scheme requires constant time symbol scanned warrender hidden markov models hmms underlying model results reported comparable presented paper training algorithm hmms expensive runs time number states hmm size trace contrast training time markov chains symbol case system call method takes time anomaly detector takes constant time process symbol generate alarms faster undertaken rigorous study hmms anomaly detection work ongoing report results future date instance learning based algorithm anomaly detection algorithm masquerade detection user acting user started investigating techniques extending algorithm masquerade detection applications anomaly detection uncovering stealthy portscans devising algorithm similar presented paper detecting stealthy port scans section describes algorithm generating anomalous patterns markov models implemented algorithm provide detailed comparison algorithm algorithms data mining based technique generating anomalous patterns rules intrusion detection system based information retrieval techniques approach discovering anomalous patterns rules based inductive learning presented implementation algorithm finished perform detailed comparison approach techniques 
obvious connections hypothesis testing intrusion detection markov model constructed test suite trace testing hypothesis generated distribution implied markov model reject hypothesis trace anomalous trace algorithm hypothesis testing apriori bound number trials sequential probability ratio test developed abraham wald plan investigate literature hypothesis testing detail order find connections algorithm future work directions future work improve space time efficiency algorithms methodology investigate computation complexity algorithm generating anomalous patterns section devise heuristics improving efficiency algorithm generate models traces system calls investigate events related system activity audit trail data network traffic markov-chain based classifier paper implemented part library developed wisconsin innumber figure results miss-probability metric number figure results miss-rate metric number figure results local-entropy-reduction metric number mtfa mtfa mtfa figure results thresholds corporate statistical models hidden markov models library goal incorporate wide variety classification techniques test effectiveness context intrusion detection plan implement algorithms existing intrusion detection systems snort bro interested investigating specialized applications statistical anomaly detection algorithm detecting stealthy port scans conclusion paper presented anomaly detection algorithm based markov chains presented general framework constructing classifiers markov chains presented specific classifiers based framework performance metrics test classifiers defined experimental results demonstrated effectiveness approach classifiers easily incorporated intrusion detection system paper creates avenues future work previous section pursuing directions acknowledgement referees csfw helpful comments thankful referee pointed connection hypothesis testing allen christie fithen mchugh pickel stoner state practice intrusion detection technologies technical report cmu sei-tr- software engineering institute carnegie mellon january anderson khattak information retrieval techniques intrusion detection proceedings international workshop recent advances intrusion detection raid september cormen leiserson rivest introduction algorithms mit press cover thomas elements information theory john wiley sons denning nuemann requirements model ides real-time intrusion detection expert system technical report technical report csl sri international august devroye gyorfi lugosi probabilistic theory pattern recognition springer verlag durrett probability theory examples duxbury press edition elliott aggoun moore hidden markov models estimation control springer verlag forrest hofmeyr somayaji longstaff sense unix processes ieee symposium security privacy pages hogg tanis probability statistical inference prentice hall ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march lane brodley temporal sequence learning data reduction anomaly detection acm transactions information system security august lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy lunt automated audit trail analysis intrusion detection survey proceedings -th national computer security conference baltimore pages october lunt tamaru gilham jagannathan neumann javitz valdes garvey real-time intrusion detection expert system ides -final technical report technical report technical report computer science laboratory sri international menlo park california february mcauliffe schaefer wolcott haley kalem hubbard computer misused proceedings sixth computer security applications conference pages december mukherjee heberlein levitt network intrusion detection ieee network june nassehi anomaly detection markov models technical report tech report ibm research division zurich research laboratory march northcutt network intrusion detection analyst handbook riders nuemann compartive anatomy computer system network anomaly detection technical report csl sri bnmenlo park paxon bro system detecting network intruders real-time proceedings -th usenix security symposium san antonio texas roesch snortlightweight intrusion detection networks proceedings usenix lisa conference november staniford hoagland mcalerney practical automated detection stealthy portscans proceedings acm ccs ids workshop november teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy pages wald sequential analysis john wiley sons warrender forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy pages 
formal analyses attack graphs jha computer sciences department wisconsin madison e-mail jha wisc sheyner wing computer science department carnegie mellon pittsburgh e-mail fsheyner wingg cmu abstract attack graph succinct representation paths system end state intruder successfully achieved goal today red teams determine vulnerability networked systems drawing gigantic attack graphs hand constructing attack graphs hand tedious error-prone impractical large systems viewing attack violation safety property off-the-shelf model checking technology produce attack graphs automatically successful path intruder viewpoint counterexample produced model checker paper present algorithm generating attack graphs model checking subroutine security analysts attack graphs detection defense forensics paper present minimization analysis technique analysts decide minimal set security measures guarantee safety system provide formal characterization problem prove polynomially equivalent minimum hitting set problem present greedy algorithm provable bounds present reliability analysis technique analysts perform simple costbenefit trade-off depending likelihoods attacks interpreting attack graphs markov decision processes iteration algorithm compute probabilities intruder success attack graph keywords attack graph model checking minimization analysis reliability analysis markov decision processes network vulnerability security jha supported office naval research contracts shyener wing supported defense advanced research projects agency army research office aro contract daad views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied dod aro onr government motivation networks hosts continue grow evaluating vulnerability attacks increasingly important automate evaluating security network presence absence isolated vulnerabilities large network builds multiple platforms diverse software packages supports modes connectivity inevitably network security holes escaped notice diligent system administrator evaluate vulnerability network hosts security analyst account effects interactions local vulnerabilities find global vulnerabilities introduced interconnections typical process vulnerability analysis network shown figure scanning tools determine vulnerabilities individual hosts local vulnerability information information network connectivity hosts analyst produces attack graph path attack graph series exploits call atomic attacks leads undesirable state state intruder obtained administrative access critical host attack graphs intrusion detection attack graphs serve basis detection defense forensic analysis motivate study attack graphs attack graph generation algorithms discuss potential applications attack graphs areas security detection system administrators increasingly deploying intrusion detections systems idss detect combat attacks network systems depend software sensor modules detect suspicious events activity issue alerts setting sensors involves trade-off figure vulnerability analysis network sensitivity intrusions rate false alarms alert stream sensors set report suspicious events sensors frequently issue alerts benign background events results administrators turning ids hand decreasing sensor sensitivity reduces ability detect real attacks deal problem intrusion detection systems employ heuristic algorithms correlate alerts large pool heterogeneous sensors valdes skinner describe probabilistic approach alert correlation successful correlation multiple alerts increases chance suspicious activity alerts fact malicious attack graphs enhance heuristic probabilistic correlation approaches graph describing attacks sequences attacker actions ids match individual alerts attack edges graph matching successive alerts individual paths attack graphs dramatically increases likelihood network attack on-line vigilance ids predict attacker goals aggregate alarms reduce volume alert information analyzed reduce false alarms rates knowledge attacker goals steps helps guide defensive response defense benefit attack graphs analyze potential effectiveness intrusion detections systems offline section show attack graphs generated automatically models network show incorporate security policy intrusion detection system model generate attack graphs specific network configurations attack graphs enable administrator perform kinds analysis assess security marking paths attack graph ids detect determining position ids components coverage exploring trade-offs security policies software hardware configurations identifying worst-case scenarios prioritizing defense forensics break-in forensic analysis find probable attacker actions assess damage legal action desired analysts seek evidence sequence sensor alerts comprises coherent attack plan series isolated benign events task harder intruders obfuscate attack steps slowing pace attack varying specific steps suggested convincing argument malicious intent intruder actions constructed matching data extracted ids logs formal model based attack graphs contributions constructing attack graphs crucial part performing vulnerability analysis network hosts red teams produce attack graphs hand drawing gigantic diagrams floor-to-ceiling whiteboards hand tedious error-prone impractical attack graphs larger hundred nodes demonstrated earlier work model checking applied automatically generate attack graphs paper show attack graphs produced method exhaustive covering attacks succinct relevant states section provide formal detailed explanation model definitions based finite-state model network state transitions standard preand post-conditions state transition corresponds single atomic attack intruder state model represents state system atomic attacks typical transition state state corresponds atomic attack preconditions satisfied effects hold state attack sequence state transitions culminating intruder achieving goal entire attack graph representation ways intruder succeed discussed attack graphs perform variety analysis specifically attack graphs answer questions interest system administrator question successful attacks undetected ids question measures set implemented network safe secure question set measures smallest subset measures implementation makes network safe answers questions analyst network administrator choosing upgrade strategy questions addressed section modeling system operating uncertain environment transitions model represent system reaction environment transitions system control occur triggered environment empirical information relative likelihood environment-driven transitions model nondeterministic choices made environment vulnerabilities data estimating probabilities empirical data make assign probabilities environment-driven transitions advantage information quantify probabilistic behavior attack graphs context system administrator interested question question deployment security measure increase likelihood thwarting attacker answer question provided section system administrator answer question perform quantitative evaluation security fixes main contributions paper earlier work paper explores semantics network model formally earlier work proved finding minimum set atomic attacks removed thwart intruder np-complete paper explore complexity problem section proves problem polynomially equivalent minimum hitting set problem collection sets represented labeled directed graph reduction additional insight enabled find greedy algorithm provable bounds answer questions paper presents algorithm compute reliability defined likelihood intruder succeeding network desirable feature algorithm incomplete information probabilities transitions provided knowledge previous metrics area security require complete information related work provided section section describes model model checking based algorithm generate attack graphs network presented section section describes network model detail network paper illustrative purposes section present analysis helps answers questions section describes probabilistic attack graphs algorithm compute reliability answer question provided section proof correctness algorithm compute reliability based markov decision processes presented companion technical report finally directions future work concluding remarks presented section related work phillips swiler propose concept attack graphs similar attack-centric view system work general input language model seemingly benign system events failure link user errors attacks 
occur simultaneously attack graphs general proposed phillips swiler based ideas tool generating attack graphs presented tool constructs attack graph forward exploration starting initial state symbolic model checker nusmv works backward goal state construct attack graph major advantage backward algorithm vulnerabilities relevant safety property goal intruder explored result significant savings space fact swiler refer advantages backward search paper model checking leverage sophisticated reduction techniques developed area post-facto analysis suggested phillips swiler presented paper plan incorporate analysis tool dacier proposes concept privilege graphs node represents set privileges owned user arcs represent vulnerabilities privilege graphs explored construct attack state graphs represents ways intruder reach goal root access host based attack state graphs metric called effort failure metf proposed experimental evaluation framework orlato surface notion attack graphs similar proposed dacier case phillips swiler dacier takes attack-centric view world pointed earlier attack graphs general experiments conducted orlato appears small examples space required construct attack state graphs prohibitive model checking made significant advances representing large state spaces basing algorithm model checking leverage advances hope represent large attack graphs analytical analysis proposed dacier performed attack graphs constructed tool plan conduct experimental evaluation similar performed orlato ritchey amman model checking vulnerability analysis networks unmodified model checker smv obtain counter-example attack intruder goal contrast modified model checker nusmv produce complete attack graphs represents attacks analysis performed attack graphs analysis techniques meaningfully performed single attacks generating attack graphs model checking formally define attack graphs data structure represent attacks networked system restrict attention attack graphs representing violations safety properties definition set atomic propositions attack graph tuple set states transition relation set initial states set success states labeling states set propositions true state intuitively denotes intruder goals obtaining root access critical host stated assume transition relation total define execution fragment finite sequence states execution fragment liveness properties section execution execution final state attack execution corresponds sequence atomic attacks leading intruder goal state turn attention algorithms automatic generation attack graphs starting description network model security property task construct attack graph representing executions violate successful attacks kinds attack graph analysis suggested section essential graphs produced algorithms exhaustive succinct attack graph exhaustive respect model correctness property covers attacks leading violation succinct states system state violating reachability analysis restrict safety properties attack graph constructed performing simple statespace search starting initial states model graph traversal procedure depth-first search find reachable success states safety property violated attack graph union paths initial states success states algorithm advantage simplicity handles safety properties run state explosion problem non-trivial models model checking dealt issues success algorithms based technology model checking algorithm model checking technique checking formal model system satisfies property work model checker nusmv model finite labeled transition system property expressed computation tree logic ctl safety properties ctl form agf agf formula propositional logic model satisfies property nusmv reports true satisfy nusmv produces counter-example single counterexample shows execution leads violation property section explain construct attack graphs safety properties model checking attack graphs depict ways system reach unsafe state equivalently successful state intruder express property unsafe state reached unsafe property false unsafe states reachable initial state precise meaning input set states transition relation set initial states labeling states propositional formulas unsafe safety property output attack graph sunsafe sps algorithm generateattackgraph model checking find set states sunsafe violate safety property unsafe sunsafe modelcheck restrict transition relation states set sunsafe sunsafe sunsafe sunsafe sps fsjs sunsafe unsafeg return sunsafe sps figure algorithm generating attack graphs unsafe depends application network security section property express privilege level intruder host index root administrative privilege network adversary privilege network priv root briefly describe algorithm constructing attack graphs property unsafe step determine set states reachable initial state algorithm computes set reachable states sunsafe path unsafe state set states sunsafe computed iterative algorithm derived fix-point characterization operator transition relation model transition state restricting domain range sunsafe obtain transition relation represents edges attack graph attack graph sunsafe sps sunsafe represent set nodes edges graph sunsafe set initial states sps fsjs sunsafe unsafegis set success states algorithm figure symbolic model checkers nusmv transition relation sets states represented bdds compact representation boolean functions efficient bdd algorithms operations algorithm shown figure attack graph properties show attack graph generated algorithm figure exhaustive lemma succinct respect states edges lemma proof lemma straightforward definitions lemma properties attack graph true exhaustive execution input model violates property unsafe attack attack graph sunsafe sps succinct respect states state input model attack graph attack succinct respect edges edge input model attack graph attack includes simple intrusion detection network shown figure target hosts firewall separating rest internet shown host running services ftp sshd database intrusion detection system ids monitors network traffic target hosts figure network world atomic attacks identified numerically sshd buffer overflow ftp rhosts remote login local buffer overflow atomic attack detectable intrusion detection system trigger alarm attack stealthy ids misses ftp rhosts attack find target host vulnerabilities writable home directory executable command shell assigned ftp user local buffer overflow exploits vulnerable version xterm executable section construct finite state model network state transition corresponds single atomic attack intruder state model represents state system atomic attacks typical transition state state corresponds atomic attack preconditions satisfied effects hold state intruder launches attack starting single computer ipa lies firewall eventual goal disrupt functioning database intruder root access database host states finite state machine model network model network set facts represented relational predicate state network specifies services host vulnerabilities connectivity remote login trust relationship hosts boolean variables host modeled services running vulnerabilities present host variable meaning sshh ssh service running host ftph ftp service running host datah database running host wdirh ftp home directory writable host fshellh ftp user executable shell host xtermh xterm executable vulnerable overflow host connectivity expressed ternary relation host host port means host reachable host port constants refer specific ports ssh ftp services slightly abusing notation write network route similarly model trust binary relation rshtrust host host rshtrust user log host host authentication host trusts host intruder function plvla hosts fnone user rootg level privilege intruder host total order privilege levels user root state variables attack intruder attempt variable meaning attack attack 
type source source host target target host strain stealthy detectable attack intrusion detection system atomic attacks classified detectable stealthy respect intrusion detection system ids attack detectable trigger alarm executed host network segment monitored ids attack stealthy ids detect ids function ids host host attack ids attack detectable executed source host target host ids attack stealthy executed source host target host ids attack detectable stealthy strains success detecting attack depends strain refer host ids specifies intrusion detection system component located host refer hosts ids specifies intrusion detection system component monitoring network path addition global boolean variable specifies ids alarm triggered previously executed atomic attack initial states initially trust hosts trust relation empty connectivity relation shown table entry table corresponds pair hosts entry triple boolean values connected physical link connect ftp port connect sshd port ipa ipa connectivity relation reflect firewall rule sets existence physical links table firewall open place restrictions flow network traffic initially intruder root privileges machine ipa privileges hosts paths ipa ipa monitored single network-based ids path monitored hostbased intrusion detection components ids detects remote login attack detectable strains sshd buffer overflow attack transitions model nondeterministic state transitions current state network satisfies preconditions atomic attack rule intruder nondeterministically chooses attacks state effects clause chosen attack rule intruder repeats process goal achieved model atomic attacks description designate source host target host denotes host reachable host port sshd buffer overflow remote-to-root attack immediately remote user root shell target machine attack sshd-buffer-overflow intruder preconditions user-level privileges host plvla user root-level privileges host plvla root network preconditions host running sshd ssht host reachable port intruder effects root-level privileges host plvla root network effects host running sshd ssht end ftp rhosts ftp vulnerability intruder creates rhosts file ftp home directory creating remote login trust relationship machine target machine attack ftp-rhosts intruder preconditions user-level privileges host plvla user network preconditions host running ftp ftpt host reachable port ftp directory writable host wdirt ftp user assigned valid shell host fshellt rsh trust host rshtrust intruder effects network effects rsh trust hosts rshtrust end remote login existing remote login trust relationship machines intruder logs machine user shell supplying password operation legitimate action performed regular users intruder viewpoint atomic attack attack rsh-login intruder preconditions user-level privileges host plvla user privileges host plvla network preconditions rsh trust rshtrust host reachable intruder effects user-level privileges host plvla user network effects end local buffer overflow intruder acquired user shell target machine step exploit buffer overflow vulnerability setuid root file gain root access attack intruder preconditions user-level privileges host plvla user network preconditions vulnerable xterm executable xtermt intruder effects root-level privileges host plvla root network effects end easy atomic attack strictly increases intruder privilege level target host remote login trust hosts means attack graph cycles finite model automatically construct attack graphs demonstrate intruder violate security properties suppose generate attacks demonstrate intruder gain root privilege host remain undetected ids ctl formula expresses safety property intruder host privilege level root detected expressed ctl property network adversary privilege network priv rootj network detected figure shows attack graph produced tool property node labeled attack number corresponds atomic attack attempted flag attack stealthy detectable intrusion detection system numbers source target hosts ipa corresponds host number path graph root node leaf node shows sequence atomic attacks intruder employ achieve goal remaining undetected instance path highlighted double-boxed nodes consists sequence atomic attacks overflow sshd buffer host overwrite rhosts file host establish rsh trust hosts log rsh host host finally overflow local buffer host obtain root privileges expanded adding additional hosts additional atomic attacks vulnerabilities flexible firewall configurations larger attack graph nodes edges figure attack graph figure attack graph analysis minimization analysis attack graph generated specific network respect safety property utilize analysis analyst faced choice deploying additional network attack detection tools prevention techniques analyst set measures deploying additional network detection tools upgrading software section answers questions posed section question successful attacks undetected ids answer answer question modify model slightly making subset atomic attacks intruder simplicity nondeterministically decide subset initially attack begins choice made subset atomic attacks fixed attack ran model checker modified model invariant property intruder obtains root privilege host network adversary privilege network priv root post-processor marked states intruder detected ids result shown figure white rectangles states attacker detected intrusion detection system black rectangles states intrusion detection system sounded alarm white leaf nodes desirable attacker objective achieved detection black leaf nodes desirable attacker achieves objective alarm resolution atomic attacks intruder circular nodes root graph transition root initial state picks subset attacks intruder child root node root disjoint subgraph subset atomic attacks chosen child note number subgraphs descending root node corresponds number subsets atomic attacks intruder successful model checker determines subset successful sequence atomic attacks root graph figure subgraphs subsets atomic attacks intruder succeed left subgraph sshd buffer overflow attack intruder readily intruder succeed remaining undetected ids subgraph attacks entire attack graph implies atomic attacks sshd attack indispensable intruder succeed analyst information guide decisions network defenses profitably upgraded white cluster middle figure isomorphic attack graph presented figure shows attacks intruder achieve objective detection paths intruder reaches white leaf graph proceed provide answers questions define attack graph edges labeled atomic attacks produced postprocessor attack graph perform analysis answer questions assume produced attack graph safety property unsafe set atomic attacks attack graph set states set edges initial state success state intruder gis labeling function edge corresponds atomic attack edges labeled represent system transitions correspond atomic attack demonstrated additional edges introduced construction loss generality assume single initial success state attack graph multiple initial states success states sus add initial state success state -labeled edges sts suppose finite set measures mkg function covers atomic attack covers adopting measure removes atomic attack question measures set implemented network safe secure answer network administrator find adopting measures set make network safe question answered linear time attack graph define covers ass covers remove edges gsuch covers network safe iff success state reachable initial state simple reachability question answer time linear size graph question set measures smallest subset measures implementation makes network safe answer network administrator wishes find subset 
smallest size adopting measures set make network safe problem np-complete develop good approximation algorithms proceed steps step finding small set atomic attacks step find set atomic attacks removal makes network safe checking subset attacks exponential number attacks related paper show finding minimum set atomic attacks removed thwart intruder fact np-complete demonstrated minimal set found polynomial-time paper explore complexity problem section proves problem finding minimum set attacks polynomially equivalent minimum hitting set problem collection sets represented labeled directed graph reduction additional insight enabled find greedy algorithm provable bounds step finding small set measures assume find set atomic attacks removal makes network safe equivalently thwarts intruder recall mkg set measures covers function covers represents set atomic attacks removed adopting measure attack set associate set measures isfmi covers set attacks defines collection subsets find smallest subset exists covers equivalently minimum hitting set problem np-complete good approximation algorithms exist solve problem section minimum critical attack sets minimum hitting set problem section addresses step answer question assume attack graph set states set edges initial state success state intruder labeling function state set attacks critical respect intruder reach goal attacks removed arsenal equivalently critical respect path success state edge labeled attack critical set state minimum denoted critical set general multiple minimum sets state minimum critical sets size critical set attack graph defined critical set initial state minimum critical set attacks mcsa problem problem finding minimum critical set attacks decision version problem defined attack graph positive integer critical set attacks asuch thatjaj assume give attack graph path sequence states complete path starts initial state ends success state label path abusing notation denote subset set attacksa gnf represents set atomic attacks path set attacks ais called realizable attack graph iff exists complete path words intruder set attacks start initial state reach success state set realizable sets attack graph denoted rel lemma easy prove straight definitions lemma assume give attack graph set attacks critical iff rel words realizable sets non-empty intersection critical set ssw qqs xxxx xxz figure attack graph representing exponential number realizable sets definition hitting set problem instance collection subsets finite set positive integer jsj question subset withjs element subset discussion appendix proves problem finding critical sets attack graph polynomially equivalent finding hitting sets collection caveat collection sets represented attack graph attack graph exponentially succinct representation collection sets figure shows attack graph linear size set realizable sets power set sng minimum critical set problem polynomially equivalent hitting set problem collection sets represented labeled directed graph greedy algorithm describe greedy algorithm greedyhitting-set minimum hitting set problem instance hitting set problem initially empty set greedy algorithm executes steps pick element set sns covers maximum number sets collection cnc element cover set iff element picked previous step collection sets covered update fsg d-th harmonic number pdi number sets collection covered element lemma greedy-hitting-set polynomialtime -approximation algorithm maxs sfjc proof lemma equivalence minimum hitting set minimum cover problem proof approximation factor greedy algorithm minimum cover problem equivalence problems finding minimum critical set minimum hitting set construct greedy procedure called greedycritical-set finding critical set attack graph assume attack graph set states set edges initial state success state intruder labeling function assume compute polynomial time function number realizable sets attack graph attack formally equal jfa rel initially empty set greedy algorithm greedy-critical-set executes steps empty pick element setana maximizes element picked previous step update fag remove edges labeled lemma greedy-critical-set polynomialtime -approximation algorithm maxa explore conditions function computed polynomial time assume attack graph dag argument section assume atomic attack path initial state success state unreasonable assumption attack graph edges labeled instantiations attack templates shown section local-setuid-bufferoverflow attack hosts distinct attack graph attack graphs called dags lemma easy prove lemma attack graph dag function computed time linear size attack graph probabilistic analysis attack graphs incorporate probabilities attack graphs choose subset states make transitions states probabilistic suppose graph state outgoing transitions regular attack graph choice transition system state nondeterministic empirical data enables estimate system state average transitions times ten transition remaining times place probabilities edges attack graph intuitively probability transition represents likelihood atomic attack transition succeed call state probabilities outgoing transitions probabilistic assigned probabilities left attack graph probabilistic nondeterministic states call mixed attack graphs probabilistic attack graphs probabilistic attack graphs evaluate reliability network note probabilities transitions lack data type atomic attack attack graph includes states transitions lead success states excludes transitions exist complete model excluded transitions non-zero probability sum probabilities transitions probabilistic state address problem model rest add catch-all escape state attack graph probabilistic state attack graph transition transition state attack graph probability minus sum probabilities states transitions self-loop preserves totality transition relation attack graph escape state attacks allowed terminate call escape attacks attacks pre-empted intruder reached goal definition probabilistic attack graph pag tuple set nondeterministic states set probabilistic states nondeterministic escape state set states transition relation transition probabilities set initial states set success states labeling states set propositions true state probabilistic attack graph pag distinguishes nondeterministic states set probabilistic states set sets nondeterministic probabilistic states disjoint function specifies probabilities transitions probabilistic states transitions viewed probability distribution states intuitively system nondeterministic state information relative probabilities transitions system probabilistic state choose state probability distribution complete probability case assume transition attack graph assigned probability nondeterministic states attack graph function assigns probabilities transitions probabilities loosely interpreted probability atomic attack transition succeeding interested finding reliability attack graph probability intruder succeed view markov chain state space transition probability steady state probability markov chain definitions technical conditions case reliability attack graph expression words reliability probability long run markov chain state set perform similar analysis probabilistic attack graphs presence nondeterministic states reliability assume pag intuitively interested finding probability intruder reach success state starting initial states recall absence nondeterministic states compute metric steady state probabilities markov chain presence nondeterministic states intruder choose transitions order maximize probability succeeding intruder reaches nondeterministic state transitions choose transition state maximize probability reaching success state idea formalized concepts theory markov decision processes state set successors denoted succ formally succ equal define function states nss function iterated equations convergence max succ snnssp succ sqnss function convergence intuitively probability intruder 
reach success state resolves nondeterminism maximize probability succeeding worst case reliability network algorithm iteration justification iteration algorithm presented companion technical report implemented iteration algorithm attack graph post-processor ran slightly modified version intrusion detection section modified attack detectable stealthy variants intruder chooses atomic attack probability picking stealthy detectable variant assigned imaginary probabilities picking stealthy attack variant sshd buffer overflow ftp rhosts remote login local buffer overflow intruder goal obtain root access host remaining undetected states goal achieved assigned benefit setup computed probability intruder success strategy attempt sshd buffer overflow host conduct rest attack host possibility detection sshd buffer overflow attack ids activity hosts context system administrator question question deployment security measure increase likelihood thwarting attacker answer installing additional ids component monitor network traffic hosts reduces probability intruder remaining undetected installing host-based ids host reduces probability things equal indication remedy effective summary contributions future work foremost contribution automatic generation attack graphs key insight attack equivalent counterexample produced off-the-shelf model checkers attack counterexample witness violation safety property small critical enhancement existing model checker easily produce attack graphs automatically graphs succinct exhaustive by-product part work showing level abstraction modeling attacks simple state machine specifications model intruder behavior set atomic attacks normal system behavior system administrator recovery actions connectivity communication subsystems important contribution support range formal analyses attack graphs security analysts attack graphs informally attack detection defense forensics paper explain minimization analysis technique attack graphs precisely answer questions security measure deploy order thwart set attacks set security measures deploy guarantee safety system explain briefly text detail technical report probabilities perform reliability analysis annotating attack graphs probabilities interpret markov decision processes mdp mdp algorithms iteration security analysts precisely answer questions attack incur damage system deploying intrusion detection system increase decrease likelihood thwarting type attack theoretical front plan exploit full power model checking exploring handle liveness properties safety properties property states user access file server violated server disabled due denial-of-service attack practical front plan conduct larger case studies illustrate usefulness automatically generating attack graphs intend build tool merges work attack graphs existing intrusion detection technologies tool intended security analysts evaluate enhance security network altman constrained markov decision processes chapman hall crc ausiello atri protasi structure preserving reductions convex optimization problems journal computational system sciences jcss bryant graph-based algorithms boolean function manipulation ieee trans comput aug clarke grumberg peled model checking mit press cormen leiserson rivest introduction algorithms mit press dacier quantitative evaluation computer security phd thesis institut national polytechnique toulouse december durrett probability theory examples duxbury press edition garey johnson computers intractibility freeman company jha sheyener wing formal analyses attack graphs technical report cmu-cs- carnegie mellon february nusmv symbolic model checker http afrodite itc nusmv ortalo deswarte kaaniche experimenting quantitative evaluation tools monitoring operational security ieee transactions software engineering sept oct phillips swiler graph-based system network vulnerability analysis acm security paradigms workshop pages puterman markov decision processes-discrete stochastic dynamic programming john wiley sons york ritchey ammann model checking analyze network vulnerabilities proceedings ieee symposium security privacy pages sheyner haines jha lippmann wing automated generation analysis attack graphs proceedings ieee symposium security privacy smv symbolic model checker http wwwcs cmu modelcheck stephenson formal methods forensic analysis intrusion events preliminary examination white paper http imfgroup document library html swiler phillips ellis chakerian computer-attack graph generation tool proceedings darpa information survivability conference exposition june valdes skinner probabilistic alert detection recent advances intrusion detection raid appendix section assume attack graph suppose compute set realizable sets rel lemma proves problem finding attack graph critical set size hitting set problem rel suppose instance hitting set problem construct attack graph set attacks attack graph set realizable sets rel graph collection critical set size attack graph hitting set collection describe construction cmg collection sets sngbe set make copies set set elements denoted byfsi sing set states attack graph initial state final state set edges labeling function defined edge state set label edge edge sij sij label edge sij sij edge state set smngto state labels edges sizes sets attack graph easy rel equal critical set attack graph iff hitting set collection size polynomial size instance hitting set problem hitting set problem np-complete mcsa problem np-hard lemma proves mcsa mcsa np-complete illustrates construction note discussion proves problem finding minimum set measures adoption make network safe np-complete simply set measures set attacks give short illustrate reduction set suppose collection consists subsets attack graph problem shown figure set attacks set realizable sets rel collection set attacksfs gis critical path success state edge label setfs gis hitting set collection figure attack graph collection 
