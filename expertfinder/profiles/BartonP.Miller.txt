prof barton miller research page copyright message function copyright notice alert respect copyrights npermission copy fee part material granted nprovided copies made distr ibuted direct ncommercial advantage copy republish quires fee specific permission acm ieee nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart research biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor current research projects paradyn parallel performance tools includes paradyn kerninst dyninst mrnet work grid middleware vulernability assessment wisa wisconsin safety analyzer security project somesh jha tom reps fuzz random software testing nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
prof barton miller biography page copyright message function copyright notice alert respect copyrights npermission copy fee part material granted nprovided copies made distr ibuted direct ncommercial advantage copy republish quires fee specific permission acm ieee nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart biography biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor biography barton miller professor computer sciences wisconsin madison directs paradyn parallel performance tool project investigating performance instrumentation technologies parallel distributed applications systems co-directs wisa security project research interests include tools high-performance computing systems binary code analysis instrumentation computer security scalable distributed systems miller co-chair dagstuhl seminar code instrumentation modeling parallel performance analysis co-chair dagstuhl seminar automated performance analysis co-chair technical papers program program co-chair acm sigmetrics symposium parallel distributed tools general chair acm sigmetrics symposium parallel distributed tools chaired acm onr workshop parallel distributed debugging miller editorial board ieee transactions parallel distributed systems international journal parallel processing concurrency computation practice experience journal computing systems miller chaired numerous workshops numerous conference program committees member ieee technical committee parallel processing miller member los alamos national laboratory computing communications networking division review committee ida center computing sciences program review committee secret service electronic crimes task force chicago area advisory committee tuskegee high performance computing program advisory board international summer institute parallel computer architectures languages algorithms prague miller active participant european union performance tools initiative miller received degree computer science california berkeley fellow acm nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
prof barton miller contact page nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart contact biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor contact information office computer sciences statistics bldg administrative assistant richard benton e-mail telephone department postal mailing address computer sciences department wisconsin west dayton street madison usa nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
prof barton miller teaching page nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart teaching biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor courses teach introduction operation systems fall freshman honors internet seminar advanced operating systems fall distributed systems spring nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
prof barton miller graduates page nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart graduates biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor longest time simply page list graduates years realize graduate students important part work added note great privilege work men women teaching learning list haven talked send note current graduate students dorian arnold andrew bernat michael brim gregory cooksey giridhar ravipati nathan rosenblum todd miller graduates cui-qing yang august intuit corporation professor computer science department north texas jong-deok choi august member technical staff ibm watson research center robert netzer august assistant professor department computer science brown david cohrs august legato systems palo alto california joann ordille december member technical staff bell labs murray hill jeffrey hollingsworth august professor department computer science maryland college park bruce irvin october member technical staff oracle corporation tia newhall august associate professor swarthmore college karen karavanic december assistant professor portland state zhichen zhichen december member technical staff yahoo ariel tamches february member technical staff vmware mountain view victor zandy february ida center computing sciences member technical staff bell laboratories murray hill philip roth april oak ridge national laboratory shai rubin july microsoft haifa jonathon giffin august assistant professor georgia tech alexander mirgorodskiy october member technical staff vmware mountain view graduates tba nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
copyright message function copyright notice alert respect copyrights npermission copy fee part material granted nprovided copies made distr ibuted direct ncommercial advantage copy republish quires fee specific permission acm ieee prof barton miller nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor selected selected papers miller research including work paradyn wisa projects andrew bernat barton miller incremental call-path profiling concurrency practice experience pdf torrey coleman miller comparison interactivity linux scheduler mlfq scheduler software practice experience april arnold ahn supinski lee miller schulz stack trace analysis large scale debugging ieee international parallel distributed processing symposium ipdps long beach california march dorian arnold dong ahn bronis supinski gregory lee barton miller martin schulz stack trace analysis large scale applications wisconsin technical report troctober pdf alexander mirgorodskiy naoya maruyama barton miller problem diagnosis large-scale computing environments tampa florida november pdf jonathon giffin somesh jha barton miller automated discovery mimicry attacks international symposium recent advances intrusion detection raid hamburg germany september pdf shai rubin somesh jha barton miller completeness attack mutation algorithms computer security foundations workshop csfw venice italy july pdf miller cooksey moore empirical study robustness macos applications random testing international workshop random testing portland maine july pdf mcilwain miller tool converting linux device drivers solaris compatible binaries software practice experience june dorian arnold gary pack barton miller tree-based overlay networks scalable applications international workshop high-level parallel programming models supportive environments hips rhodes greece april pdf philip roth barton miller on-line automated performance diagnosis thousands processes acm sigplan symposium principles practice parallel programming ppopp york city march pdf jonathon giffin somesh jha barton miller effective model-based intrusion detection technical report computer sciences department wisconsin madison wisconsin november pdf laune harris barton miller practical analysis stripped binary code workshop binary instrumentation applications wbiast louis missouri september pdf jonathon giffin david dagon somesh jha wenke lee barton miller environment-sensitive intrusion detection international symposium recent advances intrusion detection raid seattle washington september pdf eli collins barton miller loop-aware search strategy automated performance analysis high performance computing communications hpccsorrento italy september appears spring-verlag lncs pdf shai rubin somesh jha barton miller language-based generation evaluation nids signatures ieee symposium security privacy oakland california pdf shai rubin somesh jha barton miller attack mutation test high-end nids information security bulletin april online alexander mirgorodskiy barton miller autonomous analysis interactive systems self-propelled instrumentation mmcn multimedia computing networking san jose california january pdf shai rubin somesh jha barton miller automatic generation analysis nids attacks annual computer security applications conference acsac tuscon arizona december awarded paper student paper pdf henry hanping feng jonathon giffin yong huang somesh jha wenke lee barton miller formalizing sensitivity static analysis intrusion detection ieee symposium security privacy oakland california pdf philip roth dorian arnold barton miller benchmarking mrnet distributed tool infrastructure lessons learned high-performance grid computing workshop held conjunction international parallel distributed processing symposium ipdps santa mexico april pdf jonathon giffin somesh jha barton miller efficient context-sensitive intrusion detection network distributed system security symposium ndss san diego california february pdf philip roth dorian arnold barton miller mrnet software-based multicast reduction network scalable tools phoenix arizona november pdf barton miller ana cort miquel senar miron livny tool daemon protocol tdp phoenix arizona november pdf alexander mirgorodskiy barton miller crosswalk tool performance profiling user-kernel boundary international conference parallel computing parco dresden germany september pdf victor zandy barton miller checkpoints gui-based applications usenix annual technical conference san antonio june pdf victor zandy barton miller reliable network connections acm mobicom atlanta september pdf jonathon giffin somesh jha barton miller detecting manipulated remote call streams usenix security symposium san francisco california august pdf html philip roth barton miller deep start hybrid strategy automated performance problem searches euro-par paderborn germany august pdf harold cain barton miller brian wylie callgraph-based search strategy automated performance diagnosis concurrency computation practice experience march appears euro-par munich germany august karavanic miller experiment management support parallel performance tuning journal parallel distributed computing practices special issue monitoring systems tool interoperability ariel tamches fine-grained dynamic instrumentation commodity operating system kernels diss wisconsin-madison pdf barton miller mihai christodorescu robert iverson tevfik kosar alexander mirgorodskii florentina popovici playing inside black box dynamic instrumentation create security holes parallel processing letters june september appears los alamos computer science institute symposium sante october pdf ariel tamches barton miller dynamic kernel i-cache optimization workshop binary translation barcelona september pdf zhichen thomas reps barton miller typestate checking machine code european symposium programming esop genova italy april pdf zhichen safety checking machine code diss wisconsin-madison december pdf harold cain barton miller brian wylie callgraph-based search strategy automated performance diagnosis euro-par munich germany august pdf forrester miller empirical study robustness windows applications random testing usenix windows systems symposium seattle august appears german translation empirische studie zur stabilit von nt-anwendungen september pdf html zhichen barton miller thomas reps safety checking machine code sigplan conference programming language design implementation pldi vancouver june pdf karen karavanic experiment management support parallel performance tuning diss wisconsin-madison december pdf karen karavanic barton miller improving online performance diagnosis historical performance data portland oregon november pdf ariel tamches barton miller dynamic kernel instrumentation kernel application tuning international journal high-performance applications fall pdf tia newhall performance measurement interpreted just-in-time compiled dynamically compiled executions diss wisconsin-madison august pdf victor zandy barton miller miron livny process hijacking international symposium high performance distributed computing hpdc redondo beach california august pdf tia newhall barton miller performance measurement dynamically compiled java executions acm java grande palo alto june pdf zhichen barton miller oscar naim dynamic instrumentation threaded applications acm sigplan symposium principles practice parallel programming atlanta georgia pdf ariel tamches barton miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating systems design implementation osdi orleans louisiana february pdf tia newhall barton miller performance measurement interpreted programs euro-par southampton england september pdf jeffrey hollingsworth barton miller marcelo gon alves oscar naim zhichen ling zheng mdl language compiler dynamic program instrumentation parallel architectures compilation techniques san francisco california november pdf karen karavanic barton miller experiment 
prof barton miller professional activities page nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart activities biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor lectures distinguished lecturer triangle computer science lecture series joint univ north carolina north carolina state duke raleigh october plenary speaker symposium advanced computing systems infrastructures tsukuba japan distinguished lecturer ibm watson research center december distinguished lecturer iowa state electrical engineering department boards advisory committees los alamos national laboratory computing communications networking division review committee -present ida center computing sciences program review committee chair -present electronic crimes task force chicago area secret service wisconsin center human performance risk analysis internal advisory board euro-par conference advisory board -present ieee technical committee parallel processing -present advisory committee tuskegee high performance computing program advisory board international summer institute parallel computer architectures languages algorithms prague czech republic july conference chair activities co-chair dagstuhl seminar code instrumentation modeling parallel performance analysis co-chair dagstuhl seminar automated performance analysis technical papers vice chair program co-chair venezuela workshop high performance computing program co-chair symposium parallel distributed tools general chair symposium parallel distributed tools conference program committees november ieee international symposium high-performance distributed computing hpdc june network distributed system security conference ndss february international conference linux clusters international conference high performance computing communications september euro pvm mpi august international conference linux clusters international symposium automated analysis-driven debugging aadebug september international conference linux clusters international conference linux clusters european grids conference january euromicro conference parallel distributed network based processing pdp international conference linux clusters october euro pvm mpi earlier acm symposium principles practices parallel programming ppopp tutorials euro pvm mpi acm symposium principles practices parallel programming ppopp international performance dependability symposium supercomputing supercomputing acm symposium principles practices parallel programming ppopp supercomputer debugging workshop international conference distributed computing systems international conference distributed computing systems usenix summer conference nbsp computer sciences home feedback content questions send david wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
prof barton miller home page nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page bart misc biography contact nbsp information teaching research graduates professional activities miscellaneous dept nbsp home page barton miller professor miscellaneous tba link wisconsin database group web site nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
management support performance tuning san jose california november pdf zhichen james larus barton miller shared-memory performance profiling acm sigplan symposium principles practice parallel programming las vegas nevada june pdf karen karavanic jussi myllymaki miron livny barton miller integrated visualization parallel program performance data parallel computing special issue environments tools parallel scientific computing pdf jeffrey hollingsworth barton miller adaptive cost model parallel program instrumentation euro-par eds luc bouge pierre fraigniaud anne mignotte yves robert lyon france august lncs vol pdf bruce irvin barton miller mechanisms mapping high-level parallel performance data icpp workshop challenges parallel processing chicago august pdf bruce irvin barton miller mapping performance data high-level data views parallel program performance international conference supercomputing philadelphia pdf krishna kunchithapadam barton miller integrating debugger performance tool steering debugging performance tools parallel computing systems eds simmons hayes brown reed ieee computer society press pdf bruce irvin performance measurement tools high-level parallel programming languages diss wisconsin-madison october pdf miller koski lee maganty murthy natarajan steidl fuzz revisited re-examination reliability unix utilities services computer sciences technical report wisconsin-madison april appears german translation empirische studie zur zuverlasskeit von unix-utilities nichts dazu gerlernt september pdf krishna kunchithapadam barton miller optimizing array distributions data-parallel programs international workshop languages compilers parallel computing ithaca york august published eds pingali banerjee gelernter nicolau padua lncs springer-verlag pdf barton miller mark callaghan jonathan cargille jeffrey hollingsworth bruce irvin karen karavanic krishna kunchithapadam tia newhall paradyn parallel performance measurement tool ieee computer november special issue performance evaluation tools parallel distributed computer systems pdf jeffrey hollingsworth finding bottlenecks large-scale parallel programs diss wisconsin-madison august pdf jeffrey hollingsworth barton miller jon cargille dynamic program instrumentation scalable performance tools scalable high-performance conputing conference shpcc knoxville tennessee pdf bruce irvin barton miller performance tool high-level parallel programming languages ifip working conference programming environments massively parallel distributed systems ascona switzerland april pdf barton miller jeffrey hollingsworth mark callaghan paradyn parallel performance tools pvm environments tools parallel scientific computing dongarra tourancheau eds siam press pdf jeffrey hollingsworth barton miller dynamic control performance monitoring large scale parallel systems international conference supercomputing tokyo july pdf miller fredriksen empirical study reliability unix utilities communications acm december appears german translation fatale fehlertractigkeit eine empirische studie zur zuverlassigkeit von unix-utilities march pdf nbsp computer sciences home feedback content questions send bart wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
prof barton miller home page bart research interests distributed arallel program performance tools binary code analysis instrumentation computer security scalable systems operating systems software testing biography barton miller professor computer sciences wisconsin madison professor miller received degree california san diego degrees computer science california berkeley professor miller fellow acm published technical papers 
introduction operating systems fall wisconsin-madison computer sciences department fall barton miller introduction operating systems stuff final scores grades quiz answers faq frequently asked questions program programming assignment problem set code examples presented discussion section posted list basic coding standards programs list evolve semester sections lecture notes ready reading printing section lecture notes added material updated sections lecture notes ready reading printing page updated fall class staff instructor barton miller office office hours wednesday am-noon thursday am-noon itai gurari gurari wisc office office hours monday tuesday wednesday thursday note shared lecture sections advice materials organized lecture notes lecture notes class web page textbook operating systems concepts silberschatz galvin gagne modern operating systems andrew tannenbaum programming assignments semester programming language requiring specific book book happy buy book book recommend primer stephen prata book bjarne stroustrup programming language book considered complete book user-friendly books immediately amazon lecture notes read section coming class operating systems concepts book store version book edition satisfactory buy latest edition edition windows chapter lecture discussion sections lecture times tuesday thursday pmpm computer sciences discussion section wednesday pmpm computer sciences note mandatory discussion section wednesday section discuss material covered lecture weekly quizzes discuss important details programming assignments homeworks make leave room schedule attend section exams quizzes midterms final optional final exam spring review week starting week classes quiz discussion section quizzes minutes past quizzes answers quiz december quiz november quiz november quiz november quiz october quiz october quiz october quiz october quiz october quiz september programming assignments programming assignments semester details assignments class handouts assignments written workstations running unix assignments personal computer note assignments due dates lecture section programming assignment create simulator cpu scheduling algorithms implement simulation algorithsm exponential queues sctf perform variety experiments simulator due november programming assignment goal assignment learn performance measurement issues system programming due november programming assignment goal assignment write program processes pipes synchronization communication due october programming assignment goal assignment practice learn system calls write program tolerant junk input due september programming assignment goal assignment write program threads monitor-based synchronization due october written problem sets semester hand written problem sets based lectures problem sets turned find poorly weekly quizzes don problems happy answer questions problems solutions problem set goal assignment learn synchronization primitives semaphores monitors messages solve problems problem set goal assignment learn memory management hardware software problem set goal assignment learn file system structures methods late work assignments due start class date listed handout entire semester late days credit late days assignments day assignments days assignment days absolutely late work accepted late days -hour days late days assignment due week classes cheating programming assignments partners group work independently groups collaborations groups quizzes exams individual work communication students exam questions permissible activity talk penalty cheating include receiving grade academic misconduct notation marked transcript cell phones make turn cell class time cell beeper rings audibly class asked leave return meet office computer facilities linux workstations students registered class account computer proper compilers libraries programming assignments grading policy don final final programming assignments programming assignments quizzes quizzes final final lowest quiz grade dropped average quizzes weeks final exam counted past taught class class gpa range class schedule schedule tentative change date lecture discussion week september introduction overview processes intro week september dispatching process creation intro week september class tuesday cooperating processes synchronization libraries week september semaphores quiz processes week october semaphores monitors lecturer vic zandy quiz synchronization semaphores week october messages deadlocks quiz synchronization monitors week october debugging strategies dynamic memory allocation quiz synchronization messages week october relocation lecturer vic zandy oct quiz scheduling deadlock week october october segmentation paging tlbs quiz paging week november virtual memory page replacement thrashing quiz tlb week november working sets devices files quiz page replacement week november disk allocation scheduling directories quiz week november protection class thursday quiz week december security advanced topics readings quiz week december advanced topics readings quiz finals december optional final exam friday modified tue dec cst bart 
internet honors seminar wisconsin-madison computer sciences department spring bart miller internet honors seminar instructor bart miller office office hours wednesday friday -noon appointment lectures lecture time monday computer sciences class schedule written assignments class required attend lectures participate discussions schedule change week january bart miller introduction overview week january larry landweber internet architecture protocols week february week february bart miller client server remote procedure calls week february systems security week february eric bach security encryption week march march spring break week march miron livny images pictures net week march week april pei cao high-performance file systems week april week april david wood internet supercomputer week april jim larus java week april week bart miller discussions modified thu jan cst bart 
advanced operating systems fall wisconsin-madison computer sciences department fall barton miller advanced operating systems stuff summary text classes discussions papers exams scores details reading list class reading schedule archive class mailing list stuff list final project presentations december short tutorial power-law functions linked reading list file system paper zipf power-laws pareto ranking tutorial november project list october paper assignment september warning page updated fall semester depend information warning notice removed summary scores project papers december summary scores paper assignment october list suggestions avoiding common writing mistakes september summary intended give broad exposure advanced operating systems topics reading discussing topics protection security memory management operating system kernels file systems synchronization naming distributed systems read rest information sheet carefully text satisfactory textbook graduate level operating systems class current literature text structured readings journal articles conference proceedings readings semester class web page paper list includes link pdf postscript file class discuss topics relevant current papers lecture detail-by-detail review papers discussion major topics themes papers focal point form reading groups classmates meet week discuss details assigned papers readings important part class reading list posted reading schedule formula successful class read papers independently discuss reading group identify important issues participate class discussion papers list paper providing advice computer science research classes discussions class meetings form discussion lectures talk day topics discussion supported comments opinions participate actively daily class lot expect sit quietly listen weeks unhappy class receive grade expected attend classes make talk missing class note class scheduled -minute lectures week expected week meet average week initial weeks week accelerating pace week time project work end semester watch schedule carefully make schedule coming week papers class write papers short pages longer paper study system measurements benchmarking subtle subject paper involves project paper summary project selection project topics choose writing important writing good ideas paper reviewed reading refereeing paper fellow students give writer critical comments person give reader writing paper revised pass read exams exams papers readings approach class scores scores paper assignment summary scores project papers final grades paper project scores semester progresses details time monday wednesday friday pmpm place computer sciences note location change office hours wednesday thursday -noon modified wed dec cst bart 
distributed systems spring wisconsin-madison computer sciences department spring barton miller distributed systems stuff instructor readings lecture student presentations paper project writing style suggestions grades exams class schedule reading list presentation guidelines mailing list archive comp sci login required seminar web page stuff agenda final project poster session project referee report form sample referee reports guidelines writing project list page updated spring work progress session partial agenda guidelines paper presentation class information reading list pages updated spring semester read pages bring day class schedule final project demonstrations class schedule changed march onward carefully check updated schedule instructor barton miller office lecture monday wednesday friday amam computer sciences office hours tuesday thursday am-noon readings class cover topics distributed systems including time agreement file systems reliability process migration distributed virtual memory languages load sharing authentication internet web read collection papers topics distributed systems papers journal articles conference papers technical reports papers recent view distributed systems papers web linked reading list important read papers discuss class form reading groups students discuss papers covered class reading groups previous classes work goal reading groups talk ideas papers necessarily consensus ideas good bad lecture rely heavily student participation weeks class run discussion lecture talk papers participating remainder semester student presentations papers presentations individually pairs sign-up class present papers class presentations cover papers student making presentation responsible reading papers rest class paper topic read student presentations presentations generally minutes including questions interruptions comments presentations organized talks transparencies preparing presentation talk times presentation general class discussion led time read paper present discuss issues important paper ideas organizing talk time outline talk outline detailed describe covered slide time drafts slides practice talk times present class practice smooth presentation give idea organization makes sense give opportunities time talk fits hour period paper project researcher skills learning distributed systems working written spoken communication skills groups project project chosen list hand week class weeks prepare short page project proposal week classes work progress work progress session patterned conference session person talks minutes current research time quickly describe project explain main ideas hope accomplish current state work week class mini-conference mini-conference present results projects project minute presentation minutes questions class periods structured conference sessions project written project report report pages structured research paper abstract intro body conclusions final version report due week classes prepare early draft report week class project group review report project group purpose review preparing final report grades exams class schedule schedule tentative change paper numbers reading list shown parentheses check back regular basis scheduling section updated spring apr person presenting slides monday wednesday friday week jan intro overview jan jan week jan jan feb week feb feb feb postponed rescheduled week feb feb project list feb swetha week feb andy feb derek feb week feb ting feb haris project proposal due mar greg week mar mar matt mar kevin week mar mar hidayat mar mark week mar giri mar nate mar guest lecturer vic zandy week mar mar mar work progress presentations nbsp apr spring break week apr apr apr week apr apr apr week apr apr apr class discussion refereeing reports week apr paper draft due referees week final project poster presentation referee reports due final paper due bart office modified fri cdt bart 
fuzz testing application reliability fuzz testing application reliability page construction fuzz testing simple technique feeding random input applications random testing time-honored technique approach characteristics makes approaches input random model program behavior application type system description called black box testing command-line studies random input simply random ascii character streams x-window study windows study mac study random input included cases valid keyboard mouse events reliability criteria simple application crashes hangs considerd fail test passes note application respond manner input quietly exit result characteristics fuzz testing automated high degree results compared applications operating systems vendors encourage feedback comments links fuzz papers software mac fuzz report postscript pdf html miller cooksey moore empirical study robustness macos applications random testing international workshop random testing portland maine july windows fuzz report postscript compressed postscript gzip postscript pdf html forrester miller empirical study robustness windows applications random testing usenix windows systems symposium seattle august appears german translation empirische studie zur stabilit von nt-anwendungen september fuzz revisited report postscript compressed postscript gzip postscript pdf miller koski lee maganty murthy natarajan steidl fuzz revisited re-examination reliability unix utilities services computer sciences technical report wisconsin-madison april appears german translation empirische studie zur zuverlasskeit von unix-utilities nichts dazu gerlernt september original fuzz report postscript compressed postscript gzip postscript pdf miller fredriksen empirical study reliability unix utilities communications acm december appears german translation fatale fehlertractigkeit eine empirische studie zur zuverlassigkeit von unix-utilities march fuzz software ftp site slides fuzz-revisited talk postscript pdf summary basic test results reported fuzz tools testing systems recent testing systems tested send glad provide link report modified fri jun cdt 
page incremental call-path profiling abstract profiling key technique achieving high performance call-path profiling refinement technique classifies function behavior based path reach function information optimizing programs libraries communication mpi pvm linear algebra scalapack threading behavior functions libraries varies widely depending caller path reach caller unlike standard profiling techniques call-path profiling accurately characterize call-path dependent behavior present method call-path profiling called increlook-upmental call-path profiling previous callpath profilers relied global pre-instrumentation application overhead instrumentation limits techniques providing simple metrics function call counts contrast instrument application fly allowing targeted analysis functions method applied run-time previous program modification complex metrics synchronization waiting time blocking time memory stall time cpu usage result call-path profiling applied wider variety performance problems describe ipath prototype incremental call-path profiler demonstrate application technique real-world applications ipath analyze distributed milc rmd qcd simulation paradyn instrumentation daemon rmd simulation ipath detected communications bottleneck calls mpi library interleave communication operations achieving decrease running time simulation paradyn daemon discovered incorrectly optimized utility function optimizing function frequent caller achieve decrease running time seconds seconds introduction profiling key component optimization process vital achieving high levels performance function-level profiling limited gathers information aggregate behavior functions program information sufficient completely characterize function behavior varies calls function performs type input poorly call-path profiling extension function-level profiling mechanism information gathered profiler attributed paths call graph aggregated complete profiling information optimizing programs libraries communication mpi pvm linear algebra scalapack threading call-path profiling user identify characterize performance problems depend function called function function complete quickly invocations work supported part department energy grants de-fg de-fg lawrence livermore national lab grant government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon page require excessive time executed call-chain communication function block waiting input cases utility function perform poorly input call-path profiling clarifies performance problems caused inefficient calling behavior function called excessive number times math function called multiple times identical input function-level profiling mis-identify math function bottleneck call-path profiling identify calling behavior problem previous instrumentating call-path profilers traced functions program tools tracked call-path times instrumenting function entries exits complete information cases generates substantial overhead slow program profilers sampling instrumentation lessen overhead involved profiling generate precise results work motivated insight users desire information function program focusing set functions exact information behavior case information offered whole-program profiler unnecessarily broad expensive focusing functions profiler reduce overhead involved call-path profiling previous call-path profiling algorithms amenable partial profiling approach require whole-program instrumentation track call-path developed partial profiling method require whole-program instrumentation generate accurate call-path profiling results technique complements profiling tools approaches efficient method profiling call path functions paper describe technique call incremental call-path profiling incremental call-path profiling user profile functions entire program profile data examined program running user refine selected functions metrics gathered program running profiling functions provide benefits call-path profiling significantly reducing overhead incurred method distinguished key capabilities targeted technique profile functions functions instrumented dynamic profiling instrumentation inserted removed run-time prior program preparation page run-time results up-to-date profiling results program runs requiring postprocessing phase cost-effective overhead incurred profiled functions executed allowing complex metrics complete entire call-path captured including dynamic calls function pointers paper presents method incremental call-path profiling begin discussing existing work area call-path profiling discuss key technique lightweight stack walk determine complete call-path method determine complete call-chain requiring whole-program instrumentation describe implementation application ipath prototype incremental call-path profiler tool capable gathering wide variety performance metrics call-path instrumenting functions interest user ipath supports counter timer-based performance metrics capable calculating metrics based hardware counters test technique apply ipath real systems rmd distributed quantum chromodynamics simulation built milc framework instrumentation daemon paradyn dynamic profiler applications found removed significant call-path specific bottlenecks modifications resulted decrease running time rmd decrease paradyn instrumentation time related work call-path profiling well-known approach gathering detailed information behavior program projects investigated methods offering call-path profiling minimal overhead approaches divided categories based mechanism generating call-path method data collection category profilers maintain snapshot current call-path entire execution program update snapshot function call boundaries instrumentation category consists profilers sampling third-party debugging interface identify call-paths gather performance data category consists profilers approximate call-paths provide partial path information category consists call-graph profilers track current call-path execution program intraprocedural path profiler developed ball larus instruments page transitions basic blocks track execution path individual functions extended calling context function approximate call-path approximation construct called calling context tree cct represents call-tree program compact form approach presents callpath profiling information entire program cct track recursive calls collapsing recursive calls function single node cct capable accessing hardware counters sparc platform non-virtualized timers lead inaccuracies due context switches melski reps extended technique directly track interprocedural paths approximation approach assigned unique identifier path program identifier label collected performance data technique adds instrumentation function entries exits call sites instrumentation generates unique identifier call-path segments segments include recursive calls calls function pointers segments reconstruct complete call-path post-processing phase larus developed method whole-program paths wpp record block-by-block trace program execution represent compact grammar determine record paths function information pieced representation program execution representation included call-paths program performance information function call counts tau performance tools provide call-path specific profiling data tau system traces function entries exits instrumentation code inserted program information generate stack executing functions tau tracks function entries exits directly dynamic calls recursive calls represented stack tau measurement code stack active functions representation current call-path technique shares advantages approach including partial data availability complete representation call path approach whole-program instrumentation derive current call-path walking program stack derose wolf developed catch tool associates hardware metrics call-path information mpi openmp applications ipath catch built dyninst instrumentation library catch analyzes call-graph program call-site instrumentation maintain representation current callpage path user select subtrees call-graph profile tracking entire execution program catch reduce amount instrumentation inserted program catch statically predicts callpaths selected subtrees handle call-paths dynamic calls catch insert instrumentation selected functions catch instrumentation inserted subtree call graph insert instrumentation profiled functions category consists call-path profilers third-party debugging interface track program executes hall developed profiler cpprof periodically pauses samples profiled application solaris debug interface proc sample cpprof includes current application stack elapsed cpu time previous sample elapsed cpu time accumulated call-path represented stack cpprof user tune frequency sampling frequent samples 
generate larger overhead process paused sampling smaller approximations resulting profile profile generated cpprof run-time cpprof ipath stack walk determine current call path third-party sampling approach cpprof differs greatly first-party instrumentation approach technique operates address space program operates function boundaries result handle cases cpprof technique finally cpprof provide precise information functions tools gprof sprof examples category profilers instrumentation accurately count function entries exits sampling approximate cpu usage information partial call-paths length profiled function caller approximated technique partial call-path profiling low overhead introduce errors based approximated data profiler supports hardware performance metrics limiting variety information user design incremental call-path profiling key characteristics functions interest user instrumented profiling started stopped run-time relying prior program modification profiling data examined analyzed program running fourth overhead page incurred profiled functions executed entire call-path captured including dynamic calls function pointers section describe approach characteristics technique technique called dynamic instrumentation gather call-path performance metrics dynamic instrumentation operates inserting code program running prior modification instrumentation code access program state program registers hardware performance counters dynamic instrumentation profile running programs requiring prior binary modification addition insert remove instrumentation program running instrument entry exit points profiled function instrumentation performs actions performs inexpensive stack walk determine current call-path instrumentation calculates user-defined performance metric sampling desired performance counters stack walk performance data update current call-path profile function section describe actions core design based walking stack determine current call-path walking actual process stack detect recursion multiple frames stack calls function pointers requiring modification location program addition distinguish individual callsites function return addresses stack stack walking fundamental mechanisms important efficient conceptually required follow frame pointer stack entry function frame reached practice program optimizations complicate walking stack discuss optimizations techniques handling section current call-path obtained instrumentation calculates desired performance metric distinguish types performance metrics counters timers counters number times function executed call-path size function input require single point instrumentation call-path determined counter path incremented function entry exit point instrumentation required category metrics timers measure change metric execution function require points instrumentation timers record metric entry function calculate difference function exits timers calculate variety metrics including memory stall time synchronization blocking time wait time elapsed cpu usage page profile data stored collection call-path data structures structures associate performance data call-path requirements add call-path on-the-fly represent newly discovered path dynamic call finding correct structure callpath efficient lower profiling overhead structures presentation partial results program running requiring post-processing represent call-paths simply vector addresses entry call site address vector performance data collected call path shown figure performance data stored form counters timers user-defined data structure previous profilers developed sophisticated techniques represent call-paths labelling path unique integer identifier tree rooted entry function annotated profiling data unique identifier technique constant time look-up speed identifier index array performance information technique requires static determination call paths dynamic calls included number paths unbounded tree technique represents call-paths paths root tree edge node compactly represent multiple call-paths overlapping sections tree cpprof rooted entry program describe arbitrary callpaths investigated inverted tree rooted profiled function improvement look-up speed minor application due reasons time required stack walk call-path look-up small compared time required calculate performance metrics synchronization time optimizing look-up result significant decrease profiling overhead ipath figure representation call-path profiles main foo mainmain main foo foo foo path path path path foo perf data perf data perf data perf data page heuristics check call-paths heuristics significantly reduce look-up time discuss heuristics look-up techniques section key characteristic method profiling data program runs profiling data updated profiled function exits user examine data time continuous update technique combined dynamic instrumentation user continually refine functions profiled metrics gathered based preliminary results single run program capability long-running programs user examine results profiling waiting program complete implementation implemented call-path profiling method tool called ipath dyninstapi library provide dynamic instrumentation capability ipath implemented ialinux power aix platforms capable variety hardware software performance metrics ipath consists parts control process instruments monitors profiled application library stack walk profiling logic control process called mutator dyninst terminology monitors application generates instrumentation requests library injected application control process instrument profiled functions gathered profile data stored shared memory segment attached control process profiled application control process ipath supports starting profiled application attaching running application created attached application inject run-time library program address space inject library run-time require previous program modification library injected control process triggers initialization phase phase creates shared memory segment application control process profile data stored control process access data run-time pausing process page initialization complete control process inserts calls library entry exit profiled functions calls perform stack walk collect performance data single requested function matches multiple functions program functions instrumented performance information separate multiple versions function caused function overloading local functions names visible module instrumentation inserted program run manipulation control process shared memory segment store profile data access preliminary results control process pausing program control process periodically prints summary profile data program runs displays final version program completes ipath calculates percentage entire execution call-path takes determine call-path specific bottlenecks provide output milc results section figure run-time library ipath run-time library responsible things determining current call path gathering performance information hardware counter values calculating call-path profile function run-time library consists major segments data structures store profiling data stack walk logic instrumentation executed function entry exit ipath stores detected call-paths profiling information collection call path entries shared memory segment call path entry consists vector addresses call sites call path data desired performance metric format call path equivalent format returned stack walking code comparing stack walk call path consists comparing size vector iteratively comparing contents efficiency approach depends heavily comparing call-path entry stack walk result heuristics guessing path entry instrumentation exit instrumentation entry heuristic compares recently call-path stack walk function repeatedly called call-path loop caller call path changed exit heuristic matches stack walk function entries exits mechanism call active stack page active stack takes advantage fact call-path rarely entry exit function call-path changed tail call optimization longjmp call-path determined entry instrumentation re-used exit instrumentation advantage behavior maintaining stack call-paths exit instrumentation function entered current call-path pushed stack top call-path stack checked function exited stack single element handle recursive entry instrumented function result 
multiple active paths profiled function entered recursively stack maximum depth entry instrumentation performs actions walk stack determine current call-path call-path structure matches stack walk case create callpath structure technique avoid static analysis program call paths gather desired performance metrics timers memory stall time started storing current timer starting counters function call counts simply incremented current call-path added active stack instrumentation completes control returned profiled application exit instrumentation responsible stopping active timers user requested timerbased metrics exit instrumentation unnecessary inserted entry instrumentation determine active call-path stack walk table look-up unlike entry instrumentation matching entry found instrumentation immediately exits active call-path determined timers stopped sampling current timer subtracting starting accumulating difference finally top active stack exit removed stack walk optimizations stack walk conceptually simple optimizations make process difficult identify categories optimizations affect stack walks functions create stack frames functions modify stack frame execution functions record pointer previous stack frame creating frame avoid complexities walking partially constructed stack frames walking stack entry exit function page category optimizations consists functions create stack frames type optimization function stack walk call-path derived stack walk common examples frameless functions leaf functions stack frames inlined functions leaf function occur middle stack walk make calls walk stack function boundaries handle optimizations callers profiled function result leaf optimizations profiled function impede stack walking inlined functions matter distinguish inlined functions stack walks relying information symbol table reconstruct original form function ipath presents call-path inlined function group optimizations consists functions modify stack frame execution optimization functions aix math library functions execute stack frame error detected create stack frame handling error accurate stack walks presence type optimization long modifications stack frame completed time call made true case optimization aware final category consists optimizations create stack frames pointer previous frame makes impossible identify previous stack frame knowing mechanism size current stack frame optimization iathis architecture registers stack pointer frame pointer track stack stack pointer moves execution function frame pointer static pointer previous frame omit frame pointer register reused making impossible find previous frame detect case abort stack walk investigating feasible determine size stack code analysis relying frame pointer results applied profiler applications hpc domain milc rmd qcd simulation code paradyn parallel performance instrumentation daemon cases call-path profile data make substantial improvements running time programs gathered call-path profiles allowed distinguish call-paths correlated poor profiled function performance focusing page call-paths make significant performance improvements traditional profiler milc ipath investigate rmd distributed quantum chromodynamics simulation built milc framework aim investigate synchronization bottlenecks program previously investigated program gprof function-level profiler identified bottlenecks mpi functions mpi allreduce mpi wait function-level profiler provided insufficient information determine bottlenecks mpi functions called milc wrappers caused gprof identify single call-path mpi function addition calls mpi function variety points program unable determine calls caused poor performance applied ipath application identify call-paths responsible bottlenecks information restructure program eliminate mpi wait reduce mpi allreduce bottlenecks milc project framework performing qcd simulations framework defines lattice data mechanisms accessing individual points lattice applications written framework mechanisms applications run single machines clusters code modifications mechanism interested mpi-based message passing update lattice nodes framework mechanisms determining lattice distributed application run cluster simulations distributed milc framework rmd implementation algorithm qcd simulation majority execution time rmd contained single function congrad function consists loop executes result threshold parameter iteration loop consists interleaved set types operations gather information lattice points neighboring nodes perform vector operations lattice sum results computing nodes page ran rmd simulation nodes ibm ipath profile mpi wait mpi allreduce functions previously identified bottlenecks examined resulting call-path profile focusing paths passed congrad paths allowed unwind communication abstraction milc framework discovered specific synchronization bottlenecks congrad gather operations made calls mpi wait indirect calls mpi allreduce milc framework total simulation executed seconds shown line table began investigating bottlenecks mpi wait profiling showed execution time congrad spent calls mpi wait making prime candidate optimization blocking time caused lattice update operations iteration loop congrad executes gather operations milc framework implements gather series messages finalized calls mpi wait gathers executed congrad resulted sixteen distinct call-paths mpi wait figure visualizes data ipath output showing section complete mpi wait call-path profile mpi wait called wait gather function call left branch taking substantially longer complete call wait gather function dslash special takes substantially longer complete readability collapsed calls dslash special congrad behaved similar fashion call-path profile trace difference blocking time back initial send receive operations bottleneck due synchronous send operation mpi issend modified send operation asynchronous mpi isend reordered calls mpi wait hide transfer latency resulted reduction time consumed mpi wait gather operations decrease running time shown line table version time seconds change original gather operation optimization mpi allreduce optimization optimizations table rmd running time time spent congrad synchronization bottlenecks optimizations made page investigated mpi allreduce bottlenecks function rmd sum single floating point nodes executing simulation call-path profile showed operation efficient total execution time congrad spent calls mpi allreduce replaced calls mpi allreduce non-blocking equivalents overlapped loop operations data dependencies loop prevented hiding communication latency replacement resulted decrease time spent blocked mpi allreduce decrease total running time shown line table finally ran original simulation profiling inserted calculate overhead due call-path profiling worst-case overhead caused profiling mpi wait total running time program summary call-path analysis discover synchronization bottlenecks rmd simulation call-path profiling information allowed focus calls bottlenecks aggregate behavior profiled function incremental paths allowed precisely target profiling overhead minimum cases replace blocking synchronous calls asynchronous equivalents reorder operations hide message passing latency optimizations combined figure call-path profile mpi wait partial display detected call-paths mpi wait omitted paths contribute remaining percentage calls synchronization blocking time measured cpu cycles mpi wait wait gather wait gather function call calls legend cpu dslash special dslash special gauge force update congrad page reduced running time rmd seconds seconds decrease shown line table paradyn daemon ipath identify remove major bottleneck paradyn instrumentation daemon paradyn profiling tool capable performing automated analysis distributed programs frequently called utility function previously incorrectly optimized leading poor performance ipath isolate call-path utility function responsible bottleneck call-path information re-optimize utility function resulting significant reduction instrumentation overhead reduction instrumentation time resulted visible user-level performance improvement 
began noting paradyn automated analysis multi-threaded program significantly slower analysis similar single-threaded program slowdown increased number threads target program increased investigated behavior determined slowdown due instrumentation section paradyn daemon requests instrumentation taking significantly longer satisfy multithreaded program single-threaded program shown table rmd began investigating problem traditional profiler identified utility function findfuncbyaddr consumed majority extra time spent instrumentation function performed look-up mapping input address function target application contained address comments source code function bottleneck previously optimized investigated determined majority callers findfuncbyaddr advantage optimization function performing poorly findfuncbyaddr large number unoptimized seconds optimized seconds change single-threaded threads threads threads table instrumentation time time spent daemon performing instrumentation performance consultant analysis page callers places paradyn daemon believed good target call-path profiling applied ipath problem function determine call-path large effect performance function expected case surprised results performance findfuncbyaddr varied widely depending current call-path thousand cpu cycles call million cycles call unsurprisingly calls advantage existing optimizations required short time complete majority calls utility function single call-path advantage existing optimizations insight obvious call-path profiling data generated ipath investigated function poor performance single call-path characterize inputs function discover root performance problem data structures maintain address function mapping mapping stored hash table keyed entry address function method storage made function based entry address extremely fast operation look-up based address function caused linear search hash table poorly performing calls exception required linear search reimplemented findfuncbyaddr balanced tree hash table tree structure improved performance look-ups body function expense slower entry point look-ups addition cached recent results repeating look-ups results impressive re-ran benchmark instrumentation time reduced seconds performance improvement timed version results tables interested determining overhead imposed ipath gather call-path profiles unable detect running time paradyn daemon due ipath due behavior function profiling execution time function invocation large overhead imposed ipath completely hidden summary ipath localize severe performance problem previously funciton-level profiler discovered utility function findfuncbyaddr performing poorly profile data investigation code failed localize reason performance problem ipath page determine call-path bottleneck finally ipath allowed profile function bottleneck functions paradyn daemon selectivity allowed efficiently profile findfuncbyaddr excessive overhead summary call-path profiling valuable tool performance analysis presented method gathering call-path profile data functions approach avoids overhead incurred whole-program call-path profilers instrumenting functions interest function entries exits call sites program expensive metrics reducing total overhead implemented method tool ipath built dyninst instrumentation library tool user target call-path profiling functions advantage hardware software performance metrics current implementation runs ialinux power aix analyze distributed programs sequential programs ipath isolate correct bottlenecks programs ipath located characterized synchronization bottlenecks milc rmd simulation call-path profile data identify calls mpi functions caused poor performance ipath collects complete call-path unwind milc abstraction layer replaced blocking synchronous mpi calls asynchronous equivalents reordered calls hide message passing latency resulted decrease running time rmd simulation call-path profiling reduce synchronization blocking time wide range distributed programs make library functions communication identifying call chains bottlenecks unoptimized min sec optimized min sec change single-threaded threads threads threads table performance consultant analysis time required complete full automated analysis tested programs program multi-threaded tests page ipath identified bottleneck sequential program instrumentation daemon component distributed paradyn parallel performance tool discovered repaired single utility function incorrectly optimized based results function-level profiling examination source code majority callers function presented similar behavior programmer optimized utility function based assumption call-path profiling determined single call overwhelmingly responsible time spent utility function call advantage previous optimizations reoptimizing function reduce paradyn instrumentation time call-path profiling accurately characterize behavior utility function based run-time information analysis source code situation call-path profiling improve programs make utility functions source-level analysis misleading impossible ammons ball larus exploiting hardware performance counters flow context sensitive profiling sigplan conference programming language design implementation pldi las vegas june ball larus efficient path profiling annual ieee acm international symposium microarchitecture paris december bernard ogilvie degrand detar gottlieb kransitz siugar toussaint studying quarks gluons mimd parallel computers international journal supercomputer applications buck hollingsworth api runtime code patching international journal high performance computing applications winter derose wolf catch call-graph based automatic tool capture hardware performance metrics mpi openmp applications international euro-par conference paderborn germany gottlieb liu toussaint renken sugar algorithms numerical simulation quantum chromodynamics physical review graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june hall call path refinement profiles ieee transactions software engineering june hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high-performance computing conf knoxville tenn page larus program paths sigplan conference programming languages design implementation atlanta malony shende bell trebon advances tau performance system performance analysis distributed computing kluwer norwell melski interprocedural path profiling interprocedural express-lane transformation dissertation wisconsin madison melski reps interprocedural path profiling international conference compiler construction amsterdam march miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november pmapi home page http alphaworks ibm tech pmapi february sprof linux utility 
stack trace analysis large scale debugging dorian arnold dong ahn bronis supinski gregory lee barton miller martin schulz computer sciences department lawrence livermore national laboratory wisconsin livermore madison ahn bronis lee schulzm llnl gov darnold bart wisc abstract runtime tools modestly sized computing systems processors scale work poorly present stack trace analysis tool stat aid debugging extreme-scale applications stat reduce problem exploration space thousands processes sampling application stack traces form process equivalence classes groups processes exhibiting similar behavior typical parallel computations large numbers processes exhibit small number behavior classes manifested common patterns stack traces problem space reduced representatives common behavior classes full-featured debuggers root analysis stat scalably collects stack traces sampling period assemble profile application behavior stat routines process trace samples form call graph prefix tree depicts program behavior program process space time prefix tree encodes common behaviors stack samples distinguishing classes behavior representatives targeted deeper analysis stat leverages mrnet infrastructure tool control data analyses overcome scalability barriers encountered heavy-weight debuggers present stat design evaluation shows stat gathers informative process traces thousands processes sub-second latencies significant improvement existing tools case studies production codes verify stat supports quick identification errors previously difficult locate introduction lawrence livermore national laboratory llnl bluegene set current benchmark extremely large scale systems processors supercomputer class systems cray promise operate part work performed auspices department energy california lawrence livermore national laboratory contract -engucrl-abs- work supported part department energy grants de-fg defg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon processing cores recent top list systems processors systems government initiatives petaflop scale systems united states europe japan china high-performance computing hpc systems processors commonplace processor systems introduced tools debugging analyzing programs existing scales non-existent totalview arguably advanced parallel debugger takes minutes collect compose stack traces processes work targets identification diagnosis application behavior set questions aim users answer include application application making progress stuck deadlock infinite loop noted roth arnold miller developing scalable diagnosis tool presents challenges overwhelming channels control existing parallel debuggers single frontend process controls interactions back-end tool daemon processes processes application debugged front-end spends unacceptably long times managing connections back-end daemons large process counts large data volumes number debugged processes increases volume data prohibitively expensive gather excessive data analysis overhead debug data gathered acceptable time time process present excessive causing users resort targeted print statements scalable presentation results finally presenting standard source code trace individual processes overwhelms user prevents quick anomaly detection alternative presentation paradigms synthesize set processes essential address challenges present stack trace analysis tool stat manages scalable collection analysis visualization stack trace profiles depict application behavior specifically sample application stack traces form process equivalence classes groups processes exhibiting similar behavior experience shows typical parallel computations large numbers processes exhibit small number behaviors exhibiting coding errors specifically coding errors frequently manifest unexpected behavior small number subsets single subset processes similar runtime behavior errors detected spatial differentiation process space unexpected behavior typically temporal aspect behavior erroneous occurs persists mechanisms detect equivalence classes quickly allowing user focus single representative identify equivalence classes present user call graph prefix tree distinguishes visually achieve scalability leveraging tree-based overlay network model exploits logarithmic scaling properties trees tool control data analyses specifically stat leverages mrnet implementation premise scalable lightweight diagnosis approach effectively reduce exploration space thousands millions processes handful behavior classes class representatives problem space effectively reduced perform root analysis full-featured debugger debugger attach small subset processes rest paper details main contributions simple highly effective stack trace analysis technique reduces debug exploration spaces thousands handful processes sub-second latencies process group visualizations effectively guide users problem diagnoses displaying spatial temporal relationships scalable tool prototype implements analysis visualization techniques section present case studies production codes motivate stack trace analysis approach section present details techniques stat design implementation performance section section apply stat tool case studies discuss future research related tools research discussed section finally summarize expected impact work section sectionmotivating case studies motivate technology large-scale debugging case studies studies involve problems elusive root ccsm visus parallel applications cases defects manifested hangs large scales llnl machines case studies capture current manual approach large-scale debugging highlight effectiveness present scalability limitations demonstrate tool automatically applies similar techniques quickly scalably pthread deadlock exposed ccsm community climate system model ccsm widely parallel application comprises multiple climatic simulators representing atmosphere ocean sea ice land surface connected coupling module years scientists ccsm components improve climate predictions recently llnl climate scientist reported intermittent hangs running ccsm mpi tasks thunder machine itanium cluster quadrics elan interconnect factors made diagnostic process extremely challenging instance ccsm consists multiple programs multiple data mpmd importantly malfunction occurred large scale non-deterministically manifested apparently random program locations ten days repeated attempts reproduce problem controlled environment hang occurred analysis debug data reproduction hang suggested pthread deadlock mpi task additional data reproduction error confirmed figure depicts manual data gathering postmortem analysis applied reproduction error attached mpi tasks totalview gather call graphs capture dynamic behavior tasks enhancement prototyped llnl totalview call graph display view program spatial behavior job processes leftmost graph figure shows top agglomerated call graph mpi tasks stack traces view reveals characteristic user job first-level process clusters coupler tasks land model figure manual debugging practice ccsm hang mpi tasks tasks ice model tasks ocean model tasks atmosphere model tasks application modules depicted sub-graphs rooted main center graph figure suggests interesting behavior set atmosphere tasks form clusters rooted stepon function node cluster consists task tasks atmospheric model comparison details task task arbitrary representative cluster deadlock task specifically task reentered pthread mutex lock function elan library asynchronous interrupt due unix signal handler invocation rightmost graph figure tasks stalled polling mpi waitall consequence deadlock task multiple stack trace snapshots time task identical supporting deadlock theory high-level analysis aided round debugging immediately noticed tasks formed similar anomalous cluster totalview analysis revealed anomalous tasks attempting re-lock mutex mutex type pthread mutex normal results deadlock linux theorize quadrics qsnetii software internal interconnect management raised unix signal clear elan remove zone function made signal safe integer overflow visus visualization streams ultimate scalability visus research project develops data streaming techniques progressive processing visualization large scientific 
data sets year ago llnl developer reported hang scaling test hang occurred deterministically scales tasks smallest scale exhibiting defect capability debugger developer forced debug print statements ad-hoc parsers written process voluminous output change printed output demanded parsers ultimately strategy proved ineffective analyzing defect scale eventually scalable version totalview scale continued pose challenge debugging tasks totalview warranted upper limit careful provisioning avoidance non-scalable operations allowed tool requisite scale debugging tool diagnosis root hang simple debugger allowed discovery unintentionally formed infinite loop due -bit integer overflow case studies demonstrate facts program errors show scales errors non-deterministic difficult reproduce stack traces provide insight deficiencies exist current tools collecting rendering information provide information run effectively requisite scale stat addresses deficiencies scalable lightweight approach expediently collecting analyzing rendering information reduce problem manageable subset large-scale job scalable stack trace analysis motivated manual debugging practices demonstrated case studies section propose automated lightweight technique scalably reducing problem exploration spaces approach analyzes application process stack traces discover process equivalence classes processes exhibiting similar behavior based functions executing approach facilitates scalable data analysis scalable visualizations guide user diagnosis process section detail stack trace analysis approach begin discussing rudimentary techniques processing stack traces distributed application space implemented existing tools expand techniques technique stack traces collected time process space identify application behavior discussion introduce simple mpi program target problem diagnosis program process ranks organized virtual ring process performs asynchronous receive operation predecessor ring asynchronous send successor process blocks requests complete mpi waitall program synchronization point mpi barrier ring communication code includes intentional bug mpi process reach send operation singleton stack traces figure illustrates fundamental data object analysis stack trace depicts caller callee relationships functions executed process model distinguish functions invocation paths words function invoked multiple times call paths occurs multiple times stack trace functions invoked call paths including recursively demonstrate application semantics user visible distinction distinction invocation means merged stack traces result tree easier analyze algorithmically manually general directed graph singleton stack traces supported debuggers typically textual representation singleton traces user evaluate behavior large application effectively thousand processes generate thousand stack traces threshold human comprehensibility figure stack trace showing caller callee relationships functions executed d-trace space analysis address deficiency singleton traces tools totalview prism support call d-trace space analysis merging single stack trace application process call graph prefix tree maps stack traces application processes space presumption common reality significant overlap individual stack traces processes merge small call graph prefix tree data object illustrated figure compares call graph prefix tree totalview call graph users quickly focus small number individual processes stat analyzes traces depict process equivalence classes processes class shown color contrast totalview presents information call graph distinguish invocation path function leading general directed graph easily partitioned equivalence classes sta tool totalview figure d-trace space call graphs stat distinguishing nodes based call paths totalview representing nodes call path history stat tree representation create equivalence classes processes displays intuitevely d-trace time analysis d-trace space call graph prefix trees wellsuited analyzing static scenarios examining core dumps include temporal information answer questions application progress deadlock livelock conditions performance address issues introduce d-trace time analyses merge analyze sequence stack traces single process collected sampling interval figure shows analyses renders profile process behavior time allowing user length sampling period terms number samples collect interval samples stat user control granularity traces sampled tool overhead coverage collected profile d-trace time call graph d-trace space time call graph figure stat call graph prefix trees d-trace time call graph prefix tree showing call paths process exhibited sampling period trace space time call graph prefix tree showing global application profile distinguishing unique behaviors process equivalence classes d-trace space time analysis d-trace time analysis user profile individual process quickly singleton stack traces ineffective method understanding collective behavior thousands processes solution d-trace space time analysis combines previous analysis techniques merge analyze sequences stack traces multiple processes assemble global application profile figure identified process equivalence classes distinguish sets process behaviors exhibited application visualizations influenced miller criteria good parallel program visualization briefly discuss visualization results d-trace space time analysis observe guiding principles visualizations guide rationalize presenting profile applications behavior sampling period identifying equivalence classes similar process behavior user quickly extract knowledge program behavior scalability crucial thousands processes scalable display call graphs process merge graphs single compact tree discussed color distinguish classes process behavior helps user navigate complicated graphs color inform entertain visualizations color distinguish classes process behavior nodes identical color represent stack frames groups processes executing instructions program visualizations provide meaningful labels node labels appropriately identify function invoked level stack trace edge labels identify number processes ranks call path starting root node traversing edge labels identify behavior single process assemble global picture dominant application behaviors stat stack trace analysis tool section describe stat scalable implementation d-trace space time analysis present tool implementation performance application case studies section discuss scalable visualization future enhancements stat design implementation stat composed main components tool front-end tool daemons stack trace analysis routines front-end controls collection application stack trace samples tool daemons collected stack traces processed stack trace analysis routines front-end renders result single call graph prefix tree stat utilizes mrnet on-based multicast reduction network infrastructure developed wisconsin tree-based overlay network network hierarchically-organized processes exploits logarithmic scaling properties trees provide scalable application control data collection data analyses mrnet tree processes forms infrastructure stat front-end back-ends communicate mrnet data filter abstraction implement stack trace analysis algorithm executes tree parent nodes data streams children nodes process organization analysis computation distributed tool daemons merge node-local samples combines local traces whole-program view front-end stat driver front-end responsibility instantiate mrnet tree tool daemon back-ends established frontend mrnet api dynamically loads processes stat custom filter processes collected stack trace samples front-end instructs daemon attach application processes local daemon compute node attach phase front-end instructs daemon collect stack trace samples application processes sampling period defined sample count interval samples collected samples propagated result d-trace space time call graph prefix tree finally front-end color-codes process equivalence classes exports graph dot format file stat back-end simple daemon implements capabilities attach application processes sample process stack traces merge analyze locally-collected samples propagate analysis 
results tree dyninst dynamic instrumentation library debug unmodified application processes tool daemon including back-end processes locally collected stack trace samples core function implements stack trace merge analysis routines propagating results function filter internal processes stat filter inputs vector packets child executing internal node outputs single packet stat packet encapsulates call graph prefix tree core function filter inputs call graph prefix trees outputs result merging single call graph prefix tree function merge input trees single tree propagated single global tree obtained stat front-end performance evaluation test stat performance thunder node cluster llnl node ghz intel itanium cpus memory nodes connected quadrics qsnetii interconnect quadrics elan network processor experiments debug mpi message ring program section scales application run allocation nodes mpi tasks node debugging stat daemons co-located application processes place tool daemon process node application allocation tool daemon debugs application processes rest front-end internal nodes separate allocation evaluate stat performance measuring latency front-end broadcast collect stack trace samples global call graph prefix tree frontend omit sampling duration determined number samples sampling interval chosen user experiments collected samples process interval samples micro-benchmark experiments show average takes seconds stat collect stack trace application seconds subsequent samples dyninst parsing application image accurate traces high initial sampling latency stat caches information subsequent samples compare performance types tree topologies -deep trees standard tool organization front-end directly connected tooldaemons -deep tree intermediate level internal nodes -deep trees completely balanced parent processes number children results experiments debugging application processes shown figure expected scale size application debugged latency -deep tree grows linearly number application processes debugged latency -deep trees increase slower rate due controlled fan-out scale increases natural increase depth tree maintain scalable performance experiments trees depth sufficient figure stat performance flat tree directly connects tool front-end back-end daemons -deep tree intermediate level processes stat real applications apply stat real large-scale debugging cases presented anomalies section results empirical evaluation demonstrate tool insights dynamic behavior real anomalies applying stat visus apply tool visus reintroducing bug code reduced scale tasks based subsequently found reproduce hang lower scales program hangs apply stat running job attach tasks sampling ten stack traces interval milliseconds samples figure shows portion stat graph capturing spatial temporal behavior figure tasks behave homogeneously entering composite function node coloring scheme reveals first-level cluster refinement function yielding sub-clusters label link forked composite node shows rank membership sub-cluster majority tasks executes handle src function tasks invoke handle cmp task rank executes handle cmp handle mux cluster refinement correctly uncovers important characteristic visus tasks form virtual tree network composite local data efficiently global data tasks participate producing task-specific local data handle src small subset composites local data composited root task tree writes file handle mux graph shows anomaly perturb normal cluster structure removed bottom stat graph member tasks cluster carry mpi communication calls unlike ccsm case figure d-trace space time stat graph visus examining refinements cluster identify outlier tasks root hang graph naturally guides attention composite function examining small code section composite function insight infinite loop handle cmp handle src handle mux enclosed loop root analysis pick representative processes rank rank rank cluster investigate tasks full-featured debugger quickly locate bit integer overflow applying debugging features lock-stepping evaluation points bit integer overflow prevented handle src function returning loop terminating code figure d-trace space time stat graph ccsm applying stat ccsm apply stat ccsm hangs original configuration stat temporal behavior analysis effectively guides detection deadlock condition mpi task figure graph capturing spatial temporal aspects program graph depicts offending task make progress sample period separating tasks partutilitiesmodule parexchagevec function call path function node child node scalable visualization stack trace analysis results drastically reduced graphs compared visualizing nodes stack traces individually previous examples shown reduced graphs large complex cases detection equivalence classes coloring coding structure display insufficient reduce complexity presented graphs losing detailed information reduce size displayed graphs provide optional pruning method default displaying easily comprehensible representation pruned graph users expand pruned segments demand analyze relevant components deeply trees directed graphs stat implicitly leads generation hierarchical equivalence classes subtree complete stack trace information equivalence class subdivided classes represented lower branches tree property natural abstraction pruning larger trees pruning subtree results aggregating finer-grain equivalence classes coarse grain destroy abstraction produced stat mechanism true level detail selection mechanism possibility misguiding user higher levels abstraction similar approach based general directed graphs require complex expensive node coloring schemes additional pruning criteria call graphs transition user application library functions opaque user prune subgraphs nodes represent mpi routines examples shown demonstrate significantly reduce size graphs cases call graph variations occur mpi library idea pruning trees extended user dynamically prune tree level user high-level view tree fixed number branches starting root node interactively select expand existing branch interactive selection zoom detail supported traditional graph viewer file browser display hierarchical representations support dynamic expansion contraction hierarchy levels major source complexity graph visualization list process ranks edge large node counts lists long fragmented difficult interpret concrete list required obtain overview suggest replace textual representation graphical form bar code digital fingerprint users identify compare node sets quickly visually compare individual rank numbers request analyze leave nodes graphical representations expanded actual rank lists work feature progress included final paper future enhancements current tool powerful abstraction state parallel application actual diagnosis problem detection anomalous process user tool step plan integrate tool analysis techniques automate process problem identification statistical clustering call trees ranks identify processes distinct potentially anomalous behavior similarly integrate techniques detect problems typically found message passing codes load imbalances excessive waits support automatic analysis plan extend tool compare data multiple runs add additional dimension stack traces combined manual tagging runs instance good erroneous provide easy identify anomalies related work work focuses scalable strategies diagnosing problems large scale parallel distributed applications myriad tools research area exists section present related work categories parallel debuggers problem diagnosis data analysis automated debugging techniques years parallel debuggers targeted variety programming languages hardware platforms including ladebug mantis mpc pdbx prism totalview capability viewing individual process stack traces prism totalview debuggers aggregate individual process stack traces single call graph tree tool accommodates time-varying views call graphs 
answer questions programs behavior time non-scalable single level hierarchy tool front-end directly connected back-end processes ladebug support aggregated stack traces data aggregation responsive tool control data collection finally mantis supports colored process grid visualization node colors reflect process status running stopped error fully-functional nature debuggers partially renders non-scalable view lightweight sta approach complementary tools scalably reduce exploration space users apply heavy-weight tools projects investigated statistical methods automated application analysis work dickenson collect call profiles program runs distance metrics cluster similar profiles profiles cluster analyzed determine cluster represents anomaly yuan apply supervised classification algorithm classify system call traces based similarity previously analyzed traces diagnosed problems magpie stringedit distance metric measure string difference cluster events events belong sufficiently large cluster considered anomalous mirgorodskiy distance metrics categorize data control-flow traces identifying traces substantially differ perform root diagnosis instance identifying call path contributed profile dissimilarity pinpoint clustering decision trees client-server traces correlate request failures failures occurring components service requests finally ahn vetter multivariate statistics cluster large performance data sets scalable analysis visualization stack trace analysis approaches analyze collected runtime data identify anomalies approaches designed run post mortem application exited analysis light-weight making scalable suitable diagnosing program behavior application running researchers explored techniques locate specific types errors automatically umpire marmot intel message checker trace mpi executions detect violations mpi standard including resource leaks deadlocks type mismatches intel thread checker assure simulates openmp directives automatically identifies race conditions common openmp errors finally tools including valgrind totalview automatically detect memory usage errors including leaks stray writes tools provide precise information locations coding errors cost significant overhead intended applied production large scale jobs final step development process expensive techniques locate classes errors precisely explore fast scalable automated techniques locate problem coding regions tasks conclusion presented design implementation stat scalable stack trace analysis tool tool addresses issue increasingly important large scale parallel platforms diagnosis program errors emerge production runs high processor counts specifically provide method assembling stack traces processes parallel job d-trace space time diagram diagram captures hierarchical equivalence classes execution paths processes allowing programmers focus subsets tasks code regions quickly stat builds scalable mrnet tool infrastructure stat tree intermediate tool processes assembles d-trace space time diagrams highly scalable manner performance results demonstrate stat significantly improves ability examine stack traces parallel job achieves sub-second latencies thousands processes compared multiple seconds existing tools performance critical current high latencies sufficient make programmers give mission critical tasks importantly presented case studies real world application debugging experiences demonstrated stat substantially improve ability locate root errors quickly accurately top supercomputer sites http top absoft debugging solution fortran compilers http absoft products debuggers debugger html ahn vetter scalable analysis techniques microprocessor performance counter metrics baltimore maryland ats software mpc workshop http atssoft products mpcworkshop htm balle brett chen lafrance-linden extending traditional debugger debug massively parallel applications journal parallel distributed computing barham donnelly isaacs mortier magpie request extraction workload modelling osdi blackmon boville bryan dickinson gent kiehl moritz randall shukla solomon bonan doney fung hack hunke hurrell community climate system model bulletin american meteorological society buck hollingsworth api runtime code patching international journal high performance computing applications winter chen kiciman fratkin fox brewer pinpoint problem determination large dynamic internet services international conference dependable systems networks dsn washington usa ieee computer society desouza kuhn supinski samofalov zheltov bratanov automated scalable debugging mpi programs intel message checker international workshop software engineering high performance computing system applications se-hpcs louis dickinson leon podgurski finding failures cluster analysis execution profiles international conference software engineering icse washington usa ieee computer society etnus llc totalview http etnus totalview hood project building portable distributed debugger sigmetrics symposium parallel distributed tools spdt philadelphia ibm parallel environment http wwwibm systems software html intel intel threadchecker http intel support performancetools threadchecker krammer muller resch mpi analysis error detection marmot europvm mpi budapest hungary september lawrence livermore national laboratory thunder http llnl gov linux thunder lumetta culler mantis parallel debugger sigmetrics symposium parallel distributed tools spdt philadelphia miller draw draw essay parallel program visualization journal parallel distributed computing mirgorodskiy maruyama miller problem diagnosis large-scale computing environments tampa florida november nethercote seward valgrind program supervision framework electronic notes theoretical computer science pascucci visus visualization streams ultimate scalability technical report ucrltr- lawrence livermore national laboratory february quadrics supercomputers world quadrics documentation collection http quadrics onlinedocs linux html index html roth arnold miller mrnet software-based multicast reduction network scalable tools phoenix thinking machines corporation prism user guide december vetter supinski dynamic software testing mpi applications umpire acm ieee conference supercomputing dallas texas united states november yuan lao wen zhang wang automated problem diagnosis event traces eurosys leuven belgium april 
empirical study robustness macos applications random testing abstract report fourth series studies reliability application programs face random input previous years studied reliability unix command line x-window based gui applications windows applications study apply fuzz testing techniques applications running mac operating system continue simple simplistic technique unstructured black-box random testing failure crash hang previous studies technique crude effective locating bugs real programs tested reliability command-line unix utilities thirty graphical applications mac feeding random input report application failures crashes dumps core hangs loops indefinitely source code identify failures categorize testing crashed command-line utilities considerably lower rate failure observed cases previous studies found gui-based applications reliable thirty tested crash hang twenty crashed hung gui results noticeably worse previous windows win unix x-windows studies categories subject descriptors testing debugging testing tools general terms reliability key words fuzz random testing introduction published study reliability unix command line applications study motivated experience dark stormy night authors connected office computer dial-up line typical midwest thunderstorm progress due storm significant amount noise line modem predated general error correction programmers day experienced race type command noise overwhelmed typing presence noise surprising fact noise causing important commonly utilities crash surprising set study phenomenon systematically developed fuzz testing sending unstructured random input application program simple tools tested command line utility programs versions unix result testing crash surprising number programs crashes typically caused risky programming practices experienced programmers software engineering community re-tested unix command line utilities increasing number utilities unix versions tested extending fuzz testing x-window gui applications window server network services standard library interface commercial systems tested crash command line utilities open-source gnu utilities utilities distributed linux crashes similar occasionally identical study x-window applications tested crash hang based random valid keyboard mouse events crashes hangs similar command line utilities memorable result study distinctly reliability testing open-source tools shifted focus commodity desktop operating system microsoft windows win interface random valid mouse keyboard events application programs crash hang programs tested windows windows back time testing popular computing platform apple mac mac major step apple switching unix-based bsd operating system nextstep called cocoa apple extensions tested unix command line utilities gui-based application programs starting study expected command line utilities excellent reliability context fuzz testing barton miller gregory cooksey fredrick moore bart cooksey fredrick wisc computer sciences department wisconsin madison usa permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee july portland usa copyright acm expectation based years published studies widening usage fuzz testing freely fuzz tools results reasonable disappointed find reliability linux gnu tools tested expect testing guibased applications results turned worse expected specifically found key results command line utilities tested ten crashed failure rate hung results similar results gnu utilities study testing gui-based utilities valid mouse keyboard input produced large number failures thirty programs tested crashed hung failure rate result worst showing history testing effort types simple programming errors led failures present current tests fact failures found earlier tests present study section briefly describes fuzz tools study basic command line tools fuzz ptyjig changed earlier form describe detail fuzzaqua tool testing gui-based applications section describes experimental methods section details test results section analyze results discuss failures provide commentary fuzz testing attempting place context section discusses related work conclude section testing tools mac describe tools test command line utilities mac section tools essentially previous studies describe tools test gui applications mac aqua interface section goal tools provide source random keyboard mouse events previously x-windows unix win windows command line fuzz tools part testing effort repeat tests previous studies command-line utilities provided mac utilities tested included bsd subsystem developer-tools packages included operating system necessarily required perform tests tools fuzz ptyjig studies tools run required minor porting updating ansi required substantive main tool original studies fuzz random-character generator options adjust basic characteristics output options null zero-byte characters included output null bytes confuse string processing include printable ascii characters characters non-printable characters sign-bit problems variables type char number seed random-number generator number characters produce varying options generated files random characters combination random seeds file sizes characters similar option combinations previous studies files generated simple matter provide file input target applications small number applications require access underlying terminal device simply piping characters application work problem solved ptyjig run arbitrary command-line application pseudo-terminal sending standard input target application acceptable manner normal fuzz data piped ptyjig presented application desired applications needed ptyjig emacs nano vim gui fuzz tools part testing evaluate reliability applications graphical user interfaces significant applications based interfaces type testing crucial completeness previous win windows studies developed techniques send valid keyboard mouse inputs target applications previous studies generated invalid inputs generated keyboard mouse chose repeat studies produce insights task requires send manufactured events application events indistinguishable normal user input figure shows path user input event takes makes mac system input device active application event arrives device drivers window server forwarded correct application event queue based application active current position mouse screen mac points event path called event taps program insert eavesdrop events passing system tap point device drivers insert events created physical device system point device-created events remote operation events enter user session tap events annotated window server intended specific application fourth tap window server sends events applications event queues intended insert synthesized events event tap key presses mouse clicks application testing system api creating inserting user input events event stream function properly mouse events remote operation api create send mouse events target application figure shows routes send events sending mouse-click events arbitrary application requires finding point screen correspond window target application repeatability generate events targeted points relative coordinates target application windows mac effectively isolates applications application query system application windows obtain list windows open system windows accessibility api supports features required fuzz testing unreliable depends explicit application support cases lacking consistently enumerate windows target application simply generated random points global screen coordinates queried system points generated fell windows target application developed objective-c tool fuzz-aqua named aqua graphical user interface sending random 
streams input events application tool selects randomly basic event types listed event primitives implement generate keypress click doubleclick drag events arbitrary combinations modifier keys command option control shift combinations events simplistic user typing quickly complete keystroke time overlap keystrokes row convinced sophisticated input model test applications practice simple model produced considerable number application failures invoked fuzz-aqua command fuzz-aqua qmesc pid options delay events qmesc send keyboard events keys escape pressed combination cmd modifier key restriction prevents fuzz-aqua minimizing quitting program testing prevents invoking system-wide hot key commands logging current user pid process applications test number user-input events send experimental method tools previous section test command-line gui-based applications mac describe applications tested test environment tests performed discuss data collected analyzed platform applications tests performed macintosh computers version mac -mhz powerbooks dual-ghz single core powermac ideally run test machine software failures correlated hardware configurations time constraints permit degree thoroughness tested command-line applications fuzz input section compared applications applications tested linux platform study note applications tested similar applications tested make attempt providing correspondence utilities tested current study groff simply front-end program troff tables list applications tested test results current study study table lists applications crashed platforms table lists applications crash tested thirty graphical applications options section applications tested listed table results dismal twenty applications crashed hung crashing applications hung test runs figure mac event path input device application event taps denoted diamonds keypress key click mouse button doubleclick click drag mouse button mouse move mouse button application determine device driver event target application queue annotated events remote control device input inserted mouse events inserted keyboard events window server scrollwheel wheel movement specific amount failure criteria previous studies measure reliability simple crude absence crash hang command line tests run scripts check presence core file crash non-responsiveness based time-out hang program completes crash hang prints nonsensical results classify failure types testing equipped failures gui applications technique similar run applications fuzz-aqua checking system-generated crash log timing-out program hangs results describe basic quantitative success failure results observed tests outcome test classified categories application crashed completely application hung stopped responding application processed input terminate normal application mechanisms exited control categories simple categorize success failure application simple inspection provide analysis failures applications source code quantitative test results tables summarize command line testing results mac table lists utilities crashed table lists utilities crash study compares previous results linux study year note command line tests run windows study tables divide utilities categories found mac test machines found mac previous linux study mac utilities strict superset tested linux category amount type test data testing mac utilities linux utilities line table lists utility platform test results end table quantitative summary results mac results summary utilities tested platform totaling results mac mac linux categories linux results summarize utilities tested mac linux category application failed runs category column result listed table application crashed hung passed tests command line results mac cover largest number utilities tested quantitatively results good previous studies utilities crashed hung tests table summarizes results gui application study part study tested thirty application programs tested unix x-windows study similar number tested microsoft windows study thirty programs startling crashed hung presented random valid keyboard utility linux mac osonly mac expr groff zic zsh mac linux ctags flex gdb indent nroff ditroff troff vim number crash hang number tested percentage table command line utility results crashed hung table mac acid aclocal addftinfo asa automake auval bridget bsdmake bspatch bzip calendar checknr column diff emacs eqn grn gzip hexdump jar java javac javadoc javap jikes ksh lam merge nano native ascii neqn osacompile osascript paste pax perl php pic plutil procmail psed pstopdf python rpcgen ruby script sdiff sdp sliceprint soelim sqlite tab space tclsh test texi dvi texi html unvis units uudecode uuencode vgrind wall wxperl xxd yacc mac linux awk bash bison compress cat col colcrt colrm comm cpp csh diff expand fmt fold ftp gcc grep head join latex mail make refer rev sed sort split strings strip sum tail tbl tee telnet tex tsort uniq table list utilities tested crash hang mouse events comparison x-windows study windows applications windows applications study rapidly evolving collection gui applications years programs basic common tasks web browsing e-mail list sideby-side comparisons individual applications crashes previous studies examined program crashed hung identify failure source code command-line programs tested limited access source code gui-based programs source aquamacs emacs camino firefox thunderbird build problems camino thunderbird debug effort ongoing program failure source categorized categories previous studies note categories failures study categories include failure check return values mistake obvious simple programmers assume call fail work inconvenient handle case fail assumptions wrong short term inconvenience long term problems short term gain long term pain pointer arrays encourage pointers languages array subscripting bounds checking considered training wheels category programmers features continue error prone hands experienced programmers signed characters notion ascii character bit unsigned entity simplification traditional character set recent representations unicode fact char type signed -bit integer situation race conditions assuming operations execute atomically sequential programs dangerous classic receiving interrupt control-c character middle processing previous interrupt character input functions input functions bounds checking operator variables type char inherently dangerous reduction ascribed increased awareness role security attacks stack smashing buffer overruns bad error handling error checking present ineffective problem due difficulty generating test cases obscure behaviors complex program interaction effects error caused program intends input literal string user embeds commands string commands passed unintentionally interpreter format string database query type error major source recent security attacks sub-processes applications code iron-clad safe delegating control functionality sub-process sub-process problems application program problems vendor application result adobe acrobat reader adium adium apple computer calculator dictionary finder garageband ical ichat idvd imovie iphoto itunes keynote mail pages preview safari sherlock textedit xcode aquamacs aquamacs emacs microsoft corporation excel internet explorer powerpoint word mozilla foundation camino firefox thunderbird omni group omniweb opera software opera tested crash hang table gui utility results crash hang types errors found relative frequency roughly similar previous studies exception reduction input function errors remainder section describe diagnosis failures found grouping categories function return codes 
checking return values called function true beginner mistake present modern code code snippet aquamacs emacs call geteventparameter event-handling system call failed returning unchecked error code invalid window pointer output parameter file macterm define mac window frame mac output getwrefcon mfp geteventparameter event keventparamwindowref typewindowref null sizeof windowref null mac window frame invalid window-pointer argument getwrefcon returned null pointer dereferenced crash avoided checking geteventparameter return taking corrective measures pointer array errors pointers array subscripts dominate results tests cases programmer made implicit assumptions contents data processed assumptions caused programmer insufficient checks loop termination conditions values passed functions program reading data fit statically allocated array classic class error segment file array variable obuf defined element array bounds checked program writes past end array corrupting maxcol loop program eventually reads memory range causing memory protection fault getc eof switch obuf col char obuf col mode mode col col maxcol maxcol col continue maxcol obuf mode lastmode problem crops sentinel characters cases programmer assumes input program format program reaches state expecting specific character switching state perform unsafe operations expected character surfaces timezone compiler zic program received open quotation mark reading data expecting matching close quotation mark end string file zic error odd number quotation marks isascii isspace unsigned char error case pernicious appears program exit loop end string reached due call error case error print error message return loop program continues overwrite memory finds quotation mark parenthetically note naming function simply make authors ashamed examined open-source web browser firefox crashed random user input events firefox encountered unsafe dereference null pointer file nsdocument cpp causing application crash nsidocumentobserver observer static cast nsidocumentobserver mobservers elementat observercontentappended acontainer anewindexincontainer semantics make difficult caused problem explanation order case element mobservers null contentappended called null object access member variable object caused program crash mobservers contained null element problem avoided checking returned elementat fourth category utility expr crashed program ran end argument buffer int main int argc char argv struct val void setlocale argv strcmp program called input parameters set memory location past end argv array case points null pointer passed library function strcmp dereferences null pointer crashes signed characters conversion numbers size problems problem compounded characters symbolic numeric forms type char signed -bit integer unix systems presence sign bit confusing error prone possibility sign-extension arithmetic file expr left input line pointer left operatort encoding int left left char operator left char encoding left left illegal rank left rank program reads ascii character input line pointer stores left variable variable sign-extended index encoding array sign-extended left negative left assigned garbage case garbage large index array rank loop condition program crashes memory protection fault bad error handling program error handler detect bad input error handler poorly written crash program troff detected error input crashed print error message due incorrectly escaped character error message string node cpp error translation context call eventually calls function errprint string transformed translation context stored variable format errprint function expects symbol doubled escaped back slash errarg cpp format format switch case case case case default assert error handler finds space character program asserts failure crash due string hardcoded program error case apparently tested tool developers sub-processes reliable program crash invokes robust program sub-process crashes encountered groff nroff occurred tools called troff crashed due problem ran test data caused troff crash source code aqua applications crashed examine stack traces crashes stack traces twenty crashes occurred system library functions occurred function objc msgsend rtp involved calls objects appkit user inteface library low-level function integral objective-c language runtime occurred methods khtml class webcore html rendering library crash function szone calloc libsystem dylib library occurred function bigcopy corefoundation framework occurred quickdraw function setgworld called dealloc method similar destructor class nsquickdrawview final crash occurred function mdquerydisableupdates spotlight file metadata library access source code determine crashes caused invalid arguments functions bugs libraries case crashes avoided checking arguments calling library functions programmers assume library gracefully handle erroneous input analysis commentary change chose pas things change stay optimistic view software evolution learn software development engineering process code naturally pessimist realist note commonly programming languages operating systems notably twenty years ago addition software packages providing features complex view world surprising reliability guibased applications improving worse evaluation stack traces aqua application crashes showed problems wide spread caused isolated problem vendor additional force trend lack demand robust software consumers software continue fixate performance features global demand robust software expect situation change reason hope command line results perfect good stabilized notably modern operating systems bug-free crash twenty years ago systems grown complex continue programming languages managed stable robust goal study pick mac availability system revisit basic evaluation techniques condemning apple results contemporary study gui-based applications unix windows people glass houses throw stones wrote results presented paper make difference bugs found unix study present study found applications based open source reliability commercial vendors study noted subsequent improvement software reliability measure long vendors importantly purchasers features reliability hope reliable applications remains muted release fuzz testing results asked bugs matter present results software developers managers mixture basic responses bugs reflect realistic usage patterns cost effective spend time fixing early years studies good response criticism recent events shown view obsolete kinds bugs find true favorites developing security exploits ignore reliability end vulnerabilities security clear cost garfinkel spafford noted years ago reliability foundation security quote microsoft insecure driver inherently unreliable unreliable driver inherently insecure crash data easy obtain free crashes occur actual bugs fixed view hope hear rarer note easy obtain free test programs results fixes web site bugs bugs code malformed fix view resonates software development true craft job woodworker artist stonemason loath produce work flaw cringe thought fixing flaw pointed view folks working study complete complete access source code happy diagnose failures package table vendor supplies related work random testing years past looked primitive testing community book software testing myers randomly generated input test cases inefficient hoc approach testing type testing hoc find bugs real programs view random testing tool easy larger software testing toolkit body related work random testing huge present part apologize authors papers slighted early paper random testing published duran 
ntafos study test inputs chosen random predefined set test cases authors found random testing fared compared standard partition testing practice track subtle bugs easily hard discover traditional techniques found random testing cost effective testing strategy programs identified random testing mechanism obtain reliability estimates technique primitive easier type random testing duran ntafos programmer knowledge direct tests require construction test cases papers published ghosh random black-box testing applications running windows studies extensions earlier fuzz studies studies authors tested standard command-line utilities windows utilities fared unix counterparts scoring failure rate study interesting significant limitations tested applications attrib chkdsk comp expand find label replace test commonly windows applications based graphic interfaces tested windows gui-based win applications random testing test unix system call interface crashme utility effectively exercises interface actively linux kernel developments recent years projects developed systems testing software structured random input data contrast unstructured minimally structured input data fuzz utilities produce mckeeman describes hierarchy structure random test inputs context compiler testing shows aspects compiler tested input data differing degrees conformance valid program mckeeman describes technique differential testing programs perform function run input outputs compared differences output signaling bug programs sirer bershad context-free grammar generate structured random input form programs java bytecode testing java virtual machines random input black-box testing extensively network protocol testing effective finding security vulnerabilities protocol implementations spike project produces software package supports automated black-box testing network protocols marquis provide language describing network protocols generate wellformed input data protocols mutated order test protocol implementations xiao describe system injecting invalid data network protocols test robustness failures security vulnerabilities random testing software wood found random testing effective designing multiprocessor cache controller hardware developed utility generate random memory accesses simulated cache controller found half functional bugs design simulation fabricating prototype hardware continue testing software order verify design macintosh released apple developed tool similar fuzz-aqua called monkey developers application software computer trouble reproducing bugs occurred situations memory developed utility advantage demonstration feature operating system produce random user input events send current application utility find fix difficult reproduce bugs utility computers started ship memory sort tool today conclusion goal fuzz testing work threefold started effort explain phenomenon observed dark stormy wisconsin night work life goal provide simple test techniques tools add reliability software hope provide concrete measure albeit crude achieving software reliability measure reliability primitive simple strength weakness weakness exploit knowledge semantics program explicitly test program matches specification criterion crude offers mechanism easy apply application crash hang program fuzz testing guises part argot testing security intelligence communities broad acceptance accomplishment on-line resources previous papers test results source binary code fuzz tools previous studies web page http wisc bart fuzz acknowledgments work supported part department energy grant de-fg onr contract government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon aitel advantages block-based protocol analysis security testing immunity february http immunitysec downloads advantages block bas analysis html apple computer http developer apple documentation cocoa conceptual coco afundamentals whatiscocoa chapter section html carrette crashme random input testing http people delphi gjc crashme html duran ntafos evaluation random testing ieee transactions software engineering sejuly forrester miller empirical study robustness windows applications random testing usenix windows systems symposium seattle august appears german translation empirische studie zur stabilit von nt-anwendungen september garfinkel spafford practical unix internet security reilly associates ghosh shah schmid testing robustness windows software international symposium software reliability engineering issre paderborn germany november ghosh shah schmid approach analyzing robustness windows software national information systems security conference crystal city october hertzfeld revolution valley reilly media sebastopol marquis dean knight scl language security testing network applications conference centre advanced studies collaborative research toronto october mckeeman differential testing software digital technical journal digital equipment corporation december myers art software testing wiley publishing york microsoft corporation security reliability strategies http microsoft whdc driver security miller koski lee maganty murthy natarajan steidl fuzz revisited re-examination reliability unix utilities services wisconsin-madison appears german translation empirische studie zur zuverlasskeit von unix-utilities nichts dazu gerlernt september ftp grilled wisc technical papers fuzz-revisted pdf miller fredriksen empirical study reliability unix utilities communications acm december appears german translation fatale fehlertr chtigkeit eine empirische studie zur zuverlassigkeit von unix-utilities march ftp grilled wisc technical papers fuzz pdf sirer bershad production grammars software testing symposium domain-specific languages austin october wood gibson katz verifying multiprocessor cache controller random case generation computer science tech report ucb csd- california berkeley xiao deng wang integrated tcp protocol software testing vulnerability detection international conference computer networks mobile computing shanghai october 
automated discovery mimicry attacks jonathon giffin somesh jha barton miller computer sciences department wisconsin giffin jha bart wisc abstract model-based anomaly detection systems restrict program execution predefined model allowed system call sequences systems detect actual attacks previous research developed manuallyconstructed mimicry evasion attacks avoided detection hiding malicious series system calls valid sequence allowed model work helps automate discovery attacks start models program model application system call behavior model security-critical operating system state unsafe state configurations describe goals attack find system call sequences allowed valid execution program model produce unsafe configurations experiments show automatically find attack sequences models programs wu-ftpd passwd previously discovered manually undetected attacks present frequently find sequences seconds computation key words ids evaluation model checking attacks model-based anomaly detection introduction model-based anomaly detector restricts allowed program execution predefined model acceptable behavior systems compare sequence system calls generated executing program model detector classifies system call sequence deviates model malicious indicative program exploit ability model detect actual attacks depends implicit assumption attacks valid execution attack accepted model valid anomaly detected fig mimicry evasion attacks avoid detection transforming attack sequence system calls accepted program model carries malicious action previous research found examples mimicry attacks high-privilege processes restricted model-based detector attacks constructed manually iterating attack sequence program model attack made normal manually-constructed attacks served successful proof-of-concept manual approaches remain unsuitable general attack discovery strategy paper automates discovery mimicry attacks intent propose detection system provide means evaluate existing program model ability detect attacks address primary questions attacks detected attacks undetected attacks fig set system calls infinite set system call sequences program model accepts subset system call sequences valid program execution attack sequence accepted valid missed attack attacks program model fail detect attacks prove model detect finding missed attacks reveals weaknesses program model model-based detector insufficient security program conversely proving model detects attack establishes strong indications computer system model-based detection secure attacker attempts hide attack legitimate execution attack sequence system calls produces malicious change operating system attack sequence attacker produce variations sequence attack effect inserting extraneous system calls sequence replacing existing system calls alternative sequences effect program model detects sequence obfuscated sequence net result remains model fails detect attack verify model detects attack variants formalism requires knowledge attack sequences knowledge obfuscations hide sequences detector develop model respect security-critical state characterize attacks effect leverages key insight commonality obfuscated attack sequences sequences semantically equivalent respect malicious effect manually produce model definitions malicious state onetime effort reused subsequent analyses models programs executing operating system program model specifies sequences system calls allowed execute system call transforms state variables compute set configurations reachable program execution constrained model apply model checking prove reachable configuration corresponds effect attack proof fails system call sequence allowed model produces malicious effect model checker reports sequence counter-example caused proof fail providing precisely undetected attack output terms fig finding system call sequences contained attacks explicitly computing set attacks malicious system call sequences approach automates previous manual effort finding mimicry attacks experiments show automatically discover mimicry attack stide model wu-ftpd evasion attacks stide models passwd restore traceroute model checking process completed seconds undetected attacks present models model sufficiently strong detect attack model checking algorithm report attack sequence found requires exhaustive search completed seconds attacks detected models test programs note proofs successful detection hold respect abstraction state abstraction erroneous incomplete undetected attacks present model protect complete operating system work addresses outstanding problems model-based anomaly detection provide method model evaluation exhaustively searches sequences system calls allowed valid program model induce malicious configuration state current work evaluates context-insensitive stide model designed system evaluate program model expressible context-sensitive pushdown automaton pda long-term goals realized compare detection capabilities model designs proposed literature summary paper makes contributions automated discovery mimicry attacks model checking find sequences system calls accepted valid program model malicious effects operating system system produces exact sequences system calls arguments comprise undetected attacks system design attack sequences obfuscations system require attack system call sequences enumerated fact strive opposite system automatically find unknown attack sequences accepted program model produce sequences output likewise automatically find obfuscations attackers hide attack system calls legitimate sequence result approach limited priori knowledge attacker behavior section presents related work manual attack analysis section overview system section describes operating system abstraction sect explains model checker abstraction find undetected attacks program model section presents architecture implementation sect implementation demonstrate experimentally automated previously manual process discovering undetected attacks related work seminal research mimicry evasion attacks demonstrated critical shortcoming model-based anomaly detection attackers avoid detection altering attacks program normal execution altered attacks sequences system calls allowed program model malicious execution previous work constructed mimicry evasion attacks converting detected attack system call sequence equivalent undetected sequence semantically equivalent sequence allowed program model successful undetected attack determining model expressed pushdown automaton accepts computable intersection operation provided regular finding sequence intersect manual incomplete procedure drawbacks procedure requires attack sequences equivalence system call sequences defined undetected attack sequence include legitimate execution behavior irrelevant original attack sequence equivalent clear operational direction find mimicry evasion attacks automatically identifying sequences equivalent attacks manual procedure based intuition algorithmic process amenable automation model evaluation takes approach advances state art defining attacks malicious effects system work restricted attack sequences system calls attack transformations producing evasive attacks attack sequences part input system fact work produces sequences output define system call sequences equivalent respect attack produce malicious effect operating system formalism operational direction allowing work automate procedure finding undetected attacks previous attempts made quantify ability model detect attacks average branching factor abf calculates finite-state machine model average opportunity attacker undetectably execute malicious system call program execution predefined partitioning divides set system calls safe calls potentially malicious calls runtime monitor paths automaton response system calls executed program ahead transition determine number potentially malicious calls allowed operation average branching factor sum potentially malicious calls divided number system call operations verified execution extension average branching factor called average reachability measure arm similarly evaluated pushdown automaton models measurements provide convenient numeric score enabling model comparisons provide clear measure model ability detect attacks metrics effectively embody attacker abilities attacker alter program execution reach portion program model admits attack sequence 
passing sequence safe system calls system call branching benign execution path abf arm fail show strength model abf arm computed depends benign execution path program input complete evaluation model requires computing score execution paths extremely challenging forms entire body research program testing area attacks frequently comprised sequence system calls previous metrics system call isolation characterize longer attack sequences metrics provide limited insight model ability detect attacks work improves evaluation program model attack detection ability decoupling evaluation execution path describe malicious activity unsafe system calls mops similar work aspect statically checks program model determine properties model unlike work mops characterizes unsafe attack behavior regular expressions system calls requires users provide database malicious system call patterns commercial virus scanners syntactically match malicious byte sequences program code mops syntactically matches unsafe system call sequences program model likewise malicious behavior discovered database system call patterns updated conversely understanding semantics system calls system paper require malicious system call sequences fact automatically discovers user work tied patterns malicious system call execution model checking generic technique verify properties state transition systems applied previously computer security bessen model checkers verify safety properties expressed linear-time temporal logic ltl verified properties annotated control-flow graphs graph annotations expressing security properties program code unspecified source analyze automatically constructed program models model checking procedure automatically derives security properties model traverses model edges guttman model checking find violations information-flow requirements selinux policies modeled selinux policy enforcement engine ways information flow multiple processes file system verify information flow mediated trusted process system work goal verification safety properties model system calls alter state ramakrishnan sekar model checking find vulnerabilities interaction multiple processes abstracted file system program execution file system transformer program specifications complicated characterize interprocess communication work expands system abstraction include entire operating system shifts checked interface coarse-grained process execution system calls model communication channels processes walker formal proof techniques verify properties specification unix security kernel work notable authors rigorously proved abstract specification kernel matched actual implementation result properties proved abstraction hold true real operating system due difficulty producing proofs correct specifications research demonstrates abstractions accurate adopt simpler approach produced operating system abstraction manually proved correct result discovered attacks proofs absence attacks hold respect abstraction discovered attack validated running system call sequence sandboxed operating system conversely find attack good indication program model secure provably true real operating system overview provide overview model-based anomaly detection including attacker threats addressed context-sensitive program models purpose attack discovery threat model system automatically constructs undetected attack sequences threat model threat model simple strong set system calls invoking kernel operations program attacker control generate sequence system calls attackers subvert vulnerable program execution execution point including point process initialization attackers arbitrarily alter code data program replace program entire memory image image choosing alternatively attacker replace disk image program trojan loads program execution attacker generate sequence system calls system call arguments operating system execute calls privilege original program threat model matches real-world attacks remote execution environments programs execute remote untrusted machines send sequence remote system calls back trusted machine execution attacker controlling remote host arbitrarily alter replace remote program attacker program image send malicious system calls back trusted machine execution common network-based attacks server programs restrictive threat model attackers subvert execution points program vulnerabilities face greater restrictions attack code execute result system proves program model detects attack strong threat model detect attack restrictive model successful attacks discovered system specific strong threat model program model fail detect attack sequence restricted threat model restricted attacker unable program execute attack system make determination report attacks discovered strong threat model fig vulnerable program reads command characters filenames user input input network void main void char input input input setreuid syslog execing file execve input input struct stat buf syslog echoing file stat input buf int open input rdonly void filedata mmap buf size prot read map private write filedata buf size fig code show system calls boldface library calls italics unsafe call attacker execute arbitrary code program launched network services wrapper daemon xinetd command-code argument input resembles usage programs ftp servers http servers suppose program executed stored inactive privilege real effective user ids low-privilege user saved user root input command character program drops saved privilege executes filename input input command character program echoes contents file output network stream threat model attacker arbitrarily alter execution program attacker exploits vulnerable call attack vector considered attacker program execute system call including system calls contained original program code role host-based intrusion detection detect subverted program execution program model readers familiar pushdown automaton pda models elect bypass section presents background material standard notation previously pda-based program models model-based anomaly detection restricts allowed execution precomputed model allowed behavior program model language acceptor system call sequences abstract representation program expected execution behavior denotes alphabet system calls denotes language accepted system call sequence valid sequences anomalous program execution paper implement program model non-deterministic pushdown automaton pda definition pushdown automaton pda tuple set states set alphabet symbols set stack symbols initial state initial stack configuration set final states pda model close ties program execution state corresponds program point program code initial state corresponds program entry point final states correspond program termination points generally follow exit system call alphabet symbols system calls generated program executes stack symbols return addresses function call returns initial stack empty program begins execution return addresses call stack transition relation describes valid control flows program pda model types transitions system calls negationslash program generate system call transitioning state state pda stack function call return addresses remains unchanged function calls negationslash program pushes return address call stack transitioning state corresponds function call-site program corresponds entry point call destination function returns negationslash program returns function call pops return address call stack transition top symbol pda stack state corresponds program point function return instruction program point control returned program model designs proposed academic literature presented pushdown automata generality pda characterize models pda suitable analysis techniques presented paper context-free languages recognized pda completely class regular languages program models aware accept regular context-free languages characterized pda includes window-based models stide model fig digraph model fig non-deterministic finite automata nfa 
fig bounded-stack pdas deterministic pdas vpstatic model stack-deterministic pdas dyck model non-deterministic pdas fig write execve stat open mmap write read writesetreuid read write statwriteexecve open mmapwrite setreuid open mmap write read write statwriteexecve setreuid read pop push push write push pop pop execve write mmap open stat setreuid stide model digraph model nfa model pda model fig program models code fig expressed pushdown automaton simplicity assume function call generates system call read syslog function call generates write model accepts regular language simply transitions form experiments sect stide model regular language acceptor intentionally designed system analyze pushdown automata relevant wide collection program models varying strength commensurate threat model assume attacker prior knowledge program model constrain execution vulnerable program security system relies ability program model detect attacks finding undetected attacks developed model analysis system evaluates pda-based program model finds undetected attacks design features note operates automatically user provide initial one-time operating system abstraction reused analyze model program executing operating system subsequent analysis requires human input allowing analysis scale easily large collections program models attacks sequences system calls fact system attack sequences output system call arguments significantly alter semantic meaning calls system finds undetected attack sequence system calls additionally system call arguments effect attack construct abstraction operating system respect security-critical state abstraction repeatedly find attacks models programs execute operating system simple running tool models fig shows detect attacks execute shell root privilege tool automatically identifies system call sequence arguments defeats model read setreuid write execve bin read write calls nops irrelevant attack setreuid call alters state gain root access execve call executes shell access long-term goals discovered undetected attacks guide future design program models intrusion detection systems comparing undetected attack sequence original program code fig suggests model alteration eliminate undetected attack model constrains staticallyknown system call argument values attacker undetectably setreuid call set effective user root attacker remains execute shell shell increased privilege additional examples sect operating system model program model answering question posed sect attacks fail detect requires understanding attack means previous work defined attacks malicious sequences system calls directly searching program models sequences drawbacks attacker transform attack sequence detected program model sequence produces malicious effect allowed model meaningless nop system calls inserted attack system calls write changed calls mmap previous work onus finding attack variants human approach poorly handles program models monitor system calls system call arguments identifying nop system calls straightforward allowed system call arguments constrained model decouple approach system call sequences execute attacks observe system call sequence transformations attacker attack impart adverse effect operating system precisely adverse effect characterizes attack captures malicious intent attacker actual system call sequence attacker bring intent priori fact discovered automatically system formalize attacks effect operating system formalize operating system formalization components set state variables set initial assignments variables set system call transition relations alter state variables developing definitions components finally define attack effects state variables collection state variables model security-critical internal operating system state user ids indicating process privilege access permissions files filesystem active file descriptors state variable finite domain dom boolean values integer values definition set state variables set assignments values variables configuration boolean formula characterizes assignments model checking algorithms operate boolean variables variables finite domain simply syntactic sugar represented internally lists boolean variables additionally variables aggregated arrays c-style structures implementation automatically expands flat lists variables operating system per-process file descriptor table abstract structure array file descriptors subset actual file descriptor data relevant security filedescriptortable array maxfd filedescriptor filedescriptor struct inuse boolean forfile integer canread boolean canwrite boolean ateof boolean inuse field file descriptor active remaining fields meaning active descriptors forfile index array file structures shown abstract file system canread canwrite file descriptor read write file pointed forfile field ateof true file descriptor offset end file distinguish writes overwrite data file writes simply append data file identifying operating system data constitutes security-relevant state manual operation subsequent model checking procedure finds undetected attack reports attack exists results hold respect chosen abstraction attack sequence executable validated real operating system running attack sandboxed environment verifying successful model checker finds setuid uid uid uid negationslash euid ruid uid euid uid suid uid uid negationslash euid negationslash ruid uid suid uid euid uid uid euid negationslash ruid negationslash uid suid negationslash uid true fig specification setuid system call unprimed variables denote preconditions hold system call primed variables denote postconditions hold system call variable explicitly altered postcondition remains unchanged attack tangible artifact verified relevant data included abstraction system fail discover mimicry attack result absence attack abstract evidence mathematical proof model detect attack operating real initial assignments values state variables encodes state configuration present process initialized execution write assignments boolean formula state variables assignment satisfying valid initial state work developed boolean formula classes programs formula setuid root programs set initial effective user root formula programs set user low-privilege user system call transformers system calls transform state variables system call provide relation call state based previous state definition system call recall set state variables set assignments set parameter variables system call transformer relation english system call transformer produces assignments values state variables based previous values state write transformation function collection preconditions postconditions depend parameter variables preconditions boolean formulas postconditions boolean formulas precondition formula holds system call executes postcondition formula hold system call fig specification setuid shows system call parameter variable type uid integer valued type boolean formula encodes sets preconditions postconditions line uid argument valid effective user setuid call root call real effective saved user ids set user argument setuid implicitly state variables remain unchanged call line handles case non-root user calling setuid real saved user ids match argument effective user changed state implicitly unchanged line setuid nop transition change state line line preconditions hold true note line redundant omitted setuid specification show emphasize ability setuid nop components operating system abstraction definition operating system model collection state variables boolean formula indicating initial state configuration collection system call transformers attacks attack sequence system calls executes malicious action operating system sequences unique attackers produce infinite number obfuscated attack sequences inserting extraneous nop system calls sequence changing attack system calls semantically-equivalent calls manual 
specification actual attack sequences incomplete attack obfuscations individual attacks circumvent problem effects attacks sequences definition attack effect boolean formula formula characterizes bad operating system configurations indicative successful intrusion describes attacker intent effect attack system call sequence takes initial safe configuration satisfying configuration satisfying attack sequence allowed program model undetected attack automatic attack discovery role automatic attack discovery determine system call sequences accepted valid execution program model induce attack configuration attack effect notation square expresses safety property lineartime temporal logic ltl means globally true program model detect attack attempting induce effect satisfies square executions allowed interpreted model attack goal occur model checker attempts prove formula true proof succeeds attack goal reached system call sequences allowed program model proof fails model checker discovered system call sequence induces attack goal examples expanded sect find attacks execute root-shell undetected models fig attack succeeds executing image file bin effective user image bin euid boolean expression expresses effect attack sequence system calls produces effect running tool models shows detect attack shown sect find undetected attacks write system password file attack succeeds file passwd altered file passwd written true tool automatically finds successful attack digraph nfa models read setreuid write stat open passwd wronly append mmap write attack sequence sets effective user root process open password file add user read stat mmap write calls nops irrelevant attack conversely tool discovers stide pda models detect attack alter password file models accept system call sequence write privilege file passwd finally find undetected attacks add root-level account system execute user-level shell expectation attacker subsequently switch high privilege account combines elements examples image bin file passwd written true system finds attack digraph model read setreuid write stat open passwd wronly append mmap write execve bin system proves stide nfa pda models detect attack attempts obfuscate system call sequence evident models accept sequences open write file subsequent execution program model moped checker attack sequencesyscall specifications compiler system attack configuration initial configuration state variables pda program model pushdown fig architecture implementation model checking proves unsafe configuration reached program model counter-example system call trace produces unsafe configuration verifying transition systems pushdown automata limited implementation options pushdown model checkers moped bebop interchangeable tools analyze pushdown systems implementation moped simply public availability context-sensitive program model verify stream system calls generated executing process call model pushdown automaton pda system calls input tape pda final states correspond program termination points analyze model verify ability detect attacks call model pushdown system definition pushdown system pds tuple element tuple defined definition definition pds identical pda exception pds final states input tape pds transition system analyze properties sequences language acceptor moped verifies sequence system calls pds produce unsafe operating system configuration input moped collection variables pds transition tagged boolean formula formula expresses preconditions variables required hold traversing transition postconditions hold traversal preconditions hold moped traverse transition alter state variables moped input language boolean integer variables integer variables represented internally ordered lists boolean bits written specification compiler produce valid moped input files pda program model state variables initial configuration system call transformers attack prove detected fig compiler converts pda pds straightforward manner simply removing designations final states compiles system call transformer boolean formula expected moped annotates system call transitions pds formulas pds transitions push pop transitions correspond system calls compiler annotates transitions formula preconditions match variable assignment postconditions simply maintain assignment add state pds transitions system call transition precondition transitions attack configuration prove reached model invoke moped proves state reached counterexample trace system calls reaching state experiments implementation find undetected attacks program models appeared academic literature show automated approach find mimicry evasion attacks previously discovered manually automated techniques scaling number test cases compared manual approaches automatically find mimicry evasion attacks previous research found manual analysis previous work considered test programs wu-ftpd restore traceroute passwd vulnerabilities allowing attackers execute root shell forrest successfully detected attack instances model called stide stide model context-insensitive characterization execution learned system call traces generated series training runs wagner soto tan demonstrated attackers modify attacks evade detection stide model cases undetected attacks semantically equivalent original root shell exploit attacks adversely modified system state attacker subsequently gain root access successful attack variants write root-level account user accounts file passwd set passwd world-writable ordinary user add root account set passwd owned attacker attacker add root account automatically found undetected attacks infrastructure analyze stide model programs respect attack goals wu-ftpd constructed stide model original linux training data forrest unable obtain wu-ftpd training data wagner soto stide models constructed data result find attacks wu-ftpd model constructed forrest data reportedly present model constructed wagner data remaining test programs constructed models training data generated manner tan specification compiler combined pda representations stide models specifications linux system calls produce pushdown systems amenable model checking table lists size pda representation stide model program state model included bits global state bits temporary state system call argument variables temporary state reduces moped resource demands exists briefly model checker execution table number states edges transition systems describing stide model test programs boolean state includes bits global state variables bits temporary state system call argument variables wu-ftpd restore traceroute passwd edge count state count table evaluation stide model ability detect classes attacks stide model detect attack model checker unable find undetected attack stide unable protect system attack model checker discovered undetected attack sequence writing passwd normal behavior passwd wu-ftpd restore traceroute passwd execute root shell write passwd set passwd world-writable set passwd attacker-owned table presents ability stide model detect attack designed reach attack goal determined moped model prevent attacker reaching goal transform alter attack sequence system calls reverse model checker find system call sequence arguments accepted model induces unsafe operating system condition figure shows undetected attack traceroute stide model discovered system automatically found attacks researchers previously found manually additional attack due differences forrest training data wagner training data wu-ftpd additional attack restore found previous manual research previous work missed attack manual inspection scale programs attacks research attempt compute results attack goals programs manual inspection likewise difficult show attack analyst simply considered attack successful model checking prove goal unreachable actual system calls 
attacker attempt reach goal close munmap open passwd rdwr append fcntl fcntl fstat mmap read close munmap write fig undetected attack stide model traceroute adds root-level user passwd system calls producing attack effect shown boldface system discovers arguments nop system calls omit arguments conciseness discover actual string written passwd suitable string attacker root bin table model checking running times seconds wu-ftpd restore traceroute passwd execute rootshell write passwd set passwd world-writable set passwd attacker-owned show models test programs detect attacks set passwd world-writable owned attacker assertions previous manual efforts unable make proofs detection hold respect abstraction hold actual implementation sect proofs provide strong indication runtime attack detection real system effective table lists model checker running times seconds model attack goal comparing running times table loose trend apparent cases model checker found attack running times small attack found model checker executed comparatively longer period time disparity expected reflects behavior underlying model checking algorithms model checker finds counter-example disproves logical formula attack sequence violates ltl safety property model checker immediately terminate execution report counter-example successful proof logical formula holds requires model checker follow exhaustively execution paths early termination automating previously manual process attack construction significant achievement surprised ability find undetected attacks attackers significant freedom program models constrain system call arguments system call sequence open write argument constraints misused attacker alter system password file common sequence contained non-trivial program including programs execute root-level privilege required alter password file automated system means understand program model fails table learn classes attack effectively detected program model classes attack require alternative protection strategies important simply models fail detect attacks type attacks missed conclusions model-based intrusion detections systems detect prevent attacks finding undetected attacks manually difficult error-prone unable scale large numbers program models attacks unable prove attack detected showed formalizing effects attacks operating system operational means find undetected attacks automatically model checker attempts prove attack effect hold program model finding counter-examples proof fail find undetected attacks system call sequences arguments accepted valid execution induce malicious attack effect operating system automation find undetected attacks program models previously found manual inspection models efficiency computation seconds computation find undetected attacks indication automated approach easily scale large collections program models acknowledgments anonymous reviewers members wisa project wisconsin helpful comments improved quality paper work supported part office naval research grant nsf grant ccrand department energy grant de-fg jonathon giffin partially supported cisco systems distinguished graduate fellowship somesh jha partially supported nsf career grant cnsthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed hereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government ball rajamani bebop symbolic model checker boolean programs international spin workshop model checking software stanford california aug sep besson jensen etayer thorn model checking security properties control-flow graphs journal computer security chen wagner mops infrastructure examining security properties software acm conference computer communications security ccs washington nov clarke grumberg peled model checking mit press esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems computer aided verification cav chicago illinois july feng giffin huang jha lee miller formalizing sensitivity static analysis intrusion detection ieee symposium security privacy oakland california forrest data sets synthetic ftp http unm immsec data ftp unm normal synth forrest hofmeyr somayaji longstaff sense unix processes ieee symposium security privacy oakland california gao reiter song gray-box program tracking anomaly detection usenix security symposium san diego california aug giffin dagon jha lee miller environment-sensitive intrusion detection international symposium recent advances intrusion detection raid seattle washington sept giffin jha miller detecting manipulated remote call streams usenix security symposium san francisco california aug gopalakrishna spafford vitek efficient intrusion detection automaton inlining ieee symposium security privacy oakland california guttman herzog ramsdell skorupka verifying information flow goals security-enhanced linux journal computer security lam chiueh automatic extraction accurate application-specific sandboxing policy recent advances intrusion detection raid sophia antipolis french riveria france sept ramakrishnan sekar model-based vulnerability analysis computer systems international workshop verification model checking abstract interpretation pisa italy sept schneider enforceable security policies acm transactions information system security feb schwoon model-checking pushdown systems dissertation technische universit unchen june schwoon moped model-checker pushdown systems http fmi unistuttgart szs tools moped sekar bendre bollineni dhurjati fast automaton-based method detecting anomalous program behaviors ieee symposium security privacy oakland california tan killourhy maxion undermining anomaly-based intrusion detection system common exploits recent advances intrusion detection raid urich switzerland oct tan maxion defining operational limits stide anomaly based intrusion detector ieee symposium security privacy oakland california tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding noordwijkerhout netherlands oct wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wagner soto mimicry attacks host based intrusion detection systems acm conference computer communications security washington nov walker kemmerer popek specification verification ucla unix security kernel communications acm feb 
personal redistribute on-line automated performance diagnosis thousands processes abstract performance analysis tools critical effective large parallel computing resources existing tools failed address problems limit scalability management processing volume performance data generated monitoring large number application processes communication large number tool components presentation performance data analysis results applications large number processes paper present approach finding performance problems applications large number processes leverages multicast data aggregation infrastructure address performance tool scalability barriers show design scalable distributed performance diagnosis facility demonstrate design on-line automated strategy finding performance bottlenecks strategy distributed independent bottleneck search agents located tool agent processes monitor running application processes present technique constructing compact displays results bottleneck detection strategy technique called sub-graph folding algorithm presents bottleneck search results dynamic graphs record refinement bottleneck search complexity results graph controlled combining sub-graphs showing similar local application behavior composite sub-graph approach combines synergistic parts performed bottleneck searches programs processes sign tool resource saturation application processes visualization technique reduced search results graph nodes single composite -node graph sub-graph showing qualitative performance information original graph categories subject descriptors performance systems measurement techniques performance attributes general terms performance measurement keywords scalability performance diagnosis tools automation paradyn introduction computational science primary approach addressing open questions areas biology nuclear physics climate studies desire address problems high fidelity driven increasing deployment high-end parallel systems clusters thousands hundreds thousands processors achieving computational potential large-scale systems proven difficult applications achieve small percentage system peak performance exception rule tuning performance parallel program make large-scale system requires understanding program behavior tools identifying diagnosing performance problems critical understanding program behavior large-scale systems tools scalable effective identified barriers performance tools scaling management large-volume performance data flows generated monitoring large number processes efficient control large number tool agent processes presentation performance diagnosis results large number processes previous work partially addressed scalability barriers infrastructure called mrnet overlay network processes provide multicast data aggregation services tools scalable mechanism obtaining global application performance data data describing behavior application processes average cpu utilization processes infrastructure allowed partially philip roth computer science mathematics division oak ridge national laboratory bethel valley oak ridge usa rothpc ornl gov barton miller computer sciences department wisconsin madison dayton madison usa bart wisc copyright association computing machinery author version work posted permission acm personal redistribution definitive version published proceedings acm sigplan symposium principles practice parallel programming ppopp york march significant parts work undertaken author student computer sciences department wisconsin madison work supported part department energy grant defg lawrence livermore national lab grant nsf grants cdaand eiathis research sponsored part office mathematical information computational sciences office science department energy contract de-ac ut-battelle llc government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon personal redistribute address scalability barrier infrastructure multicast functionality enables address scalability barrier providing scalable mechanism communication large number tool components tool local application behavior behavior individual application processes addition global behavior data describing local behavior aggregated analyzed mrnet approach insufficient address scalability barriers address scalability barriers propose performance diagnosis approach finding performance problems applications large number processes approach synergistic parts part scalable distributed performance diagnosis facility demonstrate design form on-line automated strategy finding performance bottlenecks strategy search well-established technique methodically examining solution space part technique constructing compact displays results search-based bottleneck detection strategy technique called sub-graph folding algorithm sgfa bottleneck search results presented dynamic graphs record refinement bottleneck search control complexity results graph sub-graphs showing similar local application behavior combined composite sub-graph effect sgfa dynamically clusters application processes based qualitative behavior parts performance diagnosis approach rely multicast data aggregation infrastructure mrnet scalable communication data processing focus on-line automated performance bottleneck detection techniques perform bulk analysis application runs minimal user involvement highly effective large-scale performance tuning relieve user difficult task identifying performance data important data volume generated monitoring large-scale applications massive ability automatically find interesting data extremely valuable relieve user understand complex interactions application operating system hardware user performance tuning expert on-line automated tool effectively expertise built tool finally adapt activity response application behavior runs ability on-line automated techniques adapt data collected obtain results single application run collect process smaller volume performance data tools adapt data collect run contribution research area performance tool scalability specifically contributions work design evaluation distributed search strategy finding performance bottlenecks applications large number processes model expressing cost instrumentation parallel computation designed distributed bottleneck search strategy approach making concise graphical presentations results bottleneck search sgfa recognition synergy distributed bottleneck search strategy sgfa avoid explicit examination application global behavior evaluate approach automated performance diagnosis performed scalability study prototype implementation performance diagnosis approach find bottlenecks quantum chromodynamics qcd application running linux cluster goal work improve scalability performance tools opposed parallel applications measured characteristics performance tool scalability bottleneck tool system process prototype tool implementation measured tool process cpu utilization behavior signs resource saturation caused tool processes experiments application processes performed bottleneck searches qcd application sign tool resource saturation describe results detail section study considered scalability performance bottleneck search results visualization technique sgfa quantified scalability sgfa number nodes bottleneck search results graph measure complexity assuming preferable minimize number graph nodes demanding scenario application processes sgfa reduced bottleneck search results graph nodes -node graph single composite sub-graph showing qualitative performance diagnosis information original graph complete results part evaluation provided section sections detail performance diagnosis approach programs large number processes section present design scalable data analysis performance diagnosis facility section describe subgraph folding algorithm present results evaluation approach section conclude section discussion previous work related research scalable bottleneck detection part scalable performance diagnosis approach distributed data analysis performance diagnosis facility embodied design on-line automated strategy finding performance bottlenecks strategy addresses problem efficiently examining local global behavior applications large number processes bottleneck search strategy adopts search refinement rules performance consultant paradyn automated performance diagnosis component performance consultant bottleneck search strategy performs experiments determine application exhibiting performance problems problem occurring experiment consists hypothesis reason application exhibiting performance problem focus application hypothesis tested performance consultant small number built-in hypotheses time spent blocked cpu bound hardware counter access facility performance application programming interface papi performance consultant create hypotheses based hardware counters cache misses experiment focus constructed program personal redistribute resources static 
dynamic entities comprise program functions constitute program executable code resources processes hosts running synchronization objects application message tags barriers spin locks semaphores program resources program resources arranged hierarchies shown figure resource hierarchy resource represents resources organized beneath hierarchy code resource represents functions application executable experiment focus tuple tuple resource resource hierarchy providing concise potentially large set resources experiment performed scalability study qcd application focus code control main machine syncobject focus specifies top level machine resource focus constrain set resources names host names collection main functions application processes experiment focus code update update machine mcr rmd syncobject denotes update function process host mcr names specific resources code machine resource hierarchies dynamic instrumentation collect performance data test experiment hypothesis program locations named experiment focus performance data collected experiment user-configurable threshold experiment hypothesis search refined create specific experiments bottleneck search begins experiments test general performance problems entire application spending time waiting communication operations successive search refinements search pinpoints nature location application bottlenecks performance consultant refine search level individual functions loops performance consultant inserts instrumentation application processes run process behavior altered slightly uninstrumented user-configurable threshold cost instrumentation performance consultant limit effect instrumentation application behavior sensitive applications search made aggressive reduce toolinduced load perturbation system resources performance diagnosis approach improves ability control instrumentation overhead instrumentation cost model section distributed bottleneck search strategies add perturbation system nodes demonstrated evaluation results section results performance bottleneck search shown effectively search history graph figure records cumulative refinements search figure focuses part graph shows qualitative cpu utilization behavior application processes node graph represents experiment node background color experiment true blue dark gray black-and-white false pink light gray shown figure color node label experiment dynamic instrumentation inserted white active black root graph node labeled toplevelhypothesis representing virtual experiment tests performance problems application virtual experiment involves instrumentation start bottleneck search virtual experiment immediately refined create small number experiments entire application specific hypotheses application cpu bound application spending time waiting operations figure focuses experiments testing cpubound hypothesis search history graph nodes connected edge experiments related refinement experiment refined create specific experiment node label parent node label nature refinement instance node labeled cpubound mcr llnl gov figure represents experiment testing application processes running figure program resources arranged hierarchies personal redistribute host mcr llnl gov cpu bound experiment found true experiment refined create experiments test specific application process process cpu bound adopt paradyn search history graph display tools adopted hierarchical visualizations searchbased performance diagnosis results similar approach traditional on-line parallel performance tools tool frontend process identifies application performance problems analyzing data generated tool daemons monitor application processes traditional performance consultant bottleneck search strategy performed tool front-end process tool daemons generate raw performance data tool front-end responsible analysis search control centralized performance data tool control processing limit tool scalability number application processes grows search strategy distributes portions search examine local application behavior called sub-searches reduce centralization tool activities search strategy distributes sub-searches examine behavior application process search agent daemon monitors process important note bottleneck search strategy number placement tool daemons traditional centralized strategy distributing local sub-searches benefits automated performance diagnosis tools centralized approach distributed sub-searches reduce centralized processing data control messages tool search strategy parts search examine behavior application process delegated local search agent tool daemon monitoring process data control messages sub-search processed daemon communicated tool front-end process benefit distributed sub-searches reduce time needed complete search distributed sub-search investigates local application behavior single independent host tool perform distributed sub-searches parallel local sub-searches form sizeable fraction total search applications large number processes performing local subsearches parallel reduce time required complete search bottleneck search strategy adopts call-graph-based search refinement paradyn performance consultant centralized approach investigated alternatives distributing local bottleneck searches partially distributed approach pda requires complex management search dynamic instrumentation distributed approach tda retains pda functionality eliminating instrumentation management complexity figure part traditional search history graph display true experiments shown blue nodes dark gray black-and-white false experiments shown pink nodes light gray portion full search history graph shown full graph nodes personal redistribute partially distributed approach pda consists parts partially distributed performance bottleneck search strategy model expressing cost dynamic instrumentation parallel computation policy scheduling instrumentation generated centralized distributed parts search traditional performance consultant search refinement rules initial experiments search investigate hypothesis application global behavior application cpu bound experiment dealing global application behavior refined examine application behavior specific hosts search strategy delegates control host-specific experiments experiments refined local search agent running host experiment labelled cpubound refined experiment labelled mcr llnl gov experiment performed local search agent running tool daemon host mcr llnl gov experiment root sub-search performed local search agent examines local behavior application processes host goal distributed performance bottleneck search strategy off-load performance diagnosis activity tool front-end distributing bottleneck search introduces requirements approach monitor control search dynamic instrumentation local search agents make independent decisions inserting removing instrumentation supports local sub-searches instrumentation requests collecting global performance data satisfied tool daemons approximately time data application processes form aggregated global data traditional performance consultant centralized search control single instrumentation cost satisfy requirement decisions insert dynamic instrumentation made centrally complete instrumentation cost knowledge centralized decision-making scheme satisfy requirement local search agents make decisions independently local data instrumentation distributed performance diagnosis strategy represents cost instrumentation parallel computation model maintains cost instrumentation application process specifically application processes model expresses instrumentation cost instrumentation cost application process benefit maintaining instrumentation cost application process local search agent restrict view application instrumentation cost local search agent tracks cost instrumentation processes controls local search agent maintain instrumentation cost information local processes pda satisfy instrumentation management requirement complicates ability satisfy requirement scheduling workload local global instrumentation requests local search agents complete information application instrumentation cost guaranteed make scheduling decision based cost information response global instrumentation request tool front-end reliable distributed consensus algorithm pda enable collection local search agents reach decision global instrumentation algorithm implementation place unacceptable computation communication load daemon processes require communication channels daemon processes exist existing tool communication model pda centralizes decision making global instrumentation requests mrnet gather aggregate instrumentation cost information simplicity pda fixed-partition policy scheduling local global instrumentation combined instrumentation cost threshold defines instrumentation capacity fixed 
practical analysis stripped binary code laune harris barton miller computer sciences department wisconsin dayton madison usa lharris bart wisc introduction executable binary code authoritative source information program content behavior compile link optimize steps program detailed execution behavior differ substantially source code binary code analysis provide information program content structure foundation applications including binary modification binary translation binary matching performance profiling debugging extraction parameters performance modeling computer security forensics ideally binary analysis produce information content program code instructions basic blocks functions modules structure control data flow data structures global stack variables quality availability information affects applications rely binary analysis paper addresses problem static binary analysis extract structural information stripped binary code stripped binaries executables lack information locations sizes layout functions objects information typically contained compiler generated symbol tables analysts confronted stripped binaries commercial software stripped deter reverse engineering unlicensed malicious code stripped resist analysis system libraries utilities stripped reduce disk space requirements occasionally symbol tables incorrect misleading information structural information consists interand intra-procedural control flow addition start addresses functions function ranges basic blocks entry exit points approach extracting structural information builds control flow extraction function identification techniques employed previous work work builds techniques leel rad breadth static call graph control flow graph traversal discover classify code rad leel begin program entry point traverse static call graph find function entry points rad additionally pattern matching standard function preambles discover functions sections code space reachable static call instructions previously code functions static recognizable preambles rad optimistic identification strategy paper makes contributions augments existing binary parsing methods extended function model realistically describes structure modern code additional assurance checks boost confidence analysis presents tests evaluation results large set real programs reports experiences dealing peculiarities production code tasks designing binary parser identifies functions defining function model previous function models represent code complies traditional code conventions functions single entry points contiguous code ranges code analyzer multiple entry control flow graph model treats code connected intraprocedural control flow part function model chosen ability accurately represent unconventional structures increasingly common modern code model alteration represent code modification instrumentation analysis techniques implemented dyninst run-time binary modification tool wide variety research commercial environments dyninst multi-platform operates multiple operating systems architectures created generic framework stripped code analysis framework modular design replaceable interchangeable components making independent operating system file format machine architecture evaluation implementation split categories comparison parsing stripped binaries information provided compiler symbol table comparison parsing stripped binaries tools instrument stripped binary based parse results comparisons source code reveal general functions recover correspond source cases compiler optimizations dead code removal inlining significant differences binary analysis results source compiler generated symbol tables provide reasonable approximate account number functions binary locations initial results automated assessments roughly test programs recover average functions stripped executables compared analysis idapro popular commercial disassembler parser recovers function information idapro cases substantially instrumentation tests analysis results insert entry exit instrumentation functions test programs assessment rules simple abnormal termination failure normal termination success successfully instrument stripped test programs unstripped note failures due difficulties instrumenting code limitations analysis test experiences feedback dyninst users gave insights technical issues involved implementing robust stripped code analysis meet general purpose binary editor report insights related work paper related work discuss focus reconstruction structural information static binary analysis categories tools perform static binary analysis obtain structural information binary code including disassemblers binary rewriters decompilers binary translators tools category tend similar requirements employ similar techniques partition discussion related work application category static analysis commonly tools alternative method called dynamic code analysis structural information inter-procedural control flow call graph determined run time dynamo dynamorio diota self-propelled instrumentation pin program optimization tools dynamic code analysis tools idtrace static dynamic analysis dynamic phase correct errors resulting static analysis analyze code detectable statically disassemblers disassemblers convert binary code symbolic assembly language representations primary function disassemblers visually present assembly language representations binary code human analysts aid analyst organizing information disassemblers present control flow information attempt partition programs functions ida-pro arguably commercial disassembly tool ida-pro depth call graph traversal determine function start addresses intra-procedural control flow analysis determine function ranges ida-pro provide support contiguous functions identify functions reached indirect calls constructs common production code approach tools partition binary functions recognizing function prologues method advantage simple fast creates coarse grained inaccurate function structure functions non-standard prologues data interspersed code producing correct disassembly challenging due variable length instruction sets data mixed code indirect control flow deliberate code obfuscation scharwz combined linear sweep disassembly recursive traversal create hybrid disassembly algorithm work based idea linear sweep recursive traversal disassembly agree disassembly correct orso developed disassembly method obfuscated code response static code obfuscator developed linn debray method cfg checks verify disassembly correctness branches middle instruction error disassembly checks methods form core set safety checks speculative function discovery binary modification binary modifiers tools rewrite code statically run time major binary modification include post compilation optimization instrumentation profiling binary modification tools rely presence symbol table debugging information tools reconstruct structural information operate stripped binary code eel operates sparc binaries main disadvantages eel approach suited variable length instruction set architectures identify functions reachable indirect control transfer disadvantages addressed leel eel-based binary editing tool designed linux intel architecture beginning program entry point leel walks static call flow graph build set call targets correspond function starting points recursive disassembly points finds code blocks function establishes function size gaps code space caused presence functions reachable indirect control flow data bytes leel options option conservative analyze option aggressive assume byte gap starting address function options present undesirable extremes safer binary modification low code coverage binaries high proportion functions reached indirect calls binaries indirect calls form bridges large sections call graph approach rad similar leel rad binary editor defends stack based buffer overflow attacks instrumenting function entry exit points rad achieves code coverage leel conservative option matching byte sequences gaps function prologues rad approach locate functions static prologues rad leel conventional view function self-contained sequence code single entry point exit point laid contiguous area memory view generally applicable adequate applications binary code functions multiple entry points spread non-contiguous areas executable work designed extend approaches leel rad improve 
code coverage properly handle unconventional function structures leel rad operate stand-alone executable code debugging information needed tools rely presence symbol tables relocation tables debugging information perform similar analyses code discovery cfg creation examples include etch plto require relocation information design compilation optimization linking steps create binaries structurally source code tasks designing binary parser identifies functions defining function model section presents model remaining parts section describe implementation function models function model determines degree analysis output reflects structure binary implementation chose multiple-entry control flow graph model control flow graph models treat functions sets basic blocks form control flow graphs cfg models represent functions contiguous code basic blocks located program address space figure shows control flow models single entry shared code multiple entry single entry model simplest cfg models presented function model entry block dominates blocks shared code model variant single entry model basic blocks belong multiple functions multiple entry model treats code connected intra-procedural control flow part function alternative models include prologue prologue prologue exit models functions regions prologues exits symbol table model defines function named start address size pair models rejected naturally describe binary level functions contiguous code ranges multiple entry points shared code blocks addition prologue models vulnerable presence data code space unrecognizable missing prologues implementation parser designed modular replaceable interchangeable components components fall categories file format reader instruction decoder code parser section describe components generic assembly language interface ties dyninst system includes components dynamic code generator process control scope paper file format reader file format readers extract information file headers describe layout executable addresses sizes interesting points sections including locations text data symbol tables single entry shared code multiple entry figure control flow models program entry point addition file format readers heuristics determine address function main programs executing initial start-up code transfer control function commonly called main difficult static control flow analysis locate main locating main heuristics strictly benefits labeling function main tools expect find program call graph rooted main finding root early reduce parser reliance speculative function discovery techniques provide format readers elf coff xcoff instruction decoder instruction decoder plays roles disassemblers interprets byte streams machine instructions role extract semantic information instructions implement architecture dependent routines accessed generic assembly language interface provide stripped code parsers intel amd ibm power architectures generic assembly language interface generic assembly language interface exports uniform assembly language parser independent underlying architecture aal object model description generic operations instruction treated object exports methods operators iscondbranch isuncondbranch isindirbranch iscall isreturn getbranchtarget getmultibranchtargets isprologue isillegal size parsing operations machine instructions interface parser control flow discovery function identification parser accesses program instruction stream generic assembly language interface generic assembly language interface enables single parsing algorithm multiple platforms case correct symbol tables debugging information symbol start addresses analysis points worst case program entry point obtained file format reader guarantees reliable starting point analysis initial set starting addresses input parsing algorithm breadth-first call graph traversal recursive disassembly finds code statically reachable reachable initial set addresses valid call targets addresses named functions disassembled build control flow graphs additional call targets discovered cfg creation added list call targets analysis cfg conflicts illegal instructions rejection function algorithm terminates gaps analyzed remaining text space due presence data alignment padding functions statically referenced previously visited code speculative gap completion phases analyze gaps phase searches gap function prologues potential code address parser creates instruction calls isprologue architecturespecific method decoder checks instruction sequences commonly implement prologues platform common prologue sequence push ebp mov esp ebp isprologue returns true address assumed start function invoke core algorithm build section program call graph rooted function completion speculative discovery phase completion phase gaps present text space gaps due functions called indirectly prologue disassemble gaps orso speculative completion method method build control flow graphs starting potential code address gap cfg conflicts prune set control flow graphs branches cfg target apparent middle instruction cfg rejected addition add requirement phase cfgs non-terminal control transfer instruction requirement reduces number false positives boosts confidence functions discovered issues addressed effectively follow function local control transfers production code analysis indirect branches branches targets determined run time indirect branches commonly implement switch statements cifuentes van emmeriks describe machine compiler independent method program slicing expression substitution statically recover targets indirect branches jump tables practice simple machine compiler dependent methods proved effective recovering jump table values approach backtrack control paths leading indirect branch discover instructions set jump table access instructions give base location number entries jump table issue identification exit points exit point identified intraprocedural transfer overestimation function sizes addition return instruction detection instruction decoder implements platform specific tail-call detection non-returning call instructions calls exit abort considered exit points transfer identified exit assumed intra-procedural implementation tested compilers microsoft visual gnu gcc ibm xlc intel icc evaluation proper evaluation stripped binary analysis tool challenging process human inspection verification small sets trivial test programs larger sets programs larger sophisticated programs human inspection inappropriate evaluation automated comparisons compiler generated symbols tables automated instrumentation tests compared function recovery rate idapro popular commercial disassembly tool evaluations primarily linux microsoft windows evaluations requiring large numbers binaries programs obtained department standard bin directory large collection programs comparison symbol tables filtered output objdump display unique function addresses programs compared number functions recovered reported objdump results test binaries show average recovery rate comparison idapro table shows comparison function recover rate idapro results show general stripped code analysis identifies functions idapro firefox binary inspection suggests idapro incorrectly identifying thousands instruction sequences functions part dispatch tables instrumentation tests dyninst inserted function entry exit point instrumentation test binaries success means instrumented binary runs completion failure hanging results tests report table experiences section describe experiences real unusual code patterns pseudo call instructions call instructions valid interprocedural transfers calls target instruction immediately call position independent code obtain program counter targets instructions function entries targets call instructions filled load time means target obtained static analysis binary incorrect cases obvious target address target address junk detect case encounter calls rely cfg disassembly checks guard case exception handling code unreachable blocks exceptions creates code blocks unreachable reliable solution problem extract exception information compiler generated exception tables missing 
main binaries explicit main function illustrate speculative function discovery analysis kwrite binary part kde tools revealed executable contained main function main located dynamically loaded library accessed procedure linkage table functions stripped kwrite binary statically reachable program entry point stripped unstripped passed failed table success rate instrumentation tests binary platform ida dyninst number percent number aim window alara linux bash linux bubba linux calc windows eon linux firefox windows gimp linux kwrite linux notepad windows paradyn linux securecrt windows vcross linux linux table functions found dyninst idapro percent measures percentage functions found idapro compared total found dyninst false positives speculative code discovery analyses data bytes data bytes interpreted terminal control flow instructions give appearance single-basic-block functions data bytes interpreted instruction sequence mov reg mem mov reg mem ret eliminate occurrence false positives require functions discovered speculative discovery phase control flow instructions restriction improving reliability reduces coverage excluding legitimate functions fit pattern evaluating alternatives strategy potential direction simple semantic analysis determine single block function discovered speculative discovery accepted rejected bala duesterwald banerjia dynamo transparent dynamic optimization system acm sigplan conference programming language design implementation pldi june bruening garnett amarasinghe infrastructure adaptive dynamic optimization annual international symposium code generation optimization march buck hollingsworth api runtime code patching international journal high performance computing applications winter cifuentes van emmerik recovery jump case statements binary code international workshop program comprehension washington cifuentes van emmerik ramsey design resourceable retargetable binary translator sixth working conference reverse engineering atlanta october executable linking format http skyfree linux elf format pdf giffin jha miller detecting manipulated remote call streams usenix security symposium san francisco california august giffin jha miller efficient context-sensitive intrusion detection network distributed system security symposium san diego california february hi-pvm http parasys idapro http datarescue idabase overview htm kruegel robertson valeur vigna static disassembly obfuscated binaries usenix security symposium august larus schnarr eel machine-independent executable editing sigplan conference programming language design implementation pldi june larus bal rewriting executable files measure program behavior software-practice experience february linn debray obfuscation executable code improve resistance static disassembly acm conference computer communications security ccs october maebe ronsse bosschere diota dynamic instrumentation optimization transformation applications wbtworkshop binary translation charlottesville virginia september miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november mirgorodskiy miller crosswalk tool performance profiling user-kernel boundary international conference parallel computing parco dresden germany september mirgorodskiy miller autonomous analysis interactive systems self-propelled instrumentation multimedia computing networking conference san jose california january microsoft portable executable common object file format specification http microsoft whdc system platform firmware coff mspx orso harrold vigna massa mobile agents security static dynamic analysis icse workshop software engineering mobility wsem toronto canada april pierce mudge idtrace tracing tool simulation michigan tech report cse-tr- prasad chiueh binary rewriting defense stack-based buffer overflow attacks usenix annual technical conference june project fenris http lcamtuf coredump fenris whatis shtml luk cohn muth patil klauser lowney wallace reddi hazelwood pin building customized program analysis tools dynamic instrumentation programming language design implementation pldi chicago illinois june romer voelker lee wolman wong levy chen bershad instrumentation optimization win intel executables etch usenix windows workshop august rozinov reverse code engineering in-depth analysis bagle virus bell labs government communication laboratory internet research august schwarz debray andrews disassembly executable code revisited ieee ninth working conference reverse engineering richmond october schwarz debray andrews plto link-time optimizer intel iaarchitecture workshop binary translation wbtbarcelona spain sept sites chernoff kirk marks robinson binary translation digital tech journal wang pierce mcfarling bmata binary matching tool feedback-directed optimization fdo haifa israel november xun linux executable editing library masters dissertation national singapore http geocities fasterlu leel htm xcoff file format http unet univie aix files aixfiles xcoff htm 
partition ensures instrumentation class starve instrumentation policy trades potential unused search capacity guarantee local search block global search vice versa local global search agents search refinement rules expect produce similar sequences instrumentation requests search reaches steady state expect local global instrumentation throttled cost limits instrumentation scheduling policy totally distributed approach initial experience pda showed yields expected tool scalability benefit cost tool complexity due schedule track instrumentation cost global local instrumentation distributed bottleneck search strategy centralized search component global instrumentation avoid increased tool complexity retaining scalability advantages partially distributed strategy tda performs explicit examination application global behavior infer global behavior local behavior information approaches making inference approach assume behavior application processes similar bottleneck search results limited number processes representative approach fails chosen processes representative processes approach incorporate information application processes approximation approach bottleneck search results identify behavioral variations application processes identify possibly processes exhibit type behavior information application process included ensure search strategy global bottleneck results represent application global behavior tda design sub-graph folding algorithm section approximate application qualitative global behavior sgfa dynamically clusters application processes based qualitative local behavior retains information number processes category tda technique sacrifice insight application global behavior personal redistribute sub-graph folding algorithm sub-graph folding algorithm performance diagnosis approach addresses scalability barrier qualitatively aggregating performance diagnosis results large number processes handful application processes search history graph figure effective showing results bottleneck search search history graph display shows search results individual application processes sub-graph process display scale ideas scalable performance visualization experiment management performance tuning prism parallel debugger developed sub-graph folding algorithm sgfa visualizing results performance bottleneck search sgfa combines sub-graphs based qualitative behavior hosts processes composite subgraph sub-graphs indicating similar qualitative behavior categorized composite sub-graph expect number behavioral categories small applications allowing sgfa produce search result displays substantially compact traditional search history graph display figure shows result applying sgfa result tda bottleneck search application processes nodes folded graph original graph paradyn traditional search history graph display nodes parent children collapsed meta-node reduce screen area demands processes similar qualitative behavior represented traditional search history graph display sub-graphs similar shapes node truth values sgfa incrementally produces composite sub-graph similar sub-graphs host node added original graph sgfa traverses node sub-graph original graph composite sub-graph equivalent node present composite sub-graph sgfa adds sub-graph rooted node original sub-graph composite subgraph folded graph shown figure sgfa created single composite sub-graph represents un-folded sub-graphs search history graph display applying sgfa complete folded form search history graph partially shown figure un-folded graph nodes folded graph nodes nodes thermometer gauges represent multiple experiments un-folded graph bar fraction experiments node represents label rmd represents multiple process names unfolded graph true experiments shown blue nodes dark gray black-and-white false experiments shown pink nodes light gray black-and-white paradyn traditional search history graph display nodes parent children collapsed meta-node reduce screen area required rendering graph thermometer gauge sub-node meta-node drawn immediately sub-node collapsed node separated thin line personal redistribute folding sub-graphs composite graph sgfa identify node equivalence sgfa considers node characteristics determining nodes equivalent characteristics depend types nodes consideration types nodes labelled host process names sgfa require node labels identical nodes considered equivalent comparing nodes labelled rmd rmd figure sgfa executable disregards process values hand node types labels identical nodes considered equivalent category nodes includes nodes labels resource categories message specific application functions sgfa considers truth determining node equivalence nodes folded graph represent multiple experiments original graph presentation approach node folded sub-graph shown thermometer gauge fraction experiments represents nodes labelled update figure thermometer gauge node representing experiments true truth shaded indicating experiment function update true sub-graphs original graph situation arise small variations program behavior processes observed performance data experiment close experiment user-configurable threshold equivalent nodes original search labels similar identical sgfa wild card labels folded graph nodes labelled process identifiers figure labelled rmd folded graph tda bottleneck search generate search history graph display shown figure experiments labeled cpubound excessivesyncwaitingtime excessiveioblockingtime reflect refinement hypothesis focus individual host node composite generalized label hypothesis part focus sgfa string generalization algorithm longest common subsequence algorithm construct wild card node labels visualization technique scalable scalable on-screen presentation scalable approach building on-screen presentation centralized sgfa implementation poor match presenting results distributed bottleneck search strategy centralized sgfa limits scalability tool distributed sgfa approach needed complement scalability benefit distributed bottleneck search strategy designed implemented mrnet-based sgfa approach custom mrnet data transformation filters stateful sgfa filter running process mrnet overlay network tool front-end maintains folded sub-graph results local search agents reachable process filter folded graph add node change node truth state filter delivers description change upstream induction filter running tool front-end entire folded graph performed experimentation batch environment modified paradyn operate traditional interactive graphical user interface visualize result bottleneck searches developed minimal post-mortem search history graph visualization tool shown figure positive experience approach led future work investigating performance diagnosis strategy large-scale programs batch environments proposed approach completely independent bottleneck search agents cda on-line implementation sgfa combine results agent writes search results local storage parallel file system post-mortem tool apply sgfa visualize results evaluation evaluate distributed bottleneck search strategy sgfa modified paradyn version search performance bottlenecks pda tda approaches apply sgfa search results implemented bottleneck search strategy context paradyn performance consultant call augmented bottleneck detection component distributed performance consultant modified version paradyn search bottlenecks parallel application processes experiments rmd simulation pure lattice gauge theory quantum chromodynamics produced milc collaboration simulating standard model nuclear physics code implemented configured mpi inter-process communication weak scaling approach study experiments balanced mrnet topologies moderate fan-out process number data points scalability study limited fan-out level process network topologies fan-outs levels processes connected directly daemons smaller fan-out level run experiments numbers application processes power experiments run multiprogrammatic capability cluster mcr lawrence livermore national laboratory time experiments performed mcr contained nodes compute nodes connected quadrics qsnet elan interconnect node ghz pentium xeon processors ram node ran chaos linux distribution derived red hat enterprise linux llnl mpi implementation mcr provided quadrics based mpich distribution goal work evaluate scalability approach finding performance bottlenecks programs large number processes focused performance characteristics tool application provided test workload tool ensure performance diagnosis results 
provided approach qualitatively similar provided performance consultant traditional approach examined results produced prototype implementation application processes performance bottleneck searches cpu time bottlenecks observed cpu utilization cpu utilization hypothesis threshold mult scalar mult add matrix functions milc rmd code performance personal redistribute consultant inclusive cpu time metrics measure time required function callees performance consultant reported cpu time bottlenecks main update update update functions experiments experiments performed performance consultant false unexpected communicationrelated performance bottlenecks identified inspection rmd code shows program gather operation implements gather point-topoint operations mpi gather collective communication operation individual gather operations distinguished unique message tag gather operation pointto-point operations appears program avoid significant blocking gather distributed performance consultant results evaluate distributed performance consultant modified paradyn pda tda approach performing bottleneck search performed scalability study approaches watching computation communication load tool processes including mrnet internal processes signs resource saturation scalability bottleneck tool system tool process cpu utilization measure computation load rate reads writes data mrnet infrastructure quantify communication load support pda modified paradyn track cost global local instrumentation separately implement instrumentation scheduling policy simple fixed-partitioning policy support tda implemented sub-graph folding algorithm custom mrnet filters support scalable presentation distributed performance consultant results support running experiments mcr batch scheduling system modified tool front-end present text-based user interface graphical user interface automatically perform experiment batch jobs run results scalability study shown figures requested batch job time limits runs times longer runs pda tda runs application processes failed complete batch job allotted time limit attempt runs processes contrast performed experiments pda tda application processes limited system size resource saturation sgfa verify qualitative results produced search strategy provided comparable results front-end cpu load daemon cpu load mrnet internal process cpu load figure computation load pda tda bottleneck search strategies cpu utilization shown tool front-end tool daemons mrnet internal processes note y-axis scale differs significantly plots runs application processes failed complete batch job allotted time limit attempt runs processes cpu utilization percent processes pda tda cpu utilization percent processes pda tda cpu utilization percent processes pda tda personal redistribute front-end read rate front-end write rate daemon read rate daemon write rate mrnet internal process read rate mrnet internal process write rate figure mrnet load pda tda bottleneck search strategies number bytes read mrnet shown tool front-end tool daemons mrnet internal processes number bytes written mrnet shown tool front-end tool daemons mrnet internal processes y-axis logarithmic plot plots tda curve front-end send data daemons receive data mrnet tda search runs application processes failed complete batch job allotted time limit attempt runs processes read rate bytes processes pda tda mrnet write rate bytes processes pda read rate bytes processes pda mrnet write rate bytes processes pda tda read rate bytes processes pda tda mrnet write rate bytes processes pda tda personal redistribute figure compares computation load tool front-end daemons mrnet internal processes bottleneck search strategy consideration chart figure shows cpu utilization search strategy range process counts measured cpu utilization sampling getrusage system call one-second intervals front-end process daemon processes mrnet internal processes bottleneck search process computed average cpu utilization duration bottleneck search data point search strategy process count average processes type front-end daemon mrnet internal process runs search strategy number processes cpu load results show expected scalability benefit tda search strategy lesser extent pda search strategy saturates tool front-end small numbers application processes back-pressure daemon cpu load decrease cpu load reported getrusage larger multiprocessor hosts nodes mcr cluster contrast tda front-end cpu load remained constant varied number application processes average cpu load daemons mrnet internal processes remained experiments distributed search strategies expected mrnet internal process cpu load pda slightly higher cpu load tda internal processes aggregating global performance data pda tda cpu load results revealed unexpected behavior daemon cpu load slightly lower pda tda behavior result differences pda searches tda searches performed daemons pda local sub-searches started front-end refines global experiment host-specific experiment global experiments hypotheses excessivesyncwaitingtime excessiveioblockingtime refined daemons involved evaluating performance data hypotheses search pda contrast tda daemon begins search creating host-specific experiments hypotheses continues evaluate performance data experiments bottleneck search unexpected behavior exposed cpu load results dip tda daemon cpu load spike mrnet internal process cpu load application processes observed daemon tda load curve sawtooth pattern high points curve correspond mrnet topologies fan-out level process network intermediate points last-level fan-out low points last-level fan-out variations cpu load related mrnet topology nature relationship investigated figure compares network load tool front-end back-ends mrnet internal nodes bottleneck search strategies instrumented mrnet library collect number bytes read written mrnet socket connections modified paradyn process sample counts one-second intervals search process computed average read write rate bottleneck search obtain chart values search strategy averaged read write rates processes type front-end daemon mrnet internal process runs search strategy variability runs low mrnet results show scalability tda expected front-end writes daemon reads bottleneck search tda strategy reads writes tda data rate low remained constant increased number application processes tda results exhibit variability echoes variability tda cpu load results cpu load remains investigated fluctuation related mrnet topology sgfa results evaluated sgfa implementing custom mrnet data transformation filter section measuring ability reduce complexity search history graph results distributed performance consultant scalability study number nodes search history graph measure complexity instrumented paradyn front-end report number nodes un-folded folded search history graphs completion bottleneck search results comparison shown figure chart compares complexity un-folded search history graphs produced tda distributed performance consultant approach complexity sgfa-produced graphs number nodes un-folded graph grew linearly number application processes expected un-folded search history graph includes complete sub-graph application process sub-graph approximately complexity thirty nodes contrast complexity sgfa-produced graphs remained constant varied number application processes sgfa graphs contained single composite sub-graph related work distributed performance consultant sub-graph folding algorithm synergistic parts approach figure effect sgfa search history graph complexity chart compares number nodes un-folded search history graph resulting tda bottleneck search graph produced sgfa y-axis logarithmic number nodes processes unfolded shg folded shg personal redistribute scalable on-line automated performance diagnosis distributed performance consultant related previous work on-line automated performance tools instrumentation cost models workload scheduling sub-graph folding algorithm builds previous work 
tree-based overlay networks scalable applications dorian arnold gary pack barton miller computer sciences department wisconsin dayton street madison darnold pack bart wisc abstract increasing availability high-performance computing systems thousands tens thousands hundreds thousands computational nodes driving demand programming models infrastructures effective large-scale environments tree-based overlay networks ons proven provide model distributed tools performance profilers parallel debuggers system monitors system administration tools demonstrate extensibility flexibility distributed computing model performance characteristics make surprisingly general applications tool domain describe interesting applications commonly-used algorithms ons well-suited provide non-tool case study distributed implementation mean-shift algorithm commonly computer vision delineate arbitrarily shaped clusters complex multi-modal feature spaces introduction today exist high-performance computing systems mpps computational clusters constellations thousands tens hundreds thousands interconnected nodes trend extremely large computing environments expected continue making imperative study efficient ways tools applications run effectively environments scalability challenge forms dissemination control information data collection data analysis computation number nodes system increases computational communication demands system increase typically linear fashion explicit attention increased demands tools scale poorly tree-based overlay networks ons proven provide powerful parallel programming model addresses scalability efficiency tools fully section hierarchical organization processes network transport protocols tcp implement data multicast gather reduction services applications explicitly insert application-level code communication processes filters execute data reduction operations in-flight messages essentially ons provide effective platform data communication treebased data communication scales logarithmically number processes network allowing computations distributed treestructure ons well-suited scalable data aggregation reduction information propagates root tree tree-based networks data reduction overheads vary logarithmically respect total number processes model distributed computing surprisingly flexible generalized support wide range usages basic operations min max count average examples complex tree-based computations include distributed clock skew detection time-aligned data aggregation graph merging algorithms creating equivalence classes data histograms features make ons effective wide variety distributed tools applications extensible data reductions synchronizations high-throughput low-latency dataflow customizable topologies flexible data communication model generalization helps developers create scalable efficient systems easily extended ways envisioned original design goal study demonstrate broader applicability ons tool domains typically show large classes applications common algorithms reduce equivalence relation computation made scalable straightforward integration present non-tool case study scalability distributed version shift algorithm commonly delineate arbitrarily shaped clusters complex multi-modal feature spaces results show distributing algorithm improves scalability run-time single node version expected multi-level ons provide improved scalability compared flat one-to-many process organizations section describe computational model mrnet prototype discuss applications ons give examples ons types algorithms applications ons well-suited detail application environmentand evaluation case study section end discussion implications future research section tree-based overlay networks section detailed discussion ons define model describe mrnet on-based multicast reduction network discuss existing future applications ons high-performance computing computational model model shown figure application processes connected tree internal communication processes term application describe system directly leveraging infrastructure tool common actual end-application application process root tree front-end process leaves back-end processes collectively front-end back-ends called end-points tree processes connected fifo channels serve conduits application-level packets flow end-points strength model ability place control execution application-level logic infrastructure feature provided data filter abstraction perform data aggregation reduction operations in-flight application-level packets filter function inputs set packets outputs single packet persistent filter state carry side-effects fromone filter execution increases power filter abstraction flexible nature filters addition obvious data aggregation operations min max count average filters perform complex data aggregations enforce data synchronization policies discussed section model support direct back-end back-end communication similar support easily achieved albeit sub-optimal manner internal process-tree route backend back-end messages part strength model simplicity communication structure compelling number important computations fit model leverage provide highly efficient reliability mechanisms mrnet prototype mrnet on-based multicast reduction mrnet tree network application frontend back-ends communicate virtual channels called streams applications filters synchronize transform data flowing stream goal generality mrnet key features extensible reduction synchronization mrnet transformation filters key supporting scalable distributed computation mrnet built-in transformation filters commonaggregationsincluding avg sum min max concat additionally mrnet allowsdevelopers extend filter set application-specific filters filters loaded on-demand instantiated networks interface similar dlopen dynamically load filters running communication processes mrnet synchronization filters enforce simultaneous delivery packets time arrive communication process mrnet built-in synchronization filters wait delivers packets groups based packet receipt downstream children time delivers packets received general model constrain number output packets filter produce practice found outputting multiple packets figure tree-based overlay network application-level packets flow upstream back-ends front-end communication processes stateful filters synchronize transform packets window null delivers packets immediately receipt flexible topologies mrnet tool organization communication process-tree topology tree organization shape size including balanced ary skewed nomial trees process-tree organizationis tool mrnet streams sub-trees streams connect subset back-ends tool select portions topology communication mrnet supports dynamic topology model entire tree statically back-end processes join internal tree instantiated extending mrnet support dynamic topologies communication backend processes show leave time response failures recoveries load balancing network properly reconfigures re-routes traffic data loss high-performance communication high-performance means controlling space time usage mrnet optimized support high-throughput data transmissions counted packet place single packet object multiple outgoing packet buffers performs requisite garbage collection packet longer referenced mrnet zero-copy data paths reduce messaging overhead flexible communication model mrnet supports data communication multiple concurrent data streams overlap end-point membership concurrency reduce packet delays provide convenient mechanism tools communicate ways data aggregations end-points mrnet support filter chaining sequence filters applied communication process single super filter propagates packet flow sequence filters seamlessly mimic functionality streams propagate data single direction upstream front-end downstream back-ends plan extend mrnet filter propagate information stream direction mrnet evaluated integrating paradyn distributed performance profiling tool organized central manager controls collects analyzes performance data remote daemons mrnet filters implement efficient treebased clock-skew detection algorithm equivalence class computations suppress redundant information communicated daemons daemons filters improved tools startup time minute seconds speedup data aggregation moderate flow performance data functions front-end paradyn original oneto-many architecture process data rate produced daemons mrnet front-end easily processed loads offered daemons highest node count similar results thousand node runs achieved filters sub-graph folding algorithm sgfa combining sub-graphs similar qualitative structure composite sub-graph applications well-understood tree abstraction powerful performance scalability reinforce idea describe tools tool infrastructures ons discuss future application areas model well-suited middleware infrastructures 
scalable visualization techniques building scalable graph-based displays desirability large-scale performance tuning automated performance diagnosis tools exist paradyn seminal instance class tools recent projects kojak peridot scalea provide automated performance diagnosis functionality kojak tracebased off-line automated tool paradyn peridot scalea on-line analysis on-line automated computational steering tool kits tools falcon autopilot active harmony share characteristics on-line automated performance diagnosis tools falcon autopilot distributed system sensors collect data application behavior actuators make modifications application variables change behavior active harmony extends computational steering toolkit idea include component automatically tunes application performance adjusting application parameters systems requires application libraries modified expose steerable parameters mate augments on-line automated performance diagnosis dynamic code optimization combine advantages automated performance diagnosis computational steering mate require program modifications expose steerable parameters dynamic instrumentation adjust program parameters projects varying degrees emphasis issue scalability dynamic instrumentation form dynamically-enabled compile-time instrumentation nominal reason instrumentation scalability effect control volume performance data collected monitoring application behavior projects discussed peridot approach similar distributed performance consultant scalability number application processes increases design tested scale peridot proposed hierarchy agents monitor evaluate hierarchically-specified performance properties defined specification language asl asl product working group working group funded european union studying automated performance analysis techniques tools hierarchy processes scalability mrnet preferred approach tda single level distributed performance diagnosis agents evaluated scale falcon autopilot distributed analysis approach computational steering tool kits provide distributed decision-making mechanism design finally projects addresses issue scalable visualization performance diagnosis results address sgfa effects instrumentation application complex existing model captures dimensions instrumentation cost existing models focused dimensions easiest measure approximate malony reed yan listgarten proposed cost models trace-based instrumentation systems compensate effects instrumentation event traces models assume simple instrumentation writing fixed-length record trace file hollingsworth miller presented simple model predicting measuring cost general instrumentation on-line performance tool paradyn performance consultant model feedback system controls instrumentation cost automated bottleneck searches instrumentation cost models well-suited scalable automated performance diagnosis approach instrumentation complex instrumentation assumed reed malony yan listgarten hollingsworth miller model suited aggregates instrumentation cost parallel computation single pda tda approaches require cost information granularity individual nodes information lost hollingsworth miller model pda local global instrumentation request scheduling policy draws previous research scheduling mixed sequential parallel workloads including studies leutenegger vernon shared-memory multiprocessors arpaci network workstations arpaci-dusseau avoiding scalability problems traditional gang scheduling systems implicit co-scheduling pda scheduling problem slightly restricted problems addressed previous work pda gang scheduling global instrumentation requirement performance benefit sub-graph folding algorithm related previous work scalable visualization techniques building scalable graph-based displays couch proposed abstract technique constructing scalable performance visualizations groups processes categories displays per-category statistics kimelman technique reducing complexity dynamic graph-based displays search history graphs manually combining nodes graph stasko muthukumarasamy proposed semantic zooming technique constructing scalable graph-based displays abstracting graph matrix blocks block characteristics color texture characteristics sub-graph represented block unlike couch kimelman approaches sgfa requires user intervention construct scalable display rigorous user interface study needed decide conclusively users prefer sgfa-based search history graph display semantic zooming display sgfa display retains familiar graphlike characteristics nodes edges semantic zooming sgfa folding operation similar prism parallel debugger karavanic structural merge operator prism tree concise tree-based representation call stacks application processes folding equivalent call sequences form tree karavanic structural merge operator combines trees program resources called eventmaps operator combines equivalent nodes eventmaps form composite tree resources present eventmaps contrast prism folding operation sgfa folds trees linear sequences nodes considers node types truth values addition node folding sgfa differs karavanic structural merge operator operator requires personal redistribute user provide mappings equivalent nodes sgfa built-in node equivalence rules sgfa operate user intervention acknowledgments paper benefited hard work past present members paradyn research group dorian arnold work mrnet scott futral chris chambreau bronis supinski john gyllenhaal barbara herron computing environment lawrence livermore national laboratory jeffrey vetter oak ridge national laboratory support guidance working group automatic performance analysis resources tools http gz-juelich april arpaci dusseau vahdat liu anderson patterson interaction parallel sequential workloads network workstations acm conf measurement modeling computer systems sigmetrics ottawa canada arpaci-dusseau implicit coscheduling coordinated scheduling implicit information distributed systems acm trans computer systems august browne dongarra garner mucci portable programming interface performance evaluation modern processors intl journal high performance computing applications fall cain miller wylie callgraph-based search strategy automated performance diagnosis sixth intl european conf parallel computing euro-par nich germany august published lecture notes computer science bode ludwig karl wism ller eds springer-verlag heidelberg august september coan welch modular construction efficient bit byzantine agreement protocol mathematical sys theory couch categories context scalable execution visualization journal parallel distributed computing june fahringer gerndt riley specification performance problems mpi programs asl intl conf parallel processing icpp toronto canada aug garlick dunlap building chaos operating environment livermore linux clusters lawrence livermore national laboratory technical report ucrl-idfebruary gerndt automatic performance analysis tools grid concurrency computation practice experience february gropp lusk doss skjellum highperformance portable implementation mpi message passing interface standard argonne national laboratory report mcs-p february eisenhauer schwan vetter falcon on-line monitoring steering parallel programs concurrency practice experience august hirschberg algorithms longest common subsequence problem journal acm october hollingsworth miller adaptive cost model parallel program instrumentation intl european conf parallel computing euro-par lyon france august published lecture notes computer science boug fraigniaud mignotte robert eds springer hollingsworth miller cargille dynamic program instrumentation scalable parallel tools scalable high performance computing conf shpcc knoxville tennessee karavanic miller experiment management support performance tuning portland oregon november kimelman leban roth zernik reduction visual complexity dynamic graphs graph drawing dimacs intl workshop princeton jersey october published lecture notes computer science tamassia tollis eds springer-verlag heidelberg lamport shostak pease byzantine generals problem acm trans programming languages systems july lawrence livermore national laboratory capability cluster http llnl gov linux mcr april leutenegger vernon performance multiprocessor scheduling policies acm conf measurement modeling computer systems sigmetrics boulder colorado malony reed models performance perturbation analysis acm onr workshop parallel distributed debugging santa cruz california miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november mimd lattice computation milc collaboration http physics indiana milc html april mohr wolf kojak tool set automatic performance analysis parallel applications 
ninth intl europar conf euro-par klagenfurt austria august published lecture notes computer science kosch nyi hellwagner eds springer-verlag heidelberg morajko dynamic tuning parallel distributed applications doctoral dissertation universitat autonoma barcelona spain december ribler simitci reed autopilot performance-directed adaptive control system future generation computer systems september roth arnold miller mrnet softwarebased multicast reduction network scalable tools phoenix arizona november sistare allen bowker jourenais simons title scalable debugger massively parallel messagepassing programs ieee parallel distributed technology summer stasko muthukumarasamy visualizing program executions large data sets ieee symposium visual languages boulder colorado september tapus i-h chung hollingsworth active harmony automated performance tuning baltimore maryland november truong fahringer scalea performance analysis tool parallel programs concurrency computation practice experience sept yan listgarten intrusion compensation performance evaluation parallel programs multicomputer sixth intl conf parallel distributed computing systems isca louisville kentucky october 
mrnet ygdrasil lilith tree-based communication infrastructures scalable tools ygdrasil derived communication infrastructure ladebug parallel debugger tree aggregator nodes apply user-specified java-based plugins in-flight data ygdrasil synchronous request response communication model data flows upward response downward control request messages lilith platform distributing user code generally system administrative tasks launching tasks heterogeneous systems lilith organizes task processes tree task output propagated root tree modified en-route single user-specified filter mrnet ygdrasil lilith provide mechanisms extensible data reductions ygdrasil lilith support extensible data synchronization operations lilith ygdrasil support balanced tree topologies implemented java leverage java natural ability load dynamically tag tree-based aggregation infrastructure sensor networks tag database-like sql interface users express simple declarative queries execute distributed manner nodes sensor network similar mrnet tag supports multiple simultaneous aggregation operations supports streams aggregated data response aggregation request tag ad-hoc routing automatically organize sensors tree distributed system tools previous infrastructures designed general-purpose ons tools cluster grid systems application-specific ons distributed system monitors ganglia supermon ganglia multi-level hierarchy level furthest root represent cluster nodes higher levels represent federations clusters ganglia cluster monitoring data replicated nodes request single replica propagates monitoring data entire cluster supermon monitoring servers act clients allowing system configured hierarchies servers servers execute data concentrators implemented functional symbolic expressions lisp monitored data distributed applications application domains areas image processing bioinformatics scientists encounter challenge performing analyses large tera peta scale datasets model proven utility distributed software system tool environments large classes software applications algorithms scientific domains model efficient large scale operations scale large scales computational model befits algorithm properties algorithm computational complexity size input algorithm output lesser size total inputs algorithm output form inputs inputs sets elements output set elements properties describe general data reduction algorithms remainder section show common algorithms scientific applications fit category data mining information extraction process distilling specific facts large quantities data important element real world applications application areas include internet information retrieval bio-information intrusion detection threat analysis geographical information systems business intelligence organizing digital audio collections typically desired information describes relationships elements datasets frequencies statistics classes elements data clustering primary technique information extraction clustering algorithms generally based strategies partitioning agglomeration partitioning algorithms classify data set disjoint clusters fixed priori k-means common partitioning algorithm defines iterativelyrefinesk centroids eachcluster associating data point nearest centroid based figure diagram showing mapping data clustering algorithms equivalence class filter computation distance similarity measures agglomerative clustering data set elements initially partitioned clusters single element larger clusters formed iteratively merging nearest-neighbor clusters clustering algorithms pre-built learning data models statistical analysis group related elements distinguish unrelated general algorithms match definition data reduction computational overhead increases number elements classify result algorithm smaller summary representation inputs mapping algorithms filter computation shown figure figure shows algorithms nature reduce equivalence class filter computation inputs elements classify summarize computation application data model statistics classify data classes represent output classified data summary classified data application ons scalable scientific data analyses appears compelling expect model effective application domains proven tool domains evidence section presents case study demonstrates benefit infrastructures commonly-used general-purpose data clustering algorithm non-tool case study mrnet prototype develop scalable on-based version mean-shift powerful clustering technique delineate arbitrarily shaped clusters complex multi-modal feature spaces compare performance distributed computation single-node version mean-shift iterative procedure shifts center search window direction greatest increase density data set explored continues shift window window centered region maximum density algorithm non-parametric require priori knowledge number clusters data case k-means clustering mean-shift increasingly popular computer vision applications color image segmentation face tracking image transformation general cluster analysis global optimization problems drawback mean-shift computation prohibitively expensive size complexity dimensionality data space increases case study input data considered image data investigate mean-shift find peaks segment input image layers foreground background extract information similar computations application areas mentioned implementation implemented mean-shift algorithm dimensional data core algorithm figure mean-shift kernel operates window data centered data point estimated centroid center density shown algorithm points window move current centroid areas higher density mean-shift density estimator iteration mean-shift density estimator calculates vector move current centroid higher density areas window data algorithms stops successive iterations yield centroid maximum iteration threshold met points window current centroid calculate euclidean distance current centroid distances calculate mean-shift vector higher density estimate end mean-shift vector non-zero figure mean-shift algorithm kernel estimator calculates mean-shift vector region shape function weight data choose gaussian shape function greater weight points nearer center effectively smooths data giving improved performance dealing noisy data options shape functions weight data point uniformly quadratically triangularly implementation parameters estimated threshold sets minimum data density shift search begin low density areas poor candidates modes shift search make progress areas parameter estimates bandwidth data roughly speaking variability data cases determined experimentally choose fixed bandwidth work data discussion general approach determining bandwidth adaptively comaniciu ramesh meer paper single node non-distributed version algorithm works scan data calculate density data fixed window regions density chosen threshold starting points shift search shift algorithm runs converges local maximum peak experiments distributed algorithm leaf node part data set node applies shift procedure sends resulting data set list peaks higher node network parent node merges data sets children applies shift procedure data set peaks determined child nodes starting points data leaf nodes synthetically generated data cluster center generated random gaussian distribution cluster centers slightly shifted leaf node feature tracking video processing processing images non-uniform illumination evaluation evaluate performance impact computational model performed experiments compare running times implementation mean-shift discussed methodology increase scale input data size evaluate poorly algorithm performs executed single node -deep shallow -deep deep trees varying numbers leaves data sizes increase naturally expect workload prohibitively expensive single node shallow trees represent simple scaling solution directly distributes farms computation solution cost data aggregation central point prohibitively expensive fan-out front-end node increases ons deep trees workload distributed fashion limit fan-out nodes improve data consolidation deep trees cost increased node usage penalty moderate fan-out internal nodes needed connect back-ends back-ends experiments performed cluster ghz pentium workstations gigabytes ram inter-connected gigabit ethernet network experiment fully-balanced tree grouped experiments scale input data size experiment back-end generates input data size distribution input size scales number backends ranging essentially scale problem analyze 
increasingly larger images images generated array cameras larger scale larger array measured processing time starts broadcast control message message front-end instructs back-ends initiate mean-shift algorithm ends results mean-shift calculated front-end process experiment run times average measured processing times plotted figure figure shows distributed versions algorithm improves scalability perfortime seconds input data set scale factor single flat deep figure mean-shift processing times algorithm implemented filter single-node case axis scaling factor input data set -deep -deep trees axis scale factor input data set number back-end processes mance single-node deep trees provide significant performance scalability improvements shallow trees larger scales expected runtime single-node version mean-shift algorithm increases linearly input data size workload scales run-times shallow tree versions increase lower rate fanout shallow tree prohibitively large data consolidation front-end bottleneck fan-out performance deep trees remain constant scales input data size leaves observe small linear increase execution times determined leaves run-time directly proportional fan-out tree open question deeper trees limited fan-outs yield constant execution time scale increases summary paper posit tree-based overlay networks ons provide powerful flexible platform scalable control data collection data analysis applications tools presented examples ons tools simple aggregation operations complex operations clock-skew detection time-aligned data synchronization sub-graph folding scalable data presentation creating data histograms showed computational model applied types applications algorithms scientific data analyses mrnet prototype show scalability on-based distributed data clustering algorithm experiments mrnet start work general ons computing tasks supported networks applications areas data mining bio-information image processing geographic information systems future work ons general tool support clustering algorithms data models decision regression trees built passing data directions tree bidirectional communicationallows model cross-validationor refinement operations performed directly models acknowledgments grateful sean murphy miron livny condor project wisconsin helped tremendously procuring setting experimental environment sponsored national science foundation grant eiareferences top supercomputer sites http top visited january arnold miller zero-cost reliability tree-based overlay networks technical report wisconsin madison december balle bishop lafrance-linden rifkin ygdrasil aggregator network toolkit grid june presented minisymposium workshop state-of-the-art scientific computing balle brett chen lafrancelinden approach parallel debugger architecture applied parallel computing advanced scientific computing international conference para espoo finland june published lecture notes computer science fagerholm eds springer heidelberg germany august barbara editor special section data mining intrusion detection threat analysis volume acm sigmod record pages acm press york usa december bradski real time face object tracking component perceptual user interface ieee workshop applications computer vision pages princeton usa cheng shift mode seeking clustering ieee transactions pattern analaysis machine intelligence comaniciu meer robust analysis feature spaces color image segmentation ieee computer vision pattern recognition pages puerto rico comaniciu meer shift analysis applications ieee computer vision iccv pages kerkyra greece comaniciu ramesh meer variable bandwidth shift data-driven scale selection international conference computer vision volume pages vancouver canada july evensky gentile camp armstrong lilith scalable execution user code distributed computing ieee international symposium high performance distributed computing hpdc pages portland usa august fukunaga hostetler estimation gradient density function applications pattern recognition ieee transactions information theory guting introduction spatial database systems vldb journal hartigan wong k-means clustering algorithm applied statistics johnson hierarchical clustering schemes psychometrika kirbas quek review vessel extraction techniques algorithms acm computing surveys kobayashi takeda information retrieval web acm computing surveys kohavi provost applications data mining electronic commerce data mining knowledge discovery kohavi rothleder simoudis emerging trends business analytics communications acm macqueen methods classification analysis multivariate observations berkeley symposium mathematical statistics probability volume pages berkeley usa california press madden franklin hellerstein hong tag tiny aggregation service adhoc sensor networks symposium operating systems design implementation osdi boston usa december navarro evard nurmi desai scalable cluster administration chiba city approach lessons learned ieee international conference cluster computing cluster pages chicago usa september roth arnold miller mrnet software-based multicast reduction network scalable tools phoenix usa november roth miller distributed performance consultant sub-graph folding algorithm on-line automated performance diagnosis thousands processes submitted sacerdoti katz massie culler wide area cluster monitoring ganglia ieee international conference cluster computing cluster pages hong kong september sottile minnich supermon highspeed cluster monitoring system ieee international conference cluster computing cluster pages chicago usa september tsai wang extraction vocal-related information tofacilitate themanagement popular music collections acm ieee-cs joint conference digital libraries jcdl pages york usa acm press wilburn joshi vaish talvala antunez barth adams horowitz levoy high performance imaging large camera arrays acm transactions graphics xiao wissmann brown jablonski information extraction web system techniques applied intelligence 
completeness attack mutation algorithms shai rubin somesh jha barton miller wisconsin madison computer sciences department shai jha bart wisc abstract attack mutation algorithm takes instance attack transforms distinct instances repeatedly applying attack transformations algorithms widely testing intrusion detection systems investigate notion completeness mutation algorithm capability generate attack instances set attack transformations define notion -complete mutation algorithm set transformations algorithm complete respect generate instance transformations derive show rules uniform reversible -complete algorithm exists intuitively speaking uniform reversible transformations exclusively apply transformations simplify attack exclusively apply transformations complicate instances derived rules uniformity reversibility severe restrictions show common attack transformations uniform reversible complete algorithm incorporated existing testing tools intrusion detection systems show -complete algorithm testing purposes determining packet traces mutations attack introduction goal network intrusion detection system nids detect malicious activities attacks network misuse nids defines attack attack signature typically regular expression matches pattern attack ideally time ongoing activity matches attack signature nids raises alarm conceptually nids signature corresponds single attack sequence events exploits vulnerability practice signature match equivalent attack forms attack instances attack split tcp packets ways reliability nids ultimately depends ability detect instance attack researchers attackers successfully evaded nids mutating attack instance nids recognizes instance misses evade nids signature ascii characters url encoding transformation replaces ascii characters url equivalent hexadecimal values increase nids reliability nids developers test nids attack instances generate instances attack developers commonly attack mutation system system components set attack transformation rules url encoding mutation algorithm system testing developer constructs exemplary instance attack developer feeds exemplary instance mutation algorithm algorithm repeatedly applies transformations predetermined random order generates instances attack testing purposes attack mutation systems successfully uncovered vulnerabilities nids knowledge fundamental question underlying nids testing investigated question testing coverage question instances instances derived rules mutation algorithm generate miss address coverage question develop complete mutation algorithm exemplary attack instance set transformations mutation algorithm -complete generate instances length derived exemplary instance rules observations noted -complete mutation algorithm algorithm exhaustively applies rules combination necessarily -complete problem unclear stop generation instances longer eventually derive instances shorter -complete algorithm necessarily generate instances attack theoretically assert rules represent ways transform attack ability prove algorithm -complete step mutation system generates instances attack determining system transformations scope paper achieving -completeness achieve completeness algorithm requires rules reversible uniform reversibility means transformation system inverse uniformity means attack instance derives instance exists derivation simplify complicate result reach define simplify complicate complexity metric attack instances attack instance hex encoding complex instance encodings show rules uniform reversible instances derives derived representative instances called atoms prove atoms split attack instances equivalence classes instances class derived atom property developed two-phase mutation algorithm attack instance automatically compute atom generate instances derivable atom develop union property preserving reversibility uniformity sets transformations set uniform reversible show positively commutative defined section uniform reversible practically speaking property helps prove uniformity reversibility large set rules develop set uniform reversible rules tcp http union property show union sets uniform reversible algorithm -complete respect tcp http rules usages -complete algorithm nids development encounter forensics problem set rules determine attack instances derived problem arises determine trace packets instance attack show section -complete algorithm assert instances derived -complete algorithm asserts instances derived options instances derived algorithm transformations derive instances case algorithm helps uncover transformation instances derived case algorithm helps define attack distinction cases requires manual intervention note incomplete algorithm introduces case instances derivable algorithm determine fact show -complete algorithm efficiently solve forensics problem rules uniform reversible instances algorithm computes atom checks derived atom correctness algorithm stems fact instances derivable atom summary paper makes contributions notion -complete attack mutation algorithm algorithm addresses coverage question core rigorous nids testing process conditions -completeness develop notion uniformity reversibility attack transformations show concepts prove proposed algorithm -complete develop union property helps proving uniformity union sets transformations practical instance uniform reversible set transformations show common attack transformations uniform reversible set rules include transformations tcp-fragmentation tcp-permutation tcp-retransmission application-level transformation url encoding related work review related work areas attack transformations nids testing abstract reduction systems uniform proofs logic programming attack transformations fundamentally network attacks modified transformed level protocol stack ptacek newsham handley paxson introduce tcp transformations fragmentation packet reordering based work tools attack transformations nids testing evasion developed fragroute transforms tcp-based attacks whisker transforms http attacks randomly combine transformations user mucus attack transformations perform cross-testing nids builds packets match signature nids transforms checks nids identifies modified packets recently vigna developed tool applies application-level transformations http encoding injection telnet escape characters addition tcp transformations testing tools based attack transformations snot stick thor tools mentioned successfully found attack instances evade nids tested knowledge researchers developed tools addressed completeness question recently rubin developed tool called agent exhaustively applies transformation rules combinations provide formal proof agent generate instances argue section exhaustiveness guarantee completeness dacier attack mutation evaluate potential set idss handle large set transformations unlike work investigate completeness property system reduction systems uniform proofs formal methodology closely related abstract reduction system reduction system pair binary relation case attack instances relation defined transformation rules knowledge classic reduction system distinguish shrinking simplifying expanding complicating rules general results systems unmodified concept atom section equivalent concept normal form lambda calculus element reduced atom element reduced shrinking rules uniform form lambda calculus reduced rule note instance reduction system strongly normalized respect shrinking rules instance atom miller describe uniform proofs rightintroduction rules analogous shrinking rules section left-introduction rules similar expanding rules main intuition introducing uniform proofs capture goal-directed search proved framework logic programming uniform proofs complete term provable uniform proof uniform proofs explored contexts special structures derivation securityprotocol verification knowledge paper work explores uniform derivations basis generating attack mutations nids testing technical overview exemplary attack demonstrate fundamental concepts attack mutation paper transformations mutation algorithm atoms uniform derivation perl-in-cgi exploit can- perl interpreter installed cgi-bin directory web server allowing remote attackers execute arbitrary commands attack transformations instance perlin-cgi denoted single httpget request web page cgi-bin perl exe assume single tcp segment including tcp handshake segments transformation rules create instances perlin-cgi frag tcp-fragmentation obtained copying segments tcp packets fragmenting single segment segments instance perl-in-cgi url url encoding obtained replacing printable character url hexadecimal ascii instance 
perl-in-cgi http-pipe http pipelining obtained inserting benign httpgetrequest web page index html malicious request instance perl-in-cgi denote set rules instance derivable respect result applying rule naturally extend definition derivability sequence rule applications attack mutation algorithm generates instances perl-in-cgi repeatedly applying rules initial instance algorithm complete respect denoted -complete generate length instances derived rules notice -complete algorithm generate instances perlin-cgi instances derived rules -complete algorithm generate instances based tcp transformations tcp-retransmission partial order attack instances clear frag url http-pipe complicate add arbitrary benign http commands obfuscate urls fragment smaller tcp segments time impact rules reversible undo frag merging tcp segments undo url normalizing url printable characters undo http-pipe removing benign http requests transformation forms expanding form complicates instance shrinking form simplifies arbitrary attack instance attack mutation algorithm expanding shrinking transformations generate instances denote shrinking reverse versions frag url http-pipe fragurl- http-piperespectively expanding shrinking transformations imply partial order instances perl-in-cgi length bytes instance rank instance complexity longer instance higher complexity note frag url http-pipe increase instance complexity fragurl- http-pipereduce frag increases complexity additional tcp segment requires additional tcp header atoms intuitively instance atomic shrink single tcp segment include benign http requests printable characters simplest form attack byte required successful attack respect rules building block instances expanding rules derives perl-in-cgi instance fragmented non-overlapping tcp segments benign http commands urls printable characters hexadecimal ascii values uniform derivation uniform derivation shrinking transformations precede expanding discuss section prove proposed mutation algorithm -complete show derives uniform derivation easy expand instance fragmenting frag replacing hexadecimal ascii printable character urlthen replace character fragment instance summary observations shrinking expanding transformations correspond intuition simplify complicate attack instances atoms correspond intuition attack instances simplified instances building blocks attack instances uniformity corresponds intuition derive instances instance simplifying instance shrinking rules expanding rules generate instances achieving -completeness goal section develop -complete attack mutation algorithm formally define transformation rules mutation algorithm notion -completeness section discuss general set rules algorithm recursively applies rules -complete discuss reversibility uniformity transformations section prove proposed algorithm -complete reversible uniform section develop union property states conditions union sets rules uniform reversible notice discussion section imply set transformations uniform reversible goal reveal properties proving -completeness arbitrary definition transformations properties show common tcp transformations section http transformations section defined uniform reversible attack mutation algorithm section model attack instances strings alphabet alphabet set set strings set strings length transformation rule form pre post strings pre post predicates rule interpreted string satisfies predicate pre derivable provided post true string derived rule write set transformation rules string derivable respect denoted exists sequence rules called derivation string set rules closure respect denoted set strings derivable formally finite set strings closure byuniontext mutation algorithm denoted takes finite set strings returns set strings intuitively mutation algorithm takes set attack instances returns larger set instances mutations original definition sound complete mutation algorithm mutation algorithm set transformation rules set strings called sound respect denoted -sound intuitively -sound mutation algorithm generates attack instances derivable respect called complete respect denoted complete intuitively -complete mutation algorithm covers strings derivable respect called k-complete respect denoted complete intuitively k-complete mutation algorithm covers strings length derivable respect practical applications bound number instances mutation algorithm derives focus rest paper k-complete algorithms sound mutation algorithm trivial construct soundness granted mention property required understand difficulty constructing complete mutation algorithm standard work-list algorithm builds closure recursively deriving successors initial instance difficult determine terminate derivation process suppose derive instance length intuitively long included inclined derive instance part general mutation system rule arbitrary effect long derive shorter instance part closure uniformity reversibility difficulty constructing k-complete algorithm suggests system requires ordering attack instances goal uniformity reversibility formalize concepts simplifying complicating attack instance uniformity reversibility precedesequal partial order set precedesequal negationslash set transformations partial order precedesequal rule called shrinking rule rule called expanding rule denote subsets consisting shrinking expanding rules intuitively shrinking rules simplify attack instance expanding rules complicate derivation called uniform exist expanding rule shrinking rule alternatively uniform derivation shrinking rules applied expanding rules definition uniformity set transformation rules called uniform exists partial order precedesequal conditions hold respect precedesequal rule shrinking expanding exists uniform derivation words derivation uniform definition reversibility set transformation rules called reversible rule inverse inverse rule denoted rule holds important observations noted uniform reversible set transformations shrinking rule inverse expanding rule vice-versa observation construct -complete algorithm section mentioned beginning section set transformations uniform reversible sections show define common transformations existing mutation systems uniform reversible rest paper assume partial order mutation system descending chain finite chain attack instances called descending assumption states shrinking rules applied infinitely corresponds fact simplify attack instance point instance section simplest form perl-in-cgi attack respect rules considered computing atoms atom simplest instance attack formalize intuition shrinking expanding rules partial order precedesequal set transformations rule expanding shrinking respect precedesequal string called -atom exist shrinking rule shrinking rule applied -atom string set atoms set -atoms derived finite set strings set atoms defined atom theorem set transformations uniform reversible string set atoms singleton set proof theorem suppose sequences set atoms definition derivations reversible derivation sequence rules derivation input string set uniform reversible rules output atoms singleton set currentstring true shrinking rule applied currentstring break pick rule applied currentstring perform currentstring currentstring end return currentstring algorithm computing atoms uniform reversible currentstring string obtained applying rule currentstring derivable uniform uniform derivation cases shrinking rule shrinking rule applied violating fact atom expanding rule uniform derivation starts expanding rule definition rules expanding rules shrinking rule applied violating fact atom square algorithm shows compute atoms initially algorithm sets currentstring time loop shrinking rule applied currentstring shrinking rule applied currentstring algorithm terminates claim set transformations string uniform reversible algorithm computes atoms proof claim algorithm computes descending chains assume descending chain finite section algorithm terminate clear algorithm computes atom theorem proves uniform reversible set transformations set atoms singleton set algorithm computes set atoms square k-complete mutation algorithm show uniform reversible exists -complete mutation algorithm algorithm presents -complete mutation algorithm uniform reversible compute atoms algorithm lines apply expanding rules sequences atoms generate additional sequences notice sequence input set strings set transformations rules output set test strings worklist compute atoms 
forall compute atoms algorithm worklist worklist atoms end compute closure tests worklist worklist negationslash pick worklist worklist worklist compute forall elements negationslash tests worklist worklist end end tests tests end return tests algorithm mutation algorithm theorem proves uniform reversible algorithm k-complete -sound picked worklist successor sequences length denoted generated instance-generation purposes assume precedesequal length preserving precedesequal length length show sections assumption holds common attack transformations claim algorithm terminates proof claim show finite number steps worklist empty notice instance generated line added worklist add newly generated instance tests line add instance worklist instance found tests line notice total number instances added tests line bounded finite number instances added worklist bounded notice iteration loop instance removed worklist line note instance removed exist tests added conclude size worklist bounded iteration removes instance worklist emptied finite number iterations square theorem set transformations mutation algorithm algorithm uniform reversible length preserving partial order k-complete -sound proof theorem soundness algorithm fact apply rules generate test cases prove k-completeness show length algorithm generates formally show sequence set generated algorithm assume arbitrary assume uniform reversible uniform derivation uniform derivation form sequence obtained applying shrinking rules cases atom atoms generated algorithm start derivation atoms line length precedesequal length preserving length fact thatprecedesequal length preserving important ensures length equal algorithm generate instances including atom denote atom construct uniform derivation derives passes note showing derivation implies algorithm generates uniform reversible atoms atoms atoms claim exists derivation reversible exists derivation note precedesequal length preserving length instance derivation insert derivation original derivation obtained uniform derivation passes sequence atoms square claim set transformations uniform reversible atoms atoms proof claim theorem atoms atoms singletons assume contradiction atoms negationslash atoms note reversibility derivation uniform conclude exists uniform derivation follow proof theorem show uniform derivation exist atom square combining mutation systems purpose attack mutation convenient separate sets rules network protocols set tcp transformations set http transformations separation facilitates modular testing process test nids tcp transformations http transformations attack instances derived tcp http transformations theorem proved uniform reversible algorithm -complete complete algorithm -complete prove algorithm -complete prove scratch reversibility uniformity transformations show uniform reversible respect partial order positively commutative result simplifies completeness proof complex mutation systems easier prove commutativity sets rules uniformity union definition positively commutative transformations expanding rule shrinking rule respect partial order precedesequal positively commutative sets transformations precedesequal partial order expanding shirking rules respect precedesequal set-wise positively commutative positively commutative positively commutative note positive commutativity weaker condition full commutativity positive commutativity require claim transformation sets setwise positively commutative proof claim intuitively claim expands notion positive commutativity derivation longer rules derivation set-wise positively commutative shift left times derivation repeat shifting process derivation analogously prove square notice positive commutativity imply uniform set rules derivation positive commutativity implies derivation uniform uniform derivation converted uniform theorem generalizes observation theorem sets transformations rules reversible uniform respect partial order precedesequal set-wise positively commutative reversible uniform respect precedesequal proof theorem clear union transformation sets preserves reversibility left show uniform derivation exists derivation derivation proof similar proof claim uniformity commutativity shift shrinking rules beginning derivation express terms subderivations rules lose generality assume derivation starts rules uniform express derivation uniform subderivations prove induction derivation converted uniform derivation form derivation changed shifting process induction number uniformity violations derivation uniformity violation occurrence derivations induction appendix input strings set transformations output true false compute atoms algorithm compute atoms algorithm return true return false algorithm uniform reversible algorithm solves forensics problem summary theoretical results formulated attack transformations uniformity reversibility proved uniform reversible set transformations algorithm k-complete -sound theorem developed algorithm compute atoms algorithm showed uniform reversible atoms singleton set showed atoms atoms claim observation immediately leads algorithm uniform reversible solves forensics problem algorithm investigated union property ensures union sets uniform reversible transformations uniform reversible section show carefully defined common attack transformations uniform reversible uniform reversible tcp rules present set common tcp transformations reversible uniform prove transformations reversible uniform formally define notion tcp sequence semantics transformations section define partial order tcp streams called complexity section prove rules reversible uniform respect complexity section reader advised proof uniformity reversibility based semantics rules words claim previous attack mutation systems include types transformations define transformations reversible uniform reader encouraged check semantics closely represents nature transformations rule definitions easily adopted mutation systems familiar semantics tcp transformations tcp sequence represents communication attacker victim sequence list segments segment represents single message attacker victim exchange segment description frag fragments payload tcp segment segments create overlapping segments payload abcd frag abc bcd frag defragments tcp segments single removes overlapping segments payload abc bcd frag abcd swap swaps tcp segments out-of-order abc bcd swap bcd abc swap swaps tcp segments in-order bcd abc swap abc bcd ret retransmits tcp segment retransmit part payload note application rule produce identical result frag application abcd ret abcd retremove retransmitted segments tcp stream note application rule produce identical result fragapplication abcd retabcd table tcp uniform reversible set tcp transformations ain tcp jargon out-of-order means order sequence numbers formulated pair seq payload seq represents sequence-number payload represents message bytes position segment sequence determines time segment attacker brevity tcp sequence definition includes segments attacker table presents tcp set transformations tcp mutation system superscript denotes expanding rules superscript denotes shrinking rules formally rule form pre post section observations noted system includes tcp rules fragment tcp stream deliver segments out-of-order add retransmitted segments table informally describes rule effects formal semantics rules presented appendix tcp fragmentation rule create overlapping tcp segments definition broader previous define fragmentation splitting turns splitting uniformity existence retransmission merging unsplitting create overlapping segments simplify segments defining de-fragmentation frag overlapping cases fragmentation retransmission effect abc ret abc abc frag abc rules unique effect retransmission rule retransmits substring segment fragmentation rule split segment tcp retransmission rule retransmits data means segments overlap transmit payload overlapping parts definition retransmission facilitates uniformity proof section discusses retransmission data partial order tcp sequences show tcp table uniform show rules tcp shrinking expanding respect partial order order tcp sequences complexity complex delivers longer payload delivers payload segments delivers payload number segments segments disordered define segments definition length tcp sequence tcp sequence define length pair 
summationtextni size payload length length length length length length component complexity disorder level tcp sequence disorder level counts number segment pairs out-of-order disorder level sequence sends segments ordered sequence numbers similarly disorder level sequence sends segments reverse order definition tcp sequence disorder level tcp sequence define order seq seq disorder summationtext order definition complexity tcp sequence tcp sequence define complexity length disorder complexity complexity complexity complexity length length length length disorder disorder complex denoted complexity complexity note complexity partial order ranks sequence length primary index disorder secondary required section descending chain complexity finite simplify attack instance infinitely simply length bounded segments complexity length preserving required theorem claim respect complexity rule tcp shrinking expanding proof claim presented appendix uniformity proof tcp prove tcp uniform prove conditions claim hold claim set transformations reversible rule shrinking expanding respect partial order precedesequal iii atoms atoms atoms singleton set atom exists derivation shrinking rules uniform respect precedesequal proof claim show exists uniform derivation conditions iii exists atoms atoms condition derivations exist reversible condition uniform derivation square notice tcp condition holds rules tcp based string operations reversible concatenation permutation condition holds rules tcp shrinking expanding respect complexity claim tcp sequence reader encouraged check overlapping segments order segments repeatedly apply shrinking rules tcp sequence segments ordered sequence numbers apply swap byte transmitted apply frag ret iii number tcp segments apply frag repeatedly applying shrinking rules atom condition holds single atom rules change payload tcp sequence tcp specifications single transmit payload byte transmitted order number segments atoms tcp singleton set condition holds tcp tcp specifications rules tcp alter payload tcp sequence tcp means transmits payload single atom atoms transmit payload tcp specification atoms identical condition iii holds showed tcp conditions claim hold tcp uniform reversible respect complexity uniform reversible http rules illustrate uniform reversible set transformations http protocol illustrate representative transformations http padding pads http request spaces url http encoding encodes url hexadecimal values chose transformations successfully evade nids transformations represent applicationlevel transformations modify attack payload discuss application-level transformations section abstract http attack single string cgi-bin perl exe http define http attack regular language conforms http specifications denoted lhttp lhttp lurl http lurl defines url string ascii characters hexadecimal encodings formally lurl ascii ascii ascii standard ascii character set ascii regular substitution maps ascii character string representing character hexadecimal encoding pre condition post condition pad url http url http padm url http url http pad url http url http padm url http url http url http ascii http urlm http ascii http table http uniform reversible set transformations http-based attacks regular substitution ascii characters hexadecimal encodings stands white-space characters post common http methods http attacks table presents set http transformations denoted http rules pad pad change number spaces attack components url rule encodes single ascii character attack url hexadecimal encoding proof uniformity http show conditions claim hold http definition table clear rule reversible padpad- urlare shrinking rules respect complexity definition rules reduces number bytes instance reduces instance length definition analogously pad pad url expanding rules proofs atoms http singleton set atoms http atoms http similar proofs presented tcp section case proofs based http specification states single most-concise deliver http attack combining http tcp show http tcp uniform reversible showing conditions claim hold difficult add transformations system uniformity proof tcp section assumed rules change attack payload assumption longer true case http illustrate method proving uniformity theorem show http tcp uniform http tcp positively commutative theorem particulary suitable proving uniformity sets transformations protocols belong levels protocol stack tcp transformation-level protocol http application-level protocol tcp specification indifferent http payload http specification indifferent tcp transfers payload independency basis commutativity proof rules http represent http attack single string rules tcp represent attack tcp sequence section unify http tcp single representation attacks adjust definitions rules http work multiple tcp segments due space constraints discuss adjustment appendix claim tcp http uniform reversible proof claim notice rules tcp http shrinking expanding respect partial order complexity definition show tcp http uniform show sets set-wise positively commutative definition uniformity tcp http theorem show tcp http positively commutative show derivation form http tcp exists equivalent derivation form tcp http derivation form tcp http exists equivalent derivation form http tcp table presents major cases derivations cases similar omit brevity modeling transformations discuss uniformity reversibility transformations part tcp http modeling tcp transformations header change tcp transformations operate header tcp segment modify tcp flags prove transformations uniform involve syntactic manipulation tcp level prove uniformity extend representation tcp sequence section include representation tcp header extend definition complexity enforce notion expanding shrinking rules original change pad frag frag pad url frag frag url url ret ret url ret url url ret frag url url frag ret pad pad ret table positive commutativity http tcp biggest challenge prove uniformity reversibility tcp transformations tcp retransmission payload problem content bytes tcp segments ambiguity creates difficulty define retbecause choose values notice ambiguity practice end host resolves ambiguity linux kernels prefer byte receive comparison operating systems openbsd prefer byte suggests define tcp retransmission preserves uniformity policy defined operating system leave investigation future work modeling application-level transformations application-level transformations operate attack payload ftp padding adds benign commands malicious commands ftp attack transformations similar transformations http uniformity proved similar modeling network-level transformation networklevel transformations udp change attack delivered transformations split packets transformations similar nature tcp transformations uniformity proofs similar proofs tcp conclusion nids testing challenging problem intrusion detection experience shown nids evaded easily frequently -complete mutation algorithm serve basis rigorous testing process infeasible test mutations knowledge present algorithm acknowledgments deeply vinod ganapathy anonymous referees comments helped refine concepts presented paper alessandri editor taxonomy intrusion detection systems attacks ibm zurich research laboratory sep deliverable project maftia ist- maftia baader nipkow term rewriting cambridge press barendregt lambda calculus studies logic foundations mathematics north holland chevalier ksters rusinowitch turuani decision procedure protocol insecurity xor ieee symp logic computer science ottawa canada june clarke jha marrero verifying security protocols brutus acm toplas oct comon-lundh shmatikov intruder deductions constraint solving insecurity decision presence exclusive ieee symp logic computer science ottawa canada june dacier editor design intrusion-tolerant 
intrusion detection system ibm zurich research laboratory aug deliverable project maftia ist- maftia fielding gettys mogul frystyk masinter leach berners-lee rfc hypertext transfer protocol internet engineering task force june giovanni fun packets designing stick mar endeavor systems handley paxson network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington aug hodas miller logic programming fragment intuitionistic linear logic information computation hopcroft motwani ullman introduction automata theory languages computation addisonwesley edition marti thor tool test intrusion detection systems variations attacks master thesis swiss federal institute technology mar meadows nrl protocol analysis tool position paper ieee computer security foundations workshop franconia june miller nadathur pfenning scedrov uniform proofs foundation logic programming annals pure applied logic mitre corporation cve common vulnerabilities exposures cve mitre mutz vigna kemmerer experience developing ids stimulator black-box testing network intrusion detection systems annual computer security applications conference las vegas dec paxson bro system detecting network intruders real-time computer networks dec postel rfc transmission control protocol internet engineering task force sept ptacek newsham custom attack simulation language casl sockpuppet tqbf casl html ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks calgary canada rain forest puppy whisker anti-ids tactics bad ruin good thing dec wiretrip net rfp txt whiskerids html roesch snort open source network intrusion detection system snort rubin jha miller automatic generation analysis nids attacks annual computer security applications conference tucson dec rubin jha miller attack mutation test high-end nids information security bulletin apr shankar proof search intuitionistic sequent calculus proceedings international conference automated deduction cadesaratoga springs june sniphs snot jan stolenshoes net sniph index html song fragroute tcp fragmenter apr monkey dugsong fragroute vigna robertson balzarotti testing networkbased intrusion detection signatures mutant exploits acm conference computer communications security washington oct formal definition tcp formal definition tcp table predicates table definition fragmentation defragmentation tcp segment seq payload tcp segment possibly empty prefix payload possibly empty suffix payload size size size payload define seg frag payload payload seq seq seq seq size payload size tcp defragmentation defined inverse operation tcp fragmentation segment defragmentation seg frag definition retransmission tcp segment seq payload tcp segment substr possibly empty substring payload retrans payload substr seq seq index character substr payload proofs mentioned paper induction proof claim derivation single uniformity violation form claim convert derivation induction step derivation uniformity violations induction base convert derivation derivation uniformity violations induction hypothesis series shift side derivation due positive commutativity change uniformity change continue process derivation finally technique shift side derivation square proof claim frag ret based length definition definition fragmenting retransmitting tcp segment increases sequence length increases sequence complexity swap rule swaps segments delivered order operation increases disorder sequence increases sequence complexity formally pre-conditions post-conditions frag frag seg frag frag seg swap seq seq swap seq seq ret retrans ret retrans table formal definitions transformation rules rule form pre post assume swap definition swap seq seq table note order order order order order order order order assume seq seq seq order order order order means swap operation contributes disorder assume seq seq seq order order order order means disorder disorder assume seq seq seq order order order order means disorder disorder note orderings impossible seq seq swap order order proofs shrinking transformations reduce complexity analogous proofs complexity order suitable uniform reversible attack mutation system square properties conclude disorder disorder swap transformation change length stream complexity complexity adjusting http rules http represent http attack single string rules tcp represent attack tcp sequence section unify http tcp single representation tcp representation payload natural express http transformations terms tcp sequences preserve properties http tcp rules express http rules change sequence numbers tcp sequence http rules insert remove bytes shift bytes follow inserted bytes url update sequence numbers tcp segments segment url encoded byte url recall tcp support retransmission payload section means http rule insert remove change byte tcp stream copy byte stream abc bcd url http rules formally expressed simple procedure traverses segments tcp sequence modify 
effective model-based intrusion detection jonathon giffin somesh jha barton miller computer sciences department wisconsin madison wisconsin technical report abstract model-based intrusion detectors restrict program execution previously computed model expected behavior classes attacks systems bypass attacks evade detection avoiding detection system altogether transformational attacks alter detected attack semantically-equivalent attack undetected recent detection approaches problematic effectively address threats reductions outright failures effectiveness efficiency systems monitor execution library call interface provide accuracy inlining statically-constructed program models simplistic analysis indirect function calls attacks defeat library-call monitors directly executing operating system kernel traps inlined models grow exponentially large trap interface models test programs times larger trap interface library call interface indirect call analysis produces models times larger models built in-depth analysis detect attacks examining issues aim reveal complexities model-based detection previously understood introduction host-based intrusion detection systems identify attempts exploit program vulnerabilities frequently monitoring program execution model-based behavioral-based anomaly detector restricts execution precomputed model expected behavior execution monitor verifies stream system calls generated executing program rejects call sequences deviating model constructing model balances competing detection ability efficiency challenging task successful attack subverts execution vulnerable process manner undetectable execution monitor threat models meeting definition bypass attacks exploit design deficiencies detection system avoid execution monitor generate arbitrary unmonitored system calls system calls executed attack allowed execution monitor monitor intercepts calls bypass attack transformational attacks mimicry attack alter detected attack undetected model-based detection system carries malicious intent transformational attack allowed program model recently proposed model-based detection systems effectively address threats resistance bypass attacks requires enforcement interface attacks required requires identification trusted computing base components computer system trusted non-malicious impenetrable attack common host-based intrusion detection scenarios trusted computing base includes operating system kernel execution monitor code system effective system call interception requires monitoring kernel trap interface bypass attacks defeat recent detection systems monitor interfaces library call interface directly trapping kernel resistance transformational attacks requires program models accurately represent correct execution behavior recent systems static program analysis build models address limitations analysis accurate model control flows indirect function call sites requires identification targets indirect call simplistic indirect call analysis offer opportunities attacker including incorrect control flows model transformational attacks easier mount number allowed execution paths system call sequences increases experiments unix system weak analysis recent system increased model size times decreased model precision times compared models constructed deeper indirect call analysis accurate model correctly characterize function calls returns model inlining recently proposed technique addresses inlined models efficiently enforced execution monitor deployed monitor rapidly verify system calls maintain low in-memory footprint inlined models grow exponentially height program call graph impose unreasonable requirements verification experiments inlined model times slower required times memory non-inlined model equal accuracy examining issues aim reveal attacker threats model construction complexities affect model-based intrusion detection systems paper makes contributions explicit enumeration attacker threats model-based anomaly detectors address section describes bypass attack transformational attack detail in-depth analysis interface execution monitor securely enforce program model show section resistance bypass attacks requires non-circumventable interface computer systems set traps operating system kernel defines entire secure interface attackers trivially bypass recent systems monitor execution library call interface comparison techniques accurately model function call return behavior automata inlining non-inlined dyck model previous reported results unfair comparison inlined model library call interface dyck model kernel trap interface static analysis infrastructure construct inlined dyck models library call kernel trap interfaces allowing valid comparisons section shows inlined models prohibitively large build enforce constructed non-circumventable kernel trap interface examination effect indirect function calls statically-constructed models call foundational research area section give real examples current automated identification targets indirect calls significantly overapproximates set targets callsystem allowedsystem call kernel space user space vulnerableprocess monitor operatingsystem returnvalue returnvalue rejectedsystem call figure monitored execution monitor intercepts system call requests calls matching process behavioral model attacks model-based anomaly detectors host-based intrusion detectors find attacks monitoring behavior locally executing processes model-based anomaly detectors verify stream system calls executing process precomputed model expected behavior execution monitor process execution matches program model process monitor execute trusted operating system figure monitor incorporated operating system kernel improved performance maintain integrity monitor isolated separate address space possibly subverted process observes note designs carefully architected vulnerabilities including time-of-check time-of-use races monitor verification system call subsequent kernel execution introduced system attackers attempt alter process execution process issues malicious system calls undetectable monitor common attacks include execution command shell appending user system password file privilege escalation monitor verify process execution programming interface observable events kernel trap interface process calls interface monitor intercepts call suspends execution process call allowed program model monitor resumes process execution call falling program model monitor process subverted response activated monitor protects operating system subverted processes operating system monitor form trusted computing base tcb computer system assurances system security valid require tcb non-malicious free exploitable vulnerabilities processes change tcb well-defined system call interface processes tcb explicitly untrusted expect attacker manipulate processes arbitrary manner model-based intrusion detectors prevent manipulation harming tcb identifying process attempts system calls unexpected successful detection attack requires assumptions hold attacks produce events observable monitor model expected behavior precise accept attacks valid system call sequences attackers evade detection attack violates assumptions possibilities bypass attacks evade detection bypassing monitored interface attacks exploit systems monitor high-level interfaces fail enforce execution interface trusted computing base calling trusted computing base directly higher interface attack maliciously alter system detection examine bypass attacks section transformational attacks alter existing attack detected model-based anomaly detector semantically-equivalent attack evades detection appearing valid execution sequence system calls exists sentence language accepted program model program generate executing correctly model correct alternative detection approaches program generate correct execution program model imprecise model construction strategies developed examine techniques build precise program models context-sensitive construction indirect call analysis sections monitored interface bypass attacks exploit design errors execution monitor avoid monitor execute unverified system calls resist bypass attacks model-based intrusion detection system verify process execution non-circumventable interface trusted computing base tcb section addresses points common operating systems including windows linux unix tcb includes operating system kernel execution monitor code shared object files dynamically linked libraries dlls explicitly part tcb bypass attacks evade model-based intrusion detection system monitor interface trusted computing base current 
windows exploits commonly call library functions windows subsystem dlls exploits modified directly execute windows kernel traps recent research focused execution monitoring interfaces library calls operating system kernel traps library call interface reasonable programs make calls standard library code library interpositioning frequently easy generate events execution library code part trusted computing base show interface circumventable provide security secure systems subsequently sequences kernel traps generated programs claim non-circumventable interface execution monitors implications choosing improper interface profound efforts enforce correct patterns circumventable interface secure bypass attacks escape monitoring simply bypassing interface show section poorly choosing event interface compounds problems algorithm design accurate model construction library call interface process running modern operating system executes code application shared libraries make distinction application code library code application code void main int char argv syslog argv format string vulnerability setuid root uid chroot chdir var chdir chroot chroot establish chroot jail scandir null issetuid alphasort exit exit jail setuid program setuid drop privilege root exec argv exec program inside jail figure code function issetuid user-provided function takes directory entry returns true entry setuid binary scandir setuid execchrootsetuidsyslog exit chdir figure library model includes binary code sections contained executable image file loaded operating system code generally unique program written specific library code binary code shared object files including runtime linker standard library windows subsystem dlls general-purpose code processes reside image file application ways functions standard libraries viewed user-space extension kernel library calls serve basic purposes convenience process makes operating system request executing software trap trap requires machine instruction int systrap syscall generated hand-written assembly code high-level language compiler shared libraries provide convenient wrapper functions kernel traps providing applications function call interface kernel error checking library wrapper functions examine error returns kernel traps provide higher-level error interface application programs expect programs make shared libraries easy convenient direct consequence expect kernel trap executed process preceded call library function recent model-based intrusion detection systems make intuition monitor execution library call interface interface offers advantages library call interface richer fingerprint correct process execution windows unix linux kernels fewer traps windows system library entry points solaris library addressable functions rich library interface build expressive execution models function mainin figure makes series library calls logging filename creates chroot jail var ensures jail directory setuid executable drops privilege executes program jail syslog call format string vulnerability attacker write arbitrary memory locations possibly changing program execution syslog jump directly setuid xorl eax eax xdb xorl ebx ebx movb xcd int figure fragment shellcode format string attack final bytes directly execute setuid kernel trap preceding bytes construct arguments passed kernel trap handler exec call systems enforce correct library calls analyze code build automaton model library call events shown figure systems offer real security security systems monitoring execution library call interface requires execute kernel trap calling library function library code extension kernel fallacy libraries part tcb library interface circumventable allowing attack code execute kernel traps calling library function attacker exploiting format string vulnerability code transfer execution machine instructions contained format string execute kernel traps directly figure bypass attack invokes kernel operations escapes process monitor intercepting library calls kernel trap interface attack bypass kernel part trusted computing base kernel code immune direct attack entered entry points entry points define secure interface attacks circumvent attack generates malicious system calls create kernel trap events execution monitor verifying process execution kernel trap interface intercept trap detect malicious behavior attack evade monitor failing execute kernel traps attack contained process work linux jones lin write library call approach works buffer overflow attacks typical attacker code adds sequences library calls emphasis added disagree experience typical linux unix attacks call library functions unixlike systems easier attacks directly execute kernel traps call library functions kernel trap interface easy invoke trap requires knowledge address library code resides memory observations hold practice surveyed linux unix exploits archived securiteam january code injection attacks including buffer overflows format string attacks injected code bypassed library interface directly executed kernel traps figure shows fragment code injected executed format string attack web server front-end load balancer intrusion detection systems monitoring library call interface detect current attacks current exploits processes executing windows work differently operating system kernel traps intended executed windows subsystem shared libraries directly applications windows exploits largely obey programming practice library call enforcement detect current windows attacks exploit design largely artifact arising obfuscated set windows kernel traps kernel trap interface widely published change operating system releases details windows trap interface called native api interested attackers attackers convert attack calls subsystem library functions attack directly invokes windows kernel traps library call verification detect today attacks effort attackers alter windows exploits bypass library call interface recent intrusion detection systems monitor combination kernel traps function call return addresses stored call stack important understand utility function call monitoring knowledge function call interface circumventable function call return events serve improve efficiency online execution monitoring kernel traps provide secure monitoring point system system feng build automata accepting context-free language kernel traps correctly executing process generate recognizing context-free language incrementally cubic-time operation slow real-world deployment monitoring function calls determinizes automaton operation systems recognize context-free language linear time function call events offer additional security significantly improve efficiency kernel trap verification attacks produce fake function call events limited context-free language kernel traps accepted model gopalakrishna recognized attacks trivially escape library call monitoring suggested combination library call kernel trap enforcement enforcement subsumed systems monitor traps entire set function calls library calls function call systems changing trusted computing base secure execution monitoring occurs interface trusted computing base tcb monitored interface likewise shift remote distributed execution environments reflect change processes execute remote untrusted machines communicate parent process distributed computation stream events entire remote machine including operating system hardware malicious trusted computing base includes machine parent process executes parent process attacker remote machine attempt harm parent process sending malicious events parent communication channel non-circumventable interface attacker unable bypass model-based anomaly detection system model remote process communication channel subsequently monitor channel detect subversion remote process deviation model constructing efficient context-sensitive models reduce attacker opportunity construct transformational attacks program model accurately characterize program control flows construction method recently 
accurately model function calls returns inlines models called functions show techniques replicate model structure inlining build prohibitively large models secure kernel trap interface experiments unix system construct inlined models kernel trap interface test programs htzipd gnatsd construction consumed entire virtual address space machine scandirchroot exit chdirsyslog exec libc modelsetuid figure call-site replacement applied library call setuid simplistic algorithm introduces impossible path shown bold correctly model function calls returns successfully constructed inlined models programs cat lhttpd inlined models times larger non-inlined models choosing poor interface compounds difficulty finding reasonable model construction algorithms reasonable size bypassable library interface inlined models times larger secure kernel trap interface large size inlined models leads prohibitive runtime enforcement resource demands inlined models times slower required times memory models equal accuracy construction techniques static analyzers construct program model stages analyze function abstracting code control-flow transfers branches function calls kernel traps assemble models function global model program designer system choose algorithm call-site replacement dictates model interprocedural control flows function calls returns good call-site replacement strategies models compact accurately characterize interprocedural control flows produce models efficient operate online execution verification strategies trivial develop topic section figure shows model main figure simplistic call-site replacement strategy applied library call setuid original call edges targeting setuid replaced -edges transferring control model setuid strategy context insensitive enforce proper function call return behavior context insensitive models subject transformational attacks impossible path attacks mimicry attacks exploit inaccuracy bold path figure impossible path accepting altered program executions bypass chroot jail creation loss root privilege push-down automaton push-down automaton pda accepts context-free language generated program executing proper call return semantics call-site replacement algorithm constructs pda adding push pop symbols -edges figure call site distinct symbols distinct function call return addresses program execution monitor rejects event sequences contained context-free language accepted pda algorithm model size compact calls function link model replication state program application libraries cat htzipd lhttpd gnatsd sendmail table sparc instruction counts feng previous work function call return events cost online pda operation time linear pda size inlining additional call return events impose slight cost execution monitor read data virtual address monitored process system call recent suggested alternative method retain model context sensitivity dispensing compute call return events lam chiueh gopalakrishna implemented call-site replacement algorithm inlined models call sites inlining replaces function call transition automaton unique copy target function model program multiple call sites targeting function algorithm introduce impossible paths call site links copy target model inlining recursive call sites final program model accepts regular language overapproximation context-free language events executing process generate regular language recognized linear time requiring additional function call return events inlining replicates models functions raising concerns scale large programs gopalakrishna presented reasonable results test programs building inlined iam model insecure library interface poor interface selection obscures inlining performance constructing models non-circumventable kernel trap interface intuition suggests space cost inlining exponential height call graph simple function leaf function called functions functions called functions number copies model multiplication repeats entire height call graph leaf function program modeling program kernel trap interface increases number functions modeled height call graph including code shared libraries programs listed table correspond test programs gopalakrishna previously published results static binary analysis sparc executables constructed inlined models programs library interface kernel trap interface measure ability inlining scale complete programs earlier intuition expected inlined models constructed trap interface significantly larger models library interface tables show results comparisons static analysis demands test programs gopalakrishna static analyzer executed sun microsystems sunfire server dual -bit mhz ultrasparc iii processors physical memory running solaris solaris user processes address entire memory space list memory static analyzer time required construct program model size resulting model interface model library calls kernel traps binary iam dyck model construction memory interface model library calls kernel traps binary iam sec sec dyck sec sec model construction time interface model library calls kernel traps iam states unreported edges binary iam states states edges edges dyck states states edges edges automaton sizes table results cat interface model library calls kernel traps binary iam dyck model construction memory interface model library calls kernel traps binary iam sec sec dyck sec sec model construction time interface model library calls kernel traps iam states unreported edges binary iam states memory edges dyck states states edges edges automaton sizes table results htzipd test program list values model construction circumventable library interface construction secure kernel trap interface results iam model computed copied gopalakrishna present results memory build time models constructed trap interface implemented inlining call-site replacement technique existing binary analysis infrastructure computed results shown binary iam infrastructure lastly include results construction dyck model pda call-site replacement algorithm binary iam models library interface significantly smaller iam models constructed gopalakrishna source code analysis examined inlined model cat identified analysis differences accounted discrepancy infrastructure performed aggressive optimization program models infrastructure gopalakrishna minimized automata remove redundant edges source code analyzed gopalakrishna match object code produced compiler source code strange mix preprocessed non-preprocessed code macros expanded remaining result iam models contained macros events library interpositioning intercept macro event disabling optimizations manually inserting macro events increase size binary iam model cat states edges manual verification analyzer executing correctly binary iam models optimized source-level iam models previously reported interface model library calls kernel traps binary iam dyck model construction memory interface model library calls kernel traps binary iam sec sec dyck sec sec model construction time interface model library calls kernel traps iam states unreported edges binary iam states states edges edges dyck states states edges edges automaton sizes table results lhttpd interface model library calls kernel traps binary iam dyck model construction memory interface model library calls kernel traps binary iam sec sec dyck sec sec model construction time interface model library calls kernel traps iam states unreported edges binary iam states memory edges dyck states states edges edges automaton sizes table results gnatsd tables important features inlined models grow prohibitively large small programs modeling kernel trap interface model cat grew million percent attempts construct models htzipd gnatsd failed consuming entire address space -bit system non-inlined dyck model scales increasing code size code complexity building 
models library interface non-inlined dyck models smaller inlined counterparts measured ability inlined models enforce execution kernel trap interface executed cat command-line option workload wrote files totaling disk binary iam model dyck model effectively constrained attacker measurements precision identical decimal places indicating inlined model loss precision recursive call sites significant inlined models faired evaluating performance impact table shows slowdown runtime due execution verification binary iam dyck models operated time linear automaton size significant increase inlined model size resulted significantly worse performance table memory demands runtime monitor models large inlined model required significant system resources architecture windows operating system worsen effects inlining microkernel design user-space subsystem dlls significant functionality models constructed library call interface include shifting execution monitoring secure windows unverified verified execution model execution initialization parse model execution total slowdown binary iam dyck table performance impact verifying cat execution program model model cat memory model size increase binary iam dyck table memory impact execution monitoring kernel trap interface requires execution model windows application additionally model code libraries simple editor notepad exe functions dlls required notepad functions results speak emphatically inability inlined models meet practical security systems gopalakrishna realize small inlined models forcat htzipd lhttpdbecause application code size programs small inlining reached rapid growth exponential growth curve reached gnatsd explosive growth evident library interface adding library code programs pushes models rapid growth lam chiueh constructed inlined models linux kernel trap interface exponential model growth presented results reasons linux standard library code complex solaris standard libraries experiments lam chiueh statically inline models indirect call sites monitoring-time call-site replacement algorithm replicate model state analyzed statically-linked programs contained runtime linker typical dynamically-linked programs library call invoke runtime linker due lazy linking lazy loading runtime linker complex significantly increases model complexity effects indirect calls indirect function calls add control-flow complexity require deep analysis satisfactorily resolve indirect calls significantly affect program models constructed static analysis omission indirect call analysis builds models times larger models built analysis times larger models built combination analysis manual annotation indirect call analysis significantly constrain attackers omitted weak analyses increase attacker opportunity develop transformational attack current automated data-flow analyses insufficient require manual annotation static code analyzers identify targets indirect function calls generated model correctly characterizes control-flow transfers library function scandir called figure takes function pointers arguments subsequently calls indirect call sites analysis indirect call analysis program data-flow analysis annotations cat states states states edges edges edges htzipd states states states edges edges edges lhttpd states states states edges edges edges gnatsd states states states edges edges edges sendmail states states states edges edges edges table effect pointer analysis dyck model size precision analysis analysis annotations figure model precision cat indirect call analysis lower bar code identify targets indirect calls identification undecidable source binary code analysis statically-constructed models approximate set targets approach lam chiueh performs analysis indirect function call target function program method greatly overapproximates correct program behavior attacker significant freedom wagner dean constrained set targets functions address program source code significantly overapproximates correct execution treating function pointers identical gopalakrishna improved analysis separately analyzing function pointer source code allowed indirect function call target functions type signature matched call site binary code analysis greater difficulty binary code weakly typed previous work binary data-flow analysis compute addresses indirect function calls dataflow analysis recover call site targets constructed model allowed site target function address computed data-flow analysis significantly implementation limitations caused analyzer miss targets introduce false alarms analyzer recover function addresses vtables vtables objects heap manual annotation improve precision analyses wagner dean manually restricted targets indirect function call sites improve precision models annotation similarly improve precision add control flows missed automated data-flow analysis annotations simple pair load elf map specifies indirect call load targets function elf map inconvenient annotation adf set lorder includes virtual address indirect call site object code library virtual addresses distinguish multiple indirect call sites function analyses significantly alter constructed models table shows sizes pda-based dyck model constructed varying levels indirect call analysis show results programs earlier sections sendmail program sparc instructions application code library code table includes model sizes lam chiueh omitted pointer analysis automated binary data-flow analysis manual annotation figure presents model precision measurements average branching factor executions cat lower measurements opportunity attack greater precision case increasingly complex analyses improve model precision models constructed indirect call analysis accept fewer event sequences constrain program behavior attacker opportunities including manual annotation step improves existing automated analyses programs annotation inconvenient diminishes usefulness work additional research develop complex binary data-flow analyses previous work note researchers begun making progress area conclusions model-based intrusion detection system design threats systems face bypass attacks escape monitor verifies execution circumventable interface recent proposals monitor executing processes library call interface unable address bypass attacks successfully defeated attacker interface trusted computing base frequently operating system kernel trap interface secure monitoring point transformational attacks modify detected attack appears monitor correct execution models enforced monitor accurately represent correct program behavior reduce attacker opportunities successfully develop transformational attack function calls returns correctly modeled push-down automaton efficiently operated call return events addition kernel trap events approaches automaton inlining exponential growth program models program size increases reasonable model size bypassable library call interface indicator reasonable models secure kernel trap interface static model construction efforts remain ongoing evidenced efforts improve indirect function call analysis function calls returns models accurately characterize control flows indirect function call sites current automated analyses insufficient frequently require human annotation indirect call targets build precise models produce false alarms expect continued research static data-flow analysis make solely automated algorithms effective abadi fournet access control based execution history network distributed system security symposium ndss san diego california feb anonymous butler anonymous bypassing party windows buffer overflow protection phrack july ashcraft engler programmer-written compiler extensions catch security holes ieee symposium security privacy oakland california balakrishnan reps analyzing memory accesses executables international conference compiler construction barcelona spain apr pound format string exploit http securiteam exploits kcui html debar dacier wespi taxonomy intrusion-detection systems computer networks debray muth weippert alias analysis executable code acm symposium principles programming languages popl jan feng giffin huang jha lee miller formalizing sensitivity static 
analysis intrusion detection ieee symposium security privacy oakland feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland gao reiter song gray-box extraction execution graphs anomaly detection acm conference computer communications security ccs washington oct gao reiter song gray-box program tracking anomaly detection usenix security symposium san diego aug garfinkel traps pitfalls practical problems system call interposition based security tools network distributed system security symposium ndss feb giffin jha miller detecting manipulated remote call streams usenix security symposium san francisco aug giffin jha miller efficient context-sensitive intrusion detection network distributed systems security symposium ndss san diego feb gopalakrishna private communication apr gopalakrishna spafford vitek efficient intrusion detection automaton inlining ieee symposium security privacy oakland california jones lin application intrusion detection language library calls annual computer security applications conference acsac orleans louisiana dec kruegel kirda mutz robertson vigna automating mimicry attacks static binary analysis usenix security symposium baltimore maryland aug lam chiueh automatic extraction accurate application-specific sandboxing policy international symposium recent advances intrusion detection raid sophia antipolis france sept landi undecidability static analysis acm letters programming languages systems loplas dec lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy oakland provos improving host security system call policies usenix security symposium pages washington aug russinovich solomon microsoft windows internals microsoft press edition dec sander tschudin protecting mobile agents malicious hosts volume lecture notes computer science pages springer-verlag securiteam exploits http securiteam exploits sekar bendre bollineni dhurjati fast automaton-based method detecting anomalous program behaviors ieee symposium security privacy oakland tan killourhy maxion undermining anomaly-based intrusion detection system common exploits recent advances intrusion detection raid lncs pages zurich switzerland october springer-verlag wagner dean intrusion detection static analysis ieee symposium security privacy oakland wagner soto mimicry attacks host based intrusion detection systems acm conference computer communications security ccs washington nov wagner static analysis computer security techniques software assurance phd dissertation california berkeley fall chapin context sensitive anomaly monitoring process control flow detect mimicry attacks impossible paths international symposium recent advances intrusion detection raid sophia antipolis france sept 
environment-sensitive intrusion detection jonathon giffin david dagon somesh jha wenke lee barton miller computer sciences department wisconsin giffin jha bart wisc college computing georgia institute technology dagon wenke gatech abstract perform host-based intrusion detection constructing model program binary code restricting program execution model improve effectiveness model-based intrusion detection systems incorporating model knowledge environment program runs increasing accuracy models dataflow analysis algorithm context-sensitive recovery static data environment configuration files command-line parameters environment variables constrains acceptable process execution environment dependencies added program model update model current environment program execution static data-flow analysis associates program data flows specific calling contexts data analysis differentiate systemcall arguments flowing distinct call sites program average reachability measure suitable evaluation call-stackbased program models demonstrate techniques improve precision test programs models key words model-based anomaly detection dyck model static binary analysis static data-flow analysis introduction host-based intrusion detection system hids monitors process execution identify potentially malicious behavior model-based anomaly hids behavior-based hids deviations precomputed model expected behavior intrusion attempts execution monitor verifies stream events system calls generated executing process monitor rejects event streams deviating model ability system detect attacks false alarms relies precision model static analysis builds execution model analyzing source binary code program traditionally static analysis algorithms conservative produce models overapproximate correct execution previous statically constructed models allowed execution behaviors execution environment processes read environment configuration files command-line parameters environment variables process load time fixed entire execution process environment significantly constrain process execution disabling entire blocks functionality restricting process access process generate language event sequences current environment previous program models constructed static analysis accepted language eli set environments superset system call sequences generated correct execution environment overly general models fail detect attacks versions openssh secure-shell server prior design error allowed users alter execution root-level login process configuration file setting uselogin disabled ssh server disabled vulnerable code attacker subverted process bypass uselogin checks directly executing vulnerable code previous statically constructed models allowed paths program including disabled path executing disabled code attacker undetectably execute root-level commands paper make statically constructed program models sensitive execution environment environment-sensitive program model restricts process execution behavior behavior correct current environment model accepts limited language event sequences event sequences correctly generated current environment detected intrusive sequences correct environment openssh uselogin disabled model disallows system calls system-call arguments reachable vulnerable code paths model detects entire class evasion attacks manipulate environment data sect environment dependencies characterize execution behavior depends environment values similar def-use relations static data-flow analysis environment dependency relates values environment uselogin values internal program variables environment-sensitive hids loads program model execution enforcement customizes model current environment based dependencies paper manually identify dependencies long-term goal automate procedure sect postulate automated identification onerous task environment sensitivity works system-call argument analysis static analyzer includes powerful data-flow analysis recover statically system-call arguments execution paths program set system-call argument differently previous data-flow analysis recovered argument values calling context analysis algorithm association argument call site set work encode calling context argument values model correct execution behavior program system-call argument observed runtime match calling context leading system call additionally data-flow analysis crosses shared object boundaries enabling static analysis dynamically-linked executables environment-sensitive program modeling primary focus work make additional contribution evaluation metric existing standard metric measuring model precision average branching factor poorly evaluates models monitor program call stack addition system-call stream context-free language reachability move forward stack events discover set actual system calls reachable current program location average reachability measure fairly evaluates precision program models include function call return events average reachability measure demonstrate whole-program data-flow analysis environment-sensitive models test programs improved precision context-sensitive models summary paper makes contributions static model construction dynamically-linked executables static analyzer continues data-flow analysis shared-object boundaries learning api programs call library code sect context-sensitive encoding recovered system-call arguments detailed sect combined whole-program analysis technique improved argument recovery experiments formal definition environment-sensitive program models methods encode environment dependencies statically constructed program models environment sensitivity static system-call argument recovery improved precision program models section presents work extension commonly-used average branching factor metric suitable program models require update events function calls returns sect average reachability measure fairer comparison call-stack-based models models monitor call stack related work fix schneider added execution environment information programming logic make program specifications precise logic program execute allowing precise analysis program proof system notion environment general including properties scheduler behavior proposing similar idea environment information precisely characterize expected program behavior program model models describe safety properties violated focus environment aspects constrain safety properties chinchani instrumented source-code security checks based environment information definition environment primarily encompassed lowlevel properties physical machine process executes knowing number bits integer allowed authors insert code program prevent integer overflows approach specific exploit vectors requires source-code editing making poorly suited environment-sensitive intrusion detection aspect current work environment dependencies static analysis limit allowed values system-call arguments specific problem received prior attention static analysis identify constant statically arguments extracting execution models source code wagner dean identified arguments kernel trapunlink entryunlinklibc unlinkcall call unlink callsite callsite arg home user testfile tmp arg tmp arg home user testfile entryunlinklibc kernel trapunlink unlinkcall unlinkcall arg unknown arg unknown callsite callsite arg home user testfile fig prior static argument recovery argument values recovered execution paths join execution paths converge association specific argument execution path lost argument statically recovered execution path leading system call recovered values discarded argument completely unconstrained statically earlier work binary code analysis recover arguments sparc executables efforts suffered problems earlier binary data-flow analysis required statically-linked executables paper data-flow analysis learn api shared object analyzing executable continue data-flow analysis library api values recovered sensitive calling context forces inaccuracies association system-call argument execution path lost fig attacker undetectably recovered execution path execution path system call execution path set argument recoverable statically values recovered execution paths discarded analysis safe fig current work avoids inaccuracies encoding calling context recovered values static analysis recover values set dynamically paper make distinction dynamic values set load time values set arbitrary user input environment dependencies augment static analysis describe values set operating system loads process flow system-call arguments dynamic analysis learns program model generalizing behavior observed training phase kruegel sekar dynamic analysis learn constraints system-call 
arguments constraints include values environment part system-call argument forces tradeoff training phase modify environment values learn general model model fails constrain execution specific environment conversely training current environment environment model longer characterizes correct execution retraining including environment dependencies paper learning static binary analyzer binary program data flow models summaries environment sensitivemonitoring global model builder environment sensitive program model execution program environment monitor execution system call sequence accept executionreject environment dependencies environment dependencies specification system call static binary analyzer data flow models summaries shared object analysis shared object environment dependencies specification system call static binary analyzer data flow models summaries shared object analysis shared object executable analysis model assembly fig architecture arguments dependent environment environment dependencies resolve remaining arguments current environment time model subsequently loaded environment-sensitive models suited model-carrying code execution design sekar proposed unknown untrusted executables include models execution consumer executable model checker verify model violate security policy execution monitor limit program execution allowed model code producer build program model consumer specific execution environment avoid false alarms model general suit environments general model satisfy consumer security policy code producer adds environment dependencies model shipped code model automatically adapt consumer unique environment environment constraints model increasingly satisfy consumer security policy overview model-based anomaly detection phases construction program model execution enforcement model environment sensitivity affects phases figure shows architecture system including environment information phase analysis left occurs program shared object global model builder assembles execution models single wholeprogram model panel execution monitoring occurs time program loaded execution static analyzer builds model expected execution reconstructing analyzing control flows binary executable control flow model construct dyck model context-sensitive model finite-state machine enforce ordering system-call events correct function call return behavior static analyzer encodes environment dependencies dyck model void parse args int argc char argv char tempnam getenv tmp int execmode char unlink home user tmpfile getopt argc argv switch case execmode unlink link optarg break execmode exec sbin mail fig code calls library systemcall wrapper functions boldface analyze sparc binary code show source code readability conciseness omit error-handling code commonly required calling library functions sbin mail exec link unlink unlink fig finite-state machine model code system calls include argument restrictions identified static data-flow analysis environment dependencies describe relationship execution environment variable program detailed sect separate process runtime monitor process execution matches program model monitor resolves environment dependencies dyck model actual environment process execute parsing program command line configuration files system environment variables monitor execution environment operating system loads program prunes portions model code unreachable current environment determining directions branches dependent environment similarly propagates environment values dependencies update system-call argument constraints monitored process begins execution model execution verification enforces restrictions arising environment dependencies function fig figure shows source code readability analyze sparc binary code experiments code environment information ways similar real programs getenv call line returns environment variable tmp typically specifies system directory temporary files returned directory tempnam call construct filename temporary directory filename link unlink system calls lines getopt function call line parses options passed program command line sets library global variableoptarg option requires argument optarg passed argument link line command line option case statement line execute exec line execute present opposite holds exec execute code inside case statement skipped figure shows finite-state machine model constructed parse args earlier static analysis methods model overapproximates correct execution function argument unlink calls unconstrained attacker undetectably delete file directory process holds write access arguments statically recovered unlink line depends dynamic environment variable tmp unlink calls target library system-call wrapper function data-flow analysis system-call argument join values propagating call sites fig joining statically recovered line unknown line forces analyzer discard arguments link unconstrained computed dynamically execution environment system calls inside case statement exec system call accepted calls accepted branch correlation forces case statement exec execute lost glance exec call appears safe static analysis constrain argument due overapproximations model model accepts sequence system calls execute shell process attack issues nop call relinks statically recovered filename shell exec call occurs unlink null nop call unlink sbin mail link bin sbin mail exec sbin mail note attack requires initial nop call link transition model preceded unlink transitions environment sensitivity static argument analysis presented paper repair imprecisions produce program model represents correct execution context-sensitive encoding system-call arguments differentiate values passed unique call sites unlink system-call wrapper enabling recovery static argument line call site recovering argument line adding environment dependencies produces environmentsensitive model shown fig model template dependencies resolved execution monitor monitor instantiates template model current environment suppose environment variable tmp set tmp command line unreachable case statement code removed fig command line home user log monitor prune unreachable exec call constrain values remaining system-call arguments fig model reflects correct execution specific environment cases model prevents relinking attack previously home user tmpfile unlink sbin mail exec tmp link tmp unlink fig environment-sensitive model produced static analyzer model template environment dependencies resolved model loaded symbols branch predicates subsequent system calls command-line parameter omitted present parameter command line tmp tmp environment variable home user tmpfile unlink sbin mail exec link home user log tmp home user tmpfile unlink tmp unlink fig environment-sensitive model execution monitor resolved environment dependencies system-call arguments encoded calling context calls unlink enforce arguments string arguments regular expressions command line code processing option pruned model present exec call unreachable pruned system-call argument analysis analyzer attempts recover system-call arguments statically analyzes data flows program code shared object code determine arguments constrained execution monitor enforces restrictions recovered system-call arguments rejects system call attempts incorrect argument values learning library api object code program linked distinct times static linking occurs part compilation process combines object code form single program shared object file runtime linking time program loaded execution links code separate shared objects main executable static analyzers inspect object code static linking final runtime link analyzer simulates effects runtime link build models programs code distributed shared object files model construction primary steps analyze shared objects program build models program code shared object cache models disk future reuse program models include virtual memory addresses kernel traps function call sites addresses shared object code runtime linking occurs analyzer 
performs symbolic relocation shared object code shared object virtual address space indexed strictly symbolic addresses models reside symbolic address space enforcing program model execution monitor detects actual address runtime linker maps shared object code resolves symbolic addresses actual virtual addresses analyze binary executable interest executable call functions exist shared object code analyzer simulates runtime linker symbol resolution identify code body targeted dynamic function call reads cached model shared object code disk incorporates program execution model separate code analysis performed shared object main executable complicates data-flow analysis system-call argument recovery system calls generally library functions frequently argument values system calls set main executable passed library function library api separate analysis library code main executable code precludes previous static data-flow analysis recovering arguments data flow broken library interface remedy problem perform whole-program data-flow analysis track data flowing separate statically linked object files analyzer learns api shared object initiates data-flow analysis system-call sites type information call arguments integer argument string argument data-flow analysis program control flows reverse find instructions affect argument values depends formal argument globally visible function function part api affects system-call arguments cache data-flow summary function characterizes data flows api function entry point system-call site shared object summary function library stipulates argument function call unlink flows argument subsequent unlink system call analyzing object file utilizes learned api continue dataflow analysis calls api analyzer attempts statically recover passed api call composing cached data-flow summary function data dependencies api call site discovered object code analysis recover argument system call inside library context-sensitive argument recovery static argument recovery data-flow analysis identify system-call values statically analysis recovers arguments finite-height lattice values algebra defines combine values lattice lattice bottom element argument argument analyzed top element general means argument determined statically argument values reach system call multiple execution paths shown fig algebra lattice defines compute flow converged execution path join operator combines values previous static argument analysis recovered arguments standard powerset lattice finite set statically strings integers program lattice values elements algebra joined arguments set union lattice values reaching system-call site recovered argument joins lattice diminish precision analysis set union maintain association argument execution path result attacker undetectably recovered path execution path reaching system call suppose program opens temporary file write privileges critical file read-only access argument recovery identify arguments calling context lost attacker write privilege temporary-file open open critical file write privilege worse effect values recovered statically argument identified execution path takes point converging execution entry point library function join recovered discards recovered makes intuitive sense monitoring execution monitor determine recovered enforced knowing calling context solve imprecision extending lattice domain include calling context data-flow analysis annotates recovered string integer values address call site passes strings integers argument stated differently recover values separate powerset lattice calling context data propagates call instruction analyzer annotates return address call found single call site context sufficiently distinguish argument values analysis extended include additional calling context note call site annotation call site nearest system call originating call site argument set originating call site target function program including library calls arbitrary wrapper functions library functions data values recovered data-flow analysis pairs set integers strings calling context information definition powerset lattice set statically-known strings integers program defined call site identifiers special identifier indicating context information context-sensitive data-flow lattice defined domain uniontextni entryunlinklibc kernel trapunlink unlinkcallunlinkcall callsite arg unknown callsite callsite callsite callsite arg home user testfile arg home user testfile fig static argument recovery contextsensitive argument values home user log unlink unlink link sbin mail exec fig model program code fig context-sensitive argument values note argument constrained top-most unlink transition argument unlink call site statically determined define join operator negationslash negationslash join operation maintains calling context information points execution path convergence part joins values powerset lattice values identical calling context part maintains correctness joining context occur previously-identified context lattice improves prior data-flow analysis important ways convergence context-sensitive unrecovered nondestructive analyzer continue propagate execution context fig figure shows model code contextsensitive arguments statically filename passed call unlink call site fig constrains call intuitively discard recovered context-sensitive monitor runtime compare context information executing process call stack determine argument restriction enforced multiple context-sensitive values converge information lost distinct calling contexts remain distinct preserving context enforce association multiple arguments passed system call call site recall previous opening temporary file critical file access privileges analysis annotate filename access mode call site site calling context attacker open critical file read-only access monitor enforces argument restriction execution path system call call-site address annotating argument monitor walks call stack process system call identify calling context system call call-site address annotates exists calling context monitor enforces argument restriction argument recovered context monitor constrain allowed values runtime environment-sensitive models environment-sensitive intrusion detection restricts allowed process execution based fixed data execution environment environment-sensitive program models include data directly encode dependencies environment data evaluated immediately process begins execution formalize notions environment properties dependencies environment program definition environment program input process load time fixed entire execution process includes environment variables command-line parameters configuration file contents definition excludes environment variables altered overwritten execution measurements programs installed solaris modify environment variable definition property environment single variable parameter configuration setting file property present omitted environment present environment dependency captures relation environment properties program execution behavior definition set environments property set non-environment program inputs alue denote possiblyinfinite set values program point read data location environment program input environment dependency exists dbracketleftbig bracketrightbig words executions program data depends function characterizes data depends environment property definition intuitively similar definition def-use relation programming language analysis environment defines data executing process existing program analyses examine relations instructions program extend notion definition environment dependencies interest affect program behavior visible execution monitor focus classes dependencies present code fig control-flow dependencies exist program branches branch direction depends environment property data-flow dependencies occur visible data system-call argument dependent environment environment property flows system-call argument home user tmpfile unlink sbin mail exec link unlink fig dyck model environment branch dependencies symbols branch predicates subsequent system calls command-line parameter omitted present control-flow dependencies control-flow dependencies restrict allowed execution paths based values environment variable tested program branch dependent environment property statement line 
guards exec call executes omitted command line program data variable branch test dependent definition consequence branch direction depends similarly theswitchstatement line environment control-flow dependency execute case line present static analyzer encode control-flow dependencies dyck model predicate transitions figure shows model fig predicate transitions characterizing environment dependency predicatel-is satisfied command line likewise satisfied present execution monitor evaluates predicate transitions loading model program execute predicates satisfied environment -transitions -transition transparent events transition conversely monitor deletes edges predicates satisfied environment legitimate process execution follow path command line passed code fig transition fig subsequent exec transition removed prevent model accepting unlink link calls data-flow dependencies system-call argument values depend environment properties programs frequently environment values computing strings passed system calls filenames values significantly restrict allowed access process attacker subverted process code fig environment variabletmpgives system temporary directory prefix filename argument lines property constrains unlink line files remove temporary files parameter command-line property fully defines filename passed argument link real-world programs exhibit similar behavior apache web server command-line property server root directory environment data-flow dependencies augment existing system-call arguments recovered techniques sect figure adds argument dependencies previous model fig bracketed environment property argument simply template instantiated actual property program load time figure completed environment-sensitive dyck model context-sensitive argument encoding program fig loaded execution monitor reads current environment instantiates model environment template argument values replaced actual values environment properties argument depends final instantiated models fig sect dependency identification paper aims demonstrate environment-sensitive intrusion detection problem automated dependency identification assume environment dependencies precomputed manually experiments manually identified environment dependencies iterative model refinement high-level process parallels counterexample-guided abstraction refinement software model checking dyck model abstraction defining correct execution iteratively refine model environment dependencies improve abstraction monitored process execution collected trace reachable potentially malicious system calls sect trace included calling context potentially malicious call occurred inspected program code determine argument passed call-site calling context depended environment information reached system call branch guarded call-sites branch predicate depended environment function-call arguments branch predicates depend environment backward slice reaches function read environment getenv getopt added dependency dyck model repeated iteration practice number dependencies added iterative refinement small program experiments contained dependencies manual specification drawbacks requires user understand lowlevel process execution behavior dyck model characteristics manual work errorprose miss dependencies obscured control-flows difficult comprehend dependency identification limited manual specification postulate automated techniques identify environment dependencies direction analyst feasible summary functions library calls read environment enable existing static data-flow analysis automatically construct environment-dependent execution constraints complex dependencies learned dynamic analysis dynamic trace analyzer correlate environment properties features execution trace produce dependencies paper makes clear benefits model specialization based environment dependencies improvements noted sect motivate implementation techniques automatically identify dependencies expect future work address implementation issues average reachability measure measurements model precision ability prevent attacks benefits analyses model construction techniques previous papers measured model precision average branching factor metric metric computes average opportunity attacker subverted process execution undetectably execute malicious system call processing system call monitor inspects program model determine set calls accept potentially malicious system calls set unlink unconstrained argument contribute branching factor current monitor configuration average counts entire execution monitor average branching factor model lower numbers precision opportunity undetectably insert malicious call set potentially malicious system calls originally defined wagner remained constant subsequent work average branching factor average branching factor poorly evaluates context-sensitive program models stack update events dyck model paper typical programs characteristics limit suitability average branching factor programs function calls returns system calls number stack update events processed monitor greater number actual system-call events programs rarely execute system-call trap directly programs indirectly invoke system calls calling library functions characteristics important implications stream events observed monitor structure dyck model characteristic implies stack updates dominate event stream characteristic implies configuration monitor set events accepted predominantly safe stack update events contribute configuration branching factor fact potentially malicious system call visible event process execution path entered library function monitor processed stack event function call number potentially malicious system calls visible monitor decreases artificially skewing computed average table test programs workloads instruction counts instruction counts include instructions shared objects program program workload instruction count procmail filter message local mailbox mailx send mode send ascii message receive mode check local mailbox gzip compress ascii text cat write ascii text file branching factor downward call-stack-based model precise average branching factor makes extended average branching factor correctly evaluates contextsensitive models stack update events skew results average reachability measure context-free language reachability identify set actual system calls reachable current configuration monitor simply inspecting events monitor accept average reachability measure walks forward stack events reaching actual system calls forward inspection respects call-and-return semantics stack events limit reachable set system calls monitor operation eventually reach actual system-call event recalculate set reachable system calls count number potentially malicious sum counts divided number system calls generated process average reachability measure average reachability measure subsumes average branching factor metrics identical meaning context-insensitive models context-sensitive models stack events wagner dean abstract stack model compute model types average reachability measures call-stack-based models directly compared measures models allowing understanding differences model types implemented average reachability measure thepost algorithm push-down systems pds research converted dyck model pds ruleset generated post queries system call post algorithm wagner dean operate abstract stack model note expensive post algorithm evaluation purposes monitor verifies event streams efficient dyck model experimental results evaluated precision environment-sensitive program models average reachability precise model closely represents program constructed offers adversary ability execute attacks undetected models utilizing environment sensitivity argument analysis show improvement previous techniques test programs static argument recovery improved precision adding environment sensitivity models increased gains end arguing model-based procmail mailx send mailx receive gzip cat model precision dyck model prior data-flow analysis data-flow analysis environment-sensitive fig precision program models increasing sensitivity data-flows environment y-axis precision average reachability measure average number reachable potentially malicious system calls lower numbers greater precision opportunity attack programs bars bars show graph intrusion detection systems ignore environment information leave susceptible evasion attacks test programs measured model precision unix programs table shows workloads instruction counts programs tested note instruction counts include instructions shared objects program depends procmail additionally code shared objects loaded explicitly 
program dlopen static analyzer identify libraries loaded dlopen manually added dependencies program programs static analyzer runtime monitor run solaris sparc monitor executes separate process traces process execution solaris procfile system generate stack events dyck model monitor walks call stack process system call feng design full execution environment traced process visible monitor environment passed monitor monitor forks executes traced process environment environment-sensitive model effects static argument analysis average reachability evaluate models constructed test programs compared versions dyck model varying degrees static data-flow analysis fig report sets results mailx major modes execution sending receiving mail produce significantly execution behavior programs modes compressing decompressing data gzip exhibit notable precision measurements table environment dependencies test programs manually identified dependencies inspection source code object code program environment dependencies procmail program branching depends command-line argument program branching depends command-line argument filename opened depends user home directory mailx program branching depends command-line argument program branching depends command-line argument program branching depends command-line argument filename created depends parameter command-line argument filename opened depends tmp environment variable filename opened depends user home directory filename unlinked depends tmp environment variable gzip argument chown depends filename command line argument chmod depends filename command line filename unlinked depends filename command line cat filename opened depends filename command-line dyck model data-flow analysis system-call argument recovery overlap current test programs test programs previously dyck model reiterate results computed average reachability measure comparable average branching factor numbers previously reported dyck model current results compared previous average branching factor numbers non-stack-based models added system-call argument constraints dyck model constraints recovered previously reported analysis technique arguments values recovered recovered execution paths reaching system call execution path identified statically entire argument unknown dataflows cross shared object program considered unknown limited data-flow analysis improved model precision enabled static data-flow analyses sect argument analysis improved precision effects environment sensitivity made models environment sensitive program manually identified execution characteristics depended environment properties stated formally defined functions definition describe data-flows environment property program variable system-call argument branch condition table lists dependencies added dyck model program system-call argument dependencies augmented values recovered static data-flow analyses presented sect immediately execution monitor instantiates model current environment resolving dependencies procmail mailx send mailx receive gzip cat percent constrained dyck model prior data-flow analysis data-flow analysis environment-sensitive fig percentage potentially malicious system calls identified average reachability measure made safe constraints arguments dyck model data-flow analysis constrained arguments figure reports average reachability measure program execution monitored environment-sensitive models model precision improved procmail gzip cat gzip cat average reachability measures indicating adversary opportunity undetectably insert malicious system call point process execution successful argument recovery constrains system calls attacker longer calls malicious manner evaluated ability techniques constrain system calls figure shows percentage potentially malicious system calls discovered computation average reachability measure restricted system call argument analysis environment-sensitivity figure higher bars represent improved constraints system calls produced correspondingly lower bars previously shown fig programs mailx gzip cat environment-sensitive models constrained potentially dangerous calls expect environment-sensitive program models affect performance runtime execution monitoring monitor update program model load time remove paths unreachable current environment enforce contextsensitive argument restrictions system call table shows execution time overhead arising model update precise enforcement overheads modest one-half short-lived processes procmail mailxand seconds longer-runningcat overheads forprocmail mailx high viewed percentage original runtime occurs due short lifetime processes monitor upfront fixed cost pruning unreachable paths longer-lived processes cat give indication relative cost improved argument recovery increase size program models model additional constraints programs environmentsensitive models required pages memory dyck model argument recovery environment-sensitivity table performance overheads due execution enforcement environment-sensitive models model update one-time cost pruning model execution paths allowed current environment enforcement times include program execution verification system call executed program model program model update environment-sensitive overheadno enforcement model update enforcement total procmail mailx send mailx receive gzip cat results strongly endorse proposed environment-sensitive intrusion detection precision measurements demonstrate analysis tools program execution safely constrained point attackers ability undetectably execute attacks operating system vulnerable program constrain execution models enforce iteration counts loops verify data read written files strongly limit process execution adversely affect underlying operating system processes executing simultaneously evasion attacks intrusion detection systems environment-sensitive susceptible evasion attacks attacks mimic correct process execution environment current environment demonstrate effectiveness environment sensitivity defense attacks designed attack mailx overwrites command-line arguments stored process address space change process execution original command line passed program directed check mail exit attack environment data mailx reads sensitive information sends unwanted attack makes buffer overrun vulnerability whenmailxunsafely copies string thehomeenvironment variable assume attacker alter home variable possibly monitor resolves environment dependencies attacker variable home code inject mailx exploit typical nop sled payload address pattern part consists sequence nops sled exceeds static buffer size instruction sequence obtain current address stack payload rewrites command-line arguments memory change command-line arguments alters execution process perform operation sending spam leaking information return address end payload selected reenter getopt command-line arguments update state variables evasive exploit alter reentry point additional system calls stack frames occur overflow resumed flow attack reentering getopt sufficient implemented mailx exploit loaded home caused program read arbitrary files send unwanted exploit introduce additional system calls reentered original execution path attack perfectly mimicked normal execution environment exception caused register windows sparc architecture effectively manipulate return address exploit code return callee function corrupting stack double return makes exploit detection slightly easier sparc machines exploit attempts reenter function alters return addresses detectable attack limitation present common architecture environment-sensitive models detect evasion attacks monitor resolves environment dependencies process execution begins attack alters environment data execution paths mailx subsequent attack reading sensitive files sending match expected paths command-line input conclusions program models model-based intrusion detection benefit analyses static argument recovery reduces attack opportunities significantly prior argument analysis approaches adding environment sensitivity continues strengthen program models adding environment features models usefulness model-construction techniques shown results models severely constrain test programs execution acknowledgments anonymous reviewers members wisa project wisconsin helpful comments improved quality paper jonathon giffin partially supported cisco systems distinguished graduate fellowship somesh jha partially supported nsf career grant cnsthis work supported part office naval research grant nsf grant ccrthe government authorized reproduce 
distribute reprints governmental purposes notwithstanding copyright notices affixed hereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government chinchani iyer jayaraman upadhyaya archerr runtime environment driven program safety european symposium research computer security sophia antipolis france sept clarke grumberg jha veith counterexample-guided abstraction refinement computer aided verification chicago july debar dacier wespi taxonomy intrusion-detection systems computer networks esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems computer aided verification chicago july feng giffin huang jha lee miller formalizing sensitivity static analysis intrusion detection ieee symposium security privacy oakland feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland fix schneider reasoning programs exploiting environment international colloquium automata languages programming jerusalem israel july gao reiter song gray-box program tracking anomaly detection usenix security symposium san diego aug giffin jha miller detecting manipulated remote call streams usenix security symposium san francisco aug giffin jha miller efficient context-sensitive intrusion detection network distributed systems security symposium san diego feb httpd solaris manual pages chapter feb koziol litchfield aitel anley eren mehta hassell shellcoder handbook discovering exploiting security holes wiley kruegel mutz valeur vigna detection anomalous system call arguments european symposium research computer security pages vik norway oct lam chiueh automatic extraction accurate application-specific sandboxing policy recent advances intrusion detection sophia antipolis france sept muchnick advanced compiler design implementation morgan kaufmann publishers san francisco sekar venkatakrishnan basu bhatkar duvarney model-carrying code practical approach safe execution untrusted applications acm symposium operating system principles bolton landing oct sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding noordwijkerhout netherlands october department energy computer incident advisory capability openssh uselogin privilege elevation vulnerability dec wagner dean intrusion detection static analysis ieee symposium security privacy oakland wagner soto mimicry attacks host based intrusion detection systems acm conference computer communications security washington nov wagner static analysis computer security techniques software assurance phd dissertation california berkeley fall yannakakis graph-theoretic methods database theory acm symposium principles database systems nashville apr 
problem diagnosis large-scale computing environments alexander mirgorodskiy vmware naoya maruyama department mathematical computing sciences tokyo institute technology barton miller computer sciences department wisconsin abstract describe approach locating anomalies distributed systems target environment distributed application multiple identical processes performing similar activities lightweight form dynamic instrumentation collect function-level traces process application fails traces automatically compared find anomaliesby identifying processesthat stopped earlier rest sign fail-stop problem processes behaved rest sign non-fail-stop problem algorithm require data distinguish anomalies normal behaviors make data reduce number false positives ultimately identify function explain anomalous behavior demonstrated efficacy approach finding problems large distributed cluster environment called score introduction finding root bugs performance problems high-performance computing commerce environments difficult task main reasons difficulty distributed concurrent nature systems analyzing execution multiple interacting threads work performed author student wisconsin mirg wisc naoya maruyama titech bart wisc permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee november tampa florida usa ieee processes significantly harder sequential execution concurrent system events happen order runs concurrent systems suffer bugs present sequential software bugs deadlocks race conditions notorious hard track finally non-interactive nature system components complicates error detection silent failure process hosts remain unnoticed time simplify tasks problem detection root analysis large distributed environments automate extent envision programmer analyst autonomous agent tool locate problem analyst injects agent code running system agent starts monitoring processes interest collects run-time execution data identifies anomaliesin data potentially correspondto abnormal behavior makes results analyst investigation previous work presented selfpropelled instrumentation enables creation agents obtain execution traces running program low overhead modifying program source code paper builds foundation provide solutions locating problems distributed highperformance computing environments achieve goal extended techniques collect traces multiple processes multiple hosts key challengein approach proved analyzing large sets data collected hosts primary contribution paper lies collection techniques finding anomalies automated analysis collected data analyses apply identification failures distributed collection identical processes perform similar comparable activities environments property cluster management tools web server farms parallel numeric codes assumed similarity behaviors find processes substantially regard processes potential anomalies require investigation approach generalized support collections processes grouping identical processes performing analyses group locate root bugs distributed application three-step process collect control-flow traces chosen application fails section describes faults manifested unusual control flows collect traces current prototype injects tracing agent process application agents record function calls returns made application processes hosts section perform data categorization identify process small group processes failed section finding processes non-trivial task presence silent non-fail-stop failures step techniques simplest case identify anomalousprocesseswith fail-stop behavior process stopped generating trace records complex case identify anomalous processes non-fail-stop behavior distance-based outlier detection approach compare per-process traces automatically identify substantially algorithm work prior knowledge correct incorrect behaviors simply unusual activities examples previously investigated behaviors incorporate knowledge analysis improved accuracy finally perform root identification section determine anomalous processes behaved differently step automatically locate symptom problem symptom corresponds key difference behavior anomalous process similar normal process describe techniques analyst transition knowing symptom finding root problem projects propose techniques automated anomaly detection magpie pinpoint work dickinson yuan similar work approaches perform similar steps collect run-timedata traceorprofile form analyze identify anomalies possibly explain anomaly discussed section key strength approach meets properties easy deployment production environments self-propelled instrumentation ability integrate prior knowledge analysis fine-grained localization problem level individual function applied prototype solution identification faults largeproduction environment running distributed job scheduler called score months deployment framework public computational cluster tokyo institute technology witnessed failures scheduler successfully located trace examination results suggest combination autonomous instrumentation statistical trace analysis promising approach localizing faults complex distributed systems fault model differences control flow processes find important classes problems problems bugs performance problems problem identify failed process function failure happened non-deterministic fail-stop failures process distributed system crashes freezes control-flowtrace stop prematurely processes continue running approach identify process anomaly identify function entered crash location failure infinite loops process crash enters infinite loop start spending unusual amount time function region code approach identify process find function spends time deadlock livelock starvation problems small number processes deadlock stop generating trace records making traces processes function similarly process waits shared resource indefinitely processes requests granted spend time parts code identify starving process function process blocking spinning point location failure load imbalance uneven load main performance problems parallel applications comparingthe time spent function application nodes approach identify node receives unusually work functions node spends unusually time analyst find problem note severaltypes problems detected approach find massive failures problem nodes system approach normal behavior fortunately problems typically easier debug anomalies detect problems change control flow application fails input executes instructions normal run locate root problem experience problems uncommon locate problem occur long failure retain fixed number recent trace entries future limitation addressed performing analysis online saving older traces disk discarding data collection collect control-flow traces application self-propelled instrumentation application starts inject small autonomous fragment code called agent address space inject agent compile shared library hijack mechanism application load library agent modifies application binary code insert trace statements function call sites activity performed incrementally functions instrumented flow control reaches time executed trace statement generates timestamped in-memory log record function entry exit application process running hosts inject copy agent process copies communicate collect per-host traces independently copies controlled single coordinator process watches deactivation event application node crash user-specified exceptional condition deactivation event coordinator saves per-host traces disk make analysis retain in-memory trace data sudden application crash put trace buffer shared-memory segment segment mapped application process helper tool application process dies segment left helper tool save contents disk technique protect data crash operating system hardware failure surviving application crashes typically frequent whole-node crashes note tools shared-memory segment fast accesses performance data external process knowledge sptraceris tool technique achieving trace durability size trace depends activities traced application extreme end single process make hundred million calls empty function modern hardware high rates infrequent practice function call traces grow large consume substantial amounts memory adversely affect execution processes system limit perturbation restrict size trace buffer organize circular reaching 
end buffer agent starts adding trace records beginning technique retains recent events occurred crash experiments traced job management daemons scored score distributed environment ten-megabyte trace buffer sufficient capturing minutes normal execution daemon run-time impact tracing daemons execution user jobs proved negligible end-to-end slowdown applications npb suite daemons traced data analysis finding misbehaving host traces obtained saved local disks gathered central location start analyzing step analysis find misbehaving host purpose techniques identification node stopped generating traces identification traces similar rest technique locates hosts fail-stop problems focuses non-fail-stop problems note techniques external faultdetection mechanism locate misbehaving host traces external fault detectors typically symptoms network timeouts node crashes contrast approach find silent failures failures symptoms earliest timestamp simple technique finding failed host identify host stopped generating trace records trace record earliest timestamp reported analyst anomaly general technique effective detecting fail-stop problems application crashes indefinite blocking system calls proved work experimental studies compare timestamps hosts convert absolute time assuming system clocks hosts synchronized compute standard deviation timestamps hosts earliest timestamp substantially delta exceeds attainable clock synchronization precision assume fail-stop scenario report host earliest timestamp analyst assume problem non-fail-stop property problems performance degradations livelocks starvation infinite loops code harder debug fail-stop crashes locate technique finding behavioral outliers find anomalous hosts exhibit non-fail-stop behavior identify outlier traces individual traces small collections traces rest identify traces distance-based outlier detection approach define pair-wise distance metric estimates dissimilarity traces construct suspect score estimates dissimilarity trace collection traces normal suspect score rank trace traces highest rank interest analyst correspond hosts behavior normal note outliers correspond true anomalies unusual normal behavior master node master-worker mpi application behave substantially worker nodes workers perform units work master distributes units workers approaches outliers flag normal behavior master anomaly eliminate false positives approach utilizes data known-correct previous runs previouscorrectrun contained trace similar mpi master node current run master flagged outlier analyses provide uniform framework handle case data failed execution unsupervised case data known-correct previous run one-class ranking case pair-wise distance metric define distance traces hosts two-step process similar dickinson construct per-trace function profiles serve summary behaviors trace define distance metric profiles profile host vector length total number functions application parenleftbiggt parenrightbigg ith component vector corresponds function represents time spent function fraction total run time application summationtextfi note unlike count profiles dickinson time profiles experience time profiles detect wider range behavioral problems application blocked indefinitely system call anomaly immediately visible time profile count profile time profiles natural match detecting performance problems treat call paths function separate functions definition profile seamlessly include call path profiles assume execution trace paths function denotes call paths functions time attributed equal time spent called called time equal time spent called called algorithms presented figure geometric meaning profiles data points correspond hosts profile vectors coordinates points determined relative contributions functions total time host difference vector independent type profile refer components profile vectors functions simplicity presentation section presents experimental results path-based method profile vector defines data point f-dimensional space ith coordinate time spent function fraction total time figure shows geometric interpretation profiles application functions host profile representing fact spent time host profile distance traces defined manhattan length component-wise difference vector experiments euclidean metric showed similar results fsummationdisplay behave similarly function consume similar amounts time hosts points close distance low advantage computing distances profiles raw traces profiles sensitive insignificantvariationsinbehaviorbetween hosts activity occurring hosts times make traces significantly profiles remain main disadvantage profiles disregard subtle real symptoms problem experience failure occurs behavior host typically substantially change visible profile suspect scores trace ranking goal compute suspect score trace traces largest scores primary interest analyst probable anomalies present algorithms computing scores algorithm applies unsupervised case trace data failed execution algorithm applies one-class classifier case additionaldatafroma known-correctpreviousrun additional data identify anomalies higher accuracy algorithms based computational structure unsupervised case operate set traces collected failed run assume consists types common behaviors small number outliers ramaswamy detected outliers ranking data point distance kth nearest neighbor idea compute suspect scores unsupervised case extend handle one-class classified case determine good evaluated sensitivity algorithm data sets expected values total number outliers data sets anomalies produced false negatives ranking anomalous traces normal high values potentially produce false positives ranking normal traces anomalies cases data sets algorithm worked larger number traces cost false positive analyst examination additional normal trace significantly lower false negative overlooking true anomaly adopted conservative trace unsupervised case construct sequence traces ordering traces distance angbracketleftbigh angbracketrightbig suspect score trace defined distance kth nearest neighbor trace considered normal low suspect score anomaly high suspect score informally defined equation quantify dissimilarity nearest common behavior ctrialtrace set traces legend similar figure unsupervised case computing suspect scores anomalous trace normal trace large collection traces similar behaviors ith trial neighbors normal neighbor common behaviors normal parameter determines common behavior trace close neighbors receive low suspect score considered normal figure shows examples illustrate algorithmwhenk traceh partofa largesetc representing common behaviors large number close neighbors result kth neighbor close suspect score low considered normal trace contrast trace outlier common behavior close neighbor result kth neighbor suspect score high considered anomaly cases unsupervised algorithm produces desired results reports high suspect score outlier low suspect score common behavior outliers correspond unusual normal behavior interest analyst present modified version algorithm eliminate outliers consideration additional traces known-correct previous run add set normal traces analysis common behaviors outliers outliers correspond normal activities result outlier close outlier correspond normal behavior marked anomaly identify true anomalies traces large collection traces trace compute suspect scores similar sequence defined equation sequence arrangesall traces order distance trial trace set similar traces normal trace legend figure one-class case computing suspect scores normal unusual closest normal neighbor suspect score defined distance kth neighbor neighbor whichever closer min figure shows examples illustrate idea similar figure trace considered normal part large collection trial traces trace outlier common behavior close trial neighbor normal trace nearby suspect score low considered normal note one-class approach benefit examples prior faulty behaviors data eliminate generic symptoms anomalies common unrelated problems symptoms specific problem identifying analyst locate actual problem treating examples previous unrelated failures normal behavior one-class algorithm eliminate 
generic symptoms identify symptoms unique problem hand data analysis finding anomaly anomalous trace found provide severaltechniquesforlocating afunction problem define concepts section steps problem evolution step occurrence fault referred root problem step fault sequence program state referred errors finally state system fail crash hang stop providing service refer event failure trace entry simple technique identifying function caused found host behave abnormally examine entry host trace technique viewed natural extension earliest timestamp approach section identify host stopped generating trace records function executed host function failure technique effective identifying crashes freezes work non-fail-stop problems maximum component delta vector locate symptoms nonfail-stop problems developed approach natural extension outlier-finding approaches section locating outlier traces identify symptoms led declare traces outliers specifically find function unusual behavior largest contribution suspect score outlier trace recall equations suspect score trace equal distance trace kth trial neighbor known-normal neighbor turn distance length delta vector component corresponds contribution function distance finding maximum absolute identify function largest difference behavior anomfn argmax technique workedwell experiments outlier-finding approaches accurately identify anomalous traces examination maximum component delta vector explained decisions located anomalies anomalous time interval note approach identifies location failure necessarily root problem function corrupted memory caused function enter infinite loop locate remain undetected analyst transition failure fault extended analysis identify moment behavior anomalous host started deviating norm partition traces hosts normal anomalous short fragments equal duration apply outlier detection algorithm fragments complete traces identify earliest fragment anomalous host marked top outlier knowing time interval change behavior occurred additional diagnostic precision experimental results evaluate effectiveness techniques sptracer prototype locate bugs large production environment running distributed cluster management system called score installation score public computational cluster suffered occasional failures varying symptoms describe key features score show sptracer collect analyze traces environment overview score scoreisa ment clusters workstations score facilities include distributed job scheduling job checkpointing parallel process migration distributed shared memory infrastructure implemented large code base lines code source files typical score usage scenario user submits job central scheduler score finds number compute nodes schedules job nodes job runs scored daemons node monitor status job processes executing node finally job terminates score releases acquired nodes detect hardware software failures cluster nodes exchange periodic keep-alive patrol messages scored processes special process called watch connected uni-directional ring process ring receives patrol message neighbor forwards message neighbor watch process monitors patrol messages receive message time period ten minutes default assumes node ring hasfailedand attemptsto killandrestartallscored processes note patrol mechanism watch identify faulty node failure watch node failed months monitoring public installation score -node computational cluster tokyoinstitute technology witnessed failures investigate failures applied sptracer collect function-level traces scored processes node cluster scored process starts inject tracer agent address space starts collecting records function calls returns made scored watch times waiting patrol message sptracer saves accumulated trace buffers disk analyze collected data locate failed nodes identify anomaly network stability problem network link stability problem exhibited symptoms system stopped scheduling jobs watch detected failure ten minutes restarted scored management daemons nodes errors failure happened multiple times months making important find earliest timestamp approach section determined failure exhibited clear fail-stop behavior identified host stopped generating trace records seconds earlier host cluster examined trace entry host found scored terminated voluntarily calling score panic function eventually issuing exit system call find caller score panic due fixed-size trace buffer entire buffer preceding score panic filled calls myri kissendstable evicting common caller myri kissendstableand score panic buffer future versions tracer address limitation maintaining call stack recent trace record reconstructing call stacks earlier records problem hand source code find myri kissendstableand score panic werecalled freeze sending finding suggests scored waited in-flight messages host myrinetnic node names suspect score node figure suspect scores scbcast problem condition occur numerous checks scored aborted calling exit reported results analyses score developers feedback confirmed findings observed symptoms ethernetbased networks report showed similar problem exists myrinet networks scbcast problem problem occurred score component called scbcast stopped responding requests scored scbcast broadcasting service score runs supervisor node aggregates monitoring information produced scored client programs connect retrieve information contacting individual scoreds directly technique eliminates load scored processes introduces additional point failure execution scbcast process stopped responding incoming requests entire score system stopped functioning describe sptracer establish scbcast failure decided problem exhibit fail-stop behavior maximum difference timestamps seconds earliest host terminated earlier earliest identified problem fail-stop path-based ranking algorithms results shown figure point x-coordinate corresponds node y-coordinate suspect score suspect score node substantiallyhigher nodes making candidate detailed examination obtain figure traces failed run added traces previous runs traces previous faulty runs unrelated symptoms proved asthey allowedusto eliminate asecondnode anomalous behavior response type problem point specific problem contrast behavior executions algorithm explained behavior identifying path output job status score write short score write libc write largest contribution node suspect score minutes execution scored spent minutes executing libc write path visualizing trace jumpshot tool found scored entered score write started calling libc write loop returning score write result watch received patrol message minutes killed scored processes restart true anomaly outlieridentification approaches locate maximum-component approach found correct symptom inspecting tracesmanually required substantial effort examination source code revealed scoredwasblockingwhile write alog message socket connected scbcast process trace behavior occur scbcast froze stopped reading socket scored nodes output sufficient number log messages blocked fact scored prepared handle failures points bug code reported bug fixed future release score related work debugging parallel distributed applications active area research decades survey approaches perform analysis automatically work dickinson yuan pinpoint magpie similar work approaches collect run-time information data mining techniques simplify debugging complex software unlike data collection approaches require static instrumentation dynamic activated deactivated time works unmodified applications note dynamic approach applied systems compare data analysis approaches dickinson beta testing analysts examine execution reports coming users determine failures work dickinson aims reduce number reports analyst inspect usersrun instrumented programs collect call profiles similar profiles clustered distance metrics finally analyst examines profiles cluster determine entire cluster corresponds correct failed executions similar dickinson operate function profiles distance metric estimate similarity profiles clustering approach applied goal identifying anomalousbehaviors locate anomalies finding clusters small number nodes practice found technique unsupervised 
techniques generates false positives reporting unusual normal behaviors anomalies problem scenario assumes manual data examination false positives present challenging obstacle fully-automated online diagnosis difference approaches method automates problem diagnosis identifying anomaly algorithm attempts find single function call chain root problem section details contrast approach dickinson requires manual effort analyst identify problem yuan yuan propose technique classifying failure reports field quickly diagnose problems collect system call trace application demonstrates reproducible failure apply supervised classification algorithm label trace similarity collection previous labeled traces label trace determines type observed problem root problem yuan operate system call traces coarser granularity function traces experience problem behavior application significantly system call traces anomalous property anomaly-based intrusion detection detecting anomalies system applications remains system call traces accurately represent behavior applications parallel numeric codes system call traces sufficient finding performance anomalies general problem function make system calls finding location system call traces approach yuan work function-level traces applied problem stages classify function-level traces classes normaland anomalous similartechnique cohen correlate aggregate metrics system cpu utilization violations performance objectives approaches supervised requiring examples previous traces labeled normal anomalous contrast approach operate examples class approachofyuan root-cause identification stage classify anomalous trace similar failure category require manual effort analyst classify traces previous failures technique targets root problems unable diagnose failures difference approaches yuan cross-run repetitiveness application behavior traces runs machines compared identify root failures contrast approach cross-run within-run inherent large-scale distributed systems result perform diagnosis single application run previous approaches explored within-run repetitiveness specific large-scale environments magpie magpie builds workload models e-commerce request-based environments techniques root identification magpie collects event traces client requests represents requests strings characters character corresponds event context switch event similar request strings clustered levenshtein string-edit distance metric end strings belong sufficiently large cluster considered anomalous requests finally identify root event responsible anomaly magpie builds probabilistic state machine accepts collection request strings magpie processes anomalous request string machine identifies transitions sufficiently low probability events correspond transitions marked root anomaly data analysis techniques applied function-level data representing function calls magpie events key difference approaches magpie groups raw traces based edit distance summarize traces compute profiles analyze similarity profiles environment application nodes perform similar activities long run instantaneous behaviors radically advantage profiles situations similar difference raw traces significant disadvantageof profilesis overlook subtle real symptoms problem experience behavior node typically substantially failure failed node location failure easily identified profiles approach detect latent faults occur failure remains pinpoint pinpoint detects faults client-server systems locates root records traces components involved processing client request traces obtained application-specific middleware-specific instrumentationpresent manycommercial systems pinpoint determines request completed successfully failed faults symptoms network timeouts auxiliary fault detector detect statistically significant deviations norm pcfg probabilistic context-free grammars approach similar magpie pinpoint applies fault detection root identification finally pinpoint independent techniques clustering decision trees correlations presence component request failure request identify anomalous host pinpoint external fault detectors find silent problems section alternatively apply pcfg-based approach discussed section approach effective raw function-level traces due variability locate root problem classified traces pinpoint decision trees clustering coverage data applied function-level coverage data approaches detect narrow class problems problem manifested difference function coverage traces detected diagnostic approaches approachfor root identification investigated cbi cooperative bug isolation project cbi instruments application collect values types predicates run conditional branch function returned negative scalar variable greater run labeled failed successful depending application crashed step cbi statistical techniques analyze collected data sets numerous runs identify predicates highly correlated failed runs predicates analysts focus analysis specific parts code introduce set predicates determine function present trace cbi analysis applied data collected sptracer key difference approaches similar sptracer approach pinpoint rely externally-provided classification traces normal anomalous identify anomalies traces mentioned projects exists variety specialized approaches aim locating kind problem attain level generality approaches discussed survey briefly tools aim detecting memory-related errors applications tools detect buffer overruns memory leaks attempts uninitialized memory free operations already-freed memory region similar errors extensive body work finding race conditions multithreaded programs techniques monitor memory accesses lock unlock operations performed threads make shared memory locations guarded locks conclusion presented automated approach combines dynamic instrumentation trace analysis explaining failures large-scale distributed environments approach anomalies massive failures anomalies harder locate massive failures identify fail-stop non-fail-stop anomalous behaviors attempt explain anomaly evaluation prototype realworld distributed environment demonstrated effectiveness techniques acknowledgements somesh jha helpful discussions root analysis techniques xiaojin jerry zhu insight machine learning approaches satoshi matsuoka valuable discussions suggestions failure diagnosis clusters global scientific information computing center tokyo institute technology allowing conduct experiments production system work supported part department energy grants de-fg defg office naval research grant part japan science technology agency crest research program entitled mega-scale computing based low-power technology workload modeling government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon avizienis laprie randell fundamental concepts dependability research report laboratory analysis architecture systems laascnrs apr barham donnelly isaacs mortier magpie request extraction workloadmodelling symposium operating systems design implementation osdi san francisco dec barham isaacs mortier narayanan magpie real-time modelling performance-aware systems workshop hot topics operating systems lihue hawaii bay schwabacher mining distance-based outliers linear time randomization simple pruning rule acm sigkdd international conference knowledge discovery data mining washington aug chan ashton lusk gropp jumpshotusers guide mathematics computer science division argonne national laboratory http mcs anl gov perfvis software viewers jumpshotusersguide html chen kiciman fratkin brewer fox pinpoint problem determination large dynamic internet services international conference dependable systems networks washington jun chen accardi kiciman lloyd patterson fox brewer pathbased failure evolution management symposium networked systems design implementation nsdi san francisco mar chen zheng jordan brewer failure diagnosis decision trees international conference autonomic computing icac york cohen chase goldszmidt kelly symons correlating instrumentation data system states building block automated diagnosis control symposium operating systems design implementation osdi san francisco dec cohen ravikumar fienberg comparison string metrics matching names records kdd workshop data cleaning object consolidation washington aug dickinson leon podgurski finding failures cluster analysis execution profiles international conference software engineering icse toronto ontario canada forrest hofmeyr somayaji longstaff sense unix processes ieee symposium security privacy los alamitos hastie tibshirani friedman elements statistical learning data mining inference prediction springer-verlag isbn hasting 
joyce purify fast detection memory leaks access errors winter usenix conference san francisco jan liblit naik zheng aiken jordan scalable statistical bug isolation acm sigplan conference programming language design implementation pldi chicago jun linux manual page send sendto sendmsg send message socket litzkow livny mutka condor hunter idle workstations international conference distributed computing systems san jose jun miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer nov mills network computer precision timekeeper precision time time interval ptti applications planning meeting reston dec mirgorodskiy miller autonomous analysis interactive systems self-propelled instrumentation multimedia computing networking mmcn san jose jan nethercote seward valgrind program supervision framework workshop runtime verification boulder jul netzer miller improving accuracy data race detection acm symposium principles practice parallel programming williamsburg apr perens electric fence http perens freesoftware ramaswamy rastogi shim efficient algorithmsfor mining outliers large data sets acm sigmod international conference management data dallas ronsse stougie maebe cornelis bosschere efficient data race detector backend diota international conference parallel computing parco dresden germany sept savage burrows nelson sobalvarro anderson eraser dynamic data race detector multi-threaded programs acm symposium operating systems principles saint-malo france oct ishikawa tezuka hori sumimoto takahashi carroll harada rwc cluster score cluster system software high performance linux cluster annual linux expo raleigh tax one-class classification phd thesis delft technology http tudelft davidt thesis pdf jun van der wijngaart nas parallel benchmarks version nas technical report nas- oct wagner dean intrusion detection static analysis ieee symposium security privacy washington wismuller trinitis ludwig ocm monitoring system interoperable tools sigmetrics symposium parallel distributed tools welches aug yuan lao wen zhang wang automated problem diagnosis event traces microsoft research technical report msr-tr- jun zandy force processto load library http wisc zandy hijack 
loop-aware search strategy automated performance analysis eli collins barton miller computer sciences department wisconsin madison usa eli bart wisc abstract automated online search powerful technique performance diagnosis search change types experiments performs program running making decisions based live performance data previous research addressed search speed scaling searches large codes nodes paper explores finer granularity bottlenecks locate automated online search refining search bottlenecks localized loops ability insert remove instrumentation on-the-fly means online search utilize fine-grain program structure ways infeasible performance diagnosis techniques automatically detect loops program binary control flow graph information efficiently instrument loops implemented strategy existing automated online performance tool paradyn results sequential parallel applications show loop-aware search strategy increase bottleneck precision compromising search time cost introduction performance analysis tools aid understanding application behavior automating search performance problems enables non-experts tools fast diagnostic experienced performance analysts performance tool dynamic instrumentation search identify performance problems unmodified program program runs previous research online automated search addressed scaling large codes lowering instrumentation cost locating bottlenecks quickly paper describes online automated search strategy increases precision granularity bottlenecks identified automated performance search demonstrate efficacy strategy implemented existing automated performance tool paradyn parallel performance tool online search strategy manages search space focusing functions executed functions executed end paradyn performance tool automated search component performance consultant program callgraph locate bottlenecks spring-verlag lncs tba topdown search program behavior matches process experienced programmer helps limit amount instrumentation inserted program improves search scalability ability operate efficiently programs large code sizes searching program call graph identifies performance problems function granularity identifying bottlenecks function granularity practice user performance tool inside function bottleneck located large function multiple distinct bottlenecks small function bottleneck called repeatedly loop localize bottleneck automated search strategy search inside function requires introducing level callgraph improves search precision level inhibit search scalability adding levels callgraph increases size search space level represent program structure logically decomposes function user precisely locates bottlenecks partitions functions searching augmenting program callgraph nested loops meets requirements searching code functions loops natural program decomposition loops increase precision ways bottlenecks long running programs scientific applications identify callsites function bottlenecks logically decompose function user applications loops execute iterations loops natural sources parallelism compilers hardware exploit openmp parallel directive compiler automatically parallelize loop loop-level performance data valuable feedback optimizations loop bottleneck precisely locate bottleneck suppose function multiple calls bottleneck function calls occur levels loop hierarchy infer calls responsible bottleneck performance data collected loops figure depicts callgraph functions loop information loops determine bottleneck bottleneck loops determine bottleneck due loop call loop loop loop fig callgraph callgraph augmented nested loops loops naturally decompose functions user search specifies bottlenecks loop precision user easily examine change loop structure program loops naturally decompose functions searching loop multiple nested loops callsites search inclusive performance metric determines loop bottleneck instrument loop nested loops callsites improving bottleneck precision lower instrumentation cost show experiments contributions paper automated search strategy increases precision definition points function control flow graph correspond loop execution dynamic instrumentation techniques enable efficient instrumentation points related work traditional profilers report performance data function statement granularity sampling prof gprof profilers record flat function callgraph profiles intel vtunetmperformance analyzer callgraph statement instruction level profiles sampling enables data collection fine granularity cpu time difficult collect inclusive cpu time elapsed time synchronization blocking time sampling tools automate search problem space similar paradyn performance consultant helm heuristic classification control automated search performance problems finesse diagnoses performance problems search refinement multiple runs performance tools report performance data loop granularity svpablo users instrument source code browse runtime performance data svpablo correlates performance data program source code level statements loops functions unlike paradyn instruments program binary svpablo inserts instrumentation program source code preprocessor instrument functions loops instrumenting program source reflects code programmer wrote fully reflect code generated compiler mtool tool isolating memory performance bottlenecks program basic block count profile identify frequently executed blocks instrument mtool instruments basic blocks explicit timer calls aggregates basic block data report loop function program overheads hpcview toolkit combining multiple sets profile data correlating data program source code aggregate performance data derived metrics presented function loop levels hpcview binary analysis correlate performance data program structures resulting compiler transformations loop fusion distribution unlike paradyn performs online automated performance analysis hpcview postmortem tool combines results program runs dpomp tool dynamic instrumentation collect performance data openmp constructs including parallel loops compiler transforms openmp directives function calls dpomp instruments due compiler optimizations collect performance data loop begin end iteration events dynamic binary loop instrumentation enables collection events identifying loops control flow function calls inserted compiler bursty tracing profiler statically instruments program capture temporal profiles limit overhead instrumentation counter-based sampling switch instrumented un-instrumented copies binary eliminate checks switch copies binary analyzing program callgraph binary limit overhead instrumenting k-boring loops loops calls profiling events interest bursty tracing profiler collects performance data online performance analysis handled ine approach performs automated online performance analysis insert remove instrumentation run time based current performance data limit overhead fine-grain instrumentation activating performance data decide parts program instrument performance consultant performance consultant paradyn automated bottleneck detection component searches application bottlenecks performing experiments measure application performance locate performance problems occur initially experiments measure performance entire application performance consultant discovers bottlenecks refines experiments precise type location bottleneck experiments test hypotheses application suffer performance problems hypothesis tested performance consultant application spending excessive amount time blocking operations activate experiment performance consultant inserts instrumentation code application collect performance data instances measured exceeds predefined threshold experiment termed bottlenecks paradyn represents programs collections discrete resources resources include program code modules functions loops processes threads machines synchronization objects paradyn organizes program resources trees called resource hierarchies root resource hierarchy labeled hierarchy move root node level hierarchy represents finer-grained description program form resource concatenate labels unique path root node representing resource resource function fact module math code math fact constrain measurements parts program measure cpu time entire execution program single function loop experiment focus determines instrumentation code inserted selecting node resource hierarchy narrows viewto include nodesthat descend theselected node focus code math fact machine toaster wisc syncobject denotes function fact module math executing host toaster wisc focus specifies top level syncobject resource constrain 
resources names synchronization object type synchronization object performance consultant refines search bottlenecks true experiment experiment hypothesis true focus generating experiments specific focus refine focus performance consultant generates foci focus code math fact loop machine toaster wisc syncobject refined loop fact focus code math fact machine toaster wisc syncobject refined process host toaster wisc search history graph records cumulative refinements search node represents hypothesis focus pair paradyn visual representation graph dynamically updated performance consultant refines search display visual history search information individual experiments hypothesis focus active current measured experiment hypothesis test true false cost instrumentation enabled performance consultant continually monitored limited user-selected threshold experiments generate instrumentation requests existing hypotheses test false instrumentation removed binary instrumentation loops collect performance data loop granularity paradyn instrument individual loops program binary section describe implementation loop instrumentation paradyn parses application binaries builds flow graph function dominator information calculated lengauer-tarjan algorithm identify natural loops standard definitions basic blocks dominators back edges natural loops basic block maximal sequence instructions entered instruction exited instruction basic block dominates block execution path flow graph entry includes back edge flow graph edge target dominates source natural loop back edge subgraph consisting set nodes blocks reached passing block loop header decision natural loops opposed cycle flow graph reasonable irreducible loops rare create structured language gotos compiler code replication techniques transform reducible loops program source code irreducible loops program binary case rare experience type loop identified issue correctness irreducible loops program binary hinder instrumentation natural loops natural loops share header distinguish nesting relationship derived single loop source case combine loops single natural loop common compilers instrument loops flow graph define instrumentation points flow graph correspond loop execution semantics loop entry instrumentation executes control enters loop instrument set edges loop header member loop loop preheader edge exists instrument loop exit instrumentation executes control exits loop instrument set edges member loop loop begin iteration instrumentation executes beginning loop iteration instrument loop header loop end iteration instrumentation executesat end loop iteration instrument loop back edge loop exit instrumentation points figure illustrates location points simple loop loop entry exit points balanced instrumenting loop entry start timer operation loop exit stop timer operation execution start timer eventually execution stop timer loop begin end iteration points balanced previous versions dynamic instrumentation instrument functions basic blocks instructions work add edge instrumentation edge instrumentation static binary editors eel edges created unconditional jumps instrumented simply instrumenting instruction edge source block instrument edges created indirect jumps control transfer create loops typically jump tables dynamic call sites instrument edges created conditional jumps create edge trampolines figure illustrates instrument conditional jumps edge trampolines edge trampoline code fragment basic blocks corresponds execution fall-through edge edge shaded regions instrument edge instrumenting basic block existing technique creating instrumentation points conditional jump overwritten unconditional jump edge trampoline conditional jump relocated trampoline target address simulates execution original conditional jump blocks targets blocks end jumps original conditional jump targets end enter iteration begin iteration exit exit end iteration fig loop instrumentation points flow graph circles instrumenting conditional jump creates loop back edge shown edge trampoline create basic blocks shaded correspond execution fall-through edges conditional jump absolute jump instruction ensure edge trampoline reached application code instrumenting cisc architectures absolute jump instruction larger relative jump instruction means absolute jump transfer control edge trampoline larger conditional jump replaces case relocate instructions conditional jump head edge trampoline make room safely relocate instructions basic block terminated conditional jump rare size entire basic block smaller size unconditional jump instruction handle case short trap instruction trap caught handler sets application start address edge trampoline disadvantage approach performance suffers due cost handling trap strategy function relocation performance consultant determines basic blocks relevant loop instrumentation function large efficiently instrumented rewrites function location application address space rewriting function nop instructions inserted original code ensure relevant basic blocks large performance consultant overwrites beginning original function jump newly created copy loop-aware search strategy loops form natural extension callgraph-based search figure conceptually performance consultant treat additional steps refinement defined loop instrumentation points similar functions section result loops conceptual steps actual steps performance consultant search performance consultant performs breadth-first search application callgraph function entry exit points instrumented collect inclusive time-based metrics function bottleneck pruned search space search continues instrumenting functions calls function bottleneck search continues instrumenting functions calls nested loops function outermost loops loop bottleneck instrument children functions called directly loop loop directly nested loops loop bottleneck loop descendants pruned search addition loops suggests experiments run pruning loop callgraph means descendants pruned instrumenting non-bottleneck loop multiple function calls reduces number experiments run called functions instrumented depending structure program code adding loops callgraph fewer experiments run found top-down approach successful practice approaches work search strategy decide instrument function loops based static information function depth call graph structure function flow graph dynamic information function current performance data influence decision unlike techniques statically instrument binary dynamic instrumentation search fine-grained instrumentation make decision loops instrument run time enables loop search strategy compliment strategies deep start quickly locate functions performing poorly problematic functions found loop instrumentation precisely locate bottlenecks functions search strategy dynamically evaluates tradeoff low overhead function-level instrumentation increased precision loop-level instrumentation reap benefits techniques experimental results evaluate loop-aware search strategy compared performance consultant current search strategy performed experiments sequential parallel mpi openmp scientific applications table table lists detailed application characteristics including loop information mpich version mpi implementation version portland group compilers fortran applications gcc version application bottlenecks found time seconds loop functions loop alara bottlenecks found time seconds loop functions loop draco bottlenecks found time seconds loop functions loop bottlenecks found time seconds loop functions loop sphot fig search profiles sequential alara draco parallel sphot applications default performance consultant search loop loop-aware search strategy loop functions loop-aware search strategy functions counted bottlenecks experiments ghz pentium pcs hyperthreading enabled ram running tao linux repackaged version red hat enterprise linux connected ethernet mpi applications run identically configured pcs paradyn front-end process run machine applications performed multiple runs application run began performance consultant search application reached steady-state behavior version type nodes language domain alara sequential induced radioactivity analysis draco sequential fortran hydrodynamic 
simulation mpi global ocean circulation sphot mpi openmp fortran monte carlo transport code table application characteristics loops nestingname lines funcs loops loops func alara draco sphot table application characteristics including number loops percent total number loops nesting levels total bottlenecks leaf bottlenecks experiments function loop function loop loop alara draco sphot table types bottlenecks rate experimentation default performance consultant search loop loop-aware search strategy experiments loops frequently bottlenecks table expected examined scientific applications total applications contained function bottlenecks leaf nodes callgraph contained loop bottlenecks loops significantly increase bottleneck precision single function bottleneck time step leaf node callgraph consumes application cpu time information time step large function loops performance consultant reports loops bottlenecks bottleneck loops leaf nodes augmented callgraph loop-level data time spent time step attributed loop figure compares rate bottlenecks found performance consultant default search strategy loop-aware strategy results shown ignoring loop bottlenecks search strategies find bottlenecks similar rates loop-aware strategy finds total bottlenecks due loops takes longer identify function bottlenecks due increased height augmented callgraph observe significant differences rate experimentation required search loops table applications rate experimentation search strategies loop-aware performance consultant required faster rate experimentation application slower rate general observed precise results major change search time rate experimentation automated online search strategy instruments loops functions question pay cost fine-grain instrumentation conclusion searching loops proved natural extension performance consultant callgraph-based online automated search strategy loops frequently bottlenecks strategy precise performance diagnosis loops partition functions searching dramatically increasing number experiments defined points flow graph correspond loop execution presented technique efficient instrumentation points mechanism enables loop-aware search strategy precisely locate bottlenecks large search time cost aho sethi ullman compilers principles techniques tools addison-wesley cain miller wylie callgraph-based search strategy automated performance diagnosis concurrency computation practice experience march appears euro-par munich germany august derose mohr seelam profiling tracing openmp applications pomp based monitoring libraries euro-par pisa italy august gerndt krumme rule-based approach automatic bottleneck detection programs shared virtual memory systems intl workshop high-level programming models supportive environments geneva switzerland april goldberg hennessy mtool method isolating memory bottlenecks shared memory multiprocessor programs international conference parallel processing augsust graham kessler mckusick execution profiler modular programs software practice experience august helm malony fickas capturing automating performance diagnosis poirot approach intl parallel processing symposium santa barbara california april hirzel chilimbi bursty tracing framework low-overhead temporal profiling acm workshop feedback-directed dynamic optimization austin texas december hollingsworth miller dynamic control performance monitoring large scale parallel systems international conference supercomputing tokyo july hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing knoxville tennessee karavanic miller improving online performance diagnosis historical performance data portland oregon november larus schnarr eel machine-independent executable editing programming language design implementation lengauer tarjan fast algorithm finding dominators flowgraph acm transactions programming languages systems toplas july mellor-crummey fowler marin hpcview tool top-down analysis node performance los alamos computer science institute annual symposium santa october miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallelperformance measurement tools ieee computer november muchnick advanced compiler design implementation morgan kaufmann mukerjee riley gurd finesse prototype feedback-guided performance enhancement system euromicro workshop parallel distributed processing rhodos greece january reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance analysis environment anthony skjellum scalable parallel libraries conference october roth miller deep start hybrid strategy automated performance problem searches concurrency computation practice experience september john wiley sons appeared shorter form euro-par paderborn germany august lncs springer verlag srivastava eustace atom system building customized program analysis tools programming language design implementation june intelr vtunetmperformance analyzer http intel software products vtune official openmp fortran version specification http openmp drupal mp-documents fspec pdf 
language-based generation evaluation nids signatures shai rubin somesh jha barton miller wisconsin madison computer sciences department shai jha bart wisc abstract present methodology automatically construct robust signatures accuracy based formal reasoning systematically evaluated methodology based formal languages describe properties attack language called session signature describes temporal relations attack events called attack invariant describes semantic properties hold instance attack invariant state ftp attack include successful ftp login launched ftp representation mode set ascii iteratively eliminate false positives negatives initial session signature comparing signature language language invariant developed gard tool session-signature construction construct session signatures multi-step attacks show session signature accurate existing signatures introduction misuse network intrusion detection system nids defines attack attack signature typically regular expression matches pattern attack ideally time ongoing activity matches attack signature nids raises alarm ultimately security nids depends primarily accuracy signatures conceptually signature represents single attack set events exploit vulnerability practice single attack appears forms attack instances pro-ftpd attack requires ftp commands ordered ways can- signature essentially concise representation large set attack instances construction accurate signature daunting task security analysts inspect exemplary attack instances hypothesize properties hold attack instance write expression match properties analysts systematic identify false positives cases signature over-approximates set attack instances false negatives cases signature under-approximates set systematic evaluate impact analysts perform improve signature accuracy single change fix false positive uncover false negative end result ad-hoc time consuming error prone process surprising current signatures inaccurate producing false positives negatives paper develop systematic method construct accurate signatures main idea simple construct initial signature attack build independent representation set attack instances signature match compare signature independent representation comparison reveals false positives negatives manually refine signature repeat process satisfied signature accuracy signature develop paper called session signature existing signatures based regular language models attack events ftp messages session signature models entire attack attacker initiation connection victim indication attack succeeded compared current signatures enables precise definition temporal relations events attack result session signature potentially accurate current signatures section refine accuracy session signature develop notion attack invariant anoverapproximation set attack instances invariant describes semantic properties conditions attack property successful ftp login required launching attack invariant pro-ftpd attack mentioned semantic properties enable express knowledge protocol attack properties easily expressed signature bridge session signature represents attack syntactic features attack invariant represents semantic features develop semantic model protocol finite state machine specifies protocol command set variables values define protocol state ftp model type variable tracks representation mode ftp session ascii binary describes type command affects variable semantic model serves goals define invariant set machine states pro-ftpd attack succeeds ascii mode pro-ftpd invariant set states type set ascii model compute protocol state sequence commands determine invariant holds sequence essentially session signature attack invariant independent representations set attack instances formally represents set sequences events find false positives negatives compare set sequences represented signature set represented invariant find false positive search sequence matches signature satisfy invariant analogously find false negative search sequence match signature satisfies invariant figure invariant over-approximates set real attack instances sequence part signature part invariant false positive find false positive refine signature reason sequence match signature satisfies invariant necessarily false negative spurious sequence sequence match signature satisfies invariant implement attack manually distinguish false negatives spurious sequences find false negative refine signature find spusp attack invariant attack instances false positive false negative spurious sequence session signature figure searching false positives negatives rious sequence refine invariant repeat search false positives negatives longer refine signature invariant satisfied signature accuracy finding false positives negatives improves signature accuracy discovered spurious sequences contribute accuracy force refine invariant understand conditions identifying attack understanding key building highly accurate signatures find false negatives spurious sequences develop searching strategy search false negatives starts sequences events match signature similar terms string matching sequences match research shows sequences real attacks false negatives signature show section searching strategy effective finding false negatives carry search implement gard tool generation analysis refinement deployment nids signatures gard semantic model formalize notion attack invariant compares signature regular language invariant empirically evaluated gard capabilities show session signature simple attack accurate snort contextual counterparts show respect attack invariants signature produces false alarms miss attack instance signatures recognize show gard capable generating signature complex attack attack requires multiple steps succeed illustrate iterative process gard systematically uncover signature inaccuracies gard guarantee discovery false positives negatives finds false positives negative respect attack invariant defining meaningful invariants art based human expertise experience shows simple invariants gard capable finding false positives negatives anticipate majority semantic properties required invariant formally notion semantic model overcome signature limitations signatures require non-regular languages priori knowledge signature limitations important ability generate robust signature based knowledge signature user make rational decisions risks system faces user address risks security means summary paper makes contributions session signature models entire attack regular language show accuracy session signature systematically improved show session signature attacks analyzed accurate current signatures attack invariant representation attack evaluate session signature based semantic model attack protocol gard tool automatic evaluation generation session signatures show based empirical evaluation signatures gard produces superior current signatures related work gard centered combination capabilities modeling entire attack signature-specification language based language operators formal representation protocol semantics methodology evaluate signature accuracy review research tools respect capabilities signature specification languages snort widelyused nids represents signature set attributes packet attributes packet length pattern attributes regular expression defined attack bytes snort signature corresponds single attack event model entire attack snort facilitate composition rules ability dynamically invoke rules logging purposes bro bases detection policy scripts signatures policy script determines actions alerts based events bro identifies sequence ftp commands general script model entire attack regular language requires programming imperative language similar fact impairs ability easily define signature analyze signature accuracy recently sommer paxson bro implement contextual signature enables sequencing events declarative contextual signature model entire attack supports sequencing operators results show section sequencing constructing tight signatures statl signature specification language netstat represents signature state diagram describes sequence events attack statl support forming regular expressions events construction state diagram signature specification evaluation signature accuracy gard state machine intermediate signature representation easy translate gard signature statl work pursue issue sekar developed signature specification language 
formalizing sensitivity static analysis intrusion detection henry hanping feng jonathon gif yong huang somesh jhay wenke leez barton millery department electrical computer engineering massachusetts amherst fhfeng yhuangg ecs umass ycomputer sciences department zcollege computing wisconsin madison georgia institute technology fgif jha bartg wisc wenke gatech abstract key function host-based intrusion detection system monitor program execution models constructed static analysis highly desirable feature produce false alarms miss attacks prior work shown trade-off ciency precision accurate models based pushdown automata pda inef cient operate due non-determinism stack activity paper present techniques determinizing pda models rst provide formal analysis framework pda models introduce concepts determinism stack-determinism present vpstatic model achieves determinism extracting information stack activity program dyck model achieves stack-determinism transforming program inserting code expose program state results show run-time monitoring models slow execution test programs shows reasonable ciency sacri ced model precision compare models discover deterministic pda cient stack-deterministic pda require memory introduction typical host-based intrusion detection system hids monitors execution process identify potentially malicious behavior anomaly detection hids identi variations preconstructed model normal program behavior system interposes monitor process operating system events system calls program operating system validated model events conform model rejected monitor figure shows typical hids architecture techniques construct program model anomaly detection hids learning-based techniques construct program model training set execution traces speci cation program provided domain expert program model paper focuses program models constructed static analysis context static analysis trade-off ciency precision non-deterministic nite automaton nfa models cient operate introduce impossible paths model call-return semantics program pushdown automaton pda models eliminate impossible paths incorporating program stack inef cient operate inefciency pda models occurs stack activity program hidden model results non-determinism state space pda model prohibitively large operation call curse non-determinism paper formally presents techniques handle problem speci cally make contributions formal framework formal models intrusion detection research received scant attention address shortcoming investigating formalisms drives discovery program models exhibit reasonable performance primary purpose formally analyze recently proposed models insystem calls model rejected monitor model call system system call operating system program monitor figure architecture host-based intrusion detection system troduce all-new models commonality models exposure process execution state simple system call stream sekar proposed program counter information feng gif exposed stack activity program show context-free language cfl homomorphic deterministic cfl proof result similar chomsky intuition techniques expose program state non-determinism stack activity major factor contributing time space complexity operating pda models motivated observation stack-deterministic pda model stack activity deterministic section discusses formalisms model determinizing techniques techniques determinizing pda models essentially incorporate additional program state program counter stack activity model describe techniques incorporating additional state program observational technique monitor extracts relevant information program monitor extract information stack activity program walking call stack vpstatic model statically-constructed variant vtpath model implements technique rewriting instrumentation technique transforms program introduce additional code exposes program state additional system calls introduced call function model call happen recent dyck model implements approach compare observational rewriting approaches determinizing pda model sections present models evaluation results show formalisms deterministic stack-deterministic push-down automata enable construction context-sensitive program models suitable online security monitoring vpstatic automaton operation slows execution test programs unoptimized stack walking algorithm adds additional overhead dyck model slightly efcient due state non-determinism overheads dyck model compact representation requiring memory program instrumentation state machine results vindicate context sensitive models showing reasonable ciency sacri ced model precision complete results section related work signi intrusion detection systems research focused static dynamic analysis techniques automatically generate program models wagner produced models static analysis source code precise abstract stack model non-deterministic pushdown automaton pda due stack state maintained pda model captured precise call return behavior function calls runtime automaton operation monitor prohibitively high programs reaching tens minutes transaction observed similar results pda models extracted static binary analysis sparc executables papers concluded imprecise context-insensitive models reasonable performance context-sensitive models pda detect impossible path exploits wagner attacks force control enter function call site return call site portion program code suitable attack context-sensitive model detects illicit control modeling state program call stack experience severe non-determinism stack state major contributing factor time space complexity pda operation dyck model proved eliminating non-determinism stack transitions context-sensitive model ciently operated paper formalizes dyck model proves stack deterministic pda improve model eliminating additional system calls required previous model construction vpstatic model fully deterministic pda requires modi cations original analyzed binary dynamic analysis extends original work forrest constructs program model based observed system call traces numerous training runs sekar showed learning deterministic automaton associating system call program counter model monitor context information miss attacks due imprecision miss attacks dynamically linked libraries due oversimplied handling dynamic objects previous vtpath model improved precision dynamically constructed models model additionally monitors return addresses call stack vpstatic model natural extension vtpath constructed static analysis techniques add formalism previous work vtpath model calculates adhoc virtual path call stacks adjacent system calls veri validity path vpstatic provably deterministic pda automaton localizes transitions states making vpstatic precise vpstatic model suffer false alarms vtpaths due conservative static analysis pioneered work static dynamic analysis approaches monitor execution based speci cations system calls expected program behavior provided domain expert speci cations enhance quality automatically generated models vpstatic model anomaly recovery property considered previous approaches anomaly occurs uniquely determine expected state stack context valid system call monitoring program counter call stack continue operate automaton potentially detect attacks root-level exploit probe greater variety security policies enabling system fail anomalous system call continue execution terminate program monitor terminates network daemon anomalous system call denial service attack prevent anomalous call process execution monitoring continue formal models begin formally describing pushdown automata deterministic pushdown automata stack-deterministic pushdown automata nite state machines underlying constructs program models intrusion detection nition pda dpda pushdown automaton pda -tuple set states input alphabet stack alphabet transition relation mapping nite subsets unique initial state initial stack start symbol set accepting states types transitions input consumption transition top stack stack contents change represents transition consumes input state consume input move state push transition pushes stack explanation pushed stack pop transition pops stack explanation popped stack pda called deterministic transition relation satis conditions condition nonempty empty 
based regular expression events entire attack property important comparing signature accuracies section focus network-level attacks tcp syn-flood applicationlevel language gard language attack types address question signature accuracy suggest means evaluate translate signatures finite state machine work benefit evaluation methodology pauzol ducass proposed language called sutekh focus host-based intrusion detection language features similar model attack sequencing operators represent signature finite state machine lambda adele provide abstraction events languages expressive session-signature language general express network host-based attacks provide ability define parallel execution events required network-based attacks languages language provide ability define attack preconditions post-conditions translating signatures language languages easy task research mentioned work provide means evaluate signature accuracy gard support features found tools signatures require detection based properties network packets timers event scheduling explicit event counters count events regular expression inefficient work focused foundational concept gard formal language tools signature specification evaluation missing features integrated gard plan future signature evaluation methodologies current techniques signature evaluation based testing benchmarking knowledge apply formal verification techniques signature evaluation fundamentally verification testing complement verification process strives uncover signature vulnerabilities show absence respect abstract model protocol semantics testing hand aims uncover bugs exercising signature real network traffic wagner soto applied formal methods find vulnerabilities signatures host-based ids intersect language signature accepts language models attack manually construct instance evades signature false negative provide automatic methods constructing false positives negatives hand gard techniques attack invariant automatically perform tasks gard overview illustrate gard construct evaluate session signature purposes chose simple attack called ftp-cwd section show gard handles complex attacks ftp-cwd attack can- exploits vulnerability blackmoon ftp server windows attack requires steps attacker logs ftp server anonymous login buffer overflow providing overly-long argument ftp cwd change directory command attacker gains root privileges host communicates compromised host ftp control port port define signature ftp-cwd perform steps signature specification construct pattern matches sequence events required attack detection sequence events occur entire attack attacker initiation connection victim indication attack succeeded signature evaluation search signature loopholes sequence ftp events false positive false negative construct ftp-cwd invariant gard automatically compare signature language invariant language iterative process continues decide signature accuracy satisfactory longer refine signature invariant define session signature important understand signature matched practice matching session signature requires components lexical scanner translates raw network traffic stream events scanner identifies cwd commands required ftp-cwd signature matching engine matches stream events scanner pattern signature specification signature specification simple assume lexical scanner pass matching engine event part signature specification ftp store command irrelevant detection ftp-cwd scanner pass token matching engine assume network-level protocols tcp handled nids matching process assume tcp connection aborted matching engine halts signature specification session signature based three-phased abstraction preparation attacker sets attack preconditions exploitation attacker launches attack confirmation attacker determines attack succeeded construct session signature define events phase ftp commands arguments form regular expression phase language session signature concatenation phase languages ftp-cwd events intuitively event corresponds protocol message part formally event observable sequence bytes part attack bytes attacker victim gard represents event lexeme regular expression matches sequence bytes token uniquely identifies event lexical scanners flex identified events ftp-cwd preparation phase identified event corresponds response ftp server confirming successful login corresponds attacker attempt login logout attack length data bin intrusion pre theftp-cwd preparation phase disjunction events table exp theftp-cwd exploitation phase conf theftp-cwd confirmation phase intrusion logout attack cql length data bin intrusion logout attack cql accept start reject ordinary state superstate main machine concatenation phases ftp-cwd ftp-cwd machine hsm ftp-cwd attack superstate fully detailed note alphabet superstate bytes main machine events bin reality attacker necessarily target bin gard libraries expressions analyst build ftp-cwd explotation phase figure ftp-cwd specification operational ftp-cwd session signature logout ftp session exploitation phase event corresponds ftp cwd command event corresponds argument cwd command finally confirm intrusion identified event corresponds invalid response ftp server message part legal ftp response compromised server well-behaved ftp server matches response unix command attacker ftp-cwd check attack succeeded cases define events gard library predefined events common protocols ftp http based ftp specification ftp library table event definition event ftpcwd specification ftp-cwd phase languages explain process signature specification underlying compilation method gard present phase language finite state machine expression languages section ftp-cwd preparation language denoted pre ensures attacker logged server launching attack imposes conditions figure attacker successfully completed login procedure attacker executed logout procedure show section signatures ensure condition snort ftp-cwd signature generate false positives language figure common ftp attacks added gard library ftp patterns ftp-cwd exploitation language denoted exp concatenates event event concatenation matches cwd command benign restrict content malicious malicious cwd argument longer bytes string bin figure gard supports restrictions event length relational operators andontheeventdata regular expressions straightforward matter translate event restriction regular language ftp-cwd confirmation phase denoted conf single invalid response event figure generatinga working signature defining regular language phase completes signature specification gard compiles specification intermediate representation explain signature evaluation process provide short summary process intermediate representation gard section presents detailed compilation process gard compilation process steps ftp-cwd ftp-cwd ftp-cwd main concepts signature evaluation illustrated ftp-cwd attack semantic model protocol implement define search false positives negatives language definition star set sequences events protocol sequences implement set unambiguously define sequences session signature accepts sequences satisfy invariant sequences k-edit distance false positive false negative spurious sequence formalizing signature evaluation comparison regular languages figure fundamentals language-based generation session signatures gard concatenates phase languages main machine figure gard embeds restrictions events main machine separate finite state machines restrictions regular languages restriction represented fsm gard builds non-recursive hierarchical state machine hsm machine states ordinary states superstates fsm ftp-cwd case superstate imposes restrictions data length state superstate accepts restrictions main machine moves attack state moves state figure straightforward matter translate hsm working signature translate hsm snort plugin bro contextual signature signature evaluation purposes easy translate spin model section signature evaluation ultimately task construct signature matches ftp session implements ftp-cwd attack formally denote set ftp sessions implement ftp-cwd ftp-cwd called ultimate set ftp-cwd denote set sessions matches session signature figure ftp-cwd ideal signature signature ftp-cwd ftp-cwd non-ideal signature generates false positives negatives false positive denoted sequence ftp-cwd ftp-cwd false negative denoted sequence 
ftp-cwd ftp-cwd figure ultimate set easy define regular language signature cases ultimate set difficult define thought easy construct session signature matches ftp-cwd gard found false positive ultimate set complex attacks difficult define section systematically find false positives negatives approximate ultimate set attack invariant predicate hold instance attack define ftp-cwd invariant login procedure completed attacker sends malicious cwd command invariant expressed regular language denoted ftp-cwd evaluation methodology assumes invariant over-approximates ultimate set ftp-cwd ftp-cwd discuss reasons over-approximation section ftp-cwd find false positive searching sequence ftp-cwd ftp-cwd ftp-cwd ftp-cwd iffp ftp-cwd ftp-cwd thenfp ftp-cwd ftp-cwd false positive figure find false negative search sequence set ftp-cwd ftp-cwd ftp-cwd ftp-cwd search yield spurious sequence satisfies invariant implement ftp-cwd formally sequence ftp-cwd ftp-cwd ftp-cwd figure time find sequence ftp-cwd ftp-cwd wemanually check spurious instance refine invariant continue searching discuss techniques guiding search false negatives spurious sequences section illustrate invariant refinement process section false positive ftp-cwd formally define ftp-cwd ftp semantic model appendix gard compared ftp-cwd ftp-cwd found false positive sequence ftp commands matches signature malicious cwd appears completed login procedure ftp-cwd specification ignores victim ftp server voluntarily terminates connection event vquit table false positive includes event injected malicious cwd attacker intentionally ignores terminating message continue send malicious cwd causing false alarm open question include event ftp-cwd signature unclear attackers exploit weakness case gard generate versions signature incorporates event ignores signature users choose version fits important lesson ftp-cwd weakness revealed ftp-cwd signature systematic found weakness illustrated formal methods tools systematically construct nids signatures signatures quality evaluated understood discuss gard advantages disadvantages section gard foundations discuss gard signature-specification language algorithm translate signature specification hierarchical state machine methodology finding false positives negatives signature specification language goal gard specification language provide clean separation event representation ability construct regular languages events automate process launching instance vulnerable host leave implementation issue future work achieve goal language event representation constructing regular expressions represent events regular expressions raw network bytes practice flex language form expressions attack events multiple streams stream messages attacker victim responses annotate event stream identify streams common convention addresses port numbers brevity ftp model appendix stream event sender subscript denote attacker denote victim form regular expression events gard standard operators language manipulation table non-standard operator operator restrict data length event figure table presents complete signature specification ftp-cwd languages phases pre exp andl conf correspond state machines presented figure figure compilation process compiling signature specification table hsm figure based standard algorithm translating regular expression finite state machine compilation process steps standard algorithm translate expression fsm called superstate translate expression ftp-cwd specification machine identifies string pattern bin longer bytes standard algorithm build main figure formally build main accepts language pre exp conf embed superstates main obtaining session signature hsm denoted attack-name figure build main standard algorithm recall algorithm handle nonstandard operator perform restricted-event renaming replace restricted event token restricted operator table unique identifier convert exp table data shell length expression phase signature description preparation pre login ftp macro denoting regular expression matches ftp session successful login macro defines regular expression tokens star star exploitation exp data star bin star length malicious cwd command argument longer bytes pattern bin bin practice patterns exploit code confirmation conf invalid response event connection longer ftp connection table signature specification fpd-cwd renaming restricted event syntactic sugar preserves signature semantics essentially restricted event represents unique sequence bytes restricted event data shell length represents sequence bytes event table renaming enables standard algorithm distinguish restricted events unrestricted versions distinguishes events renaming enables identify places main machine embed superstates step edge main machine labeled renamed event replaced superstate signature evaluation algorithms session signature attack ftp-cwd figure evaluate session signature comparing language denoted language invariant denoted define invariant attack protocol represent protocol semantics semantic model finite state machine denoted state valuation variables called protocol state variables transition describes event protocol message affects variable values defined aset protocol events essentially language represents star model ftp appendix attack invariant logical formula state variables language language accepted accepting states states holds mentioned section goal construct signature close ultimate set cases clear definition evaluate accuracy approximations results show comparison effective improve accuracy require attack invariant condition attack occur figure require reasons conditions easy define facilitating fast signature construction easy successful ftp login condition ftp-cwd attack false negatives considered harmful false positives overapproximating ensure theoretically miss false negative find false positive search sequence mentioned section sequence false positive analogously find false negative search sequence set search yield spurious sequence sequence satisfies invariant implement time find sequence check spurious instance refine invariant continue searching search false negatives involves human intervention avoid spurious sequences problem larger yielding spurious sequences ftp-cwd figure sequences ftp commands ftp login completed set larger ftp-cwd set sequences implement ftp-cwd reduce probability hitting spurious sequence search set sequences similar terms string matching sequences strategy based observation attack instances generated introducing small already-known instances attack signature represents instances observation forms basis nids testing tools formalize similarity notion edit distance edit distance strings denoted number insertions deletions substitutions required transform language define k-edit-distance language denoted set strings edit distance string formally itiswell regular language regular forms regular language superset gard summary pitfalls find false positives gard checks set empty find false negatives gard checks set constant isempty check emptiness sets gard spin publicly model checker sets regular straightforward promela input language spin represent sets finite state machines spin capable checking emptiness providing sequence sets empty ability greatly simplifies evaluation process gard asserts means interpret events semantic model events model construct false positive matches signature violates attack invariant ftp-cwd signature figure ftp model appendix ftpcwd invariant section gard asserted ftp-cwd ftp-cwd adding signature means construct sequence events events table matches signature attacker logged believes model accurately describes ways login logout ftp server attacker false positive ftp-cwd signature completing ftp login procedure guarantee exist current ftp-cwd signatures section gard guarantee discovery false positives gard find false positive event part model case semantics model refined gard find false positive satisfies attack invariant figure sequence surfaces invariant refined gard asserts means interpret events semantic model sequence events model implements k-edit distance 
sequence matches signature gard guarantee discovery false negatives gard find false negative k-edits signature gard miss false negative event part model case figure inaccurate negationslash surprising vague nature motivation work false negative surfaces semantic model refined implementation notes construct sig recent methodology proposed kari methodology enables define errors permitted words permits restrict transformations attackers perform feature understand transformations preserve attack semantics ftp-cwd attack delete replace cwd command ftp command signature evaluation hsm superstates main machine ftp-cwd machine figure assume false negative positive exists main thereisalso sequence sig attacker finds sequence main construct satisfies restrictions imposed supernodes recall lexical scanner drops event explicitly signature specification section dropped events self-loops main signature evaluation add loops main gard evaluation evaluate accuracy session signature gard ability find false positives negatives complex attacks prove ftp-cwd signature table accurate current signatures vulnerable false positives respect invariant miss attack instance signatures recognize show gard model complex attacks find false positives negatives anticipate session signature evaluation initial study gard identify vulnerabilities ftp-cwd signatures current nids recent contextual signature developed sommer paxson snort signature compare signatures desig sig-name hsm size false operational comments brevity write sig-name alphabet states edges positive false positive snort ftp star star ftp star cwd star star cwd star star size deterministic hsm states edges superstates table comparison signatures weaknesses ftp set events table fined snort contextual signatures session signatures denoted snort snort signature include confirmation phase added event section confirmation phase signatures ftp model appendix define invariant login procedure completed attacker sends malicious cwd command gard find false positives signatures gard revealed false positives familiar refined initial ftp-cwd signature verified respect invariant false positives ftp-cwd snort signature signature revision essentially exploitation phase session signature figure knew signature tight attackers false positive sending malicious cwd command logged ftp server signature ignores events precede malicious cwd model preparation phase ftp star ftp set ftp events model table ftp-cwd contextual signature signature ensures login event appears malicious cwd knew signature tight attacker false positive sending ftp quit command immediately malicious cwd completed ftp login procedure defined preparation-phase language star ftp star wherel successful-login event table means observing single login event signature moves exploitation phase ftp-cwd session signature signature defined table denoted cwd evaluation summary table presents summary experiment results row table presents signature snort cwd andcwd whichwe constructed gard revealed weakness cwd signature show language accepts alphabet signature hsm number nodes edges hsm false positive gard found create operational false positive sequence gard provided observations noted order signatures accuracy snort accurate signature cwd accurate easy prove snort cwd cwd means accurate signature generates false positives accurate signature prove sequence implements ftp-cwd snort cwd cwd cwd means accurate signature misses attack instance accurate signature matches formal proofs claims scope paper operational overhead signatures low signatures require edges indicating insignificant memory footprints hsms proftpd server bro generate operational false positive sequence gard provided cwd sequence server voluntarily terminates ftp tcp connections event bro stops monitoring ftp session immediately observing terminating tcp sequence ignores events generate false alarm additional overhead cwd intermsof memory consumption insignificant cwd preferable prevents potential false positive cwd constructing complex signatures gard pilot study examined simple attack success wanted challenge gard capabilities complex attack chose multi-step pro-ftpd attack pro-ftpd attack can- pro-ftpd attack exploits buffer overflow proftpd server vulnerability occurs attacker transfers file ascii mode phase signature description pre login ftp type login ftp star star slogin event quit event table pattern ftp-cwd signature figure exp type star star star type event type event table intuition ascii mode requires event event conf star ftp event identifies opening unix shell port ftp server pattern star matches traffic traverses tcp session address events attacker arbitrary port number table ourinitialsignatureofthe pro-ftpd attack negatives fix section section event definitions table transfer proftpd server stores data byte chunks check newline characters due incorrect handling characters buffer overflow occurs proftpd parses specially crafted file attack requires steps attacker logs ftp server representation mode ascii iii uploads ftp server file shell code downloads file download buffer overflow occurs attack attacker gains root privileges host communicates compromised host tcp connection opened shell code initial pro-ftpd specification attack requires preconditions ftp session login ascii states store command uploads attacker file simultaneously impose login ascii states intersected languages login ftp type table resulting pattern concatenated store event modeled retrieval download operations pro-ftpd exploitation phase table boundary preparation exploitation phases set arbitrarily operational meaning boundary exploitation confirmation phases signals nids raise attack alert important set interpretation attack case pro-ftpd clear retrieval operation marks end attack confirmation phase pro-ftpd consists single event opening unix shell unlike case ftpcwd shell opened tcp connection server port identify activity defined event matches communication occurs port pro-ftpd false positives pro-ftpd invariant states successful pro-ftpd attack end login ascii states formally defined ftp type ftp login variables ftp model table search false positives negatives initialize variable ftp type default proftpd server proftpd enables administrator determine default mode performed search ascii default binary default representation mode ascii gard verified pro-ftpd specification false positives respect invariant default binary gard found false positive sequence type login store retv retv sequence matches signature ends binary mode implement attack type effect appears login procedure sequence matches signature intersection languages login ftp type enforce required order events login type figure problem type pattern pattern intends ensure type event type star gard instantiates set whenbinary default mode performing logout login quit login events behaves switches mode back binary modified type star star star change gard verified false positive exists default mode binary pro-ftpd false negatives illustrate iterative process found false negatives initial pro-ftpd signature iteration gard provided sequence match signature satisfies invariant manually round sequence type figure attack invariants invariant model refinement signature fix original false neg ftp login true ftp type fix login ftp type compare figure pattern figure original spurious ftp login true ftp type store command instance attack original spurious ftp login true ftp type retv command instance attack original false neg ftp login true ftp type replace login ftp type login ftp type original spurious ftp 
login true ftp type limit length attacks limit attacker transformations ftp login true ftp type length table search false negatives -edit distance original sequence matches pro-ftpd signature table event definitions table round applied invariant refinements signature fixes performed round determined sequence false negative spurious sequence case refined signature refined invariant repeated steps satisfied signature accuracy searched false negatives -edit distance session signature assumed default representation mode ascii process found false negatives process hours experienced gard user false negative found gard replaced type retv command round table essentially gard showed default representation mode ascii type command required successful pro-ftpd attack successful login puts ftp session ascii mode figure changed pro-ftpd preparation phase expression represented figure removed type false negatives sequence gard replaced store command cwd round table store condition pro-ftpd thissequence false negative spurious sequence avoid type sequences added semantic model variable denoted counts number stores sequence ensure store command appears sequence gard surprisingly sequence gard replaced retv cwd round table sequence implement attack added variable counts retv commands ensure sequence retv commands gard added append command replaced store cwd round table false negative pro-ftpd attack implemented append store modeled append modeled store increment table anticipated false negative prevent added append command pro-ftpd preparation phase question store append equivalent general scope paper answer attack-dependent security analyst address ftp attack define gard affords analyst ability investigate implications decision defined commands equivalent gard warn analyst unforeseen false negative behavior undesired analyst disable easily sequence gard replaced retv command cwd increased length sequence include retv commands required attack invariants round table spurious sequence point editdistance mechanism limit transformations attackers perform section proftpd attack retv replaced cwd forbade replacement based restrictions imposed find false negatives summary gard evaluation analytically showed ftp-cwd session signature accurate snort contextual counterparts knowledge start login ascii original login ftp type pattern machine accept ftp sessions login representation mode set ascii default mode binary sequence results false positive section default ascii sequence results false negative section start login ascii login ftp type pattern false negative fix section pattern ensures login session ascii mode default ascii mode figure versions login ftp type pattern provide evidence signature accuracy gard taught tune pro-ftpd signature proftpd server configuration anticipate outcome began experiment experience shows constructing accurate regular expression delicate issue simple cases inaccurate expressions lead unforeseen false positives negatives learned effectiveness formal methods reveal inaccuracies remember gard guarantee signature lacks false positives negatives gard guarantees false positives negatives respect invariant underlying semantic model split pro-ftpd attack ftp sessions longer detected signature refinement signature handle cases left future work conclusion future work signatures based formal reasoning verifiable accuracy worthy paper step goal present methodology construct evaluate improve signatures intend continue work initial results operational cost session signature comparable current signatures table intend perform investigation issue session signatures hsms share machines signatures improve ability nids handle signatures simultaneously develop semantic models protocols acknowledgments deeply anonymous referees comments helped refine concepts presented paper aho sethi ullman compilers principles techniques tools addison-wesley alur yannakakis model checking hierarchical state machines foundations software engineering lake buena vista nov baker barnyard caswell poor alder babbin beale doxtater foster kohlenberg rash snort intrusion detection syngress edition security proftpd ascii file remote root exploit http securiteam exploits blackmoon blackmoon ftp server blackmoonftpserver cuppens ortalo lambda language model database detection attacks international symposium recent advances intrusion detection toulouse france oct dacier editor design intrusion-tolerant intrusion detection system ibm zurich research laboratory aug deliverable project maftia ist- maftia eckmann vigna kemmerer statl attack language state-based intrusion detection computer security ginsburg themathematical theoryof contextfree languages mcgraw hill handley paxson network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington aug holzmann spin model checker primer manual addison-wesley hopcroft motwani ullman introduction automata theory languages computation addison-wesley edition kari konstantinidis perron wozniak finite-state error edit-systems differencemeasures languages words technical report saint mary department mathematics computing science lippmann haines fried korba das analysis results darpa offline intrusion detection evaluation international symposium recent advances intrusion detection toulouse france oct marti thor tool test intrusion detection systems variations attacks master thesis swiss federal institute technology mar michel adele attack description language knowledge-based intrusion detection international conference information security paris france june mitre corporation cve common vulnerabilities exposures cve mitre morrissey saunders lowes roesen renner proftpd highly configurable gpl-licensed ftp server software proftpd mutz vigna kemmerer experience developing ids stimulator black-box testing network intrusion detection systems annual computer security applications conference lasvegas dec paxson flex version fast scanner generator free software foundation mar paxson bro system detecting network intruders real-time computer networks dec postel reynolds rfc file transfer protocol internet engineering task force pouzol ducass declarative signatures misuse ids international symposium recent advances intrusion detection davis oct pouzol ducass formal specification intrusion signatures detection rules ieee computer security foundations workshop nova scotia canada june ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks calgary alberta canada roesch snort open source network intrusion detection system snort rubin jha miller automatic generation analysis nids attacks annual computer security applications conference tucson dec security administrator newsletter instant poll snort implement intrusion detection system ids network oct http winnetmag poll sekar guang verma shanbhag high-performance network intrusion detection system acm conference computer communications security singapore nov sekar uppuluri synthesizing fast intrusion prevention detection systems high-level specifications usenix security symposium washington aug sommer paxson enhancing byte-level network intrusion detection signatures context acm conference computer communications security washington oct teitelbaum minimal distance analysis syntax errors computer programs phd thesis computer science department carnegie-mellon sep nss group intrusion detection systems ids group test edition nss ids edition index htm vigna kemmerer netstat networkbased intrusion detection system computer security vigna robertson balzarotti testing network-based intrusion detection signatures mutant exploits acm conference computer communications security washington oct wagner soto mimicry attacks host-based intrusion detection systems acm conference computer communications security washington nov ftp semantic model state ftp defined variables table alphabet model section denoted ftp set tokens defined table modeled common ftp commands modeled similar brevity define lexemes upper case letters ftp specification 
combination upper lower case letters events table form event library ftp model complete event defined table state change var values semantic comments user command issued pass command issued victim successful login alias ftp login section holds session representation type type alias ftp type section ascii binary ebcdic undefined holds session transmission mode mode stream block compressed undefined session passive mode max counts number files uploaded session max counts number files downloaded session table state variables ftp semantic model event token lexeme flow description user user user login pass pass user password cwd cwd change directory cquit quit client terminates session rein rein user logged session restarted pasv pasv enter passive mode type type change representation type ascii type type change representation type binary type type change representation type ebcdic mode mode change transmission mode stream mode mode change transmission mode block mode mode change transmission mode compressed retr retr retrieve file server stor stor store file server appe appe append file server dele dele delete file server list list list files server slogin star user successfully logged vquit star victim voluntarily terminates session arg str argument ftp command invalid response non-ftp response valid response start digit str denotes string ftp specification denotes match beginning line denotes alphanumeric precede command requires argument brevity add state variables required track type command table events transitions ftp semantic model rule description token single token valid expression star closure valid expression valid expression negation valid expression valid expression eop concatenation intersection union valid expressions valid expression token restricted event valid expression restricted valid expression data raw expr regular restriction imposed data attribute token length int regular restriction imposed length attribute token negationslash rop logical combination restrictions valid restriction table grammar construction regular expressions events 
condition element deterministic pda abbreviated dpda nition stack symbol pushed popped stack general nition pda found stack symbol pushed stack easy pda general nition converted pda conforms nition construction essentially transforms pushing symbols stack sequence pushes symbol pda con guration tuple current state string stack symbols representing stack contents con gurations transformed sequence transitions pda consuming input relation extended words con gurations transformed sequence transitions pda consuming input string clear context simply write language accepted dened fwj pdas accept context free languages cfl language accepted dpda called deterministic context free language dcfl theorem proves cfl homomorphic dcfl proof theorem procedure determinizing pda expanding input alphabet proof similar chomsky theorem cfl exists dcfl homomorphism proof pda accepting construct input alphabet types symbols input input symbol input symbol represents consuming input transitioning state push input symbol input symbol represents consuming input pushing stack transitioning state pop input symbol input symbol represents consuming input popping stack transitioning state construct dpda notice components input alphabet transition relation transition relation dpda ned transition transition transition transition transition transition easy deterministic homomorphism language accepted dpda construction proof theorem expands input alphabet exposing stack operations target state transition input symbol dpda consume input push stack transition state suppose pda models program case dpda models program internal state program stack activity exposed words exposing program state corresponds input alphabet expansion theorem intrusion detection pdas dpdas model-based intrusion detection constructs model program figure generates sequence symbols sequence system calls receiving symbol program model determines exist transitions symbol exist transition input symbol monitor reports intrusion model processes symbol updates state pda models suppose model pda state model set con gurations model initial state set con gurations processing sequence symbols suppose symbol generates state program succ represents con gurations result con gurations processing input formally succ ned succ empty monitor reports intrusion state model succ processing continues general state model nite suppose model state receives symbol assume model transitions easy succ nite set notice niteness arises rule corresponds left recursion program turns state model set con gurations regular represented nite-state automaton time space complexity updating state model receiving symbol cubic size model wagner dean concluded operating pda model intrusion detection prohibitively expensive dpda models suppose model dpda input symbol con guration dpda exists con guration easy monitoring set con gurations conguration time space complexity updating state model receiving symbol stack-deterministic pda models experience nondeterminism stack activity major contributing factor time space complexity operating pda models motivates nition stack-deterministic pda model non-determinism requires state stack left unchanged points nondeterminism formally pda called stack-deterministic pda sdpda satis conditions condition stack activity -transitions push pop transition condition stack activity depends input symbol top stack exist states necessarily assume sdpda model program intrusion detection set con urations obtained processing sequence symbols conditions con gurations stack formally set states stack alphabets model size jqj time space complexity processing symbol language accepted sdpda called stack-deterministic context free language sdcfl theorem appendix proves language accepted sdpda dcfl sdpda fundamentally powerful dpda theorem cfl exists sdcfl homomorphism proof pda accepting construct set input symbols types symbols input simply input alphabet pda push input symbol input symbol represents consuming input pushing stack pop input symbol input symbol represents consuming input popping stack construct sdpda psd notice components psd input alphabet transition relation transition relation sdpda psd ned transition transition transition transition transition transition easy psd stack-deterministic homomorphism psd language accepted psd psd construction proof theorem expands input alphabet exposing stack operations input alphabet sdpda consume input push stack recall proof theorem expanded input alphabet expose stack activity target transition consume input push stack transition state constructing sdpda exposed stack activity pda target transition table summarizes time space complexity processing symbol models size input alphabet models shown theorems clear size input alphabets dpda sdpda models larger pda model time complexity space complexity input alphabet size pda dpda knr sdpda table time space complexities processing input symbol models number states transitions model denoted size input stack alphabets pda denoted connection existing techniques authors proposed exposing program state improve precision models sekar propose program counter information equivalent expanding input alphabet expose target transition gif feng expose stack activity program context equivalent expanding input alphabet exposing stack activity similar homomorphism demonstrated proof theorem formal framework pda dpda sdpda homomorphisms systematic understanding evaluating techniques expose additional program state vpstatic model determinizing stack exposure vpstatic model statically-constructed variant context-sensitive vtpath model dynamic counterpart stackwalks execution determine call stack state monitored process combined program counter monitoring produces extra symbols fully determinize model model generation static analysis vpstatic model generated statically analyzing binary executable program rst introduce notation function entry state entry exit state exit function executable system call state system call instruction call site entry state state call exit state state return function call site addr addr addr denote address system call function call instruction addr addr func function instruction address states char filename pid pid int prepare int index entry prepare char buf pid index getpid getpid strcpy buf filename return open buf rdwr open exit prepare void action entry action uid uid getuid getuid int handle uid handle prepare read handle read handle prepare write handle write close handle close exit action figure simple code fragment simple program fragment shown figure running automaton left side list transitions figure describe non-deterministic pda program similar callgraph model callgraph model system call numbers observed inputs simulate automaton commonly place holder transitions system call pda non-deterministic exposed stack activities targets transitions make pda deterministic extract address information binary expose internal state automaton side list transitions figure describe nal dpda input symbols dpda forms proof theorem slight modi cations system call call site states addr expose state address information extract program counter call stack dynamically monitoring program executions addr means automaton consumes input symbol pops stack transitions state equivalent transition proof theorem symbols similarly explained forms input symbols figure formal models section proved pushdown automaton deterministic detailed description model appendix online detection dynamic monitoring pro generated simulate automaton online program monitoring sysentry action getuid read write close exit action entry 
prepare getpid exit prepare open getuid addr getuid addr addr read addr read write addr write close addr close close addr close exit action getpid addr getpid open addr open exit prepare entry prepare addr entry prepare addr addr addr addr addr getuid read write close close getpid open push addr push addr pop addr pop addr figure pda vpstatic dpda generated code exit func exit func exit func entry func entry func entry func figure vpstatic input symbol sequence generated system call tem call made extract call site addresses functions returned virtual stack list vsl ordered outermost function innermost function nition vsl similar assume virtual stack lists current system calls assume current system call address current program counter system call address suppose rst index items equal current system call generate sequence input symbols feed automaton input symbol sequence generated shown figure assume ordinary user root executes program runs getpid line figure virtual stack list pre addr pre sequence addresses functions lead toaction system call getpid program executes open virtual stack list call stack change system call open figure symbol sequence generated open addr sopen successfully leads automaton state sopen attacker ows buffer strcpy change return address prepare addr gain unauthorized write access prepare returns case virtual stack list pre addr addr addr figure symbol sequence generated exit prepare addr addr addr entry prepare addr open addr sopen state sgetpid transition exit prepare alarm triggered intrusion detected input symbols generated system call processed current state state system call current automaton stack context vsl system call current state stack context uniquely decided valid system call transition follow input symbol anomalous execution indicative intrusion attempt occurred action prepare getuid getpid openprepareprepare writeread close figure local dyck models dyck model determinizing instrumentation shown section adding stack determinism pda requires additional alphabet symbols make stackmodifying transitions deterministic statically constructed program models pda stack model running process call stack stack operations occur function call sites returns dyck model binary rewriting insert code function call site generate extra symbols needed stackdeterminism static model construction dyck static analyzer reads binary program image produces dyck model instrumented version binary requires steps function construct control graph cfg convert cfg local model nondeterministic nite automaton accepts sequences function calls kernel traps function generate correct execution classify function calls insert code function call sites generate symbols stackdeterminism instrumentation adds events call stream update local models match combine collection modi local models single sdpda modeling entire rewritten program recall figure shows code functions prepare action show source code readability analyze sparc binary code convert function cfg local model straightforward cfg non-deterministic nite state machine edges unlabeled basic block user call kernel trap site label outgoing void action uid uid getuid int handle uid precall handle prepare postcall read handle precall handle prepare write handle close handle postcall figure code dyck instrumentation inserted code appears boldface edges block call label edges convert basic blocks automaton states -reduced minimized local automata code shown figure appendix formal nition local model add edges local models function call transitions model call stack occurring runtime edge call transition pushes unique identi pda stack runtime monitor edge call pops identi call site unique push pop symbol monitor differentiate call sites function nfa local models pdas add stack-determinism pda models add symbols event stream distinguish stack operation analyzer rewrites binary image program inserting history stack program data space adding code immediately call site history stack records stack occurring kernel trap precall code call site pushes symbol history stack call generates kernel trap returning monitor reads collected symbols history stack identify execution path program call returns generating kernel trap postcall code pops history stack discards adds symbol history stack figure shows rewritten code action instrumented call sites prepare adding code instrumentation recursive call sites potentially high runtime cost add stack transitions local models code binary image call sites recurse lastly compose collection modi local automata points function calls form global model action prepare getuid getpid open writeread close figure dyck model entire program analyzer replaces function call transition -edges entering returning model target function figure shows completed dyck model functions note similarity vpstatic model earlier input symbol additionally pushes identi pda stack symbol input symbol pops appendix formally nes model language theory dyck model sdpda appendix runtime monitoring user executes rewritten binary securitycritical environment runtime monitor tracing execution system calls monitor enforces model guaranteeing process execution deviate sequences system call streams dyck model operation straightforward vpstatic operation model pda monitor pda stack due stack-determinism traced process generates kernel trap monitor reads saved symbols process history stack symbol input automaton modi stack state corresponds return call function symbols equivalent virtual path symbols calculated stack walks vpstatic model monitor processes kernel trap symbol permitting execution symbol valid transition model performance measurements compare performance vpstatic dyck models measured costs execution monitoring measured increase execution time monitoring calculated increased memory due program models dyck instrumentation analyzed performance test programs tools build models statically-linked programs result set test programs representative greatest security concern mix computation-intensive syscallintensive programs table lists programs workloads statistics htzipd proprietary implementation httpd httpd implementation successfully compiled statically solaris execution time overheads calculated subtracting base execution time monitored execution time times averaged runs execution times include setup time monitor program model read disk current implementation vpstatic dyck monitors execute user space detect system call events solaris process tracing evaluate cost operating model base execution time measured process tracing enabled system call stop monitor resume execution stopped process difference base time monitored time captures overhead model operation calculated memory usage similarly interest increase state required process static code monitoring process meaning shared audited processes vpstatic model compute process state taking difference memory full auditing enabled empty pro loaded auditing disabled memory dyck model includes cost binary code inserted original application section include measurements previously average branching factor metric metric poorly suited measurements context-sensitive languages stack transitions entering system call wrapper functions obscure reachable system calls lacking metric rely theoretical discussions previous sections evaluation strength models strength metrics applied future research develops reasonable measurement algorithms 
execution time overhead results table execution time overheads vpstatic dyck models base execution times presented differences monitor implementations result base times due high cost stack walk operation vpstatic model separate model runtime components time operate automaton time perform stack walk dyck model walk call stack separation presented program workload instructions functions call sites htzipd service client requests transferring total gzip compress tar cat concatenate les totalling table test programs workloads statistics vpstatic dyck program untraced base automaton stackwalk base automaton htzipd gzip cat table model execution times seconds base execution time includes system call tracing automaton operation percentages compare base execution program vpstatic dyck htzipd gzip cat table average system call veri cation time microseconds table shows average monitor execution time microseconds system call event received system call requires monitor update calling context information verify system call valid operation program model times perform operations remained constant number stack symbols read monitored process changed outlying points occur tables show interesting results deterministic stack-deterministic models cient operate automaton operations deterministic vpstatic model extremely fast vpstatic model cient operate dyck model result occurs reasons illustrates operational differences deterministic stack-deterministic automata dpda vpstatic model operates constant time sdpda underlying dyck model requires linear time operation table effect visible respective runtimes models dyck model additional execution function call sites due injected code cost arises process execution path generate system calls vpstatic model incurs monitoring cost system call events memory overhead results table presents memory execution monitoring models divide memory costs dyck model cost current rewriting infrastructure doubles size program code segment cost code insertions state machine representation infrastructure cost excessive signi cantly reduced shifting efcient rewriter vpstatic state machine cost greater dyck models highlights differences dpda sdpda models automaton allowing non-determinism state transitions naturally compact representation dyck model produce smaller automaton structures vpstatic model optimized vpstatic model size remove function entry exit nodes techniques similar automaton reduction dyck model original format model recent development conceptually clearer discussion draw primary conclusions work formalisms deterministic stack-deterministic push-down automata result highly accurate highly cient program models non-deterministic contextsensitive models produced overheads orders magnitude worse base execution suitable real-world operation automaton operation overheads low show context-sensitivity precise program models sacri ced performance differences models suggests hybridization construction monitoring techvpstatic dyck program unmonitored state machine infrastructure instrumentation state machine htzipd gzip cat table memory due monitoring percentages increases unmonitored execution niques bene cial dyck model produces context information points recursion dynamic linking non-instrumented binaries vpstatic model identify missing information inspecting existing program state instrumented libraries dyck model easily libraries runtime memory offsets return addresses issue dyck model successfully reveal context information optimized binaries stack walking difcult impossible hand binary rewriting occasionally fail rely stack walk technique recover state information likewise limit instrumentation set critical program points rely stack walking hybrid model combine state recovery mechanisms capture complete context system call hybrid gain strengths models minimizing drawbacks limitations approaches produce sensitive accurate models approaches limitations documented attackers exploit weaknesses limitations intrusion detection models avoid detection short complete instrumentation amounts essentially interpreting program statically-generated models complete information state executing program attacker exploit incomplete information model evade hids incomplete sensitivity models discussed paper incorporate information stack activity program models context sensitive model track predicates branches path sensitive incompleteness result model allowing extraneous behavior code fragment char str user str char calloc user char calloc strncmp user admin sys sys strcpy str someinput strncmp user admin sys sys system call sequences code fragment sys sys sys sys sequences correspond predicate strncmp user admin true false notice predicates branches models track values branch predicates sequences sys sys sys sys sys sys sys sys attacker exploit limitation avoid detection attack large someinput strcpy str heap change user user guest strcpy user admin illegal sequence sys sys executed accepted model attack detected incomplete set events events monitored model system calls pointed wagner soto tan attacker evade detection generates sequence events accepted model previously presented attack code segment system calls buffer-overflow occurs program jumps regular user return super user privileges execve bin attack buffer force program jump illegally obtain root shell inserting code instrumentation models miss attack system call code segment call words matter program control illegally modi code segment observable events models code instrumentation added call attack detected model attack evade detection simply replaces system call parameters recover arguments system calls static analysis system calls incomplete information arguments playing inside sandbox mimicry attacks assume attackers complete knowledge model-construction algorithm mimicry attacks adversary transforms attack resulting sequence accepted detection model attacker mimic legal program behavior generating legal system calls inserting original attack sequence attacker attack sequence semantically equivalent original attack sequence attacks easily evade simple detection models n-gram model proposed incorporating additional information program model makes dif cult mount mimicry attacks models monitors information system calls program counter call stack mount successful mimicry attack adversary required produce correct call stack program counter information sequence system calls equivalent attack conclusions formally statically-constructed contextsensitive program models host-based intrusion detection seeking add ciency precision models examined deterministic pdas introduced stack-deterministic pdas proofs language equivalence homomorphic image dcfl sdcfl cfl give rise monitoring techniques make models vpstatic model walks process call stack harvest return addresses revealing context information enabling deterministic model program instrumentation dyck model eliminates stack non-determinism experiments demonstrate contextsensitivity ciency coexist program models bene ting intrusion detection systems acknowledgments anonymous referees comments members wisa security group wisconsin provided ongoing feedback work acknowledge weibo gong massachusetts discussion support prahlad fogla oleg kolensnikov georgia institute technology provided ongoing feedback work eel analyze sparc binary code work supported part army research ofce contract daad naval research grant nsf grants ccrand ccrand department energy grants defg de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices xed thereon views conclusions contained authors interpreted necessarily representing cial policies endorsements expressed implied government agencies government chomsky context-free grammars pushdown storage quarterly progress report pages massachusetts institute technology research laboratory electronics april feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland california forrest hofmeyr somayaji longstaff sense unix processes ieee 
symposium security privacy pages los alamitos california garvey lunt model-based intrusion detection national computer security conference ncsc baltimore maryland june ghosh schwartzbard schatz learning program behavior pro les intrusion detection usenix workshop intrusion detection network monitoring santa clara california april gif jha miller detecting manipulated remote call streams usenix security symposium san francisco california august gif jha miller cient context-sensitive intrusion detection annual network distributed systems security symposium ndss san diego california february hofmeyr somayaji forrest intrusion detection system sequences system calls journal computer security hopcroft motwani ullman introduction automata theory languages computation addisonwesley edition ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march fink levitt automated detection vulnerabilities privileged programs execution monitoring annual computer security applications conference acsac orlando florida december lane brodley temporal sequence learning data reduction anomaly detection acm transactions information system security august larus schnarr eel machine independent executable editing sigplan conference programming language design implementation pldi jolla california june lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy oakland california lunt automated audit trail analysis intrusion detection survey national computer security conference ncsc baltimore maryland october paxson bro system detecting network intruders real-time computer networks december ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks january http aciri vern ptacek-newsham-evasionps schwoon model-checking pushdown systems dissertation technische universitcurrency mcurrency unchen june sekar bendre bollineni dhurjati fast automaton-based method detecting anomalous program behaviors ieee symposium security privacy oakland california tan killourhy maxion undermining anomaly-based intrusion detection system common exploits recent advances intrusion detection raid lncs pages zurich switzerland october springer-verlag tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding lncs noordwijkerhout netherlands october springer-verlag teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy oakland california wagner static analysis computer security techniques software assurance dissertation california berkeley fall wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wagner soto mimicry attacks host-based intrusion detection systems acm conference computer communications security ccs november warrander forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy oakland california wespi dacier debar intrusion detection variable-length audit trail patterns recent advances intrusion detection raid lncs pages toulouse france october springer-verlag proof section theorem language accepted sdpda dcfl proof remove transitions sdpda recall sdpda stack activity -transitions states stack symbol exists -transition exive transitive closure notice computed polynomial time standard graph reachability algorithms transform transition relation remove transitions nontransitions transition remove state non-determinism due step assume sdpda -transitions remove state non-determinism standard subset construction determinizing nfa sdpda -transitions construct dpda subsets ned set recall condition nition sdpda stack activity completely determined input top stack nition ned easy dpda accepts language sdpda nition vpstatic model expand notation section syscall system call made target target target function call site computation model dpda simple program fragment shown figure running automaton shown figure set states program states note kinds states automaton function entry states entry action entry prepare function exit states exit action exit prepare system call states getuid read call site entry states call site exit states input alphabet input symbols dpda forms proof theorem slight modi cations system call call site states addr expose state addr means automaton consumes input symbol pops stack transitions state equivalent transition proof theorem symbols similarly explained proof theorem online detection monitor call stack program counter expose address information addr placeholder system call involved transition forms input symbols figure stack alphabet model faddr function call site stateg initial stack start symbol automaton stack dpda simulate program call stack start state entry state program entry function set accepting states require program exit set states exit system calls program killed anytime set states program program fragment start accept state set shown figure transition function automaton constructed interconnecting transformed control graph function states connected transition function call intra-function transition call inter-function transition intra-function transitions marked input symbols form deal automaton stack figure transition close addr close means current state read program issues system call close observe program counter addr close current state moved close inter-function transitions modify automaton stack exist call site entry state target function entry state target function exit state call site exit state call site entry state target function entry state add transition label addr means program calling function push address call site automaton stack figure transitions belong case call site exit state target function exit state add transition label addr addr means follow transition address call site program returning matches top symbol automaton stack pop address figure transitions belong case completes model nition formal models section proved pushdown automaton deterministic note recursive function call return transitions handled non-recursive nitions proofs section nition dyck model set system call sites traps operating system set function call sites denote target function call site note call sites unique nition local model control graph program vertex call site local model function unique cfg entry state cfg exit nition simply labels cfg edges section local models -reduced minimized reduce storage requirements nition global dyck model depends classi cation function call sites partition recurse generate system call returning recurse conditionally generate system call returning recurse generate system call returning recurse write denote nition dyck program model range functions entry point function symbols proof theorem dyck model exists -reduction properties nition require explanation property adds push pop symbols alphabet system calls property maintains system call transition property local automata system call modify stack state property adds -edges call sites generate system call properties link automata recursive call sites -edges edges update pda stack properties describe transitions precalls postcalls modify stack state stack-determinism dyck model theorem dyck model sdpda proof dyck model pda sdpda condition satis suppose proof contradiction cases property property property sdpda condition holds 
crosswalk tool performance pro ling user-kernel boundary parco preprint alexander mirgorodskiy barton miller fmirg bartg wisc computer sciences department wisconsin madison wisconsin usa october abstract performance pro ling application programs challenging task problem analysis applications spend signi amount time operating system result conventional user-level pro lers trace performance bottleneck system call information insu cient programmer deal performance problem system calls complex making hard pinpoint problem address ciency designed tool called crosswalk performance analysis kernel boundary crosswalk starts pro ling user level pro les main function callees walks application call graph ning performance problem function determines function system call walks kernel code starts traversing kernel call graph locates ultimate bottleneck key technologies crosswalk dynamic program instrumentation dynamic kernel instrumentation existing library called dyninst api designed framework called kerninst api interface modeled dyninst combined libraries provide uni powerful interface building cross-boundary tools demonstrate usefulness cross-boundary approach analyzing squid proxy server crosswalk drilling kernel identify ultimate performance problems remove modifying application source code introduction application programs make heavy functions provided operating system naturally performance applications depends make functions ciently functions implemented operating system key ciency high-performance applications network performance constraining factor tools web proxy servers cient synchronization primitives crucial multithreaded applications finding performance problems os-bound applications challenging task user-level pro ler locate region program code system time spent unable explain happening problem application spent time open system call pro ler detect report programmer open complex system call create les truncate existing network distributed systems knowing exact problem programmer opaque boundary user kernel spaces continued pro ling kernel ning open bottleneck pro ler performance problem truncation option open information programmer modify application work bottleneck avoid truncating les open alternatively programmer tune kernel parameters make problem tuning standard operating system interface obviating kernel recompilation reboot goal work demonstrate cross-kernel pro ling feasible ective nding performance problems approach based idea dynamic instrumentation traverse call graph search bottlenecks technique studied call graphs user applications generalize seamlessly walk joined call graph application kernel key technologies dynamic program instrumentation dynamic kernel instrumentation existing library called dyninst api designed framework called kerninst api interface modeled dyninst synergy libraries uni powerful interface developing cross-kernel tools bringing pieces designed tool called crosswalk locate bottlenecks application program seamlessly cross kernel boundary bottlenecks kernel code crosswalk performance bottleneck ned main program entry point application code kernel space kernel function ultimate problem crosswalk simple prototype proved valuable nding performance problems study squid proxy server crosswalk results boost squid performance standard workload factor related work exist tools accomplish parts goal combined pro application program gprof pro kernel kgmon kernprof analysis set bottlenecks user space set kernel-space bottlenecks understanding sets related easy task fact found kernel bottlenecks induced processes connection process study disjoint tools insu cient understanding problem complete tools cross-boundary analysis exist erent technologies implementing tools sampling tracing pro ling source-code modi cation dynamic instrumentation crosswalk dynamic instrumentation works production systems cycle-accurate timing results overhead narrowing choice dynamic instrumentation choose program instrumentation frameworks number options kernel instrumentation smaller dprobes appears maintained dprobes cient functionality purposes instrumentation trap-based experience overhead traps prohibitively high performance monitoring basic technology ective search performance bottlenecks walk application call graph dynamic instrumentation paradyn technique bottlenecks user code sections describe call-graph walking dynamic instrumentation greater detail call-graph walking assume searching performance bottleneck function takes amount wall-clock time total running time program call-graph approach mimicks experienced performance analyst searching bottleneck step-by-step diagram shown figure method examines functions called directly main program entry point inclusive time spent function threshold search marks bottleneck bottleneck examining callees function bottleneck search refine main refine final bottleneck current bottleneck current bottleneck main main main figure walking call graph instrumentation code instrumentation toolapplication user libdyninstapi dyninst-based system instrumentation tool instrumentation code kernel libkerninstapi kerninst-based system figure frameworks dynamic program kernel instrumentation descend function continue reaches function callees threshold callees function nal user-space bottleneck searching identi function system call crosswalk analysis stop tool seamlessly walks kernel starts system call entry point descends callees nal in-kernel bottleneck identi result analysis chain functions connecting main located bottleneck collect performance data dynamic instrumentation program running tool injects code function entry point start timer code exit points stop timer code removed longer needed approach require program source code modi cation recompilation discuss detail program instrumentation dyninst api crosswalk dyninst api application program instrumentation dyninst library write instrumentation tools typical structure tool shown figure library lets attach running program perform operations instrument tool generate instrumentation code library inject speci point program functionality crosswalk puts timing code functions browse code resources tool locate program modules functions basic blocks retrieve control information crosswalk facilities locate main identify functions called function walk call graph inspect modify program data tool read write program variables program running functionality crosswalk peeks values timers instrumentation code created kernel instrumentation kerninst api dyninst api instrument user applications drill kernel mechanism experience kernel instrumentation designing kernel performance timer variable function total tick start start tick instrumentation total time start time timing function hash table call push regular call indirect call callee caller hash table call instrumentationfunction identifying callees function figure major building blocks crosswalk monitor called kperfmon reasonable amount ort factored instrumentation-related functionality library called kerninst api kerninst api closely modeled dyninst api functionality interface syntax programmer single consistent model program kernel instrumentation finally enable tools crosswalk designed kerninst api coexist dyninst application typical kerninst-based system shown figure system important properties instrumentation tool injects code kernel tool user-space program kerninst works standard production operating system recompile kernel reboot machine tool simply attaches kernel starts instrumenting kerninst requires user root privileges system allowing user insert execute code kernel security hole implementation major issues implementing crosswalk time function function callees walk call graph similarity dyninst kerninst apis implement features uni kernel user spaces timing crosswalk figure shows sketch instrumentation insert function interest provide cycleaccurate results low overhead code processor hardware counters timer readings samples cycle counter entry point function samples exit point computes delta code executes per-function timer variable accumulates total number wall-clock cycles spent function note approach easily extended handle types performance metrics cpu time number 
cache misses crosswalk similar primitives timing application kernel code erence kernel constrain timing process study multiple threads execute kernel function timer ect time spent process thread crosswalk achieves goal wrapping kernel start stop primitives check proper process identi running thread check fast taking instructions identifying function callees function proves bottleneck crosswalk function callees dyninst kerninst api provide method identifying callees static analysis method locates call instructions function extracts destination addresses static analysis works cases fails analyze indirect calls destinations computed run time constructs common practice calls function pointers callbacks virtual functions translated indirect call instruction main storecreate open storeswapout open copen syscall trap ufs create httpreadreply bottlenecks original version eventrun storeufsunlink unlinkdunlink syscall trap select main poll swtchcv waituntil sig bottlenecks tuned version figure squid bottlenecks links dashed functions omitted brevity crosswalk solves problem paradyn instruments indirect call sites identify callees run time figure shows call-site instrumentation invoked callee address computed instrumentation simply adds hash table result hash table callees invoked watched sites approach worked support indirect calls crosswalk advance past system call entry point system call handlers dispatched indirect call experimental results squid popular technique optimizing web transfers proxy caching places intermediary proxy server web servers clients caches server responses clients technique takes extra load web servers network infrastructure ectiveness heavily depends performance proxy server study years ago found xed performance problems popular open-source proxy called squid crosswalk current version program enhanced ran squidstable sun ultraworkstation ultrasparc-iii mhz processor ram ide hard drive mbit network card -bit version solaris model typical web activities subjected standard workload wisconsin proxy benchmark workload issues concurrent requests clients erent web servers squid benchmark measure performance wall-clock time takes serve requests requests client crosswalk attached squid found chain functions shown figure wallclock time threshold white nodes belong application gray kernel functions httpreadreply storeswapout receive object web server store on-disk cache bottlenecks network read write problem surprisingly bottleneck open system call skimming source code squid storecreate realized calls open correspond opening individual cache les creating objects point user-level pro ler stop crosswalk drill kernel traced open bottleneck ufs create routine apparently squid spends time creating les on-disk cache remove bottleneck crosswalk found pre-create les squid cache object web server squid open existing sized save object avoiding create obstacle approach squid removes les cache periodically cache size control result eventually fall back original mode creating les obstacle minor modify squid source remove les simply truncate size discovered squid support truncation strategy enabled default turned recompiling squid parameters running time wisconsin proxy benchmark dropped factor seconds original scheme removing les seconds modi truncating les optimize squid ran crosswalk discovered problems shown figure user-space bottleneck unlinkdunlink function calling select nement kernel suggests squid simply blocks condition variable waituntil sig switched-out swtch chain kernel activity problem program examined source unlinkdunlink found waiting squid helper daemon unlinkd consumes le-truncate requests lled-up queue requests bursts give unlinkd chance catch simply making queue longer extended entries recompiled squid running time benchmark dropped additional seconds crosswalk correctly identi performance problem provided information estimate overhead pro ling ran benchmark multiple times crosswalk determined crosswalk increased total running time approximately isolate individual contributions application kernel instrumentation modi crosswalk perform application-only kernel-only call-graph walks found application instrumentation accounted approximately total slowdown kernel overhead low prevent crosswalk nding correct bottlenecks future work identi directions improvement crosswalk rst support analysis multithreaded applications current parallel system programs multiple threads paradyn search user-space bottlenecks multithreaded programs providing matching support kernel-space analysis straightforward direction future work account asynchronous kernel activities programs spend lot time kernel perform system calls typical out-of-core application main memory ers excessive paging activities application crosswalk narrow problem user-level function takes time kernel system call entry point bottleneck account activities walk kernel call graph entry points simultaneously feasibility approach studied almeida cao wisconsin proxy benchmark technical report computer sciences department wisconsin-madison april buck hollingsworth api runtime code patching journal high performance computing applications winter cain miller wylie callgraph-based search strategy automated performance diagnosis euro-par munich germany august derose hollingsworth hoover dynamic probe class library infrastructure developing instrumentation performance tools international parallel distributed processing symposium april graham kessler mckusick gprof call graph execution pro ler sigplan symposium compiler construction boston june kernprof http oss sgi projects kernprof mckusick gprof tune bsd kernel european unix users group meeting april miller clark hollingsworth kierstead lim torzewski ipsthe generation parallel program measurement system ieee transactions parallel distributed systems april mohr brown malony tau portable parallel program analysis environment conpar vapp linz austria september moore dynamic probes generalised kernel hooks interface linux annual linux showcase conference atlanta october pearce kelly field harder gilk dynamic instrumentation tool linux kernel international conference computer performance evaluation april reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance analysis environment scalable parallel libraries conference los alamitos october ronsse bosschere jiti robust time instrumentation technique workshop binary translation philadelphia october tamches miller dynamic kernel instrumentation kernel application tuning international journal high performance computing applications fall wessels squid internet object cache http squid nlanr net squid august miller naim dynamic instrumentation threaded applications acm sigplan symposium principles practice parallel programming atlanta 
mrnet software-based multicast reduction network scalable tools philip roth dorian arnold barton miller computer sciences department wisconsin madison dayton madison usa pcroth darnold bart wisc abstract present mrnet software-based multicast reduction network building scalable performance system administration tools mrnet supports multiple simultaneous asynchronous collective communication operations mrnet flexible allowing tool builders tailor process network topology suit tool requirements underlying system capabilities mrnet extensible allowing tool builders incorporate custom data reductions augment collection built-in reductions evaluated mrnet simple test tool integrated existing real-world performance tool tool back-ends realworld tool mrnet multicast simple data reductions custom histogram clock skew detection reductions experiments mrnet-based tools showed significantly performance tools mrnet average message latency throughput tool start-up latency performance data processing throughput keywords scalability tools multicast reduction aggregation introduction desire solve large-scale problems areas climate modelling computational biology particle simulation driven development increasingly large parallel computing resources steady deployment traditional high-end parallel systems processors asci systems usa japan earth simulator hpcx coupled low price performance ratio commodity hardware desire led proliferation clusters hundreds thousands nodes performance debugging system administration tools work small-scale environments fail scale systems applications larger address problem developed mrnet infrastructure providing scalable multicast data aggregation support designed scalable tools parallel tool functionality divided categories data collection analysis presentation control application processes activities implemented components tool system components typical tool system shown figure tools totalview paradyn follow organization data collection process control occurs tool back-end components called tool daemons running nodes parallel distributed system user interacts tool user interface component data analysis high-level control implemented separate component co-located tool backends analysis user interface implemented component commonly called tool front-end tool activity cost activity cost larger underlying system support activity limits tool scalability costs categories computation tools incur computation cost processor executes code implements tool functionality tool obvious computation cost data analysis tool pays computation cost activities data collection user interaction communication tools incur communication cost transfer data tool components tools incur communication cost transfer data back-ends analysis analysis occurs system collected work supported part department energy grant de-fg lawrence livermore national lab grant nsf grants cdaand eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee november phoenix arizona usa copyright acm analysis centralized communication cost transferring control requests responses tool system tools parallelized analysis incur communication cost exchanging data analysis components finally tool analysis user interface activities implemented tool component communication cost transfer analysis results user interface component display storage tools analyze data collected called post mortem tools store data analysis tools pay storage cost data stored examples tools leave data storage local nodes collected transfer data centralized file server types tools pay costs times characterize tool based performs bulk data analysis on-line tool analyzes data monitored system application running tool pays communication cost transferring data analysis system application runs on-line tools closed-loop tools dynamically control application system based analysis tool on-line analysis avoid cost storing data collection analysis contrast post mortem tool stores collected data files database off-line analysis depending data stored analysis tool incur pre-analysis communication cost data collected data collected mrnet parallel tool infrastructure reduces cost important tool activities mrnet-based tools incorporate tree processes tool front-end back-ends shown figure mrnet internal processes distribute tool activities reducing analysis time keeping tool front-end loads manageable mrnet-based tools send data front-end back-ends logical flows data called streams mrnet internal processes filters synchronize aggregate data tool front-end filters manipulate data parallel passes network mrnet efficiently compute averages sums complex aggregations back-end data type communication structure examined previously features make mrnet wellsuited general facility building scalable parallel tools flexible organization mrnet dictate organization mrnet tool processes mrnet process organization configuration file common network layouts ary k-nomial trees custom layouts tailored system running tool mrnet internal processes allocated dedicated system nodes co-located tool back-end application processes mrnet off-load data aggregation processing tool frontend single connection frontend top-most mrnet internal process scalable flexible data aggregation mrnet builtin filters provide efficient computation averages sums concatenation common data reductions custom filters loaded dynamically network perform tool-specific aggregation operations paradyn custom filters implement scalable algorithm detecting figure components typical parallel tool mrnet-based parallel tool shaded boxes show potential machine boundaries user interface analysis control back-end process back-end process back-end process user interface analysis control back-end process back-end process back-end process mrnet internal ocesses clock skew tool front-end paradyn daemon paradyn custom histogram filter place back-ends equivalence classes based program resources functions discovered back-end high-bandwidth communication mrnet transfers data tool system efficient packed binary representation zero-copy data paths reduce cost transferring data internal processes scalable multicast number back-ends increases serialization sending control requests limits scalability existing tools mrnet supports efficient message multicast reduce cost issuing control requests tool front-end back-ends multiple concurrent data channels mrnet supports multiple logical streams data tool components data aggregation message multicast takes place context data stream multiple operations upward downward active simultaneously mrnet part larger effort improve scalability reliability resiliency parallel performance system administration tools mrnet addresses problem non-scalable global data processing non-scalable global command control global data processing aggregation data processes application nodes system local data processing collection analysis data single process system node aspects scalability work involve distributed strategy automatically finding application performance problems distributed performance data management scalable visualizations performance analysis results paper introduces mrnet evaluates scalability reliability resiliency characteristics addressed future work context work paradyn parallel performance tool supporting automated application performance problem searches section detail mrnet concepts implementation api section describes experience integrating mrnet paradyn performance tool section presents quantitative analysis investigating mrnet impact tool scalability discuss mrnet relates previous work area section multicast reduction network mrnet customizable high-throughput communication software infrastructure parallel tools mrnet main components libmrnet library linked tool front-end back-end components mrnet commnode program runs intermediate nodes interposed front-end back-ends mrnet library exports api enables interaction front-end groups back-ends mrnet mrnet commnode program distributes data processing functionality multiple computer 
hosts implements efficient scalable group communications present overview mrnet architecture discussions interface internal process implementation data aggregation mechanisms system instantiation process network topology issues mrnet overview mrnet library libmrnet tool network internal processes communication substrate tool front-end back-end processes internal processes instances mrnet commnode program connection topology host assignment processes determined configuration file geometry mrnet process tree customized suit physical topology underlying hardware mrnet generate variety standard topologies users easily topologies section discussion mrnet process topologies mrnet communicators represent groups network end-points communicators mpi mrnet communicators provide handle identifies set end-points point-to-point multicast broadcast communications contrast mpi applications typically non-hierarchical layout potentially identical processes mrnet enforces tree-like layout processes rooted tool front-end mrnet communicators created managed front-end communication allowed tool front-end back-ends back-ends interact directly mrnet limitation reflects design current run-time tools relaxed future appears demand interaction stream logical channel connects front-end end-points communicator toollevel communication mrnet streams streams carry data packets downstream front-end back-ends upstream back-ends front-end stream unique stream identify packets stream mrnet stream support multiple simultaneous streams communication components tool instance communication mrnet separate tool instantiations supported tool mrnet network instantiation data packets carry typed data enabling data aggregation operations stream types format string similar formatted primitives printf scanf packet data format string integer float character string mrnet adds specifiers arrays simple data types data aggregation process transforming multiple input data packets output packets aggregation result data data aggregations reduce modify data values common mrnet filters aggregate data packets filter bound stream stream created aggregation operation perform expected type data stream mrnet types filters synchronization filters transformation filters synchronization filters organize data packets downstream nodes synchronized waves data packets transformation filters operate input data packets flowing upstream downstream yielding output packets mrnet interface mrnet api consists network end-point communicator stream objects tool front-end back-end communication network object instantiate mrnet network access end-point objects representing tool back-ends communicator object container groups end-points streams send data end-points communicator simplified code tool front-end back-end shown figure front-end code variable definitions lines instance mrnet network created line topology specification config file line newly created network object queried auto-generated broadcast communicator end-points line communicator build stream floating point maximum filter find maximum floating point data upstream front-end send initialization messages back-ends line await single floating point result back-end code reflects actions front-end tool back-end connects mrnet network init backend call line contrast front-end stream-specific recv call back-ends call stream-anonymous recv returns integer front-end stream object representing stream front-end send data finally back-end sends scalar floating point upstream front-end mrnet internal processes libmrnet access mrnet capabilities internal processes mrnet tree provide core functionality mrnet internal processes implement logical channels flow control messages data tools components perform data aggregation reduction operations internal process main task create manage logical channels streams correctly control flow packets system internal processes stream manager object manage control flow route packets stream established internal process creates stream manager initializes set end-points stream filter data packets stream stream manager maintains list children nodes stream child node object represents connection directly end-point internal process end-point set ultimately reached figure illustrates organization functional layers internal process describe layers discussing path user data packets upstream downstream flows upstream data flow exercises layers internal process functionality bounded dashed line figure packets unbatched demultiplexed synchronized aggregated re-batched continuing upstream journey front-end incoming packet buffers unbatched individual packets data packets front end main network net communicator comm stream stream float result net network config file comm netget broadcast communicator stream stream comm fmax fil streamsend float max init streamrecv result back end main stream stream int val network init backend stream recv val stream val float max init streamsend rand float figure mrnet front-end back-end sample code code broadcast integer initializer batched packet buffers logically represent series communications destined process fewer larger messages busy connections reducing communication costs packet tagged stream demultiplex packets streams demultiplexing phase packets passed stream manager instance delegates control filter objects synchronization aggregation aggregation packets destined upstream node re-batched single packet buffer scheduled transmission upstream node tree note packets manipulated passed layers shown figure avoid unnecessary copying downstream data flow identical upstream data flow respects synchronization filters supported downstream data flows data packet flowing downstream multiple output packet buffers packet destined multiple back-ends upward path packets buffered avoid copying filters filters operate data flowing network synchronization filters receive packets time output packets synchronization criteria occurred transformation filters input group packets perform type data transformation data contained packets output packets distinction synchronization transformation filters synchronization filters independent packet data type transformation filters operate packets specific type synchronization filters provide mechanism deal asynchronous arrival packets children nodes synchronization filter collects packets typically aligns waves passing entire wave ters data transformation operate packets type-independent fashion mrnet supports synchronization modes wait wait packet child node time wait time packet arrived child whichever occurs wait output packets immediately synchronization filters criteria determine return packets stream manager anticipate types synchronization filters added user transformation filters combine data multiple packets performing aggregation yields data packets transformation filters expected perform computational operations data packets type requirement data packets passed type filter data format string stream packets filter transformation operations synchronous carry state transformation static storage structures mrnet transformation filters general basic scalar operations min max sum average integers floats concatenation operation inputs scalars outputs vector length base type mrnet designed tool developers add filters provided set discussion focuses transformation filters synchronization filters share basic design transformation filters added similar techniques order establish filter tool developer provide filter function implements data transformation operation filter functions signature filter function takes vector data packets outputs vector data packets arbitrary size packet array data elements element consists union type integer float character pointer arrays types filter functions implemented tool developer named made mrnet tasks accomplished load filterfunc function provided mrnet api load filterfunc function takes filter function filter shared object file filter function returns identifies filter mrnet frontend internal processes access filter function operating system api managing shared objects dlopen dlsym unix systems figure functional layers mrnet internal process data encoding data transformation operation data 
decoding data-specific aggregation packet synchronization packet batching unbatching packet batching unbatching void filter func std vector packet inpackets std vector packet outpackets void clientdata onward time synchronization filmrnet instantiation conceptually simple creating connecting mrnet process network complicated interactions job management systems simplest environments launch jobs manually facilities rsh ssh complex environments submit requests job management system case constrained operations provided job manager vary system system support modes instantiating mrnet-based tools mode process instantiation mrnet creates internal back-end processes mrnet topology configuration determine hosts components located front-end consults configuration rsh ssh create internal processes level communication tree hosts newly created process establishes connection process created activity connection message parent child portion configuration relevant child child information begin instantiation sub-tree rooted child sub-tree established root sub-tree sends report parent end-points accessible sub-tree internal node establishes children processes respective connections sequentially processes expected run compute nodes sub-trees branches network created concurrently maximizing efficiency network instantiation mode process instantiation mrnet relies process management system create mrnet processes mode accommodates tools require back-ends create monitor control application processes ibm poe environment variables pass information process rank application global mpi communicator mpi run-time library application process cases mrnet provide back-end processes environment start mpi application processes result mrnet creates internal processes recursively instantiation mode instantiate back-end processes mrnet starts tool back-ends process management system ensure environment needed create application processes successfully starting back-ends mrnet provide information needed connect mrnet internal process tree leaf processes host names connection port numbers information provided environment shared filesystems informamrnet process layout mrnet tool node allocation process connectivity tailored computation communication requirements system running tool choosing mrnet configuration difficult due complexity tool activity interaction system briefly discuss issues related process layout current work focuses tool scalability full treatment optimal mrnet configurations scope paper configurations experiments section chosen ability show mrnet effect tool scalability anticipate future research examine issue mrnet topology detail choosing process configuration mrnet-based tool key issues mrnet internal processes co-located application processes study internal processes connected primary measures configuration quality latency single broadcast operation measured initiation front-end receipt back-end latency single data aggregation operation measured initiation back-ends receipt front-end throughput streams broadcasts data aggregations cpu utilization mrnet internal processes issue choosing mrnet configuration co-locate mrnet internal processes application processes nodes literature broadcast reduction networks assumes internal processes co-located application processes approach flaws practice internal processes contend application processes cpu network resources impacting application performance differing loads mrnet internal processes create imbalance application processes skewing performance parallel program speed limited slowest process performance skew increase tool impact application result recommend mrnet internal processes located resources distinct running application processes mrnet internal processes application processes co-located run distinct nodes resource usage similar advocate separate location achieve predictable understandable application behavior issue choosing mrnet configuration internal process topology balanced unbalanced tree topologies tion services target system attractive properties mrnet configurations literature parallel collective communication algorithms argues unbalanced tree topologies situations bernaschi iannello show optimal communication tree broadcast single-level flat tree binomial tree depending latency transferring messages processes minimum interval message send operations process similarly optimal algorithms broadcast data aggregation problems evaluated logp loggp models unbalanced communication trees literature assumes processes involved operation data sources reductions sinks broadcasts case mrnet internal processes balanced tree topologies provide attractive advantages unbalanced tree topologies work regularity makes easier analyze choosing size shape mrnet internal process tree latency individual collective communication operations worse balanced trees unbalanced trees provide throughput sequences collective communication operations mrnet tree topologies shown figure connecting tool front-end sixteen tool back-ends assuming logp model minimum gap successive send operations process overhead send receive message transfer latency time required complete broadcast operation sixteen back-ends balanced tree topology shown figure tool start broadcast cycles comparable unbalanced tree topology reaching sixteen back-ends shown figure topology constructed binomial tree nodes providing low-latency broadcast binomial tree node mrnet back-ends attached binomial tree node depending relative values single broadcast operation topology complete balanced tree broadcast tool topology cycles broadcast operation due larger fanout tree root tool supports six-way fan-out root unbalanced tree topology balanced topology six-way fan-out tree reach sixteen tool back-ends paper chose experiment balanced tree topologies leaving examination unbalanced trees optimal communication topologies future work ability internal process upward downward data flow fan-out internal process limited experiments multi-level balanced trees moderate fanouts real-world tool evaluate mrnet usefulness building realworld scalable parallel tools modified paradyn parallel performance tool mrnet main ways paradyn mrnet simplify complex interactions front-end tool daemons process start-up initialization off-load performance data processing tasks paradyn front-end report experience mrnet paradyn quantitative evaluation presented section scalable tool start-up tools debuggers performance tools transfer large amounts data tool start-up create attach application processes debugger sets breakpoints function deliver names addresses functions tool user interface parallel tools follow process organization shown figure front-end bottleneck connected large number application processes reducing tool interactivity start-up latency caused bottleneck create problems parallel runtime systems fail application processes created timely fashion modified version paradyn built-in custom mrnet aggregation filters activities involving tool daemons back-ends tool start-up phase including reporting data paradyn daemons frontend distributing data performance data metrics daemons detecting clock skew front-end process figure comparable mrnet internal process topologies number back-ends latency single broadcast aggregation operation unbalanced topology balanced topology throughput pipelined operations daemon process reporting data application processes front-end activities manipulate paradynspecific data techniques mrnet implement applicable activities commonly performed parallel tools paradyn start-up data transferred tool system categories data describing daemon application processes back-ends front-end configuration data front-end back-ends tool start-up paradyn back-ends examine application processes identify relevant parts program modules functions process ids items called resources paradyn terminology back-ends identified application resources reported front-end statically-determined call-graphs application processes bulk start-up information front-end back-ends collection performance metric definitions instrument processes collect performance data paradyn mrnet ways reduce cost reporting data daemons front-end method depends data significant number processes function names addresses processes process ids host names data significant number processes data transferred tool start-up redundant application processes created small number executables run collection homogeneous hosts report data paradyn daemon computes summary data checksum daemons write checksums mrnet stream created custom 
binning filter filter partitions daemons equivalence classes based checksum values frontend receives final set equivalence classes requests complete function resource information class representative process unlike function names data process identifiers host names hosts paradyn leverages mrnet reporting data paradyn parallel concatenation aggregation construct larger resource report messages efficiently delivered underlying communication subsystem small resource report messages paradyn mrnet deliver configuration data efficiently front-end back-ends paradyn metric definitions describing instrument processes collect metric performance data prothe paradyn metric definition language frontend simple broadcast operations deliver metric definitions tool back-ends clock skew detection start-up activity fall neatly communication paradigms mentioned earlier mrnet-based clock skew detection scheme occurs phases phase consists repeated broadcast reduction pairs special stream reserved finding clock local clock skew process downstream processes directly connected children mrnet process tree phase consists single broadcast daemons requesting initiate collection skew results daemon initializes cumulative skew passes upstream mrnet network mrnet internal process receives cumulative skew downstream connections adds observed local clock skew connection cumulative computing skew clock daemon reachable connection induction algorithm finishes paradyn front-end holds skews clock clocks tool back-end distributed performance data aggregation parallel performance tools paradyn aggregates performance data collected back-ends examine application global behavior global performance measure monitored paradyn back-end produces sequence data samples representing measure processes threads controls obtain sequence samples representing application cpu utilization paradyn back-end collects sequence cpu utilization samples processes paradyn aggregates samples sequences single global sample sequence ordinal aggregation common technique constructing global sample sequence aggregating sample sequence shown figure paradyn design recognizes back-ends collect data asynchronously ordinal aggregation combine samples representing intervals application execution result paradyn represents data sample sample time interval applies interval start end timestamps set back-ends sample collected paradyn performance data aggregation takes account sample time interval aggregation values comparable time intervals illustrated figure vided front end configuration file written mrnet paradyn aggregates data samples front-end computation communication cost aggregation front-end scalability barrier paradyn monitors global performance measures large number nodes mrnet paradyn distributes aggregation activity filters running mrnet network reducing front-end data processing load paradyn distributed data aggregation scheme custom performance data aggregation filter mrnet internal process aligns data samples inputs reduces form single output sample collectively filters produce single aggregated sample tool front-end paradyn performance data aggregation filter collects data samples inputs aligns data samples reduces determine align samples deliver aligned samples aggregation filter filter maintains notion output sample interval interval defines start end times aligned data samples start end time aggregated output sample illustrated figure showing performance data aggregation filter internal process input connections samples arrived input connections figure sample arrives input connection filter places queue input connection figure filter checks interval newlyarrived sample overlaps current output sample interval attributes percentage input connection current output sample leaving remainder adjusting interval start time remove overlap figure note sample attributed proportionally current output interval remainder output sample interval lost performance data due round-off issues arrival caused current output sample interval full sample data input connections input connections filter reduces aligned samples figure advances output sample interval figure output sample interval aligned input samples paradyn mrnet-based performance data aggregation scheme exhibits common trade-off centralized distributed algorithms centralized aggregation scheme complete knowledge samples aggregated considers sample finding aggregated sample start end times hand distributed scheme performs multiple alignments network leading work tool system distributed scheme alignments parallel reduces computation cost data aggregation tool front-end mrnet-based distributed scheme exhibits scalability centralized scheme evaluation evaluate mrnet measured performance test harness integrated paradyn real-world parallel performance tool micro-benchmark experiments test harness tool measured mrnet start-up latency round-trip latency single broadcast reduction mrnet reduction throughput proa figure performance data aggregation ordinal aggregation time-aligned aggregation examples sample data streams aggregated output sample stream ods ordinal aggregation aggregates sample stream time-aligned aggregation considers samples start end times aggregate data interval program execution ods time ods time interval cess tree topologies paradyn experiments compared performance start-up performance data aggregation activities mrnet experiments run asci blue pacific system lawrence livermore national laboratory blue pacific nodes compute nodes connected ibm switch interconnect node mhz powerpc processors ram runs aix parallel system support programs version results show mrnet significantly improves scalability key activities parallel performance system administration tools micro-benchmark results began measuring low-level performance mrnet minimal test harness run test harness tool requested appropriatelysized partition blue pacific batch scheduling system partition determined partition nodes host names automatic configuration generator program build mrnet configuration file desired topology partition executed tool frontend program passing configuration file sured mrnet performance characteristics latency instantiate mrnet network latency broadcast operation data reduction mrnet throughput sequence data reductions results experiments shown figure micro-benchmark measurements show necessity infrastructure mrnet building scalable parallel tools flat single-level topology closely approximates architecture parallel tools instantiation latency grows quickly number tool back-ends increases due serialization process creation operations instantiation latency grows slowly mrnet fully-populated balanced tree topologies fourand eight-way fan-outs mrnet creates process tree parallel round-trip latency data reduction throughput measurements show benefits mrnet parallel tools flat topology broadcast reduce implemented serialized point-to-point message transfers message transfer time-consuming rsh create processes tool instantiation effect serialization similar latency grows rapidly figure distributed data aggregation paradyn custom mrnet filter initial situation sample data streams sample arrives queue input connection sample interval overlaps current output sample interval split attribute overlap output sample interval newly-arrived sample completes data output sample interval samples reduced output sample interval advanced output sample interval time output sample interval time output sample interval time output sample interval time output sample interval time argument run test harness meanumber back-ends increases tool front-end involved message transfer start subsequent reduction previous operation completes multi-level mrnet process configurations mrnet perform point-to-point message transfers parallel moderate fan-outs mrnet process data reductions pipelined pass network keeping reductrends mrnet micro-benchmark scalability studies expected previous tool infrastructures hierarchy processes ladebug parallel debugger lilith show similar scalability trends integrated performance results evaluate mrnet real-world performance modified paradyn parallel performance tool start-up latency round-trip latency reduction throughput figure mrnet micro-benchmark experiment results tool instantiation latency round-trip latency single broadcast single reduction data reduction throughput singleand multi-level mrnet topologies compared flat 
singlelevel topology commonly found parallel tools multi-level mrnet topologies exhibited dramatically scalability performance showing necessity multi-level process networks mrnet building scalable parallel tools back-ends time sec flat -way fanout -way fanout back-ends time sec flat -way fanout -way fanout back-ends throughput ops sec flat -way fanout -way fanout tion throughput high application size increases mrnet section evaluated mrnet performance tool start-up tool collecting processing performance data tool start-up performance results paradyn start-up protocol highly tuned reduce redundant data transfer data transfers tool daemons front-end technique tool daemon computes checksum data front-end partitions daemons equivalence classes based checksum values requests complete data single representative equivalence class measured latency paradyn start-up activities preparing monitor smg parallel linear equation solver smg executable small approximately functions executable started timer daemons started reported tool front-end stopped timer daemons reported information application processes created ready run application results scalability study mrnet topologies shown figure mrnet serialization communication paradyn front-end daemons start-up latency rise exponentially number daemons increases mrnet process topologies moderate fan-outs start-up latency curves flatter growth linear indicating significant improvement tool scalability investigate start-up latency mrnet affect measured latency indiour largest experimental configuration results shown figure individual activities shown figure reportself mrnet concatenation filter daemon reports basic characteristics front end host running reportmetrics front-end broadcasts metric definition language data daemons daemons respond equivalence class algorithm report metrics support including internal metrics mdl data find clock skew front-end finds clock skew respect daemon clock skew detection algorithm section parse executable daemon examines application executable shared libraries find names addresses functions parses code discover application static call graph report process creating attaching application process daemon reports data process front end including process command-line arguments created daemon created daemon attached front-end issue command resume process start-up activities complete report machine resources concatenation filter daemon defines paradyn resources host process initial thread application processes paradyn resource definition protocol report code classes report code resources equivalence class algorithm daemons define resources functions figure paradyn start-up latency increasing numbers daemons activity daemons bold activity names mrnet data aggregation concatenation part activity daemons atency sec mrnet -way fanout -way fanout -way fanout time sec report report metrics find clock skew report process report machine resources report code classes report callgraph classes report mrnet -way fanout parse executable report code resources report callgraph vidual start-up activities mrnet modules application executable report callgraph classes report callgraph equivalence class algorithm daemons report static call-graph information built parse executable activity front-end report daemons end start-up phase activity mrnet communicate daemons showed significant latency reduction mrnet activities show significant improvement mrnet activities consist work parallel daemons parse executable point-to-point communication small number daemons front-end report code resources report callgraph fact point-to-point communication activities transferred data mrnet additional overhead passing intermediate mrnet processes observed negligible benefit mrnet increased increased number tool daemons largest configuration back-ends latency performing start-up activities times faster mrnet balanced fully-populated tree configuration eight-way fan-out mrnet based investigation mrnet benefit individual activity paradyn start-up expect trend continue configurations significantly larger daemons clock skew detection paradyn start-up activity benefitted mrnet repeated broadcast reduction operations distribute collect clock samples intermediate skew results activities perform collective operations evaluated clock skews computed mrnet-based clock skew detection algorithm comparing skews computed blue pacific switch clock globally-synchronous clock skew results computed commonlyused direct-communication scheme compute clock skew respect daemon direct communication scheme front-end sends small amount data daemon daemon samples clock receives data sends sample front-end front-end receives daemon sample samples clock computes round-trip latency sends receives front-end approximates one-way latency round-trip latency adds one-way latency daemon clock sample difference front end receive timestamp clock skew experiments front-end measured skew direct communication scheme times observed skew smallest absolute actual clock skew -daemon topology four-way fan-out three-level topology mrnet-based clock skew detection algorithm produced skews average error compared skews computed globallysynchronous switch clock average error skews produced direct-connection method standard deviation errors produced mrnet-based algorithm slightly higher standard deviation direct connection method errors short mrnet clock skew detection algorithm produced results comparable direct-connection method significantly scalable tool data aggregation performance results assess impact mrnet paradyn performance data processing capabilities measured paradyn consume process volume performance data samples generated daemons variety configurations varied load tool front-end varying number daemons number performance metrics data collected daemon simplify evaluation ran paradyn synthetic parallel application behavior easily-controllable run time data rate high configured paradyn daemons fixed sampling rate duration experiments fixed daemon sampling rate paradyn default initial rate samples metric number daemons metrics rate samples generated tool samples results integrated performance data processing experiments shown figure figure shows paradyn performance collecting data metrics configurations daemons data point marks ratio rate paradyn front-end processed performance data samples rate daemons generated samples ratio represents fraction offered load processed paradyn front-end minor start-up transients steady-state rate front-end consumed performance data fluctuate significantly report steady-state ratio figures level curve paradyn front-end performance data volume generated daemons number daemons increased results show paradyn relies mrnet performance data processing activity scales significantly increases number tool daemons number metrics data collected increasing number metrics data collected paradyn ability process offered performance data sample load degraded quickly collecting data daemons metrics daemon mrnet paradyn front-end processed data rate generated daemons metrics front-end processed data rate offered load note number metrics daemon increases paradyn increases size messages performance data number messages mrnet allowed paradyn front-end scale number daemons metrics increased foureight- sixteen-way mrnet fan-outs front-end process entire offered load configurations tested related work mrnet data aggregation multicast services building scalable parallel tools similar functionality found previously softwarebased collective communication infrastructure parallel tools applications parallel databases overlay networks mrnet lilith ygdrasil parallel tool infrastructures providing multicast data aggregation functionality mrnet differs lilith ygdrasil communication model tool architecture software engineering trade-offs lilith commua metric metrics metrics metrics figure fraction offered load serviced paradyn front-end mrnet increasing number metrics data collected shown curves labelled flat paradyn ability process offered performance data sample load degrades quickly number daemons increases mrnet off-load performance data processing paradyn scale number daemons metrics increases foureight- sixteen-way mrnet fan-outs daemons fraction offered load flat 
abstract describe system called guievict enables graphical user interface gui application transparently migrated replicated display premeditative steps re-linking application program binary re-directing application process window system communication proxy guievict based small window server extension enables application retrieve window session transportable representation gui window server library gui migration functionality injected application process run time discuss underlying technical issues controlling synchronizing communication application window system identifying retrieving gui resources form window session regenerating window session window system maintaining application transparency implemented guievict xfree implementation window system gui migration performance guievict measurably perceptibly worse proxy-based system introduction application mobility ability application execution follow user user moves computer moves computer internet mobility includes moving executing code network connections access graphical user interface gui gui access files developing roaming applications system called evict addresses issues providing application mobility transparent users applications requiring modification system code tion gui migrate application migrates independently application types migration require ability capture application window session transportable representation gui window sessions difficult capture state represent resident application portions application gui state reside window server separate system handles display gui-based applications host window servers provide extract state individual application resources guievict implemented window system characteristics migration occurs application granularity users select move gui individual applications desktop leaving application guis free move application program including based legacy toolkits migrated modifications re-programming re-compiling relinking migration unpremeditated users run applications special redirecting gui communication proxy modifications window system code required functionality contained window server extension require server re-linked library loaded application run-time guievict functionality replicate gui individual applications demand checkpoints gui-based applications victor zandy barton miller computer sciences department wisconsin madison usa zandy bart wisc paper describes guievict part evict system migrates application gui applicaon multiple desktop hosts enabling multiple users interact single instance application collaborative work support remote service essential elements gui-based application figure application runs processes execution host user interacts possibly desktop host desktop comprises display keyboard mouse managed window system multiplexes deskthis work supported part department energy grants de-fg de-fg lawrence livermore national lab grant nsf grants cdaand eiaand veritas software government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon top applications interact user host window system responds requests gui services creating window application passes notification desktop events mouse click application communication channel network connection execution desktop hosts shared memory state application gui distributed window system library called toolkit application process focus migration single application desktop host abstraction encapsulates precisely gui state application individual windows application windows applications served user desktop host previous systems studied techniques session migration user entire desktop migrated machine ability migrate application granularity advantages session migration flexible users freedom migrate applications location saving migration costs enables users work multiple desktops time session migration systems generally involve virtualization layer virtual machine nested window server sort gui prison user redirect applications advance addition inherent overhead virtualization layers emulate basic generic display hardware preventing applications taking advantage enhancements acceleration features present real underlying hardware mechanism application migration enables operations gui attach users dynamically attach interact gui user application guievict offers major advantages previous systems perform gui migration application granularity notably xmove enables users migrate applications premeditative step redirecting application xmove proxy details redirection hidden user launch script user script start applications anticipate moving contrast guievict offers application mobility features users develop habits foresight simplifies process migration gui-based applications migration original design goals xmove combined process checkpointing migrate gui-based application addition application process xmove proxy state communication channel proxy application checkpointed migrated guievict window session mechanisms manage migration reside address space application process migrated application code data migrate guis ordinary unmodified applications display host overcome main challenges dynamically taking control window system communication running program inject code application process discovers process communication channel window server synchronizes communication server figure elements gui-based application user interacts application hardware managed window server desktop host application process executes possibly execution host exchanging gui-related messages window server communication channel user execution host application gui libraries desktop host window server keyboard mouse display communication channel figure initializing application process evictor stops application process forces load evict client library exits execution host application libraries evictor execution host application libraries evictlibrary initialization initialization retrieving gui resources application developed extension window server enables application time determine identifiers gui resources dependencies resources extract resources form regenerated desktop regenerating application resources desktop host standard protocol operations regenerate gui resources window server ensuring gui migration transparent application applications guis migrated confused resulting resource identifiers message sequence numbers display characteristics pixel depth interpose filter called guimux communication application mapping maintain transparency guimux serves multiplexor gui replication main limitations guievict requires user install window server extension desktop hosts requires availability symbols window protocol stubs application large overhead checkpointing font state discuss implications workarounds issues section remainder paper organized section presents architecture guievict section describes implementation section presents evaluation guievict section identifies security issues raised guievict section presents related work system overview major steps operation guievict initializing system migrating application gui desktop host replicating application gui multiple desktops migrating application process gui operations involve system components evictor program user runs control evict system user runs host application process evict client library loaded evictor run time application process implements application-side gui migration operations evict server extension server-side component guimux daemon started client library runs execution host ensures gui migration replication transparent application remainder section describe guievict operations detail section discuss solutions technical problems underlying operations initialization user prepares running application process evict system invoking evictor initialize operation passing application process argument evictor hijacks application process stops process forces load initialize evict client library figure initialization client library establishes communication channel future interaction user hijacking transparent figure detaching gui desktop evict client library requests window session evict server extension desktop closes connection execution host application libraries evictlibrary desktop host window evict extension server window session retrieve window session desktop host window evict extension server execution host application libraries evictlibrary desktop host window evict extension server desktop host window evict extension server window session detach detach window system socket connection guievict message application afterward evictor resumes application process 
allowing continue time user run evictor request evict operation evictor interrupts application process sends commands client library communication channel evict server extension loaded initialized window server user request evict operation xfree window server support run-time extension loading implementation server configured load evict extension started general gui migration gui migration broken steps user requests application evictor command detach gui window server response evict client library figure synchronizes application communication window server blocks application communication retrieves window session server closes connection window server user requests application reattach gui window server figure evict client library starts guimux process replaces application socket window server fullduplex pipe guimux process transfers control guimux process guimux process opens connection window server regenerates state window session signals evict client library resume application re-attach operation arbitrary period time detach meantime client library suspends execution application code prevent temporary absence window server connection affecting application common case user wishes detach desktop attach logical operation evictor combined detach attach command gui replication gui replication simple variation gui migration user requests evictor application replicate gui window server evict client library performs final step detach operation acquires current state window session close connection window server performs normal attach operation connect gui additional window server figure time attach operation performed redirects original window server connection guimux process gui process migration guievict supports simultaneous migration application process gui figure shows typical scenario type mobility execution desktop hosts laptop user migrate application process figure re-attaching gui desktop evict client library establishes connection desktop guimux forwards window communication application desktop starting request regenerate window session re-attach execution host application libraries evictlibrary desktop host window evict extension server desktop host window evict extension server execution host application libraries evictlibrary desktop host window evict extension server desktop host window evict extension server window session guimux window session window session windo session window system socket connection guievict message re-attach gui host computer desk scenario user evictor request application migrate providing arguments window server execution host evict detaches application gui window server terminates guimux daemon running checkpoints application process producing checkpoint file state application process including window session exits application process point user transport checkpoint file execution host invoke evictor restart application process complete migration evict restores state application process gui attaches application process window server checkpointing restarting application process transparently performed user-level process checkpoint library linked evict client library details library previously scope paper implementation implemented evict linux xfree implementation window system describe major technical issues solve implementation hijacking application find application connection window server synchronizing connection retrieving restoring gui resources ensuring gui migration transparent application hijacking application process hijacking safely implemented basic dynamic instrumentation mechanisms provided dyninst api include stopping process forcing process execute code load initialize evict client library resuming process evictor implementation mechanisms avoid requiring users install additional software dyninst api functionality evict requires evictor forces application process load evict client library injecting code calls run-time library loading feature named dlopen process dynamic loader technique directly work statically-linked programs dynamic loader processes based programs supporting statically-linked programs important gui-based applications distributed statically avoid forcing users gui library dependencies developed hijacking functionality cope statically linked programs idea map initialize copy dynamic loader process address space essentially reproducing initial steps figure replicating gui desktop replication similar migration connection desktop preserved multiplexed guimux connections desktop hosts execution host application libraries evictlibrary desktop host window evict extension server window session retrieve window session desktop host window evict extension server execution host application libraries evictlibrary desktop host window evict extension server desktop host window evict extension server window session guimux window session windo session window session window system socket connection guievict message replicate replicate operating system takes loading dynamic-linked program instance dynamic loader control original code process serves provide implementation dlopen call dynamically-linked programs evict client library creates named unix domain socket subsequent communication evictor library deletes socket application exits socket based application process user ids avoid conflicts independently running instances evict stale sockets left abnormal termination cleaned user discovers evictor attention evict client library writing message socket application process receive signal handled library finding window server windows applications communicate window server unix domain tcp socket unlike proxybased systems xmove guievict invoked creation connection window server search file descriptors process sockets connected window server operating systems provide proc entry linux list open file descriptors process guievict test file descriptor fstat system call guievict file descriptor refers socket inode figure migrating application process gui laptop desktop computer evict client library detaches gui window server evict checkpoints application process producing checkpoint file entire application state including window session transporting checkpoint file desktop host evict restarts application process evict re-attaches gui desktop window server application libraries evictlibrary laptop window evict extension server application libraries evictlibrary desktop window evict extension server window session application libraries evictlibrary laptop window evict extension server window session application libraries evictlibrary window session application libraries evictlibrary desktop window evict extension server window session guimux window session checkpoint file retrieve window session windo session window system socket connection guievict message detach checkpoint restart re-attach reported fstat system call connected window server condition difficult check cases getpeername system call returns address socket side connection sufficient check socket peer address well-known window server tcp ports unix domain socket names test fail application tunnelled window server proxy peer address socket proxy address common proxy configuration ssh tunnels firewall port forwarding rules difference proxy address normal window server address small positive offset port number easy recognize event getpeername reveal obvious window server connection guievict checks peer address socket leads window server creates socket attempts connect peer address connection succeeds performs round standard windows handshake server expected response handshake guievict concludes found socket connected server probe fails sockets guievict control application probe raises concerns probe succeed window servers happen respond handshake windows server practice response distinguishable common protocols ssh telnet ftp http distinctive presume conflicts occur common protocols event false positive guievict eventually receive nonsensical messages server abort probe negative effect probed servers server implementations robust spurious connections existing hardened internet deployment users risk probe evictor accepts 
command line argument identify file descriptor peer address window system connection synchronizing communication guievict ensure state window session change retrieved window state caused messages exchanged application window server guievict synchronizes communication finding point message stream partially unanswered requests blocks communication synchronization occurs steps guievict forces application process reach message boundary stream messages application server examines application process stack starting operation searching library functions stubs protocol requests function appears stack application process middle sending message guievict sets timer resumes application code short period time re-examines stack procedure repeats stack free potentially unsafe functions guievict sends protocol request illegal resource identifier server effect request elicits error message server guievict reads scans stream messages server recognizes error point client unanswered requests connection synchronized messages read error buffered re-sent application guimux application allowed resume detecting presence protocol stubs application process stack depends presence symbols functions application process issue dynamically linked applications symbols present facilitate linkage symbols stripped statically linked executables evictor refuses work stripped static applications remedy limitation investigating alternative approaches synchronizing communication depend stack traces including inferring message boundaries analyzing messages socket retrieving regenerating gui resources windows applications create modify destroy gui resources exchange protocol messages window server gui resources reside window server indirectly manipulated application -bit resource identifiers drawn namespace global clients window server clients choose low-order bits identifier resource create set high-order bits fixed client chosen server application connects generally impossible locate resource identifiers application process code data window server window server manages per-client table allocated resources provide external access information table previously reported server extension addressed limitation server extension missing interface getresources request application request server return enumeration resources application created types resources resource identifier sufficient application retrieve state resource standard protocol requests exceptions windows graphics contexts cursors fonts getresources reply windows includes background pixel window cursor identifier replies graphics contexts cursors include entire state graphics context small array flags cursor bitmap geometry fonts complicated windows fonts stored server clients acquire font sending request server font resource identifier font server loads binds font identifier font returns error applications request detailed geometric information font font identifier request map font identifier font strangely server discards font loading font mapping server extension detach operation evict client library performs search map font identifier font requests server list stored fonts standard protocol request searches list font geometry matches font identifier font suffices regenerate font resource window server server font cases guievict searches font list server selects font closest matching geometry leastsquares font matching algorithm similar shared complicated expensive approach migrating font resources eliminated switching client-managed fonts recently proposed architectural change window system meantime eliminate overhead caching application file system font names geometry server regularly regenerate pixelbased resources identically previous instances displays vary number bits pixel depth method pixels mapped colors visual type meaning pixel values change xmove provided additional translation operation mapped pixel values previous depth visual current server recent developments server promise eliminate translation extension shadow framebuffers server-based mechanisms virtualizing depth visual designed goal providing heterogeneity support migration replication systems extension complements developments combine produce system gui migration transparent display heterogeneity maintaining transparency main role guimux daemon make gui migration transparent application process translating resource identifiers sequence numbers messages exchanged application window server resource identifier mapping initialized regeneration gui resources evict client library regenerates resource issuing ordinary protocol resource creation request original identifier guimux forwards requests replaces identifier unused identifier valid current window server subsequent messages application server guimux maps resources current identifier performs similar reverse mapping messages server application application destroys resources removed map sequence numbers occur messages window server application represent number messages server processed application occur messages application guimux replaces sequence number message sequence number expected application process procedure initialized guievict synchronizes communication window server point sequence number expected application process sequence number contained sentinel error reply replication windows multiple displays extends role guimux process managing replicated gui guimux maintains separate translation map window server connection messages application translated window server messages window servers reverse translated forwarded series application control behavior replicated guis guimux accepts set commands evictor act primitives setting replication policy user suppress forwarding keyboard mouse window modification events selected desktop hosts users seated desktops observe modify state gui sophisticated policies managing collaborative work built primitives evaluation evaluated performance guievict gui migration functionality point compared performance proxy-based xmove system measured time detach re-attach gui impact interactive response performed measurements mhz pentium-iii laptop running xfree linux recent release xmove results surprising guievict takes longer xmove detach gui window server re-attaches comparable time xmove guievict re-attach increase latency communication application process window server perceptible users detach re-attach latency measured latency detaching gui window server re-attaching window server applications guievict detach latency elapsed time evict client library receives detach command closes connection window server guievict re-attach latency elapsed time evict library receives re-attach command application process continue xmove latencies analogous ran application process window server laptop detached application gui initial windows drawn user interaction gui report average measurements runs results reported table guievict expensive detach operation xmove table breaks average guimux detach time application expensive stage mapping font identifiers fonts names time spent waiting server return complete list fonts generally guievict takes longer detach retrieves gui state receives detach request xmove collects gui state created reduce detach latency plan enable evict client library incrementally fetch font list idle periods application process execution implemented optimization guievict xmove similar re-attach performance expected perform similar tasks stage interactive overhead measure impact guimux xmove interactive response created small application repeatedly sends request minimal size bytes window server waits reply minimal size bytes measured average time round trips application detached re-attached guievict xmove results reported table guievict xmove measurable impact round trip time caused overhead redirecting window system communication proxy overhead millisecond perceptible users application guievict latency msec xmove latency msec detach re-attach detach re-attach xterm xmame emacs ghostview netscape table average detach re-attach latency stage time usec font list pixmaps windows fonts graphics contexts cursors colormaps table breakdown detach latency netscape system latency usec guievict xmove table average round trip time minimal protocol request reply security 
system introduces issues related security window applications servers owner application process control migrate replicate gui policy owner process perform guievict operations process policy enforced mechanisms standard operating system protection prevents user modifying process user process hijacked owner evict library authenticates messages receives evictor credential passing mechanism unix domain sockets ensure sender message user owns application process mechanisms suffice protect application process ordinary users superuser execution host guievict server extension weaken security window system goal met getresources request returns information resources application issues request learn resources application man-in-the-middle attack staged inject getresource request application connection window system information revealed obtained passive eavesdropping connection windows vulnerability defense encrypt connection owner desktop host authorize guievict re-attach gui display server access control mechanisms mit-magiccookie require authorized application possess server-generated capability present server establishes connection capability possessor complete access server desktop owner secure transfer capability guievict user trust guievict user abuse access server guievict provide capability transfer mechanisms change access control policies server issues trivial migration scenarios desktop user guievict user user transfer capability log execution host run evictor issues faced gui replication system built guievict replication mechanism related work guievict closely resembles xmove systems share goal migrating guis perapplication basis desktop host unlike guievict xmove requires user redirect advance application window system connection proxy tracks state resources addition xmove support migration application processes lacks restore communication application proxy processes application process migrated migrate proxy process state systems including vnc teleporting slim provide remote access session collection guis remotely executing applications unlike xmove systems enable user migrate display applications session single unit convenience users remote access entire desktop hindrance users independent movement guis xmove systems depend level indirection established applications started support application process migration recent systems extended session migration concept include application process migration users internet suspend resume system run entire computing environment operating system applications inside virtual machine state saved regenerated machine system mobility model coarser evict applications operating system migrate single unit gui migration separately application process migration zap system finer degree mobility allowing users run application processes session abstractions independently migrated hosts zap support gui migration users systems vnc migrate guis adding level indirection systems developed replicate gui unmodified windows applications multiple desktops xmove systems require applications redirected proxy started interesting exception shared system performs replication server extension unlike guievict extension providing retrieve window session state server extended shared server acts proxy regenerates gui displays forwards messages application process displays extension unsuitable gui migration application detach original server conclusion guievict enables gui ordinary windows application migrated desktop host replicated multiple desktop hosts premeditative steps redirecting application process communication proxy relinking application program binary shown server functionality retrieve window session transportable representation application gui small encapsulated window server extension server recompilation ordinary windows applications hijacked run time retrieve window session perform gui migration replication implemented guievict -based versions linux running xfree window system code freely http wisc zandy guievict abdel-wahab feit xtv framework sharing window clients remote synchronous collaboration ieee tricom communications distributed applications systems chapel hill usa april abdel-wahab jeffay issues problems solutions sharing clients multiple displays internetworking research practice march baldeschwieler gutekunst plattner survey protocol multiplexors acm sigcomm computer communication review april bazik xmx protocol multiplexor http brown software xmx bormann hoffmann xmc scalable window sharing mobility annual technical conference january buck hollingsworth api runtime code patching journal high performance computing applications winter chen noble virtual real workshop hot topics operating systems hotos-viii elmau oberbayern germany garfinkel spafford practical unix internet security edition reilly associates sebastopol april garfinkel welti yip sharedx tool real-time collaboration hewlett-packard journal april gettys future coming window system usenix annual techical conference freenix track monterey june gettys packard resize rotate extension randr usenix annual technical conference freenix track boston june gutekunst bauer caronni hasan plattner distributed policy-free general-purpose shared window system ieee acm transactions networking februrary jones multidisplay software survey architectures resource issue reilly associates jan kozuch satyanarayanan internet suspend resume ieee workshop mobile computing systems applications wmcsa callicoon june litzkow tannenbaum basney livny checkpoint migration unix processes condor distributed processing system technical report computer sciences department wisconsin april osman subhraveti nieh design implementation zap system migrating computing environments symposium operating systems design implementation osdi boston december richardson bennett mapp hopper teleporting window system environment resource issue reilly associates jan richardson stafford-fraser wood hopper virtual network computing ieee internet computing january february scheifler gettys window system acm transactions graphics april schmidt lam northcutt interactive performance slim stateless thin-client architecture acm symposium operating systems principles sosp kiawah island south carolina december solomita xmove version beta ftp ftp columbia pub xmove november solomita kempf duchamp xmove pseudoserver window movement resource issue july wood richardson bennett harter hopper global teleoporting java ubiquitous personalized computing nomadics san jose march ylonen kivinen saarinen rinne lehtinen ssh protocol architecture internet engineering task force internet-draft draft-ietf-secsharchitecture- september zandy miller livny process hijacking eighth international symposium high performance distributed computing hpdc redondo beach august zwicky cooper chapman building internet firewalls edition reilly associates sebastopol june 
-way fanout -way fanout -way fanout daemons fraction offered load flat -way fanout -way fanout -way fanout daemons fraction offered load flat -way fanout -way fanout -way fanout daemons fraction offered load flat -way fanout -way fanout -way fanout nication model synchronous waves messages tool front-end root process tree generalizing multicast reduction capabilities ladebug parallel debugger ygdrasil suited synchronous request response model tools parallel debuggers contrast mrnet communication model supports multiple simultaneous asynchronous collective communication operations tools built mrnet ygdrasil share similar architecture internal processes distinct tool back-ends lilith architecture tool back-end code process lilith process network tool extensibility lilith ygdrasil implemented java advantage language natural ability load code dynamically mrnet trades ease extensibility higher potential data throughput -based data serialization network processes mrnet called overlay network defines logical network overlays physical network overlay network projects data aggregation functionality similar mrnet ganglia defines hierarchical overlay network mrnet infrastructure monitoring clusters federations clusters supermon servers organized hierarchical infrastructure data aggregation systems designed support high throughput ill-suited collecting manipulating application performance data sampled high frequency ganglia relies availability multicast clusters enabled target systems data aggregation studied context parallel databases shatdal naughton suggest algorithms efficient data aggregation parallel databases gray suggest ways efficiently implementing data cube aggregation operator approach separate network aggregator processes mrnet parallel database tag sql-based interface expressing data aggregation queries relational database model representing aggregation results collected wireless sensor networks similar mrnet tag supports multiple simultaneous aggregation operations supports streams aggregated data response aggregation request tag supports ordinal data aggregation mrnet flexibility filters align aggregate timestamped data tag sql relational interface contrast rpc-style interface tag organizes sensors ad-hoc routing tree mrnet network configuration priori configuration file work software-based collective communication focused providing multicast data ing interface standard defines broadcast data reduction operations mpi implementations serialized point-to-point operations implement collective operations provide optimized implementations magpie mpi collective communication primitives optimized applications run geographically-distributed environment grid magpie process tree consisting flat single-level tree root efficient communication wan binary tree efficient communication local network acct system automatically tunes mpi collective communication algorithms based modelling experimental results tailoring algorithms system mpi application runs optimized mpi implementations universally depend availability high-performance mpi layer efficient collective communication parallel tools mpi reductions restrictive mrnet data aggregations applied ordinally operands finally tool mpi conflict mpi monitored application common tool start-up scenario process manager creates tool back-end processes create application processes back-end processes supposed transparent process manager mpi-based programs mrnet mpi collective communication safe tools monitor mpi applications advocate mrnet substitute mpi implementation efficient broadcast data reduction support acknowledgments paper benefited hard work past present members paradyn research group victor zandy bryan wylie fruitful discussions topic john gyllenhaal jeff vetter chris chambreau barbara herron charlie hargreaves computing environment asci blue pacific advanced simulation computing program national nuclear security administration united states america department energy http nnsa doe gov asc home htm february alexandrov ionescu schauser scheiman loggp incorporating long messages logp model journal parallel distributed computing july susanne balle personal communication november balle brett chen lafranceaggregation support applications message passlinden approach parallel debugger architecture sixth international conference para espoo finland june published lecture notes computer science fagerholm eds springer heidelberg june bernaschi iannello collective communication operations experimental results theory concurrency practice experience april brown falgout jones semicoarsening multigrid distributed memory machines siam journal scientific computing center computational research buffalo state york http ccr buffalo february culler karp patterson sahay santos schauser subramonian von eicken logp practical model parallel computation communications acm november earth simulator center http jamstec february etnus llc totalview user guide document version january http etnus evensky gentile camp armstrong lilith scalable execution user code distributed computing sixth ieee international symposium high performance distributed computing hpdc portland oregon august evensky personal communication november forecast systems laboratory national oceanic atmospheric administration http hpcs fsl noaa gov feb gray chaudhuri bosworth layman reichart venkatrao pellow pirahesh data cube relational aggregation operator generalizing group-by cross-tab sub-totals data mining knowledge discovery april hollingsworth miller goncalves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques pact san francisco california november karp sahay santos schauser optimal broadcast summation logp model acm symposium parallel algorithms architectures velen germany june kielmann hofman bal plaat bhoedjang magpie mpi collective communication operations clustered wide area systems acm sigplan notices august lawrence livermore national laboratory multiprogrammatic capability cluster http llnl gov linux mcr february lawrence livermore national laboratory asci blue pacific http llnl gov asci platforms bluepac february madden franklin hellerstein hong tag tiny aggregation service ad-hoc sensor networks symposium operating systems design implementation osdi boston massachusetts december massie chun culler ganglia distributed monitoring system design implementation experience california berkeley technical report http ganglia sourceforge net talks parallel computi ganglia-twocol pdf february message passing interface forum mpi message passing interface standard international journal supercomputing applications fall winter miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november shatdal naughton adaptive parallel aggregation algorithms acm sigmod record sottile minnich supermon highspeed cluster monitoring system cluster chicago illinois september uoe hpcx http hpcx february vadhiyar fagg dongarra automatically tuned collective communications acm ieee conference supercomputing dallas texas november waheed rover hollingsworth modeling evaluating design alternatives on-line instrumentation system case study ieee transactions software engineering june 
page playing inside black box dynamic instrumentation create security holes abstract programs running insecure malicious hosts cited ripe targets security attacks enabling technology attacks ability easily analyze control running program dynamic instrumentation technology analysis control embodied dyninst api library dynamic instrumentation easy construction tools inspect running process obtaining structural information program control execution program libraries dynamically loaded process address space splice code sequences running program remove replace individual call instructions entire functions technology provided demonstrations exposing vulnerabilities distributed scheduling system condor bypassing access license server word processor framemaker demonstration shows danger remote execution job system unknown pedigree demonstration shows vulnerabilities software license protection schemes types vulnerabilities long speculated show tool dyninst api easily accomplished discussion vulnerabilities discuss strategies compensating introduction programs execution long considered immutable objects object code libraries emitted compiler linked executed program require revisiting compile link steps contrast running program object examined instrumented re-arranged fly dyninst api portable library tool builders construct tools operate running program previous tools required special compiler linker run-time library tools based dyninst operate directly unmodified binary programs execution papers show technology subvert system security discussions based cases exposing vulnerabilities distributed scheduling system condor bypassing access license server word processor framemaker condor study create lurker processes left latent host condor pool lurker processes lie wait subsequent condor jobs arrive infected host lurker dyninst attach newly-arrived victim job control control lurker victim job make requests back home host causing execute wide variety system calls license-server study constructed collection dyninst-based tools allowed understand control flow application framemaker program result detect remove framemaker contact license server addition frequent checks framemaker cached valid license credential dyninst-based tools locate neutralize checks studies provide suggestions make vulnerable attack barton miller mihai christodorescu robert iverson tevfik kosar alexander mirgorodskii florentina popovici computer sciences department wisconsin madison dayton madison usa bart mihai riverson kosart mirg pif wisc february page dyninst api dyninst architecture-independent library making on-the-fly modifications running program require special preparation executable re-compiling re-linking figure shows organization software tool based dyninst api tool called mutator linked dyninst api library makes api calls control modify application program called mutatee dyninst library attaches mutatee usual process debugging interface provided operating system ptrace proc unix process control api windows operations reading writing memory mutatee performed dyninst directly interface complex operations allocating memory executed library installed dyninst mutatee called run-time instrumentation library rtinst dyninst mutator splice code patches sequences machine instructions locations mutatee mutator provided structural information including application call graph intraprocedural control glow graphs list function entry points exit points call sites dyninst architectureindependent mechanism code patches terms familiar program data control flow operations including assignment logic arithmetic branching function calls individual function calls mutatee replaced calls functions existing newly loaded program calls function replaced mutator mutatee dynamically load libraries dll time make inferior rpc mutatee asynchronously execute function mutatee including functions part mutatee code functions libraries loaded dyninst attack lurking condor job attack demonstrates dyninst technology expose security vulnerabilities distributed computing environment background condor system users schedule run application programs idle hosts widely-distributed environment condor users user accounts privileges theses hosts condor takes responsibility running application programs harm machines run remote execution idiom expose condor user security risks figure dyninst api operation mutator mutatee process hijacker application process process modifications application rtinst library process modifications dyninst dyninst api library process modifications application code february page condor application typically linked special version system-call library library replaces standard system calls rpc stubs forward calls back user submitting machine condor starts program remote execution machine starts shadow process receives remote system calls application program executes normal privileges submitting user figure remote system call path back type security threat remote machine subvert application program make inappropriate malicious requests user requests include accessing modifying deleting private files originating e-mail proliferating virus initiating password cracking software path provide attacker access inside organization firewall crunchy environments crispy soft inside vulnerable suppose user submitted lawful job scheduled malicious malicious superuser gain control condor job superuser modify image job run time make execute arbitrary system calls worse demonstrate ability normal condor user submit malicious job time takes control user application program make inappropriate system call requests remote execution scenario unique condor occurs web browser down-loads java applet applet contacts server fact typically constrained communicate originating server make queries requests easily subvert applet server perform inappropriate actions cite key concept dyninst library makes easy control program analyze execution execute arbitrary instructions clever applications technology avoid special privileges make difficult trace source intrusion attack strategy steps subvert condor job submit malicious job condor normal submissions process time future condor schedule malicious job idle computer figure note computer organization submitting user condor flock located organization possibly geographically common condor configuration job run figure condor job execution application program linked condor rpc library causing system calls execution machine processed submitting machine application program shadow process process modifications application condor rpc library remote system calls code submitting machine execution machine february page anonymous restricted user typically malicious job creates process forks call process lurker figure malicious job departs completing checkpointed migrated condor figure lurker process wait innocent condor job arrives figure newly arrived job user lurker attaches job intercepts system calls inappropriate calls home node innocent job figure figure creating lurking process innocent condor job shadow process process modifications malicious condor rpc library remote system calls application submitting machine execution machine malicious job scheduled condor shadow process process modifications malicious condor rpc library remote system calls application submitting machine execution machine malicious job forks lurker process lurker submitting machine execution machine malicious job terminates departs lurker shadow process process modifications innocent condor rpc library remote system calls application submitting machine execution machine innocent job arrives infected lurker shadow process process modifications innocent condor rpc library malicious system calls application submitting machine execution machine lurker intercepts system call path lurker introduces destructive calls february page notes malicious job designed run long period time resulting checkpointing migration multiple times subsequent host visits option creating lurker process malicious job terminates migrates lurker process left running dormant lurker process lie idle 
long time springing action subsequent condor jobs arrived departed making difficult attribute authorship malicious job demonstrated dyninst create malicious lurking jobs job compiled run linux hosts tested isolated condor pool local clusters malicious job simply waited innocent job attached caused modify files innocent user home directory added entries rhosts login files intruder free access login host protecting lurker attacks clear approaches condor add security basic approach create sandbox shadow process sandboxing techniques include restrict system calls shadow accept restricted calls include process creation fork exec network access socket process control kill restrict access file directories restriction simple severe chroot limit shadow access current directory flexible policies possibly per-job policies security machine increased techniques include unix versions sun solaris set allowable system calls process created condor starts job disallow calls fork preventing creation lurking processes operating system kernel perform restriction condor remote system call library job call functions fork job simple create assembly language version call clean job migrates completes condor check processes created user remove thinks job host lurker processes caught strategy user multiple user condor large collection user cycled starting jobs lurking process access subsequently arriving jobs jobs run condor cycled list technique desirable condor requires organization add user ids machine condor pool current unix platforms default standard user privileged per-host administration techniques effective host trusted malicious owner privileged access bypass techniques general running job malicious host problematic topic researching attack subverting license checking attack demonstrates dyninst technology subvert commercial software license protection background modern software products form checking user legally authorized run program february page checks intended prevent piracy enforce software vendor product licensing terms common approach license checking involves data external source protected file secured network server verifying validity goal bypass checking attain full program functionality license data obtained developed dyninst-based tools analyze running program prior information executable access source code target application framemaker word processing tool adobe tests performed ultrasparc iii running solaris focused programs license server results easily extended products local license files evaluation application similar cases access remote stored credential appears similar well-defined place program attack strategy approached problem bypassing license checking angles attempted program black box capture replay traced flow control program understand license checking performed combination methods helped understand program behavior step modifying license checking capture operations dyninst attach mutatee trace library functions performs making applicable analyzing behavior programs network communications replace open read write send recv library function custom versions open sets trace file read write modified copy data mirror file save contents temporary files socket activity data worth analyzing technique located operations specific contacting license server trace operations application traced control flow function call level application tracing control flow cases application successfully contact license server case failed locate license checking occurs important determine functions skipped replaced avoid failure license check attack toolkit attack techniques embodied collection tools built tools simplified analysis task generally similar tasks tools include function call tracer function argument parser java dyninst compiler tools accessed interfaces dyninst command line interpreter license bypasser gui function call tracer dyninst tracing easy insert code beginning end function mutatee inserted code generate output mutator interpret depth call stack order calls return values function reported avoid inserting excessive instrumentation incrementally instrumented program calls call stack starting main calling function insert trap entry exit points function entry instrumented function insert trap function calls made function exit function remove traps calls made function call function completes remove entry exit traps february page step discover call function pointer immediately identify destination call case instrument call site determine address callee address dyninst library map address function result eventually generate complete call graph application approach similar dyninst-based paradyn performance tools automatically instruments application program searching performance problems function argument parser function argument parser makes easy track type parameter function application program compiled debugging information user information developed tool helps automate process parsing strings int open char int oflags int mode char strcpy char char determine arguments information passed code-snippet generator produce dyninst api calls generate instrumentation code instrumentation code inserted application collect parameter return values provide detailed analysis internal workings application program java dyninst compiler javad simplify task creating code snippets built java dyninst compiler dyninst api calls operate machine-language level building code sequences simple interface cumbersome error-prone manually construct sequences java dyninst compiler javad supports arithmetic expressions function calls statements snippet insertion loops dyninst constructs included compiler figure shows java snippet conditionally opens file sequence dyninst calls class public int open string path int flag int mode public static void main string argv int test test open filename wronly creat figure java input javad compiler dyninst api output february page dyninst command line interpreter dynit dyninst command line interpreter called dynit access previously analysis tools dyninst code generation primitives includes debugger-like process control commands dynit scripting facility aids performing repeated experiments dynit code generation functions provide command line interface basic code snippet construction insertion primitives snippet definitions constructed re-used code insertion include simple insertion function call function replacement process control commands user start stop insert breakpoints control tracing inspect print function state information license bypasser gui license bypasser gui top level tool accessing tool set user walk call graph target application search list functions call called specific function list modules license-related functions application load user-defined libraries replace function calls continue execution dynit commands accessible bypasser gui figure shows part gui attacking framemaker traced network framemaker application allowed successfully contact license server prevented making successful contact traced control flow framemaker previously tools found functions directly perform kind license-related activity transitivity functions functions called function call total functions total functions framemaker inspecting top level functions discovered characteristics framemaker relative license checking initialization phase framemaker main function calls nlopenlicenses contacts license bpatch function openfunc imagefindfunction open bpatch vector bpatch snippet openargs bpatch variableexpr test threadmalloc imagefindtype int bpatch arithexpr arithexpr bpatch assign test bpatch constexpr -arith expr bpatch constexpr path filename bpatch constexpr flag wronly creat bpatch constexpr mode openargs push back path openargs push back flag openargs push back mode bpatch funccallexpr opencall openfunc openargs -function call bpatch 
vector bpatch snippet statementsinsideif statementsinsideif push back pointer statement bpatch sequence ifsequence statementsinsideif bpatch boolexpr boolexpr bpatch test bpatch constexpr bpatch ifexpr ifexpr boolexpr ifsequence -if epression figure java input javad compiler dyninst api output february page server retrieves license data stores memory nlopenlicenses fails license retrieved program continues initializing steps setting windows reading user defaults most-recently-used document list configuration settings end initialization phase main calls nluichecklicense function checks license data memory valid license obtained framemaker displays dialog box user demo mode exit demo mode user save files calls changeproducttodemo fmexit depending user input program continues execution displays standard framemaker tool bar license checking validation performed user opens create document license data missing invalid figure interface license bypasser gui february text warning lack license displayed access full functionality denied full page functionality enabled user proceed creating editing saving documents license checking validation code called frequently user edits document initial license check validation successfully bypassed licensing checks steps steps facilitated dyninst modify executing framemaker application allowed retrieval license data fail prevented framemaker entering demo mode deleting function call changeproducttodemo bypassed license data validation skipping sequence code performed modified license data validations succeed presence license data memory modification changing nluichecklicense return true controlled failure mode successfully ran framemaker license obtained license server protecting application license attacks ways good software engineering practices make easier find parts application related checking licenses common functions obtaining license verifying validity encapsulated functions consistently application clean design intended make software reliable easier maintain easier incorporate functionality characteristics person intends circumventing checks basic code obfuscation techniques make type checking difficult techniques include obscure naming modules functions violating modularity implementations functionality multiple implementations include license check function include error reporting code checking code detects violation report error simple task detect calls error reporting code list stack-trace showing functions reported error conclusions goal paper provide concrete examples kinds problems caused speculations years easy monitor control running program easy make arbitrary program behavior dyninst library makes type activity commodity condor framemaker examples intended show specific ways techniques applied production software tension decision reveal security problem raising awareness providing strong incentive fix problem problems secret innocent users software application system vulnerabilities openness problems raises general awareness community general improvement security techniques paper present challenges security community safe remote execution including preventing inappropriate operations prevent undetected modification spoiling computational results difficult problem significant study problem providing selective authorization run application program similarly challenging problems present scientific commercial concerns spawn interest research coming years february page buck hollingsworth api runtime code patching journal high performance computing applications winter cain miller wylie callgraph-based search strategy automated performance diagnosis euro-par munich germany august collberg thomborson low manufacturing cheap resilient stealthy opaque constructs acm symposium principles programming languages popl january hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference knoxville hollingsworth miller cost control instrumentation overhead theoretical computer science april invited paper hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques november san francisco california litzkow livny mutka condor hunter idle workstations international conference distributed computing systems san jose california june litzkow livny experience condor distributed batch system ieee workshop experimental distributed systems huntsville oct livny basney raman tannenbaum mechanisms high throughput computing speedup journal june miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november special issue performance evaluation tools parallel distributed computer systems zandy miller livny process hijacking ieee international symposium high performance distributed computing los angeles august february 
benchmarking mrnet distributed tool infrastructure lessons learned philip roth dorian arnold barton miller computer sciences department wisconsin dayton madison usa pcroth darnold bart wisc abstract mrnet infrastructure scalable multicast data aggregation functionality distributed tools evaluating mrnet performance scalability learned important lessons benchmarking large-scale distributed tools middleware automation essential successful benchmarking effort leveraged benchmarking process microbenchmarking invaluable establishing performance low-level functionality design verification debugging resource management systems substantial improvements support running tools applications finally demanding experiments attempted early benchmarking effort increase chances detecting problems tool experimental methodology introduction desire solve large-scale problems driven development increasingly large parallel distributed computing resources performance debugging system administration tools work small-scale environments fail scale systems applications larger heterogeneous mrnet parallel tool infrastructure designed reduce cost important tool activities mrnet scalable multicast data aggregation support designed distributed tools contrast typical parallel tool organization shown figure mrnet-based tools incorporate tree processes tool front-end back-ends commonly called tool daemons shown figure communication mrnet-based tools occurs logical data streams data stream manipulated filters evaluated performance scalability mrnet measuring performance simple test harness tool real-world tool simple test tool provided controlled environment verification benchmarking fundamental multicast data aggregation operations debugging integrating mrnet paradyn parallel performance tool provided opportunities benchmarking mrnet performing complicated surprising collective communication operations performance data aggregation clock skew detection identifying tool experimental methodology ease task benchmarking large-scale parallel tools evaluating performance scalability mrnet learned important lessons benchmarking tools large-scale environments found automation essential successful benchmarking effort benchmarking process benchmarking effort leveraged automation batch resource management system scheduling experiments shell scripts generate batch jobs entire scalability study scripting functionality control tool experiment run found leveraging automation benchmarking process require substantial modifications tool remove tool graphical user interface batch system learned micro-benchmark experiments important goal show mrnet scalability real-world work supported part department energy grant de-fg lawrence livermore national lab grant nsf grants cdaand eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon setting examining mrnet simple test tool invaluable gauging performance lowlevel mrnet operations verifying design debugging initial implementation experimental methodology identified critical improved tool support resource management software target environment found resource management system lacked support running applications tool control forcing rely clumsy hoc workaround schemes perform benchmarking experiments finally noted debugging large-scale experiments early benchmarking process increased scale experiments expose bugs software experimental methodology hidden smaller scales paper organized section provide overview mrnet infrastructure present lessons learned benchmarking mrnet section summarize lessons learned benchmarking effort section mrnet mrnet software infrastructure scalable group communication customizable data aggregation distributed tools tools mrnet linking mrnet library mrnet api mrnet api encapsulates interactions system mrnet internal processes form tree connects tools front-end back-ends tree processes enables scalable group multicast reduction communication internal process ability apply filters manipulate in-flight data tools applications distribute data processing functionality section present overview mrnet previous paper describes mrnet features interface implementation quantitative performance detail mrnet interface mrnet library exports api tool network internal processes communication substrate tool front-end back-end components mrnet api consists network end-point communicator stream objects network object instantiate mrnet network processes access end-point objects represent tool back-ends geometry mrnet network customized configuration file specifies connection topology host assignment mrnet internal processes mrnet automatically generate variety standard topologies users custom mrnet topologies based physical topology underlying hardware performance load-balancing reasons mrnet communicator object container groups end-points communicators provide handle identifies set end-points point-to-point multicast broadcast communication mrnet stream logical channel connects front-end end-points communicator mrnet streams transport tool-level data packets downstream front-end back-ends upstream back-ends front-end figure components typical parallel tool mrnet-based parallel tool shaded boxes show potential machine boundaries user interface analysis control back-end process back-end process back-endnprocessn- user interface analysis control back-end process back-end process back-endnprocessn- mrnet network instantiated tool group end-points communicator communicator create stream newly created stream send receive data components connected stream simplified shown figure front-end code variable definitions lines instance mrnet network created line topology specification config file line newly created network object queried auto-generated broadcast communicator end-points line communicator build stream floating point maximum filter find maximum floating point data upstream filters discussed section mrnet data packets carry typed data types primitives format strings similar printf scanf functions integer floating point scalar send receive calls mrnet adds specifiers arrays simple data types lines broadcast integer initializer await single floating point result back-end code reflects actions front-end tool back-end connects mrnet network creating network object configuration file line contrast front-end streamspecific recv call back-ends call version recv returns integer message tag front-end stream object representing stream frontend send data finally back-end sends scalar floating point upstream front-end mrnet internal processes mrnet internal processes implement streams logical channels data flows system addition data packet routing forwarding internal processes appropriately apply filters data flow streams established front-end control messages mrnet network identify components part stream filter data packets stream packet header identifier determines stream packet belongs filters applied packet internal processes end-points packet forwarded mrnet employs techniques provide highthroughput communication packet batching groups series packets destined process fewer larger messages reduce communication overhead mrnet zero-copy data paths packet passes functional layers internal process manipulated avoid unnecessary copying mrnet filters data aggregation process transforming multiple input data packets output packets mrnet filters aggregate data packets filters bound stream created mrnet distinguishes synchronization filters receive packets time output packets synchronization criteria satisfied transformation filters input group packets perform type data transformation data contained packets output packets synchronization filters independent packet data type transformation filters operate packets specific type mrnet synchronization filters mechanism deal asynchronous arrival packets children nodes mrnet supports synchronization modes wait wait packet child node time wait time packet arrived child wait output packets immediately transformation filters combine data multiple packets performing aggregation yields front end main network net communicator comm stream stream float result net network config file comm netgetbroadcastcomm stream stream comm fmax fil streamsend float max init streamrecv result back end main stream stream network net int val net network netrecv val stream val float max init streamsend rand float figure mrnet front-end back-end code data packets transformations synchronous carry state transformation operation 
mrnet built-in transformation filters basic scalar operations min max sum average integers floats concatenation input scalars output element vector mrnet tool developers add filters provided set load filterfunc function takes filter function shared object filter function returns identifier bind filter streams function leverages operating system api managing shared objects dlopen dlsym unix systems mrnet instantiation support modes instantiating mrnet-based tools environments resource manager mrnet cooperates system resource manager launch tool simple environments mrnet instantiated primitive remote shell facilities rsh ssh mode instantiation shown figure mrnet relies resident resource management system create mrnet processes accommodate cases mrnet properly instantiate tool back-end processes mrnet provide environment needed create processes successfully cases mrnet creates internal processes recursively instantiation mode instantiate back-end processes tool starts tool back-ends resource system mrnet shared filesystem information transfer method provide back-ends information connect mrnet internal process tree parent processes host names connection port numbers mode instantiation shown figure mrnet creates internal back-end processes mrnet topology configuration determine hosts components located starting front-end parent node created consults configuration remote shell facility create children nodes internal proa mrnet spawns level internal processes internal processes spawn tree levels parallel resource management system rms creates tool back-end processes tool back-end processes connect leaves mrnet internal process tree figure mrnet instantiation resource management system tool front-end instantiates mrnet mrnet spawns internal process tree recursively parallel remote shell utility rsh mrnet internal processes instantiated tool issues request resource management system start tool back-ends backends connect leaves mrnet process tree complete mrnet instantiation rms bebe cesses application end-points hosts newly created process establishes connection parent process created parent process connection send child process portion configuration relevant child continue instantiation sub-tree rooted child benchmarking mrnet lessons learned evaluate mrnet measured performance scalability simple test tool micro-benchmarking integrated paradyn real-world parallel performance tool evaluated mrnet asci blue pacific system lawrence livermore national laboratory evaluating mrnet recognized important lessons benchmarking tools large-scale distributed environments automation essential simplest experiment plans automation essential completing experiment plan successfully time exploited automation benchmarking effort including lcrm batch system llnl scheduling running experiments shell scripts generate jobs comprising entire scalability study time tool scripting support hardwired control tool control individual experiment runs early benchmarking effort chose lcrm batch system scheduling launching experiments blue pacific reasons decision lcrm blue pacific policy severely limits number nodes interactive jobs node limits reasonable batch jobs batch jobs request dedicated resources interactive jobs share nodes interactive jobs batch system greatly reduces experimenters schedule experiments find free resources launch monitor experiments fact batch system allowed run smaller-scale experiments simultaneously greatly reducing time required perform scalability study performed scheduling manually doubt run experiments concurrently difficulty scheduling monitoring jobs submitting experiment jobs batch system developed set mrnet spawns level internal processes internal processes spawn tree levels parallel leaves internal process tree spawn tool back-ends figure mrnet instantiation environments resource management system tool front-end instantiates mrnet mrnet spawns internal process tree recursively parallel remote shell utility rsh mrnet internal processes created mrnet spawns tool back-ends remote shell utility complete mrnet instantiation parameterized shell scripts generated submitted jobs entire scalability study exhibiting automation ease benchmarking process benchmarking mrnet crude manual approach managing experiments collecting performance data sed awk scripts extract data experiment standard output file pasted data spreadsheet spreadsheet charting functionality generate initial graphs step simplistic techniques experiment management system electronic notebooks zoo karavanic experiment management system zenturio automate data management experiment generation activities performed manually lcrm batch system proved substantial benefit managing experimental plan reducing time required experimentation automating experimental process lcrm job submission scripts led significant costly real-world tool approach running experiments unlike simple test tool paradyn designed on-line interactive tool graphical user interface interactive experimentation paradyn graphical user interface feasible scalability studies evaluate mrnet run programs window system-based gui batch jobs blue pacific judicious xauth command case program gui displayed job runs rejected approach experimentation reasons delay submitting job run vary greatly depending jobs batch queue number nodes requested job interactive jobs experimentation requires operator present start control monitor experiments tedious error-prone task delay imposed displaying tool gui remotely non-negligible perturbed benchmarking results adapted paradyn experimental methodology experiments submitted run user interface run interactively user controls paradyn interacting graphical user interface removed user interface experiments scripting hardwired control logic control tool experiment run paradyn supports minimal tool scripting functionality metric definition language files support limited setting parameter values creating application processes tool start-up control tool application processes created added hardwired control logic tool start application configure tool collect performance data needed benchmark tests finally found approach allowed automate benchmarking process adapting tool experimental methodology costly strongly recommend tool builders design tools automation mind supporting non-interactive mode tool run graphical user interface providing tool scripting support exposes tool functionality scripting language recommendations important developing on-line tools paradyn interact application runs micro-benchmarks invaluable design validation debugging important goal benchmarking mrnet show scalability performance context real-world tool initially examined behavior important low-level mrnet functionality simple controlled environment implemented test harness tool performed micro-benchmarks tool measured latency instantiating mrnet process network latency single broadcast reduction pair throughput performing repeated mrnet reductions micro-benchmarks invaluable establishing performance scalability mrnet quantitative results previous work validating mrnet design exposing subtle bugs implementation difficult detect realworld tool benchmark results micro-benchmark experiments critical verifying mrnet design finding bugs prototype implementation results round-trip latency scalability study expected find clear exponential increase roundtrip latency mrnet small steady increase latency mrnet initially results roughly exhibited trends exhibit smooth curves expected increased number tool back-ends investigation found mrnet micro-benchmark results falling victim nagling algorithm tcp socket performance enhancement option sends small messages delayed hope send occur concatenated original send turned nagling algorithm mrnet sockets micro-benchmarks confirmed scalability mrnet multicast data aggregation operations higher level communication complexity paradyn bug difficult uncover based solely results real-world tool experiments experience micro-benchmarks provided strong evidence critical resiliency reliability distributed infrastructure address mrnet resiliency reliability future work resource management systems improved tool support early mrnet benchmarking effort realized resource management system target environment critical improved tool support starting paradyn mrnet processes application batch job supported batch system blue pacific 
requiring clumsy hoc workaround support experimentation llnl ibm systems including blue pacific batch system requests ibm loadleveler allocate node partition job set environment partition job processes typical case job batch script invokes poe parallel process launcher command start mpi application loadleveler-provided environment poe create application processes node partition necessarily process processor nodes typical llnl batch system loadleveler poe usage model insufficient experiments application processes tool processes mrnet processes running time llnl batch system support co-scheduled jobs run application processes tool processes mrnet processes node partition application processes distinct tool processes avoid tool perturb application behavior effect divide loadleveler node partition sub-partition application sub-partition tool processes sub-partition mrnet internal processes starting application tool partition llnl batch system requires modifications paradyn carefully-crafted job batch script micro-benchmark experiment jobs job batch script determine names nodes allocated partition node running job script allocated run tool front-end script allocates subset nodes running application tool daemons paradyn daemons run nodes application processes communicate performance data application process daemon shared memory nodes run application processes tool daemons written poe host file list remaining nodes passed mrnet configuration generator utility produces mrnet configuration file finally job script starts paradyn front-end providing location application node file mrnet configuration file front-end launches paradyn daemons poe host file written earlier paradyn daemons initialize waits establish connection mrnet front-end instantiates mrnet network instantiation mode mrnet creates internal processes create tool back-ends front-end finishes tool startup issuing request mrnet connect leaves tool daemons daemons connected mrnet paradyn performs mrnet-based start-up activities clock skew detection determination location functions lack support running tools applications restricted resource management system blue pacific endemic resource management systems mpps clusters grid tool daemon protocol tdp promises alleviate problem tdp defines interface tools resource management systems exposes information control functionality resource manager tool allowing resource manager directly control application process experimentation ability co-schedule jobs lcrm sub-partition loadleveler partition greatly simplified experimental approach recommend resource management systems provide capabilities support tool experimentation run scale early neared end mrnet benchmarking effort found poor approach running large-scale experiments started benchmarking natural experiment smaller scales expose fix bugs mrnet implementation experimental methodology found time increase scale experiments increasing tool back-ends power found problems evident smaller scale problems included hardcoded limits paradyn tool infrastructure race conditions manifest concurrency present tool system debugging fixing problems scale inevitably re-run experiments smaller scales changed code approach turned highly inefficient retrospect served adopting approach ran large-scale experiments early benchmarking effort frequently experimental plan approach maximizes likelihood finding bugs manifest scale leaving time identify fix situations resources required extremely large-scale experimentation infrequently jobs processors allowed run daytime blue pacific approach improves chances obtaining needed resources summary mrnet parallel tool infrastructure scalable multicast data aggregation functionality evaluate mrnet measured performance scalability simple test tool paradyn realworld performance tool test tool measured latency throughput simple collective communication operations increased number tool backends experiments gave confidence mrnet design initial implementation mrnetbased paradyn implementation measured tool start-up latency increased number tool daemons measured tool ability process performance data generated daemons varied load increased number daemons process evaluating mrnet learned important lessons reinforced lessons knew benchmarking tools large-scale environments automation essential successful benchmarking effort leveraged benchmarking process micro-benchmarks invaluable verifying design debugging low-level tool functionality resource management systems significant improvement support running tools applications resource management developers recognize importance supporting tools embrace approaches tool daemon protocol clumsy workarounds continue tools resource management systems demanding experiments early benchmarking effort benchmarking mrnet demanding experiments large-scale experiments tool back-ends approach increases chances detecting bugs tool experimental methodology occur scale chances sufficient time deal bugs acknowledgments paper benefited hard work past present members paradyn research group chris chambreau jeff vetter barbara herron charlie hargraeves john gyllenhaal environment asci blue pacific lawrence livermore national laboratory asci blue pacific http llnl gov asci platforms bluepac february lawrence livermore national laboratory livermore computing resource management system lcrm http llnl gov computing tutorials lcrm november geist schwidder jung nachtigal ornl electronic notebook project http csm ornl gov geist java applets enote november hollingsworth miller goncalves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques pact san francisco california november ioannidis livny gupta ponnekanti zoo desktop experiment management environment international vldb conference bombay india september karavanic miller experiment management support performance tuning san jose california november miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november miller cortes senar livny tool daemon protocol tdp phoenix arizona november prodan fahringer web service-based experiment management system grid international parallel distributed processing symposium ipdps nice france april roth arnold miller mrnet software-based multicast reduction network scalable tools phoenix arizona november stevens tcp illustrated volume protocols addison-wesley reading massachusetts january 
abstract present systems reliable sockets rocks reliable packets racks provide transparent network connection mobility user-level mechanisms system detect connection failure seconds occurrence preserve endpoint failed connection suspended state arbitrary period time automatically reconnect end connection address correct recovery in-flight data rocks racks interoperate ordinary clients servers introduce general user-level enhancement detection protocol enables remote detection rocks racks socket enhancement system affect applications ordinary sockets rocks racks provide functionality implementation models rocks intercept modify behavior sockets api interposed library racks packet filter intercept modify packets exchanged connection racks rocks introduce small throughput latency overheads deem acceptable level mobility reliability provide introduction present systems reliable sockets rocks reliable packets racks transparent network connection mobility ordinary applications userlevel mechanisms systems major features common automatically detect network connection failures including caused link failures extended periods disconnection change address process migration seconds occurrence automatically recover broken connections loss in-flight data connectivity restored application systems establishes connection safely probes remote peer presence rocksor racks-enabled socket falls back ordinary socket functionality present finally designed ready-to-use ordinary users systems re-compiling relinking existing binaries making kernel modifications rocks installed unprivileged users failure detection recovery mechanisms reliability features intended enable applications transparently endure travails mobile computing moving network unexpected link failure modem failure laptop suspension rocks racks automatically resume broken connection end matter address rare cases ends move time rocks racks provide callback interface third-party location service interface value-added services provided rocksor racks-aware applications rocks-expanded api re-api remote detection sockets enhancements accomplished user-level enhancement detection protocol edp protocol achieves tricky task enables userlevel socket enhancements test compatible functionality end connection affecting unenhanced applications non-trivial costs protocol borne client reasonable deploy production servers interfere network infrastructure network address translation nat devices firewalls protocol general purpose mobility systems msocks mobile tcp sockets support systems enhance sockets functionality compression encryption quality-of-service edp end common practice reserving ports encrypted non-encrypted network services imap major difference rocks racks track communication rocks based library interposed application code operating system library exports sockets api application permitting transparently dropped ordinary applications extending behavior functions mask connection failures application contrast racks based separate user-level daemon advanced kernel-level packet filter redirect flow selected packets daemon packet filters functionality include linux netfilter freebsd divert sockets racks require code interposed processes approaches distinct advantages drawbacks implement transparent enhancements network communication functionality user-space requiring kernel modifications implementations complete distribute maintain real applications avoiding kernel modifications main benefits facilitates deployment kernel modifications maintained kernel version inherently unportable system administrators rightly paranoid apply kernel patches provide functionality absolutely user-level mobility easier combine process checkpointing mechanisms rocks expand scope condor process migration include distributed jobs communicate sockets checkreliable network connections victor zandy barton miller computer sciences department wisconsin madison zandy bart wisc permission make digital hard copies part work forpersonal classroom granted fee provided copies made distributed profit commercial advantage cop-ies bear notice full citation page copy republish post servers redistribute lists requiresprior specific permission fee mobicom september atlanta georgia usa copyright acm point parallel programs based mpi rocks ideal abstraction functionality user-level abstraction portable compatible user-level kernel-level checkpointing mechanisms replacement sockets api save communication state aware application-specific details message formats buffering rocks racks key component system roaming applications goal enable migration host entire context desktop application including network user interface state introducing modifications application operating systems network infrastructure systems complement functionality existing mobile networking systems layered network stacks support mobile tcp migrate option recover connections preserved systems disconnected periods longer tcp retransmission timeout hand users install kernel mechanisms required network stacks network infrastructure required mobile rocks racks replace functionality user-level mechanisms rocks racks support mobility model fine-grained mobile mobile requires applications address move rocks racks enable independent mobility individual connections freedom enables individual connections easily migrated hosts summarize contributions paper user-level techniques transparent network connection mobility including mechanisms failure detection connection suspension connection recovery preserves in-flight data comparison implementation techniques userlevel packet filtering interposition techniques transparently enhancing functionality network connection issues transparency performance user-level edp remotely determining enhanced socket functionality rocks racks present end tcp connection analysis role unreliable connection-less protocols udp presence network connection reliability mobility remaining sections paper section discusses tcp failure model motivated work section presents enhanced socket detection protocol section presents architecture functionality rocks discuss issues implementation model section presents racks section discusses security issues rocks racks section discusses rocks racks process checkpointing migration section discusses approach reliability mobility udp section evaluates performance rocks racks section discusses related work network connection failure model rocks racks extend reliability tcp detecting failures tcp connections preventing applications aware review essential background tcp relate failure modes mobility events tcp review tcp reliable bi-directional byte stream communication processes running separate hosts called local host peer host figure operating system kernels host maintain state end tcp socket tcp socket identified internet address comprised address port number pair addresses identifies tcp connection applications manipulate sockets calls sockets api tcp reliability mechanism based pair buffers socket scheme acknowledging retransmitting data local application process writes socket local kernel copies data socket send buffer transmitting peer data remains send buffer periodically retransmitted kernel receives acknowledgement receipt peer local kernel receives data peer copies destination socket receive buffer sends back acknowledgement receive buffer holds data consumed application process process pass data tcp stored combined space local send buffer peer receive buffer limits maximum amount in-flight data data passed process kernel end consumed process kernel end exist time tcp connection tcp connection failures occur kernel aborts connection aborts primarily occur data send buffer unacknowledged period time exceeds limits retransmission defined tcp abort include request application unacknowledged tcp keepalive probes receipt tcp reset packet peer reboots types netfigure established tcp connection sockets api application code network local host data flight local host peer host data flight peer host local host tcp socket receivebuffer sendbuffer kernel sockets api application code peer host tcp socket receivebuffer sendbuffer kernel work failures reported layer abort occurred socket invalid application events leading aborts mobile computer users routinely perform actions lead abort tcp connections actions include disconnection mobile host disconnected link unreachable user moves wireless range link fails modem drops 
connection host suspended change address host move physical subnet requiring address suspended host lose address dhcp subsequently provide change address lead failure tcp connection time endpoint attempts send data change physical address process migration applications execution move computer process migration important mobility feature people multiple computers laptop travel separate desktop computers home work frees users restart applications move migration types failures address process process migration mechanism migrate kernel state separate process socket descriptor underlying kernel socket original kernel socket closed aborted descriptor process refer non-existent socket characteristic sockets long obstacle migration applications sockets host crashes peer crashed host reach retransmission limit host host reboots receive reset message response packet sends host explore host crashes paper entail application recovery connection recovery detecting socket enhancements establishing connection systems protocol enhancement detection protocol detect remote socket supports systems trigger fall back ordinary socket behavior connection rare exceptions protocol transparent application code end network connection mobility protocol generalpurpose approach safe portable user-level remote detection type socket enhancement servers freely protocol imposes trivial performance penalty accepting connections unenhanced clients significant costs protocol incurred clients socket enhancements verified protocol works standard services including ssh telnet ftp windows tricky remotely distinguish enhanced socket ordinary user-level mechanisms problem enhanced socket unmistakably presence remote processes enhanced sockets affecting socket enhancement code simply announce presence connection established suggested unenhanced process misinterpret problematic separate connection scheme creating connection conflict processes participate scheme tcp socket options tcp options read written user space emulating tcp privileged raw socket socket options construct distinct socket configuration remotely sensed protocol figure client probe client server perform step protocol establish client server enhanced client opens connection server client closes end connection writing sockets api function shutdown server detects end-of-file announces response enhanced closes connection client receives announcement server enhanced closes connection client announcement client opens connection server sends announcement enhanced server client mutually aware enhanced enhancement negotiation client server exchange messages agree enhancements enhancement initialization client server perform enhancement-specific initialization application communication protocol complete application code begins normal communication enhancement announcement exchanged pattern extremely produced unenhanced clients servers server generates long byte random byte array announcement client returns array enhancement announcement announcement pattern shared enhanced server processes interesting cases enhanced client connects unenhanced server performs steps protocol server close reset end connection obliviously send data case client receive announcement server aborts protocol reverts ordinary behavior server client abort strange server quietly leave open connection closed writing client happen happen client timeout prevent hanging timeout period multiple time connect succeed conservative estimate time round trips unenhanced client connected enhanced server perform steps protocol includes reading half-closed connection unexpectedly receive announcement generated server client behavior bizarre worth accommodating remote shell client implementations shutdown similar send commands data server apply case finally client connections reach servers server application replicated device distributes incoming connections multiple server machines arrangement affects protocol replicated servers non-uniformly enhanced problem deployment protocol reliable sockets reliable sockets implemented library interposed application process kernel ends tcp connection figure library exports sockets api application code enable transparently dropped ordinary applications library exports rocks expanded api re-api enables mobile-aware applications set policies behavior reliable sockets library manually control mechanisms give overview reliable sockets architecture operation describe experience rocks issues pertinent system attempts interpose user-level functionality application code kernel rocks overview operation reliable socket summarized state diagram shown figure reliable socket exists states closed connected suspended note states correspond reliable socket behavior affects process internal tcp socket state maintained kernel reliable socket begins closed state establish reliable socket connection application code makes usual sequence sockets api calls create tcp connection handled kernel system sockets library calls handled rocks library performs steps test interoperability rocks library performs edp reverts socket ordinary socket behavior peer support rocks racks establish data connection data connection tcp connection reliable socket connection established application communication figure socket enhancement detection protocol connect shutdown read connect accept read write accept eof enhanced tcp handshake enhanced rocks racks rocks close write read write read write read write read close read write read write write read server enhanced tcp handshake client enhanced client probe client announcement enhancement negotiation enhancement initialization application communication client server figure reliable sockets architecture figure reliable socket state diagram rock in-flightbuffer application code network local host data flight local host peer host data flight peer host local host tcp socket receivebuffer sendbuffer kernel re-api sockets api rocks library sockets api rock in-flightbuffer application code peer host tcp socket receivebuffer sendbuffer kernel re-api sockets api rocks library sockets api closed connected suspended connect acceptclose tcp failure reconnect abor initialize rocks establish identifier connection based addresses connection endpoints timestamp perform diffie-hellman key exchange authentication exchange sizes kernel socket buffers sockets api establish control socket control socket separate udp socket exchange control messages peer detect failure data connection steps rock connected state connected application rock ordinary socket rock buffers in-flight data application size in-flight buffer sum size tcp send buffer size peer tcp receive buffer maximum number bytes flight rock peer application sends data rock puts copy data in-flight buffer increments count bytes older data in-flight buffer discarded make room data in-flight buffer sized guarantee data received peer remains buffer application receives data rock increments count bytes received connection failures detected primarily heartbeat probes periodically exchanged control sockets unlike tcp retransmission mechanism heartbeats detect connection failures seconds minutes sensitivity tuned re-api per-connection basis work connection idle tcp keep-alive probe detect failures idle connections poorly suited reliable sockets hour minimum default period generally lowered per-connection basis system-wide basis privileged users rock switches suspended state detects received successive heartbeats number adjusted re-api separate control socket motivated difficulty combining application data asynchronous rocks control data tcp connection flow single connection transmit heartbeat probes ordinary data flow blocked tcp rocks suspend perfectly good connections tcp urgent data mechanism type communication limitations sockets receive urgent data out-of-band sending heartbeat connection application data interfere applications telnet rlogin make urgent data operating systems including linux out-of-band data received previously received urgent data consumed application merged data stream record position possibly corrupting application data guarantee heartbeat consumed arrives 
cient context-sensitive intrusion detection jonathon gif somesh jha barton miller computer sciences department wisconsin madison e-mail fgiffin jha bartg wisc abstract model-based intrusion detection compares process execution program model detect intrusion attempts models constructed static program analysis historically traded precision ciency address problem dyck model rst cient statically-constructed context-sensitive model model speci correct sequences system calls program generate stack occurring function call sites experiments demonstrate dyck model order magnitude precise context-insensitive nite state machine model null call squelching dynamic technique bound cost dyck model operates time similar contextinsensitive model present static analysis techniques designed counter mimicry evasion attacks branch analysis identi test programs system call sites affecting control return values interprocedural argument capture general values recovers arguments previously reported techniques introduction host-based intrusion detection seeks identify attempts maliciously access machine detection system executes remote intrusion detection identi hostile manipulation processes executing distributed work supported part naval research grant department energy grants de-fg de-fg lawrence livermore national lab grant nsf grant eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices xed thereon views conclusions contained authors interpreted necessarily representing cial policies endorsements expressed implied government agencies government computational grid intrusion detection systems monitor processes running local machine unusual unexpected behavior malicious modelbased detection system model acceptable behavior monitored process model describes actions process allowed execute monitor compares running process execution model ags deviations intrusion attempts model-based intrusion detection detect unknown attacks false alarms system detects attacks model nes acceptable process behavior behavior attacks false alarms low non-existent properly constructed model model captures correct execution behaviors constructing valid precise program model challenging task previous research focused basic techniques model construction human speci cation training static source code analysis static binary code analysis static binary code analysis requires human interaction determination representative data sets access program source code unsuitable interpreted-language analysis constructs models execution paths process follow false alarms occur imprecise model incorrectly accept attack sequences valid static binary analysis construct nite state machine accepts system call sequences generated correctly executing program models constructed static program analysis historically traded precision ciency precise program representations generally context-sensitive push-down automata pda prohibitively expensive operate wagner dean suggested precise digraph model simply precise models proved expensive earlier work regular language overapproximations context-free language model due cost paper presents model structure suffer drawbacks dyck model highly precise context-sensitive program representation runtime behavior slightly worse cheap imprecise regular language model dyck model powerful expressive full pda model early result chomsky proved context-free language homomorphism intersection dyck language regular language chomsky result implies dyck model powerful pda model ciency gains observe loss correctness dyck model detect broad class attacks generally model detects attacks execute arbitrary code code match expected behavior process host-based intrusion detection includes attempts exercise race condition invalid control repeatedly execute code sequence attempts bypass security checks impossible paths appendix attempts execute programs command insertion unsanitized arguments subshells changing symbolic link target exec call buffer overruns heap ows format string attacks force jump injected code dyck model suited remote intrusion detection detection technique identi hostile manipulation remotely executing programs send system calls local machine execution successful remote manipulation means local system executes malicious system calls stronger threat model host-based intrusion detection setting attackers exploit vulnerabilities speci points execution replace entire image remote process attack tool arbitrary execution point modeling remote job dyck model monitoring stream remote system calls arriving local machine detect remote manipulation produces invalid call sequences paper makes primary contributions dyck model enabling cient context-sensitive program modeling dyck model represents substantial improvement statically constructed program models dyck model exposes call stack monitor model operation highly cient monitor explores exact call path application experiments bear claims test programs show order magnitude improvement precision dyck model contextinsensitive model model precision procmail improved context-insensitive model dyck model measured average branching factor metric excluding recursive call sites impossible paths exist dyck model sequences system calls accepts program produce null call squelching dynamic method limit null call generation developed null call squelching prevent excessive null call generation reducing security squelching combines static dynamic techniques generate null calls provide context system call squelching enabled worst-case number null calls generated system call bounded diameter program call graph present dyck model null call squelching section ciency gains demonstrate squelching previous experiments context-sensitive pda completed model update failed terminate reasonable time dyck model operational cost nears context-insensitive nondeterministic nite automaton nfa model data analyses counter mimicry attacks interprocedural data analysis model arguments passed return values received system calls combination analyses hinder mimicry evasion attacks restricting paths program model accept attack sequence discuss data analysis section related work human-speci model-based intrusion detection security analyst manually speci correct behavior program interest annotates source code describe security properties runtime monitor enforces manually model alternative systems check behavior speci cation malicious activity systems reasonable small programs programs grow human speci cation overly tedious static dynamic program analysis scale automatically constructing models wagner dean statically analyzed source code extract contextinsensitive context-sensitive models cost operate precise context-sensitive abstract stack model prohibitively high unsuitable practical observed similar expense context-sensitive push-down automata constructed static analysis sparc binary code papers recommended imprecise context-insensitive models achieve reasonable performance dyck model presented paper signi cantly improves works providing precise context-sensitive model excellent performance characteristics wagner dean introduced impossible path exploit context-insensitive model includes paths originating function call site returning call site correctly executing program follow path due call stack attacker force impossible control exploit dyck model context-sensitive detects impossible path exploits dynamic analysis based seminal work forrest constructs program models observed behavior repeated training runs feng extended work sekar learn sequences system calls calling contexts vtpath program model database pairs sequential system calls stack occurring pair collected numerous training runs vtpath language regular language expansion context-free language bounded stack equivalent dyck model stack bound maximum depth program call graph ignoring recursion work differs feng important aspects dyck model fundamentally expressive vtpath ciency dyck model treats recursion regular limitation model dyck model correctly express context-sensitive recursive calls accept strictly context-free language vtpath model recursion recursive depths learned training accept regular language dyck model null 
prevent corruption operating systems flow normal tcp data blocked flow urgent data urgent data notification separate control socket avoids problems suspended rock automatically attempts reconnect peer performing steps establish data connection rock simultaneously attempts establish connection peer address address port number peer end previous data connection whichever connection attempt succeeds data connection authenticate rocks mutually authenticate challenge-response protocol based key established initialization establish control socket control socket established manner original control socket recover in-flight data rocks perform go-back-n retransmission data in-flight time connection failure rock determines amount in-flight data resend comparing number bytes received peer number bytes rock reconnection best-effort mechanism depends ability end matter establish connection rock establish connection end moved period disconnection blocked establishing connection firewall address peer masqueraded nat device ordinary applications recover cases re-api interface support mobile-aware applications alternate means recovery mobile-aware applications receive callback connection suspended reconnection timeout expires alternate address suspended rocks attempt reconnect days period time handles disconnections span weekend re-api change disable period per-rock basis rocks suspended longer switch closed state behave application ordinary aborted socket rock closes gracefully application calls close shutdown application attempts close suspended rock rock continues reconnect peer automatically performs normal close reconnected preserving case close semantics tcp outstanding case application attempt abort tcp connection converted rocks library ordinary close rocks abort mechanism distinguish connection failure intentional application-level close application depends abort semantics exist rocks control socket application abort provide programs rock rockd make simple rocks existing applications rock starts program rock-enabled program linking reliable sockets library run time rockd reliable socket server redirects client connection server ordinary tcp connection rock-enabled clients effectively establish reliable socket connections ordinary servers running rockd host server connection rockd server reliable immune tcp failures including server host address local host simplify rockd rock detects common client applications automatically attempts start rockd server host experience rocks daily basis year primarily interactive network clients ssh ftp telnet windows clients gnu emacs adobe framemaker hosts root access modified startup scripts servers rock server hosts establish rocks connections rockd restart applications addictive rocks widely generally works edp switches ordinary sockets run trouble rocks application main problem maintaining application transparency applications exhibit behavior interferes rocks library unanticipated ways point section illustrate major problems handled system interposition maintain application transparency link application reliable sockets library preloading feature linux loader commonly mechanism enables library linked binaries execution time preloading problems binaries support preloading performed static binaries depends dynamic linker security reasons disabled setuid binaries system libraries correctly support preloading resolver linux library static calls socket trapped preloading mechanism rocks steps problem patching library corrected calls run time requires knowledge problematic functions change library versions developing tool automate search rocks library library user interpose application link kangaroo condor created bypass toolkit multiple library interposition requires ordering libraries linkage intercepted function calls library consistent management file descriptors kernel resources virtualized libraries automatically libraries generated bypass co-exist interposed libraries assume layer closest kernel rocks state resides user space automatically managed kernel application calls fork passes underlying socket descriptor process unix socket rock shared ways rocks library things moves state rock shared memory segment forces sharing processes attach segment makes sharing processes responsible monitoring rock heartbeat triggering reconnection event failure sharing processes periodically verifies responsible process running chooses process resume responsibilities problem stemming rock sharing server daemon hands incoming client connections subprocesses find accepting reconnection attempts past connections handle case server rock accepts reconnection attempt locates indexing shared table identifier established initialization process end suspended connection passes connection similar problem user-level state rock occurs application calls exec left exec expunge process rocks state including rocks library retain underlying kernel sockets rocks library intercepts application call exec creates shares rocks temporary process sets environment variables preload rocks library exec call execute call fails library kills temporary process call succeeds rocks library loaded initialization library transfers state rocks temporary process call succeeds preloading work binary rocks library loaded temporary process eventually times closes rocks maintaining transparency requires virtualizing additional mechanisms including emulating polling asynchronous non-blocking semantics reliable sockets data read user-level buffer rocks library multiplexing timers signal handlers set application heartbeat mechanism virtualizing process control interfaces wait kill sigchld isolate processes created application created rock library issues difficult aggregation mechanisms introduced preserve transparency substantial socket enhancements support introduce additional operating system dependencies ported unix oriented comprise significant part effort port windows reliable packets seeking alternative application transparency problems created rocks library developed reliable packets goal supporting network connection mobility kernel execute process address space main idea packet filter manipulate packets exchanged kernel-level socket endpoints connection control behavior sockets api applications idea similar packet manipulation tcp migrate option tcp splice msocks proxy main differences racks perform packet manipulations kernel modifications provide additional functionality including interoperability long-term connection suspension automatic failure detection reconnection packet filter kernel mechanism enables user process select packets traverse host network stack packet selection based set matching rules combination tcp flags range source addresses process dynamically passes packet filter early applications packet filters included user-level implementation network protocols trading performance penalty passing network traffic user-kernel boundary convenience kernel independence racks tradition primary packet filters turned network monitoring kernel functionality enabled packets redirected user space replaced efficient mechanisms passing copies packets making systems racks difficult develop recently ability control packets user space returned operating systems primarily support firewall software implementation based recent linux netfilter technology freebsd divert sockets racks implemented daemon rackd packet filter insert flow packets local sockets network figure job rackd prevent local tcp sockets aborting due connection failure rackd executes separate process kernel application processes rackd lacks ability change binding kernel sockets processes allowed sockets abort rocks library recover connection rackd inspects packets flowing direction packet decides discard forward possibly modified destination time rackd inject packets destined end connection operations privileged linux rackd run root privileges compatible rocks rackd emulates behavior reliable sockets generating packet stream indistinguishable induced rocks library connections peer managed rackd takes advantage fine control packets simpler enhancement detection protocol detect failures separate control socket rackd exchanges messages rackd rocks library end connection initialization authentication reconnection rackd sends 
automatic generation analysis nids attacks shai rubin somesh jha barton miller wisconsin madison computer sciences department shai jha bart wisc abstract common elude signature-based nids transform attack instance nids recognizes instance misses avoid matching attack payload nids signature attackers split payload tcp packets hide benign messages observe attack instances derived simple transformations model transformations inference rules natural-deduction system starting exemplary attack instance inference engine automatically generate instances derived set rules result simple powerful tool capable generating attack instances nids testing determining sequence packets attack testing phases sets rules tool exposed vulnerabilities snort widely deployed nids attackers acquainted vulnerabilities construct instances elude snort tcp-based attack web-cgi attack attack signature type regular expression introduction goal network intrusion detection system nids alert system administrator time intruder penetrate network signature-based nids defines penetration malicious signatures ongoing activity matches signature alarm raised systems widely deployed simple provide concrete information events occurred weakness signature-based nids inability recognize attack attack signature attacker wishing stealthily penetrate network monitored signature-based nids exploit weakness ways attack signature nids attacks difficult find attack elude nids finding instance attack nids detect elude nids perform tcp reassembly attacker fragment attack signature tcp packets elude nids printable characters signatures attacker change signature http attack substituting equivalent hexadecimal ascii values characters url attacker find instance attack eludes nids nids useless study ability attackers find attack instances elude nids ability nids detect instances concrete translate abilities problems black hat problem nids instance attack find instance evades nids white hat problem instance attack sequence packets determine instance propose approach rigorously tackle problems observe variants attack methodically computed derived express attacker knowledge set inference transformation rules rule represents atomic transformation attacker hide attack signature starting attack instance inference engine successively apply rules automatically compute attack instances based combination rules finally deal black hat problem feed instances nids find undetected deal white hat problem check instance matches instances generated paper makes contributions agent nids testing attack analysis tool based notion attack derivation implemented agent attack generation nids testing tool agent addresses black white hat problems advantages unlike tools agent sound generating instances real attacks nids misses agent-generated attack nids vulnerable agent exhaustive capable generating attack instances instance set rules single instance evades nids agent find similarly agent show nids correctly identifies attack instances derived set transformations results show agent effectively finds nids vulnerabilities generating instances sequence packets agent provide proof sequence transformations obfuscation sequence real attack developers agent analyze attacks identify exact transformation nids fails handle attack derivation model computing attack instances formalized agent inference engine natural deduction system developed formal model computing attack instances model formalize black white hat problems model advantages model sound computes real attacks model exhaustive set transformations attack instance model computes attack instances derivable instance transformations model explanatory proof network event mutated attack event mutated attack proof sequence transformations links event attack instance event benign model asserts respect rules proof exist model agent appears insensitive derivation starting point starting points derive attack instances experience shows rules attacks paper starting point derives instances model applications testing knowledge formal method determine tcp sequence implements attack previously developed attack model formally defines notion tcp sequence implementing model computes tcp sequences implementing deriving initial instance transformations preserve semantics formal model essential examining capabilities single nids comparing capabilities nidss improving widely deployed nids agent found vulnerabilities snort exposed vulnerabilities tcp engine snort snort handles http requests pattern-matching algorithm attacker acquainted vulnerabilities caused snort miss tcp-based attack http scripting attack attacks require wildcard characters signatures foo bar reported suggested fixes vulnerabilities snort development team immediately fixed fixed future rest paper organized section presents related work section illustrates variants real attack derived presents agent architecture section discusses agent implementation section formalizes notion derivation natural deduction section presents vulnerabilities found snort demonstrates agent capability analyze attack instances related work review related work areas attack transformation nids evaluation counter evasion techniques protocol verification deductive databases attack transformation methods ptacek newsham semantics preserving tcp transformations elude nids tested implemented tool packet manipulation similarly handley paxson discussed evasion techniques based inherent ambiguities tcp protocol researchers systematically address nids evasion techniques unlike work research formal model combine transformations tool automatically tools mutate attacks originated work table discuss tools differ agent attack transformation tools attacktransformation tools combine multiple transformations fragroute mutates tcp-based attacks whisker mutates http attacks randomly combine transformations user nids testing limitations address work preserve attack semantics systematically search space attack instances miss instances elude nids snot stick mucus family packet-mutation tools snot stick synthesize raw network packet tcp packet matches snort signature mutated packet perform dos attack snort mucus hand nids testing tool synthesizes packets match snort signature writing random data packet fields required signature testing feeds packname generation capabilities sound transformations implemented handles white hat problem fragroute full-session tcp-based attacks subset transformations whisker full-session http attacks full-session tcp http transformations mucus single tcp udp packets single packet tcp udp transformations thor full-session attacks fragmentation agent full-session attacks full-session tcp finger http ftp table major tools attack variation testing methodology ets nids tools generate raw packets testing nids patternmatching mechanism nids ability detect udp based attacks tcp-based attacks nids produce alert tcp packet generated mucus hard nids discarded packet part tcp session scanned packet missed signature due vulnerability pattern matching algorithm comparison nids misses agent-generated attack necessarily case nids vulnerable agent mucus complement intend explore ways incorporate randomness agent work closest thor thor launches mutated attacks analyze detection capabilities set idss thor mutates attacks altering semantics based concept activity variations analogous semantics-preserving transformations conceptual level extend work developing computational model combine transformations systematic practice address issues work address handling inference transformations bounding number generated attacks thor implementation includes single transformation fragmentation agent implementation includes tcp application-level transformations tools mentioned ability find vulnerabilities agent discovered tools generate full tcp sessions expose vulnerabilities evasive rst table nids mechanism tracks state tcp session tools transport applicationlevel transformations expose vulnerabilities ftp padding table interaction nids mechanism handles tcp packets performs pattern matching concurrently work vigna developed tool combine transformations found vulnerabilities snort iss realsecure set transformations agent found 
message injecting data local socket sends message tcp packet sequence number sequence number data emitted local socket message acknowledged local socket remote end longer synchronized sequence numbers rackd rewrites packets forwards map sequence acknowledgement numbers expected socket establish connections control rackd rackd configures packet filter redirect packets tcp syn flag set packets three-way handshake tcp connection establishment receives outbound initial syn packets connection attempts issued local client sockets inbound attempts remote clients connect local servers initial syn address port number ends connection created information rackd select subsequent packets connection initial syn originates local socket rackd completes three-way handshake behalf initial sequence number supplied initial syn blocks local socket packets exchanged handshake performs edp client probe established connection closes rackd local socket complete three-way handshake sending original initial syn packet edp probe determined peer enhanced rackd takes control connection releases connection configuring packet filter cease redirecting packets local socket connection established original initial sequence number messages exchanged function rackd initial syn originates remotely rackd local socket perform three-way handshake rackd data watches initial events remote client client performs client probe rackd sends enhancement announcement client closes ends connection client sends enhancement announcement exchanges reliable sockets initialization messages rackd releases connection connection establishment protocol short circuited rackd present ends connection sending initial syn rackd modifies packet include tcp option produced rackd rackd receives initial syn option includes option packet three-way handshake figure reliable packets architecture host localtcp socket kernel user packet network filter outboundpacket flow inboundpacket flow application process rackd point ends connection mutually aware racks support immediately packet handshake initialize reliable sockets connection tcp option rackd option hosts racks detect failures established connection tcp keepalive protocol separate control socket rackd periodically sends standard keep-alive probe tcp packet payload sequence number sequence number acknowledged peer rackd end receives packet forwards remote socket response remote socket sends standard reply keepalive probe acknowledgement current sequence number sending rackd acknowledgements serve role heartbeat asserts viability connection technique unaffected keepalive option processes end connection tcp responds probes option set tcp affected presence probes usual keepalive protocol rackd connected rack connected rock rackd manages separate control socket suspends connection rackd prevent local socket aborting happen unacknowledged data send buffer application enabled tcp keep-alive probe rackd sends local socket tcp packet advertising receive-window peer packets local socket peer viable accept data local socket periodically probes remote socket change condition connection suspended rackd acknowledges probe leaving window size unchanged tcp implementations discouraged closing windows manner peers required cope remain open long probes acknowledged racks reconnect reliable sockets end connection attempts reconnect address peer rackd receives initial syn remote socket checks destined previous local address suspended racks handles syn incoming reconnection maintain consistency local socket rackd rewrites packets connection match source address port numbers sequence numbers expected receiving socket function similar performed tcp splice msocks security rocks racks provide additional protection existing security problems network connections end rocks racks guarantee suspended connection resumed party possesses key established initialization obtained diffiehellman key exchange protocol key secure passive eavesdropping ordinary network connections rocks racks vulnerable man-in-the-middle attacks staged key exchange connection established resolving limitation requires trusted party authenticate connection endpoints applications require additional level security register callbacks reapi invoke authentication mechanism initialization reconnection easily extend rocks racks interface public key infrastructure waiting technology widespread rocks racks compatible existing protocols encryption authentication ssh ipsec encrypted connections common case daily addition rocks racks sensitive denial-of-service attacks consume resources ordinary connections additional memory consumption occurs user level rocks library rackd additional kernel resources consumed rock control socket rackd packet filter rules represent types denial-of-service attacks lower requirements attacker bring host process checkpointing rocks racks extend process checkpointing mechanisms handle parallel programs mpi pvm direct message routing mode free checkpoint mechanism knowledge library-level communication semantics application rocks racks recovery mechanisms operate underlying sockets common denominator contrast systems checkpoint parallel programs cocheck mist explicitly aware communication library application existing process checkpoint mechanisms advantage reliable sockets modification process linked rocks checkpointed state rocks library automatically saved rest process address space process restarted checkpoint rocks library detects socket file descriptors invalid initiates recovery process rocks migrated connections simply restarting checkpoint host racks complicated checkpoint added racks checkpointing support user-level checkpoint library linked process checkpoints rack checkpoint consists state maintained rackd rackd buffer in-flight data contents kernel socket buffers directed checkpoint library rackd induces socket transmit contents unacknowledged data send-buffer advertising large receive window checkpoint library obtains receivebuffer contents reading socket restoring rack checkpoint checkpoint library passes checkpoint rackd creates socket connects socket special address rackd intercepts packets exchanged connection establishing normal connection resumes connection checkpoint restore socket buffers checkpoint library sends send-buffer contents socket rackd transmits receive-buffer contents local socket process checkpointing functionality enabled rocks racks ways tolerate failure single node process running node checkpointed restarted node recovers checkpoint migrate process node restarting checkpoint node manner entire application migrated set hosts migration performed process time ensure successful reconnection alternately network proxy developing roaming applications enables subset processes migrated time generally re-api link arbitrary mechanism locating migrated process rocks library racks rocks obtain global checkpoint parallel application application restarted hardware failure care ensure checkpoint globally consistent approach stop process checkpoints processes checkpointed application resumed general approach require entire application stopped chandy lamport distributed snapshot racks rocks checkpoint migrate processes ordinary mpi application running mpich application runs cluster workstations mpich device clusters application started process signalled checkpoint terminate stop technique plan extend condor support mpi applications include checkpointing migration obtain globally consistent checkpoint process stop checkpoints condor responsible restarting udp rocks racks obvious fit udp-based applications mobility features rocks racks clear benefit udp applications enabling program continue communication change address extended period disconnection streaming media applications automatically continue user disconnection movement hand reliability features rocks racks udp simplify reliability mechanisms udp applications reliable delivery data compromise application performance poorly matched reliability model udp inherently unreliable applications udp prepared lost duplicated out-of-order datagrams applications generally timeouts trigger retransmission lost data decide communication aborted difficult rocks racks override timer-based mechanisms require understand application sufficiently separate timer events related communication failure trigger events user-level 
call instrumentation detects attacks vtpath null calls reduce non-determinism enabling monitor track process execution appendix presents static analyzer constructing dyck model analyzes system call arguments return values prevent mimicry attacks dyck model includes restrictions valid arguments acceptable execution directions based system call return values vtpath model learned model ignore arguments return values context-free dyck model compact program representation worst case regular language expansion bounded context-free language vtpath grow exponentially large view static dynamic analysis techniques complementary static analysis overapproximates acceptable program behaviors generates model miss attacks conversely dynamic analysis underapproximates acceptable behaviors leading high false alarm rate ultimately hybrid model based approaches advantageous minimizing drawbacks technique chose present dyck model context static analysis appears equally suited dynamic analysis hybrid approach model construction infrastructure completeness presentation included summary infrastructure work area readers familiar work skip paper major contributions dyck model section mimicry attack defenses section tool features components binary analyzer runtime monitor analyzer reads sparc binary program static program analysis construct model program additionally rewrites binary program code enable precise cient modeling user executes rewritten binary security-critical environment runtime monitor tracks execution rewritten binary ensure analyzer constructed model deviation model security violation occurred program model nite state machine language nes sequences system calls application generate correct execution model construction progresses stages read binary program construct control graph cfg procedure application cfg represents control ows procedure convert control graph nondeterministic nite automaton nfa models correct call sequences function produce compose collection local automata points internal user function calls form single interprocedural automaton modeling entire application runtime monitor enforces program model operating interprocedural automaton runtime figure sparc assembly code functions system calls boldface figure presents nfa constructed function note system call transitions include arguments analyze data program reconstruct expression graph argument simulating execution machine instructions expression graph analyzer recovers statically argument values func save sethi file file call open mov mov mov cmp bge mov call action mov add call writewrap nop mov call action mov ret restore static char file filename void func int open file rdwr int action writewrap action action cmp ble mov sethi buf jmp read buf retl nop static char buf void action int filedes int size filedes read filedes buf size writewrap sethi root root jmp write mov static char root root void writewrap int filedes write filedes root figure sparc assembly code source code functions func action writewrap analyze binary code include source code aid comprehension code behavior recovery prevents attacker passing arbitrary arguments system calls observe rst argument read figure descriptor returned open dynamic statically recovered technique section presents technique recovery values automata desirable property system call modeling absence indirect function calls model safe exists input underlying function produces sequence calls language automaton accepts sequence monitor raise false alarms maintain safety property indirect call sites rst attempt argument recovery jump register targets test programs section analysis recovers indirect targets remaining cases mark call-site targeting function address call-site replacement constructs model entire application splicing local automata function call edges models program execution points function calls control shifts called procedure previous work constructed nfa pda global model model satisfactory nfa model figure imprecise cient context-insensitive model nfa offers excellent runtime performance suffers impossible path exploits impossible paths exist multiple call sites target procedure exist language accepted model superset program actual language includes paths actual program execution paths important attacker existence edges attack process detection bold path figure impossible path accepting repeated read write calls pda model adds context-sensitivity greater precision suffers extremely high runtime overheads figure shows pda includes model program call stack monitor traverse matching call return transitions impossible paths exist model stack model adds complexity operation pda straightforward execution fails presence left recursion post algorithm designed terminate left recursive grammar worst-case complexity cubic number aubuf action write root read func action writewrap open file action writewrap figure local function models write root read buf func open file writewrap action figure nfa program model bold cycle impossible path tomaton states leads unreasonably high runtime overheads binary rewriting mitigate cost pda operation null call insertion null calls dummy system calls observed monitor path execution process limits runtime exploration pda states dominated null call transition naive null call insertion shortcomings statically compute cost null call insertion point possibly leading high cost execution context information accurate attacker takes control application dyck model addresses shortcomings providing attack-resilient context-sensitive model dynamically controls null call cost write root read buf func open file pop push push pop writewrap action push pop pop pop figure pda program model func open write read writewrap action figure dyck model squelching dyck model developed dyck model rst cient statically-constructed context-sensitive model dyck model achieves greater ciency pda limiting state exploration pda dyck model includes stack record function call return locations dyck model stack update transitions symbols automaton alphabet monitor updates dyck stack precisely update ects actual program behavior produce stack update symbols insert null calls selected function call sites program precall immediately function call noti monitor calling location call returns program generates postcall null calls inserted call site call return path target function distinguishable postcall matching precall invoid func int open file rdwr int null call action null call null call writewrap null call null call action null call figure code dyck instrumen tation inserted null calls bold face user call null call indicating call return line numbers correspond figure gure shows code readability instrument sparc binary code dicates program attempting force execution impossible path language accepted dyck model bracketed context-free language originally developed ginsberg harrison precall postcall inserted call site correspond parenthesis symbols language form dyck language monitor accepts sequences correctly match paired preand postcalls note forced pairing stricter null calls previous work prevents introduction impossible paths attack attacker free insert change null calls wishes manipulations match correct program execution path figure shows dyck model null calls link entry exits target function model call sites function edges labeled precalls insert dyck stack edges labeled postcalls pop reaching state dyck model monitor follow transition observed symbol call stream conversely operating pda monitor replicate state follow stack 
push transitions states suffering greater overhead figure shows program rewriter inserts dyck null calls existing program recall instrument binary code precall postcall inserted immediately call site appendix formal nition dyck model selecting instrumentation points naive instrumentation lead excessive run-time overhead program execution generates null call func open write read writewrap action figure dyck model squelching high frequency recursion loops exacerbate number null calls produced cases execution backedge function control graph program call graph leads repeated null call site execution execution patterns correspond backedge traversal affect rate execution encounters null call insert dyck calls naively selection algorithm statically chooses function call sites avoid instrumenting instrument recursive call sites strongly connected component scc program call graph represents recursive cycle rule attens scc single node lose context sensitivity points recursion limit cost instrumentation instrument call sites execute system call note function execute system call entire subgraph program call graph rooted reaches system call prunes portions call graph uninteresting system call monitoring monitor follow program execution functions generate system call null call squelching strictly static technique adequately address looping problem developed null call squelching dynamic technique restricts null call generation squelching produces meaningful null calls indicating call stack state reaching system call null calls function call returns generating system call provide security information discarded show important results rst number null calls generated bounded diameter program call graph number system calls generated show model resists attacker manipulation begin describing squelching algorithm change selection null call instrumentation points modify semantics instrumentation create squelch stack program data space precall instrumentation pushes call site identi squelch stack send identi monitor modify system call sites send squelch stack system call precall identi ers squelch stack represent calling context system call squelch stack cleared postcall code examines state squelch stack stack empty system call site symbols monitor including precall call site postcall meaningful monitor stack empty call site generated system call application pops top element call stack inserting irrelevant null calls call stream algorithm discards slight expense stack activity application note postcall pops element match popped element mismatch program manipulation visible monitor occurred program kill attacker prevent termination observe manipulation uninteresting generated system calls squelch stack entered bad state revealed system call event squelching table line shows path dyck model figure null call squelching function call generate system call produces matched dyck pair call stream pairs provide system call context removed line shows call string pairs removed remaining dyck pair envelops system call application stack context point system call squelching runtime cost null call insertion notably reduced loss security change model construction incorporate null call squelching precall-postcall sequence converted -transition describe language transformation language accepted dyck model null call squelching language accepted squelching replace precall-postcall strings denoting recursive calls terminating precallpostcall strings exist generates squelched language figure shows dyck model transformed accept squelched language note pair replaced -transition directly nally show null call squelching imposes strict upper bound cost instrumentation theorem call graph program denote graph obtained strongly connected component collapsed single state maximum diameter generates true system calls execution worst-case number null calls generated proof appendix resilience attacker manipulation dyck model relies state application squelch stack rewritten call sites produce null calls state memory image process monitor attacker arbitrarily modify state claim dyck model resilient modi cation modi cations successful represent possibly legitimate program behavior attacker modify stack monitor detect added elements system call call path represented stack legitimate argument element deletion detected attempts introduce impossible path note denial-of-service attack releasing memory stack produce memory fault stack process killed myriad simpler means attacker modify code attacker prevent null call generation generate large number null calls send erroneous null calls equivalent stack manipulations previously discussed detected attempt introduce impossible path generating large number null calls terminate process squelch stack space exhausted monitor stores program model separate process space attacker modify model simply put modi cations state application produce valid call sequences accepted monitor attacker gains modifying state data flow analysis designed advanced data analyses counter mimicry evasion attacks recent literature papers stress monitor system call arguments return values prevent attacker system calls nops mimicry attack added object analysis infrastructure enables analyses data number monitored call string null calls open read read write open read read write table system call strings accepted dyck model strings correspond paths figure figure path accepted context free dyck model string null call squelching note large drop observed null calls dependence graph ddg represents complex interprocedural data ows appendix section presents argument capture method recover statically-known arguments branch analysis explained section ddg identify branch conditions dynamically set system call return values argument branch analysis reduce opportunities successful mimicry attack argument capture prevent attacker manipulating arguments passed system call ddg recover statically-known arguments analysis recovers statically-known data values step process paths data dependence graph collect expression graph simulates execution instructions expression graph determine analysis reliably construct expression graph statically analyzer marks unknown multiple execution paths set arguments differently recover sets integers set regular expressions string arguments dependencies return previous system call interprocedural approach general constant-valued intraprocedural capture previous work restricting possibilities successful attacker manipulation importantly argument recoveries prevent mimicry evasion attacks read system call transition figure argument recovery replace transition read buf read open buf rst argument return fromopen argument set values attacker transform read call nop argument recovery prevents manipulation branch analysis mimicry attack works attacker easily generate nop system calls steer model operation needed nop calls invalid arguments force call fail change system state failed system calls return error indicator legitimate programs corrective action monitor track return values system call arguments unknown attacker undetectably system calls fail branch analysis detects manipulation analysis determines expected subsequent process execution based return system call insert predicate transitions automaton control dependencies return values runtime monitor records return values traverses edge predicate evaluates true -transition ignores edge evaluating false attacker nop call steer execution call system calls match error case behavior actual application ddg reveals branch instruction line figure based return open insert predicate transitions action model branch behavior figure attacker open call nop invalid argument monitor detect intrusion read 
thread scheduling main benefit rocks racks udp applications source information mobility mobile-aware applications provide callbacks re-api notified failure detected rocks racks reconnection mechanism located remote peer callbacks replacement reliability mechanisms application provide mechanisms additional information communication failures rare cases full reliability features rocks racks udp application re-api application tunnel udp packets rocksor racks-managed tcp connection performance evaluated rocks racks data transfer throughput latency connection latency reconnection latency tcp connections stationary mhz intel pentium iii laptop mobile mhz intel pentium iii laptop running linux surprises additional context switches copying redirecting packets rackd makes racks expensive systems overhead rocks noticeable data transferred small packets performance effects racks significant occur larger block sizes startup cost rocks racks connection establishment significantly higher ordinary tcp connection order altogether feel overhead acceptable level mobility reliability functionality provided systems throughput latency attached stationary laptop baset ethernet switch department network measured tcp throughput latency mobile laptop links switch department wireless network home network connected internet cable modem uplink direction compared throughput latency ordinary sockets rocks racks varying block sizes block size size buffer passed socket send system call report average measurements runs figure overhead rocks racks vividly illustrated fast link blocks size bytes larger ordinary sockets rocks comparable throughput close link capacity sec smaller blocks throughput drops connection types drop larger rocks latency overhead rocks small usec independent block size attribute rocks overhead per-operation costs incurred data transfer rocks including overhead copying in-flight buffer periodic heartbeat interruptions rocks wrappers underlying socket api functions racks dramatic overhead throughput similar rocks small blocks larger blocks plateaus significantly lower rate sec higher per-block latency overhead unlike rocks increases block size attribute overhead additional per-packet rackd context switches system calls overhead copying packets rackd performance effects racks rocks easily discerned slower links exclusive access baset switch measurements cable modem networks subject varying conditions shared networks making difficult capture clear differences link standard deviation average throughput average latency cable modem standard deviation average throughput average latency conclude overhead racks apparent slower links overhead rocks connection measured connection overhead rock-to-rock connection rack-to-rack connection timed application calls connect report average times table rock connection time times higher time ordinary socket connection rack connection times higher expensive aspect connections key exchange authentication operation involves large integer arithmetic takes approximately times high connection times deem acceptable cost added reliability mobility reconnection measured amount time takes reconnect suspended rock rack reconnection time time restoration network connectivity rock spends establishing data control socket peer recovering in-flight data experiment suspended connection disabling network interface machine measured time elapsed re-enabled interface connection returned established state figure average rocks racks throughput latency baset cable modem links baset throughput block size bytes sockets rocks racks baset latency block size bytes sockets rocks racks throughput block size bytes sockets rocks racks latency block size bytes sockets rocks racks cable modem throughput block size bytes sockets rocks racks cable modem latency block size bytes sockets rocks racks connection type time usec ordinary sockets rocks racks table average tcp connection establishment time elapsed time multiple runs experiment seconds time time required restart non-trivial applications fail rocks racks small time scale events typically lead network connection failures change link device link device failure laptop suspension re-dial connect process migration related work techniques network connection mobility proposed unlike systems racks rocks emphasize reliability mobility viewing mobility network connection failure provide reliability integrating mechanisms rapid failure detection unassisted reconnection mechanisms preserving connection state distinguishing features systems implemented kernel enlist user-level protocol interoperate safely ordinary sockets mobile tcp sockets persistent connections interpose rocks library application code sockets api preserves illusion single unbroken connection successive connection instances connections mobile tcp sockets preserve in-flight data unspecified kernel interface contents tcp send buffer interfaces common persistent connections makes attempt preserve in-flight data mobile sockets handle tcp failures result abort tcp socket action destroys contents socket send buffer techniques depend external support re-establish contact disconnected peer interoperates safely ordinary applications mobilesocket java programs in-flight data reliability rocks racks in-flight data buffer similar rocks lacks automatic failure detection complicated in-flight data buffering scheme restricts application data flow lacks interoperability feature edp operate applications mobilesocket tcp migrate option experimental kernel extension tcp introduces state tcp state machine established connection enters disconnected returns connection re-established technique similar racks manipulates connection state packet level based modification kernel implementation transport protocol manipulation packets addition lacks automatic failure detection automatic reconnection support extended periods disconnection msocks architectural similarities rocks racks msocks proxy-based system enables client application process establish mobile connection ordinary server proxy kernel modification called tcp splice client moves close end connection establish affecting server tcp splice maps state original connection held open server state current connection held client tcp splice reimplemented user level rackd packet filter technique map packets local remote socket state addition msocks interposes library client application code operating system redirect socket api calls msocks proxy mechanism similar rocks in-flight buffer preserve data client server msocks lacks mechanisms automatic failure detection reconnection tcp splice implemented kernel alternative tcp-specific techniques mobile routes packets including tcp udp mobile host ordinary peers redirecting packets home agent proxy fixed host specialized kernel masking address tcp sockets mobile handle failures tcp connections depends external mechanisms detecting disconnection initiating reconnection conclusion rocks racks transparently protect ordinary applications network connection failures including caused change address link failure extended period disconnection unavoidable part life mobile computers failures occur unexpectedly non-mobile communication modems fail dynamic address leases expire rocks racks require modifications kernels network infrastructure work transparently ordinary application binaries enhancement detection protocol transparently revert ordinary socket behavior communicating ordinary peers routinely systems sockets enduser interactive applications remote shells remote gui-based applications checkpointing migrating parallel programs part ongoing work roaming application developing network proxy general network connection mobility proxy provide support simultaneous movement ends connection support rocksand racks-based connections ordinary peers support system acknowledgements somesh jha offered insightful observations rocks racks security made helpful suggestions paper phil roth made comments development paper joel summers marios skounakis convinced udp-based control socket reviewer observation led robust choice connection identifier braden requirements internet hosts applications support internet request 
vulnerabilities found vice versa unlike earlier work vigna investigate theoretical model systematically apply transformations address white hat problem applications attack transformations dacier noticed idss handle sets transformation methods developed tool evaluates potential set idss handle large set transformation methods manually identified methods ids supposed handle ids documentation prolog rules formulate knowledge automatically found set transformations set idss handle contrast test nids attacking analyzing potential capabilities wagner soto developed formal model based language theory find attack instances elude hostbased ids added system calls attack attack semantics preserved hids longer detect tan provide evidence theoretical model practice strongly support formal models intrusion detection knowledge provide formal model nids evasion type transformation scope paper code obfuscation recent research suggests identify transformations obfuscate viruses future intend explore ways integrate obfuscation transformations attack derivation model nids evaluation lippman present comprehensive effort evaluate ids capabilities critique mchugh compared capabilities idss detect set attacks contrast test single nids ability detect instances attack lee study ability nids handle packet loss due resource attack nids general packet loss semantics preserving transformation nids misses packet host accepts investigate paper fundamental limitation agent generating instances missing packets resisting evasion attacks handley shankar present techniques remove tcp ambiguities network connections techniques prevent evasive rst vulnerability found snort table knowledge methods widely deployed finally kruegel designed nids highly robust resource attacks agent implemented packet loss transformations testing system deductive databases security protocol verification protocol verification deductive systems model capability participants adversary security protocol techniques related approach deductive systems model power adversary improve agent performance intend explore techniques logic programs state-space reduction efficient bottom-up top-down evaluation approach overview illustrate main idea work instances attack systematically computed start examples attack instances ftp vulnerability illustrate instances variants instance derived repeatedly applying single step transformations present simple based real vulnerability discovered snort section present agent architecture based idea attack derivation vulnerability published buffer overflow commonly ftp server blackmoon ftp server windows can- exploiting overflow crash server present root privileges exploit overflow providing overly-long argument ftp cwd change directory command call attack ftp-cwd instance ftp-cwd present similar instances found hacker sites typical instance call ftp-cwd typ fig phases tcp packets tcp handshake ftp login achieved anonymous login iii benign phase attacker browses server benign ftp commands attack phase attacker launches attack sending long cwd command illustrate derivation ftp-cwd instance present shorter instance ftp-cwd fig called root ftp-cwd denoted ftp-cwd root respect rules derives ftp-cwd instances ftp-cwd root instance victimattacker tcp handshake ftp login benign ftp commands cwd aaaahhhhh ftp login cwd aaaahhhhhh victimattacker tcp handshake ftp-cwd typ instance ftp-cwd root instance figure ftp-cwd variants data successful ftp-cwd attack data condensed single tcp packet tcphandshake packets putting ftp messages required ftp-cwd user pass cwd single packet server response carry attack ftp application-level protocol indifferent number tcp packets deliver messages attacks considered paper implemented single packet computational model agent handle multi-packet attacks ftp-cwd typ ftp-cwd root attacker point view attacker exploit victim ftp-cwd typ exploit victim ftp-cwd root intuitively speaking infer ftp-cwd typ ftp-cwd root vice versa denotes tcp sequence denotes tcp sequence implements attack called instance transformation rules tcp-fragmentation instance attack anda obtained copying packets fragmenting single packet fragments instance ftp-padding instance ftp attack consists malicious ftp command login cwd command ftp-cwd attack obtained inserting benign ftp command login malicious command quit command instance call rules semantics preserving alter semantics tcp specification legal fragment tcp packets desired knowledge ftp attack inflated padded benign ftp commands exist ftp attack padded packets fragmented rules changed legal modifications ftp-cwd root instance ftp-cwd attack derive conclusion ftp-cwd typ instance ftp-cwd apply ftp-cwd root fragment single attack packet ftp login packets malicious cwd packet ftp-cwd typ apply add benign ftp commands attack natural deduction terminology ftp-cwd typ derived ftp-cwd root rules formally write ftp-cwd root turnstileleft ftp-cwd typ observations noted process illustrated define closure subset ftp-cwd instances derive ftp-cwd typ instance instances ftp-cwd rules derive instance ftp-cwd benign ftp commands fragmented tcp packets observation motivates automate derivation process enables identification ftp-cwd instance category generation instances nids testing purposes interference toderive ftp-cwd typ fragment attack add ftp commands add commands fragment attack observation simplifies practical implementation agent section theoretical aspects formal derivation model section inference process bi-directional shrinking rules de-fragmentation removal padding easy ftp-cwd root derived ftp-cwd typ bi-directional property suggests derivation process start attack instance finding instances elude nids overly sensitive derivation starting point observation section define starting points attack derivation model translate observations practice built agent tool derives attack instances representative instance attack set transformation rules agent address black white hat problems section agent comprised components fig closure generation set rules attack instance agent computes root instance ftp-cwd root fig generates instances derived root instance represented list tcp packets attack response packets instances stored file passed stage closure generation agent attack derivation model rules attack instance eluding instance search nids snort alert instance simulator check instance instance feasibility check optional attack segments real victim responses instance simulator real victim nids attack response packets figure agent architecture eluding-instance search stage finds attack instance eludes snort perform search implement instance simulator successively writes instances network simulator machine installed snort reads network search stops undetected instance found instances checked implemented simulator libraries construct raw tcp packets simulator plays complete tcp sessions including tcp handshake attacker victim packets termination procedures simulates average instances pentium iii mhz instancefeasibilitycheck machines connected lan separate attacker victim stage instance simulator send attacker packets victim responses generated real application strictly speaking stage unnecessary agent sound include validate methodology illustrate attacks found work wild agent implementation discuss core components agent describe implementation agent inference engine present transformation rules constructed attack instance start derivation process discuss customized inference-engine address black white hat problems inference engine implemented agent inference engine prolog starting set facts prolog program applies set inference rules successively generate facts implementation represents root instance prolog fact inference rules prolog rules prolog rule specifies set conditions conjunction hold derive conclusion rule conditions hold conclude tcp packets fragments packet represent attack sequence tcp packets attack packets attacker response packets victim choose tcp sequence represent 
symbol failed open call blocks path read call return branch analysis helps prevent development successful attacks evaluation evaluate program models criteria precision ciency precise models present attacker opportunity insert malicious system calls cient model adds small runtime overhead existing process execution cient models deployed precise models add security precise models generally higher runtime overhead demonstrate dyck model squelching presents excellent tradeoff precision ciency metrics standard techniques measure criteria average branching factor metric originally developed wagner dean measures model precision average branching factor dynamic measure adversary opportunity insert dangerous system calls running process call stream monitor operates call sites program workload functions instructions system user procmail filter message local mailbox gzip compress text eject open cd-rom drive tray fdformat format high-density oppy disk report process status processes cat concatenate les totaling table test programs workloads statistics open open action read figure model action branch analysis automaton model records potentially dangerous system calls accept call average branching factor total number calls divided number automaton updates performed monitor low average branching factor attacker opportunity undetectably insert malicious system calls call stream ciency measurements straightforward forms time length process execution model operation measure process runtime memory usage increase due binary code instrumentation model state monitor experimental design include precision ciency results test programs table shows workloads program note experiments reproducible execution depends constantly changing system state table statistics binary code program number user function call sites level interprocedural control transfers worst-case number dyck instrumentation points analyze statically-linked binaries statistics include linked library code test programs runtime monitor run solaris sun ultra mhz workstation procmail gzip eject fdformat cat average branching factor nfa dyck squelched dyck figure nfa dyck precision lower bars greater precision ram monitor test processes run simultaneously machine implemented support kernel trap monitoring application communicates monitor shared message queue purposes experimentation collection solaris libc kernel trap wrapper functions nes set system call events measured precision ciency programs monitor calculates average branching factor test program method determine runtime overheads unix time program measure wall time elapsed execution test program test program monitor execute machine time includes test process execution monitor execution operates automaton context switches processes time include setup time monitor parses program model measure memory usage recording maximum process image size observed return brk kernel trap ran experiments lightly loaded multi-user machine active users effects dyck model analyzed dyck model uenced precision ciency compared dyck model program base nfa dyck squelched dyck procmail gzip eject fdformat cat table program execution times seconds base execution time automaton operation percentages compare base execution models argument recovery branch analysis program unmonitored infrastructure instrumentation state machine increase procmail gzip eject fdformat cat table memory due instrumentation monitoring unmonitored base case ecution unmodi programs columns show additional due rewriting infrastructure instrumentation state machine structure monitor column shows percentage increase compared base case squelching nfa model previous work figure shows precision models test programs note dyck models improve precision order magnitude procmail improves average branching factor nfa model squelched dyck model squelched model appears slightly precise unsquelched dyck model side effect average branching factor calculation recall monitor divides number potentially dangerous system calls accepted execution number automaton operations average branching factor inversely proportional number events passed monitor squelched program generate fewer null calls unsquelched program leading slight increase average branching factor table presents execution times models measurement noise accounts slight timing variations note marked improvement dyck model includes squelching squelched dyck model produced times system calls nfa model depending program exception cat performance impact additional calls signi system-call-bound program cat additional time consumed null calls noticeable expect performance markedly improved batching dyck calls sending actual system calls minimize number user-to-kernel transitions squelching critical unsquelched gzip model generated times system calls base execution due loop iteration measured memory overhead monitoring squelched dyck model table overhead parts memory monitor process increased size instrumented executable monitor processes differing state machine read monitor code static data one-time cost shared multiple executions approximately code resides shared libraries processes system state machines shared memory sizes shown column instrumented binaries additional memory reasons program size increases artifact current rewriting infrastructure column overhead disappear transition rewriting environment areas project null call insertion adds code program shown column column shows percentage increase due instrumentation state machine structure monitor memory demands critical monitor large numbers processes system identi areas make substantial optimizations memory usage column reduced cient encodings state machines unaware published memory related projects results compare favorably procmail gzip eject fdformat cat average branching factor capture intraprocedural analysis constant values interprocedural analysis general values figure effects argument capture lower bars greater precision bars squelched dyck model black bars correspond black bars figure note average branching factor scale changed order magnitude figure effects argument capture squelched dyck model represents tradeoff precision ciency model investigate effects improved argument capture tested argument capture forms argument capture turned recovered arguments set intraprocedurally single constant previous work finally enabled complete recovery technique interprocedural analysis recover general representations call arguments figure shows model precision level capture test programs data flow analysis support mimicry tack detection mimicry evasion attacks exploit ciency program model monitor accepts attack system call sequence valid tan wagner soto stress monitor system call arguments return values mimicry attack prevention rst hardening mimicry attacks implemented branch analysis extended argument capture general values passed interprocedurally figure shows argument capture improvement table shows results branch analysis average branching factor poorly suited measurement branch analysis number call sites affecting branching advisory results promising system call sites set branches return affects program control branch analysis identi system call sites program affecting branches procmail gzip eject fdformat cat table branch analysis results table lists total number system call sites pro gram data size subset system call sites return affects program branching system calls test programs constantvalued intraprocedural argument capture corresponds previous work capture recovers general arguments passed interprocedurally stronger analysis recovers arguments depending test program partial results providing early indication effectiveness mimicry attacks current work mimicry attack detection prevention based analyzing attacks language containment problem formally language system call sequences accepted monitor determine attack sequences study 
attack majority attacks tcp snort rules target tcp communication representation exposes tcp parameters application data easy manipulate attacks tcp transformations application-level transformations tcp representation essential agent easy define transformation rules representations udp packets inference rules agent inference rules tcp sequence implements attack returns sequence implements inference rules definition sound produce sequence implements soundness ensures agent derives instances real attacks experience defining sound rules difficult task issues defining rules attack application-level protocol ftp rules section sound respect http attacks rule set specific application-level protocol operating system victim host protocol semantics depend implementation rule preserve semantics operating systems customize rule set operating system sounds complex practice easy process differences operating systems affect small number inference rules network transport levels interference rules rule preserves semantics applied preserve semantics applied rules find application-level transformation interferes transport level encountered interference tcp level tcp-permutation rule permutes packets sequence tcp-retransmission rule adds retransmitted packets sequence interference occurs define retransmitted packet appears original packet permute packets address issue section transformation define rules expanding shrinking rules shrinking rule reverses effect expanding rule vice versa adding benign ftp command expands ftp attack removing commands shrinks transformations change attack length sending tcp packets out-of-order artificially assign expanding rule tcp-permutation shrinking tcp-sorting overly shrinking attack change semantics applying shrinking rule require checking preconditions expanding rule instance rule removes ftp commands ensure remove malicious command building set inference rules time effort single set shared attacks application-level protocol amortized cost effort low cases specific rule unsound respect specific attack http-space-padding rule table nullify buffer overflow attack requires http request length envision large set rules distributed agent soundness rule respect attack consideration experience straightforward manner table summarizes tcp application-level rules supported agent detailed rule descriptions earlier report tcp level cover transformations fragmentation outof-order transmission permutation retransmission header change push flag change developed transformations application-level protocols ftp http andfinger chose ftp http common finger agent development simplicity finger exposed evasive-rst vulnerability snort section ensure soundness simulated attack instances evaded snort real servers bsd finger apache http server verified work rules unique add victim tcp acknowledgments part transformations nids performs stateful tcp inspection acknowledgments update internal tcp state orderings attack packets acknowledgments induce tcp states limited ability influence ordering attack packets victim acknowledgments attacker create ordering induces tcp state nids misses attack snort evasive-rst vulnerability section technical details added acknowledgments earlier report note issue victim responses tcp application levels part transformation fully investigated derivation starting point derivation process starts attack instance called root attack instance compute root successively applying shrinking rules rules applied general inname description fragmentation fragments attack packet packets adds victim acknowledgment packet permutation permutes packets tcp stream sound permutation preserves original order attack packets victim responses interference tcp-retransmission handled section retransmission family rules add retransmitted attack packet original stream focused retransmission evasive rst packets packet retransmitted rst flag set header change family rules change header attack packet practice paper pplication finger padding adds spaces username ftp padding adds benign ftp commands malicious command rule adds cwd tmp list quit preserve semantics http space padding insert spaces http method http request url url http multiple requests adds benign http requests malicious request cmd exe benign commands index html connection close option attack semantics http url encode substitute printable characters url equivalent ascii values practice paper table agent inference rules expanding rules shown stances attack produce roots root instance unique depend application order shrinking rules attacks rules paper found unique root common attack instances discuss formal requirements shrinking rules definition roots section customizing inference engine black hat customizations agent enables derivation infinite number instances practice number instances feed nids finite select finite subset instances high probability finding vulnerabilities common strategy construct subset testing technique called equivalence partitioning technique splits test cases classes class represents cases exercise features software testing attack transformations represent features nids handle define class combination transformations derive instances techniques implement equivalence partitioning strategy apply inference rules depth-first order apply application level rules independent transport rules fragment instance permute instances add retransmitted packets fig order ensures instances derivation path belong classes apply tcp-retransmission tcp-permutation order resolves interference rules section prune derivation paths prevent generation large number instances class prune instances change attack fragmented fragment packets shorter bytes split testing process phases transformations instances phases belong classes strategy impairs agent exhaustiveness experimental results show effective find nids vulnerabilities section whitehatcustomizations white hat settings goal find derivation path root instance exists start root derive instances hit instance approach ineffective difficult determine stop searching instance root instances section search infeasible white hat settings agent performs bottom-up search shrinking rules shrinks instance hits root shrinking case manually determine found root instance implement attack formal model attack derivation agent inference engine generalized computational model deriving attack instances computational model based natural deduction formally define black white hat problems discuss model applications nids testing natural deduction system pair set facts set inference rules sysa root application-level tcp-fragmentation tcp-permutation tcp-retransmission pruned derivation path fragment packets smaller bytes figure application order inference rules node represents generated instance black hat setting expanding rules table tem enables derivation facts applying inference rules facts fact derives fact denoted turnstileleft ifthereisa derivation sequence result applying derivation rule derivation sequence terminates rule applied ensure finite number derivation starting points make assumptions rules rule expanding shrinking version section shrinking version rule increase length bytes instance derivation sequence shrinking rules cycles note assumptions hold rules describe paper assumptions hold general investigation validity left future work set attack instances wedefinefor derivation starting points roots intuitively root compact simple representation formally root instance terminates derivation sequence shrinking rules starts assumptions previous paragraph ensure sequence starts terminates set roots finite denote set roots roots set instances roots formally define derivation model attack black white hat problems readability definitions based single attack instance trivially extended set instances definition derivation model attack instance attack set sound inference rules respect derivation model natural deduction system roots closure derivation model denoted roots set tcp sequences derived roots rules definition nids view nids view respect attack denoted set tcp sequences recognizes definition black hat problem roots attack 
derivation model nids view respect black hat problem find tcp sequence derivable roots formally find roots definition white hat problem roots attack derivation model tcp sequence white hat problem determine roots properties attack derivation model attack envision derivation model respect set rules sound derives tcp sequences implementa complete derive tcp sequence implements anddecidable tcp sequence algorithm determines sequence derived root black hat problem soundness means instance discover evades nids implies vulnerability nids completeness means eventually model generate instances evades nids white hat case soundness means lack false positives completeness means lack false negatives decidability important solve white hat problem derivation model sound definition require rules combinations sound respect inferences rules explore paper model decidable section decidable general code obfuscation rules model undecidable prove completeness show derivation model computes tcp sequences adhere formal definition notion tcp sequence implements knowledge formal definition exist proving completeness derivation model inductively define implementing tcp sequence implements derived tcp sequence implementsa expert determines induction base tcp sequence implementing transformation rules preserve semantics model defines set tcp sequences implement formalism notion implementinga iscrucial studying understating nids capabilities formal model defining attack instances developed model formal compare model agent practice present results agent nids testing attack analysis nids testing agent agent generate instances attacks feed snort snort missed instance stopped investigated snort code find reason generated instances attacks finger-root gain root sensitive information victim cve- perl-in-cgi usedto execute arbitrary commands web server can- iii ftp-cwd buffer overflow gain root access ftp server can- description implications eludes snort evasive rst snort accepts out-of-window tcp rst packet stops tracking live tcp connection tcp-based attack fixed snort flushing snort misses signature fragmented tcp packets attack signature inflated application-level rule http space padding exploits snort default configuration nature report single alert tcp packet snort misses attack generates general alert perl-in-cgi alert web-cgi attack default configuration snort misses attack user-defined configuration snort generates general http alert specific alert attack http multiple requests snort analyzes single http request tcp packet web-cgi attack fixed snort ftp padding snort recognize type regular expressions attack signature foo bar fixed snort concurrently work sommer paxson reported vulnerability table snort bugs found agent earlier report details attack tested agent found instances eluded snort instances exposed vulnerabilities sections snort code tcp engine http decoder pattern matching mechanism vulnerabilities fixed fixed upcoming releases snort table presents summary vulnerabilities testing effort exposed chose snort target nids reasons snort signatures easy find signatures chosen attacks snort considered state-of-the-art nids snort performance comparable commercial nids aware evasion techniques reported past snort techniques tcp reassembly http encoding ttl checks balanced data structures maintained regularly assumed non-trivial find instances elude testing effort summary based equivalencepartitioning testing strategy section performed total testing phases yielded vulnerabilities started simple attack rule set derived small number instances cover classes phase added rules agent changed attack table presents summary test phases phases finger-root transport rules phase agent exposed evasiverst vulnerability continued finger-root attack added finger-padding rule rule yield vulnerabilities phase combining transport rules exposed flushing vulnerability phase continued perl-in-cgi http rule exposed vulnerability snort http decode engine phases finally tested snort instances ftp-cwd attack discovered ftp padding vulnerability phase agent success finding vulnerabilities arises combination features agent sound generates instances real attacks tested millions instances waste time determining tcp sequence real attack agent generates instances set rules generates subset instances based feature testing section finds vulnerabilities exposed small number instances phase agent exposes vulnerabilities requires combination transport application level transformations phase phases illustrate implications agent exhaustiveness phases agent generates instances set rules pruning phase snort identifies instances assert snort correctly reassembles tcp streams characters phase assert snort pattern matching algorithm correctly ignores spaces signature simple claims provide important information snort reliability knowledge reliability claims unknown context network intrusion detection hope future agent assert complex properties agent limitations phase agent found instance eluded snort generating million instances uniformly samphase attack rules table generated instances eluding instances vulnerability discovered table finger-root finger-root evasive rst finger-root finger-root flushing perl-in-cgi http space padding perl-in-cgi http multiple requests ftp-cwd ftp padding table testing effort summary ple instances derived phase found instance samples observation suggests improve agent efficiency random sampling methods attack analysis agent report bug nids includes trace packets captured tcpdump demonstrates attack nids misses task nids development team verify trace real attack demonstrated agent automate task created ftp-cwd attack instances randomly applying ftp-padding tcp-fragmentation tcp-permutation tcp-retransmission rules table ftp-cwd root instance fig ftp-cwd root instance bytes single tcp packet handshake packets instance average bytes packets duplicated instances created benign benign instance changed byte nullify attack changed sequence number packet packets reassembled obtained instances real attacks agent white hat tool section distinguish attack benign instances attack instance agent found derivation sequence root seconds average length rules benign instance agent exhaustively searched derivation sequence find average search seconds essentially agent proved respect rules paper benign instance real attack experiment illustrates agent ability analyze complex attack instances manually distinguishing instances required tremendous effort automate process nids crosstesting technique technique provide sequence transformations obfuscate attack assert sequence exist future work expanding knowledge-base rules exploring link transport payload level rules model attackers knowledge intend investigate code obfuscation rules enable attackers change binary code network exploits intend explore techniques proving rules cover ways modify attack intend explore usages attack derivation model model partition attack instances families transformations create characterize compare nids based mutations handle acknowledgments marc dacier jon giffin dennis gopan brian fields vinod ganapathy anonymous reviewers comments earlier draft paper digital information society phreak alessandri editor taxonomy intrusion detection systems attacks ibm zurich research laboratory september deliverable project maftia ist- maftia caswell bealeand foster faircloth snort intrusion detection syngress feb christodorescu jha static analysis executables detect malicious patterns usenix security symposium washington august crosby wallach denial service algorithmic complexity attacks usenix security symposium washington august dacier editor design intrusion-tolerant intrusion detection system ibm zurich research laboratory august deliverable project maftia ist- maftia debar morin evaluation diagnostic capabilities commercial intrusion detection systems international symposium recent advances intrusion detection zurich switzerland october detristan ulenspiegel malcom underduk polymorphic shellcode engine spectrum analysis phrack 
online magazine august dietrich extension tables memo relations logic programming international conference symposium logic programming san francisco august fielding gettys mogul frystyk masinter leach berners-lee rfc hypertext transfer protocol internet engineering task force june giovanni fun packets designing stick march endeavor systems handley paxson network intrusion detection evasion traffic normalization end-to-end protocol semantics usenix security symposium washington august internet security systems realsecure network http iss net kruegel valeur vigna kemmerer stateful intrusion detection high-speed networks ieee symposium security privacy oakland lee cabrera thomas balwalli saluja zhang performance adaptation real-time intrusion detection systems international symposium recent advances intrusion detection zurich switzerland october lippmann haines fried korba das analysis results darpa off-line intrusion detection evaluation international symposium recent advances intrusion detection toulouse france october lippmann fried graf haines kendall mcclung weber webster wyschogrod cunningham zissman evaluating intrusion detection systems darpa off-line intrusion detection evaluation darpa information survivability conference exposition hilton head january marti thor tool test intrusion detection systems variations attacks master thesis swiss federal institute technology march mchugh testing intrusion detection systems critique darpa intrusion detection system evaluations performed lincoln laboratory acm transactions information system security november meadows model computation nrl protocol analyzer ieee computer security foundations workshop csfw franconia june mitre corporation cve common vulnerabilities exposures cve mitre mutz vigna kemmerer experience developing ids stimulator black-box testing network intrusion detection systems annual computer security applications conference las vegas december myers art software testing john wiley sons edition paulson mechanized proofs security protocols needham-schroeder public keys technical report cambridge computer laboratory paxson bro system detecting network intruders real-time computer networks december postel rfc transmission control protocol internet engineering task force sept postel reynolds rfc file transfer protocol internet engineering task force prawitz natural deduction proof-theoretical study almquist wiskell ptacek newsham custom attack simulation language casl sockpuppet tqbf casl html ptacek newsham insertion evasion denial service eluding network intrusion detection technical report secure networks calgary alberta canada rain forest puppy whisker antiids tactics bad ruin good thing december wiretrip net rfp txt whiskerids html ramakrishnan srivastava sudarshan efficient bottom-up evaluation logic programs computer systems software engineering state-of-the-art kluwer academic publishers june roesch snort open source network intrusion detection system snort rubin jha miller attack generation nids testing natural deduction technical report wisconsin madison january schiffman libnet library portable packet creation injection packetfactory net libnet security administrator newsletter instant poll snort implement intrusion detection system ids network october http winnetmag poll shankar paxson active mapping resisting nids evasion altering traffic ieee symposium security privacy oakland shmatikov stern efficient finite-state analysis large security protocols ieee computer security foundations workshop csfw rockport june sniphs snot january stolenshoes net sniph index html sommer paxson enhancing byte-level network intrusion detection signatures context acm conference computer communications security washington october song fragroute tcp fragmenter april monkey dugsong fragroute sterling shapiro art prolog themit press tan killourhy maxion undermining anomaly-based intrusion detection system common exploits international symposium recent advances intrusion detection zurich switzerland october tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding noordwijkerhout netherlands oct nss group intrusion detection systems ids group test edition december nss ids edition index htm nss group intrusion detection systems ids group test edition nss ids edition index htm tcpdump group tcpdump libpcap tcpdump vigna robertson balzarotti testing networkbased intrusion detection signatures mutant exploits acm conference computer communications security washington october wagner soto mimicry attacks host-based intrusion detection systems acm conference computer communications security washington november zimmerman rfc finger user information protocol internet engineering task force december 
comments rfc october casas clark konuru otto prouty walpole mpvm migration transparent version pvm computing systems spring chandy lamport distributed snapshots determining global state distributed systems acm transactions computer systems february crispin internet message access protocol version rev internet request comments rfc december egevang francis network address translator nat internet request comments rfc ferguson senie network ingress filtering internet request comments rfc geitz beguelin dongarra jiang manchek sunderam pvm parallel virtual machine users guide tutorial networked parallel computing mit press cambridge massachusetts gropp lusk doss skjellum highperformance portable implementation mpi message passing interface standard parallel computing september litzkow tannenbaum basney livny checkpoint migration unix processes condor distributed processing system technical report computer sciences department wisconsin april maltz bhagwat msocks architecture transport layer mobility infocom san francisco april mccanne jacobson bsd packet filter architecture user-level packet capture winter usenix conference san diego menezes van oorschot vanstone editor handbook applied cryptography crc press message passing interface forum mpi message passing interface standard mogul efficient workstations passive monitoring local area networks acm symposium communications architectures protocols sigcomm philadelphia mogul rashid accetta packet filter efficient mechanism user-level network code symposium operating system principles sosp austin november okoshi mochizuki tobe tokuda mobilesocket continuous operation java applications ieee international conference computer communications networks boston october perkins mobility support internet request comments rfc october postel transmission control protocol internet request comments rfc september brent mobile tcp socket technical report tr-cs- computer sciences laboratory rsise australian national canberra australia april brent mobile tcp socket international conference software engineering san francisco usa november snoeren balakrishnan end-to-end approach host mobility ieee acm international conference mobile computing networking mobicom boston august stellner cocheck checkpointing process migration mpi international parallel processing symposium honolulu stellner pruyne resource management checkpointing pvm european pvm user group meeting lyon france thain basney son livny kangaroo approach data movement grid ieee symposium high performance distributed computing hpdc san francisco california august thain livny bypass tool building split execution systems ieee symposium high performance distributed computing hpdc pittsburgh august wright cheap cycles desktop dedicated cluster combining opportunistic dedicated scheduling condor linux clusters hpc revolution champaign-urbana usa june zhang dao persistent connection model mobile distributed systems international conference computer communications networks icccn las vegas september 
requires investigation component continuing research conclusions dyck model cient context-sensitive program representation experiments show contextsensitive models signi cantly improve strength intrusion detection system null call squelching dyck model operates ciency slightly worse imprecise context-insensitive nfa makes context-sensitive models usable lastly interprocedural argument capture branch analysis based system call return values limit attacker manipulation reducing opportunities successful attacks acknowledgements anonymous referees members wisa security group wisconsin valuable feedback suggestions ashcraft engler programmer-written compiler extensions catch security holes ieee symposium security privacy oakland california chomsky context-free grammars pushdown storage quarterly progress report pages massachusetts institute technology research laboratory electronics april chomsky schcurrency utzenberger algebraic theory context-free languages braffort hirschberg editors computer programming formal systems studies logic foundations mathematics pages north-holland publishing company amsterdam esparza hansel rossmanith schwoon efcient algorithms model checking pushdown systems conference computer aided veri cation cav lncs pages chicago illinois july springer-verlag feng kolesnikov fogla lee gong anomaly detection call stack information ieee symposium security privacy oakland california ferrante ottenstein warren program dependence graph optimization acm transactions programming languages systems july forrest hofmeyr somayaji longstaff sense unix processes ieee symposium security privacy oakland california garvey lunt model-based intrusion detection national computer security conference ncsc baltimore maryland june ghosh schwartzbard schatz learning program behavior pro les intrusion detection usenix workshop intrusion detection network monitoring santa clara california april gif jha miller detecting manipulated remote call streams usenix security symposium san francisco california august ginsberg harrison bracketed context-free languages journal computer system sciences hofmeyr somayaji forrest intrusion detection system sequences system calls journal computer security ilgun kemmerer porras state transition analysis rule-based intrusion detection approach ieee transactions software engineering march fink levitt automated detection vulnerabilities privileged programs execution monitoring annual computer security applications conference acsac orlando florida december kuck kuhn padua leasure wolfe dependence graphs compiler optimizations acm symposium principles programming languages popl pages williamsburg virginia january lane brodley temporal sequence learning data reduction anomaly detection acm transactions information system security august lee stolfo mok data mining framework building intrusion detection models ieee symposium security privacy oakland california lindqvist porras expert-bsm host-based intrusion detection solution sun solaris annual computer security applications conference acsac pages orleans louisiana december lunt automated audit trail analysis intrusion detection survey national computer security conference ncsc baltimore maryland october maheshwari traversal marker placement problems np-complete technical report cu-csdepart- ment computer science colorado boulder colorado ottenstein data-flow graphs intermediate program form dissertation purdue august schwoon model-checking pushdown systems dissertation technische universitcurrency mcurrency unchen june sekar bendre bollineni dhurjati fast automaton-based method detecting anomalous program behaviors ieee symposium security privacy oakland california sekar uppuluri synthesizing fast intrusion prevention detection systems high-level speci cations usenix security symposium washington august sekar venkatakrishnan basu bhatkar duvarney model-carrying code practical approach safe execution untrusted applications acm symposium operating system principles sosp bolton landing york october tan killourhy maxion undermining anomaly-based intrusion detection system common exploits recent advances intrusion detection raid lncs pages zurich switzerland october springer-verlag tan maxion ning operational limits stide anomaly based intrusion detector ieee symposium security privacy pages oakland california tan mchugh killourhy hiding intrusions abnormal normal international workshop information hiding lncs noordwijkerhout netherlands october springerverlag teng chen adaptive real-time anomaly detection inductively generated sequential patterns ieee symposium security privacy oakland california von dyck gruppentheoretische studien mathematische annalen wagner static analysis computer security techniques software assurance dissertation california berkeley fall wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wagner soto mimicry attacks host based intrusion detection systems acm conference computer communications security ccs washington november warrander forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy oakland california wespi dacier debar intrusion detection variable-length audit trail patterns recent advances intrusion detection raid lncs pages toulouse france october springer-verlag vtpath attack vtpath model fails detect impossible path attacks based non-determinism dyck model detect due null call insertion code figure function security check veri current process root user access denies access function log writes activity log buffer overrun line attack works attacker root privilege enters log call buffer log set return address return line log return line execute privileged actions vtpath detect attack vtpath observes return addresses system call point return address modi line point non-determinism leading vtpath incorrectly call log originated line push-down automaton model similarly miss attack dyck model detects attack calls log instrumented preand postcalls point buffer overrun correct return address stored null calls call site aid attack detection reducing nondeterminism coding patterns arise note vtpath model detect attack learned behavioral database program dyck instrumentation previously inserted formal nitions proofs definition denote local nfa models ranges functions program entry point function set system calls set user functions called dyck model iqi iqi set states input alphabet stack alphabet transition relation unique entry state initial stack conguration set accepting states system call transition precall pushes stack entry state postcall pops stack models system call sequences generates application bracketed context-free language subsequences consisting symbols form dyck language lemma squelched dyck model postcall true system call postcall proof suppose postcall precall top application squelch stack construction squelching removes call stream lemma observed sequence calls true system call true system call null calls rst precall precall proof suppose rst postcall precall contradicting lemma theorem call graph program denote graph obtained strongly connected component collapsed single state maximum diameter generates true system calls execution worst-case number null calls generated proof lemmas observed call pattern repeating sequence string precalls system call string postcalls claim precall string postcall string length system call suppose precall string length exists directed path length occur suppose postcall string length exists directed reverse path length similarly occur number null calls generated system call data dependence graph data dependence graph ddg common program analysis structure representing interprocedural ows data program ddg subgraph void security check char file uid uid getuid uid log accessing file restricted access file log invalid access file exit security error void log char msg char file char buf sprintf buf msg file buffer write log buf strlen buf figure code vtpath attack passargs argspass register condition code passargs condition coderegister sethi 
file file call open mov mov mov bge mov mov sethi buf sethi root ble cmp mov call action add call writewrap call action mov action entry cmp mov jmp read buf writewrap entry root jmp write mov figure data dependence graph analysis constructs data dependence graph code figure shaded numbers correspond line numbers figure sparc code rightmost register instruction written register registers call arguments return call program dependence graph includes data dependence edges graph abstracts procedure basic block boundaries instruction node graph edges data owing instruction write data location instructions read exists def-clear path respect convenience edge label data location creating dependency ddg includes interprocedural data edges interprocedural edges data dependencies nition arguments entry point function arguments exit point function return definition set instructions program set function entry points data dependence graph def-clear path respect figure shows ddg constructed program code figure shaded node numbers correspond line numbers figure sparc delay slots unwound node precedes node graph ddg argument capture straightforward subgraph ddg rooted system call instruction reachable reverse edges dependent data location expression graph setting argument argument register read instruction node nodes expression graph simulating execution instructions identify buffer passed toread similarly expression graph argument register read includes nodes note represents interprocedural data simulated execution recovers values argument branch analysis argument capture system call return values requires slight change procedure discovery expression graph stops return system call expression graph argument register read instruction node reaches back node analysis recognizes open system call marks argument open return analysis branch node proceeds similarly expression graph reveals return open node compared node branch condition branch equal predicates added program model open branch-taken control path open fall-through path shown figure 
empirical study robustness windows applications random testing paper appears usenix windows systems symposium seattle august empirical study robustness windows applications random testing justin forrester barton miller nbsp jforrest bart wisc nbsp computer sciences department dayston street wisconsin madison abstract report series studies reliability application programs face random input studied reliability unix application programs command line x-window based gui study apply testing techniques applications running windows operating system testing simple black-box random input testing measure crude technique effective locating bugs real programs tested gui-based applications subjecting kinds random input streams valid keyboard mouse events streams random win messages built tool helps automate testing windows applications simple parameters application tested random testing techniques previous unix-based studies showed crash wide variety command-line x-window based applications unix platforms test results similar nt-based applications subjected random valid input produced mouse keyboard crashed applications tested hung additional applications subjected raw random win messages crashed hung applications tested report applications failed tests provide analysis failures introduction report series studies reliability application programs face random input studied reliability unix command line x-window based gui application programs study apply techniques applications running windows operating system testing called fuzz testing simple black-box random input knowledge application generating random input study evaluated reliability standard unix command line utilities showed applications crashed hung reading random input study evaluated larger collection applications study including common x-window applications newer study found failure rates similar original study specifically standard command line unix utilities crashed hung random input x-window applications tested failed deal random input current study find similar results applications running windows measure reliability primitive simple program passes test responds input exit fails crashes terminated abnormally hangs stops responding input reasonable length time application respond sensibly formal specification criterion crude offers mechanism easy apply application crash hang program simple fuzz testing replace extensive formal testing procedures curiously simple testing technique find bugs found techniques study x-window applications provided direction current study test x-window applications interposed testing program application client x-window display server allowed full control input application program send completely random messages application send random streams valid keyboard mouse events current windows study accomplish level input control application windows event mechanisms section subjecting application streams random valid keyboard mouse events tests application conditions tolerate occur normal software subjecting application completely random invalid input messages test general strength error checking considered evaluation software engineering discipline respect error handling producing application years passed study time windows-based applications dominate desktop environment windows windows offers full power modern operating system including virtual memory processes file protection networking felt time comparable study reliability applications environment current study produced main results applications tested crashed presented random valid keyboard mouse events test results applications run windows similar additional applications tested hung presented random valid keyboard mouse events tests results applications run windows similar applications tested failed crashed hung presented completely random input streams consisting random win messages noted result completely random input testing application running windows platforms vulnerable random input streams generated application running system appears flaw win message interface analysis applications source code shows appears common careless programming idiom receiving win message unsafely pointer handle contained message results study significant reasons reliability foundation security results offer informal measure reliability commonly software expose bugs examined rigorous testing debugging techniques potentially enhancing software producers ability ship bug free software expose vulnerability applications windows interfaces finally results form quantitative starting point judge relative improvement software robustness studies access source code large percentage programs tested including applications running vendors platforms gnu linux applications result addition causing programs hang crash debug applications find crash categorized reported results passed software vendors authors form specific bug reports windows environment limited access source code applications result perform analysis applications emacs public source code open source version netscape communicator mozilla section describes details perform random testing windows systems section discusses experimental method section presents results experiments section offers analysis results presents commentary related work discussed section random testing windows platform goal random testing stress application program testing required simulate user input windows environment describe components kernel application involved processing user input describe application programs tested environment study x-window applications random user input delivered applications inserting random input regular communication stream x-window server application types random input random data streams random streams valid keyboard mouse events testing random data streams completely random data necessarily conforming window system protocol application kind input normal operating conditions provided insight level testing robustness application crucial properly constructed program check values obtained system calls library routines random valid keyboard mouse event tests essentially testing application monkey keyboard mouse user generate input failure circumstances represents bug encountered normal application basic principles categories windows environment architecture slightly figure simplified view components support user input windows environment figure windows architectural components user input explain role component figure case user clicks link web browser action sets motion windows user input architecture mouse click generates processor interrupt interrupt handled system base windows kernel system hands mouse interrupt mouse device driver device driver computes parameters mouse click mouse button clicked adds event system event queue event queue window manager calling mouse event function point device driver work complete interrupt successfully handled system event queue mouse event awaits processing kernel raw input thread rit rit converts raw system event win message win message generic message structure provide applications input rit delivers newly created win message event queue window case mouse click rit create win message lmousebuttondown identifier current mouse coordinates determine target window message web browser rit determined web browser window receive message call postmessage function function place win message message queue belonging application thread created browser window point application receive process message win application program interface api getmessage function applications retrieve messages posted message queues application threads create windows generally enter quot message loop quot loop retrieves message preliminary processing dispatches message registered callback function called window procedure defined process input specific window case web browser win message mouse click retrieved application call getmessage dispatched window procedure web browser window window procedure examine parameters lmousebuttondown message determine user clicked left mouse button 
set coordinates window click occurred web link figure insertion random input architecture test applications random events random win messages testing random events entails inserting random system events system event queue random system events simulate actual keystroke mouse events added system mechanism related device driver mouse event keybd event functions random testing mechanism involves sending random win messages application random win messages combine random valid message types completely random contents parameters delivering messages win api function postmessage postmessage function delivers win message message queue selected window returns note similar function postmessage called sendmessage delivers win message waits message processed fully returning win messages fixed size format messages fields message field integer parameters testing produced random values fields constraining field message range valid message figure shows random testing mechanism fits windows user input architecture notice figure testing conditions target application unable distinguish messages testing mechanisms system distinction essential create authentic test environment experimental method describe applications tested test environment testing tool called fuzz tests performed discuss data collected analyzed applications platform selected group application programs select applications representative variety computing tasks selection influenced software commonly computer sciences department wisconsin software includes word processors web browsers presentation graphics editors network utilities spread sheets software development environments addition functional variety strove test applications variety vendors including commercial free software operating system ran tested applications windows build service pack insure results timely tested subset applications windows system version applications re-tested windows obtained similar results tested hardware platform testing collection standard intel pentium pcs fuzz testing tool mechanism testing applications tool called fuzz built applications running windows platform fuzz produces repeatable sequences random input delivers input running applications mechanisms section basic operation obtain process application tested launching application explicit command line parameter determine main window target application desktop placement coordinates sendmessage postmessage keybd event mouse event deliver random input running application fuzz invoked command line gui interactions tool interfere testing applications version windows fuzz tool gui interface gui testing tool interfered testing applications result changed fuzz operate command line fuzz command format fuzz -ws -wp pid msgs seed appl cmd line -ws random win messages sendmessage -wp random win messages postmessage random valid mouse keyboard events options option start testing already-running application process tells fuzz launch application option controls maximum number messages application seed random number generator set options provide finer control sendmessage postmessage tests tests report paper null parameters included tests command messages control activation messages button clicks included tests tests divided categories input techniques section application underwent battery random tests included random win messages sendmessage api call random win messages postmessage api call random system events introduced mouse event keybd event api calls cases completely random input case streams valid keyboard mouse events quantity messages send determined preliminary testing testing appeared application fail number messages events tests detailed performed distinct sequences random input random seeds test trials conduced application random sequence total runs application random input streams application results describe basic success failure results observed tests provide analysis failures applications source code quantitative results outcome test classified categories application crashed completely application hung stopped responding application processed input close application normal application mechanisms categories simple categorize success failure application simple inspection addition quantitative results report diagnosis crashes applications source code table summarizes results experiments windows table results subset applications tested windows application failed runs category column result listed table application crashed hung passed tests mark column application vendor sendmessage postmessage random valid events access microsoft access microsoft acrobat reader adobe systems nbsp calculator microsoft nbsp nbsp cd-player microsoft nbsp codewarrior pro metrowerks command antivirus command software systems nbsp eudora pro qualcomm excel microsoft nbsp excel microsoft nbsp framemaker adobe systems nbsp nbsp freecell microsoft nbsp ghostscript aladdin enterprises nbsp ghostview ghostgum software pty nbsp gnu emacs free software foundation nbsp internet explorer microsoft internet explorer microsoft nbsp java workshop sun microsystems nbsp netscape communicator netscape communications notepad microsoft nbsp paint microsoft nbsp paint shop pro jasc software nbsp nbsp powerpoint microsoft powerpoint microsoft nbsp secure crt van dyke technologies solitaire microsoft nbsp nbsp telnet windows mit kerberos group nbsp nbsp visual microsoft winamp nullsoft nbsp word microsoft word microsoft wordpad microsoft ftp ipswitch percent crashed percent hung total percent failed table summary windows test results crash hang note application crashed hung crash reported application vendor sendmessage postmessage random valid events access microsoft nbsp access microsoft codewarrior pro metrowerks nbsp nbsp excel microsoft nbsp excel microsoft nbsp internet explorer microsoft nbsp netscape communicator netscape communications paint shop pro jasc software nbsp nbsp powerpoint microsoft nbsp powerpoint microsoft nbsp secure crt van dyke technologies nbsp visual microsoft word microsoft word microsoft percent crashed percent hung total percent failed table summary windows test results crash hang note application crashed hung crash reported results tests show large number applications failed deal random input failure rates win message tests greater random valid keyboard mouse event tests expected win message types include pointers parameters applications apparently de-reference blindly tests sendmessage api function produced crash rate applications hung scant successfully dealt random input tests postmessage api function produced slightly higher crash rate hang rate application successfully withstand postmessage test random valid keyboard mouse event results improved random win message test produced significant number crashes fully applications crashed hung leaving applications successfully deal random events result troublesome random events introduced user windows system mouse keyboard windows tests similar results performed expected significant difference platforms results confirm expectation crashes source code applications access source code applications gnu emacs text editor open source version netscape communicator mozilla examine applications determine crashes occurred testing emacs crash analysis examined emacs application crashed random win messages crash simple casting parameter win message pointer structure de-reference pointer access field structure file fns message handler wnd proc standard win callback function callback function de-reference parameter lparam note error checking exception handling protect de-reference lresult callback wnd proc hwnd msg wparam lparam point pos pos point lparam trackpopupmenu hmenu wparam flags posgt posgt hwnd null pointer random produced fuzz invalid de-reference caused access violation uncommon find failures caused unsafe pointer 
previous studies found cases cases well-documented literature inspection crashes based machine code appears problem random win message crashes mozilla crash analysis examined open source version netscape communicator called mozilla crashed random win messages crash similar emacs crash crash occurred file nswindow cpp function nswindow processmessage function designed respond win messages posted application windows fashion similar gnu emacs parameter function lparam case assumed valid window handle nswindow control nswindow getwindowlong hwnd lparam gwl userdata control controlgt setupforpaint hdc wparam passed argument getwindowlong function access application specific information window case parameter random produced fuzz getwindowlong function retrieving random window application casts return pointer attempts de-reference causing application crash analysis conclusions goal study provide general reliability variety application programs running windows hope study inspires production robust code discuss results previous section provide editorial discussion tests random valid keyboard mouse events provide sense relative reliability application programs tests simulated random keystrokes mouse movements mouse button clicks events caused user concern results tests show commonly-used desktop applications reliable hope tests produced greatest failure rates random win message tests normal events messages produced kernel application program impossible kernel send messages invalid values tests interesting reasons demonstrate vulnerability interface application program send messages application program win interface type protection modern operation systems provide durable firewalls results point discipline software design major interfaces application software components application operating system checks return values result parameters inspection crashes diagnosis source code shows blind de-referencing pointer dangerous simple action protecting de-reference exception handler windows structured exception handling facility make qualitative improvement reliability side note applications detect error provide user reasonable pleasant choices applications follow opportunity save pending made current document open files best-effort save current work copy user file give user hope recovering lost work applications tested saved user dialog pertaining crash contained memory address instruction caused fault hexadecimal memory dump average application user dialog cryptic mysterious serves confuse final piece analysis concerns operating system crashes occasionally unix study tests resulted crashes windows study operating system remained solid crash result testing note early version fuzz tool windows result occasional crashes tool contained bug generated mouse events top left corner screen reason events occasionally crash windows repeatable fashion results inspire comments quot applications flaky quot important validate anecdotal intuitions results provide concrete basis comparing applications tracking future hope improvements results lead observations current software testing methodology random testing elegant bring surface application errors evidenced numerous crashes encountered study bugs produced crashes low priority software makers due extreme situations occur simple approach find bugs overlooked lack general access application source code prevented making detailed report program failures gnu emacs mozilla applications diagnose limited diagnosis exposes trend poor handling pointers event records studies reasonable access application source code unix vendors result provided bug fixes addition bug reports today software market makes access application source code difficult extreme cases database systems tested study act reporting bugs performance data forbidden licence agreements vendors aggressively pursue restriction vendors righteously defend practices works counter producing reliable systems results presented paper make difference bugs found unix study present study found applications based open source reliability commercial vendors study noted subsequent improvement software reliability measure long vendors importantly purchasers features reliability hope reliable applications remains muted opportunity analysis remains project goals include full testing applications windows goal hard achieve anticipate full results shortly explanation random win message results surprised postmessage sendmessage results differed difference caused synchronous asynchronous nature postmessage sendmessage priority difference types messages reasons identified exploring reasons difference explanation windows windows results test identical versions applications windows windows initial guess results identical differences due reasons including timing size screen system dependent dlls exploring reasons difference related work random testing years ways looked primitive testing community book software testing meyers randomly generated input test cases quot inefficient hoc approach testing quot type testing hoc find bugs real programs view random testing tool easy larger software testing toolkit early paper random testing published duran ntafos study test inputs chosen random predefined set test cases authors found random testing fared compared standard partition testing practice track subtle bugs easily hard discover traditional techniques found random testing cost effective testing strategy programs identified random testing mechanism obtain reliability estimates technique primitive easier type random testing duran ntafos programmer knowledge direct tests require construction test cases papers published ghosh random black-box testing applications running windows studies extensions earlier fuzz studies studies authors tested standard command-line utilities windows utilities fared unix counterparts scoring failure rate study interesting tested applications attrib chkdsk comp expand find label replace commonly windows applications based graphic interfaces felt extensive testing random testing test unix system call interface quot crashme quot utility effectively exercises interface actively linux kernel developments source code source binary code fuzz tools windows web page ftp ftp wisc paradyn fuzz acknowledgments susan hazlett running initial fuzz tests windows john gardner helping initial evaluation fuzz tool philip roth careful reading drafts paper microsoft helped study providing pre-release version windows paper referees jim gray provided great feedback review process work supported part department energy grant de-fg nsf grants cdaand eiaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon carey dewitt naughton quot benchmark quot acm sigmod international conference management data washington carrette quot crashme random input testing quot http people delphi gjc crashme html duran ntafos quot evaluation random testing quot ieee transactions software engineering sejuly garfinkel spafford practical unix amp internet security reilly amp associates ghosh shah schmid quot testing robustness windows software quot international symposium software reliability engineering issre paderborn germany november ghosh shah schmid quot approach analyzing robustness windows software quot national information systems security conference crystal city october meyers art software testing wiley publishing york miller koski lee maganty murthy natarajan steidl quot fuzz revisited re-examination reliability unix utilities services quot wisconsin-madison appears german translation quot empirische studie zur zuverlasskeit von unix-utilities nichts dazu gerlernt quot september ftp ftp wisc paradyn technical papers fuzz-revisted miller fredriksen quot empirical study reliability unix utilities quot communications acm december appears german translation quot fatale fehlertr auml chtigkeit eine empirische studie zur zuverlassigkeit 
von unix-utilities quot march ftp ftp wisc paradyn technical papers fuzz petzold programming windows microsoft press redmond richter microsoft press redmond solomon inside windows microsoft press redmond whittaker jorgensen quot software fails quot technical report florida institute technology http fit papers swfails pdf modified wed jun cdt 
autonomous analysis interactive systems self-propelled instrumentation alexander mirgorodskiy barton miller computer sciences dept univ wisconsin dayton madison usa abstract finding intermittent bugs performance problems modern systems challenging task conventional profilers focus improving aggregate performance metrics application disregard problems highly visible users deemed statistically insignificant finding intermittent bugs hard breakpoint debuggers change timing events masking problem address limitations propose approach called self-propelled instrumentation autonomous agent perform self-directed exploration system inject agent running application agent starts propagating code carried application flow control propagates inserts instrumentation dynamically collect analyze detailed execution information key feature approach lies ability meet requirements high level detail low overhead autonomy reliance human existing techniques tracing profiling violate requirements proof concept implemented tool called sptracer self-propelled instrumentation obtain function-level traces applications kernel tool enabled locate fix problems unfamiliar code linux environment keywords tracing performance analysis dynamic instrumentation introduction finding root bugs performance problems modern systems challenging task focus conventional profilers improving aggregate performance metrics application latency individual operations latency-related problems common end-user desktop environments large production systems streaming video telephony gui applications sensitive short delays execution delays highly visible user traditional profilers statistically insignificant finding intermittent bugs hard concurrent environments debuggers change timing events masking problem propose identify intermittent bugs performance problems autonomously flow control applications operating system kernels systems diota dynamo pin offer effective follow control flow approach previously explored significant warm-up overhead mechanisms techniques demonstrate reasonable performance steady-state case long-running applications introduce severe perturbation time activation contrast mechanism low warm-up overhead apply studies latency-sensitive systems analysis technique practical real-world environments satisfy main requirements autonomous perform investigation heavy reliance human copyright society photo-optical instrumentation engineers paper published multimedia computing networking conference made electronic preprint permission spie print electronic copy made personal systematic multiple reproduction distribution multiple locations electronic means duplication material paper fee commercial purposes modification content paper prohibited work supported part department energy grants de-fg de-fg office naval research grant government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon authors e-mail mirg bart wisc production environments users symptoms problem understand search root detailed miss relevant facts aggregated coarse-grained performance data insufficient determining problem approach introduce perturbation system changing timing events system hide intermittent problems slowing production system services users unacceptable existing analysis technique satisfies requirements performance profilers autonomous acceptable overhead fail detailed test collect aggregate metrics execution finding short intermittent problems impossible mechanisms breakpoint debuggers require user guidance failing autonomy low perturbation requirement tracing techniques fail autonomy test low perturbation test tracing tools insertion probes user-specified locations code hands experienced analyst approach provide arbitrary level detail controlled overhead autonomous requires significant user expertise insert trace probes lack autonomy user-directed approach implies multiple re-runs test narrow problem analyzing problems hard reproduce approach tools insertion trace calls locations system function entries approach detailed autonomous fails low-perturbation requirement binaries system pre-instrumented trace probes users suffer significant overhead tracing performed alternative approach insert probes run time user decides start tracing approach adverse latency effects performance run-time insertion trace probes locations long operation self-propelled instrumentation satisfy requirements additional practical features techniques enable features autonomy perform self-propelled instrumentation inject agent code system injected agent propagates autonomously system flow control collecting information making propagation decisions perturbation agent propagates dynamic instrumentation performed address space code insertion local memory operations expensive system calls context switches high level detail agent programmed intercept flow control granularity individual functions past experience standard profilers suggests function-level data provide level detail performance analysis intercepting flow control lower level individual basic blocks instructions albeit price higher overhead rapid activation agent start data collection demand costly preparation feature important analysis short-lived intermittent problems ability analyze black-box systems self-propelled instrumentation cut non-transparent layers code including kernel boundary capability crucial introspection complex multicomponent systems proof concept implemented autonomous tracing tool called sptracer self-propelled instrumentation propagate code tool lets user collect detailed function-level traces application kernel user specifies events tracing start stop points start key combination pressed stop start event inject tracer currently-executing application starts propagating code application flow control application performs system call preempted hardware interrupt tracer seamlessly walk kernel continue propagating kernel code propagation procedure continues user-specified event end obtain visualize complete log functions invoked events demonstrate usefulness approach analyzed problems linux environment traced choppy dvd playback mplayer movie player application problem linux kernel found two-second freeze access menu bar microsoft word running wine ms-windows emulator identify linux laptops wake entering standby mode self-propelled instrumentation proved powerful mechanism obtaining detailed accurate execution information finally measured overhead self-propelled instrumentation instrumenting mplayer dvd playback resulted slowdown short periods time level slowdown tolerable performance analysis latency-sensitive multimedia systems reduce overhead instructing self-propelled instrumentation avoid tracing parts code stop deeply nested function calls repetitive calls function tight loop flexible nature self-propelled instrumentation makes policies easy implement related work conventional approaches performance analysis debugging unsuitable time-sensitive systems common technique performance analysis full-system profiling made tools dcpi oprofile mentioned focus aggregate system performance makes tools ignore short one-time problems find problems detailed analysis technique required standard debuggers unsuitable finding bugs time-sensitive systems introduced overhead pausing multithreaded application stepping code change timing events hide subtle race conditions pausing highly-availablesystems watchdog timers watched application respond time interval killed restarted partition discussion related work sections describe techniques performance analysis debugging time-sensitive systems describe existing mechanisms collecting detailed execution traces applications finally discuss existing approaches automated analysis trace data anomaly detection performance analysis debugging interactive systems address inability standard profilers find short performance problems interactive systems tipme project constant monitoring tracing system runs logs events context switches process creation events passing server circular buffer main memory performance problem user hit key combination save trace disk analysis approach proved finding problems process disk schedulers tipme framework records events pre-defined types easily extendable adding event type tipme appears require source code modification recompilation kernel possibly server fixed set high-level events sufficient locating arbitrary performance problem past experience standard profilers shows problems call detailed function-level performance data detailed analysis developers softwarefor embedded systems simulators recent advances simulation technology similar techniques applied general-purpose systems approach collect function-level instruction-level performance data perturbation system execution deterministic replay capabilities 
finding intermittent bugs advantages full-system simulators drawbacks introduce slowdown times relative native execution slowdown eliminates possibility online diagnostics complicates collection data long-running programs analyze real-world problem techniques reproduce problem simulated environment hardware-related problems intermittent bugs highly sensitive system configuration difficult achieve existing mechanisms trace collection mechanisms trace execution applications kernels trace statements inserted statically functions entries exits source-to-source translator compiler binary rewriter common drawback static mechanisms lies inability remove instrumentation tracing required overhead study section shows executing null instrumentation function call return result slowdown users static instrumentation frameworks endure slowdown entire running time system contrast dynamic techniques activate deactivate tracing run time well-known dynamic tracing tools strace strace launch application print names arguments system calls application executes functionality proved quick insight program behavior trace system calls capture details execution tracing regular function calls application similarly insight calls made kernel mode limitation partially addressed tool called itrace itrace interface similar strace records function calls application support tracing kernel code obtain information itrace single-steps instructions application generates trace record call return instruction encountered approach highly intrusive incurs context switch instruction traced process tolerable debugging time-insensitive applications approach suitable performance analysis approach obtaining function-level traces implemented ltrace tool ltrace traces calls functions shared libraries inserting breakpoints entries exported functions solaris truss tool technique instrument functions present symbol table exported shared libraries mechanism applications code executes natively single-stepping overhead breakpoint trap function call prohibitively expensive performance analysis applications efficient tracing approach chosen tracetool project dynamic instrumentation capabilities dyninst api insert trace calls function entries exits application similarly dtrace framework supports instrumentation user kernel functions downside en-masse instrumentation mechanisms significant latency inserting trace statements avoid introducing delays run time pre-instrument functions advance approach limitation static instrumentation introduces noticeable overheadeven tracing performed collecting traces flow control reduce cost inserting trace statements dynamic instrumentation inject incrementally flow control application reaches code projects follow flow control techniques similar self-propelled instrumentation dynamo diota pin primary goalof dynamo diota pin providegeneral-purpose instrumentation facilities systems similar mechanisms flow control projects build cache clone code fly execute cached fragments original code cached fragment attempts jump uncached location framework takes control creates fragment uncached location copying adjusting instructions executes giving control jump cache obtain execution trace technique diota pin insert calls tracing routines fragments generated diota supports tracing entries exits individual basic blocks pin supports tracing function entries exits diota pin dynamo offer capabilities similar self-propelled instrumentation unsuitable analysis latency-sensitive systems building code cache slow operation instruction uncached location examined moved cache adjusting position-dependent instructions cache populated traced application suffer substantial overhead running time application experience slowdown flow control reaches previously-unseen code analyzing latency-sensitive systems finding root intermittent delays mechanism introduces intermittent delays existing mechanisms trace analysis collecting detailed trace events analyze search anomalous behavior trace complex visual examination feasible recent projects automated analysis traces large multi-component internet services pinpoint magpie systems collect coarse-grained information analysis methods apply finding anomalies function-level traces pinpoint client requests system collects names components involved processing detects request succeeded failed per-request traces clustered identify components highly correlatedwith failures magpie requests system records high-level events context switches remote procedure calls system calls network communications component names strings events grouped clusters based similarity strings close existing cluster considered anomalous magpie builds probabilistic state machine identifies anomaly event suspiciously low probability overview approach devised approach performance analysis debugging complex systems called selfpropelled instrumentation corner stone approach autonomous agent performs self-directed exploration system typical usage scenario agent attaches running application stays dormant waiting user-specified activation event event agent starts propagating application code carried flow execution agent takes control point interest executes user-specified payload code collects performance data decides receive control lets application continue outline main elements activation propagation payload execution detailed implementation steps discussed section activation agent stays dormant inside application user-specified event agent wake function call function application executed similar traditional breakpoint timer event time key press key combination pressed future plan extend supported set events include common user-interface actions propagation propagate agent in-situ instrumentation kind dynamic instrumentation performed address space agent examines current location code application executes finds point interest ahead flow control call interception point modifies code insert call point application continue application hits instrumented point agent receive control propel point characteristic feature approach low predictable overhead unlike diota pin instrument code in-place generating cached copy technique start executing code full speed obviating costly cache-buildup period bring instrumentation costs perform code analysis advance application starts running key benefits approach rapid agent activation elimination intermittent delays flow control reaches previously-unseen code middle execution technique achieve lower overhead diota pin dynamo steady-state scenario code cache populated systems continue intercepting indirect jumps prevent control returning original uncached code fact accounts major share residual overhead diota contrast in-situ technique support indirect jumps interceptions execute original code studies section show latency-related problems kernel manifest user applications investigate problems propagate application kernel traced application performs system call preempted hardware interrupt agent walks kernel starts propagating kernel code mechanism local memory operations instrumentation techniques sides kernel boundary payload execution extensibility agent executes user-specified payload code interception point payload passively record analyze execution information approach figure sample trace functions performanceanalysis automated bug finding payloadcan react observedinformation potentially altering execution common applications active approach security analysis monitor process prevent executing malicious actions dynamic optimization current implementation passive monitoring approach record time stamp reaching interception point point identifier intercept flow control functions entries exits collecting function-level trace execution trace collected agent saves disk examine visually anomalies future plan automate analysis process agent find bugs performance problems human obviating collecting storing trace visualize function-level traces nupshot tool shown figure function trace represented rectangle width rectangle duration function execution milliseconds nested rectangles represent nested function calls figure function main calls function calls returns returns main main immediately calls implementation techniques previous section implemented autonomous tracing tool called sptracer tool propagates code self-propelled instrumentation collects traces function calls chosen application kernel made user-specified events discuss implementation start propagation mechanisms discuss questions activation user kernel domains propagation sptracer records function entries returns obtain information self-propelled instrumentation treat call sites code interception points sptracer 
intercepts calls made traced application receive control function entered function returns entry sptracer makes propagationstep intercepts callsites function called application executes sptracer propagatesthroughits call graph movingfrom function callees andinto callees suppose sptracer received control entering function function call function intercept call sptracer replaces call instruction jump run time-generated patch area patch area calls tracing routines relocatedcall call tracerentry call call tracerexit tracerentry routine reached emits trace record entry propagates instrumentation pre-computed code analysis results locate call sites generates patch areas site replaces call instructions jumps patch areas tracerexit routine reached simply emits trace record exit previous implementation tracer generated per-site patches simply replaced call instruction call tracerentry tracerentry reached return address original destination call function hash table jumped returning control application intercept flow control exits tracerentry modified return address stack point tracerexit scheme memory-efficient per-site patches substantially higher run-time overhead factors performing hash lookup function call expensive modifying return address stack resulted mis-predicting destination return instruction cpu penalty significant modern processors instrumenting indirect calls intercepting regular call instructions straightforward platforms fixed-size instructions intercepting indirect calls calls function pointers virtual functions equally simple overwrite indirect call unconditional branch patch area target platform variable-length instruction set indirect call instruction small bytes replace long five-byte jump address problem relocate basic blocks short indirect call instructions identify basic block indirect call instruction copy block contents heap location adjusting position-dependent instructions appropriately copying indirect call insert calls tracerentry tracerexit finally write jump relocated block beginning original block execution flows relocated block blockrelocationis similar building code copy performedby dynamo diota pin unlike systems relocate entire code application blocks short indirect calls moved heap perform analysis code generation off-line application starts running factors lower run-time overhead generating relocated code similar technique relocation single function performed dyninst advantages relocation basic block level relocating block simpler efficient single pass code block function relocation post-processing adjust destinations forward branches function relocation functions jump tables relocated dyninst involved complexity adjusting indirect jumps code note block relocation assumption technique overwrite entry point block jump relocated version blocks longer bytes relocated single long jump blocks longer byte relocated short jump springboard location long jump relocated version finding space springboard displacing long bytes longer block nearby finally relocating one-byte blocks technique fortunately instrument blocks call instructions purposes trap-based instrumentation function relocation past code analysis perform instrumentation tracer parse binary code application kernel find call sites function instrumented determine destinations call graph application instrumenting indirect calls relocates basic blocks function heap support functionality obtain control flow graph function indirect calls prototype obtains call graph control flow graphs application starts running leverage code analysis infrastructure dyninst api retrieve save data structures disk obtain graphs linux kernel dyninst analyze on-disk vmlinux elf image kernel analyze loadable kernel modules similarly application starts tracer fetches data disk begins user enables tracing future envision system-wide repository results code analysis installed applications activating user-level tracing trace application kernel time tracing components propagation mechanism separate activation methods user-side agent implemented shared library preloaded applications pre-loading application starts preload mechanism run time hijack mechanism cases library stays dormant user asks system initiate tracing case studies motivated implement primitive activation methods method activates tracer function application executed naturally assumes user familiar internals application function agent injected application instruments chosen function lets application continue instrumented function reached agent receives control starts propagating method initiates tracing user-specified time interval elapses start application mechanism analyzing problems happen fixed moment depend input user receive control timer expiration tracer library alarm system call arrange sigalrm signal delivered application number seconds tracer library catches signal determines application executing signal instruments function agent starts propagating point usual method activates tracer user hits key combination notified keyboard events implemented linux kernel module intercepts keyboard interrupts irq application starts library issues ioctl system call register application kernel module enable snooping ability module receives keyboard interrupt checks key combination pressed sends sigprof signal registered application initiate tracing library catch signal process similarly sigalrm events stack walking activation methods discussed common shortcoming tracing subgraph application call graph start tracing function propagate instrumentation callees call graph callers initial function instrumented tracing stop initial function returns tracing starts function calls trace records address problem augmented starting mechanisms stack walking capability tracing starts walk stack instrument current function functions stack main technique continue tracing current function returns obtain complete traces stack walking techniques fully robust optimizing compilers emit functions stack frames stack frames frame pointer walking stack past functions detecting cases unreliable crash application obviate stack walking plan implement scheme tracing starts instrument call sites current function return instructions return-point instrumentation reached register points return address tracer find caller current function propagate turn instrument caller return points advance caller notice return-point instrumentation needed walk functions stack started tracing removed reached activating kernel-level tracing traced application issues system call preempted hardware interrupt tracer starts recording kernel functions application resumes user-level execution kernel tracer propagation mechanisms shares code base user-level counterpart controlling kernel tracing implemented linux kernel module dev ktracedrv ioctl interface activate kernel tracing application issues ktrace start ioctl command typically framework issues command starting user-level tracing command makes driver preinstrument kernel entry points irq hardware interrupts system call system calls moment events collect incurred function calls module trace buffer similarly stop kernel tracing application issue ktrace stop ioctl command ktracedrv sees command pulls inserted instrumentation restoring kernel image original state collected data returned user space ioctl figure user-level trace mplayer irrelevant details hidden figure kernel activity mplayer running experimental results evaluate approach applied analysis performance problem choppy dvd playback mplayer non-responsive gui microsoft word running wine emulator system crash problems required techniques trace collection describe separately end section compare overhead self-propelled tracing existing approaches analysis multimedia application mplayer popular multimedia player linux platforms supports wide variety video audio formats works low-end consumer systems experience quality dvd playback adequate player drops frames resulting user-visible freezes playback modern systems symptoms common mplayer community accumulated knowledge base potential fixes decided proceed autonomously model real world conditions bugs specific found community end ease tracing self-propelled instrumentation allowed fix problem identify root investigate 
problem mplayer display short dvd trailer low-end pentium mhz desktop computer running linux system satisfies typical hardware requirements dvd playback fact verified hardware capabilities machine adequate task trailer displayed accurately commercial dvd players microsoft windows time playback linux choppy mplayer reported frames dropped find problem subject self-propelled tracing player starts pre-load tracer library preload mechanism library initializes requests alarm signal delivered seconds signal arrives mplayer middle playback handler tracer library catches initiates instrumentation collects trace milliseconds frames trailer pulls instrumentation lets test run completion mplayer terminates save trace disk visualize nupshot tool nupshot proved powerful navigating collected traces interactively zooming relevant fragments printed snapshot data hard understand significant volume irrelevant details address problem figure displays real trace mplayer showing functions called directly main relevant details periodic sequence events fragments similar structure correspond processing sequential frames note timing events frame rest frames frames spend average milliseconds decode audio milliseconds decode video frame spends similar amount time milliseconds decode video spends significantly milliseconds decode audio figure kernel activity magnification trace reveals time spent decode audio attributed single call read packet function finding surprising reasons trace shows time spent read packet callees time spent executing loop binary code read packet loop calls memcpy iteration trace repetitive calls memcpy long delay short straight-line code sequence suggests mplayer preempted middle function collecting additional instances trace similar long delays parts code expected read system call surprising calls malloc memory allocation routine verify preemption hypothesis turn results kernel tracing hide irrelevant details capture preemption events starting kernel instrumentation irq kernel entry point figure shows system idle periodic timer interrupts triggered milliseconds burst kernel activity time read packet executing data suggest time attributed read packet spent kernel handling hardware interrupts find preemption examine kernel trace closer range figure shows time spent cdrom read intr called ide intr fact suggests system handling ide interrupt signaled dvd drive data read handle interrupt cdrom read intr called atapi input bytes loop immediately called ide input data source code ide input data found spent time reading data drive bytes time insl input long port instructions fact fetching data drive buffers ultimate bottleneck suggests fix problem enabling dma direct memory access allowthe dvd drive put data main memory cpu intervention linux ide driver superuser change settings run time hdparm utility enabled dma transfers dvd drive mplayer stopped dropping frames problem kernel traces reveal dma greatly oads cpu system spend time handling ide interrupts time handle single ide interrupt invocation ide intr shrunk milliseconds milliseconds searching internet confirmed problems choppy dvd playback linux solved enabling dma dma default ide chipsets reported data corruption conditions summarize self-propelled tracing correctly identify short intermittent performance problem ability cross kernel boundary proved powerful mechanism trace problem kernel analysis gui application wine application users run microsoft windows applications windows environment works surprisingly cases wine match native execution speed windows applications gui applications wine noticeably responsive wine takes severalseconds display drop-downmenu microsoftword behavior minor nuisance access menu bar application starts lets demonstrate general approach pinpointing problems self-propelled instrumentation figure trace functions opening drop-down menu low-level details hidden study initiate tracing user hits key combination time launching wine alt-f open drop-down file menu stop tracing user hits key key press activation method worked applications encountered problem wine stack walking routine unable walk stacks winword running emulator closer binary code application revealed wine linux binary directly executes winword code windows binary portions winword code supporting libraries optimized standard frame pointer making stack walks virtually impossible future technique section eliminate reliance stack walks interim workaround mechanism trace wine activate self-propelled agent application startup follow flow control wine emit trace records alt-f combination pressed functions call stack instrumented agent start tracing walking stack function-level trace wine obtained technique displayed figure data show wine spent time calls wine dlopen examining source code found function loads dynamic libraries run time apparently access menu bar microsoft word load dynamic libraries disk operation expensive produces user-visible freeze middle displaying menu accesses menu bar trigger calls wine dlopen required libraries loaded time identify libraries winword load modified source code wine dlopen print library loaded surprise majority libraries loaded menu click multimediarelated including winmm dll standard component windows multimedia api wineoss drv wine oss open sound system driver apparently user opens drop-down menu winword system play audible click play sound wine load multimedia libraries discovering problem found similar problems reported native windows environment application explorer exe pre-load libraries wine starts application problem users insignificant performance hit startup taking hit run time highly visible test idea modified wine source perform pre-loading problem eliminated reducing time takes display menu seconds fraction sptracer identify performance problem study revealed limitation current prototype code analysis tool unable discover parts code winword executable native windows dll libraries result tracer follow call chains producing blind spots trace close examination trace revealed call chain leading wine dlopen passed blind spot fortunately functions blind spot chain instrumented time wine executed loading shared objects startup fact allowed sptracer receive control notice calls wine dlopen identify performance problem discovering code ine analysis ine tools analyze dynamically-generated code plan address limitations hybrid approach combine ine code analysis on-the-fly capabilities similar dynamo diota pin maintaining repository code analysis results applications retain low-overhead feature ine code analysis unknown code fragment discovered tracer parse figure trace apm events freeze kernel figure normal sequence standby apm events kernel fly add results persistent repository similar approach proved viable dynamic binary translation repository keeping translated code debugging laptop suspend problem locating causeof problem unfamiliar piece kernel code challenging task describe self-propelled instrumentation helped investigate power-management problem ibm thinkpad laptop computer running linux left idle amount time laptop question power-saving standby mode wake resume normal execution standby screen remained blank respond keyboard mouse events accept network connections freezes happened recent linux kernels original kernel pre-installed redhat distribution exhibit behavior locate problem self-propelled instrumentation trace kernel events happen system transitions standby state initiate tracing tool sends ktrace start ioctl request dev ktracedrv executes apm command initiate standby system starts generating trace runs locks fetching trace memory frozen system resorted printing 
trace records serial connection generated laptop serial connector infrared port emulate serial port connect similarly-configured machine end approach proved work short traces sending complete record kernel function calls narrow -kbit serial connection introduced unbearably high overhead system unable reach standby state minutes tracing takes reduce amount trace data serial connection restricted scope tracing apm powermanagement code linux kernel instrumenting standard entries hardware interrupts system calls injected initial instrumentation entry points apm device driver dev apm bios trace functions belong address range driver figure shows trace apm-related events immediately preceding freeze apparently system locks apm bios call simple function call apm bios call simple returns source code apm bios call simple confirmed invokes apm routines bios firmware chain calls driver servicing standby ioctl request user-level program compare figure shows record apm events kernel freeze almost-identical trace calls apm bios call simple returns system executes apm bios calls interrupts typically disabled fact explain system respond keyboard mouse wake events confirm interrupts serviced freeze adjusted tracing approach inject instrumentation irq hardware interrupt entry point flow control reaches standby function traces showed interrupt activity call apm bios call simple warm-up steady-state inactive pre-instr diota self-prop compiled gccwarm-up steady-state inactive pre-instr diota self-prop compiled gcctable slowdown mplayer verify interrupts serviced disabled made system generate periodic non-maskable interrupts nmi booting kernel nmi watchdog flag nmi interrupts affected cli instructions delivered interrupts disabled surprise nmi interrupts longer generated apm bios call simple entered behavior caused disabling maskable interrupts made suspect interrupt controller stopped functioning properly standby call apm bios call simple recent systems typically equipped interrupt controllers smp machines require apic advanced programmable interrupt controller uniprocessors apic original pic programmable interrupt controller apic features hardware software support pic appears tested verify problem apic-stability issue recompiled kernel standard pic kernel system enter standby mode wake user activity properly problem found traditional methods step execution apm application debugger identify problem ioctl call step ioctl apm driver kernel debugger hypotheses tested instrumenting kernel source code sending traces serial connection flexibility dynamic nature self-propelled instrumentation allowed find problem modifying kernel overhead study estimate run-time overhead self-propelled tracing measure slowdown introduced mplayer dvd playback thinkpad measure slowdown modified mplayer source code count number cycles spent processing video frame note show frames regular interval video clip mplayer inserts calculated delay decoding frame showing screen adjustable nature delay mask overhead measuring exclude time spent sleeping total time processing frame compare self-propelled instrumentation approaches pre-instrumentation diota version perform pre-instrumentation self-propelled framework insert trace statements functions startup starting measurements disable propagation instrumentation pre-instrumentation self-propelled instrumentation call empty trace routines entry exit function application diota support function-level tracing measure lower bound overhead overhead control flow executing trace calls model trace collection short interval execution measure overhead stages warm-up frame enabling tracing steady-state enabled inactive disabling enabling tracing overhead approaches proved depend compiler building mplayer overhead varied greatly depending functions compiler decided inline table table present highest mplayer compiled gccand lowest mplayer compiled gccoverhead results discussion applies runs instrumentation methods show similar relative performance pre-instrumentation approach demonstrates reasonable performance warm-up steady-state stages notice warm-up overhead pre-instrumentation self-propelled instrumentation lower steady-state tracing frame takes longer fetch decode rest frames lowers warm-up overhead instrumentation methods pre-instrumentation rapidly enabled fly same-address space instrumentation self-propelled framework requires approximately milliseconds instrument functions mplayer supporting libraries time exceeds -millisecond interval allotted displaying video frame larger applications delay pronounced alternative approach pre-instrument function startup force user endure steady-state overhead entire running time system current version diota support on-demand activation implemented non-zero overhead inactive stage problematic importantly diota significant warm-up overhead resulting dropped frames startup lower overhead run building code cache fly unacceptable analysis latency-sensitive applications introduce intermittent delays run-time activation tracer flow control reaches previously-unseen code contrast warm-up overhead self-propelled instrumentation significantly lower diota perform code analysis advance populate code cache impose overhead inactive stage tracing rapidly activated demand measure upper bound steady-state overhead self-propelled instrumentation traced microbenchmark invoking empty function tight loop self-propelled instrumentation benchmark ran slower pathological cases rare real applications addressed plan design adaptive scheme detect short frequently-executed functions avoid tracing lower run-time overhead efficacy scheme studied conclusion presented approach detailed performance analysis system introspection key features approach ability analyze black-box systems human high level detail low overhead enabling technology ability perform analysis flow control follow control flow efficiently in-situ instrumentation perform code analysis advance approach proved feasible performance analysis debugging real-world interactive systems ability cross kernel boundary foundation future full-system analysis acknowledgments victor zandy eli collins philip roth anonymous reviewers helpful feedback revisions paper dyninst expertise laune harris invaluable debugging code analysis tool akkerman strace home page http liacs wichert strace albertsson temporal debugging profiling multimedia applications multimedia computing networking san jose jan anderson berc dean ghemawat henzinger leung sites vandevoorde waldspurger weihl continuous profiling cycles acm transactions computer systems nov bala duesterwald banerjia dynamo transparent dynamic optimization system conference programming language design implementation vancouver british columbia june barham isaacs mortier narayanan magpie real-time modelling performance-aware systems workshop hot topics operating systems lihue hawaii bruening duesterwald amarasinghe design implementation dynamic optimization framework windows acm workshop feedback-directed dynamic optimization austin dec buck hollingsworth api runtime code patching journal high performance computing applications winter cantrill shapiro leventhal dynamic instrumentation production systems usenix annual technical conference boston june cespedes ltrace home page http cespedes software ltrace chen kiciman fratkin brewer fox pinpoint problem determination large dynamic internet services international conference dependable systems networks washington june chernoff hookway digital running -bit applications alpha usenix windows workshop seattle washington aug cohen multiple architecture characterization linux build process oprofile http people redhat wcohen wwc cohn muth pin user guide http rogue colorado pin documentation php cyberlink corporation cyberlink powerdvd system requirements http gocyberlink english products powerdvd system requirements jsp endo seltzer improving interactive systems tipme acm sigmetrics performance evaluation review june graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june herrarte lusk studying parallel program behaviour upshot technical report anl argonne national lab hollingsworth altinel dyner user guide http dyninst docs dynerguide pdf houston kernel trace mechanism kdb http ussg hypermail linux 
kernel html kerninstapi programmer guide http paradyn kerninst releasekapiprogguide html lindlan cuny malony shende mohr rivenburgh rasmussen tool framework static dynamic analysis object-oriented software templates high performance networking computing conference dallas nov maebe ronsse bosschere diota dynamic instrumentation optimization transformation applications wbtworkshop binary translation charlottesville virginia september magnusson dahlgren grahn karlsson larsson lundholm moestedt nilsson stenstrom werner simics sun virtual workstation usenix annual technical conference orleans june microsoft knowledge base performance issues loading winmm dll http support microsoft default aspx scid en-us miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer nov mirgorodskiy miller crosswalk tool performance profiling user-kernel boundary international conference parallel computing dresden germany sept mplayer home page http mplayerhq playing dvd videos http linuxquestions questions answers prasad chiueh binary rewriting defense stack-based buffer overflow attacks usenix annual technical conference san antonio june red hat cluster suite configuring managing cluster http redhat docs manuals enterprise rhel-manual cluster-suite ap-hwinfo html robertson itrace home page http ucsb wkr projects itrace rosenblum bugnion devine herrod simos machine simulator study complex computer systems acm transactions modeling computer simulation jan schendel tracetool simple dyninst tracing tool http paradyn tracetool html srivastava eustace atom system building customized program analysis tools conference programming language design implementation orlando florida june sun microsystems truss trace system calls signals solaris manual collection http docs sun tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating systems design implementation orleans feb wine home page http winehq zandy force process load shared library http wisc zandy hijack 
page october typestate checking machine code abstract check statically safe untrusted foreign machine code loaded trusted host system safety means program abides memory-access policy supplied host side technique works ordinary machine code mechanically synthesizes verifies safety proof earlier work lines based c-like type system suffice machine code origin source code present paper address limitation improved typestate system introduce techniques including summarizing effects function calls analysis stop trusted boundaries inferring information sizes types stack-allocated arrays symbolic range analysis propagating information array bounds techniques make approach safety checking precise efficient handle larger collection real-life code sequences previously case allowing subtyping structures pointers allowed implementation analyze code originating object-oriented source code symbolic range analysis eliminated total attempts synthesize loop invariants programs test suite array accesses programs eliminated synthesize loop invariants altogether resulting speedup globalverification phase system ranges median introduction goal check statically safe piece untrusted foreign machine code loaded trusted host system start ordinary machine code mechanically synthesize verify safety proof earlier paper reported initial results approach chief advantage opens possibility certify code produced general-purpose off-the-shelf compiler programs written languages fortran work limit safety policy fixed set memory-access conditions avoided perform safety checking respect safety policy supplied host side earlier work based c-like type system suffice machine code origin source code present paper address limitation introduce techniques make safety-checking analysis precise scalable proof-synthesis techniques employed host side approach viewed alternative proof-carrying code pcc approach pcc requires code producer create machine code proof code safe host perform proof-validation step proof-synthesis techniques employed code producer foreign side untrusted trusted boundary approach viewed ally pcc helps lift current limitations certifying compilers produce pcc automatically programs written safe source languages paper present improved techniques proof synthesis improved typestate-checking system perform safety-checking untrusted machine code implements inheritance polymorphism physical subtyping work introduces method coping subtyping presence mutable pointers section mechanism summarizing effects function calls safety preand post-conditions summaries analysis stop trusted boundaries form step checking untrusted code modular fashion makes safety-checking technique scalable section technique infer information sizes types stack-allocated arrays local arrays left open problem previous paper section zhichen thomas reps barton miller wisconsin madison zhichen reps bart wisc page october symbolic range analysis suitable propagating information array bounds analysis makes safety-checking algorithm dependent expensive program-verification techniques section section review safety-checking technique earlier work section illustrates benefits techniques case studies section compares techniques related work result improvements handle broader class real-life code sequences precision efficiency allowing subtyping structures pointers analyze code originating object-oriented source code symbolic range analysis eliminated total attempts synthesize loop invariants programs test suite array accesses programs eliminated synthesize loop invariants altogether resulting speedup global verification ranges median improvements made global-verification phase range analysis verify untrusted code handle previously safety checking machine code section briefly review safety-checking technique earlier work safety-checking analysis enforces default collection safety conditions prevent type violations array out-of-bounds violations address-alignment violations uninitialized variables null-pointer dereferences addition host side precise flexible access policy access policy specifies host data accessed untrusted code host functions methods called means host privilege untrusted code accomplish task approach based annotating global data host type information untrusted code inferred analysis starts information initial memory state entry untrusted code abstractly interprets untrusted code produce safe approximation memory state program point annotates instruction safety conditions instruction obey checks conditions memory states entry program points untrusted code terms abstract storage model anabstract store total map abstract locations typestates abstract location summarizes physical locations analysis finite domain work typestate describes type state access permissions values stored abstract location initial memory state entry untrusted code host-typestate specification invocation specification host typestate specification describes type state host data invocation untrusted code safety preand post-conditions calling host functions methods invocation specification binding information host resources registers memory locations represent initial inputs untrusted code safety-checking analysis consists phases phase preparation combines information provided host-typestate specification invocation specification access policy produce initial annotation form abstract store program entry point produces interprocedural controlflow graph untrusted code phase typestate-propagation takes control-flow graph initial annotation inputs abstractly interprets untrusted code produce safe approximation memory contents typestate abstract location program point phase annotation takes input typestate information discovered typestate-propagation phase annotates instruction local global safety conditions assertions local safety preconditions conditions checked typestate information assertions restatements logical formulas facts implicit page october typestate information fourth phase local verification checks local safety conditions phase global verification verifies global safety conditions program-verification techniques present implementation handles non-recursive programs improved typestate system past work analysis made assumption register memory location stored values single type program point register memory location store types values program points approach drawbacks programs written languages support subtyping inheritance programs written languages programmers ability simulate subtyping inheritance section describe extended typestate system incorporate notion subtyping pointers approach register memory location occurrence instruction resolved polymorphic type super type acceptable values rest section describe improved type component typestate system type expressions figure shows language type expressions typestate system compared previous work typestate system includes bit-level representations integer types top bottom types parameterized size parameter type int represents signed integer bits highest bits middle bits represent sign result sign extension lowest bits represent -bit signed integer represented int -bit signed integer char -bit sign extension represented int type uint represents unsigned integer middle bits zeros type denotes pointer points middle array type size ground ground types pointer base array type size pointer middle array type size ptr pointer struct union function top type bits bottom type bits type bits member labeled type offset ground int uint figure simple language type expressions stands type stands struct union member language chosen express type system bit assume untrusted code necessarily written page october bit-level representation integers express effect instructions load store partial words code fragment sparc machine language copies character pointed register location pointed register ldub stb points signed character c-like type system typestate checking lose precision checking code fragment loss precision instruction ldub loads register byte memory zero-fills highest bits type system treats unsigned integer contrast bit-level integer types figure assign type int execution load instruction preserves fact lowest bits store signed character int subtyping 
relation introduce notion subtyping type expressions adopted physical-subtyping system takes account layout aggregate fields memory figure lists rules define type physical subtype denoted figure rules top bottom ground pointer array additions physical-subtyping system integer type subtype type range represented subrange range represented sign-extension bits rule member states structure subtype scalar type type member structure subtype scalar type consequence rule valid program pass structure place supertype member expected rules structures members state structure subtype prefix member supertype member rule members constraints members structures rule pointer states subtype ptr subtype ptr rule array states pointer base array subtype pointer middle array system assignment legal type right-hand-side expression physical subtype type receiving location receiving location space rule array valid describes larger set states global-verification phase analysis check array bounds figure inference rules define subtyping relation note subtype ordering conventional typestate checking ordering flipped type lattice iff structures top sizeof bottom sizeof ground int int member members reflexivity array pointer ptr ptr uint uint uint int page october allowing subtyping integer types structures pointers analysis handle code implements inheritance polymorphism physical subtyping function accepts -bit integer legal invoke function actual parameter signed character int provided actual parameter stored register memory instruction handles sign extension properly figure shows involves subtyping structures pointers subtyping inference rules structures pointers type colorpointptr subtype pointptr function polymorphic legal pass actual parameter type colorpointptr function object-oriented languages additional complication arises virtual functions virtual function implemented subclasses long full information class hierarchy simply assume callee call virtual function functions implement virtual function check state access component typestate system briefly review state access components typestate system state lattice bottom element denotes undefined type scalar type state denote uninitialized initialized values define state lattice pointer type state non-empty set abstract locations referenced define elements null sets define iff aggregate type state states fields access permission subset tuple access permissions access permission introduced pointer-typed values pointer dereferenced access permission applies values type pointer function values hold address function function pointed called untrusted code access permission includes rights examine copy perform operations covered meet access-permission sets intersection meet tuples access permissions meet respective elements type checking subtyping typestate checking subtyping readers familiar problems encountered subtyping presence mutable pointers suspicious rule pointer fact rule pointer unsound traditional flow-insensitive type systems absence alias information flow-insensitive analysis account aliasing unable determine indirect modifications shared data structure indirect modifications disastrous effects figure concrete statement line clrptr point object type point indirectly variable clrptr longer fulfill obligation supply color field line static technique handle problem detect disastrous indirect modifications happen approaches problem found literature linear type system avoids aliases altogether indirect modifications consuming pointer struct point int int struct colorpoint int int uint color void point y-figure subtyping pointer types page october smith singleton types track pointers alias constraints model shape store goal tracks non-aliasing facilitate memory reuse safe deallocation objects approach involves introducing notions immutable fields objects idea subtype type type ptr subtype ptr field subtype field immutable field pointer object pointed immutable rule applies transitively approach work correctly mechanism needed enforce immutability restrictions work represents fourth technique system performs typestate checking flow-sensitive analysis tracks aliasing relationships abstract locations state descriptors resemble storageshape graphs chase similar diagrams shown right-hand column figure inspecting storage-shape graphs program points access heap-allocated storage safely detect illegal field access occur instance shape graph arises statement figure analysis determine access color statement represents memory-access error programs accesses rejected safety checker summarizing function calls summarizing function calls safety-checking analysis stop boundaries trusted code tracing body trusted callee analysis check call obeys safety pre-condition post-condition rest analysis describe method summarizing trusted calls safety preand post-conditions terms abstract locations typestates linear constraints safety pre-conditions describe obligations actual parameters meet post-conditions provide guarantee resulting state produce safety preand post-conditions hand process error-prone desirable automate generation function summaries recent work interprocedural pointer analysis shown pointer analysis performed modular fashion techniques analyze function assuming unknown initial values parameters globals function entry point obtain summary function dataflow effect function future work investigate techniques create safety preand postconditions automatically typedef point pointptr typedef colorpoint colorpointptr colorpoint clr point void void pointptr bwptr colorpointptr clrptr clr colorpointptr clrptr pointptr bwptr clrptrcolor figure rule pointer unsound flow-insensitive type checking absence aliasing information assume type declarations shown figure bwptr clrptr clr clrptr clr clrptr clr clrptr bwptr bwptr bwptr bwptr page october represent obligation provided actual parameter placeholder abstract location placeholder size access permissions typestate provide detailed requirements actual parameter satisfy formal parameter pointer state descriptor include placeholders represent obligations provided locations pointed actual parameter model state descriptor pointer-typed placeholder refer null placeholder placeholder null refers null actual parameter point null refers placeholder locations pointed actual parameter satisfy obligation denoted placeholder state descriptor refers null placeholder actual parameter point null locations satisfy obligation represent pre-conditions list form placeholder typestate safety post-conditions provide safety-checking analysis compute resulting state call summarized function represented list post-conditions form alias context placeholder typestate alias context set potential aliases potential non-aliases neq placeholders alias contexts capture aliasing actual parameters affect resulting state safety preand post-conditions include linear constraints safety pre-conditions represent additional safety requirements post-conditions provide additional information resulting memory state call make idea concrete figure shows summarizes library function gettimeofday specifies call safe null address writable location size sufficient storing type structtimeval safety post-conditions execution call fields location initialized initialized integer sparc actual parameters passed registers return function stored register figure alias contexts empty ambiguity aliasing alias contexts summarize function calls precision opposed make fixed assumptions aliasing figure shows alias contexts provide precision function returns null object pointed parameter depending aliases checking call trusted function involves binding process update process binding process matches placeholders actual abstract locations checks meet obligation update process updates typestates actual locations represented placeholders safety postconditions int gettimeofday struct timeval safety pre-condition struct timeval ptr null struct timeval safety post-condition struct timeval int int int figure safety preand postconditions typestate aggregate typestates components enclosed component labeled offset bits closest enclosing aggregate page october goal summarize library functions generally complicated things pointers present focused obligations represented tree placeholders 
obligations represented fall back letting typestate-propagation phase trace body function tree-shaped placeholders binding process carried simple algorithm binding algorithm iterates formal parameters obtains respective actual parameters typestate descriptors call site traverses obligation tree checks actual parameter meets obligation establishes mapping placeholders set abstract locations represent store callsite binding process distinguishes information information intuitively placeholder represent location binding algorithm establish represent unique concrete location algorithm updating process interprets post-condition distinguishes strong update weak update depending placeholder represent unique location represent multiple locations alias context evaluates true false strong update placeholder represents unique location alias context evaluates true weak update placeholder represent multiple locations alias context determined true false case typestate location receives meet typestate call typestate post-condition alias context determined true false update post-condition place make safest assumption weak update inferring information stack-allocated arrays determining information arrays reside stack difficult figure types bounds previous work required manual annotations procedures made local arrays section describe method inferring subrange stack frame holds array illustrate method simple figure shows program updates local array column shows sparc machine code produced compiling program gcc version infer local array present examine live pointers time typestate-propagation algorithm reaches entry loop discussion abstract location denotes stack frame allocated add instruction line denotes point offset denotes subrange starts offset ends offset abstractly interpreting add instructions lines find points points time typestate-checking algorithm visits loop entry point column figure abstractly interpreting instructions line line reveals stores integer time typestate-checking algorithm visits loop entry points pointptr pointptr pointptr null return safety pre-condition pointptr ptr pointptr ptr pointptr safety post-condition neq pointptr pointptr null figure safety preand post-conditions alias contexts page october orsf candidate local array reasoning runs create fictitious components shown right-most column figure point component instruction polymorphic usage program point pointer pointer compatible types choice type system pointer array letting denote type array element compute general type steps compute size compute greatest common divisor gcd sizes slots delimited pointer consideration slot size size compute limits array assume array ends location closest live pointer stack pointer consideration compute type assuming size computed create fictitious location size give initial type slide area identified step bytes time bytes time perform meet operation covered ifan area covered sub-area type assume type find struct int refinement needed general make refinements findings iterations typestate-checking algorithm refinement bring element type array type lattice address consideration register general form registers integer method heuristics compute limits array affect soundness approach reasons typestate-propagation algorithm make program type correct ensure element type inferred correct global-verification phase verify local array inferred bounds program sparc machine language time time typedef struct int int int main int main add add mov add cmp bgeu mov add cmp blu add retl figure inferring type size local array label represents entry loop int page october note matter analysis original program written terms n-dimensional array terms -dimensional array analysis treats arrays -dimensional arrays approach works original code written terms n-dimensional array layout scheme compilers n-dimensional array involves linear indexing scheme reflected linear relationships analysis infers values registers range analysis technique array bounds checking earlier work techniques cousot halbwachs precise higher cost describe simple range analysis determines safe estimates range values register program point information determining accesses arrays bounds advantage synergy efficient range analysis expensive powerful technique applied demand apply program-verification technique conditions proven range analysis range-analysis algorithm standard worklist-based forward dataflow algorithm finds symbolic range register program point analysis range denoted lower upper bounds form integer constants symbolic names serve placeholders base address length array reason restrict bounds form array-bounds checks involves checking range array index subrange lengthor range pointer points array subrange base base lengthwhere base length base address length array analysis symbolic names stand unknown values quantities base length ranges form meet semi-lattice respect meet operation ranges meet defined min max top element empty range bottom element largest range function min returns smaller ifl comparable determine relative order instance min returns function max defined similarly returns greater parameters parameters comparable give dataflow transfer function machine instruction define dataflow transfer functions strict respect top element introduce basic abstract operations describing dataflow transfer functions abstract operations summarized integer operations figure binary operations symbolic expressions page october arithmetic operations bounds figure non-zero integers arithmetic operations ensure bounds form comparison instructions major source bounds information analysis works machine code tests forms program variables figure summarizes dataflow transfer functions forms assume ranges tests function min max defined upper bound range smaller lower bound range equivalent empty range dataflow functions variables false branch test improve precision slightly returning empty range equal ensure convergence range-analysis algorithm presence loops perform widening operation node loop dominates source loop backedge range arbitrary variable previous iteration dataflow current iteration resulting range widening operator defined sharpen basic range analysis enhancements enhancement deals selecting suitable spot loop perform widening key observation do-while loop kind dominates binary code effective perform widening test exit loop case loop iterates array loop test length strategy minimizes imprecision crude widening operation range widened loop test immediately sharpened transfer function loop test range propagated loop backedge lengthconsequently analysis quiesces iterations enhancement utitest true branch max min max min false branch true branch min max false branch max min figure dataflow functions tests loops common source code compilers typically transform do-while then-part transformation compiler exploit fact code body do-while executed loop executes perform code-motion fear slowing execution program compiler hoist expressions body loop point then-part loop guarded min min comparable max max comparable ifl page october lize correlations register values test consideration nand establish program point constant incorporate information range analysis assuming branch tests n-c case studies techniques exception technique section infer sizes local arrays implemented safety-checker sparc machine programs illustrate benefits improvements programs examples include array sum start-timer stop-timer code paradyn suite versions btree traversal version compares keys function call hash-table lookup kernel extension implements page-replacement policy bubble sort versions heap sort manually inlined version interprocedural version stack-smashing update message-digest algorithm functions jpvm cases case includes functions module device driver dev kerninst reads kernel symbol table experiments find safety violation implements page-replacement policy attempts dereference 
pointer null identified array out-of-bounds violations stack-smashing array out-of-bounds violations dev kerninst figure summarizes time needed verify examples mhz sun ultra machine times divided times perform typestate propagation create annotations perform local verification perform range analysis perform global verification figure characterizes examples terms number machine instructions number branches number loops total versus number loops number calls total versus sum aging olicy start imer hash bub ble sort stop imer btr btr heap sort heap sort jpvm stacksmashing jpvm ninst number eatur instructions branches loops loops procedure calls trusted calls global conditions bounds checks source language cccccccccccccc typestate propagation annotation range analysis global verification total seconds figure characteristics examples performance results test cases written compiled gcc version dev kerninst written compiled sun workshop comipler page october number calls trusted functions number global safety conditions number bounds checks source language test case written note checking lower upper bounds regarded separate safety conditions times verify examples range seconds seconds extensions typestate system handle broader class real-life examples bit-level representations integers analysis deal instructions load store partial word update stack-smashing examples technique summarize trusted functions analysis summaries host library functions hash startand stop-timer btree jpvm examples dev kerninst examples simply summarize library functions checking implies examples safe library functions safe principle check library code summaries subtyping structures pointers summaries jni methods polymorphic jni function jsizegetarraylength jnienv env jarray array takes type jarray parameter applicable types jintarray jobjectarray subtypes jarray java objects manipulated jni interface model types jintarray jobjectarray physical subtypes jarray summarizing jni interface functions symbolic range analysis system identify boundaries array field structure typestate-propagation algorithm information range register run intraprocedural version range analysis demand intraprocedural range analysis run function test cases array accesses range analysis eliminated total attempts synthesize loop invariants test cases eliminated synthesize loop invariants altogether resulting speedup global verification ranges median conjunction improvements made global-verification phase range analysis verify dev kerninst handle previously figure shows times performing global verification times performing range analysis normalized respect times performing global verification range analysis reason analysis stack-smashing figure times perform global verification range analysis normalized respect times perform global verification range analysis sum jpvmhash sor bub btree btree heap sor heap sor ratio jpvm stac smashing time range analysis normalized time global verification normalized page october slowed array accesses bounds array accesses fact bounds range analysis speed analysis analysis apply program-verification technique conclude array out-of-bounds violations similarly reason hash slowed conditions array-bounds checks range analysis prove array accesses bounds related work papers investigated topics related typestate-checking system symbolic range analysis morrisett introduced notion typed assembly language tal type system model language features instance tal models language features address exceptions existential types hand system models size alignment constraints tal tal type system support general pointers stack stack heap pointers distinguished declare function receives tuple argument accept heap-allocated tuple call site stack-allocated call site finally talx introduces special macros array subscripting updating prevent optimizer rescheduling macros expand code sequences perform array-bounds checks impose restrictions idioms compiler employ implement array subscripting tal achieves flow-sensitivity system tal blocks code labeled functions types assigned registers function system achieves flow-sensitivity typestate instruction mycroft technique reverse engineers programs target machine code typeinference techniques type-reconstruction algorithm based milner algorithm associates type constraints instruction ssa representation program type reconstruction unification mycroft technique infers recursive data-types loops recursive procedures start annotations initial inputs untrusted code technique requires annotation abstract interpretation unification note technique detect local arrays based principle unification technique mycroft technique recovers types registers memory locations technique handle stackand heap-allocated objects technique recovers type information propagates type state access information analysis flow-sensitive mycroft flow-insensitive recovers degree flow sensitivity ssa form variables live ranges ramalingam describe efficient algorithm decomposing aggregates records arrays simpler components based access patterns specific program technique infer local arrays identifies aggregates arrays based access pattern specific loop people techniques statically check out-of-bounds array accesses cousot halbwachs method based abstract interpretation convex hulls polyhedra technique precise simply verify assertions discover assertions deduced semantics program range analysis regarded simple form cousot halbwachs analysis eye efficiency goal advantage synergy efficient range analysis expensive powerful program-verification technique applied demand apply program-verification technique conditions proven range analysis page october verbrugge range-analysis technique called generalized constant propagation gcp symbolic range analysis differs gcp respects gcp domain intervals scalars symbolic ranges gcp attempts balance convergence precision analysis stepping ranges variables failed converge fixed number iterations perform widening operation quicker convergence sharpen analysis selecting suitable spots loops performing widening operation incorporating correlations register values gcp technique points-to information discovered earlier analysis phase current implementation range analysis context-insensitive gcp context-sensitive rugina rinard symbolic bounds analysis analysis gains context sensitivity representing symbolic bounds variable functions polynomials rational coefficients initial values formal parameters analysis proceeds basic block generates bounds variable entry abstractly interprets statements block compute bounds variable program point inside exit basic block based bounds build symbolic constraint system solve constraints reducing linear program coefficient variables symbolic bound polynomials solve symbolic constraint system goal minimizing upper bounds maximizing lower bounds bodik describe method eliminate array bounds checks java programs method restricted form linear constraints called difference constraints solved efficient graph-traversal algorithm demand goal apply analysis array bounds checks selectively based profile information fall back run-time checks cold code blocks wagner formulated buffer-overrundetection problem integer constraint problem solved linear time practice analysis flowand context-insensitive goal finding errors abadi cardelli theory objects monographs computer science gries schneider springer-verlag york bodik gupta sarkar abcd eliminating array bounds checks demand sigplan conference programming language design implementation vancouver canada june chandra reps physical type checking paste sigplan-sigsoft workshop program analysis software tools engineering toulouse france september chase wegman zadeck analysis pointers structures sigplan conference programming language design implementation york chatterjee ryder landi relevant context inference acm symposium principles programming languages san antonio january cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation sigplan conference programming language design implementation vancouver canada june colby lee necula blau plesko cline certifying compiler java sigplan conference programming language design implementation vancouver canada june cousot halbwachs automatic discovery linear restraints variables program annual acm symposium principles programming 
languages tucson january javasoft java native interface specification release jpvm native methods interface pvm java platform http chmsr gatech jpvm mycroft type-based decompilation program reconstruction type reconstruction european symposium programming esop amsterdam netherlands march miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november milner theory type polymorphism programming journal computer system sciences page october morrisett tarditi cheng stone harper lee til compiler performance safety types workshop compiler support systems software tucson february morrisett walker crary glew system typed assembly language annual acm symposium principles programming languages san diego january morrisett crary glew walker stack-based typed assembly language workshop types compilation published xavier leroy atsushi ohori editors lecture notes computer science springerverlag morrisett crary glew grossman samuels smith walker weirich zdancewic talx realistic typed assembly language acm workshop compiler support system software atlanda necula compiling proofs dissertation carnegie mellon september necula lee design implementation certifying compiler acm sigplan conference programming language design implementation montreal canada june necula proof-carrying code annual acm symposium principles programming languages paris france january ramalingam john field frank tip aggregate structure identification application program analysis acm symposium principles programming languages san antonio january rivest message-digest algorithm request comments mit laboratory computer science rsa data security april rugina rinard symbolic bounds analysis pointers array indices accessed memory regions sigplan conference programming language design implementation vancouver canada june siff chandra ball kunchithapadam reps coping type casts seventh european software engineering conference seventh acm sigsoft symposium foundations software engineering toulouse france september smith stack smashing vulnerabilities unix operating system http destroy net machines security strom yellin extending typestate checking conditional liveness analysis ieee transactions software engineering strom yemini typestate programming language concept enhancing software reliability ieee transactions software engineering january small seltzer comparison extension technologies usenix annual technical conference san diego january smith walker morrisett alias types european symposium programming berlin germany march susuki ishihata implementation array bound checker acm symposium principles programming languages los angeles january tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating system design implementation orleans february verbrugge hendren generalized constant propagation study international conference compiler construction link ping sweden april wadler taste linear logic mathematical foundations computer science lecture notes computer science springer-verlag gdansk poland august wegner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed systems security conference san diego february miller reps safety checking machine code sigplan conference programming language design implementation vancouver canada june 
deep start hybrid strategy automated performance problem searches abstract attack problem scalability performance diagnosis tools respect application code size developed deep start search strategy technique stack sampling augment automated search application performance problems hybrid approach locates performance problems quickly finds performance problems hidden straightforward search strategy deep start strategy stack samples collected by-product normal search instrumentation samples strategy selects deep starters functions application bottlenecks good locations early search priorities careful control search refinement strategy preference experiments deep starter functions callees approach enables deep start strategy find application bottlenecks efficiently effectively straightforward search strategy implemented deep start search strategy performance consultant paradyn automated bottleneck detection component tests deep start strategy found half bottlenecks faster average performance consultant current search strategy deep start strategy found bottlenecks search faster average current strategy keywords automated performance diagnosis search sampling introduction automated search performance problems effective strategy performance diagnosis user expert performance analysis productive automated performance problem search tool analysis expertise embodied tool search strategy capability automate searches performance problems enhanced incorporating structural information application study call graph pruning prioritizing space search takes place based application behavior previous runs developed technique sampling augment automated search performance problems attack problem code size scalability hybrid approach called deep start substantially improves tool search effectiveness locating performance problems quickly locating performance problems hidden straightforward search strategy demonstrate power implemented hybrid search strategy performance consultant automated search component paradyn performance tool control performance consultant paradyn performs automated search performance problems dynamic instrumentation technology implement search performance consultant forms hypotheses potential performance problems application inserts dynamic instrumentation evaluate hypotheses true performance consultant begins search general performance problems philip roth barton miller computer sciences department wisconsin madison dayton madison usa pcroth bart wisc work supported part department energy grant de-fg lawrence livermore national lab grant nsf grants cdaand eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon broad scope focus paradyn terminology entire application spending time performing synchronization operations user-configurable threshold performance consultant finds hypothesis true refines search testing specific hypotheses performance consultant found application spending time synchronization refines search application spending time performing synchronization operations processes application current performance consultant search strategy application call graph structure guide refinement application code performance consultant found mpi application spending time sending messages evaluates application spending time sending messages application main function including direct indirect callees subsequently performance consultant finds application spending time sending messages main function callees refines search form individual hypotheses functions main calls directly callees note search branches point main function callee performance consultant prunes search refinement path encounters function hypothesis found false deep start search strategy augments call-graph-based refinement strategy stack sample information guide search performance problems quickly sampling information gathered by-product normal instrumentation ensure dynamic instrumentation inserted safely paradyn performs stack walk application processes determine executing code overwritten instrumentation deep start search strategy stack samples collected early search performance consultant testing general performance problems entire application deep start strategy refines search hypotheses individual functions stack sample information begin searching application main function functions frequently collected stack samples general functions frequently stack samples long-running called times case closer terms automated search refinement strategy functions exhibiting actual performance problems stack sample information makes deep start search strategy efficient current performance consultant search strategy functions frequently stack samples deep start search strategy skip ahead search space start performance problems closer exist application ability deep start strategy detect performance problems quickly current performance consultant search strategy application call graph structure deep start strategy incorporates standard call graph-based search strategy lower priority find performance problems stack sample data deep start search effective current performance consultant search strategy find performance problems hidden current strategy portion application call graph shown figure call graph strategy prune search finding bottleneck bottlenecks significant bottleneck statistical nature sampling guarantee considered deep start search strategy likelihood considered high occurs frequently stack samples desirable replace dynamic instrumentation sampling performance tool sampling collect inclusive cpu performance data performance data function direct indirect callees sampling current program counter program counters functions stack correlating stack samples application call graph approach makes collection inclusive cpu performance data sampling complicated expensive contrast collecting inclusive performance data dynamic instrumentation trivial requiring instrumentation sample timer function entry exit form difference timer samples sampling inappropriate collecting performance data cpu time spent executing function difficult collect elapsed time wall-clock time data sampling impossible collect accurate counts program events sampling approach hand dynamic instrumentation suited collecting elapsed time data long wall timer system-wide tick counter collecting accurate event counts dynamic instrumentation simple inserting instrumentation increment counter event occurs troublesome event-driven sampling sample collected response low-level event expiration timer tool collect samples response instruction cache misses hardware support event-driven sampling problematic modern out-of-order microprocessors compaq alpha intel pentium due imprecise interrupts imprecise interrupts unpredictable delay occurrence event delivery interrupt triggering sample making impossible sampling-based tool associate event instruction function caused event occur finally application behavior missed sampling approach due statistical nature light limitations sampling approach desirable replace dynamic instrumentation sampling leverage strengths sampling dynamic instrumentation deep start search strategy performance consultant performance consultant paradyn automated bottleneck detection component searches application bottlenecks performing experiments determine application experiencing performance problems problems occurring initially experiments test behavior application performance consultant discovers bottlenecks application refines experiments specific nature location bottleneck experiment tests hypothesis reason application performing poorly hypotheses tested performance consultant application spending time performing blocking operations performance consultant activates experiment inserts instrumentation code application collect performance data evaluate experiment hypothesis true figure application call graph hidden performance bottleneck experiment focus helps determine experiment instrumentation code inserted focus denotes set application resources locations application performing poorly functions comprise application executable code resources application processes systems running synchronization objects application barriers spin locks semaphores mpi communicators message tags application resources shown figure paradyn organizes application resources hierarchies type resource represents resources organized beneath hierarchy beneath top-level machine resource resources system application processes running beneath system resource resources application processes running system concise potentially large set resources focus takes advantage hierarchical resource organization focus tuple resource resource hierarchy focus code setup machine wisc syncobject denotes functions 
source file setup executing processes running host named wisc focus specifies top level syncobject resource constrain set resources names synchronization object type synchronization object technique called refinement performance consultant continues bottleneck search true experiment experiment hypothesis true focus creating experiments specific original experiment experiments specific hypothesis specific focus original experiment performance consultant small number predefined hypotheses search refinement involves refinement experiment focus refine focus performance consultant replaces resources focus type resource replaced code resource performance consultant generates foci callees function represented code resource performance consultant refines focus code setup setup machine wisc syncobject replacing code resource setup function calls functions setup initial set ranstuff initialize prn make lattice make lattice resulting foci code setup initial set machine wisc syncobject code ranstuff initialze prn machine wisc syncobject code make lattice make lattice machine wisc syncobject resource replaced code resource performance consultant replaces children figure application resources arranged hierarchies resource hierarchy performance consultant refines sample focus replacing machine resource application processes running host wisc ids resulting foci code setup setup machine wisc syncobject code setup setup machine wisc syncobject cases focus refinement performance consultant search involves taking step time application call graph resource hierarchies builds search path sequences experiments related refinement performance consultant searches resource hierarchy application call graph starting search attempting refine resource type successive focus refinements search path performance consultant generates experiments true experiment focus refinement replaces code resource replace code resource focus refinements experiments refine focus replacing code resource function represented resource callees performance consultant start searching resource hierarchy replacing type resource performance consultant starts searching resource hierarchy experiment path found false performance consultant terminates search path refine experiment path refinement experiment result creation experiment performance consultant search paths simultaneously active terminated ensure overly perturb application study experiments large number active search paths performance consultant observes user-configurable limit amount instrumentation inserted application time graph records cumulative refinements search called search history graph shown figure paradyn visual representation graph search history graph display display dynamic nodes added performance consultant refines search providing visual record search performed performance consultant display mechanism users obtain information state experiment hypothesis focus active performance consultant collecting performance data experiment performance data collected experiment experiment hypothesis true false deep start search strategy deep start search strategy performance consultant stack samples collected by-product dynamic instrumentation guide search paradyn incorporates single front-end process daemons controlling application processes paradyn daemons handle insertion dynamic instrumentation stack samples performed insertion instrumentation daemons collect stack samples send batches performance consultant request search performance consultant analyzes stack samples find deep starters functions application performance problems application based frequency occurrence stack samples creates experiments deep starter functions high priority preference performance consultant chooses experiments perform stack sampling stack samples deep start search strategy collected side effect insertion instrumentation code application processes paradyn daemons insert instrumentation code requested component paradyn front-end process performance consultant visualization manager inserting instrumentation code process paradyn daemon controlling process ensure process executing code overwritten code patch requirement implies paradyn daemon location process executing locations control return process completes function calls progress paradyn daemon current program counter return addresses frames call stack paradyn daemon performs check pausing process walking call stack support deep start search strategy time paradyn daemon performs stack walk saves stack walk information daemon records process sample choosing deep starters performance consultant obtains batch stack samples paradyn daemon adds information sample data structure call function count graph stack samples determine nodes edges directed graph nodes graph represent functions application edges represent call relationship functions dictated stack samples function represented graph graph count number times function stack samples instance assume performance consultant collects stack samples denotes function called function time stack sample figure performance consultant search history graph display compilers support frame pointer omission optimization formal stack frames necessarily present stack function calls progress ensure safety dynamic instrumentation presence compiler optimization paradyn daemons obtain return addresses function calls progress absence formal stack frame figure shows function count graph resulting samples figure node labels function count strengths performance consultant ability examine behavior application behavior per-host per-process granularity capability invaluable finding performance problems related workload imbalance mismatched hardware deep start search strategy enhances finer-granularity searches supporting selection deep starters global per-host perprocess data support choosing deep starters function count information varying granularities function count graph slightly complicated shown figure single count function count graph node maintain tree counts node shown figure graph node represents single function application root count-tree count function counting number times function stack samples nodes level tree count number times function observed stack samples specific hosts level tree counts number times function observed stack samples specific application processes count-trees function count graph performance consultant restrict stack samples considers choosing deep starters make per-host per-process deep starter selections performance consultant choosing deep starters restricted process machine performance consultant traverses function count graph walks count-tree graph node find count representing number times node function stack samples collected process machine performance consultant adding node function deep starter count deep starter threshold performance consultant triggers deep starter selection algorithm updates function count graph requesting latest batch stack samples paradyn daemon controlling application processes stack sample batch performance consultant processes stack sample starting function bottom call stack considers function sample walks function count graph increment counts functions node exists function stack sample performance consultant creates node function initializes count figure function count graph performance consultant finishes updating function count graph traverses graph find functions good choices deep starters functions execute frequently long time execute good candidates fortunately functions found stack sample data functions occur frequently samples base decision finding deep starter functions number times function occurs stack samples choose functions counts higher threshold threshold computed percentage total number stack samples represented function count graph based experience initial implementation deep start search strategy default threshold stack samples represented function count graph chose deep starters deepest functions above-threshold subgraph function count graph functions furthest root function count graph deepest function abovethreshold subgraph deep starter performance consultant focuses attention application performance bottlenecks performance consultant search path code hook experiment determine function count graph counts choosing deep 
starters path search path code hook experiment path performance consultant began refining focus application call graph performance consultant refined focus application main function performance consultant triggers algorithm choosing deep starters search path extracts machine resource focus search path code hook experiment focus machine resource top-level machine hierarchy resource performance consultant global counts traverses function count graph functions counts deep starter threshold machine resource represents specific host process performance consultant traverses count-tree node visits find sample count host process performance consultant search path code hook experiment determine choose deep starters path performance consultant triggers deep starter selection algorithm time refines experiment search path code hook performance consultant waits search figure function count graph nodes count-tree global function counts function counts function counts function counts path well-defined code hook choosing deep starters path performance consultant guaranteed place add deep starter experiments search section adding deep starters search path code hook experiment determine select deep starters search path performance consultant path code hook template experiments creates deep starter functions copies code hook hypothesis focus deep starter experiments replacing code resource code hook focus resources representing deep starter functions deep starter chosen likelihood performance bottlenecks application performance consultant adds deep starter experiments higher priority normal performance consultant search experiments priorities inherited performance consultant refines search sub-search rooted deep starter experiment precedence experiments generated normal operation performance consultant applications large number functions behavior highly advantageous performance consultant throttles amount active instrumentation minimize perturbation application study giving deep starter experiments high priority means undertaken experiments performance consultant enable instrumentation high priority deep starter experiments performance consultant focus attention search space deep starters functions actual bottlenecks application performance consultant find bottlenecks quickly strict top-down search search space comforting properties paradyn search history graph search structure reflects structure application call graph performance consultant searching code resources reflects resource hierarchies searching non-code resources retain properties presence addition deep starter experiments performance consultant adds experiment deep starter function experiments connect deep starter experiment experiment present search history graph behavior shown figure performance consultant added experiment function makemg deep starter experiments functions anneal neighbor isvalid connecting experiments evaluation evaluate deep start search strategy modified performance consultant search strategy current call graph-based search strategy compared behavior deep start strategy current strategy searching performance problems scientific applications experimental environment performed experiments sequential mpi-based scientific applications table mpi applications built version mpich mpi implementation modified performance consultant paradyn version software base augmenting search deep start search strategy current call graph-based search strategy modified paradyn search history graph export facility export information reconstruct search compare behavior search strategies experiments ran paradyn front-end process lightly-loaded sun microsystems ultra system mhz ultrasparc iii processor ram ran sequential applications sun ultra system lan ran mpi applications nodes intel cluster running linux kernel version node ram mhz pentium iii processor cache cluster nodes connected ethernet switch experimental methodology experiments consisted trials application trial consisted runs application performance consultant search application performance problems search strategies run began performance consultant search application reached steady-state behavior performance consultant search reached steady state performance consultfigure deep starter connecting experiments search history graph display version type language domain size draco sequential fortran hydrodynamic simulation lines functions alara sequential induced radioactivity analysis lines functions parallel mpi global ocean climate simulation lines functions rmd parallel mpi pure gauge lattice theory simulation lines functions table application characteristics ant activating experiments exported search history graph experimental results began investigating sensitivity deep start search strategy deep starter threshold section performed experiments range deep starter thresholds sequential application parallel application based results experiments selected single deep starter threshold remaining experiments compared performance deep start call graph search strategies test applications analysis wanted choose run set runs determine run borrow concept utility theory consumer choice microeconomics reflect tool user preferences postulate utility function captures user preference obtaining results tool weight observed results utility function sum weighted results obtain single describing behavior search capture idea users prefer results earlier search utility function decreasing function time analysis chose linear function utility function run largest weighted sum weighted sum smallest absolute rmd application implements gather operations point-to-point message passing functions unique message tag label gather operation prototype implementation resource discovery control mechanism rmd experiments deep start call graph searches rmd application discovery message tags application avoid swamping search experiments ephemeral resources implementing sophisticated approach handling ephemeral resources message tags threads ignores resources creation rate high deep starter threshold sensitivity investigate sensitivity deep start search strategy deep starter threshold performed trials alara sequential application parallel application thresholds collected stack samples table summary experiments total bottleneck count application number distinct bottlenecks found runs performance consultant application search strategy deep starter threshold runs figures show profiles searches alara range deep starter thresholds charts relate bottlenecks found search strategy time found charts show cumulative number bottlenecks found percentage total number bottlenecks type chart steeper curve bottlenecks found earlier rapidly search curve shown figures represents run trial based results table figures chose report results remainder paper experiments deep starter threshold threshold yielded searches maximum weighted sum run average runs trial threshold deep start strategy found bottlenecks compared thresholds alara single threshold superior number bottlenecks found average weighted sums cases behavior threshold close thresholds comparison deep start call graph searches general deep start search strategy found bottlenecks performance consultant call graph-based search strategy intable present summaries deep start call graph searches test applications cases deep start call graph strategies find application bottlenecks deep start strategy found bottlenecks call graph strategy application total bottlenecks deep starter threshold average number experiments attempted average number bottlenecks found percentage bottlenecks found average weighted sum weighted sum alara table summary deep starter threshold sensitivity experiments total bottlenecks number unique bottlenecks observed search application search type deep starter threshold figure search profiles searches alara application range deep starter thresholds time seconds bottlenecks found deep start deep start deep start deep start shown figures deep start search strategy produced results quickly call graph strategy figure shows profile deep start search call graph search test applications figure represents run trial quantify results shown figures present time find percentage 
total bottlenecks table test applications deep start search strategy found half bottlenecks application figure search profiles searches application range deep starter thresholds application total bottlenecks search strategy average experiments attempted average bottlenecks found percentage bottlenecks found average weighted sum weighted sum alara call graph deep start draco call graph deep start call graph deep start rmd call graph deep start table summary deep start call graph comparison experiments total bottlenecks number unique bottlenecks observed search application search type deep starter threshold time seconds bottlenecks found deep start deep start deep start deep start faster average call graph strategy deep start search strategy found bottlenecks search faster average call graph strategy related work deep start-enabled performance consultant stack sampling enhance normal search behavior tools sampling primary source application performance data unix distributions include figure search profiles observed deep start call graph search alara figure search profiles observed deep start call graph search draco time seconds ttlenecks found deep start callgraph time seconds ttlenecks found deep start callgraph prof gprof profiling tools performing flat call graph-based profiles anderson lazowska addressed shortcomings prof gprof parallel applications running shared memory multiprocessors anderson program counter sampling dcpi obtain low-level information instructions executing in-order alpha processors recognizing limitations dcpi approach out-oforder processors dean designed hardware support obtaining accurate instruction profile information figure search profiles observed deep start call graph search figure search profiles observed deep start call graph search rmd time seconds ttlenecks found deep start callgraph time seconds ttlenecks found deep start callgraph types processors form profileme design incorporated modern alpha processors projects program counter sampling primary technique obtaining information application study contrast deep start search strategy collects samples entire execution stack introductory artificial intelligence texts describe heuristics reducing time required search problem state space heuristic involves starting search close goal state adapted idea deep start search strategy stack sample data select deep starters close goal states problem domain bottlenecks application study usual situation artificial intelligence problem search goals deep start search strategy minimize time required find solutions application bottlenecks contrast usual artificial intelligence search stops solution found goal find solutions deep start search strategy augmentation call graph-based search strategy call graph deep start search strategies seek improve search run application karavanic miller showed benefit information collected previous runs application improve characteristics performance bottleneck search karavanic miller approach deep start search strategy priorities control search behavior deep start search strategy designed improve search information current application run previous runs techniques goal deep start search strategy improve behavior performance tool implements automated search performance problems working group forum discussing tools automate performance analysis process including search problem application percentage bottlenecks found call graph average time required sec deep start average time required sec change call graph sec percent change call graph alara found draco found found rmd found table average time required find specific percentages bottlenecks test application found rows average time required find bottlenecks found run space similar paradyn performance consultant helm describe poirot approach heuristic classification control strategy guide automated search performance problems finesse project supports form search refinement sequence application runs provide performance diagnosis functionality conclusions deep start search strategy found hybrid approach augments search stack sampling information outperform call graph-based search strategy general search strategy efficient call graph-based search strategy locating application bottlenecks find bottlenecks earlier search strategy effective call graph-based search strategy find bottlenecks hidden simpler strategy experiments deep start strategy found half bottlenecks application faster call graph search strategy average found bottlenecks search faster call graph strategy deep start strategy effective call graph-based strategy find bottlenecks hidden simpler strategy approach leverages advantages sampling augment automated search sampling sufficient replacing search inability sampling obtain types information inclusive cpu metric information wall clock time limit attractiveness source performance data diagnostic tool deep start strategy leverage advantages techniques automated search tool future work number enhancements deep start search strategy improve behavior reduce overhead adding short dedicated stack sampling period start search technique call priming pump improve quality deep starter selections made early search modifying performance consultant advantage semantic knowledge functions stack samples tailor deep starter selections search path hypothesis path experiments separate function count graph stack samples include communication library functions improve deep starter selections made paths experiments excessive synchronization waiting time hypothesis finally changing pull model push model building function count graphs paradyn daemons front-end process reduce deep start-related traffic daemons front-end process improving scalability tool large machines plan continue exploring microeconomics analysis techniques capture user preferences obtaining results automated performance diagnosis tools work include survey potential tool users gauge willingness pay results production scheme information improve model user preference function model user preference heuristics controlling bottleneck search results produced model acknowledgments paper benefited hard work past present members paradyn research group victor zandy paul wilson professor peter norman wisconsin-madison department economics brian wylie fruitful discussions topic victor zandy erik paulson david thompson enabling collection mpi application results anderson berc dean ghemawat henzinger leung sites vandevoorde waldspurger weihl continuous profiling cycles acm symposium operating systems principles saint malo france october anderson lazowska quartz tool tuning parallel program performance acm conference measurement modeling computer systems boulder colorado working group automatic performance analysis resources tools http gz-juelich cain miller wylie callgraph-based search strategy automated performance diagnosis euro-par munich germany august compaq corporation microprocessor hardware manual part number dsa-te december dean hicks waldspurger weihl chrysos profileme hardware support instruction-level profiling out-of-order processors thirtieth annual ieee acm international symposium microarchitecture microresearch triangle park north carolina december gerndt krumme rule-based approach automatic bottleneck detection programs shared virtual memory systems int workshop high-level programming models supportive environments gen switzerland april graham kessler mckusick execution profiler modular programs software practice experience gropp lusk doss skjellum high-performance portable implementation mpi message passing interface standard parallel computing september helm malony fickas capturing automating performance diagnosis poirot approach proceedings international parallel processing symposium april hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conf knoxville tennessee intel corporation intel pentium processor optimization manual order number karavanic miller improving online performance diagnosis historical performance data portland oregon november miller 
callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november mukerjee riley gurd finesse prototype feedback-guided performance enhancement system euromicro workshop parallel distributed processing rhodos greece january pindyck rubinfeld microeconomics prentice hall rich knight artificial intelligence mcgraw-hill 
callgraph-based search strategy automated performance diagnosis abstract introduce technique automated performance diagnosis program callgraph discuss implementation diagnosis technique paradyn performance consultant implementation includes search strategy dynamic instrumentation resolve pointer-based dynamic call sites run-time compare effectiveness technique previous version performance consultant sequential parallel applications results show search method performs search inserting dramatically instrumentation application resulting reduced application perturbation higher degree diagnosis accuracy introduction automating part performance tuning cycle valuable activity intrinsically complex non-deterministic distributed programs concerned previous research developed techniques automate location performance bottlenecks tools make suggestions fix program improve performance performance consultant paradyn parallel performance tools years automate location bottlenecks basic interface one-button approach performance instrumentation diagnosis novice programmers immediately results identify performance-critical activities program watching performance consultant operation acts simple tutorial strategies locating bottlenecks expert programmers performance consultant head start diagnosis find obscure problems saves programmer time locating common important attribute performance consultant dynamic instrumentation instrument part program inharold cain barton miller brian wylie cain bart wylie wisc http wisc paradyn computer sciences department wisconsin madison work supported part department energy grant de-fg lawrence livermore national lab grant nsf grants cdaand eiaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon appears euro-par munich germany august terested instrumentation longer needed removed insertion removal instrumentation occur program running unmodified executables instrumentation include simple counts function calls bytes communication process elapsed times blocking times synchronization performance consultant shown practice limitations reduce effectiveness operating complex application programs functions modules limitations manifest isolate bottleneck function application code original organized code static hierarchy modules functions modules automated search based tree poor direct search bottlenecks reasons large number modules difficult examine instrumenting modules expensive bottleneck isolated module large number functions module difficult examine paper describe avoid limitations basing search application callgraph contributions paper include automated performance diagnostic strategy based application callgraph instrumentation techniques discover callgraph edges presence function pointers demonstration effectiveness techniques callgraph-based search expensive form timing primitive reducing run-time overhead original designed automate steps experienced programmer naturally perform locate performance-critical parts application program callgraph enhancements theme general idea isolating problem part code starts consideration main program function found critical consideration passes functions calls directly found critical investigation continues functions turn call consideration called functions caller assessed determine bottleneck isolation repeats exigent branch callgraph critical functions found callgraph-directed performance consultant default paradyn parallel performance tools release experience uniformly positive faster generates significantly instrumentation overhead result applications previously suitable automated diagnosis effectively diagnosed section describes paradyn performance consultant original form section describes search strategy based application program callgraph callgraph-based search instrument resolve function pointers mechanism presented section compared effectiveness callgraph-based original version serial parallel applications experiments results section appears euro-par munich germany august paradyn basics paradyn application profiler dynamic instrumentation insert delete measurement instrumentation program runs run-time selection instrumentation results small amount data compared static compile link time selection section review basics paradyn instrumentation discuss performance consultant original limitations isolate bottleneck parts program code exclusive inclusive timing metrics paradyn supports types timing metrics exclusive inclusive exclusive metrics measure performance functions isolation exclusive cpu time function foo time spent function excluding callees inclusive metrics measure behavior function active stack inclusive time function foo time spent foo including callees timing metrics measure process elapsed wall time based cpu time synchronization memory blocking time paradyn inserts instrumentation application make measurements exclusive time figure instrumentation inserted start timer function entry stop exit include time spent function stop timer function call site restart returning call instrumentation inclusive time simpler start stop timer function entry exit figure simpler instrumentation generates run-time overhead start stop pair timer calls takes sgi origin savings significant functions call sites performance consultant paradyn performance consultant dynamically instruments program timer start stop primitives automate bottleneck detection program execua exclusive time inclusive time figure timing instrumentation function foo foo stoptimer starttimer bar car stoptimer stoptimer starttimer starttimer foo starttimer bar car stoptimer appears euro-par munich germany august tion starts searching bottlenecks issuing instrumentation requests collect data set pre-defined performance hypotheses program hypothesis based continuously measured computed paradyn metrics fixed threshold starts search measuring total time spent computation synchronization waiting compares values predefined thresholds instances measured hypothesis exceeds threshold defined bottlenecks full collection hypotheses organized tree hypotheses lower tree identify specific problems higher represent program collection discrete program resources resources include program code modules functions machine nodes application processes threads synchronization objects data structures data files group resources distinct view application organize program resources trees called resource hierarchies root node hierarchy labeled hierarchy move root node level hierarchy represents finer-grained description program resource formed concatenating labels unique path resource hierarchy root node representing resource resource represents function verifya shaded figure code testutil verifya performance measurement isolate measurement specific parts program interested measuring blocking time total entire execution total single function focus constrains view program selected part selecting root node resource hierarchy represents unconstrained view program selecting node narrows view include leaf nodes descendents selected node shaded nodes figure represent constraint code function verifya running cpu machine labeled focus code testutil verifya machine node search represents instrumentation data collection hypothesis focus pair node tests true meaning bottleneck found figure sample resource hierarchies code machine syncobject vect addel verifyb verifya printstatus mainmain testutil vect vect findel vect print cpu cpu cpu cpu code machine syncobject semaphore spinlock barrier message appears euro-par munich germany august performance consultant determine specific information bottleneck considers types search expansion specific hypothesis specific focus child focus defined focus obtained moving single edge resource hierarchies determining children focus method referred refinement pair tests false testing stops node refined refines true nodes specific focus foci roots refinement specific hypothesis constructions avoid undesirable exponential search expansion hypothesis focus pair represented node directed acyclic graph called search history graph shg root node shg represents pair toplevelhypothesis wholeprogram child nodes represent refinements chosen paradyn shg display shown figure original paradyn searching code hierarchy search strategy originally performance consultant based module function structure application wanted refine bottleneck part application code isolate bottleneck modules obj dll file metric module threshold isolate bottleneck functions module strategy drawbacks large programs programs modules 
modules hundreds functions starts instrument modules instrument efficiently time information choose instrument order instrumentation essentially random result functions needlessly instrumented functions module called instrumented callgraph operates size program isolate bottleneck module function exclusive metrics mentioned section metrics require extra instrumentation code call site instrumented functions cheaper inclusive metrics original search strategy based notion coarse-grain instrumentation expensive fine-grained instrumentation code hierarchy searches means instrumentation determine total time module cheaper determining time individual function cost instrumenting module instrumenting functions module difference timer entire module function effect reduced module instrumentation stopping starting timers call sites call functions inside module technique small benefit worth complexity callgraph avoids code hierarchy appears euro-par munich germany august figure original performance consultant bottleneck search progress items immediately toplevelhypothesis added result refining hypothesis excessivesyncwaitingtime excessiveioblockingtime tested false node color pink light grey cpubound blue dark grey tested true expanded refinement code hierarchy module nodes bubba channel anneal outchan random tested false modules graph partition machine nodes grilled brie tested true refined function makemg module partition subsequently found surpassed bottleneck hypothesis threshold final stage search function exigent machine node individually evaluated nodes names rendered black longer active instrumentation instrumented white-text nodes continue evaluated appears euro-par munich germany august dynamic function call instrumentation search strategy dependent completeness callgraph direct search caller-callee relationships included graph search strategy suffer blind spots information missing paradyn standard start-up operation includes parsing executable file memory dynamically linked libraries parsed loaded parsing executable requires identifying entry exits function trickier location function call site classify call sites static dynamic static sites destination determine inspection code dynamic call sites destination calculated run-time call sites static non-trivial number dynamic sites common sources dynamic call sites function pointers virtual functions instrumentation resolves address callee dynamic call sites inserting instrumentation sites instrumentation computes callee address register contents offsets call instruction call destination addresses reported paradyn front-end updates callgraph notifies learns callee incorporates callee search discuss instrumentation call site discuss information gathered call site call site instrumentation code paradyn daemon includes code generator dynamically generate machine-specific instrumentation code illustrated figure instrumentation code inserted figure simplified control flow application instrumentation code dynamic call instruction functionfoois replaced branch instructions base trampoline base trampoline saves application registers branches series mini trampolines instrumentation primitives final mini trampoline returns base trampoline restores application registers emulates relocated dynamic call instruction returns control application foo relocated instruction trampoline base restore regs trampoline mini stoptimer program application save regs callflag calculate callee address appears euro-par munich germany august application replacing instruction branch code snippet called base-trampoline base-trampoline saves restores application state executing instrumentation code instrumentation code specific primitive timing primitive contained mini-trampoline dynamic call instructions characterized destination address residing register memory location dynamic call resolution instrumentation code duplicates address calculation call instructions code reads contents register reading slightly complicated instrumenting call instruction levels registers saved caller-saved registers saved base trampoline original contents register stored stack overwritten access saved registers added code generator primitive abstract syntax tree operand type implemented dynamic call site determination mips sparc power alpha forthcoming examples address calculations shown table show type instruction dynamic call site mini-trampoline code retrieve saved register memory calculate callee address control flow dynamic call site instrumentation instrument dynamic call site application paused instrumentation inserted application resumed call site instrumentation inserted demand caller function relevant bottleneck search function foo dynamic call site site instrumented identifiesfooas bottleneck point callees offoo instrumenting sites demand minimize amount instrumentation application flow control steps shown steps figure call site instrumentation detects time callee called site callee called site instrumentation code notifies paradyn daemon step figure notifies paradyn front-end step table dynamic callee address calculation instruction set call instruction mini-trampoline address calculation explanation mips jalr load stack call edi mov eax ebp mov ecx eax load edi stack load function address memory location pointed eax sparc jmpl add load stack register window appears euro-par munich germany august caller-callee edge added callgraph desired instrumentation inserted newly discovered callee steps incur communication instrumentation cost time dynamic call site executed fortunately call sites call functions small table callee addresses dynamic call site time dynamic call site executed callee determined check table previously caller-callee pair pair previously bypass steps a-d paradyn daemon notified performance consultant dynamic caller-callee relationship advantage information dynamic caller previously determined bottleneck callee instrumented determine bottleneck optimization sequence paradyn daemon instrument dynamic callee discovered reducing added delay conveying information paradyn front-end waiting front-end issue instrumentation request callee optimization require knowledge paradyn daemon type instrumentation timing primitive desired callee limit generality technique dynamic callee determination callgraph-based searching modified performance consultant code hierarchy search strategy direct search application callgraph remainder search hierarchies machine syncobject searched structure hierarchy technique isolating search part code hierarchy starts refining potential bottleneck specific part code starts top program graph program entry function distinct figure control flow performance consultant application issues dynamic call-site instrumentation request function foo daemon instruments dynamic call sites foo application executes call instruction callee found runtime library notifies daemon daemon notifies callee bar function foo requests inclusive timing metric function bar daemon inserts timing instrumentation bar paradyn front-end paradyn daemon application performance consultant main bar foo bar code generator splicer notifier runtime library appears euro-par munich germany august executable involved computation functions instrumented collect inclusive metric current candidate bottleneck cpubound function instrumented cpu time inclusive metric timer metric runs program running function stack entire time application running case metric main program function threshold callgraph identify functions called similarly instrumented inclusive metric callgraph-based search function sustained metric found threshold stop search branch callgraph expand search include function children function sustained metric threshold search continues instrumenting functions calls search callgraph continues manner branches exhausted accumulated metric small reached leaves callgraph activating instrumentation functions executing found callstack requires careful handling ensure program instrumentation active timers flags remain consistent state special retroactive instrumentation immediately executed set instrumentation context partially-executed instrumented function prior continuing program execution timers started immediately executing functions produce measurements earlier waiting function exit removed callstack instrumenting callgraph forms natural organizational structure reasons search strategy based callgraph represents process experienced programmer find bottlenecks program callgraph describes control 
flow program path intuitive programmer instrument function reasonable candidate bottleneck calling functions considered bottleneck callgraph scales large programs step search addressing individual functions function sizes typically proportional code size total number modules functions effect strategy callgraph-based search naturally inclusive time metrics significantly costly dynamic instrumentation system exclusive time counterparts callgraph-based paradyn shg display end comprehensive bottleneck search shown figure advantages callgraph-based search method disadvantages drawback search method potential miss bottleneck single resource-intensive function called numerous parent functions parents meet threshold considered bottleneck application spend time executing single function function parents bottleneck threshold search strategy fail find bottleneck function handle situation worth exigent functions found appears euro-par munich germany august stack paradyn activating modifying instrumentation periodically sample state callstack record callstack samples forms basis candidate functions explicit consideration previously encountered completion callgraph-based search figure callgraph-based performance consultant search completion snapshot shows performance consultant completion search application run pentium xeon nodes linux cluster clarity hypothesis nodes tested false hidden leaving paths led discovery bottleneck view search graph illustrates path performance consultant callgraph locate bottleneck functions functions called time step routine found threshold considered cpu bottlenecks aggregation cluster nodes wrap wrap wrap functions determined synchronization bottlenecks mpi communicator message tag appears euro-par munich germany august experimental results performed experiments evaluate effectiveness search method relative original version performance consultant criteria evaluation accuracy speed efficiency performs search accuracy search determined comparing bottlenecks reported performance consultant set bottlenecks considered true application bottlenecks speed search measured amount time required perform search efficiency search measured amount instrumentation conduct bottleneck search favor search strategy inserts instrumentation application describe experimental set-up present results experiments experimental setup sequential applications multithreaded application parallel application experiments sequential applications include spec benchmarks fpppp fortran application performs multi-electron derivatives program plays game draco fortran hydrodynamic simulation inertial confinement fusion written laser fusion groups rochester wisconsin sequential applications run dual-processor sgi origin irix matrix application based solaris threads package run ultrasparc solaris uniprocessor parallel application sstwod solves poisson problem mpi nodes ibm application previous study parallel application free-surface z-coordinate general circulation ocean model written mpi members space science engineering center wisconsin run nodes -node sgi origin irix characteristics applications affect performance consultant search space detailed table system libraries explicitly excluded accounting subsequent searches table application search space characteristics application language lines code number modules number functions number dynamic call sites draco fpppp matrix sthreads sstwod mpi mpi appears euro-par munich germany august ran application program conditions original callgraph-based case timed run start search alternatives evaluate run saved complete history performance search paradyn export facility recorded time found bottleneck threshold cpu bottlenecks threshold synchronization waiting time bottlenecks sequential applications verified set application bottlenecks prof profiling tool parallel applications paradyn manual profiling versions performance consultant determine bottlenecks results ran original modified versions performance consultant applications measuring time required locate bottlenecks experiment single execution search sgi origin dedicated heavily loaded experiments cases original version unable locate application bottlenecks due perturbation caused larger amount instrumentation requires table shows number bottlenecks found version time required complete search size application significant impact performance original small fpppp benchmark matrix application original version locates application bottlenecks faster callgraph-based functions complex bottlenecks completely cpubound programs types combinations bottlenecks result original performance consultant quickly instrument entire application performance consultant traverse portion application callgraph larger applications search strategy advantages apparent callgraph-based performance consultant performs search significantly faster table accuracy overhead speed search method bottlenecks found complete search instrumentation mini-tramps required search time seconds application original callgraph original callgraph original callgraph draco fpppp matrix sstwod appears euro-par munich germany august program fpppp matrix draco original performance consultant search requires time due additional perturbation unable resolve bottlenecks identifies draco bottleneck functions bottlenecks measured efficiency version performance consultant performs search efficient performance tool perform search inserting minimum amount instrumentation application table shows number mini-trampolines search methods corresponds insertion single instrumentation primitive version performance consultant provide dramatic improvement terms efficiency number mini-trampolines previous version order magnitude larger draco significantly larger applications studied improvement efficiency results perturbation application greater degree accuracy performance diagnosis callgraph-based performance consultant identifies greater number bottlenecks original version performance consultant suffers drawback stems inclusive metrics inclusive timing metrics collect data specific function callees performance data collected restricted single function difficult evaluate function isolation determine exigency functions determined bottlenecks callgraph-based performance consultant bottlenecks remainder functions classified bottlenecks route discovery true application bottlenecks solution inclusive bottleneck ambiguity re-evaluate inclusive bottlenecks exclusive metrics work underway paradyn group implement inclusive bottleneck verification conclusions found callgraph-based bottleneck search paradyn performance consultant combined dynamic call site instrumentation efficient identifying bottlenecks predecessor works faster instrumentation resulting lower perturbation application greater accuracy performance diagnosis advantages callgraph-based search disadvantages remain addressed foremost blind spots exigent functions masked callgraph multiple parent functions meet threshold criteria found bottleneck circumstance appears sufficiently rare encountered instances practice function exigency consideration progress weak inclusive criteria strong exclusive criteria determine true bottlenecks exclusive refinement function found exigent inclusive criteria considered follow-on equivalent refineappears euro-par munich germany august ment children reconsideration exigency stronger criteria additionally remains determined implicit equivalence main program routine code root code hierarchy resource specifiers exploited efficient searches insightful presentation acknowledgements matthew cheyney implemented initial version static callgraph structure paper benefited hard work members paradyn research group group influenced helped results paper specially andrew bernat support aix measurements chris chambreau support irix mips measurements grateful laboratory laser energetics rochester sgi origin system experiments authors codes made ariel tamches provided constructive comments early drafts paper williams hoel pase mpp apprentice performance tool delivering performance cray programming environments massively parallel distributed systems decker rehmann editors birkh user beguelin dongarra geist sunderam visualization debugging heterogeneous environment ieee computer june gerndt krumme rule-based approach automatic bottleneck detection programs shared virtual memory systems int workshop high-level programming models supportive environments gen switzerland april hollingsworth miller dynamic control performance monitoring large scale parallel systems int conf supercomputing tokyo japan july hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conf knoxville tennessee hollingsworth miller gon alves zheng mdl language compiler dynamic program instrumentation int conf parallel architectures compilation techniques san francisco california nov 
karavanic miller improving online performance diagnosis historical performance data portland oregon november kohn williams atexpert journal parallel distributed computing june miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november mukhopadhyay mukerjee riley gurd finesse prototype feedback-guided performance enhancement system euromicro workshop parallel distributed processing rhodos greece january miller dynamic instrumentation threaded applications acm symp principles practice parallel programming atlanta georgia appears euro-par munich germany august 
july page empirical study robustness windows applications random testing abstract report series studies reliability application programs face random input studied reliability unix application programs command line x-window based gui study apply testing techniques applications running windows operating system testing simple black-box random input testing measure crude technique effective locating bugs real programs tested gui-based applications subjecting kinds random input streams valid keyboard mouse events streams random win messages built tool helps automate testing windows applications simple parameters application tested random testing techniques previous unixbased studies showed crash wide variety command-line x-window based applications unix platforms test results similar nt-based applications subjected random valid input produced mouse keyboard crashed applications tested hung additional applications subjected raw random win messages crashed hung applications tested report applications failed tests provide analysis failures introduction report series studies reliability application programs face random input studied reliability unix command line x-window based gui application programs study apply techniques applications running windows operating system testing called fuzz testing simple black-box random input knowledge application generating random input study evaluated reliability standard unix command line utilities showed applications crashed hung reading random input study evaluated larger collection applications study including common x-window applications newer study found failure rates similar original study specifically standard command line unix utilities crashed hung random input x-window applications tested failed deal random input current study find similar results applications running windows measure reliability primitive simple program passes test responds input exit fails crashes terminated abnormally hangs stops responding input reasonable length time application respond sensibly formal specification criterion crude offers mechanism easy apply application crash hang program simple fuzz testing replace extensive formal testing procedures curiously simple testing technique find bugs found techniques study x-window applications provided direction current study test x-window applications interposed testing program application client x-window display server allowed full control input application program send completely random messages application send random streams valid keyboard mouse events current windows study accomplish level input control application windows event mechanisms section subjecting application streams random valid keyboard mouse events tests application conditions tolerate occur normal software subjecting application completely random invalid input messages test general strength error checking considered evaluation software engineering discipline respect error handling producing application justin forrester barton miller jforrest bart wisc computer sciences department wisconsin madison appears usenix windows system symposium august seattle july page years passed study time windows-based applications dominate desktop environment windows windows offers full power modern operating system including virtual memory processes file protection networking felt time comparable study reliability applications environment current study produced main results applications tested crashed presented random valid keyboard mouse events test results applications run windows similar additional applications tested hung presented random valid keyboard mouse events tests results applications run windows similar applications tested failed crashed hung presented completely random input streams consisting random win messages noted result completely random input testing application running windows platforms vulnerable random input streams generated application running system appears flaw win message interface analysis applications source code shows appears common careless programming idiom receiving win message unsafely pointer handle contained message results study significant reasons reliability foundation security results offer informal measure reliability commonly software expose bugs examined rigorous testing debugging techniques potentially enhancing software producers ability ship bug free software expose vulnerability applications windows interfaces finally results form quantitative starting point judge relative improvement software robustness studies access source code large percentage programs tested including applications running vendors platforms gnu linux applications result addition causing programs hang crash debug applications find crash categorized reported results passed software vendors authors form specific bug reports windows environment limited access source code applications result perform analysis applications emacs public source code open source version netscape communicator mozilla section describes details perform random testing windows systems section discusses experimental method section presents results experiments section offers analysis results presents commentary related work discussed section random testing windows platform goal random testing stress application program testing required simulate user input windows environment describe components kernel application involved processing user input describe application programs tested environment study x-window applications random user input delivered applications inserting random input regular communication stream x-window server application types random input random data streams random streams valid keyboard mouse events testing random data streams completely random data necessarily conforming window system protocol application kind input normal operating conditions provided insight level testing robustness application crucial properly constructed program check values obtained system calls library routines random valid keyboard mouse event tests essentially testing application monkey keyboard mouse user generate input failure circumstances represents bug encountered normal application basic principles categories windows environment architecture slightly figure simplified view components support user input windows environment explain role component figure case user clicks link web browser action sets motion windows user input architecture appears usenix windows system symposium august seattle july page mouse click generates processor interrupt interrupt handled system base windows kernel system hands mouse interrupt mouse device driver device driver computes parameters mouse click mouse button clicked adds event system event queue event queue window manager calling mouse event function point device driver work complete interrupt successfully handled system event queue mouse event awaits processing kernel raw input thread rit rit converts raw system event win message win message generic message structure provide applications input rit delivers newly created win message event queue window case mouse click rit create win message lbuttondown identifier current mouse coordinates determine target window message web browser rit determined web browser window receive message call postmessage function function place win message message queue belonging application thread created browser window point application receive process message win application program interface api getmessage function applications retrieve messages posted message queues application threads create windows generally enter message loop loop retrieves message preliminary processing dispatches message registered callback function called window procedure defined process input specific window case web browser win message mouse click retrieved application call getmessage dispatched window procedure web browser window window procedure examine parameters lbuttondown message determine user clicked left mouse button set coordinates window click occurred web link 
architecture test applications random events random win messages testing random events entails inserting random system events system event queue random system events simulate actual keystroke mouse events added system mechanism related device driver mouse event keybd event functions figure windows architectural components user input windows kernel mode keyboard mouse system device driver window manager win user raw input thread rit system event system event queue application program application thread win message thread message queue appears usenix windows system symposium august seattle july page random testing mechanism involves sending random win messages application random win messages combine random valid message types completely random contents parameters delivering messages win api function postmessage postmessage function delivers win message message queue selected window returns note similar function postmessage called sendmessage delivers win message waits message processed fully returning win messages fixed size format messages fields message field integer parameters testing produced random values fields constraining field message range valid message figure shows random testing mechanism fits windows user input architecture notice figure testing conditions target application unable distinguish messages testing mechanisms system distinction essential create authentic test environment experimental method describe applications tested test environment testing tool called fuzz tests performed discuss data collected analyzed applications platform selected group application programs select applications representative variety computing tasks selection influenced software commonly computer sciences department wisconsin software includes word processors web browsers presentation graphics editors network utilities spread sheets software development environments addition functional variety strove test applications variety vendors including commercial free software operating system ran tested applications windows build service pack insure results timely tested subset applications windows system version applications re-tested windows obtained similar results tested hardfigure insertion random input windows kernel mode keyboard mouse system device driver window manager win user raw input thread rit system event system event queue application program application thread win message thread message queue random system events random valid keyboard mouse events random win messages completely random messages appears usenix windows system symposium august seattle july page ware platform testing collection standard intel pentium pcs fuzz testing tool mechanism testing applications tool called fuzz built applications running windows platform fuzz produces repeatable sequences random input delivers input running applications mechanisms section basic operation obtain process application tested launching application explicit command line parameter determine main window target application desktop placement coordinates sendmessage postmessage keybd event mouse event deliver random input running application fuzz invoked command line gui interactions tool interfere testing applications version windows fuzz tool gui interface gui testing tool interfered testing applications result changed fuzz operate command line fuzz command format fuzz -ws -wp pid msgs seed appl cmd line -ws random win messages sendmessage -wp random win messages postmessage random valid mouse keyboard events options option start testing alreadyrunning application process tells fuzz launch application option controls maximum number messages application seed random number generator set options provide finer control sendmessage postmessage tests tests report paper null parameters included tests command messages control activation messages button clicks included tests tests divided categories input techniques section application underwent battery random tests included random win messages sendmessage api call random win messages postmessage api call random system events introduced mouse event keybd event api calls cases completely random input case streams valid keyboard mouse events quantity messages send determined preliminary testing testing appeared application fail number messages events tests detailed performed distinct sequences random input random seeds test trials conduced application random sequence total runs application random input streams application results describe basic success failure results observed tests provide analysis failures applications source code quantitative results outcome test classified categories application crashed completely application hung stopped responding application processed input close application normal application mechanisms categories simple categorize success failure application simple inspection addition quantitative results report diagnosis crashes applications source code figure summarizes results experiments windows figure results subset applications tested windows application failed runs category column result listed table application crashed hung passed tests mark column results tests show large number applications failed deal random input failure rates win message tests greater random valid keyboard mouse event tests expected win message types include pointers parameters applications apparappears usenix windows system symposium august seattle july page ently de-reference blindly tests sendmessage api function produced crash rate applications hung scant successfully dealt random input tests postmessage api function produced slightly higher crash rate hang rate application successfully withstand postmessage test random valid keyboard mouse event results improved random win message test produced significant number application vendor sendmessage postmessage random valid events access microsoft access microsoft acrobat reader adobe systems calculator microsoft cd-player microsoft codewarrior pro metrowerks command antivirus command software systems eudora pro qualcomm excel microsoft excel microsoft framemaker adobe systems freecell microsoft ghostscript aladdin enterprises ghostview ghostgum software pty gnu emacs free software foundation internet explorer microsoft internet explorer microsoft java workshop sun microsystems netscape communicator netscape communications notepad microsoft paint microsoft paint shop pro jasc software powerpoint microsoft powerpoint microsoft secure crt van dyke technologies solitaire microsoft telnet windows mit kerberos group visual microsoft winamp nullsoft word microsoft word microsoft wordpad microsoft ftp ipswitch percent crashed percent hung total percent failed figure summary windows test results crash hang note application crashed hung crash reported appears usenix windows system symposium august seattle july page crashes fully applications crashed hung leaving applications successfully deal random events result troublesome random events introduced user windows system mouse keyboard windows tests similar results performed expected significant difference platforms results confirm expectation crashes source code applications access source code applications gnu emacs text editor open source version netscape communicator mozilla examine applications determine crashes occurred testing emacs crash analysis examined emacs application crashed random win messages crash simple casting parameter win message pointer structure dereference pointer access field structure file fns message handler wnd proc standard win callback function callback function de-reference parameter lparam note error checking exception handling protect de-reference lresult callback wnd proc hwnd msg wparam lparam point pos pos point lparam trackpopupmenu hmenu wparam flags posx posy hwnd null pointer random produced fuzz invalid de-reference caused 
access violation uncommon find failures caused unsafe pointer previous studies found cases cases well-documented literature inspection crashes based machine code appears problem random win message crashes application vendor sendmessage postmessage random valid events access microsoft access microsoft codewarrior pro metrowerks excel microsoft excel microsoft internet explorer microsoft netscape communicator netscape communications paint shop pro jasc software powerpoint microsoft powerpoint microsoft secure crt van dyke technologies visual microsoft word microsoft word microsoft percent crashed percent hung total percent failed figure summary windows test results crash hang note application crashed hung crash reported appears usenix windows system symposium august seattle july page mozilla crash analysis examined open source version netscape communicator called mozilla crashed random win messages crash similar emacs crash crash occurred file nswindow cpp function nswindow processmessage function designed respond win messages posted application windows fashion similar gnu emacs parameter function lparam case assumed valid window handle nswindow control nswindow getwindowlong hwnd lparam gwl userdata control controlsetupforpaint hdc wparam passed argument getwindowlong function access application specific information window case parameter random produced fuzz getwindowlong function retrieving random window application casts return pointer attempts de-reference causing application crash analysis conclusions goal study provide general reliability variety application programs running windows hope study inspires production robust code discuss results previous section provide editorial discussion tests random valid keyboard mouse events provide sense relative reliability application programs tests simulated random keystrokes mouse movements mouse button clicks events caused user concern results tests show commonly-used desktop applications reliable hope tests produced greatest failure rates random win message tests normal events messages produced kernel application program impossible kernel send messages invalid values tests interesting reasons demonstrate vulnerability interface application program send messages application program win interface type protection modern operation systems provide durable firewalls results point discipline software design major interfaces application software components application operating system checks return values result parameters inspection crashes diagnosis source code shows blind de-referencing pointer dangerous simple action protecting de-reference exception handler windows structured exception handling facility make qualitative improvement reliability side note applications detect error provide user reasonable pleasant choices applications follow opportunity save pending made current document open files besteffort save current work copy user file give user hope recovering lost work applications tested saved user dialog pertaining crash contained memory address instruction caused fault hexadecimal memory dump average application user dialog cryptic mysterious serves confuse final piece analysis concerns operating system crashes occasionally unix study tests resulted crashes windows study operating system remained solid crash result testing note early version fuzz tool windows result occasional crashes tool contained bug generated mouse events top left corner screen reason events occasionally crash windows repeatable fashion results inspire comments applications flaky important validate anecdotal intuitions results provide concrete basis comparing applications tracking future hope improvements results lead observations current software testing methodology random testing elegant bring surface application errors evidenced numerous crashes encountered study bugs produced crashes low priority software makers due extreme situations appears usenix windows system symposium august seattle july page occur simple approach find bugs overlooked lack general access application source code prevented making detailed report program failures gnu emacs mozilla applications diagnose limited diagnosis exposes trend poor handling pointers event records studies reasonable access application source code unix vendors result provided bug fixes addition bug reports today software market makes access application source code difficult extreme cases database systems tested study act reporting bugs performance data forbidden licence agreements vendors aggressively pursue restriction vendors righteously defend practices works counter producing reliable systems results presented paper make difference bugs found unix study present study found applications based open source reliability commercial vendors study noted subsequent improvement software reliability measure long vendors importantly purchasers features reliability hope reliable applications remains muted opportunity analysis remains project goals include full testing applications windows goal hard achieve anticipate full results shortly explanation random win message results surprised postmessage sendmessage results differed difference caused synchronous asynchronous nature postmessage sendmessage orthe priority difference types messages reasons identified exploring reasons difference explanation windows windows results test identical versions applications windows windows initial guess results identical differences due reasons including timing size screen system dependent dlls exploring reasons difference related work random testing years ways looked primitive testing community book software testing meyers randomly generated input test cases inefficient hoc approach testing type testing hoc find bugs real programs view random testing tool easy larger software testing toolkit early paper random testing published duran ntafos study test inputs chosen random predefined set test cases authors found random testing fared compared standard partition testing practice track subtle bugs easily hard discover traditional techniques found random testing cost effective testing strategy programs identified random testing mechanism obtain reliability estimates technique primitive easier type random testing duran ntafos programmer knowledge direct tests require construction test cases papers published ghosh random black-box testing applications running windows studies extensions earlier fuzz studies studies authors tested standard command-line utilities windows utilities fared unix counterparts scoring failure rate study interesting tested applications attrib chkdsk comp expand find label replace commonly windows applications based graphic interfaces felt extensive testing random testing test unix system call interface crashme utility effectively exercises interface actively linux kernel developments source code source binary code fuzz tools windows web page ftp grilled wisc fuzz acknowledgments susan hazlett running initial fuzz tests windows john gardner helping initial evaluation fuzz appears usenix windows system symposium august seattle july page tool philip roth careful reading drafts paper microsoft helped study providing pre-release version windows paper referees jim gray provided great feedback review process work supported part department energy grant de-fg nsf grants cdaand eiaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon carey dewitt naughton benchmark acm sigmod international conference management data washington carrette crashme random input testing http people delphi gjc crashme html duran ntafos evaluation random testing ieee transactions software engineering sejuly garfinkel spafford practical unix internet security reilly associates ghosh shah schmid testing robustness windows software international symposium software reliability engineering issre paderborn germany november ghosh shah schmid approach analyzing robustness 
windows software national information systems security conference crystal city october meyers art software testing wiley publishing york miller koski lee maganty murthy natarajan steidl fuzz revisited reexamination reliability unix utilities services wisconsin-madison appears german translation empirische studie zur zuverlasskeit von unix-utilities nichts dazu gerlernt september ftp grilled wisc technical papers fuzz-revisted miller fredriksen empirical study reliability unix utilities communications acm december appears german translation fatale fehlertr chtigkeit eine empirische studie zur zuverlassigkeit von unix-utilities march ftp grilled wisc technical papers fuzz petzold programming windows microsoft press redmond richter advanced windows microsoft press redmond solomon inside windows microsoft press redmond whittaker jorgensen software fails technical report florida institute technology http fit papers swfails pdf appears usenix windows system symposium august seattle 
dynamic kernel i-cache optimization abstract developed facility run-time optimization commodity operating system kernel facility step evolving operating system adapts time rebooting infrastructure implemented ultrasparc solaris includes ability detailed analysis running kernel binary code dynamically insert remove code patches dynamically install versions kernel functions technology implemented run-time kernel version code positioning i-cache optimizations obtained noticeable speedups kernel performance case study performed run-time code positioning kernel tcp read-side processing routine running web client benchmark found code positioning optimizations reduced function execution time resulting end-to-end benchmark speedup primary contributions paper run-time kernel implementation code positioning infrastructure turning unmodified commodity kernel evolving contributions made kernel performance measurement provide simple effective algorithm deriving control flow edge execution counts basic block execution counts contradicts widely held belief edge counts derived block counts describe means converting wall time instrumentation-based kernel measurements virtual cpu time measurements instrumentation kernel context switch handlers introduction paper studies dynamic optimization commodity operating system kernel describe mechanism replacing code kernel function alternate implementation enabling installation run-time optimizations proof concept demonstrate dynamic kernel optimization implementation pettis hansen code positioning i-cache optimizations previously applied statically user-level programs applied code positioning tcp kernel code ultrasparc solaris running web client benchmark reducing ratio cpu time tcp read-side processing routine tcp rput data spent idled due i-cache misses led speedup invocation tcp rput data anda reduction benchmark elapsed run-time demonstrating benchmarks incur cpu time benefit i-cache optimization code positioning consists optimizations procedure splitting called outlining optimization segregates frequently-executed hot basic blocks cold reduce i-cache pollution cold code prevalent kernels due extensive error checking basic block positioning function blocks reordered increase straight-lined execution common case advantages include increasing amount code executed conditional branches decreasing i-cache internal fragmentation due un-executed code shares line common code reduction unconditional branches pettis hansen studies block positioning yielded greatest benefit procedure positioning optimization places code functions exhibit temporal locality adjacent memory reduce chances i-cache conflict misses pettis hansen implemented code positioning feedback-directed customized compiler user code applies optimizations off-line entire program contrast implementation performed kernel code run-time selected set functions optimized time entire kernel ariel tamches barton miller veritas software plymouth street mtv mountain view computer sciences department wisconsin madison tamches veritas bart wisc work supported part department energy grant de-fg lawrence livermore national lab grant nsf grants cdaand eiaand veritas software corporation government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon page implementation on-line kernel version code positioning bigger picture dynamic kernel optimization framework considered step evolving operating system kernels modify code run-time response environment evolving operating system continuous on-line process requires evolution code class part code base treat newly modified installed code previously existing code result code included future measurements optimizations evolving system general dynamic feedback system chooses distinct policies run-time dynamic feedback system hard-codes components logic driving adaptive algorithm measurement code policies logic switching policies run-time pre-compiled evolving system hard-wire components successful implementation dynamic optimization unmodified commercial kernel written expecting optimized evidence commodity kernel made evolving run-time kernel code positioning algorithm demonstration mechanisms support evolving kernel implemented run-time kernel code positioning kerninst dynamic kernel instrumentation system kerninst consists components high-level gui kperfmon generates instrumentation code performance measurement low-level privileged kernel instrumentation server kerninstd small pseudo device driver dev kerninst aids kerninstd arises operate kernel address space perform code positioning steps function optimize chosen step requiring user involvement kerninst determines function i-cache bottleneck basic block execution counts gathered function frequently called descendants counts group functions optimize chosen optimized re-ordering functions chosen installed running kernel interestingly optimized code installed entire code positioning optimization repeated optimizing optimized code reasons discussed section measurement steps measurement phase determines i-cache bottleneck present making code positioning worthwhile assuming optimization forward measurement step collects basic block execution counts user-specified function subset call graph descendants code positioning performed user-specified function subset call graph descendants significantly affects i-cache performance call collective set functions function group user-specified function group root function intuitive basis function group gain control i-cache behavior root function executes group hot subset root function descendants group entered call root function control stay group root function returns leverage knowledge flow control improve i-cache performance time i-cache bottleneck measurement step checks code positioning kperfmon generates instrumentation code measure i-cache stall time root function virtual cpu time function ratio measurements fraction function virtual time processor stalled due i-cache miss user-definable threshold arbitrarily set default algorithm continues kerninst collects timing information desired code resource function basic block inserting instrumentation code starts timer code entry point stops timer code exit point entry instrumentation reads stores current time processor cycle counter exit instrumentation rereads time subtracts time previously stored adds delta accumulated total changing underlying event counter read entry exit measurements timing replacing reading cycle counter framework reading ultrasparc performance counter programmed count i-cache stall cycles yields metric measures time spent i-cache misses desired function basic block general measurement framework called interval counter accumulation page instrumentation accumulates event elapsed cycles measuring time interval counting metric created underlying monotonically increasing event counter measurements made framework inclusive events occur calls made code measured included inclusion vital measuring i-cache stall time function callees contribute i-cache behavior contrast sampling-based profilers collect inclusive time measurements performing expensive stack back-trace sample effectively prohibiting frequent sampling dcpi morph obtain accurate profiles long run-times key aspect measurement framework accumulates wall time events virtual time events includes events occur thread context switched started stopped accumulation trait desirable metrics latency cpu metrics i-cache stall cycles virtual execution time section shows additional dynamic instrumentation kernel context switch handlers convert wall time based metric virtual time collecting basic block execution counts measurement phase performs breadth-first traversal call graph collecting basic block execution counts function called root function active call stack block counts determine functions hot included group divide basic blocks hot cold sets traversal begins instrumenting root function collect basic block counts allowing instrumented system run short time default seconds instrumentation removed block counts examined block function executed statically identifiable callee functions block counts measured pruning applied call graph traversal cases function block execution counts collected re-measured function called basic block execution count measured indirect 
function calls function pointer call graph function reached calls block counts measured functions chance included optimized group measuring block counts called root function collecting basic block execution counts root function descendants include count executions affect root function i-cache behavior descendant function called root function called locations kernel root function case included kerninst collects basic block execution counts kerninst achieves selective block counting performing code positioning re-optimizing optimized code time group generated block counts high code replacement installation version function discussed section performed solely root function non-root group functions invoked optimized root function call stack technique ensures block execution counts re-optimization include executions root function call stack desired allowing basic block counting instrumentation ignore descendant basic block called root function collecting block counts single pass re-optimization require predicating block counting instrumentation code test code called directly indirectly root function instrumentation sets flag root function call stack flag tested block counting instrumentation code extra run-time cost thread-safety require perthread flags extra complexity choosing block ordering steps choosing ordering basic blocks optimized group set functions include group chosen procedure splitting applied function segregating groupwide hot blocks cold blocks basic block ordering applied distinct hot cold sections group function steps determine ordering basic blocks group emitted contiguously virtual memory implicitly performing procedure placement sample group layout shown figure page functions include group functions basic block execution counts measured optimized group includes hot block hot basic block measured execution frequency root function call stack greater frequency root function called threshold user-adjustable frequency root function called number times entry basic block invoked entry basic block predecessors function begins loop sum predecessor edge count subtracted entry block execution count discuss obtaining edge counts section procedure splitting perform procedure splitting group function segregated hot cold chunks chunk contiguous layout hot cold basic blocks function test hot block section function entry block hot chunk beginning chunk simplicity pettis hansen block executed hot kerninst mimic behavior setting user-defined hot block threshold execution count considered cold aid optimization hot cold blocks single function segregated group-wide hot blocks segregated group-wide cold blocks shown figure words procedure splitting applied group-wide basic block positioning procedure splitting divides function basic blocks hot cold chunks basic block positioning chooses layout ordering basic blocks chunk specifically block positioning edge execution counts choose ordering chunk basic blocks facilitates straight-lined execution common case block positioning applied function cold chunk unimportant cold blocks seldom executed remainder section discusses positioning function hot chunk algorithm block positioning variant pettis hansen function control flow graph execution counts edge counts derived algorithm section weighted traversal edge counts basic block function hot chunk chain sequence figure sample layout optimized function group function group consists root function ufs create descendants dnlc lookup enter exit hot chunks highlighted chunks shown scale cold chunks typically larger hot non-root functions inlined group copy enter called times ufs create group calls inter-procedural branches re-directed group version destination function destination selected inclusion group manner control enters group stay root function returns assuming group hot descendants root function hot basic blocks ufs create ordered block positioning hot basic blocks dnlc lookup ordered block positioning hot basic blocks enter ordered block positioning hot basic blocks exit ordered block positioning cold basic blocks ufs create ordered block positioning cold basic blocks dnlc lookup ordered block positioning cold basic blocks enter ordered block positioning cold basic blocks exit ordered block positioning jump table data ufs create dnlc lookup enter exit page contiguous blocks optimized straight-lined execution motivation chains place frequently successor block immediately block branch unconditional branches eliminated conditional branch placing likeliest successors immediately branch fall-through case commonly executed path reversing conditional tested branch instruction general number basic blocks instructions chain expected distance branches assuming edge counts accurately approximate path counts instructions branches i-cache utilization lower mispredicted branch penalty ideally function hot chunk covered single chain emitting installing optimized code kerninst segregates function basic blocks hot cold chunks procedure splitting chooses ordering blocks chunks block positioning generates optimized group installs group code kernel kerninst parses function machine code relocatable representation representation optimized version function re-emitted arbitrary basic block ordering point interleaving blocks functions required group-wide procedure splitting general basic blocks reordered maintaining semantics adjusting branch displacements adding unconditional branches rewriting jump tables similar statically performed eel user-level programs group functions emitted relocatable form group location kernel memory unknown relocatable element inter-chunk branch displacement unknown distance chunks defined call instructions non-group functions address callee call instruction patched proper pc-relative offset call inter-procedural branch function chosen inclusion group altered call group version call left unaltered non-group destination called defeating optimization calls callee callee address presently unknown jump table data relocatable element entry depends displacement jump instruction destination basic block represented difference labels group relocatable code emitted kerninstd request download code chunk ordering contiguous area kernel memory sparc solaris kernel code low bits address space ensure pc-relative sparc call instruction sufficient displacement reach intended destination time kerninstd resolves code relocatable elements linker contiguous group layout consequences implicitly performs procedure placement ensures displacement provided classes sparc branch instructions transfer control chunks group group code downloaded kernel space code replacement section redirects calls root function group optimized version function pettis hansen method emitting branches hot cold basic blocks differs kerninst system branch redirected nearby stub performs long jump stubs infrequently executed transfers hot cold blocks seldom occur increase total hot code size branch hot cold block function stub end function hot blocks layout ensures hot blocks multiple functions contiguously laid minimal i-cache footprint stubs effectively small cold basic blocks reside hot chunks installation kerninst analyzes group functions manner kernel functions detected kerninst starts first-class treatment runtime-generated code functions instrumented speedup achieved optimization measured re-optimized requirement discussed section kerninst track optimized functions behavior basic blocks interleaved procedure splitting consequent interleaving functions optimized group required improving kerninst control flow graph parsing algorithm function disjoint chunks chunk bounds provided branches properly recognized intra-procedural inter-procedural basic blocks fall function identified page code replacement code replacement primary mechanism enables run-time kernel optimization evolving kernels code kernel function dynamically replaced masse alternate implementation section describes design 
implementation code replacement installing code replacement implemented top kerninst code splicing primitive entry point original function spliced jump version function shown figure code replacement takes sif original function resides kernel nucleus solaris nucleus range covered single i-tlb entry single branch instruction jump original function version function springboard achieve sufficient displacement springboard required required springboard resides nucleus framework incurs overhead time function called overhead avoided patching function call sites directly call version function optimization applied statically identifiable call sites indirect calls function pointer replacing call site takes resides nucleus give largescale replacing function kmem alloc including patching call sites takes kernelwide function called average times standard deviation cost installing code replacement restoring higher expect dev kerninst performs expensive undoable write call site undoable write automatically changed back original dev kerninst front-end gui kerninstd exit unexpectedly dev kerninst maintains log undo leftover kernel instrumentation first-class treatment newly installed functions kerninstd analyzes replacement version function run-time creating control flow graph calculating live register analysis updating call graph manner kernel code recognized kerninstd startup uniformity important tools built top kerninstd treat replacement function first-class kperfmon informed replacement function updates code resource display user measure replacement function undoing dynamic code replacement undone restoring patched call sites un-instrumenting jump entry original function entry version ordering ensures atomicity code replacement undoing completed replacement function invoked due jump original version basic code replacement call sites patched undone original function lies nucleus springboard reach replacement function removed resided nucleus patched call site restored resided nucleus virtualization instrumentation measures interval event counts starting stopping accumulation entry exit chosen function measures wall time events specifically events occur thread context switched midfigure basic code replacement entry point instruction original function replaced unconditional non-delayed branch version function springboard scratch area kernel space kerninst takes enable long jumps needed original function springboard needed version function long-jump version function instructions unconditional branch page dle function included inclusion desirable blocking metrics latency undesirable virtual time metrics subsets cpu execution time virtual time metric i-cache stall time metric study section describes extra instrumentation kernel context switch routines enables creation virtual time metric wall time metric context switch instrumentation code virtualization splices code kernel context switch routines switch-out stop active virtual accumulator started thread presently switched accumulator data structure stores accumulated total fields indicating accumulation presently active snapshot underlying event counter time accumulator started switch-in re-start virtual accumulator stopped recent switch-out thread presently switched invariant aids implementation switch-out instrumentation code presently active virtualized accumulator started exclusively running thread demonstrate assume thread started accumulator switched assuming uniprocessor thread runs time switched virtualization instrumentation stopped accumulators started contradicting assumption presently accumulating events started accumulation thread started accumulation virtualization code executed context switch-out straightforward stop presently active virtual accumulator context switch-in instrumentation code maintain hash table indexed thread entries pointers virtual accumulators stopped recent switch-out thread number threads presently switched started stopped accumulator hash table entries pointers accumulator accumulator actively running thread per-switched-out-thread information accumulators presently turned due virtualization hybrid approach compares favorably per-thread accumulators extra complexity space time overhead context switch-out instrumentation code allocates vector free list vector gather pointers accumulators stopped virtualization loops accumulators invoking metric-specific routine depends metric underlying event counter stops accumulator started vector added hash table indexed thread synchronization required context switch routines invoked interrupt priority level set prevent scheduling context switch-out instrumentation code bytes executes timings instrumentation code paper obtained kerninst instrument instrumentation code measure latency context switch-in instrumentation code comparatively simple newly running thread index hash table obtaining vector pointers accumulators restarted completed vector returned free pool hash table entry thread removed context switch-in instrumentation code bytes executes context switch instrumentation points virtualization requires identifying kernel context switch-out switch-in sites kerninst virtualize interrupts run kernel threads block highest-priority interrupts ecc error detection concern high-level interrupts preempt kernel scheduler virtualization instrumentation code insert virtualization instrumentation code high-priority interrupt handlers multiprocessor issues key assumption made context switch instrumentation code single thread accumulate events time hold multiprocessor invariant restored per-processor accumulators additionally per-processor accumulators ensure processors actively compete write access structure causing undue cache coherence overhead page virtualized accumulator started cpu stopped cpu presence migration solaris migration occurs presently switched-out thread context switch-out virtualization code running original cpu stopped accumulator context switch-in virtualization code re-starts accumulator cpu stopping accumulator cpu started important on-chip registers serving event counter elapsed cycles cache misses generally sync processors invariant migration prevented middle start stop primitive accomplish raising processor interrupt priority level primitive short duration solution prevents race condition thread start cpu version accumulator migrated cpu per-cpu versions single logical accumulator virtualization framework hybrid accumulator cpu represent actively running thread hash table information accumulators stopped virtualization code presently switched-out thread calculating edge execution counts block execution counts section describe simple effective algorithm deriving control flow graph edge execution counts basic block execution counts edge execution counts required effective block positioning kerninst presently implement edge splicing mechanism direct measurement edge counts fortunately found solaris control flow graph edge counts derived basic block counts result implies simple instrumentation sampling measures block counts place technically difficult edge count measurements results section tend contradict widely-held belief block counts derived edge counts converse hold limitation true general case arbitrarily structured control flow graphs technique effective practice algorithm special interest sampling-based profilers dcpi morph gprof vtune directly measure block execution counts edge execution counts algorithm assume function control flow graph execution counts function basic blocks algorithm calculates execution counts edges function precisely approximated obtain edge counts simple formulas sum basic block predecessor edge counts equals block count equals sum block successor edge counts block count predecessor successor edge counts unknown edge count precisely calculated block count minus sum predecessor successor edge counts algorithm repeats convergence edge counts precisely derived block counts calculated phase algorithm approximates remaining unknown edge execution counts formulas bound count edge count larger predecessor block execution count minus sum block precisely calculated successor edge counts similarly edge execution count larger successor block execution count minus sum block precisely calculated predecessor edge counts minimum values imprecise approximation edge execution count alternative choices evenly dividing maximum allowable 
unknown edges edge counts precisely derived approximation seldom needed making issue unimportant figure control flow graph pettis hansen paper demonstrate edge measurements block measurements edge counts precisely derived block counts block predecessor edge successor edge execution counts equal count edge successor count unknown count count minus count successor edge edge remaining unknown predecessor edge count equals block count minus count page predecessor edge finally edge successor unknown count count equals block count minus successor edge results analysis applying algorithm solaris kernel reveals control flow graph edge counts derived basic block counts kernel functions precisely calculate counts control flow graph edges exceptions collecting block counts sufficient derive edge counts conclusion sampling-based profilers directly measure edge counts edge counting directly measured deriving edge counts block counts preferable expensive specifically basic block counting instrumentation block spot sufficient scratch registers execute instrumentation code register spilling live register analysis machine code solaris kernel shows average integer registers live values instrumentation code machine code instruction judging purely number sites instrumentation individual costs edge instrumentation cheaper block instrumentation leverage previous work minimizing number basic block counters work probert provably minimum set basic block instrumentation sites source code transformation subset programs called well-delimited control statement matched delimiter end-if end-while posit set functions edge count calculated isomorphic set well-delimited functions enabling probert work leveraged reducing number basic block instrumentation sites experimental results concrete demonstration efficacy run-time kernel code positioning section presents initial results optimizing i-cache performance solaris kernel running web client benchmark study performance tcp rput data callees major tcp function processes incoming network data tcp rput data called thousands times benchmark poor i-cache performance tcp rput data execution time idled due i-cache misses prototype implementation code positioning reduced percentage optimization presently limited inability include group routines called function pointers code positioning reduces time invocation tcp rput data benchmark decrease execution time figure edge counts derived block counts unknown count edge calculated unknown successor count block unknown predecessor count block repeated application rule convergence calculate edge counts augmented version figure block count block count block count block count page benchmark gnu wget tool fetch files totaling data largely comprised postscript compressed postscript pdf files benchmark contained ten simultaneous connections running wget program sec lan client machine mhz ultrasparc-iii processor benchmark spends time tcp code read-side tcp connection stressed tcp rput data processes data received ethernet connection recognized packet chose perform code positioning tcp rput data size bytes code basic blocks suggests room i-cache improvement function performance tcp rput data code positioning determine tcp rput data benefit code positioning measured amount inclusive virtual execution time spends i-cache misses result surprisingly high invocation tcp rput data takes idled waiting i-cache misses words tcp rput data spends execution time i-cache miss processing concentrated optimizing invocation cost tcp rput data achieve improvement scales execution frequency execution frequency function processor network speed network load benchmark measured basic block execution counts tcp rput data descendants estimate hot set basic blocks benchmark run measured counts approximation code reached indirect call measured measurement includes block executions regard group root function call stack approximate block counts estimate i-cache layout subset blocks hot based kerninst default interpretation hot blocks executed frequently tcp rput data called estimate shown figure tcp rput data called frequently important function exhibits good i-cache performance conclusions i-cache performance drawn figure greater -way set associativity i-cache helped hot subset tcp rput data descendants execute i-cache conflict misses i-cache fully associative small effectively run benchmark bottom figure estimates i-cache blocks needed hold hot basic blocks tcp rput data descendants half total i-cache size code ethernet processing code invokes tcp rput data executed thousands times total set hot basic blocks exceeds capacity i-cache total cache blocks i-cache size figure i-cache layout hot blocks tcp rput data descendants pre-optimization cell represents -byte i-cache block number cell hot basic blocks distinct i-cache tags fall block figure shows cache blocks totalling ultrasparc i-cache -way set associative addresses map block figure conflicting highlighted cells addresses mapping i-cache block indicating conflict page performance tcp rput data code positioning performed code positioning improve inclusive i-cache performance tcp rput data figure presents i-cache layout optimized code estimated data figure i-cache conflicts group hot basic blocks fit comfortably confines direct-mapped i-cache figure shows functions optimized group relative sizes hot cold chunks fourth column figure shows chains needed cover hot chunk ideal indicating likelihood hot code covered single path contiguously laid memory code positioning reduced benchmark end-to-end run-time seconds seconds explain speedup kperfmon measure performance improvement invocation tcp rput data code positioning reduced i-cache stall time invocation tcp rput data branch mispredict stall time virtual execution time addition ipc instructions cycle increased preand post-optimization numbers shown figure analysis code positioning limitations code positioning performs indirect function calls hot basic blocks group section analyzes limitations indirect calls optimization tcp rput data system streams code general presents measurements frequency indirect function calls kernel quantify present inability optimize indirect function calls constrains code positioning system streams code indirect calls limit presently optimized single streams module tcp ethernet measured hot code tcp rput data descendants frequently-executed indirect function calls calls made putnext stub routine forwards data upstream queue indirectly calling module stream put procedure call made tcp completed data processing verifying check sums stripping tcp header data block ready forward processed data upstream callees reached hot indirect function calls optimized miss opportunity include remaining upstream processing code group end system stream tcp data processing function root optimized group missed opportunity include downstream data processing code performed ethernet protocol processing quantify inability optimize indirect calls limits code positioning examined kernel-wide frequency indirect calls average kernel function makes direct calls standard deviation indirect calls standard deviation indirect calls exist unix genunix modules utility routines invoked kernel large function group indirect function call unix module putnext function performs indirect call pulled group total cache blocks i-cache size figure i-cache layout optimized tcp rput data group i-cache conflicts hot basic blocks compare figure page future work candidates improving runtime kernel code positioning include handling function pointers automated selection group root function block ordering procedure boundaries 
inline expansions calls function pointers included optimized group recognized call graph traversal additional kernel instrumentation indirect call site call graph updated heretofore unseen callee encountered allowing indirect callees included optimized group candidate future work removal user involvement initial step choosing group root function allowing steps performed automatically paradyn performance consultant shown bottlenecks automatically located non-threaded user programs call graph traversal emitting hot chunks cold chunks relative placement functions group arbitrary future work basic block positioning performed procedure call bounds allowing chains basic blocks functions change execute longer sequences straight-lined code common case fortunately change necessarily blur bounds group functions make impossible parse control flow graphs major complexity functions code spread chunks jump table data hot basic blocks cold basic blocks presently supported note change increase group total code size function jump table data hot chunk size bytes number chains hot chunk cold chunk size bytes group tcp tcp rput data group unix mutex enter group unix putnext group unix lock set spl spin group genunix canputnext group genunix strwakeq group genunix isuioq group timer group cksum group tcp tcp ack group genunix pollwakeup group genunix timeout group genunix div group unix ocsum group genunix allocb group unix mutex tryenter group genunix signal group genunix pollnotify group genunix timeout common group genunix kmem cache alloc group unix disp lock enter group unix disp lock exit totals figure size optimized functions tcp rput data group group version tcp rput data hot subset statically identifiable call graph descendants code positioning applied figure shows effects procedure splitting hot chunks moved cold chunks fourth column number chains hot chunk chain covering entire hot chunk ideal indicating likelihood single hot path laid contiguously covers function hot blocks measurement original optimized change total virtual execution time invocation i-cache stall time invocation branch mispredict stall time invocation ipc instructions cycle figure measured performance improvements tcp rput data code positioning performance tcp rput data improved due fewer i-cache stalls fewer branch mispredict stalls page future optimization hot path expansion increase length straight-lined code duplicating hot basic blocks effectively inlining hot portions callees places optimized paths group optimization performed dynamo user-level run-time optimization system found path expansion generally beneficial backfires occasionally due code explosion dynamo runs parisc processor luxury unusually large dedicated i-cache processors tolerant code explosion ultrasparc processors i-cache non-root group functions invoked root function call stack invariants hold enable optimizations variable constant allowing constant propagation dead code elimination optimizations include inlining specialization super-blocks optimizations presently unimplemented optimizer demonstrating general-purpose back-end machine code optimizer related work measurement measure i-cache virtual stall time choose group root function measure effect code positioning alternative instrumentation sampling dcpi gprof morph vtune sampling measures virtual time events periodically reading register assigning time event cache misses sample location attractive simplicity low constant perturbation sampling limitations hard accurately assign events instructions dcpi samples periodic traps modern processor imprecise variable-delayed interrupts difficult instruction trapped solution presented profileme requires hardware support sampling measure virtual time events easily measure wall time events latency wall time measurements sampling require call stack back-trace blocked threads sample accuracy dictates frequent sampling making back-tracing prohibitive sampling easily measure inclusive metrics required identify routine exhibiting poor i-cache performance inclusive measurements sampling requires assigning time sampled routines presently call stack requiring call stack back-trace sample gprof reports inclusive time making dubious assumption call function takes amount time expense back-traces inaccurate due tail-call optimizations caller removes stack frame call stack entry transferring control callee optimization common occurring times solaris kernel code i-cache bottleneck located measurement finds hot basic blocks procedure splitting edge counts block positioning perturbation introduced block counting instrumentation temporary reducing overhead enable frequent optimizations lower overhead combination basic block sampling section algorithm deriving edge counts approach net prediction maintains instrumentation reduces cost estimating path execution counts net instrumentation incremental initially counting path head executions time extra instrumentation collects full path counts paths head execution counts hot net performed sampling augmented block counts-to-edge counts algorithm means derive path counts edge counts note kerninst optimization orthogonal means measurement logic analyzing machine code re-ordering installing running kernel orthogonal ordering obtained run-time optimizations dynamo user-level run-time optimization system hp-ux programs dynamo net prediction interpretation collect hot instruction sequences software cache code software cache executes full speed ameliorating initial expense interpretation similar spirit kerninst evolving framework dynamo exhibits differences dynamo runs user-level code difficult port dynamo kernel interpreting kernel technically difficult overhead kernel interpretation unacceptable entire system affected kernel slowdown issue relates code expansion dynamo expands entire hot paths basic block multiple times expansion result code explosion number executed paths high hp-pa dynamo runs handle code explosion unusually large i-cache path expansion overwhelm smaller i-caches ultrasparc-ii page synthetix performs specialization modified commodity kernel differences synthetix kerninst synthetix runs modified version operating system synthetix requires specialized code templates pre-compiled kernel synthetix requires pre-existing level indirection call pointer change implementations function incurs slight performance penalty specialized code installed limits number points specialized evolving framework proposed vino extensible kernel code built kernel detects high resource utilization triggering off-line heuristic suggest algorithmic change examined simulating execution inputs previously gathered traces logs deemed superior version function installed note key assumption custom kernel required steps incorrect kerninst perform commodity kernel steps installing measurement trace-gathering code run-time simulating situ proposed algorithm dynamically installing algorithm place existing conclusion introduced notion evolving kernels change code response runtime circumstance proof concept implemented kind evolving kernel algorithm run-time version pettis hansen code positioning optimizations implementation on-line kernel version optimization operates off-the-shelf version commercial operating system solaris demonstrating rewrite run-time code kernel written expecting optimized adaptive algorithms tunable variables built kernel source code adaptive mutex locks solaris implementation on-line evolving kernel algorithm implementation evidence unmodified commodity operating system kernel made evolving limit evolving systems research custom kernels anderson berc dean ghemawat henzinger leung sites vandervoorde waldspurger weihl continuous profiling cycles acm symposium operating system principles sosp saint-malo france october bala duesterwald banerjia dynamo transparent dynamic optimization system acm sigplan conference programming language design implementation pldi vancouver june ball larus optimally profiling tracing programs acm toplas july ball mataga sagiv edge profiling 
versus path profiling showdown annual acm symposium principles programming languages popl san diego january cain miller wylie callgraph-based search strategy automated performance diagnosis european conference parallel computing euro-par munich germany august dean hicks waldspurger weihl chrysos profileme hardware support instruction-level profiling out-of-order processors annual ieee acm international symposium microarchitecture microresearch park triangle december diniz rinard dynamic feedback effective technique adaptive computing acm sigplan conference programming language design implementation pldi las vegas june duesterwald bala software profiling hot path prediction international conference architectural support programming languages operating systems asplos-ix cambridge november free software foundation gnu wget non-interactive downloading utility http gnu software wget wget html graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june hollingsworth miller dynamic control performance monitoring large scale parallel systems seventh acm international conference supercomputing ics tokyo july hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference shpcc knoxville hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques pact san francisco november intel corporation vtune performance analyzer http developer intel vtune analyzer index htm page larus schnarr eel machine-independent executable editing acm sigplan conference programming language design implementation pldi jolla june mosberger peterson bridges malley analysis techniques improve protocol processing latency acm applications technologies architectures protocols computer communication sigcomm stanford august pettis hansen profile guided code positioning acm sigplan conference programming language design implementation pldi white plains june probert optimal insertion software probes well-delimited programs ieee transactions software engineering january audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating system principles sosp copper mountain december seltzer small self-monitoring self-adapting operating systems workshop hot topics operating systems hotos-vi rio rico march sun microsystems ultrasparc-iii user manual microelectronics division sun microelectronics manuals tamches miller fine-grained dynamic instrumentation commodity operating system kernels usenix symposium operating systems design implementation osdi orleans february miller naim dynamic instrumentation threaded applications sigplan symposium principles practice parallel programming ppopp atlanta zhang wang gloy chen smith system support automatic profiling optimization acm symposium operating system principles sosp saint-malo france october page 
improving online performance diagnosis historical performance data karen karavanic barton miller karavan bart wisc computer sciences department wisconsin madison abstract accurate performance diagnosis parallel distributed programs difficult time-consuming task describe technique historical performance data gathered previous executions application increase effectiveness automated performance diagnosis incorporate types historical knowledge application performance existing profiling tool paradyn parallel performance tool gather performance structural data previous executions program extract knowledge diagnosis collection data form search directives input directives enhanced version paradyn conducts directed online diagnosis compared existing approaches incorporating historical data shortens time required identify bottlenecks decreases amount unhelpful instrumentation improves usefulness information obtained diagnostic session introduction accurate performance diagnosis parallel distributed programs difficult time-consuming task recent research examines approaches automating simplifying process diagnosing single program run paper describes historical performance data data gathered previous executions application increase effectiveness automated performance diagnosis test ideas incorporate types historical knowledge application performance existing diagnostic research tool paradyn parallel performance tool paradyn performance consultant performs online automated bottleneck detection single execution parallel serial code general search strategy performance consultant works studying unfamiliar applications systematic investigation application depend assumptions application runtime environment yields information wide range programs practice noticed time sat application miss data interesting events possibly stop completion due inherent instrumentation cost limits natural tension generally single button approach performance diagnosis application-specific knowledge-dependent approach goal replace performance consultant single button model augment search strategy cases prior knowledge program studied goals research shorten time required identify important bottlenecks evaluate strategy measuring comparing total time find botthis work supported part department energy grant de-fg nasa gsrp grant ngtnsf grants cdaand eiaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon karavanic miller improving online performance diagnosis historical performance data tlenecks historical information decrease amount unhelpful instrumentation practical limit total amount instrumentation place time minimize inaccuracy results due perturbation decreasing unhelpful instrumentation cases search continue reach limit halt evaluate strategy measuring total amount instrumentation time find bottlenecks determine precise location significant bottlenecks results performance tuning obtained testing identifies small number welldefined potential problem areas practical limits total amount instrumentation result important bottlenecks fully explored noise bottlenecks tested measure identifying set important bottlenecks execution evaluating effect historical information finding bottlenecks set save performance structural data successive executions application extract knowledge diagnosis collection data form search directives types directives prunes performance consultant ignore bottleneck tests completely priorities provide ordering tests thresholds provide level test application performance perform online performance diagnosis enhanced version paradyn directives guide search evaluated technique testing mpi application ibm reductions time needed locate performance bottlenecks paradyn performance consultant testbed studies enhanced version paradyn paradyn application profiler dynamic instrumentation insert delete measurement instrumentation program runs approach results small amount data contrast tracing methods result possibly unusably large data files paradyn performance consultant capitalizes dynamic instrumentation automate bottleneck detection program execution starts searching bottlenecks issuing instrumentation requests collect data set pre-defined performance hypotheses program hypothesis based continuously measured computed paradyn metrics fixed threshold starts search measuring total time spent computation synchronization waiting compares values predefined thresholds instances measured hypothesis exceeds threshold defined bottlenecks full collection hypotheses organized tree hypotheses lower tree identify specific problems higher represent program collection discrete program resources resources include program code modules functions application processes machine nodes synchronization points data structures data files group resources distinct view application organize program resources trees called resource hierarchies root node resource hierarchy labeled hierarchy move root node level hierarchy represents finer-grained description program resource formed concatenating labels unique path resource hierarchy root node representing resource resource represents function verifya shaded figure code testutil verifya performance measurement parts program interested measuring cpu time total entire execution total single function focus constrains view program selected part selecting root node resource hierarchy represents unconstrained view program selecting node narrows view include leaf nodes descendents selected node shaded nodes figure represent constraint function verifya process tester running cpu labeled focus code testutil verifya machine process tester node search represents instrumentation data collection hypothesis focus pair node tests true meaning bottleneck found performance consultant determine specific karavanic miller improving online performance diagnosis historical performance data figure representing program tester resource hierarchies code machine process figure performance consultant search progress items toplevelhypothesis added result refining hypothesis nodes excessivesyncwaitingtime excessiveioblockingtime tested false node color light grey figure node cpubound dark grey tested true expanded refinement nodes bubba channel anneal outchan graph tested false nodes goat partition tested true refined vect addel verifyb verifya printstatus mainmain testutil vect vect findel vect print tester tester tester process cpu cpu cpu cpu tester code machine karavanic miller improving online performance diagnosis historical performance data information bottleneck considers types expansion specific hypothesis specific focus child focus defined focus obtained moving single edge resource hierarchies determining children focus method referred refinement pair tests false testing stops node refined refines true nodes specific focus hypothesis focus pair represented node directed acyclic graph called search history graph shg root node shg represents pair toplevelhypothesis wholeprogram child nodes represent refinements chosen paradyn displays shg list box form show figure depending number resources needed represent application number hypothesis focus pairs explored large prevent data requests overwhelming system capacity perturbing application point reliable results determined cost instrumentation enabled continually monitored search expansion generates instrumentation requests halted cost reaches critical threshold restarted instrumentation deletion initiated nodes test false cost return acceptable level harvesting historical data investigated mechanisms including historical data diagnostic tool pruning directives tool ignore resources priorities tool aspects application runtime environment thresholds tool specific values measure application actual performance directives section order search directives extracted run diagnosis session perform mapping resource names describe mapping section types search directives pruning directives instruct diagnostic tool ignore subtree resource hierarchy evaluation specific hypothesis mechanism conveying information insignificant parts application total number hypothesis focus pairs tested performance consultant large total number resources large practice frequently true top-down approach effect excluding part potentially huge search space false nodes refined prunes shrink size search space avoid overhead instrumenting small infrequently executed functions pruning search pruning directives customize search strategy environment static process model mpi version leads one-to-one correspondence 
process machine node investigate relative performance process machine prune machine hierarchy pruning dictate search strategy employed examine reduces size total search space side effect pruning incorrectly eliminating important reason investigated methods robustness investigated pruning based historical data functions short execution time redundant hierarchies machine hierarchy processes machines map oneto-one sections hierarchies investigated pruning based general rules pruning syncobject hierarchy synchronizationrelated hypotheses priorities assign relative level importance focus-hypothesis pairs resources responsible behaviors interest studied allowing data collected longer time interval unlike prunes priorities exclude foci consideration instruct diagnostic tool hypothesis-focus pairs hypothesis-focus pair priority high tested true previous execution low tested false previous executions medium high priority pairs instrumented search start persistent testing continues entire program run true false conclusion reached starting high priority pairs immediately waiting default top search order refine results control search order comparison setting priority medium low ensures ordering node siblings thresholds values determine hypothesis true false focus standard version paradyn threshold karavanic miller improving online performance diagnosis historical performance data hypothesis set user goal number bottlenecks reported practically range reporting large number bottlenecks yields inadequate guidance tuning effort drives cost instrumentation reporting bottlenecks failing refine bottlenecks detailed level information obtained simple visualization investigated automatically setting thresholds based historical data mapping resource names executions resources change run program -node application run nodes run nodes run similarly process run relate performance results previous run current run establish equivalency map differently named resources issue mapping code module function resources section present results multiple implementations poisson function decomposition program version names main function kernel function run performance consultant search history graph program resource hierarchies results generate search directives subsequent runs added functionality performance consultant map focus names found directives names valid current environment mapping link resources executions names paradyn treats equivalent motivate mapping common case executing differently named nodes machine runs mapping implemented set directives form map resourcename resourcename user input file starting paradyn apply mappings list extracted search directives read directives performance consultant increased efficiency apply pruning directives resulting list search directives read performance consultant figure shows combined resource hierarchies versions mpi application versions resource tagged execution identifier resource found version version mappings map code exchng code nbexchng map code exchng exchng code nbexchng nbexchng map code oned code onednb map code sweep code nbsweep map code sweep sweep code nbsweep nbsweep figure mappings versions left show execution map versions poisson decomposition application code hierarchy expanded resource tagged execution identifier resources unique version labeled unique version labeled common labeled map unique nodes refer code modified versions including change mapping directives shown karavanic miller improving online performance diagnosis historical performance data resources unique execution candidates mapping module function main named oned version onednb version map resources code oned code onednb search directives extracted runs diagnosing runs full set mappings shown resource hierarchies results performed set experiments evaluate prior knowledge form pruning prioritization threshold directives section reports effectiveness adding pruning priority directives performance consultant section explores advantages applicationspecific thresholds formulated historical data final section studies pruning prioritization generated thresholds versions application simulate common practice performance tuning successive versions implementation pruning priority directives ran enhanced version performance consultant mpi application solves poisson problem running nodes ibm ran application modifications saved resource hierarchies search history graph performance results run forms base case allowed run completion identify complete set bottlenecks tested variations directed searching generated pruning directives priorities combined version prunes priorities identical search thresholds runs experiment recorded time bottleneck reported tool times recorded timestamps assigned paradyn data reflect application execution time paradyn performs dynamic instrumentation starting timestamp determined instant instrumentation request time required insert instrumentation application code conclusion performance hypothesis determined set time interval data received running application results reported table experiment investigated performance advantages obtained pruning directives data previous runs generate list pruning directives ran paradyn providing list pruning directives input modified performance consultant combined search pruning directives result reduction time locate true bottlenecks ran tests evaluate effects types pruning general prunes pruning syncobject hierarchy synchronization-related hypotheses specific application environment historic prunes pruning specific function low execution time formulated based data gathered previous executions application substantial improvement type pruning combination yields results adding historic prunes resulted execution times shorter general prunes experiment studied effects ordering search bottlenecks priorities historical data generate priorities hypothesis focus pair outlined section expected compared historical data reduce time required find necks found directives prunes general prunes historic prunes priorities priorities prunes table time seconds find true bottlenecks search directives karavanic miller improving online performance diagnosis historical performance data major true bottlenecks change amount instrumentation obtained reduction time locate true bottlenecks improvement modest reduction obtained pruning directives reordering search introduce possibility missing bottlenecks important advantage method final experiment tested combination prunes priorities goal improve time reduction obtained priorities avoid possibility pruning important tests search included pruning redundant irrelevant hierarchies include prunes previously false hypothesis focus pairs combined approach result retesting false nodes miss behaviors due pruning obtained reduction finding true bottlenecks reduction seconds pruning priorities thresholds determined historical data studied behavior performance consultant varying threshold values decomposition application section run nodes ibm sample application strongly dominated synchronization waiting time accounts approximately total execution time total execution time processors spent waiting function exchng function main wait split message tags individual processes dominated wait time significant waiting occurred processes investigated quality diagnosis checking number areas reported bottlenecks individually function main combination message tag function main full results shown table threshold setting greater bottlenecks previously determined significant reported threshold set tool reported close full set bottlenecks default paradyn setting contrast resulted bottlenecks missed column shows instrumentation diagnose program run setting threshold shaded yields good results noticeably instrumentation setting final column shows efficiency metric determined dividing number bottlenecks found number hypothesis pairs tested efficiency decreases thresholds indication lowering threshold increases amount instrumentation improve result earlier studies found similar results ocean circulation modeling code pvm running sun sparcstations found optimal synchronization threshold starting point yielded incomplete diagnosis efficiency decreased number metric-focus pairs instrumented synchronization bottleneck threshold setting total execution time number bottlenecks reported performance consultant total number hypothesis focus pairs tested efficiency bottlenecks 
page permission advantage erwise mission fee tool mon protocol tdp make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial copies bear notice full citation page copy othabstract run-time tools crucial program development desktop computer environments granted availability tools operations debugging profiling tracing checkpointing visualization programs move distributed grid environments difficult find tools difficulty caused complex interactions application program operating system layers job scheduling process management software result run-time tool individually ported run job management system tools environments problem effort hoped-for neffort variations underlying operating systems make problem worse consequence situation paucity tools distributed grid computing environments response problem analyzed variety job scheduling environments run-time tools understand interactions analysis isolated essential interactions runtime tool job scheduler resource manager application program proposing standard interface called tool mon protocol tdp codifies interactions communication functions implemented pilot tdp library experimented parador prototype paradyn parallel performance tools profiling jobs running condor batch-scheduling environment introduction run-time tools crucial program development desktop computer environments granted availability tools operations debugging profiling tracing checkpointing visualization programs move distributed grid environments difficult find tools distributed computing well-established gaining popularity recent years availability compute clusters shared-memory multiprocessors grid infrastructure general systems require software schedule access stage resources needed run job monitor jobs execution retrieve results produced job software commonly referred resource manager local clusters form batch queuing environments resource management plays crucial role cluster environment responsibility carrying steps guarantee execution applications seamless secure supporting mechanisms resource discovery status monitoring selection allocation job control systems condor load leveler nqe lsf popular commercial research batch queuing environments schedule jobs local area cluster recently attention focused grid computing systems globus legion provide access heterogeneous collections widely distributed dynamically configured resources presence grid system additional services authentication data staging monitoring scheduling interfaces crucial running programs complex environment offer additional layers interfaces abstractions negotiated deploy run-time tool environment run-time tools distributed environment difficult complex interactions application program operating system layers job scheduling process management software result run-time tool individually ported run job management system tools environments problem effort hoped-for effort isolated point-solution successes totalview running mpich effort needed generally solve problem prohibitive variations underlying operating systems make problem worse consequence situation paucity tools distributed grid computing environments barton miller ana cort miquel senar miron livny computer sciences department wisconsin madison usa bart miron wisc departament inform tica universitat aut noma barcelona bellaterra barcelona spain miquelangel senar ana cortes uab republish post servers redistribute lists requires prior specific pernovember phoenix arizona usa copyright acm page address problem analyzed variety job scheduling environments run-time tools understand interactions analysis isolated essential interactions run-time tool job scheduler resource manager application program figure illustrates main components proposing standard interface called tool mon protocol tdp codifies interactions communication functions crucial interfaces needed runtime tools monitor control programs goal identify interfaces process creation fundamental operation launching processes operation conflict tool debugger profiler expects launch process sophisticated run-time tools ability attach running process handle case tool attach process starts execution clean division work creates start application process attaches process performs initial processing starts application provide information find operate application program tool creation responsible launching launched application created launched case provide approand operate application process control normal operation pause resume application process change process state viewed sign faulty behavior coordinate operations status monitoring stated interested state application process receive information agreement entity responsible information circumstances operating systems versions unix distinctly behavior area mechanism information communicated entity standard input output management tool launches application program intercepts applications standard input output information appears location front-end control standard input output conflict similar operations operation properly belongs coordinated tool daemon tool front-end communication common front-end back-end configuration requires communication channel typically tcp connection established front-end back-end processes case private networks firewalls nat communication execution nodes require proxy provided purposes estabfigure remote execution resource manager run-time tool resource manager run-time tool application process front-end front-end firewall remote host priate information attach page lish proxy tunnel communication tool daemon configuration data files configuration files transferred execution nodes generate output files traces summary data trace files processed off-line transferred execution nodes application completes auxiliary services entities addition required proper execution distributed environment software multicast reduction networks crucial scalable tool aware launch kind non-application entity fault detection recovery entities launched fail execution detect failures respond communicate occurrence entities clear precise fault model required note modeling detecting faults ongoing work scope paper things explicitly part tdp general tdp solve problem distributed environment solved general usage desktop environment coordinating interactions multiple run-time tools tdp designed multiple tools launched application interactions tools coordinated tools excellent experimental work area feature found tools common address problems presented resource managers monitoring tools aware existence prepared execute conditions resource managers monitoring tools development on-going grid projects support above-mentioned functionality work deals analysis design basic services overcome drawbacks limitations existing middle ware services tdp effort address problem tool interoperability distributed grid environments interoperability refer ability tools resource managers co-operate controlling user applications common services communication mechanisms general deployment run-time tools distributed environments maximum transenhancement monitoring tools resource management systems make interoperable consequence project run-time tools easily deployed distributed infrastructures easing task application program development words make distributed environments significantly easier application developers tool builders concentrate key technologies repetitive porting efforts tdp interfaces tool daemon protocol interfaces creation application processes subsequent monitoring control processes establishing connections tool daemon components means exchanging configuration data start discussion data exchange facility called attribute space operations depend attribute space cases exchange information examples cases include telling process providing network address host port number front-end providing network address standard input output designing special protocol messages type information exchanged organized communication general purpose attribute-value space mechanism inspired mpi process daemon mpd argonne considered highly simplified version linda tuple space note x-window server similar mechanism clients interface exhibit desirable characteristics generality portability extensibility kind format information exchanged restricted combination resource manager monitoring tool based flexible extensible mechanisms enable pair resource managers monitoring tools communicate effectively host application process tool daemon runs local instance attribute space server lass central attribute space server cass 
process host running tool front-end process tdp library access attribute space lass cass access lass nodes lass started cass started front-end process figure shows structure parency portability requires extension figure addition attribute servers page attributes values inserted removed attributed space simple put interface mechanism providing asynchronous notifications details interface provided section application process creation run-time tools variety schemes creating application processes schemes include create application process start running scheme typically simplest tools perform external initialization application program needed initialization code compiled linked application scheme requires mechanism support tools vampir pcl technique create application initialize start running scheme tool perform initialization time creating application started execution unix terminology fork exec complete execution stopped question initialization code application run intuition program stopped starting execute main function tools gdb totalview paradyn technique attach running application process attaching important mechanism operating already-running programs servers programs complex start-up sequences attaching requires steps obtain control application proc ptrace pause application perform tool initialization reading symbol table parsing executable continuing application tools gdb totalview paradyn technique resource manager environment case requires special modifications tools cases require change cases longer creating application process responsibility belongs result tdp library steps similar sequence steps case coordinated tdp library creates starts creates start application process sends information identifies application process attaches application case performs initialization tells start application communication attribute space operations provided tdp note started operating application process step skipped case tdp works similar minor differences difference created application process step requires attaching pausing application tools ability attach technique vampir trace tool requires tracing started application starts execution goal tdp standardize interactions encapsulate library details hidden small amount figure remote execution local lass global gass attribute space servers added resource manager run-time tool application process front-end central attr space remote host local attr space lass cass front-end firewall modification demonstrated experience page condor paradyn reported section reorganized tdp interfaces result operate directly environment supports tdp run tool supports tdp application process monitoring control tdp responsibility controlling application process monitoring status belongs process management operations localized encapsulated encapsulation good design practical necessity control operations single point responsibility eliminates confusing race conditions processes attempt conflicting control operations process monitoring avoid confusing conflicting semantics operating systems linux parent process recipient child process termination code choice process depend process attached control child application process unusual case return code processes tdp communication status control information exchanged attribute space operations perform process management operation contacts notify change process status places attribute space optionally asynchronous notification hear immediately change tool communication front-end communicate communication typically tcp sockets application running private network firewall gateway establish connection private network similar problem occur standard input application program connected desktop machine user site private network process managers condor globus provide proxy mechanisms forwarding connections private network tdp standard interface mechanisms general tdp provide host port number pair contact front-end application program connect standard input routing addressing restrictions host port number actual address remote process private networks block connections host port number proxy responsible establishing connection forwarding inbound outbound messages tdp require proxy facilities permissions leverages existing present standard interface facility tdp services tdp main groups services process management inter-daemon communication interface event notification outline main features open issues related groups developers resource management systems monitoring tools unix windows interfaces create control execution applications fork exec proc interface ptrace examples unix systems createprocess waitforsingleobject examples windows tdp set interfaces neutral guidelines designing api api simple api set small api consistent standard library interfaces implementation provided language library thread safe expected developers linking library serial multi-threaded codes process management tdp supports scenarios operation application process create attach figure illustrates steps daemon tdp services scenario create case figure notified application launched monitored unlike normal process creation tdp create process function paused option launch process stopping beginning unix terms process stopped execution exec call point tdp framework initialized calling tdp init finally launch started regular process tdp create process scenario application running controlled resource manager system time tool attach application process monitor analyze situation notified launch monitor running application process previously created step skipped page basic steps scenario depicted figure user decides application process tdp framework established calling tdp init subsequently launched initialization steps accomplished tdp communication channel established daemons ready exchange information notice state application process completely cases behavior monitoring tool similar application created fork exec successful application process remains stopped point monitoring tool attach chance perform initialization track application execution start attaches running application application process stopped unknown point execution attach create cases completed initialization application restart application tdp continue process operation tdp inter-daemon communication daemon process tdp environment perform basic initialization including establishing connection local attribute space service lass exchanging basic configuration information step daemon process execute tdp init funcbetween rts success tdp init return tdp handle tdp subsequent action tdp framework successfully set communicate lass exchange configuration information basic attribute space primitives tdp tdp put information shared environment space form attribute pairs attribute constrained nullterminated strings attribute consists simply character string names data shared space standard list attribute names set data commonly exchanged daemons understand set tools resource managers extend set situation specific attributes limiting attribute values strings simple brings problem provide attributes multiple structured values arguments passed application pass information kind attributes stored shared environment space simple put operation tdp client handle parsing local attributed space initialized tdp init called deals simultaneously initialize space interacts local attribute space called context context parameter tdp init call crea creates application process attaches existing process figure steps operation application program note create case creation application process occur order tdp create process run tdp init tdp create process paused tdp init tdp attach pid tdp continue process tdp create process run tdp init tdp create process run tdp init tdp attach pid tdp continue process tion establishes tdp communication channel page ate space communication specific accomplished context multiple tools share space context current tool designs feature disengages tdp library attribute space tdp exit function attribute spaced shared resource manager tools common context destroyed element specific context calls tdp exit briefly describe main functions required 
found pair tested table bottlenecks found varying threshold values number bottlenecks reported rounded averaged values calculated repeated tests karavanic miller improving online performance diagnosis historical performance data jumped threshold case differs found mpi application showing advantage application-specific historical performance data historical data code versions studied historical application knowledge application revised time tuning application developer repeats cycle profile-analyze-change performed series performance diagnoses versions mpi application ibm application implements iterative poisson function decomposition versions implementation presented gropp step study results previous runs performance consultant direct subsequent runs versions application version -dimensional version blocking send receive operators version non-blocking -dimensional version version performs -dimensional decomposition version runs code version nodes run nodes changed versions compute fixed number iterations stopping solution reached started running performance consultant version search directives resulting time locate true bottlenecks seconds repeated diagnosis version time including search directives generated previous execution decreased diagnosis time approximately examined version search directives extracted runs version found improvement diagnosis time continued versions time running performance consultant search directives extracted individual prior run mapped pair machine resources search directives generated run meaningfully refer machine resources discovered subsequent run mapped functions modules code versions section full results shown table case adding historical knowledge performance consultant greatly improved ability quickly diagnose performance bottlenecks diagnosis time reduced minimum executions historical knowledge table row represents version application diagnosed column represents source extracted search directives column time reach diagnosis search directives subsequent columns time reach diagnosis search directives sources dedicated machine time low variability run time repeated executions version completing test runs analyzed performance consultant behavior determine affected search directives added examined effects search directives base run diagnose run source search directives application ersion table time seconds find bottlenecks search directives application versions times reported median values runs reported seconds standard deviations range seconds row data application version column data source search directives performance consultant cell found row column time diagnose directives previous run time relative base version column shown parentheses karavanic miller improving online performance diagnosis historical performance data hypothesis focus pairs tested true resulting search directives set priority high total hypothesis focus pairs tested true pairs tested true included search directives remaining set low priority intermediate level nodes tested remaining detailed refined answers tested due cost limits case search directives resulted detailed diagnosis performed directives anticipated search directives versions effective search directives version results showed small differences cases examined runs version noting differences sets search directives extracted base runs versions shown table priorities common sets directives unique single set remaining occurred sets high priority settings bigger impact category common unique remaining common list bottlenecks found vary runs search directives extracted versions total bottlenecks diagnosed true performance consultant runs common remaining common conclude modifications communications primitives blocking nonand modifications algorithm decomposition bottleneck locations remained total synchronization time total execution time varied versions set resources responsible time similar investigated results multiple previous runs guide current run looked approaches combining search directives versions sets high low priority hypothesis focus pairs tested true false versions sets high priority hypothesis focus pairs tested true sets low priority hypothesis focus pairs tested false version test true resulting set directives diagnose version lists priorities result methods combination common directives additional directives unique resulting diagnosis times difference small conclude superiority combination method performs related similarity sets directives generated data runs similarity code platform versions related work existing tool automated performance diagnosis adapts testing strategy historical performance data chitra generates parameterized empirical model fitting observed data program runs predict future program performance cmon pspec tools gather data multiple executions produce single summary application behavior checking metric values predetermined execution priority setting total high low table similarity extracted priorities code versions column represents source priority directives run versions rows data high priority low priority complete set values number priority directives category total high priority directives unique version common versions karavanic miller improving online performance diagnosis historical performance data points widely set benchmarks measure effectiveness correctness parallel distributed performance diagnosis francioni proposed test suite debugging performance analysis tools called swamp malony conducted detailed study performance perturbation due instrumentation hondroudakis procter classify tasks involved parallel performance tuning based extensive user survey results support performance data storage multiple executions tuning studies recent study smith investigates relevant parameters predicting application run times historical information goal predict run time harvest directives runtime tool measure behavior detailed level conclusions future work approach automated performance diagnosis incorporates knowledge previous runs application result performance tool learns diagnostic program run adapting search strategy obtain diagnoses quickly show performance gains obtained incorporating historical knowledge performance consultant search strategy results presented demonstrate utility approach repeated performance diagnosis similar program runs common scenario tuning parallel applications harvesting historical knowledge requires store performance data gathered previous program runs work part ongoing research effort designing developing infrastructure storing naming querying multi-execution performance data representation space executions techniques quantitatively automatically comparing executions previous paper extending research directions studying additional approaches mapping resources executions goal automate mapping furthest extent continuing user-specified mappings demonstrated resource mapping performed start execution hope extend cover cases resources discovered application run extending ability extract search directives case results form search history graph previous run raw data needed test hypotheses postmortem study search directives extracted results gathered monitoring tools williams hoel pase mpp apprentice performance tool delivering performance cray decker rehmann editors programming environments massively parallel distributed systems birkh user hollingsworth miller dynamic control performance monitoring large scale parallel systems proceedings international conference supercomputing tokyo july helm malony fickas capturing automating performance diagnosis poirot approach proceedings international parallel processing symposium pages april sinha kale automatic performance analysis proceedings international conference parallel processing pages iii miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november gropp lusk skjellum mpi portable parallel programming messagepassing interface chapter mit press mathur abrams machine assisted software performance diagnosis methodology technical report virginia polytechnic institute state department computer science perl weihl noble continuous monitoring performance specification technical report compaq digital systems research cenkaravanic miller improving online performance diagnosis historical performance data ter june francioni determining effectiveness interfaces debugging performance analysis 
tools simmons hayes brown reed editors debugging performance tuning parallel computing systems pages ieee computer society press malony performance observability phd thesis illinois urbana-champaign hondroudakis procter empirically derived framework classifying parallel program performance tuning problems proceedings sigmetrics symposium parallel distributed tools pages acm press august smith foster taylor predicting application run times historical information proceedings ipps spdp workshop job scheduling strategies parallel processing march karavanic miller experiment management support performance tuning san jose november working group automatic performance analysis resources tools http fzjuelich 
communicate information attribute space basic functions tdp tdp put functions structure synopsis sketched tdp handle attribute tdp put handle attribute handle corresponds identification returned tdp init attribute string identifies information store retrieve attribute space information contained attribute operations blocking forms communication daemon lass put case function block attribute stored shared space case function blocks attribute returned error returned attribute contained shared space asynchronous versions retrieving storing information shared space tdp async handle attribute callback callback arg tdp async put handle attribute callback callback arg functions return immediately called storing retrieval information completed time callback function provided functions executed operation completes usersupplied argument callback arg passed callback function asynchronous functions prevent daemon process blocked communication operation shared environment space activities event notification principle callback function asynchronous put called operation completed pure asynchronous notification mechanisms hard manage tools obvious unix implementation features tdp unix signals threads signals problem run-time tools signal finding signal conflict tool problematic threads problem plethora thread packages select thread package tdp compatible packages rts cases pure asynchronous notification mechanism rts rms central polling loop operation unix poll select wait event process cases asynchronous events simply activity descriptor daemon return poll find descriptor active call function extract event possibly act mechanism compatible operating systems windows support unix signals case client registers callback event type support behavior tdp library tdp service event call pending callback registered previously asynchronous put scheme delivery events related communication actions checked specific point tdp service event code callback function called well-known presumable safe point tdp service event function called activity detected tdp handle identify kind event delivered call action function pseudo-code asynchronous communication services illustrated tdp tdp async tdp handle pid pid callback arg tdp tdp async tdp handle executable exec callback arg main polling loop tool poll descriptors tool processes events related descriptors process event callbacks registered completed tdp functions processed tdp service events tdp service event call callback callback depending action completed parador prototyping tdp initial test tdp protocol chose condor batch system paradyn parallel perforbecause tdp signals conflict page mance tool representative examples resource manager run-time tool outline structure system describe modified work tdp condor structure condor widely-used system scheduling jobs run distributed cluster grid environment mechanisms needed submit jobs run remotely including checkpointing remote file access condor terminology local host submit machine remote hosts called execution machines submission job interaction condor daemons illustrated figure paragraphs describe role condor daemons start describing daemons run local machine condor schedd condor shadow continue daemons run remote machine condor startd condor starter local daemons condor schedd daemon represents resources requests condor pool submit machine condor schedd running basically condor schedd takes care job suitable resource found job condor schedd spawns condor shadow daemon serve request condor shadow program runs machine request submitted acts resource manager request jobs linked condor standard universe perform remote system calls condor shadow system call performed remote execute machine network condor shadow performs system call file submit machine result back network remote job remote daemons condor startd daemon represents resource machine capable running jobs condor pool condor startd runs machine pool execute jobs condor startd ready execute condor job spawns condor starter condor starter program entity spawns remote condor job machine sets execution environment monitors job running job completes starter sends back status information submitting machine exits condor startd condor starter form figure shows element called match maker represents entity responsible finding suitable machine run job figure condor structure schedd shadow run user local machine startd starter run remote machine page matchmaking algorithm responsible locating compatible resource requests offers compatible match found matchmaker notifies job machine suitable matching notified schedd contacts startd claiming protocol party decide complete allocation condor daemon called condor master present local remote nodes job track condor daemons figure shows existing relation components paradyn structure paradyn performance profiling tool parallel distributed programs major technologies ability automatically search performance bottlenecks performance consultant dynamically inserting removing instrumentation application program run time dyninst paradyn main parts paradyn front-end user interface paradyn paradyn daemons paradynd agents run remote host application program running paradyn user interface user display performance data visualizations performance consultant automatically find bottlenecks start stop application monitor status application paradynds operate control paradyn monitor instrument application processes tdp terminology paradynd paradyn interacts application program modes section starting program create mode attaching alreadyrunning process attach mode create mode paradyn launches application user providing information working directory application arguments execution host machine frontend information related application create paradynd fork case launching paradynd local machine rsh ssh executing remote machine paradynd successfully started connection established front-end paradynd point paradynd ready launch application process forking process allowing user start application initialization paradyn run-time library loaded application process paradynd parses executable discover symbols find potential instrumentation points connection established application paradynd steps user control execution application front-end attach mode user specifies host process application process front-end launches paradynd forking executing rsh ssh case paradynd attach application process attach action pause application perform actions previously create mode daemon structure condor submit file entries figure paradyn running condor tdp universe vanilla executable foo input infile output outfile arguments transfer files suspendjobatexec true tooldaemoncmd paradynd tooldaemonargs -zunix pid tooldaemonoutput daemon tooldaemonerror daemon err tranfer input files paradynd queue -mpinguino wisc create pause application monitoring tool information typical job description page parador combining worlds process control paradyn condor modified tdp library modifications involved re-arranging related code system total code involved lines condor user submit job create application process paused create paradynd provide paradynd information contact front-end code paradyn condor fell categories rearrangement basic operations fit tdp model addition tdp library calls rearrangement operations net effect behavior paradyn condor rearrangement separates functions combined considered permanent addition tdp library calls paradyn condor operate tdp calls invoked tdp environment prototype section developed create mode resource manager daemon condor starter case creates beginning addition prototype managed local attribute space lass remote host management global attributes included logical view approach depicted figure condor point view job consists entities application process paradynd current prototype commands job submit file notify condor application process created started paradynd 
monitor application process scratch purpose suspendjobatexec directive introduced condor submit file shown figure line submit file information case paradynd purpose set lines initiated string tooldaemon introduced lines outline information needed launch paradynd equivalent description regular job arguments tooldaemonarguments output tooldaemonoutput tests paradyn front-end started step required front-end publishes port numbers paradynds connect figure port numbers manually included submit file starter passed directly paradynd arguments starting time complete tdp framework port arguments published paradyn front-end disseminated remote sites attribute values hand application pid communicated local attribute space pid notation temporary mechanism show information starter put lass information paradynd attribute paradynd running tdp framework expressive mechanism defined resource manager run-time tool real scenario paradyn front-end created carry action create paradynds application processes work left condor submitting job figure front-end waited condor found machine run application briefly sketch tdp functions included paradynd condor work tdp figure describes daemons behavior remote host condor claiming activation protocols completed remote machine ready accept submitted job condor startd creates starter charge processes involved job case job special job submit file includes extra arguments earlier arguments parsed starter detects monitored job launched figure shows steps starter paradynd complete launching sequence step starter executes tdp init create lass starter paradynd communicate tdp framework initialized starter launches application process tdp create process paused argument application process stopped starting execution unix terms means application stopped executing pair fork exec calls libraries dependencies loaded initialized point paradynd safely introduce instrumentation points step starter launches paradynd tdp create process function case paused option paradynd created paradynd parses arguments job submit file find application process paradynd assumes working tdp framework step point paradynd calls tdp init contact lass contact successfully accomplished paradynd immediately asks application pid purpose calls tdp pid attribute tdp blocking function paradynd blocked page starter stores lass application pid tdp put paradynd receives queried pid attaches application calling tdp attach function paradynd run application process beginning main function issuing tdp continue process call step paradynd control application execution usual condor defines execution environments called universes run applications universe chosen type application user run universe attribute submit file slightly mechanisms starter universe spawn application prototype demonstrated vanilla mpi universes similar starters vanilla universe run sequential applications specific restrictions applied job sequential job runs condor run vanilla universe modification vanilla application run tdp framework starter creates application paradynd order depicted figure paradynd blocked tdp operation application pid put starter lass paradyn front-end updated information application user control application usual mpi universe run parallel programs written mpi specifically applications compiled mpich version mpi case submit file specifies number nodes parallel job application start suitable number machines allocated condor process called master process started mpi terminology process rank paradynd created information exchanged starter paradynd figure tdp function calls condor paradyn sides lass paradynd attaches process simipage larly vanilla universe control passed user front-end user issues run command rest processes application created paradynd attached processes created stopped paradynds attach reporting front-end immediately issue run command tdp continue point user steer analyses execution application usual commands paradyn frontend benefits distributed resource sharing established numerous software environments toolkits evolved recent years support mode computing grids considered generalized metacomputing systems gained tremendous popularity recently enabling secure coordinated resource sharing multiple administrative domains networks institutions conclusions potential benefits large distributed systems commonly accepted inherently complex existing parallel systems local-area clusters large-scale distributed systems resource managers play crucial role responsible providing basic services guarantee execution applications remote resources hand on-line monitoring tools important approach finding effective solutions performance problems ensuring application reliability reliability performance problems restricted user applications set components commonly referred system middleware subsequently on-line monitoring tools extensible middleware services large-scale distributed environments imply scenario requires resource managers monitoring tools aware existence prepared execute conditions paper early experiences tdp tool daemon protocol standard interface aims improve interoperability resource managers monitoring tools interoperability refer ability tools resource managers cooperate controlling user applications common services communication mechanisms tdp based small set functions resource managers monitoring tools create control application processes additionally manages common attribute space based flexible extensible mechanisms enable pair resource managers monitoring tools communicate effecbasic configuration application specific information notify occurrence run-time events related application execution prototype tdp applied condor batch system paradyn parallel performance tool proof concept daemons condor paradyn modified work tdp library result run jobs condor pool sequential mpi job monitored controlled paradyn prototype focussed interoperability problems resource manager daemon run-time monitoring tool daemon execution site local attribute space acknowledgements work supported part department energy grants de-fg defg lawrence livermore national lab grant veritas software direcci general universidades grant comisi interministerial ciencia tecnolog cicyt contract tic government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon balle brett chen lafrancelinden approach parallel debugger architecture sixth international conference para espoo finland june published lecture notes computer science fagerholm eds springer heidelberg june butler gropp lusk scalable process-management environment parallel programming europvm mpi balaton hunger august spring verlag lncs carriero gelernter linda context comm acm april cray computer nqe users guide version january etnus llc totalview user guide document version january http etnus evensky gentile camp armstrong lilith scalable execution user code distributed computing sixth ieee international symposium high performance distributed computing hpdc portland oregon august foster kesselman globus project status report seventh heterogeneous computing workshop orlando florida march tively attribute space exchange page grimshaw wulf legion view feet international symposium high performance distributed computing hpdc syracuse august ibm corporation load leveler users guide version ludwig wism ller oberhuber ocm omis compliant monitoring system european pvm conference nchen germany october springer verlag lncs madden franklin hellerstein hong tag tiny aggregation service ad-hoc sensor networks symposium operating systems design implementation osdi boston massachusetts december miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november special issue performance evaluation tools parallel distributed computer systems mutka livny litzkow condor hunter idle workstations int conf distributed systems san francisco calif june adrian nye xlib programming manual edition reilly associates july platform computing lsf users guide roth arnold miller mrnet software-based multicast reduction network scalable tools phoenix 
november 
process hijacking abstract process checkpointing basic mechanism required providing high throughput computing service distributively owned resources present process checkpoint migration technique called process hijacking dynamic program re-writing techniques add checkpointing capability running program process hijacking makes checkpoint migrate proprietary applications re-linked checkpoint library makes dynamically hand ordinary running process distributed resource management system condor discuss problems adding checkpointing capability program execution loading code running process replacing functions process calls dynamically loaded functions dyninst api process editing library augmented call replacing functions solve problems discuss problems migrating hijacked process preserving uncheckpointable operating system state hijacked process migration safely restoring dynamically assembled address space hijacked process checkpoint preserve uncheckpointable operating system state spawning shadow process hijacked process process hijacking migrate variety programs including running unmodified java show migration performance hijacking comparable condor introduction process checkpointing contributes flexibility power distributed resource management system allowing processes migrated hosts execution systems condor codine checkpointing dynamically schedule longrunning programs characteristic checkpoint techniques employed systems application re-linked checkpoint library submitted requirement prevents submission proprietary executables re-linking depends access original object files program addition program execution handed resource manager require ability relink running process present process checkpointing technique called process hijacking enables types programs submitted resource management system includes support remote hijacked processes migrated foreign administrative domains process hijacking dynamic program re-writing techniques add checkpointing capability remote ordinary processes creates execution context similar created condor hijacked process split processes figure application process shadow process application process original process hijacker adds checkpoint remote victor zandy barton miller miron livny zandy bart miron wisc computer sciences department wisconsin madison work supported part department energy grant de-fg nsf grants cdaand eiaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon figure hijacked process shadow process remains original submit host application process migrated remote host application process shadow process remote submit host remote host calls checkpoint library system call rpc library rpc stubs system system call support originally runs submit host hijacked migrated remote host shadow process started submit host provide stable context application process application makes context-sensitive system call call executed shadow remote procedure call rpc stubs application contained library called remote system call library dynamically loaded application hijacker hijacker rewrites application rpc stubs standard system calls important type contextsensitive system calls related calls involve file descriptors remotely executing operations shadow application process migrated hosts file system resources security credentials submit host add support migration hijacker loads checkpoint library application checkpointing triggered sending signal application process restarted resumes communication shadow process transmitting remote system calls host process hijacking interesting main reasons expands scope checkpointing users running proprietary programs benefit checkpointing services offered distributed resource management systems process migration re-link advance makes migration viable alternative program termination suspension unanticipated resource availablity arise process running machine close exhausting swap space hijacked checkpointed convert swap space usage disk usage introduces technology generalize access metacomputing process hijacking replaces system call functions hijacked process dynamically loaded substitutes effect process linked running allowing programs execution dynamically modified redirect access authentication services interact scheduling service concrete demonstration power runtime code modification adding checkpointing capability program runs requires ability modify code toolkit makes editing running programs simple found dyninst api modifications easy ordinary data manipulation process hijacking shows runtime program rewriting previously shown debugging performance profiling resource management hijack process support migration hijacked process overcome main technical challenges dynamically inserting code controlling execution hijacked process dyninst api runtime code re-writing library modify control process library architecture-independent interface splicing code sequences running process installing code libraries section replacing system call functions running process developed extension dyninst api called replacefunction replace original system call functions remote system call rpc stubs replacefunction general mechanism re-linking running program section migrating process dynamically loaded checkpoint library checkpointed process arbitrarily arranged address space restart code careful place reconstructs address space section preserving operating system state hijacked process migration process state hidden operating system open file state checkpointed directly preserve state shadow process remote system calls system calls involving state serviced section implemented process hijacking tool called process hijacker runs ultrasparc workstations running solaris remote system call checkpointing libraries derived libraries condor excluding dyninst libraries hijacker approximately lines section briefly describe dyninst api runtime program re-writing library implement process hijacker modifications performed hijack process explained section aspects migration unique process hijacking section section describes performance process hijacker showing breakdown costs dyninst api dyninst architecture-independent api making on-the-fly modifications running program figure shows organization dyninst api application program called mutator linked dyninst api library makes api calls control modify application program called mutatee mutator attaches mutatee usual process debugging interface provided operating system ptrace proc unix process control api windows operations reading writing memory mutatee performed dyninst directly interface complex operations allocating memory executed library installed dyninst mutatee called run-time instrumentation library rtinst dyninst operate dynamically linked executable require special preparation executable re-compiling re-linking executable debugging symbols dyninst mutator splice code patches sequences machine instructions entry exit call sites function mutatee dyninst architecture-independent mechanism code patches terms familiar program data control flow operations including assignment logic arithmetic branching function calls mutator make inferior rpc mutatee asynchronously execute code patch dyninst mutator attaches process parses code process find instrumentation points modified dyninst parse functions instrumented hijacker reduce parsing time hijacker started hijacker operation describe motivate operation process hijacker figure shows process hijacked figure application ordinary process linked system call functions standard library figure things loaded checkpoint library remote system call library signal handler shown triggers checkpoint context-sensitive system calls replaced remote system calls shadow process running handle remote system calls system calls safely replaced system call function active stack resuming system call invalidate state shadow process hijacker detect situation inspecting stack handled intercepting return system call proceeding hijacking inherit limitations condor checkpointing mechanism processes spawn children communicate processes run multiple kernel-level threads migrated hijacker assumes system calls generated application process handled standard library system call interface system calls bypass interface forwarded shadow process hijack process process hijacker performs operations calls dyninst figure attaches application process stops loads rtinst library loads checkpoint replacement system 
call libraries application saves open file state application process shadow process forking application process section replaces application system calls section initializes shadow communication installs checkpoint signal handler restarts application process detaches figure dyninst api operation mutator mutatee process hijacker application process process modifications application rtinst library process modifications dyninst dyninstapi library process application code modifications figure process hijack application code process modifications application code standard system calls application process process modifications rpc stubs application process shadow process hijack hijack checkpoint system call rpc rtinst steps primitive dyninst operations attaching detaching mutatee step performed dyninst operation loadlibrary mutatee load library step performed onetimecode dyninst operation making inferior rpc mutatee interesting steps creation shadow process step replacement system calls step remainder section explains steps preserving process state shadow shadow process serves main functions condor executes context-sensitive system calls submit host context preserves open-file state checkpoint subsequent restart application discuss motivation shadow process preserving open-file state running application program file descriptors opened hijacked descriptors include open files devices pipes sockets processes file open separate position pointers separate open calls shared position pointer dup calls checkpointing state makes severe demands operating system open works file names names files opened application process re-open finding file descriptor requires inode search file system operating system maps descriptors inodes file names file happened unlinked descriptor created open deleted closed re-opened descriptor set previous position possibly duplicated lseek determine position duplication state descriptor file types support seeking device files special close semantics rewind eject closing undone device re-opened avoid addressing problems directly hijacker fact fork copies file descriptors parent process child create complete copy application open file state shadow process advantage created approach migration distributed applications communicate sockets shadow process fixed location communication ports disadvantage figure steps hijacking hijacker attaches application application loads checkpoint remote system call libraries application spawns shadow process hijacker replaces application system calls application initializes shadow connection hijacker detaches hijacker application hijacker application shadow hijacker application shadow ckpt rpc rti dyn libc checkpoint system call rpc rtinst dyninst standard system call ckpt rpc rti hijacker application shadow ckpt rpc rti application shadow ckpt rpc rti hijacker application shadow ckpt rpc rti rti libc libc libc dyn dyn dyn dyn dyn libraries ckpt rpc rti approach shadow process live application process terminates shadow process small trivial performance impact submit host submit host crashes application restarted condor shadow contrast restarted condor remote system calls linked application process beginning execution condor remote system calls record parameters passed context-senstive system calls filenames open calls descriptor numbers dup calls condor shadow reconstruct file descriptor state restarts condor shadow flexible survive crash submit host unmodified already-running processes provide level fault-tolerance hijacking shadows require operating system mechanism allowing handles open files persist process termination system shutdown replacing system calls added method dyninst api called replacefunction replace original system call functions hijacked process rpc stubs contained remote system call library replacefunction inserts code patch entry point original function jump replacement function jump designed replacement function returns directly caller original function replaced function replacefunction understands code optimizations affect function calls abbreviated state saving tail-calls figure shows operation replacefunction powerful applications replacefunction process hijacking code patch inserts arbitrary code including code parameters replaced function patch select multiple replacement functions call depending parameter values mechanism calling dynamically specialized functions general mechanism re-linking program started running conventional dynamic linking techniques set binding time symbols definitions start execution replacefunction applied change function binding time execution costs replacefunction small amount memory code small time penalty call jump original function replacement memory required depend number potential callers function time penalty negligible replacement function call makes rpc shadow process time easily dominates cost control transfer ways dynamically replace functions method chose appears general point modification entry point replaced function convergence control paths function modification function required repeated techniques include modifying point function called modifying dynamic linkage data structures techniques require multiple modifications made replaced function control path function modifying call points dynamic library call function modifying linkage data require process permanently monitored modifications applied code dynamically loaded process technique hijacker attach process rewrite disappear process migration process hijacked ready migrated process migration parts checkpointing restarting process checkpoints signal handler contained checkpoint library triggered process checkpointed restarted signal handler context exception shadow preserve file state checkpoint mechanism identical condor discussed figure function replacement function write replaced hijackwrite foo write hijackwrite call write trap shadow rpc return return foo write hijackwrite call write shadow rpc return return patch jump hijackwrite jump patch checkpointed process restarted process called starter transforms continuation checkpoint delicate stage procedure occurs starter replaces address space checkpointed address space starter process library called restart library code data perform address space replacement region checkpointed address space coincides location restart library restart library overwrite replaces region address space possibly crashing restart prevent restart library loaded region disjoint region checkpointed process delay loading restart library loaded safe place solaris dlopen function load runtime loaded pre-allocate regions allocated checkpointed address space allocated starter load restart library regions checkpointed address space allocated loader forced load region safe copy checkpointed address space stage restart procedure unloads restart library copies accumulate multiple checkpoints restart mechanism requires services operating system means discover address space process provided proc solaris ability allocate specific regions virtual memory provided mmap map fixed flag restart code data location problem occur systems condor statically link restart library application systems application executable restart checkpoint command-line parameter determines application run restart checkpoint static linking loads restart library address time application run checkpointed address space copy restart library address process restarts checkpoint restart library preserved region address space replaced arrangement process hijacker creating custom starter checkpoint statically linked restart library safe location performance measured aspects performance process hijacker hijack time migrate time hijack time total running time process hijacker including time inserting checkpoint remote system call libraries replacing system calls migration time measured parts checkpoint time restart time checkpoint time begins application process receives checkpoint signal ends checkpoint written restart time begins restart program executed ends restart program returns application code checkpointed process report hijack time migrate 
time hijacker condor programs tiny small compute-intensive program big program similar tiny larger data area kaffe java virtual machine text data running line compute-intensive java program cpu simulaprogram hijack time checkpoint time restart time condor chkpt server hijack chkpt server hijack local file hijack afs condor chkpt server hijack chkpt server hijack local file hijack afs tiny big kaffe path table hijack migration times condor hijacker times milliseconds program condor hijacker tiny big kaffe path table checkpoint sizes condor hijacker tor architecture researchers wisconsin text data path mixed complementary solver mathematical programming researchers wisconsin text data performance results summarized table checkpoint sizes measured programs shown table processes hijacked migrated mhz sun ultrasparc memory running solaris hijack time seconds table shows cost breakdown major hijacking stages program real time includes time spent executing inferior rpcs application process virtual time reflects cpu time user system hijacker stages listed order occur figure attaching application expensive stage dyninst loads rtinst library application process scans executable shared libraries application locate functions parses code replaced system call functions identify entry exit call sites entry sites points replacefunction laters inserts jumps rpc stubs expensive stage loading scanning checkpoint remote system call libraries replacing system calls initializing shadow connection expensive stage starting shadow process requires inferior rpc hijacker process results significant activity processes application process executes rpc creates shadow process shadow starts detaching application process inexpensive stage hijacker makes application runnable exits stages read write data application process data size factor hijack time excluding paging effects migration time hijacked processes compare performance methods checkpoint file writing local disk writing afs distributed file system writing condor checkpoint server time transfer checkpoint file host included times local disk included times afs checkpoint server make checkpoint file globally checkpoint restart times checkpoint server comparable times condor times slightly higher checkpoints bigger condor due large data areas dyninst rtinst library user hijack migrate medium-sized process checkpoint server expect seconds local disk fast checkpoint convenient users checkpointing yield machine resources requires user migrate process manually transfer checkpoint destination host afs convenient mechanism transferring checkpoint files significantly slower network checkpoint server performance condor checkpoint server falls methods related work process migration operating system function early feature demos locus sprite research systems advantage implement kernel primitives accessing process state making checkpointing migration transparent application processes systems limited migration kernels hosts administrative control recent systems provide user-level checkpointing migration commodity kernels systems require user prepare executable checkpointing linking special libraries inserting calls checkpointing libraries source code special compiler condor codine cocheck mist require application re-linked checkpoint library codine distributed resource management system checkpoint migration service applications re-linked checkpoint library cocheck adds condor checkpoint library pvm mpi applications mist migration pvm tasks providing special version pvm library includes checkpoint fuctionality migration systems require access application source code clip checkpoint system intel paragon multi-computers requires insertion calls checkpoint library source code tui process introspection project heterogeneous process migration systems provide special compilers generate checkpoint capable programs tui supports heterogeneous process migration programs written common languages ansi custom compiler hijack stage real time virtual time attach load libraries start shadow replace syscalls detach table breakdown hijacking costs times milliseconds identifies properties program data execution points checkpoint system process introspection project defines platform-independent design pattern expressing checkpointing information source code application special library compiler automatically generate checkpoint capable executables programs written compliance pattern conclusions process migration basic mechanisms required provide high throughput computing service distributively owned resources paper report checkpointing tool process hijacker expands scope range process migration hijacker users long-running proprietary programs benefit checkpointing migration services offered distributed resource management systems freed requirement re-link application advance pass time control process started interactively resource management system hijacker splits running process processes original application process augmented checkpoint remote system call libraries shadow process remains original execution environment preserve state application process remotely execute future system calls hijacker employs dynamic program re-writing techniques insert checkpoint remote system call libraries application replace standard system calls process remote system calls shadow hijacker dynamically migrate ordinary programs including java shown process hijacking inexpensive operation cost migrating hijacked process comparable costs incurred condor migrating pre-linked process acknowledgments jim basney todd tannenbaum derek wright condor team assistance condor bryan buck tia newhall christopher serra ariel tamches brian wylie zhichen assistance dyninst jim basney jin zhang idea restart library relocation safely restarting checkpoints hijacked processes casas clark konuru otto prouty walpole mpvm migration transparent version pvm computing systems spring chen plank clip checkpointing library intel paragon supercomputing san jose douglis ousterhout transparent process migration design alternatives sprite implementation software practice experience august ferrari chapin grimshaw process introspection heterogeneous checkpoint restart mechanism based automatic code modification technical report cs- department computer science virginia genias software codine http genias products codine hollingsworth buck dyninstapi programmer guide http umd projects dyninst api litzkow tannenbaum basney livny checkpoint migration unix processes condor distributed processing system technical report computer sciences department wisconsin april livny raman high-throughput resource management grid blueprint computing infrastructure morgan kaufmann walker popek english kline thiel locus distributed operating system distributed computing systems concepts structures ieee computer society press miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november powell miller process migration demos acm symposium operating system principles october smith hutchinson heterogeneous process migration tui system software practice experience stellner cocheck checkpointing process migration mpi international parallel processing symposium honolulu stellner pruyne resource management checkpointing pvm european pvm user group meeting lyon france theimer lantaz cheriton preemptable remote execution facilities system acm symposium operating system principles orcas island december 
dynamic kernel instrumentation kernel application tuning abstract designed technology fine-grained dynamic instrumentation commodity operating system kernels insert runtime-generated code machine code instruction unmodified operating system kernel technology ideally suited kernel performance profiling debugging code coverage runtime optimization extensibility written tool called kerninst implements dynamic instrumentation stock production solaris kernel running ultrasparc cpu written kernel performance profiler top kerninst measuring kernel performance two-way benefit suggest optimizations kernel applications spend time kernel code paper present experiences kerninst identify kernel bottlenecks running web proxy server profiling kernel routines understand performance bottlenecks inherent proxy disk cache organization understanding make kernel application cumulatively reduce percentage elapsed time proxy spends opening disk cache files writing introduction operating system kernels complex entities internals difficult understand measure optimize designed fine-grained dynamic kernel instrumentation low-level technology arbitrary code spliced inserted kernel machine code location runtime dynamic kernel instrumentation runtime measurements optimizations extensibility performed unmodified commodity kernels dynamic kernel instrumentation single infrastructure means monitoring functionality debugging profiling alongside mechanisms extensibility adaptability manner kernel evolving entity measure adapt accommodate real-world runtime usage patterns evolving operating systems form foundation dynamic environments code adapt demands performance profiling dynamic kernel instrumentation natural fit meta-computing grid environments place dynamic demands operating system making runtime performance gathering essential previous paper describes low-level technology dynamic kernel instrumentation implementation unmodified solaris kernel paper presents case study kerninst optimize web proxy server making kernel proxy found understanding kernel performance two-way benefit information tuning kernel user processes kernel profiling kernel application developers remainder paper organized section summarizes kerninst section overview benchmark drive kernel section study kernel performance bottlenecks running benchmark solutions ideas future optimization section discusses related work section concludes kerninst designed implemented tool called kerninst performs fine-grained dynamic instrumentation stock unmodified solaris kernel running ultrasparc cpu kerninst desired runtime-generated code inserted removed changed kernel code space ariel tamches barton miller computer sciences department wisconsin madison tamches bart wisc work supported part department energy grant de-fg nsf grant cdaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon machine code instruction granularity runtime kerninst instruments dynamically unlike kernel binary rewriter reboot required instrumentation effect built kernel performance profiling tool kerninst user insert performance-gathering primitives kernel runtime performance instrumentation determined choosing metric resource metric determines type measurement resource determines function measured paper metrics measures number procedure calls made function calls made measures number kernel threads executing function concurrency measuring function concurrency similar measuring latency meaning multi-threaded environment total latency units seconds measures total time spent function threads simultaneously execute function overlapping time counted total concurrency units thread-seconds include overlapping time interval times plot concurrency time bottom curve figure x-axis denotes time y-axis denotes number threads executing function moment metric concurrency instrumentation deferred user requests kernel performance profiling kerninst completely interactive dynamic activity metric resource selections made instrumentation inserted measurements gathered time finding bottlenecks interactive activity involving successive refinement set routines measured essential tool user decide measurements made runtime kerninst ideally suited paradigm performance study parameters case study kernel performance profiling kerninst measure performance solaris kernel running squid web proxy server section outline major components benchmark squid wisconsin proxy benchmark squid web proxy server web proxy servers effective means reducing load web servers web clients attach local proxy actual web server caches web server contents proxy retrieves files needed web server satisfy client http request cache studied performance solaris kernel running version squid freely web proxy server squid levels cache in-memory on-disk incoming requests searched squid memory cache misses squid disk cache squid misses fetches file server squid disk cache installed local disk running default unix file system ufs heavily loaded proxy server expect hundreds thousands simultaneous tcp connections multiplex alongside local disk activity squid create thread process handle request single thread control multiplexes active tcp connections pending file operations non-blocking operations wisconsin proxy benchmark version wisconsin proxy benchmark drive squid thirty synthetic client processes connect squid proxy squid turn connects synthetic server process machines client squid server client process connects squid makes http requests thinking time requests stages stage requests made files file requested locality purpose stage populate cache stress cache replacement algorithm stage client sends requests time temporal locality pattern designed lead proxy hit ratio server process listens port number http requests arrives parses url determine file synthetically created server creates file file size uniformly distributed time time file size performance study kerninst measure performance solaris kernel running benchmark search application squid bottleneck led kernel requiring kernel profiling tool section discusses bottlenecks found optimizations kernel squid address ideas optimization found kernel performance profiling two-way benefit kernel performance profiling understand kernel bottlenecks leading kernel optimizations proxy servers spend time kernel performing measure in-kernel performance understand bottlenecks optimize application first-order bottleneck file opens wisconsin proxy benchmark working set size larger squid in-memory cache hypothesized squid disk bound examined squid code causing disk thrashing hypothesized bottleneck disk reads files missed squid in-memory cache hit reading disk disk writes files missed squid on-disk cache requiring file brought true server ran quantify profiling tool squid determine source first-order bottleneck found squid bottleneck routine storeswapoutstart called demote file squid inmemory cache on-disk cache interestingly bottleneck occurred writing disk cache file call open squid spending non-idle excluding time spent waiting select statement run time simply opening on-disk cache files writing explain result investigated squid cache organization squid maintains file http object cached disk squid on-disk cache single huge fixed-size file collection files cached differing file sizes simplifies squid code severe bottlenecks squid organizes files hierarchy number files directory manageable squid level directory structure fanned based fixed program constants hash function maps file table entry number full path file since-ejected cached object file present squid truncates existing file size passing trunc flag open reusing files squid avoids delete files avoids expensive meta-data required deleting unix file updating parent directory file freeing file inode disk blocks squid spending time open strategy ineffective bottleneck open system call program multiplexes file descriptors interface non-blocking open system call contrasts read write return ewouldblock block process allowing work proceed ready file descriptors non-blocking opens entire squid process include 
dozens open file descriptors blocked open file blocks performance study required examining open slow turn requires understanding operations place open system call user-level performance profilers systems calls black box offer guidance understanding kernel performance kerninst continue performance study user-level tools leave user-kernel boundary understanding kernel performance open dynamic nature kerninst interactively find kernel bottlenecks bottlenecks found user programs start function performing slowly measure latency routine callees measurement determines callee bottleneck process repeated callee kerninst calculate number cycles spent routine instrumenting entry exit points code starts stops cycle counter kerninst instrumentation unmodified running commodity kernel perform iterative refinement stock solaris ultrasparc workstations squid running interesting symptom support claim constant noise disk seeks coming hard drive computer running squid measured kernel routine copen implements file creation file opening results shown figure copen called times squid elapsed time spent examined copen spending time copen calls falloc allocate entry process file descriptor table open perform open times routines shown figure surprised find falloc taking negligible time file table allocation reported bottleneck heavy disk load copen time spent open examined routine file creation opening diverge calling create creat flag passed open open called open creat flag essentially performs creat figure copen called times sec copen clear bottleneck average kernel threads executing routine time translates squid elapsed time single-threaded program percentage elapsed time differs quantify reports open quantify percentage non-idle time elapsed wall time excluding time spent waiting idle select call figure copen major callees falloc open negligible time spent falloc times create creating on-disk cache file remaining calls open non-creating indicating hits on-disk cache examination latencies figure show time spent open consumed time spent create file creations account squid file opening bottleneck file creation bottleneck examined create routine create calls lookuppn namei translate file path vnode passes vnode file system-specific creation routine ran squid local disk default unix file system ufs create invokes ufs create results shown figure reveal file creation distinct bottlenecks path lookup lookuppn ufs file creation ufs create return bottleneck lookuppn turn attention ufs create surprised find ufs create bottleneck file creation ufs performs local meta-data operations shown figure squid spending time traced time spent ufs create ufs itrunc invoked ufs create trunc flag passed figure open spends time create concurrency curves open create overlap averaging threads time figure create main callees lookuppn ufs create lookuppn ufs create distinct bottlenecks elapsed time open system call routines identical performance numbers shown figure squid elapsed time spent truncating existing files size opening determine ufs itrunc slow looked callees results shown figure ufs itrunc time spent ufs iupdat synchronously writes disk pending updates file inode truncation slow inode made synchronously keeping unix file semantics dictate synchronous updates meta-data ensure file system integrity case crash squid strategy overwriting existing cache files avoid expensive meta-data updates required file deletion backfiring present optimization addresses bottleneck section recall figure lookuppn bottleneck extent surprising obtaining vnode path require path component reading directory file obtain inode disk location reading inode solaris optimize path lookup directory lookup cache dnlc dnlc hash table indexed path component pointer entry cache inode cache hit dnlc operating system figure ufs create time spent ufs itrunc ufs file creation time dominated inode truncation latency curves ufs create ufs itrunc completely overlap figure ufs itrunc time spent ufs iupdat file truncation slow ufs meta-data updates made synchronous ufs itrunc bypass reading directory file ufs dirlook reading inode ufs iget shown figure dnlc hit ratio miss penalty execution ufs dirlook sufficiently high account ufs lookup bottleneck shown figure addressing pathname lookup bottleneck dnlc default entries machine squid cache files benchmark hundreds subdirectories three-level cache hierarchy dnlc ineffective squid preponderance small files overwhelmed solaris sets dnlc size based kernel variable maxusers increase dnlc size increasing maxusers system maximum allowed rebooting effects increasing dnlc size figure benchmark run long warm squid disk cache minute dnlc miss rate drops correspondingly total time spent miss routine ufs dirlook drops negligible percentage squid running time ufs lookup implication lookuppn longer bottleneck figure dnlc hit ratio miss routine ufs dirlook invoked calls ufs lookup figure ufs lookup spends time ufs dirlook low miss rate dnlc miss penalty ufs dirlook high account entire ufs lookup bottleneck ufs dirlook ufs lookup curves completely overlap dnlc lookup curve essentially checking dnlc hit miss quick addressing file truncation bottleneck address ufs create bottleneck synchronous inode updates truncating file size modified squid reduce bottleneck squid bottleneck ufs create truncates existing cache files size overwriting involves updating file inode synchronously keeping ufs semantics note truncation redundant data blocks added synchronously version file written file size greater equal original size truncating file superfluous data block deleted re-created file size original size variant optimization presents truncate extra blocks end file representing change file size minor squid totalling lines source code needed implement opening disk cache file trunc flag removed contents file written removed squid code seeked end-of-file writing writing fcntl call parameter freesp truncate file size present location file pointer file size smaller previous file size inodes representing now-unused end file deleted file size greater equal original file size fcntl effect optimization re-ran kerninst examine file creation performance shown figure performance improved squid time spent creating cache files compared earlier file truncation latency optimized version squid shown figure calls ufs itrunc longer made open system call squid longer passes trunc flag opening cache files writing file closed squid invokes fcntl freesp flag truncate portion file needed results kernel code ufs freesp executed smarter truncation policy time squid spends updating meta-data reduced combined effects optimizations section increasing dnlc size reduced path lookup time squid run time section avoiding unnecessary file truncation squid reduced ufs file creation time squid run time negligible combined effects optimizations shown figure file creation figure effect increasing dnlc size ufs lookup latency twenty seconds benchmark dnlc misses account squid run time file names reused dnlc hits frequent ufs dirlook bottleneck compare figure squid run time takes added time spent explicitly truncating inodes fcntl ufs freesp figure squid elapsed run time takes re-ran quantify squid found squid elapsed time excluding idle 
time select spent storeswapoutstart opening cache files writing contrasts optimization first-order bottleneck squid write takes squid nonidle elapsed time ideas squid optimization bottlenecks identified kerninst involve meta-data updates opening local disk file writing presented optimizations significantly reduced bottlenecks squid elapsed time spent waiting open system call complete fundamental redesign squid disk cache improve performance on-disk cache figure file creation performance truncation bottleneck addressed file creation squid run time inode truncation optimization reduces figure ufs itrunc optimized squid longer trunc flag squid opening cache files truncation performed explicitly requested fcntl ufs freesp file cached http object squid huge fixed-sized file disk cache manage blocks file policies effectively bypassing overhead ufs operations optimization eliminate meta-data update bottlenecks reasons synchronously update meta-data web proxy server file corruption assuming detected worked re-fetching affected file server similarly squid ufs feature synchronously updating time modification writing files measurements suggest bypassing ufs managing disk space manually yield major performance improvements cost significantly increasing squid code complexity related work kerninst insert dynamically generated code unmodified commodity kernel code space runtime extensible operating systems processes download code kernel differ approach ways unmodified commodity kernels perform coarse-grained instrumentation vino classes customize object methods limited number instrumentation points pre-coded manner easy instrumentation synthetix replaces function called level indirection overwriting function pointer note kerninst complement extensible kernels digital continuous profiling dcpi measures detailed performance metrics cycles instruction cache misses fine grain instruction level commodity kernel digital unix unlike kerninst dcpi instrument kernel code precludes performance metrics readily sampled kerninst dynamic instrumentation create software-based metrics sampled metrics gather exact performance data statically accurate samples accuracy performance data gathered kerninst depends instrumentation code writes software timers counters rate sampled kerninst concert continuous profiling provide access greater range performance data paradyn dynamically instruments user programs work differs paradyn ways applies kernels instrumentation fine-grained paradyn limits instrumentation points procedure entry exit call sites kerninst instruments pausing paradyn incurs substantial overhead pausing application walking stack ensure safe splicing instrumentation request static binary rewriters eel atom fine-grained arbitrary code inserted user programs potentially kernels static rewriting requires program figure create time file truncation dnlc optimizations applied create squid run time figure takes instrumented off-line instrumented re-run instrumentation effect kerninst contrast dynamic instrumentation deferred needed static instrumentation requires instrumenting case turn interest dynamic instrumentation user refine runtime instrumentation code interest kitrace traces kernel code locations replaces instructions traced trap transfers control custom handler handler appends entry trace log resumes execution trap instructions inserted instructions kitrace fine-grained kerninst differs kitrace ways kerninst require kernel recompile recent version kitrace kitrace insert code kernel resuming execution kitrace trap expensive dynamic instrumentation fine-grained dynamic instrumentation subsumes kitrace insert arbitrary code trace-gathering code conclusion dynamic kernel instrumentation understand bottlenecks caused running heavily loaded squid web proxy server solaris case study demonstrates two-way benefit kernel measurement providing information kernel application tuning bottlenecks found poor dnlc performance addressed changing kernel increasing dnlc size shows kernel profiling kernel developers bottleneck superfluous file truncation addressed changing application code shows kernel profiling application developers cases optimization made detailed understanding kernel workings provided kerninst knowing open system call high latency thought optimization acknowledgments pei cao kevin beach wisweb group supplying wisconsin proxy benchmark stephen chessin madhusudhan talluri sun microsystems technical assistance suggestions matt cheyney carlos figuiera karen karavanic tia newhall brian wylie zhichen comments manuscript almeida cao wisconsin proxy benchmark http wisc cao wpb html anderson berc dean ghemawat henzinger leung sites vandervoorde waldspurger weihl continuous profiling cycles acm symp operating sys principles saint-malo france oct bershad savage pardyak sirer fiucynski becker chambers eggers extensibility safety performance spin operating system acm symposium operating systems principles copper mountain dec cao personal communication july cockcroft pettit sun performance tuning java internet sunsoft press engler kaashoek toole exokernel operating system architecture application-level resource management acm symposium operating systems principles copper mountain dec grid blueprint computing infrastructure foster kesselman eds morgan kaufmann hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference knoxville hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques san francisco nov kuenning precise interactive measurement operating systems kernels software practice experience january larus schnarr eel machine-independent executable editing acm sigplan conference programming language design implementation pldi jolla june national laboratory applied network research squid web proxy server http squid nlanr net squid audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating sys principles copper mountain dec rational software quantify web site http rational products quantify seltzer endo small smith dealing disaster surviving misbehaved kernel extensions usenix symposium operating systems design implementation osdi seattle oct small tool constructing safe extensible systems usenix conference object-oriented technologies systems coots santa april srivastava eustace atom system building customized program analysis tools sigplan conference programming language design implementation june tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating system design implementation february 
page october dynamic instrumentation threaded applications abstract threads commonplace sequential parallel programs paper describes design initial experience non-trace based performance instrumentation techniques threaded programs goal provide detailed performance data maintaining control instrumentation costs extended paradyn dynamic instrumentation instrument programs recompiling relinking handle threaded programs controlling instrumentation costs means efficient instrumentation code avoiding locks instrumentation design based low contention data structures associate performance data individual threads threads share instrumentation code assign thread private copy performance counters timers asynchrony threaded program poses major challenge dynamic instrumentation implement time-based metrics per-thread basis instrument thread context switches instrumentation code interleave interleaved instrumentation corrupt performance data scenario call self-deadlock instrumentation code deadlocks thread introduce thread-conscious locks avoid self-deadlock per-thread virtual cpu timers reduce chance interleaved instrumentation accessing performance counter timer reduce number expensive timer calls thread context switches initial implementation sparc solaris including multiprocessor sun ultrasparc enterprise machines tested tool large multithreaded applications including java virtual machine jvm show techniques helped speed java native method execution time jvm interpreting appletviewer driven game applet introduction multithreading powerful technique exploit parallelism multiprocessors improve performance uniprocessors overlapping computation general-purpose solution managing concurrency adopted today core applications including database web servers internet search engines java interpreters web applications irregular numerical applications graphical user interfaces multithreaded program faces obstacles good performance sequential program obstacles include competition resources synchronization context-switching non-overlapped response problems extended paradyn performance measurement tools monitor analyze performance threaded applications paper describes techniques initial results obtained applying techniques real programs goals research zhichen barton miller oscar naim zhichen bart wisc onaim oracle computer sciences department wisconsin madison oracle corporation broadway suite portland work supported part department energy grant de-fg nsf grants cdaand eiaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon page october provide detailed information locate performance bottlenecks threaded program associate individual threads groups threads handle dynamic nature environment including frequent thread creation deletion frequent insertion removal instrumentation paradyn users insert remove instrumentation program execution instrumentation overhead threaded programs comparable non-threaded programs handle thread packages including user-level kernel scheduled threads preemptive nonpreemptive scheduling result research provide detailed performance information threaded program tracing special compiling linking application major challenge building performance tool threaded programs associate performance data individual threads acceptable overhead adopt design called instrumentation code multiple data sicmd threads share instrumentation code private copy performance counters timers design greatly simplifies instrumentation code reduces locking global bookkeeping data structures avoiding locks instrumentation code makes intrusive challenge handle asynchrony occur multithreaded programs thread preemption instrumenting context switches reasons implementing time-based metrics instrumentation code interleave execution thread instrumentation code calls functions locks thread-safe library deadlock thread call scenario self-deadlock devised lock structure called thread-conscious locks avoid self-deadlock similar problem occur paradyn mechanism asynchronously triggering instrumentation code application called inferior rpc devised safe inferior rpc ensure interleave instrumentation code challenge minimize instrumentation cost measuring time-based metrics per-thread basis measure time spent individual threads virtualize timers thread turn timers thread-context switches context switching frequent additional instrumentation substantially slow application introduce thread virtual timers implement timers virtual timers approach reduces chance interleaved instrumentation access timer structure addition technical contributions important features paradyn tool free paradyn dynamic instrumentation technology enables tool instrument unmodified binary running program monitor multithreaded server running initial implementation runs sparc solaris including multiprocessor sun ultrasparc enterprise machines tested tool large multithreaded applications including java virtual machine jvm show techniques helped speed java native method reduce execution time jvm interpreting appletviewer driven game applet paper refer threaded paradyn version paradyn instrument threaded programs non-threaded paradyn previous version paradyn term process refer kernel scheduled entity address space light-weight processes lwp refer kernel-scheduled threads page october execute process threads refer user-level scheduled threads execution similar terms microsoft terms process thread fiber paradyn basics briefly describe basic characteristics paradyn performance tool complete descriptions paradyn parallel performance measurement tool runs sparc solaris alpha dec unix power aix solaris linux platforms paradyn dynamic instrumentation technology instrumentation code inserted changed removed running application standard performance metrics cpu waiting times paradyn instrument system hardware network activity visible application program address space paradyn basic abstractions performance data metric focus metric time-varying function measures aspect application performance cpu utilization procedure call frequency focus component running application paradyn views program collection resource hierarchies represent elements program code modules procedures machines processes threads synchronization messages semaphores locks selection nodes resource hierarchy forms focus tool users request paradyn collect metrics foci interested paradyn dynamically instruments program criteria non-threaded paradyn instrumentation code data counters timers allocated process basis instrumentation code trampoline structure figure runtime instrumentation request paradyn patches jump base-trampoline relocates instructions overwritten base-trampoline preand post-instrumentation sections pre-instrumentation section links instrumentation code executed program point post-instrumentation section links instrumentation executed program point linked item called mini-trampoline figure trampoline structure non-threaded version paradyn entry point function foo instrumented func foo relocated instruction trampoline base save regs restore regs trampolines mini save regs restore regs pre instrument post instrument instrumentation program application starttimer update cost update cost primitive instrumentation counter primitive page october instrumenting threaded programs goal provide fine-grained information locate performance bottlenecks threaded program quantify respect individual threads groups threads achieve goal adopting design called instrumentation code multiple data sicmd single copy instrumentation code per-thread copies performance counters timers extended resource hierarchy paradyn include resources threads thread-specific synchronization objects instrumentation code multiple data multithreaded application threads share code modifying application code affects threads instrumentation code multiple data threads share instrumentation private copy performance data performance metrics group threads computed aggregating measurements individual threads main data structure application address space matrix called thread table active thread column table table cells row point vector counters timers thread created free column thread table assigned newly created thread metric-focus pair enabled row counters timers allocated vector counters timers non-threaded paradyn counter timer identified thread entry vector measure cpu time spent thread thr figure timer allocated identified column row vector element trampoline structure instrumenting threaded programs shown figure section called preamble maps thread address column thread table column address stored register mini-trampolines mini-trampoline extra piece code computes counter timer address based register holds column 
address metric-focus pair figure thread table thr thr thr vector counters vector timers page october advantages design trampoline structure similar non-threaded version locks needed counter timer structures address calculation counters timers simple efficient disadvantage counter timer slots maintain thread table instrument thread creation deletion routines addition thread table global data structures free list columns thread table dictionary maps thread column index assigned thread table thread ids threads exited dictionary updated thread creation deletion base trampoline compute column address table deleted threads newly created thread terminated occur thread extremely short-lived multiple threads simultaneously access global bookkeeping data structures locks needed protect reduce contention locks implement dictionary table terminated threads hash-tables shown figure hash table bucket lock threads thread ids hash bucket contend current implementation sparc solaris cache column index assigned thread global register preserved procedure calls reducing table access figure trampoline structure threading features highlighted figure low-contention data structures func foo relocated instruction trampoline base save regs restore regs save regs restore regs pre instrument post instrument program application update cost update cost preamble preamble trampoline mini instrumentation addcounter primitive compute addr thread thread hash tid column thread table tid column thread table tid column thread table tid column thread table function page october technical difficulties arise monitoring multithreaded programs started run important obtain information threads created important information includes stack base thread lwp thread mapped stack base needed walk stack ensure thread executing instrumentation code remove lwp needed ensure timer metric correct section add code instrumentation detect time thread executes instrumentation code check data structures maintained thread package information dealing asynchrony multiple threads access global instrumentation data simultaneously locks protect global bookkeeping data structures thread preemption interleaving instrumentation code case thread preempted executing instrumentation code instrumentation installed thread context switch routines interleave instrumentation preempted write performance counter timer performance data corrupted making situation worse locks instrumentation code potential deadlock application interesting scenario call self-deadlock scenario occurs instrumenting thread context switches instrumentation code context switch routine requests lock deadlock thread granted lock solve self-deadlock problem introduced lock structure called thread-conscious lock tc-lock lock field holding thread holds lock returns special lock acquisition routine detects thread granted lock instrumentation code tests return tc-lock avoid self-deadlock allowing code handle case table illustrates logic tclock current implementation tc-lock returns simply skip instrumentation section cache column index assigned thread global register greatly reduces dictionary lookups contention locks introduced per-thread virtual timers reduce chance timer data accessed interleaved instrumentation section solution add extra information lock counter timer structures effect communication interleaved instrumentations carry actions previous return state tid state tid held held held held free held table thread-conscious lock thread requests tc-lock held page october timer issues challenge minimize instrumentation cost measuring time-based metrics per-thread basis threads executed lwps measure cpu virtual time individual thread per-lwp timer kernel calls instrument thread context switches account thread context switching migration reduce number calls expensive timer routines introduced per-thread virtual timers thread implement performance timers virtual timers initial lwp newly created thread recorded virtual timer updated thread context switch account thread migration turn virtual timer thread de-scheduled stops performance timers thread turn back thread resumes execution implementing perthread virtual timers reduces number calls expensive timer routines reduces chance timer structure accessed interleaved instrumentation inferior rpc paradyn mechanism called inferior rpc asynchronously trigger instrumentation code inferior rpc start instrumentation execution past point inserted measure cpu function foo insert start-timer code function entry stop-timer code exit executing foo instrumentation request made inferior rpc trigger entry instrumentation start timer paradyn implements inferior rpc pausing application installing inferior rpc code application address space changing program inferior rpc code execute trap instruction installed end inferior rpc code notify paradyn resume application inferior rpc similar call feature debugger complement paradyn dynamic instrumentation threaded program execute inferior rpc code thread thread requires starting timer paradyn control thread executing application performing inferior rpc solution thread execute code behalf thread run inferior rpc achieve passing thread inferior rpc inferior rpc code correct entry thread table perform inferior rpc thread executing perform asynchronous operation asynchrony problems similar instrumenting thread context switches avoid problem created safe inferior rpc paradyn posts inferior rpcs shared memory segment accessible paradyn application base-trampolines check segment pending rpc execute safe time ensures inferior rpc interleave instrumentation refining paradyn resource hierarchy paradyn decouples performance metrics program components user request performance data cpu time spent procedure selecting procedure resource hierarchy performance metric cpu time extend resource hierarchies paradyn include threads number thread-specific synchronization objects condition variables mutex locks read write locks left side figure shows code hierarchy lists procedures shared object libjava middle part page october shows process hierarchy process java chocolate threads side shows resource hierarchy synchronization objects figure shows profiling synchronization waiting time conditional variables individual threads top curve shows conditional waiting time thread thr bottom curve shows conditional waiting time thread thr figure resource hierarchy showing resource hierarchies code process synchronization objects figure fine-grained performance data dividing synchronization waiting time conditional variable individual threads page october instrumentation overhead section describes cost instrumenting threaded code simple benchmarks compares non-threaded paradyn table presents cost basic instrumentation primitives including cost execute base-trampoline increment counter start stop cpu timer costs presented threaded non-threaded paradyn instrumentations systems ultrasparc mhz processor enterprise twelve -mhz processors shown table cost base-trampoline threaded paradyn times nonthreaded version extra costs code added check inferior rpcs calculate column address thread table counter primitives version expensive non-threaded paradyn timer code expensive version level indirection feeling cost instrumentation instrumented simple multithreaded application matrix multiply lines code compared cost instrumenting sequential version machine base trampoline counter start timer stop timer nonthreaded threaded nonthreaded threaded nonthreaded threaded nonthreaded threaded ultrasparc uniprocessor enterprise table micro benchmarks instrumentation non-threaded paradyn sequential version threaded paradyn threaded version ultrasparc processor enterprise ultrasparc processor enterprise processors instrumentation cpu time inclusive program procedure call frequency function innerp cpu time inclusive function innerp table matrix multiply page october algorithm non-threaded paradyn table shows elapsed times versions repeatedly multiplying matrices floating point numbers table measure cpu time inclusive program procedure call frequency cpu time inclusive function innerp 
procedure call frequency innerp calls uniprocessor calls multithreaded version multiprocessor note overhead threaded instrumentation times non-threaded instrumentation instrumentation cost proportional event frequency instrumented frequently called procedure stress test discussion previous sections techniques dynamically instrument threaded programs things make tool usable improve naming threads synchronization objects resource hierarchy relate source level constructs operate directly binary programs information extracted runtime instrumentation threads label start function thread applicationprovided string provided thread packages associating source-level information synchronization objects challenging synchronization object created explicitly calling creation function synchronization object created calling creation routine associate line number source file calling function focused attention correctness instrumentation instrumentation overhead threaded code expensive non-threaded places make instrumentation code efficient collapse logic performance timers perthread virtual timer make timer code efficient hardware timers wall time-based metrics processors provide hardware counters timers performance metrics cache misses branch mispredictions incorporating measurements tool provide users information preliminary experience threaded instrumentation studied performance sun java virtual machine version interpreting appletviewer driven game applet called tetris java boutique ultrasparc uniprocessor machine running solaris tetris applet approximately lines java code tetris applet appletviewer adding include java classes figure shows cpu time individual threads threads threads accounted time thread thr largest threads thr thr invoke functions invokejavamethod invokenativemethod common bottlenecks java profiling functions showed function invokenativemethod total cpu time figure detailed reveals invokenativemethod called thread thr accounting time spent thr figure close examination invokenativemethod thr showed applet delays inserted artificially slow visual behavior obtain demanding load virtual machine removed delays page october time due call sun awt motif graphics drawline figure eliminate redundant code shared monitor enter exit code cut number calls function systhreadself returns information running java thread thread thr figures show number calls systhreadself redundant code elimination result improved performance function sun awt motif graphics drawline elapsed time jvm table performance study ability select performance data individual function individual thread individual function individual thread feature appears unique tool sun awt motif graphics drawline elapsed time original optimized table performance improvements figure cpu time measured per-thread basis total threads thr thr thr accounted cpu time top curve shows cpu time spent program curves showing time spent threads thr thr thr page october figure invokenativemethod takes total cpu time top curve shows cpu time spent program curve showing cpu time spent calling invokenativemethod figure invokenativemethod called thr top curve shows total cpu time spent thread thr middle curve shows cpu time spent calling invokenativemethod program bottom curve shows cpu time spent thr calling invokenativemethod page october figure subdivide invokenativemethod cpu time spent invokenativemethod thr calling sun awt motif graphics drawline small percentage spent real work xdrawline figure calls invokenativemethod systhreadself call invokenativemethod approximately calls systhreadself number calls monitorenter monitorexit xdrawline number calls invokenativemethod page october related work tools developed monitor analyze performance parallel programs tools built multithreaded programs sun workshop thread event analyzer socrates tmon trace-based tools divide performance data threads event analyzer socrates save trace data post-mortem analysis visualization socrates stores trace data database analysis visualization tools sun event analyzer measures file socket memory allocations string usage synchronization visualizes graph table timeline displays socrates event analyzer user select events interest graphical user-interfaces control instrumentation overhead event analyzer instrumentation accomplished shared library interposition instrumentation socrates changing program source code tmon performance tool multithreaded programs developed princeton tmon implements performance metrics higher-level implemented event analyzer metrics tmon implements include thread waiting time building thread waiting graph semi-busy-waiting time tmon supports on-line analysis visualization client-server architecture server side tmon processes traces client side socket tracing sending traces socket incur intrusion large times slow socrates tmon captures thread synchronization events changing source code lightweight user-level thread package gthread trace-based pthread visualization package developed ksr parallel machines debug multithreaded programs gthread involves set animation views depict individual threads movefigure calls systhreadself redundant code elimination eliminating redundant code calls systhreadself cut significantly number calls invokenativemethod increased slightly page october ment functions program shows program features barriers mutexes gthread adds instrumentation program macros replace pthread calls add tracing capability writes tracing data file subsequently visualizer drive animation tool differs tools runtime dynamic instrumentation tracing dynamic instrumentation tool instrument unmodified binary running programs control instrumentation overhead dynamically conclusion paper describes design initial experience non-trace based performance instrumentation techniques threaded programs goal provide detailed performance data maintaining control instrumentation cost main contributions sicmd design divide performance data individual threads techniques handle asynchrony contention instrumenting multithreaded programs sicmd threads share instrumentation private copy performance data approach simplifies instrumentation code reduces locks instrumenting multithreaded programs faces challenges dealing contention asynchrony introduced thread-conscious lock avoid scenario instrumentation deadlock thread per-thread virtual timers reduce number calls expensive timer routines thread context switches per-thread virtual timer reduces chance interleaved instrumentation accessing performance data techniques low-contention data structures caching instrumentation cost threaded program comparable non-threaded program initial implementation sparc solaris including multiprocessor sun ultrasparc enterprise machines show technique speed java native method execution time jvm interpreting appletviewer driven game applet acknowledgments tia newhall helping java jvm matt cheyney ari tamches helping paradyn tia newhall ari tamches brian wylie comments manuscript dan nash suggesting perthread virtual timer members paradyn group helpful discussions miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques san francisco nov felton performance measurements multithreaded programs acm sigmetrics performance loukides oram programming gnu software reilly associates jan ousterhout threads bad idea purposes invited talk usenix conference http scriptics people john ousterhout threads sept vahalla unix internals frontiers prentice hall voss instrumentation measurement multithreaded applications thesis institut fuer mathematische maschinen und datenverarbeitung universitaet erlangen-nuernberg jan narayan multithreaded performance analysis sun workshop thread event analyzer technical white paper april revision page october zhao stasko visualizing execution threads-based parallel programs technical report git-gvu- graphics visualization usability center georgia institute technology atlanta january 
safety checking machine code abstract show determine statically safe untrusted machine code loaded trusted host system safety-checking technique operates directly untrusted machine-code program requiring initial inputs untrusted program annotated typestate information linear constraints approach opens possibility certify code produced compiler source language code producers freedom choosing language write programs eliminates dependence safety correctness compiler final product compiler checked leads decoupling safety policy language untrusted code written makes safety checking performed respect extensible set safety properties host side implemented prototype safety checker sparc machine-language programs applied safety checker examples safety checker prove met safety conditions identify places safety conditions violated checking times ranged seconds ultrasparc machine introduction prevailing trends software development call techniques protect software component trend dynamic extensibility trusted host extended importing executing untrusted foreign code web browsers download plug-ins databases load type-specific extensions operating systems load customized policies performance-measurement code proposals loading application-specific policies internet routers certification safety untrusted code crucial domains trend componentbased software development software components produced multiple vendors construct complete application component-based softwaredevelopment model improves software reusability productivity software components sources proper protection software components essential paper show determine statically safe untrusted machine code loaded trusted host system contrast work enforces safety restricting things expressed source language safe languages certifying compilers typed-assembly languages safe code written source language produced compiler long unsafe expressed machine code philosophical difference implications code producer freedom choosing implementation language building certifying compiler language certify code produced off-the-shelf compiler leads decoupling safety policy language untrusted code written makes safety checking performed respect extensible set safety properties host side short important high-level characteristics safety-checking technique operates directly binary code ability extend host finegrained level foreign code manipulate internal data structures host directly iii enforces default collection safety conditions prevent array out-ofbounds violations address-alignment violations uninitialized variables null-pointer dereferences stack-manipulation violations addition providing ability safety criterion extended access policy host essence approach recover source-level type information precisely typestate information based small amount annotation initial inputs untrusted code apply techniques originally developed program verification determine untrusted code safe initial annotation form typestates linear constraints linear equalities inequalities combined quantifiers analysis typestates opposed types condition safe perform operation function types operation operands states safe write location stores zhichen barton miller thomas reps computer sciences department wisconsin madison zhichen bart reps wisc work supported part department energy grant de-fg nsf grants cdaeia- ccrccr- -israel binational science foundation grant vilas associate award form wisconsin darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon uninitialized unsafe read typestates differ types providing information finer granularity typestate checking differs traditional type checking traditional type checking flow-insensitive analysis typestate checking flow-sensitive analysis typestates related security automata security automaton states accepting states automaton detects security-policy violation read symbol automaton current state transition defined design typestate system captures states security automaton security-violation state typestate checking method statically assessing security violation perform safety checking machine-language programs issues face include design language policies inference typestate program point iii overload resolution machine-language instructions synthesis loop invariants source-level typestates describe state host untrusted code invoked safety policy specifies data accessed functions methods called piece untrusted code extend typestate checking infer typestate program point perform overload resolution induction-iteration method synthesize loop invariants main contributions paper technique opens possibility certify object code produced off-the-shelf compilers independent source language compiler require inputs untrusted code annotated typestate information linear constraints technique extensible addition default collection safety conditions checked additional safety conditions checked host typestates related security automata makes extending technique perform security checking natural extend notion typestate ways typestates describe state information abstract locations abstract storage model extend typestates include access permissions extent untrusted code allowed access host resources iii addition typestates distinguish initialized values uninitialized typestates track pointers finally focusing enforcing fine-grained memory protection decidable logic expressing safety conditions simple heuristics synthesizing loop invariants stress techniques originally developed verification correctness prove total partial correctness safety checking ambitious verification correctness implemented prototype safety checker sparc machine-language programs applied safety checker examples ranging code branches code nested loops code function method calls safety checker prove met safety conditions identify places safety conditions violated times ranging seconds ultrasparc machine section contrary initial intuition observed compiler optimizations loop-invariant code motion improved register-allocation algorithms make task safety checking easier remainder paper organized section describes default safety properties enforce notion host-specified safety policy section overview safety-checking analysis section describes basis safety-checking analysis section describes phases safety-checking analysis greater detail section presents initial experience section discusses related work section discusses limitations technique safety properties policies untrusted code imported host system acceptable behaviors untrusted code behavior specifications form safety conditions include collection default safety conditions host-specified access policies default safety conditions check array outof-bounds violations address-alignment violations uninitialized values null-pointer dereferences stack-manipulation violations inputs safety-checking analysis include untrusted code host-typestate specification aninvocation specification safety policy inputs untrusted code provided host host-typestate specification includes data aspect describes type state host data invocation untrusted code control aspect safety preand post-conditions calling host functions methods terms types states parameters return values linear constraints invocation specification information initial values passed untrusted code invoked host host-specified access policy specifies host data accessed piece untrusted code host functions methods called model view addresses passed piece untrusted code doors host data region safety policy controls memory locations resources accessible pointer types memory locations reachable safety policy specifies ways accessed terms types memory locations contents policy classification memory locations regions list triples form region category access permitted region large entire address space small single variable category field set types aggregate fields access field subset meaning readable writable followable executable operable model properties location properties stored location access permission introduced pointer-typed values pointer dereferenced access permission applies values type pointer function values hold address function function pointed called untrusted code access permission includes rights instructions add overloaded add adding integers adding base address array array index examine copy perform operations covered feel safety policy suppose user asked write extension piece untrusted code finds lightweight process thread running suppose information threads stored host address space linked list defined structure thread struct thread int tid 
int lwpid struct thread policy extension read examine tid lwpid fields follow field stands host region region list threads stored thread tid thread lwpid thread rfo model variety safety policies roughly equivalent sandboxing original sandboxing model partitions address space protection domains modifies piece untrusted code accesses domain model sandboxing boils allowing untrusted code access memory valid addresses untrusted data region examine operate data items type address location host region dereferenced side-effects confined untrusted region approach differs sandboxing purely static make untrusted code sandboxing works situations limit memory accesses untrusted data region forbidding access data host region draconian measure instance access host data region applications simple performance instrumentation read statistics maintained host environment model aggressive policies defined allowing simple reads writes locations host data region forbidding pointers modified policies permit untrusted code follow types valid pointers host data region order traverse linked data structures aggressive policies permit untrusted code change shape host data structure allowing untrusted code modify pointers presented simplified view safety policy reality safety policy include safety postcondition typestates linear constraints ensuring invariants defined host data restored time control returned host overview safety-checking analysis goal verify untrusted code obeys collection default safety conditions accesses data calls host functions manner consistent safety policy introduce abstract storage model default safety conditions host-specified access policy attach safety predicate instruction static analysis determine approximation contents memory locations point program check instruction obeys safety predicate abstract storage model includes notion abstract locations typestates typestate describes type state access permissions stored abstract location divide safety-checking analysis phases preparation typestate propagation annotation local verification global verification illustrate phases informally means simple figure shows piece untrusted code sparc assembly language sums elements integer array shows host-typestate specification safety policy invocation specification host-typestate specification states arr integer array size single abstract location summarize elements array arr safety policy states arr region integers region readable operable base addresses integer array size region readable operable followable invocation specification states arr size arr passed registers code additional registers phase preparation takes host-typestate specification safety policy invocation specification translates initial annotations consist linear constraints typestates inputs figure initial annotations shown figure fact address arr passed register line column fact size arr passed register captured untrusted code host typestate safety policy invocation mov move clr set cmp compare bge branch clr set sll load address cmp compare branch add retl nop int initialized arr int rfo arr int int rfo arr arr integer array size abstract location summarizes elements arr arr region integers region readable operable base addresses integer array size region readable operable followable arr size arr passed registers figure simple summing elements integer array linear constraint note access permissions refer registers untrusted code permitted read change registers array arr overwritten access permission acts surrogate elements arr permission phase typestate propagation takes untrusted code initial annotations inputs annotates instruction abstract representation memory contents characterize state execution instruction phase discovers instruction line array access holds base address array represents index phase annotation takes input typestate information discovered phase traverses untrusted code annotate instruction local global safety preconditions assertions local safety preconditions conditions checked typestate information assertions facts derived results typestate propagation assertions local safety preconditions global safety preconditions instruction line summarized figure phase local verification checks local safety preconditions local safety preconditions true line phase global verification attempts verify global safety preconditions program-verification techniques presence loops induction-iteration method synthesize loop invariants proving line index upper bound safety checker automatically synthesizes loop invariant basis safety-checking analysis section describes abstract storage model safety-checking analysis abstract operational semantics sparc machine-language instructions iii safety predicates attached instructions abstract storage model abstract storage model includes notion abstract locations typestates abstract location summarizes set physical locations safety-checking analysis finitesize domain work general number concrete activation records unbounded presence recursion number concrete objects allocated loop size concrete linked data-structures abstract location size alignment optional attributes location readable writable typestate records properties abstract locations typestate defined triple type state access define meet operation typestates typestates form meet semilattice meet typestates defined meet respective components type system based siff addition abstract types pointers middle arrays alignment size constraints types figure alignment size constraints types shown type denotes pointer points middle array type size meet operation types defined meet non-pointer types meet pointer types meet pointer type non-pointer type meet type type ist meet meet state component typestate captures notion object type state operations state lattice bottom element denotes undefined type figure illustrates selected elements state lattice state descriptors track abstract locations represent pieces stackand heap-allocated storage resemble storage-shape graphs chase access permission subset tuple access permissions abstract location stores aggregate access permission tuple access permissions elements tuple denoting access permissions initial annotations initial typestate initial constraints int initialized int rwfo int initialized rwo figure initial annotations assertions local safety preconditions global safety preconditions address integer array mod null readable writable followable operable array bounds checks mod alignment null-pointer checks null mod figure assertions safety preconditions line ground ground types abstract abstract types pointer base array type size pointer middle array type size ptr pointer struct union function member labeled type offset ground int uint int uint int figure simple type system stands type stands struct union member implementation incorporates notion subtyping ground types makes analysis precise dealing operations load byte load half word respective aggregate fields meet access-permission sets intersection meet tuples access permissions meet respective elements reader puzzled safety policy defined terms kinds access permissions typestates kinds reason properties properties location typestates capture properties values policies permissions abstract locations permissions values typestate lattice includes top element remainder paper absloc denote set abstract locations symbols denote individual abstract locations size align denote size alignment abstract location call abstraction location summarizes physical location summary location register readable writable alignment constant access permission abstract operational semantics sparc machine instructions abstract store total map absloc typestate define abstract operational semantics sparc machine instruction transition function denote type state access component typestate abstract location overload resolution determine typestate abstract location program point finding greatest fixed point set typestate-propagation equations section overload resolution instructions add falls by-product 
process type components typestates obtained arguments overloaded instructions identify register holds scalar pointer base address array instruction add represents addition scalars pointer indirection array-index calculation achieve define abstract operational semantics sparc machine instructions strict typestate checking propagation information instructions loop delayed non-t arrives loop entrance artifact method occurrence overloaded instruction resolved single usage kind scalar addition pointer indirection array-index calculation call single-usage restriction restriction represent significant limitation practice performing typestate checking flow sensitive typestate checking instruction add resolved pointer indirection occurrence instruction array-index calculation occurrence figure portion state lattice scalar type state denote uninitialized initialized values pointer type state state uninitialized pointer non-empty set abstract locations referenced elements null sets define iff aggregate type state states fields null null scalars pointers aggregates operation assumption type-propagation rule state-propagation rule access-propagation rule add opnd scalar add opnd opnd opnd array-index calculation store aggregate field lookup summary location summary location summary location table propagation type state access information propagation type state access information sake brevity table shows rules propagating type state access information kinds add instruction scalar add array-index calculation storing aggregate field registers opnd integer constant register denote absloc denote types abstract location execution instruction define similarly refer possibly empty sequence field names function lookup takes type integers input returns set fields offset size fields exist typestate-propagation rules scalar-add state execution add instruction typestate meet opnd execution typestate abstract locations absloc remain unchanged array-index calculation type destination register type array element type point element array state-propagation rule present single abstract location summarize entire array state destination register source register typestate-propagation rules storing aggregate field divided cases depending strong weak update abstract-location set set locations instruction store pointer point summary location case receives typestate source register pointer point locations summary location case destination receives meet typestate operation typestate source register attachment safety predicates phase safety-checking analysis default safety conditions host-specified access policy results overload resolution attach collection safety predicates instruction safety predicates divided local safety predicates global safety predicates depending predicates validated typestate information table summarizes safety predicates cases add case earlier scalar add safety predicate specifies uninitialized values predicate readable true iff readable predicate operable true iff safety predicates array-index calculation state opnd readable operable index bounds array predicate inbounds size low high true iff low size high size mod size safety predicates state followable valid index field size non-null address properly aligned predicate followable true iff pointer type predicate assignable true iff readable writable align mod align sizeof size hold predicate align true iff elaboration phases safety-checking analysis section expand phases safetychecking analysis array-summation introduced section phase typestate propagation typestate-propagation phase works interprocedural controlflow graphs nodes graph represent instructions edges represent control flow usual create safe approximation program state node node total maps type absloc typestate representing abstract stores algorithm typestate propagation standard worklist-based algorithm starts map program points entry node map entry node incorporates initial annotations generated phase figure abstract locations initial annotations initialized typestate initially instruction untrusted code worklist instruction chosen worklist examined typestates abstract locations entry examined instruction meet typestates exits instruction predecessors instruction interpreted abstractly typestates abstract store exit instruction change case instruction successor operation assumptions local safety predicates global safety predicates add opnd scalar add operable operable opnd add opnd array-index calculation operable operable opnd null inbounds sizeof opnd store aggregate field lookup followable operable forall assignable null forall align align sizeof table attachment safety properties examined instruction added worklist process repeated worklist empty figure shows results typestate propagation applied running column shows instructions left column shows abstract store execution instruction lines correspond loop initially holds base address integer array arr elements summarized holds size array typestate checking initiated placing mov instruction line worklist abstract interpretation mov instruction line sets contents point typestate changed instruction line worklist interpretation clr instruction line sets contents process continues worklist empty line results show holds base address integer array integer index phase verification global safety preconditions phase verifies global safety preconditions program-verification techniques phase involves generating verification conditions vcs verifying vcs theorem prover unlike standard techniques program verification monolithic created properties prove check validity global safety preconditions demand-driven fashion verify conditions time array-bounds null-pointer address-alignment requirements represented linear equalities inequalities theorem prover based omega library omega library represents relations sets presburger formulas formulas constructed combining affine constraints integer variables logical operations quantifiers affine constraints equality inequality constraints presburger formulas decidable details omega library kelly pugh untrusted code involves loops additional step needed synthesize loop invariants system synthesis loop invariants attempted means induction-iteration method extended induction-iteration method synthesize loop invariants natural loops work machine-language programs induction iteration method induction-iteration method weakest liberal precondition wlp heuristic generating loop invariants weakest liberal precondition statement respect postcondition denoted wlp condition statement executed state satisfying true termination terminates condition weaker satisfies weakest liberal precondition differs weakest precondition weakest liberal precondition guarantee termination technique works machine language programs extended induction-iteration method work reducible control-flow typestate untrusted code mov clr cmp bge clr sll cmp add retl nop figure results typestate propagation int rwfoe int int rwo int int rwo int rwfo int rwfo int int rwo rwo int rwfo int int rwo rwo int rwfo int int rwo rwo int rwfo int int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwfo int rwo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwfo int rwo int int rwo int rwo int rwo int rwo int rwfo graphs partition control-flow graph code regions cyclic natural loops acyclic method generating wlps non-conditional instructions generating weakest preconditions compute wlp load store instructions based morris general axiom assignment general framework computing weakest precondition assignments pointer-typed variables compute wlp acyclic code region standard technique verification generation compute wlp natural loop define wlp generated back-substituting postcondition proved entry loop reached wlp 
loopbody define wlp loop-body wlp loop formula denote induction-iteration method attempts find true entry loop loop invariant implies wlp loop-body suzuki ishihata show established showing true entry loop inv inv argument runs assumption implies implies observe equivalent wlp loop-body wlp loop-body wlp loop-body wlp loop-body induction iteration method essence iterates steps create expression current candidate loop invariant generate vcs inv inv attempt verify vcs theorem prover figure shows basic induction-iteration algorithm suzuki ishihata rewritten pseudo code reader puzzled algorithm tests inv tests inv test inv matches test inv performed previous iteration case inv holds vacuously true made enhancements basic inductioniteration algorithm enhancement ability deal multiple loops ensure induction-iteration algorithm terminate presence nested loops extended basic induction-iteration algorithm treat loop differently verify inv case computing wlp loop due synthesis loop invariant outer loop naively testing loop true entry loop record current trial invariant outer loop verify implies procedure calls complicate induction-iteration method ways handling procedure call performing back-substitution reaching procedure entry prove disprove condition iii recursion handle procedure calls back-substitution simply walk body callee inlined caller generate wlp callee function respect postcondition propagated callsite reach entry procedure check conditions true callsite conditions postconditions proven caller simplify matters present system detects rejects recursive programs principle induction-iteration method synthesize invariant entry conditions recursive functions loops conditionals loop weaken extent prevented loopinvariant address problem strengthen computing disjunctive normal form wlp loop-body disjuncts turn rank candidates simple heuristic test potential candidates breadth-first strategy fourth breath-first strategy extended induction-iteration algorithm incorporates technique called generalization introduced suzuki ishihata generalization formula defined elimination elimination fourier-motzkin variable-elimination method eliminate variables set variables generate simplified set constraints integer solution resulting generalizations turn chosen generalized formula conditionals program formula consideration blow-up size exponentially generation reduce effect back-substitution region performed backwards topological order respect program control-flow graph formula junction point simplified strategy effectively controls size formulas considered ultimately time spent theorem prover finally reduce number times induction-iteration algorithm performed back-substitute formulas proven reach loop entry partition formulas groups made comparable constituents invoke induction-iteration algorithm strongest formulas group induction iteration success failure create formula max number iterations switch theorem prover inv true return success switch theorem prover wlp on-entry-to-loop inv true wlp loop-body return failure figure basic induction-iteration algorithm illustrate induction-iteration method applied running control-flow graph program shown figure instructions lines replicated model semantics delayed branches single boolean variable icc model sparc condition code label control-flow graph edge condition edge line number instruction denote instruction sequence line numbers square brackets represent path verify holds line perform backsubstitution starting back-substituting condition line produces instruction line entry natural loop attempt synthesize loop invariant implies set tautology verify true entry loop create formula fact true entry loop shown back-substituting path create perform back-substitution loop body starting formula reach loop entry wlp wlp icc wlp icc wlp wlp formula tautology continuing creating strengthen generalization technique mentioned section steps generalize negating produces eliminating produces iii negating produces set generalized formula case tautology formula create round back-substitution variables modified loop body implies means loop invariant synthesized line invariant implies holds line turn implies holds line discussion section address scalability verification phase discuss potential improvements induction-iteration method major cost verification phase performing induction-iteration method cost determined number iterations performed invariant identified cost iteration step induction-iteration method determined cost perform generation invoking theorem prover costs ultimately determined characteristics untrusted code experience sufficient set maximum allowable number iterations intuition number iteration incorporate conditionals loop iteration test loop invariant information discovered iteration situation loops synthesizing loop invariants outer loop tests loops contribute proof condition outer loop enhancements previous section enhancements principle made existing prototype cache theorem prover represent formulas canonical form previous results tabulation function calls nodes multiple incoming edges reuse previous results vcgen efficient algorithms simple formulas people methods trade generality constraint system efficiency bodik describe method eliminate array-bounds checks java programs method restricted form linear constraints called difference constraints solved efficient graph-traversal algorithm demand wagner formulated buffer overrun detection problem integer constraint problem solved linear time practice finally profitable invariant-synthesis methods conjunction induction iteration induction-iteration method synthesize loop invariants works linear constraints totally mechanical conceivable techniques heuristic methods introduced katz manna wegbreit difference equations method introduced elspas abstract interpretation convex hulls method works forward program control-flow graph potential speed inductioniteration method pushing facts program control-flow graph simple experiments carried demonstrated substantial speedups induction-iteration method figure induction iteration sll cmp mov clr cmp bge clr add retl nop clr add icc icc icc icc selectively pushing conditions involving array bounds program control-flow graph abstract-interpretation method addresses current limitations inferring bounds local arrays arrays structures section initial experience implemented prototype safety checker sparc machine-language programs applied safety checker examples time check examples varies seconds seconds examples include array sum start-timer stop-timer code paradyn suite versions btree traversal version compares keys function call hash-table lookup kernel extension implements page-replacement policy bubble sort versions heap sort manually inlined version interprocedural version stack-smashing smith paper update message-digest algorithm java jpvm addhosts jpvm jpvm java native interface pvm java platform java native interface jni native-programming interface java code runs inside java virtual machine interoperate applications libraries written programming languages assembly jpvm verify calls jni methods pvm library functions safe obey safety preconditions section examples written compiled gcc version experiments find safety violation implements page-replacement policy attempts dereference pointer null identified array out-of-bounds violations stack-smashing figure summarizes time needed verify examples mhz sun ultra machine times divided times perform typestate propagation create annotations perform local verification perform global verification characterizes examples terms number machine instructions number branches number loops total versus number loops number calls total versus number calls trusted functions number global safety conditions time check examples ranges seconds seconds current approach major limitations untrusted code local arrays infer bounds stack-smashing update programs annotate stackframes functions local arrays similarly structures multiple arraytyped fields analysis find array pointer points address limitation forward pass cousot halbwachs propagate preconditions forward find information bounds local arrays disambiguate pointers point arrays structures analysis lose precision due array recall single abstract location summarize elements array model pointer array base arbitrary array element pointer 
point summary location analysis loses precision determine assignment kills elements array analysis reported actual parameters host methods functions undefined jpvm fact defined dependence-analysis techniques parallelizing compilers address limitation type system paper restrictive incorporate notion subtyping structures pointers analysis lose precision certifying programs written object-oriented style experience date make observations compiler optimizations loop-invariant code motion improved register-allocation algorithms make task safety checking easier memory-usage analysis part typestate checking lose precision instructions access memory registers job register allocation precise sum aging olicy start imer hash bub ble sort stop imer btr btr heap sort heap sort jpvm stacksmashing number eatur instructions branches loops loops procedure calls global safety conditions ime seconds typestate propagation annotation local verification global verification total figure characteristics examples performance results trusted function host function function trust check calls trusted function obey safety preconditions function typestate information recovered loop-invariant code motion makes induction iteration efficient making loops smaller simpler compiler optimizations strength reduction optimizations address-calculations complicate task global verification hide relationships induction-iteration method standard techniques overcome limitation strategies makes induction-iteration method effective conditions loop pollute wlp loop-body compute disjunctive normal form wlp loop-body disjuncts turn rank potential candidates simple heuristic test candidate breadth-first strategy depth-first finally forward propagation information array bounds substantially reduce time spent induction-iteration method reduces time needed verify true entry eliminates generalization synthesize loop invariant verifying interprocedural version untrusted program time verifying manually inlined version manually inlined version replicates callee functions global conditions callee functions place analysis benefits procedure abstraction related work projects investigating topics related safetychecking technique approaches projects range statically identifying common programming errors statically ensuring type safety run-time checking security properties projects closest proof-carrying code pcc touchstone certifying compiler typedassembly language tal proof-carrying code pcc code producer generate code proof code safe verification safety untrusted code carried small proof checker manual generation proofs tedious error-prone certifying compiler automates generation pcc compiler generate code carries proofs touchstone prototype certifying compiler compiles safe subset machine code carries proofs type safety morrisett introduced notion typed assembly language tal approach type information high-level program incorporated representation program platform-independent typed intermediate form carried series transformations level target code compiler type information perform sophisticated optimizations internal errors compiler detected invoking type-checker code transformation compiler typed assembly language certifies type safety ensuring well-typed source program maps well-typed assembly program prominent difference approach certifying compiler tal approach philosophical certifying compiler approach enforces safety preventing bad things expressible source language safe subset touchstone compiler popcorn language talx pointer arithmetic pointer casting explicit deallocation memory contrast safe code written language produced compiler long bad code philosophical difference implications code producer freedom choose language including unsafe languages assembly freedom produce code off-the-shelf compiler manually eliminates dependence safety correctness compiler pcc technique checks safety final product compiler leads decoupling safety policy source language turn makes safety checking performed respect extensible set safety properties host side important difference approach certifying compiler tal approach safety properties enforce based notation typestate information finer granularity types finally touchstone popcorn compiler track aliasing information introduced abstract storage model extended typestate checking track pointers result analysis provide precise popcorn touchstone addition high-level differences technical differences noted safety checker viewed certifier generates proofs recovering type information existed source-language program embodiment suggestion made necula lee approach safety checker differs touchstone compiler respects touchstone replaces standard method generating vcs formulas pushed backwards program forward pass program combines generation symbolic execution contrast system forward phase typestate checking kind symbolic execution fairly standard backward phase generation vc-generation phase backwards pass program usual reason advantage propagating information backwards avoids existential quantifiers arise formulas pushed forward direction generate strongest postconditions forward vc-generation phase quantifiers accumulate forcing work larger larger formulas safety-checking analysis mechanically synthesizes loop invariants bounds checking alignment checking touchstone generates code explicit bounds checks removes checks prove redundant comparing tal type system tal richer sense model language features considered including exceptions type variables existential types type system support general pointers stack stack heap pointers unified function taking tuple argument passed heap-allocated stack-allocated tuple talx introduce special macros array subscripting updating prevent optimizer rescheduling macros expand code sequences perform bound checks impose restrictions tal restrictive pcc pcc suggests relevant operational content simple type systems encoded extensions first-order predicate logic type system closer spirit pcc provide meta language describe types including size alignment constraints tal achieve flow-sensitivity label blocks code functions assign types registers level basic blocks achieve flow-sensitivity traditional dataflow-analysis techniques results pointer-analysis community straightforward differences interesting note safety checker programs written typed assembly language untyped machine language work required recover type information perform overload resolution propagate state access information applies java bytecode type information contained bytecode instructions static debugger static analysis find unsafe operations guarantee safety detlefs describe static checker common programming errors array index out-of-bounds null-pointer dereferencing synchronization errors multi-threaded programs common approach analysis makes linear constraints automatically synthesizes loop-invariants perform bounds checking parameterized policy specification safetychecking analysis works source-language programs makes analyses sound complete policy specifications user-supplied modifies lists variables procedure modified offer degree access control access policies terms regions categories access permissions general mechanism leroy rouaix proposed theoretical model systematically placing type-based run-time checks interface routines host code technique differs respects dynamic checks host untrusted code requires source host api safety requirements enumerating set predetermined sensitive locations invariants locations model safety policy general finally perform type checking perform typestate checking limitations main limitation technique enforce safety properties expressible typestates linear constraints excludes liveness properties safety properties analysis flow-sensitive interprocedural analysis propagate typestate information verification phase fairly costly due synthesize loop invariants prove safety predicates scalability analysis remains evaluated bigger applications static techniques technique incomplete analysis loses precision handling array single abstract location summarize elements array existing prototype infer bounds local arrays annotate stackframes functions local arrays induction-iteration method incomplete linear constraints induction-iteration method prove correctness array accesses loop correctness depends data values set execution loop sentinel end array speed sequential search generalization capabilities system fall short problems care memory safety induction-iteration method fail cases loop invariant strengthened point end verifying large part partial correctness algorithm fourth type system incorporate notion subtyping structures pointers 
hurt certifying programs written object-oriented style principle define meet operation structures terms physical subtypes struct initial prefix struct define meet pointer types ptr ptr ptr typestate-checking algorithm extended track pointers mutable discussion subtyping presence mutable pointers finally analysis deal unconventional usages operations swapping non-integer values means exclusive operations limitations method shows promise limitations represent potential research opportunities future research make analysis precise efficient continued engineering make technique practical larger programs acknowledgments rastislav bodik jianjun chen brian wylie ari tamches philip roth feedback paper anonymous referees comments substantially improved technical quality readability paper abadi cardelli theory objects monographs computer science gries schneider springerverlag york bershad savage pardyak sirer fiucynski becker eggers chambers extensibility safety performance spin operating system symposium operating system principles copper mountain december alpern schneider recognizing safety liveness distributed computing bodik gupta sarkar abcd eliminating array bounds checks demand sigplan conference programming language design implementation vancouver canada june chase wegman zadeck analysis pointers structures sigplan conference programming language design implementation york chiueh venkitachalam pradhan integrating segmentation paging protection safe efficient transparent software extensions acm symposium operating systems principles charleston december cousot halbwachs automatic discovery linear restraints variables program annual acm symposium principles programming languages tucson january detlefs leino nelson saxe extended static checking research report compaq systems research center palo alto december dijkstra discipline programming prentice-hall englewood cliffs elspas green levitt waldinger research interactive program-proving techniques sri menlo park california engler kaashoek toole exokernel operating system architecture application-level resource management symposium operating system principles copper mountain december hoare axiomatic basis computer programming communications acm october illustra information technologies illustra datablade developer kit architecture manual release javasoft java native interface specification release jpvm native methods interface pvm java platform http chmsr gatech jpvm katz manna heuristic approach program verification international conference artificial intelligence august kelly maslov pugh rosser shpeisman wonnocott omega library version interface guide omega umd http umd projects omega november leroy rouaix security properties typed applets acm sigplan-sigact symposium principles programming languages san diego january lindholm yellin java virtual machine specification edition http java sun docs books vmspec ndedition html vmspec toc doc html mccanne jacobson bsd packet filter architecture user-level packet capture winter usenix conference usenix association san diego january misrosoft microsoft technologies-information resources component object model-based technologies http microsoft march miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november mogul rashid accetta packet filter efficient mechanism user-level network code acm symposium operating systems principles austin november morris general axiom assignment theoretical foundations programming methodology lecture notes international summer school directed bauer dijkstra hoare manfred broy gunther schmidt reidel publishing company morrisett tarditi cheng stone harper lee til compiler performance safety types workshop compiler support systems software tucson february morrisett walker crary glew system typed assembly language annual acm symposium principles programming languages san diego january morrisett crary glew walker stack-based typed assembly language workshop types compilation published xavier leroy atsushi ohori editors lecture notes computer science springerverlag morrisett crary glew grossman samuels smith walker weirich zdancewic talx realistic typed assembly language acm workshop compiler support system software atlanda muchnick advanced compiler design implementation morgan kaufmann publishers necula compiling proofs dissertation carnegie mellon september necula lee design implementation certifying compiler acm sigplan conference programming language design implementation montreal canada june necula proof-carrying code annual acm symposium principles programming languages paris france january netscape browser plug-ins http home netscape plugins index html audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating systems principles copper mountain december pugh omega test fast practical integer programming algorithm dependence analysis supercomputing albuquerque november pugh wonnacott eliminating false data dependences omega test acm sigplan conference programming language design implementation san francisco june pugh wonnacott experience constraint-based array dependence analysis technical report cs-truniversity maryland redell dalal horsley lauer lynch mcjones murray purcell pilot operating system personal computer communications acm february rivest message-digest algorithm request comments mit laboratory computer science rsa data security april schneider fault-tolerant secure agentry international workshop distributed algorithms saarbr cken germany september seltzer endo small smith dealing disaster surviving misbehaved kernel extensions usenix symposium operating systems design implementation seattle october siff chandra ball kunchithapadam reps coping type casts seventh european software engineering conference seventh acm sigsoft symposium foundations software engineering toulouse france september smith stack smashing vulnerabilities unix operating system http destroy net machines security strom yellin extending typestate checking conditional liveness analysis ieee transactions software engineering strom yemini typestate programming language concept enhancing software reliability ieee transactions software engineering january small seltzer comparison extension technologies usenix annual technical conference san diego january stonebraker inclusion types relational data base systems readings database systems edition michael stonebraker sun microsystems java plug-in overview http java sun products indexhtml october susuki ishihata implementation array bound checker acm symposium principles programming languages los angeles january tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating system design implementation orleans february tamir adi automatic derivation invariants ieee transactions software engineering sejanuary tennenhouse wetherall active network architecture computer communication review april wegner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed systems security conference san diego february wegbreit synthesis loop predicates communications acm february wahbe lucco anderson graham efficient software-based fault isolation symposium operating system principles asheville december 
performance measurement interpreted programs tia newhall barton miller computer sciences department wisconsin madison abstract interpreted execution interdependence interpreter execution interpreted application execution implementation interpreter determines application executed application triggers activities interpreter present representational model describing performance data interpreted execution explicitly represents interaction interpreter application terms interpreter application developer view execution present results prototype implementation performance tool interpreted java programs based model prototype techniques dynamic instrumentation transformational instrumentation measure java programs starting unmodi ced java class cles unmodi ced java virtual machine performance data tool tune java program result improve performance factor introduction interpreted execution execution program interpreted application interpreter application code input interpreter interpreter executes application examples include justin-time compiled interpreted dynamically compiled simulator executions performance measurement interpreted execution complicated interdependence execution interpreter execution application implementation interpreter determines application code executed application code triggers interpreter code executed present representational model describing performance data interpreted execution model characterizes interaction application developer inside interpreter understand fundamental costs application execution interpreter developer characterize interpreter execution terms application workloads model concrete description behaviors interpreted execution point needed implement performance tool measuring interpreted executions implementation model answer performance questions speci interactions interpreter application appears proceedings euro-par represent performance data javainterpreter activities thread context switches method table lookups garbage collection bytecode instruction execution berent method functions java application present results prototype implementation model measuring performance interpreted java applications applets prototype tool paradyn dynamic instrumentation dynamically insert removeinstrumentation java virtual machine javamethod byte-codes byte-code interpreted java virtual machine tool requires modi ccations java virtual machine java source class cles prior execution eculties measuring performance interpreted codes demonstrated comparing interpreted code execution compiled code execution compiled code form executed directly operating system farchitecture platform performance tools compiled code provide performance measures terms platform-speci costs executing code process time number page faults blocking time examples platform-speci measures contrast interpreted code form executed interpreter virtual machine interpreter virtual machine application program executes operating system farchitecture platform obvious berence compiled interpreted application execution extra layer interpreter program part determines application performance figure performance tool measuring performance interpreted execution measure interaction application layer interpretervm layer potentially berent program developers interested performance measurementofthe interpreted execution virtual machine developer application program developer performance data terms platform-speci costs executing parts program views platform program berentlayers interpreted execution developer sees input program run platform layer left side interpreted execution figure developer sees application layer program run side interpreted execution figure developer means characterizing virtual machine developer view platform arch application compiled execution platform application platform input interpreted execution application platform application developer view interpretervm arch fig compiled application execution interpreted application execution developers view interpreted execution berently performance terms platform layer costs program execution input amount process time executing function invokemethod interpreting method foo application program developer performance data measures interaction decned terms vm-speci costs execution amount method call context switch time method foo characteristic interpreted execution application programhasmultiple executionforms bymultiple executionformswe meanthat code transformed form forms executed java class read javavmin class cle format transformed internal form java executes bers compiled code application binary modi ced executes model characterizes transformations measurable event code execution represent relationship berent forms code object performance data measured form code object mapped back viewed previous forms object performance measurement model present representational model describing performance data interpreted execution explicitly represents interaction application program virtual machine model addresses problems representing interpreted execution describing performance data interpreted execution language virtual machine developer application program developer understand representing interpreted execution representation interpreted execution based paradyn representation program execution set resource hierarchies resource physical logical component program semaphore function process examples program resources resource hierarchy collection hierarchically related program resources process resource hierarchy views running program set processes consists root node represents processes application number child resources process running program examples resource hierarchies code hierarchy code view program machine hierarchy set machines application running synchronization hierarchy set synchronization objects application application execution represented set resource hierarchies fprocess machine code syncobjg individual resource represented path root node function resource main represented path fcode fmain fmain path represents relationship resources objects code hierarchy code threads monitors mon mon tid tid tid blah foo main foo codemachine process syncobj cham grilled main blah msg tag syncobj pid pid virtual machine pid application program fig resource hierarchies virtual machine application program application program virtual machine viewed executing programs represent executions set resource hierarchies execution represented fcode thread syncobjg half figure virtual machine execution represented fmachine process code syncobjg left half figure resource hierarchies cgure represent executions separately interaction execution represented relationship virtual machine input runs represent runs relationship interaction program resources code process synchronization objects virtual machine interact code process synchronization objects application programduring interpreted execution interpreted execution union resource hierarchies figure interpreted execution represented fmachine code process syncobj apcode apthreads apsyncobjg application program multiple execution forms represented set sets resource hierarchies bone set forms takes execution set mapping functions map resources form resources form dynamically compiled java application method functions translated byte-code form native code form execution initially create code hierarchy byte-code form run-time transformations occur create code hierarchy native form objects create mapping functions map resources form resources form codemachine process syncobj cham grilled main blah msg tag monitors mon mon tid tid tid blah foo main foo pid pid pid runs apcode apthreads apsyncobj fig resource hierarchies representing execution runs representing points interpreted execution program execution series events executing instruction waiting synchronization primitive accessing memory page examples events anyevent program execution represented subset active resources resources involved event event cprocess executing code function foo resource fcode fmain ffoo resource fprocess fpid active activity occurring single resource selections resource hierarchy called constraints activity speci ced constraint active constraint function true cnition constraint single resource selection resource hierarchy represents restriction hierarchy subset resources cnition constraint function constrain boolean function resource true active constrain fprocess fpid true process active running constraintfunctions areresource-speci allconstraintfunctions testwhether resource argument active type test depends type resource argument constraint function process resource test speci ced process running constraint function function resource test program counter function resource hierarchy exports constraint functions resources hierarchy code 
fine-grained dynamic instrumentation commodity operating system kernels abstract developed technology fine-grained dynamic instrumentation commodity kernels splice insert dynamically generated code machine code instruction completely unmodified running commodity operating system kernel technology well-suited performance profiling debugging code coverage security auditing runtime code optimizations kernel extensions designed implemented tool called kerninst performs dynamic instrumentation stock production solaris kernel running ultrasparc top kerninst implemented kernel performance profiling tool understand kernel application performance web proxy server workload information make kernel proxy cumulatively reduce percentage elapsed time proxy spends opening disk cache files introduction operating system kernels complex entities internals difficult understand measure optimize recently extensible kernels spin exokernel vino designed applications extend functionality kernel policies synthetix specialized versions kernel functions installed runtime providing dynamic optimization design proposed self-measuring self-adapting extensible kernel work performed customized kernels difficult evaluate real-world programs workloads paper introduces finegrained dynamic kernel instrumentation low-level technology arbitrary code spliced inserted kernel machine code location runtime dynamic kernel instrumentation runtime measurements optimizations extensions performed unmodified commodity kernels paper provide motivation fine-grained dynamic kernel instrumentation describe dynamically instrument unmodified commodity kernel show kernel profiler dynamic instrumentation two-way benefit insight kernel application performance show information optimize web proxy server discuss safety security issues introduced finegrained dynamic kernel instrumentation dynamic instrumentation supports monitoring functionality debugging profiling alongside mechanisms extensibility adaptability single infrastructure kernels evolving entities measure adapt accommodate real-world runtime usage patterns main contribution work design implementation fine-grained splicing mechanism stock commodity kernel contents inserted code performance profiling annotations optimized versions functions process-specific kernel extensions orthogonal issue splice commodity kernel implemented kerninst instrumentation tool solaris kernel main features fully dynamic kerninst loaded instruments running kernel recompile reboot pause kernel fine-grained instrumentation points locations code spliced machine code instruction kernel contrasts kernels coarser-grained code function granularity vino synthetix entire kernel modules changed commodity kernels runs commodity kernel immediately run real-world programs runs unmodified kernel ultrasparc system running solaris immediately kerninst ariel tamches barton miller computer sciences department wisconsin madison tamches bart wisc work supported part department energy grant de-fg nsf grants eiaand cdaand darpa contract -cthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon applications dynamic kernel instrumentation section describes applications finegrained dynamic instrumentation unmodified commodity kernels performance profilers dynamic instrumentation insert performance-gathering code annotations incrementing counter start function basic block annotation code start stop timers access hardware performance counters complex code sequences control structures predicate measurements kernel state running process detail dynamic kernel instrumentation performance profiling presented section dynamic instrumentation kernel tracing splicing logging code desired kernel code locations runtime desired trace collected kernel code restored original contents overhead incurred tracing desired contrasts static kernel instrumentation system binary rewriter insert code lasting entire run kernel code coverage measured splicing code sets flag basic block indicating code reached instrumentation basic block removed flag set overhead code coverage decreases time basic block coverage demonstrates instrumentation fine-grained kernel debuggers implemented finegrained dynamic instrumentation breakpoints inserted machine code instruction splicing code displays kernel state optionally pauses executing thread informs debugger conditional breakpoints easily accommodated predicating breakpoint condition security auditing annotations installed dynamic instrumentation solaris audit thread creation deletion file system pathname lookups file system vnode creation successful unsuccessful credential checks super-user access process forks core dumps stream device operations file opens closes chdirs auditing code turned default turning requires kernel recompile reboot dynamic instrumentation auditing package distributed independent kernel add-on installed running system requires fine-grained splicing mechanism auditing checks place middle kernel functions dynamic instrumentation enables automated runtime code optimization based performance feedback gathered dynamic profiling annotations function specialization input parameter function dynamically instrumented collect histogram desired parameter examined frequent annotation code removed specialized version function machine code generated constant propagation applied specialized parameter function code spliced entry input parameter equals common jump optimized version fall original version optimization bypass check sites function called examined actual parameter equals specialized call site altered directly call optimized version function moving seldom-executed basic blocks line improve instruction-cache behavior performed fine-grained dynamic instrumentation function entry exit point annotated measure number icache misses incurs high function basic blocks instrumented count execution frequency optimized version function infrequently executed blocks moved line installed splicing code entry original function unconditionally jump optimized version parameter specialization extra jump overhead eliminated altering sites function called dynamic kernel instrumentation change kernel functionality installing process-specific version kernel policy extensible operating systems download process-specific code kernel improved performance perform kind adaptation dynamic instrumentation easily provide similar operation commodity kernel splicing code desired kernel function executing process equals customized pid jump customized version patch area fall applications dynamic kernel instrumentation varying requirements kernel source code kerninst kernel runtime symbol table function names starting locations memory control flow graph basic blocks machine code level information applications readily identify machine code locations function entries exits function calls benefit working machine code effect compiler optimizations reorder remove code visible applications require information kernel kernel developer dynamic kernel instrumentation trace specific source code line compiler debugging line number information map line numbers kernel addresses fortunately kernel developers access information applications require knowing names specific kernel functions application wanting profile file system pathname-to-vnode translation solaris relevant function lookuppn end users application applications work solely information kerninst optimizer moves seldom-executed basic blocks line run-time works machine code level mechanisms dynamic kernel instrumentation process splicing dynamically generated code sequences points kernel code space splicing overwrites machine code instruction instrumentation point jump patch code kerninst fine-grained instrumentation points machine code instruction kernel discuss exceptions section section code patch dynamically generated code inserted overwritten instruction jump back instruction instrumentation point net effect splicing insert dynamically generated code kernel machine code instruction important feature dynamic instrumentation splicing independent code generation kerninst splice machine code created code generation packages vcode interpreter performing just-in-time compilation precompiled position-independent code structure kerninst system shown figure applications instrument kernel interact kerninstd user-level daemon small runtime-loaded kerninst driver dev kerninst run-time allocated patch area heap runtimeallocated heap timers counters instrumentation code performance-gathering annotations kerninstd maps heaps address space mmap dev kmem minimize tool presence kernel functionality kerninstd perform actions kernel address space kerninstd enlists assistance dev kerninst 
constrain fcode fmain constraint function applied code hierarchy resource main constraint functions combined create boolean expressions constraints resource combining constraint resource hierarchy operator represent berent activities running program representation called focus cnition focus selection resources resource hierarchy represents activity running program focus active resources active constraint functions focus resources cned resource hierarchies represents speci part virtual machine execution application program fmachine fcode fmain finvokemethod fprocess fpid fsyncobj fapcode ffoo class ffoo fapthreads fapsyncobj focus figure represents process executing function invokemethod interpreting method foo activity occurring constraint functions true performance data interpreted execution describe performance data measure interaction application program virtual machine provide mechanism selectively constrain performance information part execution complementary occasionally overlapping ways constraints implicitly speci ced metric functions explicitly speci ced foci metric function time-varying function measures aspect program execution performance metric functions consist time count functions combined boolean expressions built constraint functions constraint operators cputime dprocesstime fsec amount process time methodcalltime bcode constrain fcode fmain finvokemethod processtime fsec time spent function invokemethod wait bcode constrain fcode flibc fread code constrain fcode flibc fwrite walltime fsec time spent reading writing secondwayto constrainperformancedata foci represent restricted locations execution foci resources representaninteractionbetween andap focus fcode fmain ffetchcode fapcode ffoo class ffoo represents part execution virtual machine fetching code object foo part execution active bcode constrain fcode fmain ffetchcode apcode constrain fapcode ffoo class ffoo true combine metric functions focus represent performance data speci ced interaction represent performance data metric-focus pairs operator combine metric focus metric focus pairs show components focus cned hierarchy root node cputime fapcode ffoo class ffoo processtime fsec bapcode constrain fapcode ffoo class ffoo cputime fcode fmain finvokemethod fapcode ffoo class ffoo processtime fsec bcode constrain fcode fmain finvokemethod apcode constrain fapcode ffoo class ffoo methodcalltime fapcode ffoo class ffoo bcode constrain fcode fmain finvokemethod processtime fsec bapcode constrain fapcode ffoo class ffoo measures amount process time spent function foo performancemeasurements examples identical measure amount process time spent function invokemethodwhile interpreting function foo represented form developer represented form developer vm-speci metric vm-speci metric functions measure activities speci virtual machine designed present performance data developer mayhave knowledge virtual machine encode knowledge virtual machine representation closer semantics application language developer measure costs execution program details implementation methodcalltime metric encodes information function invokemethod compute cnal issue representing performance data foci application program resources object form performance data viewable forms mapping functions map performance data measured form object logical view object forms measuring interpreted java applications present tool measuring performance interpreted java applications applets running sun version javavm tool implementation model representing performance data interpreted execution java abstract stack-based processor architecture java program consists set classes compiled class cle method function compiled byte-code instructions executes measure performance interpreted java application applet performance tool discovers java program resources loaded generates inserts sparc instrumentation code java routines generates inserts javabyte-code instrumentation java methods triggers java execute instrumentation code javavmperforms delayed loading class cles classes loaded point execution insert instrumentation code noti ces tool class cle loaded parse internal form class create application program code resources class point instrumentation requests made class metric bfocus pairs class resources dynamic instrumentation insert delete instrumentation java method code javavmcode pointintheexecution dynamic instrumentation technique instrumentation code generated heap branch instruction inserted function instrumentation point instrumentation code function instructions replaced branch relocated heap executed instrumentation code sparc instruction set instructions save restore stack frames instrumentation code relocated instructions execute stack frames instrumentation code destroy values function stack frame technique instrumentjava methods complicated fact method byte-code instructions push pop operands operand stack java instrumentation code operand stack execution stack frame java instruction set instructions explicitly save restore execution stack frames create operand stacks solution technique called transformational instrumentation technique forces java create operand stack execution stack frame instrumentation code transformational instrumentation steps crst time instrumentation request made method relocate method byte-code heap expand size adding nop byte-code instructions instrumentation point nop instructions replaced branches instrumentation code execute relocated method byte-code replacing crst bytes original method goto byte-code instruction branches relocated method goto instruction inserted veri ced method byte-code legal execute instruction branches original method function generate instrumentation code heap generate sparc instrumentation code heap java native methods facility call instrumentation code java method byte-code insert method call byte-code instructions relocated method call native method function execute instrumentation code implicitly create execution stack frame stack instrumentation code results present results running java application performance tool applicationis acpu schedulingsimulatorthat consistsof elevenjavaclasses approximately lines java code represent performance data terms program resources code resources combination program resources foci vm-speci metrics describe interaction figure shows resource hierarchies interpreted execution including separate code hierarchies began cpu utilization program account part cpu time due method call context switching object creation java measure created vm-speci metrics methodcall measures time java perform method call context-switch obj create measures time java create object result interpreting byte-code instructions measured values program focus constraints result found fig resource hierarchies interpreted execution fig time histogram showing cpu utilization object creation time method call context switching time graph shows methodcall context switching time object creation time account total cpu time large portion total cpu time spent handling method context switching object creation figure results crst reduce method call context switching time in-lining method functions figure shows method functions accounting cpu time largest number method function calls found nextinterrupt isbusy methods device class called accounting large amount total cpu time examining code found sim method called frequently methods return private data member good candidates in-lining changing code in-line calls method functions total number method calls decreased total execution time decreased rowintable reduce object creation time examined cpu time version code found sim device job stringbuffer classes accounted cpu time time spent stringbuffer methods due large number calls append constructor methods made sim device classes reduce number stringbuffer string objects created removing strings created creating static data members parts strings recreated multiple times device stop device start reduce total execution time fourth rowintable cpu enabled java class due executing java code method call context switching instrumentation overhead fig classes methods account largest cpu left called frequently 
crst column lists focus column lists metric focus table performance results berentversions application optimization number number total execution method calls object creates time seconds original version method in-lining change fewer obj creates change change tool provided performance data ecult obtain performance tools tool provided performance data expensive interactions java java application accounted costs terms resources data easily determine make java application improve performance related work general purpose program performance measurement tools measure performance virtual machine unable present performance data terms application program terms interaction performance tools provide performance data terms execution tools provide performance data terms java application code represent performance data terms java execution terms interaction java application time values provided tools include java method call object creation garbage collection thread context switching class cle loading activities performance data explicitly represents interaction java java application execution application developer determine tune application conclusion future work paper describes approach performance measurement interpreted executions explicitly models interaction interpreter program interpreted application program performance data part execution performance data represented terms application program developer interpreter developer understand working expand prototype include larger set vm-speci metrics thread synchronization resource hierarchies support mapping performance data berent views code objects support thread synchronization resources tool provide performance data multi-threaded java applications acknowledgments marvin solomon providing cpu simulator java application work supported part darpa contract -cnsf grant cdaand department energy grant de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon intuitive systems optimize http fwww optimizeit group jprobe http fwww klg fjprobe malony mohr beckman gannon yang bodin performance analysis portable data-parallel programming system scalable parallel computers proceedings international parallel processing symposium ipps cancun mexico pages april miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance anlysis environment proceedings scalable parallel libraries conference pages ieee computer society sun microsystems computer corporation java virtual machine speci ccation august yan performance tuning aims automated instrumentation monitoring system multicomputers hawaii international conferenceon system sciences wailea hawaii pages january article processed macro package llncs style 
section discusses kerninst performs finegrained dynamic instrumentation commodity operating system kernel present specific examples current solaris implementation dynamic kernel instrumentation modern operating systems bootstrapping kerninst kernel instrument running kernel kerninstd allocate patch area heap parse kernel runtime symbol table obtain permission write portion kernel address space code patches hold dynamically generated code inserted allocated patch area heap kernel address space kerninstd allocate kernel memory dev kerninst perform kmem alloc ioctl instrument kerninstd functions reside memory access kernel runtime symbol table symbol table disk kernel unix insufficient incomplete kernel contained runtime-loaded modules dev kerninst reads kernel runtime symbol table directly kernel memory behalf kerninstd solaris similar interface driver dev ksyms label functions kernel module emitting code patch area splicing require write permission kernel address space kerninstd writes patch area heap directly mapped address space mmap dev kmem splicing existing kernel code difficult solaris operating systems parts kernel code modified kernel specifically solaris kernel modules collectively termed kernel nucleus written ultrasparc platforms mapped i-tlb read-only permission write code nucleus dev kerninst maps page figure kerninst system architecture kerninstd acts instrumentation server performing kernel instrumentation requests arrive applications dev kerninst kerninstd kernel address space timers heap patch area heap countersioctl application dynamic kernel instrumentation kernel profiler tracer optimizer instrumentation request solaris kernel modules unix architecture-specific part kernel krtld kernel runtime linker genunix architecture-independent part kernel segkmem mapin performs write unmaps segkmem mapout structural analysis dynamic code generators perform machine code transformations compiler runtime benefit greatly information compilers linkers discard part symbol tables control flow graphs live register analysis kerninstd constructs similar information analyzing kernel in-core machine code creating interprocedural control-flow graph basic blocks finding live registers basic block kerninstd builds control flow graph kernel machine code partitioning functions basic blocks graph needed performing live register analysis dynamic code generation splicing source code debugging information process runtime symbol table parsed determine in-memory start kernel functions function machine code read memory parsed basic blocks basic block ends instruction potentially interrupts program control flow function call encountered jump tables jumps constant addresses determined backwards slice register jump register-relative jumps marked unanalyzable kerninst controlflow graph construction similar binary rewriters user programs eel atom kerninst performs processing runtime code including runtime-loaded modules controlflow graph interprocedural aggressive data-flow analyses kerninstd performs interprocedural live register analysis kernel code basic block set live registers entry calculated stored code generation splicing conserve storage kerninstd store live registers kernel machine code instruction fine-grained analysis performed instrumentation needed figure summarizes code components solaris running ultrasparc kerninst performs one-time structural analysis efficiently shown figure structural analysis optimized making results persistent recalculated kernel module loaded unloaded start-up processing time seconds pursued optimization code generation issues code generation splicing phases dynamic instrumentation decoupled kerninstd splice code generated runtime code generator coordinate kerninstd overwrite registers kerninstd free instrumentation point emit machine code directly memory location kerninstd vcode code generator fits model interpreters runtime compilers statically generated positionindependent code instrumentation runtime kerninstd resolves procedure calls brackets code register spills ensure free registers overwritten unlike compiler kerninst concerned inserting splicing generated code midst existing kernel code safety dynamically generated code write registers free live information instrumentation point registers required free kerninstd brackets code stack frame set-up tear-down free additional registers sparc involves emitting save restore instructions instructions safely executed trap handlers register window overflow underflow kerninstd instrument routines figure lists kerninstd dynamic instrumentation steps section describes live register analysis allocating patch hold generated code code generation step live register analysis determines registers scratch instrumentation point finding live registers classic backwards data-flow problem operating control-flow graph set live registers top basic kernel component number modules functions basic blocks instruction bytes figure solaris kernel overview structural analysis step time kernel runtime symbol table dev kerninst sec parse functions basic blocks create cfg sec perform live register analysis basic block sec total sec figure structural analysis one-time start-up costs instrument routines explicitly saving live registers stack making sparc register window save restore instructions plan add feature future version kerninstd block calculated stored kerninstd structural analysis start-up phase finding live registers instruction basic block quickly free registers point live live register analysis averages current implementation step code generation allocates patch space hold dynamically generated code patch size sum size machine code inserted extra instructions spill registers stack scratch registers needed space original instruction instrumentation point space jump back instruction instrumentation point pieces instrumentation inserted instrumentation point kerninstd simply compounds code patch rule code patch spliced instrumentation point code sequences varying number instructions returning jump depending required displacement number instruction bytes required code patch determined allocated circular dependency broken assuming maximum number instructions needed perform jump instructions sparc assuming -bit addresses space code patch allocated patch heap calculating patch size allocating typically takes patch space allocated dynamically generated code emitted step place patch allocation machine code representation pc-relative instructions sparc call instruction depend instruction addresses entire patch area heap mapped kerninstd space writing generated code written directly patch simple annotation incrementing -bit integer counter code generation takes cost due kernel policy deferring page mapping time written explicit kernel calls made write mapped kernel memory kernel performing noticeable work write subsequent warm writes require mapping complete patches typically written times fall slower cold code splicing fast fine-grained code splicing kerninst major technology contribution splicing action inserting runtime generated code desired kernel code location instrumentation point kerninst splicing fine-grained instrumentation points kernel machine code instruction kerninstd splices overwriting instrumentation point instruction branch patch code code patch dynamically generated code instrumentation step cost finding free registers instrumentation point time code spliced instrumentation point results cached section retrieve live registers bottom basic block calculated startup calculate live registers instrumentation point machine code instruction cost machine code instruction instrumentation point basic block cost assumes instructions return result calculate size patch allocate instrumentation request generate emit code patch add counter emit relocated instruction jump instruction instrumentation point section creating installing splice patch assuming springboard required unlike patch area springboards mapped kerninstd quick writing allocate springboard section generate springboard code swrite springboard contents kernel springboard nucleus write springboard contents kernel springboard nucleus 
overwrite instruction instrumentation point nucleus section overwrite instruction instrumentation point nucleus total worst case instrumentation point springboard nucleus total instrumentation point springboard nucleus total case springboard needed instrumentation point nucleus figure dynamic kernel instrumentation main steps timing measurements mhz ultrasparc running solaris original overwritten instruction jump back instruction stream instrumentation point figure illustrates basic design ideally runtime code splicer finegrained splice code machine code instruction splice quickly pause synchronize executing threads splice customized code instrumentation point unmodified kernels work multi-threaded kernels splicing safely occur time threads potentially executing instrumentation point splicing kerninstd fulfills goals splicing multi-threaded kernel pausing requires replacing machine code instruction instrumentation point branch code patch section discusses safety motivation single-instruction splicing displacement issue single-instruction splicing branch instructions insufficient range reach code patch instrumentation point section discusses springboards solution problem discuss contents code patch code patch contents dynamically generated code inserted code patch ends original instrumentation point instruction jump back instruction instrumentation point original instruction instrumentation point overwritten relocated code patch relocated instruction generated code instrumentation code effectively inserted machine code instruction note instructions semantics pc-dependent branches relocated verbatim code patch cases kerninstd emits sequence instructions combined semantics equivalent original instruction patch code ends jump back instruction instrumentation point instrumentation point instruction unconditional branch jump step skipped single branch instruction sufficient range scratch register written destination address jump jump executes relocated instruction scratch register found set registers free instrumentation point contrasts instrumentation code executes context free registers instrumentation point integer registers kerninstd makes spilling stack kerninstd generates relocated instrumentation point instruction returning jump splicing control transfer instructions delay slot requires extra step control transfer instruction successor delay slot instruction copied code patch ensures delay slot instruction executed proper semantics control transfer instruction changed shown figure note code patch completes returns instruction delay slot ensure executed control transfer instruction unconditional emit jump back instruction stream executed splicing delay slot control transfer instruction difficult branch code patch occur control transfer instruction figure code splicing machine code instruction overwritten branch patch code desired instrumentation code overwritten instruction branch back instruction stream kernel code code patch branch dynamically generated branch back insn overwritten instruction equivalent sequence code inserted instrumentation point instrumentation point cheaper alternative spilling integer register store floating point register sparc architecture instructions raw non-converting integer-to-floating point register move code splicing tcp err ack call mov code splicing tcp err ack patch addr mov code patch dynamically generated code omitted call relocated overwritten instruction mov relocated delay slot instruction jump return instruc delay slot figure splicing delayed control transfer instructions overwritten instruction call delay slot instruction mov relocated patch delay slot instruction left longer executed changed code patch completes jump instruction delay slot effects control transfer instruction executed valid return locations control transfer instruction conditional branch fall-through solution effectively relocate control transfer instruction end code patch instruction falls code patch returns instruction delay slot usual approach works instrumentation point instruction executed delay slot preceding control transfer instruction rare occasions solaris kernel delay slot instruction target branch executed delay slot preceding control transfer instruction kerninstd instrument cases code patch choose instruction sequences returning case detected noticing delay slot instruction start basic block overwriting single instruction instrumentation point safety kerninstd splices overwriting single instruction instrumentation point branch code patch code patch written kernel memory instruction instrumentation point overwritten branch time instruction make instruction cache fetched icache threads continue safely execute original code sequence pre-instrumentation post-instrumentation code sequence executed mix single-instruction splicing hazard-free fine-grained splicing replacing single instruction inherently unsafe unmodified commodity kernel thread execute mix pre-slice post-splice sequences figure shows instructions kernel routine kmem alloc kernel thread located instruction two-instruction splice replaces instructions instrumentation point instruction kmem alloc instructions splice instruction function replaced thread executed instruction successor sra splice occurs unsafe sequence instructions executed shown figure note problem occurs architecture write instructions atomically theory hazard avoided pausing performing backtrace kernel threads check execution return instructions replaced hazard detected splicing deferred strategy paradyn instrumentation system user programs work kernel reasons pausing kernel allowed involve freezing kernel threads kerninstd thread performing splice possibly disrupting critical background activities performing backtrace threads thousands solaris kernel expensive pausing practical jump unanalyzable destination longjmp jump middle splice sequence resulting execution inconsistent code sequence fourth problem multiple-instruction splicing occurs instrumentation point end basic block splice sequence spills basic block reachable block branch block code taking path execute half splice sequence inconsistent code sequence crash kernel reasons conclude fine-grained dynamic instrumentation unsafe multipleinstruction splicing single-instruction splicing difficult architectures branch instructions delay slot mips forces delayed branch instruction splicing resulting unusual execution sequence jumping patch code instruction instrumentation point implicitly delay slot splice branch instruction executed code patch reached instruction instrumentation point executed instruction origicode splicing kmem alloc save sra code splicing kmem alloc save call code patch nop dual-instruction splicing executed sequence save nop inconsistent instruction sequence figure multiple-instruction splicing hazardous nally instrumentation point relocated code patch execution ordering instruction originally instrumentation point successor reversed cases worked instrumentation point instruction successor mutually independent reversing execution order safe instrumentation point instruction independent successor successor instruction idempotent instrumentation point instruction successor code patch resulting execution sequence successor original instrumentation point instruction successor mentioned constraints step equivalent nop independence idempotency constraints met making single-instruction splicing always-delayed-branch architectures difficult final possibility splice replacing instrumentation point instruction trap illegal instruction immediately jump trap handler safely instrumented check offending instruction perform long jump code patch note current implementation kerninstd sparc architecture non-delayed branch instruction splicing avoiding difficulties single-instruction splicing variable-instructionlength architectures challenging depending existing code instrumentation point jump instruction splicing bytes overwrite instruction jump instruction smaller instruction overwritten instruction stream newly written jump instruction tail end original instruction executed hand instrumentation point instruction smaller jump instruction splicing overwrites instruction problems instruction overwritten instruction destination branch corrupted instruction stream executed case handled splicing one-byte trap illegal instruction transfer control trap handler instrumented conventional jump instruction made address offending instruction hash table undo processor-state side effects trap transfer control code patch singlebyte trap instructions overwrite instruction hazard-free current implementation kerninst ultrasparc splices instrumentation points kernel nucleus pwrite dev kmem 
page mdl language compiler dynamic program instrumentation abstract form dynamic code generation called dynamic instrumentation collect data execution application program dynamic instrumentation instrument running programs collect performance types informations instrumentation code generated incrementally inserted removed time base instrumentation machine independent language compiling system runs sparc pa-risc power alpha architectures specification data collect written specialized language called metric description language part paradyn parallel performance tools language platform-independent descriptions collect performance data concise constrain performance data resources modules procedures nodes files message channels combinations resources mdl general procedural programming language compiling faster simpler general specialization dynamic instrumentation environment includes compiler code generation structural analysis binary instrumentation manager code inserted removed running program operate optimized code supported platforms introduction dynamic run-time code generation powerful idiom system adapt changing functional demand workloads extensible operating system kernels construct efficient network protocols compile-on-demand interpreted languages form dynamic code generation called dynamic instrumentation paradyn parallel performance tools make run-time decisions performance data collect dynamic instrumentation differs run-time code generation schemes periodically modifies running application program collect information execution instrumentation activity collecting information execution modifying intent underlying calculation code generation modification techniques variety paper concentrate program instrumentation describe mdl language instrument running programs analyze binary programs code generation scheme performance measurements note techniques work supported part wright laboratory avionics directorate air force material command usaf grant arpa order department energy grant de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government software instrumentation level intrusiveness section discuss measure effect jeffrey hollingsworth oscar naim barton miller zhichen marcelo gon alves ling zheng hollings umd bart mjrg naim zhichen lzheng wisc computer science department maryland college park computer sciences department wisconsin madison page paper part paradyn tools running solaris sparc aix hp-ux dec unix windows defined language called metric description language mdl cleanly kind data collected data collected mdl specialized language key roles specifies code inserted application program calculate performance metrics code includes simple control data operations ability instantiate control real virtual timers specifies instrumentation code inserted application program specification includes points application program place instrumentation code dynamic instrumentation environment parts part parser translates mdl intermediate form part application analysis structural analysis application program identify potential instrumentation points part dynamic code generator code generator takes requests performance data intermediate mdl representation generate machine code fourth part instrumentation manager hooks dynamically generated code application part requires modifying application code trigger instrumentation code application binary analysis dynamic code generator instrumentation manager applications including efficient data breakpoints architecture simulation run-time adaptation steering programs permit developed dynamic instrumentation api foundation constructing run-time tools technical challenges work include support wide class architectures address issue standard language intermediate form keeping instrumentation specifications simple challenge generate efficient instrumentation code avoid instrumentation overhead work minimize challenge dealing optimized code unlike tools operate code generated full optimization current compilers cases forces de-optimize small parts code run-time insert instrumentation current instrumentation based procedure granularity entry exit call complexity manageable future versions handle basic blocks require additional development dynamic code generation general specialization general dynamically compiling procedural programming language incrementally generate small pieces code afford cost full compiler simple code templates based specialization restrictive two-stage compiling process targeted functionality mdl provide sufficient generality efficiency dynamic code generation run-time program control run sparc alpha power pa-risc dynamic instrumentation pushes spectrum instrumentation technology complementing techniques binary rewriting dynamic instrumentation defers decision instrument execution starts performance evaluated on-the-fly made instrumentation based application program execution characteristics long-running programs large scientific codes already-running programs database servers instrumented dynamic instrumentation rewriting advantage requiring access source code binary rewriting static process works advanced knowledge collect remain fiex program execution performance background performance debugging parallel programs requires detailed understanding program execution interaction hardware executing wide range hardware operating systems programpage ming languages libraries primitives parallelism difficult build performance measurement tools provide required detailed information hardware platforms key problem facing tool builders create tools flexible variety platforms provide sufficient detail assist programmer parts performance debugging data collection data presentation paper focus question make easy collect types data present language called mdl describing parallel program performance metrics mdl permits compiler library application programmers customize performance measurement tool gather desired data continually adding hard-wired data collection analysis techniques tool preferable build performance tool extensible permits easy addition types data goals metric description language portability portability performance tool requires tool run variety platforms instrumentation specifications portable platforms library writer describes performance metric library description usable system run library achieve portability data collection higher level abstraction machine instructions important portable metrics types data relevant defined platforms metric description language permit platform specific metrics decouple metrics program components metrics entire computation generally gather metrics finer granularity report waiting time entire program file procedure making request depending situation combination describing individual metrics ways isolate data practical metrics orthogonal ways constrain metrics combinations writing custom definitions metric program component combination impractical metrics program components decouple description metric constrain program components result sufficient describe constraints metrics rest paper describes language implementation section describes mdl language section part paper specific performance profiling section describes obtain structural information binary executable section describes insert remove code running program section section discuss issues relating instrumenting optimized code section describes dynamic instrumentation code generation metric description language mdl mdl special purpose language writing instrumentation requests instrumentation requests written terms performance metrics performance metric time-varying function characterizes part program behavior percent cpu usage message bytes specifications written mdl describe basic instrumentation calculate performance metric additional specifications constrain metric program components mdl metric description represents potentially huge number variations performance measurements gather metric combinations requested execute page mdl description thought two-part program part description insert program instrumentation code specification part program specification code inserted application specification request made instrument application program where-specification interpreted compute type places application instrument application program running user higher-level tool makes request instrument specific list metrics specific parts program what-specification translated machine code combined where-specification information control structure application program machine code inserted running program instrumentation manager figure shows flow information mdl 
instrumentation point nucleus kerninstd dev kerninst perform map write unmap sequence section completes springboards safety requires single-instruction splicing risc architectures provide ideal instruction branch instrumentation point code patch ideal splicing instruction displacement reach patch instrumentation point delay slot instruction executed code patch reached side effects changing absolute pc-relative register relative register relative jumps reach part address space require register set leads hazardous multiple-instruction splicing figure reviews features branch jump instructions architectures suited single-instruction splicing risc architectures instruction suitable key limitation displacement patch area heap allocated arbitrarily code kernel modules means reaching patch matter required displacement splicing single instruction safety kerninst implements general solution displacement problem called springboards springboard scratch area reachable instrumentation point suitable jump instruction idea splice instruction branch nearby springboard turn takes instructions needed jump code patch figure shows code splicing presence springboards code patch springboard written branch instruction written arch instruction range delayslot sideeffects sparc call writes jump register powerpc mips current aligned region cond alpha branch nonejmp register jmp figure suitability instructions singleinstruction splicing risc architectures ideal splicing instruction instrumentation point kernel thread execute springboard code splice completed safety properties single-instruction splicing maintained springboard approach requires chunks scratch space collectively springboard heap conveniently located spots kernel kernel instruction reach nearest chunk suitable jumps figure fortunately unix svr -based kernels including solaris linux windows ideally suited scratch space initialization termination routines dynamically loaded kernel modules kernel modules loaded runtime unloaded memory tight module initialization termination routines called module loaded unloaded kerninstd locks kernel modules memory guarantees initialization termination routines longer called makes free springboard space addition preventing module unloading reloading obviates re-insert splicing code lost module re-loaded practice single kernel module approaches megabyte size jump instruction modest range sparc easily reach nearest springboard solaris kernel modules nucleus subject runtime loading unloading initialization termination routines practice nucleus modules loaded kernel virtual memory dynamically loaded reach initialization termination routines potential springboard space routines nucleus start main invoked kernel booting executed kerninstd adds routines springboard heap figure summarizes springboard space set current solaris ultrasparc implementation kerninstd springboard technique ad-hoc applicable kernels experience -bit operating systems running architecture -bit instructions possibility finding single branch instruction bits displacement limited single instruction springboard code arbitrary displacement making general solution problem reaching patches springboard needed kerninstd allocates generates contents contents copied kernel space springboard reside kernel nucleus kerninstd fills single pwrite dev kmem springboard nucleus kerninstd invokes dev kerninst perform write section dynamic instrumentation performance profiling section presents case study kerninst locate performance bottlenecks kernel application web proxy server workload original code kmem alloc save sra code splicing spliced code kmem alloc save sra springboard call call overwrites free nop code patch inserted code omitted call nop code splicing figure code splicing springboard instrumentation point code patch reached branch kerninstd places branch nearby springboard turn performs multi-instruction long jump code patch solaris routines called init fini module svr unix standard routines called module load module unload linux called init module cleanup module windows device drivers driverentry routine installs pointer cleanup routine instrumentation point location size bytes nucleus start main nucleus initialization termination routines kernel modules figure springboard space solaris kernel metrics kerninst implement kernel profiling tool due space constraints discuss representative sample performance primitives include basic counters cycle timers accumulators averageover-time aot accumulators primitives nonblocking safe multi-threaded environment compare-and-swap instruction changing values primitives combined complex control flow code basic counters implemented inserting increment operations point cycle timers insert start stop operations code function basic block entries exits accumulators collect values kernel variables hardware counters icache misses calculate total aot accumulators calculate average counter variable time average number threads executing function average number threads waiting condition variable instrumentation code calculate area curve averaged area calculated instrumentation code sums rectangles time event performance metrics formed applying primitives metrics tool-kit library call counts average number executing threads average number waiting threads virtual timers call counts simply record number times function called calls made curve figure shows number calls kernel function copen average number executing threads counter record number threads section code incremented entry block decremented exit recording time averaged changed aot calculated values concurrency curve figure shows average number threads function copen average waiting threads counts number threads waiting kernel mutex variable kmutex instrumenting mutex enter aot primitive applied counter underlying processor cycle counters kerninst measure elapsed wall time virtual processor time important isolate bottlenecks kerninst measures virtual time instrumenting context switch handler detect kernel thread dispatched stop re-start timer primitive times metrics constrained process kernel thread predicating primitives find average number kernel threads belonging process executing function time aot primitives spliced entry exit points predicated current pid equals sparc compilers make instrumenting function return challenging function called ends calling tail call optimized unwind stack frame delay slot call makes return directly instrument exit point kerninst splices code sequence de-optimizes tail call sequence paradyn web proxy server benchmark kerninst study performance solaris running version squid web proxy server version wisconsin proxy benchmark running client processes drive squid squid files stored local disk running unix file system ufs kerninst squid run machine ultrasparc ram running solaris kerninst instruments runtime gathering kernel performance information interactive process previous studies proxy servers shown file opens common bottleneck measured kernel function copen handles file open file creation shown figure called times averages threads executing code time squid single-threaded program means average squid elapsed time spent opening existing files reading creating files writing copen performs major calls falloc allocate entry process file descriptor table open file system-specific opening squid maintains disk file cached http object expected falloc bottleneck performs linear search find table entry figure squid file creation called times copen clear bottleneck found falloc consume negligible run time copen time spent open open paths creating files calls create opening files found create path called times accounted open bottleneck file creation squid case call open creat flag bottleneck create calls important routines lookuppn ufs create lookuppn translates full path vnode structure ufs create creates ufs file vnode measurements routines shown figure shows bottlenecks lookuppn namei obtains vnode parsing path components calling file system 
evaluation section introduce model program instrumentation describe mdl language end section present short shows mdl metric description combined request generate instrumentation introduction mdl describing details mdl briefly summarize process collecting performance data collect data insert software instrumentation program previously developed simple defined set operations building blocks compute metrics desired program components keeping instrumentation operations simple optimize performance platform recording performance information application program accomplished points primitives predicates points figure mdl flow control dashed-line boxes generated paradyn mdl program paradyn mdl parse paradyn structural analysis application binary exe instrumentation machine code paradyn instrumentation manager application control information paradyn code generator parsed mdl user input metrics focus parsed mdl instrument instrument page well-defined locations application code instrumentation inserted points procedure entry procedure exit individual call statements future points extended include basic blocks individual statements primitives simple operations change counter timer predicates boolean expressions primitives determine primitive executed inserting predicates primitives correct points program wide variety metrics computed note primitives added deleted modified application program executes mdl differs languages part program specification executed request insert instrumentation received part executes inside application process measure performance clarify parts language foreach procedures append preinsn entry proc calls line loop implicitly declares variable iterate list procedures defined list variable procedures line keywords append preinsn instrumentation code inserted line defines point instrumentation inserted inserting instrumentation beginning entry procedure defined variable instrumentation code insert bracketed tokens code inserted increment variable proc calls result code snippet time procedure called application program counter variable proc calls incremented instrumenting point desirable control instrumentation code point multiple instrumentation snippets inserted single point order execution mdl includes parameters controlling placement instrumentation code control instrumentation executed instruction instrumentation point points procedure calls permits instrumentation inserted immediately immediately procedure called values modifier preinsn postinsn control order instrumentation code snippets snippet inserted point snippet added point added snippet point prepend append addition calls basic primitives instrumentation code blocks conditional expressions calls subroutines application variables application program reading application variable timesteps conditional start execution timer record time spent time step application readsymbol timesteps startprocesstimer program instrumentation generally inserted specific procedures application library compute metrics message passing library requires instrumentation inserted message procedures pre-defined variable lists procedures application program page passing functions instrumentation inserted procedures library entry points make operation easier mdl includes create lists procedures simple list declaration list pvm msg func procedure flavor pvm items pvm send pvm recv line defines list pvm msg func type list procedure line list applies pvm programs line enumerates procedures list list mdl evaluation listed procedures looked application program present program removed list constraints key feature mdl ability constrain metric description program components program components identified hierarchical naming system program component procedure file process unique collections program components grouped resource hierarchies procedures grouped modules modules grouped resource called code procedure func located file test named code test func gather performance data specific program component metric description language constraint clauses constraint clauses create boolean variables true specific program component active constraint module true procedure module executing procedure simple constraint clause true selected module active constraint module code counter foreach func constraint funcs append preinsn func entry module prepend preinsn func return module part constraint clause describes constraint module resource hierarchy constraint clause applies code constraint clause variable constraint bound resource selected case metric user requested metric restricted specific module resource named code foo constraint variable bound foo module constraint attribute funcs list procedures defined module constraint shown code fragment creates boolean variable true selected module active power constraints combined module constraint combined message type tag constraint restrict metric messages specific type received single module combining constraints metric users request detailed metrics applicathe subscripts resource names start specific trailing component page tion programs constraint corresponds boolean variable constraints combined operation complete mdl definition complete metric definition description code insert compute un-constrained metric metric computed entire application list attributes metric list constraints applied metric figure shows complete metric description section definition includes information display metric units operations aggregateoperator describes metric combined processes threads compute single threads execution metrics combined sum operation minimum maximum provided flavor field lists programming models metric valid metrics apply configurations control metrics requested part metric description lists constraints applied metric constraints metrics apply metric defined listed final section metric definition base clause describes instrumentation code compute metric entire program shown base metric increments counter time function list functions pvm msg func called list pvm msg func procedure flavor pvm items pvm send pvm recv constraint procedure code counter append preinsn constraint entry procedure prepend preinsn constraint return procedure metric msgs messages units opspersecond aggregateoperator sum flavor pvm list constraints applied constraint module constraint procedure constraint msgtag base computation metric base counter foreach func pvm msg func append preinsn func entry constrained msgs figure complete metric description metric msgs counts messages pvm message passing routines listed pvm msg func page application execution user higher level software requests metric defined mdl enabled specific combination program resources user requested msgs metric enabled procedure code myprog foo code shown figure inserted program satisfy request instrumentation code snippets inserted inserted procedure foo entry point foo sets counter foo called instrumentation end foo clears counter foo returns snippets inserted evaluating constraint clause fourth code snippets inserted message passing routines pvm send pvm recv statements conditionally increment variable counts number messages received snippets inserted evaluating base clause msgs procedures defined list pvm msg func metric requested entire program un-constrained snippets statements inserted entry pvm send pvm recv capabilities limitations mdl mdl simple type system consisting base types instrumentation code types define instrumentation code inserted instrumentation code types counter timer instrumentation code integer variables record time events types define instrumentation inserted procedure module list iterator procedure aggregate type describes subroutine fields subroutines called entry point return statements single procedure modules collections procedures list aggregate type represents collection variables type lists accessed sequentially list iterators randomly array subscript notation denoted square brackets mdl describe types metrics instrumentation code lacks looping construct language turing complete choose include looping construct make impossible predict execution time instrumentation code mdl execution time called 
application subroutines develop fairly accurate model cost execute instrumentation snippet inserted paradyn cost information control amount instrumentation inserted program metrics written date found absence looping figure instrumentation generated msgs metric constrained foo function foo pvm send pvm recv fooflg fooflg fooflg msgs fooflg msgs page statement limitation expressing metrics wanted create gain experience mdl evaluate absence looping construct unduly limits type metrics created structural analysis parsing binary file paradyn performs simple form structural analysis identify instrumentation points application program result structural analysis list instrumentation points function annotated information point needed instrumentation address point original instruction point additional instructions replaced point instrumented information functions obtained analysis executable determine function leaf function function creates stack frame sparc architecture function save instruction considered leaf function information stack trace inserting deleting instrumentation section paradyn finds points analyzing executable file application goal handle arbitrary executable file gathering information symbol table scanning binary image identify point determine instrumentation inserted point analysis techniques binary rewriting executable file processed steps step memory-map executable file process symbol table size address code data segments result step platform independent representation executable consisting pointers code text segment memory mapped executable file list symbols functions data objects annotated type starting address size cases module symbol belongs important piece information directly platforms size function needed instrumentation points size directly symbol table sort objects address compute size subtracting starting address address function data object starts address sorting step needed platforms supposedly provide size directly symbol table found functions correct size symbol table aix power platform determine end function scanning signature trace-back record procedure extended coff file format platforms solaris hp-ux read symbolic debugging information find module source file functions information derived standard symbol table list functions step find instrumentation points function instrumentation points provided function entry exit points call sites entry point function defined starting address obtained symbol table basic method finding instrumentation points sequentially scan code function beginning entry point searching instruction sequences implement calls exit step platform dependent depends instruction set scanning instructions trivial risc platforms instructions size simple matching instructions sizes decode instruction determine length processing find start instruction cases find function exit points call sites return call instructions jumps leave function defined exit points indirect jumps difficult analyze target analysis time indirect jump leaving function basic page approach assume indirect jumps leave function cases heuristics find target indirect jump sparc code idiom target jump loaded register indirect jump register sethi addr reg low addr reg reg jump reg code sequence frequently jumps distance target jump instruction greater fits field jump instruction find instruction sequence code target function jump defined exit point cases insert code dynamically check jump destination address addition finding instrumentation points analysis executable finds additional instructions point instrumenting point additional instructions needed cases replace instructions insert jump point instructions needed build jumps distant destination check jumps middle instruction sequences collect targets direct jumps scan instructions instrumentation points compilers put data code segment make difficult distinguish data instructions scan executable missing finding incorrect instrumentation points finding instrumentation point inside data common data mixed code jump table switch statements heuristics find skip jump tables effective code generated gnu sun microsoft visual compilers indirect jumps form jmp dword ptr reg addr reg general register addr base address jump table depending base address jump table code segment size table infer addresses table long find address current function assume part jump table inserting deleting instrumentation major challenge dynamic run time instrumentation encountered binary rewriting interacting execution state application program instrument program run time generate instrumentation code fragments place dynamically allocated patch areas called trampolines code generated trampolines tied application program instrumentation manager responsible insertion instrumentation deletion application process complete details trampolines section block generated instrumentation code tied instrumentation point application processes insert code stop application process install code data counters timers application address space operating system facilities unix systems ptrace proc file system code generated trampolines original instruction instrumentation point modified jump base trampoline original instruction point relocated trampoline instrumentation disabled remove branch trampoline reclaim memory code page longer active sections explain processes detail instrumentation insertion insertion instrumentation consists creating trampolines section modifying original instructions instrumentation point jump base trampoline instrumentation instrumentation point existing trampoline instrumentation inserted point original instruction point changed jump trampoline simple case instruction point replaced single jump instruction general replace multiple instructions point size instruction point smaller size jump instruction instructions jump make jumps location middle sequence instructions modified handle case checking direct jump application jumps middle instruction sequence modify jump middle instruction sequence modify sequence alternatives insert trap instruction requires modification instruction safely inserted copy larger instruction sequence including jump trampoline padding code make room instrumentation code modifying jump reject instrumentation request point checking targets direct jumps indirect jumps target determined execution time cases heuristics find targets indirect jumps statically works code encountered gnu commercial compilers increase abilities structure analysis include full control data dependences issue general solution problem instrument indirect jumps analyzed check target run-time taking special action find target middle modified instruction sequence implemented solution demand instrument functions small insert jumps base trampoline entry exit points library functions read write relocate entire function location base trampoline short jumps platforms require modification instruction original function replaced jump relocated function problem modifying multiple instructions program executing instruction sequence moment stop insert instrumentation simply resume program modifying instruction sequence begin executing middle code unpredictable results simple solution modify application code resumes relocated instructions trampoline original location insert breakpoint trap end sequence run program wait reaches breakpoint instrumentation deletion delete request made prevent future activations instrumentation modifying jump trampoline bypass memory block deleted code freed make code active requests delete instrumentation code collected handled batch batching amortize fixed overhead involved deletion list queued deletes processed page list longer pre-defined threshold space instrumentation high water mark delete instrumentation stop application process examine call stack check current stack frames make instrumentation code executed executed defer deletion placing deletion request back list deletion attempted deletion triggered delete instrumentation code delete data counters timers code data shared multiple instrumentation points count counter timer control deallocation 
fragmentation instrumentation heap space dynamic code data insert delete instrumentation heap fragment total space requests single contiguous block big case compact heap updating branch destinations data addresses compaction algorithm run extreme option memory dealing compiler optimizations major challenge run-time tools coping compiler optimizations users interested improving performance applications measure programs compiler optimizations enabled optimizations affect ability instrument code obtain meaningful performance results optimizations lead instrumentation produce incorrect results general method dealing compiler optimizations handle specific optimizations meaningful results techniques undo compiler optimizations fused multiple instrumentation points instrumentation request fused point made compilers tail-call optimization functions make procedure call operation optimized function return caller return address called function returns directly caller sparc platform tail-call optimization implemented instruction delay slot call instruction modify register return address call written call restore kind optimization make difficult collect correct performance data treat call normal call site miss exit point function alternative treat tail call exit point miss time spent called function approach problem undo tail-call optimization reasonable performance data instrument point relocating instructions generate code trampoline emulates original code optimized page tail-call code fragment generate code restore original restore save mov save return address call nop mov restore return address restore retl nop de-optimization commonly instrumenting library functions read solaris tail-call optimization frequently compiling code generation mdl compiling generating code mdl takes place points time figure stage occurs paradyn mdl parse processes configuration file basic metric definitions definitions compiled parse trees interesting stage code generator occurs request made instrument running program machine code generated satisfy request code generation incremental process request instrumentation generating fragment code application program section present basic structure instrumentation code describe code generation instrumentation primitives predicates describe optimizations points code generation features section supported architectures sun sparc pa-risc ibm power dec alpha intel pentium architectures accommodating idiosyncrasies architectures trampolines tying instrumentation step inserting code application allocate space dynamically generated code code generation incrementally request instrumentation made time point application program instrumentation code inserted deleted small code fragments called trampolines mechanism tie active instrumentation point base trampoline block instrumentation code mini-trampoline base trampoline relocated original instructions instrumentation point application program instructions save restore registers slots jumps mini-trampolines inserted jump return application code mini-trampolines instrumentation code jump multiple instrumentation requests point mini-trampolines chained synthesis trampoline list jumping back base trampoline trigger instrumentation code instructions inserted point application code jump base trampoline section cost instrumentation instrumentation point updated base trampoline pre-instrumentation post-instrumentation paradyn track perturbation introduced application figure shows structure base mini-trampolines base trampoline reserve space hold relocated instructions application norpage mally relocate instructions call delay slot times additional save call relocate extra instructions sparc function returns structure instruction delay slot size structure relocated nop added relocating jump instruction fill delay slots relocated instructions details code mini-trampoline appendix mini-trampoline figure illustrates increment primitive similar generated entry foo figure loads counter increments counter stores counter finally jumps back base trampoline mini-trampoline optimization base trampoline consists skipping save restore operations instrumentation point base trampolines removed application general structure base trampolines architectures similar number slots base trampoline relocated instruction instance power architecture requires slots compared required sparc required pa-risc difference power architecture figure application code base mini-trampolines instrumentation code increment primitive load counter minitramp sethi minitramp dyninstdata increment counter minitramp store counter minitramp sethi minitramp dyninstdata branch base trampoline mini-trampoline minitramp basetramp minitramp nop figure mini-trampoline sparc architecture func foo relocated instruction trampoline base save regs restore regs trampoline mini save regs restore regs pre instrument post instrument instrumentation program application starttimer update cost update cost primitive page save restore registers base trampolines register saved relocate jump branch instruction base trampoline modify jump architectures range jump instructions limited generate multiple instructions emulate effect original jump destination address target range original jump instruction pa-risc architecture original instructions replaced instruction sequence ldil basetramp ble basetramp branch link return instructions save program counter base trampoline return application code relocated instruction jump target base trampoline base register jump architecture additional difference base trampoline instruction length variable relocate instructions instruction point additional instructions point extra instructions moved make sufficient space jump base trampoline additional instructions instrumentation point relocated beginning base trampoline additional instructions point relocated end base trampoline return application code scheme advantages include jump instruction relocated sequence leave ret ret instruction instrumentation point instruction byte relocate additional instructions instruction relocated long jump leave ret instructions relocated beginning base trampoline instrumentation executed jump base trampoline leave pre point instrumentation ret post instrumentation reached case return user code instrumentation function return point handled special power platform difficult determine precisely exact return points approach insert instrumentation entry point replace link register return address address basetrampoline return point original return address saved stack restored function returns jump base-trampoline executing instrumentation code retrieves save registers demand prior exploit machine calling convention infer registers save call page original return address stack jumps location code generation primitives predicates request specific performance resource metric specific point generate mini-trampoline code instrumentation request instrumentation request machine independent part code generator select pieces parse tree pieces parameterized request requesting measure cpu time procedure foo select definition cpu instrumentation constraint restrict metric procedure information combined procedure foo code generator constructs abstract syntax tree ast astnode machine independent intermediate representation code translated machine code ast dag astnodes represents instrumentation code inserted application program generate code architecture specific code generated beginning mini-trampoline ast traversed triggering code generation routine basic node type traversal architecture specific code end trampoline generated optimizations places optimizations made dynamic code generation optimization environment unique aspects interacting existing application code previously inserted instrumentation code avoid repeated address computation perform common sub-expression elimination avoid long streams redundant instrumentation collecting data instances resource employ simple form vectorization structured code generation support peephole optimizer implemented simple optimization eliminating common sub-expressions type operation effective frequently multiple computed addresses common sub-expressions ast identified parse time code generation standard techniques generating code expression result register hold register occurrence sub-expression collecting performance data instances resource generate repetitious expensive instrumentation situation occur profiling memory blocks case hundreds thousands instances resource instrumentation request generated separately detect independent requests vectorize vectorization generated code 
conpage ceptually constraint arg instance counter constraint arg instance counter constraint arg instancen countern statement represents constraint related vectorization constraining procedure statement group target vectorization optimization note optimization similar switch statement arg term specifies resource instance means instance identified parameter function instrumentation inserted number instructions inserted linearly proportional number resource instances amount instrumentation perturbation intolerable allocate vector counters timers resource instances insert code index cells vector optimized code constraint index arg resource vector index function user-supplied function maps resource instance vector index function takes input description resource class arg instance number instructions inserted constant independent number resource instances optimization effective mapping function produce dense vector improve optimization pre-calculate propagate constants time instrumentation measured operations cache misses memory block cache line arrays application program allocate vector counters counter memory block array resource case user array information mapping function base address length resource instance arg memory address function maps arg cell counter vector based array information memory block size unoptimized instrumentation executes instructions mini-trampoline number resource instances number instructions register save restore constraints vectorization number instructions peephole optimization reduce number instruction memory resources large large performance measurements critical performance cost instrumentation time takes user code trampolines back cost instrumentation code part calculates metrics specific semantics metric description difficult make general statements counter timer operations page previously reported costs results figures show performance code patching system processor architectures time shown fourth row figure reflects time required execute instrumentation call empty procedure single point program due preserve machine state squeeze code existing binary image times higher traditional compiler generate procedure call architectures largest share time spent saving restoring machine state platform time spent saving restoring machine state time spent preserving register flags saving restoring register required total instrumentation time sparc register wheel preserve local parameter registers preserve general mhz pentium-pro sparc mhz microsparc power mhz power pa-risc mhz call empty procedure base trampoline jump saves restores base trampoline trap saves restores base trampoline jump saves restores empty mini-trampoline figure cost triggering instrumentation line cost procedure call parameters instrumentation place line adds jump base trampoline back register save restores jump mini-trampolines line trap instruction jump base tramp line adds register save restores jump case line adds base tramp register save restores jump empty minitrampoline numbers parentheses cost relative empty procedure call figure cost operations figure normalized clock speed page floating point registers ensure correct behavior save restore time significantly shorter power architecture save registers resulting instrumentation analysis instrumentation code decide save registers specific instrumentation point row figure shows time required execute null procedure trap instruction expected requires trap operating system kernel time significantly longer simply executing branch instruction data breakpoints approach faster trap instruction context switch separate debugger process opportunities improve performance instrumentation system base trampoline static code template place holders nop situations customizing base trampoline situation improve time base trampoline execution cases likewise fuse base mini-trampolines reduce number branches change improve run-time performance cost greater complexity managing multiple mini-tramps single point program conclusions paper introduced mdl language dynamic program instrumentation mdl machine independent describe instrumentation inserted application program language includes features de-couple specification data collect constrain data collection program components procedures addition mdl permits customization data collection parallel programming models permitting metric developers tag metric definitions specific programming models part paper mechanisms create run-time instrumentation compiler run-time code instrumentation system differs binary editors run-time code specialization tools generate code run-time weave arbitrary points binary image execution presented techniques shoehorn instrumentation tight code sequences including moving code selective deoptimization compiler generated code reported ways insert delete code running program optimization techniques run-time code generation instrumentation optimized code supported platforms including commercial compilers ibm xlc microsoft visual sun sparcworks compiler technology advances dynamic instrumentation advance ability handle optimizations future depend compiler providing information nature transformations run-time code generation system produces code sun sparc pa-risc dec alpha ibm power intel architectures features paper incorporated paradyn parallel performance tools working create api export run-time compiler features beguelin dongarra geist sunderam visualization debugging heterogeneous environment ieee computer june page nashon berstein fdpr post-pass object-code optimization tool international conference compiler construction linkoping sweden spring verlag lncs april lzle chambers ungar debugging optimized code dynamic deoptimization sigplan pldi conf san francisco june heath etheridge visualizing performance parallel programs ieee software sept hollingsworth irvin miller integration application system based metrics parallel program performance tool acm symposium principles practice parallel programming williamsburg april hollingsworth miller adaptive cost model parallel program instrumentation euro-par lyon france august hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference knoxville hough cuny perspective views technique enhancing parallel program visualization international conference parallel processing vol august hollingsworth miller dynamic instrumentation api computer sciences technical report http umd hollings dyninstapi kimelman environments visualization program execution performance instrumentation visualization simmons koskela editors addison-wesley larus schnarr eel machine-independent executable editing sigplan conference programming language design implementation jolla june massalin threads input output synthesis kernel symposium operating systems principles operating systems review december miller callaghan cargille hollingsworth irvin karavanic kunchithapadam tia newhall paradyn parallel performance measurement tools ieee computer november necula lee safe kernel extensions run-time checking symposium operating systems design implementation october autrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system symposium operating systems principles copper mountain december rastings joyce purify fast detection memory leaks access errors winter usenix conference january reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance analysis environment scalable parallel libraries conference skjellum editor ieee computer society shende cuny hansen kundu mclaughry wolf event state-based debugging tau prototype sigmetrics symposium parallel distributed tools philadelphia srivastava eustace atom system building customized program analysis tools sigplan conference programming language design implementation orlando topol stasko sunderam monitoring visualization cluster environments technical report gitcc- georgia institute technology march yan sarukkai mehra performance measurement visualization modeling parallel distributed programs aims toolkit software practice experience page appendix base trampoline code sparc save registers basetramp save basetramp std fpbasetramp std fpbasetramp std fpbasetramp std fpupdate cost basetramp sethi basetramp dyninstobscostlow basetramp add basetramp branch mini-trampoline pre-instrumentation basetramp minitramp basetramp nop restore 
registers basetramp ldd fpg basetramp ldd fpg basetramp ldd fpg basetramp ldd fpg basetramp restore basetramp nop space relocated instruction basetramp sethi basetramp dyninstin sample basetramp nop basetramp nop basetramp nop basetramp nop basetramp nop save registers basetramp save basetramp std fpbasetramp std fpbasetramp std fpbasetramp std fpupdate cost basetramp sethi basetramp dyninstobscostlow basetramp add basetramp branch mini-trampoline post-instrumentation basetramp nop basetramp nop restore registers basetramp ldd fpg basetramp ldd fpg basetramp ldd fpg basetramp ldd fpg basetramp restore basetramp nop branch application code basetramp call user code basetramp nop 
lookup routine ufs lookup ufs general case ufs lookup disk obtain inode location directory file read inode contents optimize path lookup solaris directory lookup cache dnlc hashes path components entries inode cache dnlc hit bypasses reading directory file ufs dirlook reading inode ufs iget dynamically instrumenting kernel count calls ufs dirlook lookuppn found dnlc hit rate miss penalty execution ufs dirlook high account ufs lookup bottleneck shown figure squid preponderance small cache files benchmark overwhelmed dnlc entries default address bottleneck increased dnlc size maximum allowed shown figure eliminates ufs lookup bottleneck accounts squid elapsed time permanent solutions suggest dnlc grow needed avoid conflict misses flip side argument squid simply small files redesigned large fixed-size file disk cache recall figure ufs create bottleneck create accounting squid elapsed time ufs create time spent ufs itrunc invoked squid passes trunc flag open system call squid time spent truncating existing cache files size opening ufs itrunc time spent ufs iupdat synchronizes updates inodes truncation slow ufs synchronizes meta-data squid reuses obsolete disk cache files deleting obsolete file creating scratch motivation avoid expensive meta-data operations required file deletion updating parent directory file freeing inodes ufs itrunc bottleneck shows squid strategy backfiring address bottleneck note deleting file inodes truncation added synchronously version figure create components lookuppn ufs create distinct bottlenecks figure ufs lookup ufs dirlook called dnlc miss accounts ufs lookup bottleneck curves overlap note dnlc lookup time essentially figure effect increasing dnlc size miss penalty routine ufs dirlook called infrequently accounts squid elapsed time file written file size equal size inode deletions creations amount expensive no-op file size original size lesser optimization delete inodes file end longer needed modified squid implement effect shown figure time spent synchronously updating inodes reduced squid run time combined effect optimizations shown figure open system call consumed squid run time takes added time spent truncating cache files explicitly trunc flag open figure squid elapsed time takes safety security issues splicing code running kernel introduce race conditions kernel threads executing instrumentation point spliced splicing hazards adversely disrupt kernel execution safety violations introduce undesirable information flows security violations single-instruction splicing section solves splicing hazard problem plan harness rich body existing work safety security commodity kernel written extensibility mind fine-grained patching issues complex summarize issues outline initial directions trusted code approach authority certifies code well-behaved certification generator code code lies specially protected directory system administrator update alternatively code trusted party network digital signature strategy fall-back position current work kerninstd requires applications written top super-user privileges dynamically safe code safety issues addressed executing inserted code safety violations detected inserting extra instructions dynamic code corrective action violation detected action simple exiting dynamic code killing kernel thread executed offending code complex dynamic code local executing behalf single user process modifying shared kernel data structures exiting dynamic code sufficient software fault isolation sfi techniques augment dynamic code run-time checks insure code stays local space vino exokernel systems technique dynamic code global common parts kernel accessing data structures shared kernel threads case terminating offending code leave locks held shared data structures inconsistent state sfi techniques significantly extended handle shared resources kernel data structures transaction semantics vino simplify constructing recovery mechanism statically safe code code identified statically safe advantages code potentially efficient run-time checks needed code misbehave recovery scheme needed proof carrying code pcc approach pcc requires safety policy formally defined resources accessed extension inserted code access kernel data structures call kernel figure effect improving squid truncation ufs itrunc accounts squid elapsed time figure create performance optimizations lookuppn component reduced larger dnlc ufs create component reduced open system call longer trunc flag note ufs create time essentially functions rigor formally defined safety policy combined approaches combination static dynamic checking safe languages java modulain spin potentially requires fewer run-time checks recovery strategy extension code classified interaction underlying kernel annotations performance measurement debugging code orthogonal underlying computation annotation writes data transfer control annotations code bounded time resource requirements recovery strategy easy annotation removed annotations call kernel functions locking routines temporarily modify system state safety annotations requires specification semantics kernel routines dynamic code calls plan design specifications cover common synchronization scenarios recovery commodity operating system open annotation fault area actively researching code adaptations intentionally change behavior underlying system examples include on-the-fly optimizations specialization outlining adaptation part kernel replace code accomplishes task efficient reliable manner developing mechanisms closed-looped dynamic measurement optimization adaptations include adding functionality kernel safety recovery issues fine-grained adaptations complex open annotations security issues distinct safety issues security restricting information flows authenticating data modifications annotations adaptations efficient safe secure sensitive kernel structures process address spaces copied file quickly safely open large security holes security addressed safety verifying formally-defined policies resources accessed inserted code respected related work extensible operating systems spin exokernel vino processes download code kernel differ approach ways unmodified commodity kernels perform coarse-grained instrumentation vino classes customize object methods limited number instrumentation points pre-coded easy instrumentation synthetix replaces function called preexisting level indirection overwriting function pointer requiring special code process-specific customization place incurs small overhead methods customized limits granularity instrumentation impractical place level indirection kernel basic block note kerninst complementary research kernels provide additional splicing capabilities digital continuous profiling system dcpi measures detailed performance metrics cycles icache misses instruction level commodity kernel unlike kerninst dcpi instrument kernel code precludes metrics readily sampled kerninst concert continuous profiling create additional metrics software paradyn dynamically instruments user programs work differs paradyn ways applies kernels instrumentation fine-grained paradyn limits instrumentation points function entries exits calls sites kerninst instruments pausing paradyn incurs substantial overhead pausing application walking stack ensure safe splicing instrumentation request static binary rewriters eel atom fine-grained arbitrary code inserted user programs potentially kernels static rewriting requires program off-line instrumentation instrument case turn interest contrast dynamic instrumentation user refine runtime instrumentation interest kitrace traces kernel code locations replaces instructions traced trap transfers control custom handler handler appends entry trace log resumes execution trap instructions inserted kernel instructions kitrace fine-grained kitrace differs work ways requires kernel recompile insert general code kernel method resuming execution trap expensive dynamic instrumentation finegrained dynamic instrumentation subsumes kitrace insert 
arbitrary code trace-gathering code slic extensibility commodity operating systems rerouting events crossing kernel interfaces system calls signals virtual memory routines extensions downloaded kernel run user-level process slic interposes extensions kernel interfaces rewriting jump tables binary patching kernel routines performs binary patching slic replaces instructions start kernel function section multiple-instruction patching unsafe addition slic fine-grained interposing system calls dozen kernel instrumentation points conclusion future work fine-grained dynamic kernel instrumentation including performance profiling debugging testing optimizing extending kernel paper shown design implementation dynamic kernel instrumentation combines fine-grained splicing dynamic code generation shown technology feasible implementing solaris running ultrasparc investigating ports architecture combinations including kerninst opens areas opportunity general creates safety security concerns formulating formal access control model goal automating checking dynamic code acknowledgments pei cao kevin beach wisweb group supplying wisconsin proxy benchmark stephen chessin madhusudhan talluri sun microsystems technical assistance suggestions matt cheyney carlos figueira karen karavanic tia newhall brian wylie zhichen comments manuscript almeida cao wisconsin proxy benchmark http wisc cao wpb html anderson berc dean ghemawat henzinger leung sites vandervoorde waldspurger weihl continuous profiling cycles acm symposium operating systems principles sosp saint-malo france oct auslander philipose chambers eggers bershad fast effective dynamic compilation acm sigplan conference programming language design implementation pldi philadelphia bershad savage pardyak sirer fiucynski becker chambers eggers extensibility safety performance spin operating system acm symposium operating systems principles sosp copper mountain dec cockcroft pettit sun performance tuning java internet sun soft press engler kaashoek toole exokernel operating system architecture application-level resource management acm symposium operating systems principles sosp copper mountain dec engler vcode retargetable extensible fast dynamic code generation system sigplan conference programming language design implementation pldi philadelphia ghormley rodrigues petrou anderson slic extensibility system commodity operating systems usenix technical conference orleans june hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference knoxville hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques san francisco nov kuenning precise interactive measurement operating systems kernels software practice experience january larus schnarr eel machine-independent executable editing acm sigplan conference programming language design implementation pldi jolla june mosberger peterson bridges malley analysis techniques improve protocol processing latency acm sigcomm stanford aug necula lee safe kernel extensions runtime checking usenix symposium operating systems design implementation osdi seattle oct necula lee design implementation certifying compiler acm sigplan conference programming language design implementation pldi montreal canada june audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating systems principles sosp copper mountain dec seltzer endo small smith dealing disaster surviving misbehaved kernel extensions usenix symposium operating systems design implementation osdi seattle oct seltzer small self-monitoring self-adapting operating systems workshop hot topics operating systems cape cod small tool constructing safe extensible systems usenix conference object-oriented technologies systems coots santa april srivastava eustace atom system building customized program analysis tools acm sigplan conference programming language design implementation pldi orlando june wahbe lucco anderson graham efficient software-based fault isolation acm symposium operating systems principles sosp asheville dec 
page experiment management support performance tuning karen karavanic barton miller karavan bart wisc computer sciences department wisconsin madison abstract development high-performance parallel system application evolutionary process code environment program lifetime change key question developers performance change existing performance tool functionality answer question paper reports design preliminary implementation tool views execution scientific experiment functionality answer questions program performance span single execution environment report results tool actual performance tuning study scientific application run changing environments goal historic program performance data develop techniques parallel program performance diagnosis introduction experimental science supposed experiments find generalities supposed tally long list individual cases unique life histories butterfly collecting richard lewontin development high-performance parallel system application evolutionary process begin models simulations initial implementation program code incrementally modified tune performance continues evolve applications life span step key question developers performance change question arises comparing implementation models simulations versions implementation algorithm communication numeric library language studying code behavior varying number type processors type network type processes input data set work load scheduling algorithm benchmarking regression testing broad utility type comparison existing performance tool functionality answer state art research tools paradyn pablo focus measuring performance single program execution describe infrastructure answering question stages life application view program run simulation result program model experiment provide functionality experiment management system project parts representation space executions techniques quantitatively automatically comparing executions enhanced performance diagnosis abilithis work supported part wright laboratory avionics directorate air force material command usaf grant darpa order nsf grants cdaand cdaand department energy grant defg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government page ties based historic performance data paper present initial results parts measure success project activity complex cumbersome manually automate part concise representation set executions collected life application store information experiment program event enumerates components code executed execution environment stores performance data collected combinations code execution environment form multi-dimensional program space dimension axis variation point program event enable exploration space simple naming mechanism selection query facility set interactive visualizations queries program space made contents performance data metadata describes multi-dimensional program space graphical representation program space serves user interface experiment management system part project develop techniques automating comparison experiments performance tuning multiple executions answer deceptively simple question changed run program developed techniques determining difference program runs automatically describing structural differences differences program execution structure resources performance variation resources change run apply technique compare actual execution predicted desired performance measure application compare distinct time intervals single program execution include performance tuning efforts automated scalability studies resource allocation metacomputing performance model validation studies dynamic execution models processes created destroyed migrated communication patterns distributed shared memory optimized data values code changed steering difference information necessarily simple measure total execution time complex measure derived details program structure analytical performance prediction actual previous execution code set performance thresholds application required meet exceed incomplete set data selected intervals execution part research investigate predicted summary historical data contained program events program space performance diagnosis exploring opportunities exploiting collection data focus data gathering analysis efforts critical sections large application isolating spurious effects interesting performance variations details scope paper program events automated comparison program event representation program run execution program event collection performance data automatically compare program events structural difference operator program event represent program collection discrete program resources resources include program code application processes machine nodes synchronization points data structures files group resources unique view application organize program resources classes aspect application represent structure class tree called resource hierarchy definition program event forest composed unique resource hierarchies resource hierarchy collection related program resources root node resource hierarchy represents entire program execution labeled entire resource hierarchy descendant root node represents program resource view move root node level hierarchy represents finer-grained description program code hierarchy level nodes represent modules level function nodes level loops basic block nodes code resource hierarchy figure root level level program-level view application represents cumulative behavior program level module-level view source code level function-level view level resource hierarchy set resources level leaf level partition set nodes lower level module level figure page testutil main vect partition set leaf nodes level hierarchy superscript notation refers level children root node resource hierarchy code hierarchy figure shows set functions partitioned modules code testutil main vect printstatus verifya verifyb main vect addel vect findel vect print definition resource hierarchy tree form resource set children resource hierarchy figure shows sample program event parallel application called tester program event set code machine process code hierarchy nodes represent program modules functions machine hierarchy node cpu tester executed process hierarchy node process resource representation logical physical component program execution single resource represent aspect program environment executes process function cpu variable figure leaf node labeled verifya represents resource code testutil verifya semantic meaning attached resource relevant programmer affect model functionality program execution component uniquely represented single resource internal node resource hierarchy tree represents set resources code testutil single resource represents aggregation set printstatus verifya verifyb resource formed concatenating labels unique path resource hierarchy root node representing resource resource represents function verifya shaded figure code testutil verifya representing performance information program event performance measurement part parts program interested measuring cpu time average executions total entire execution total single function focus constrains view program selected part selecting root node hierarchy represents unconstrained view program selecting node narrows view include leaf nodes descendents selected node shaded nodes figure program event program tester resource hierarchies vect addel verifyb verifya printstatus mainmain testutil vect vect findel vect print tester tester tester process machine cpu cpu cpu cpu tester code page figure represent constraint functions verifya verifyb process tester running cpu definition focus formed selecting resource node resource hierarchies level resource hierarchy total number resource hierarchies nodes selected levels hierarchies program event intuitive naming scheme program components called resource normal form convert selected set resource normal form concatenating selections resource hierarchy shaded selection figure represented code testutil verifya verifyb machine process performance data represented function form program execution defined definition metric measurable execution characteristic cpu time focus performance data cpu 
time focus code main machine process time interval specifies execution data collected returns performance result simple scalar complex object data uniquely identified focus performance data stored resource normal form structural difference operator comparing performance program executions natural question code environments tests differ perform test runs identical code running identical dedicated platforms resource hierarchy execution identical counterpart execution performance data meaningfully compared focus valid individual executions comparison complex cases code run time environment differ test runs determine common set valid resources determine set valid foci program program events figure calculate structural difference perform structural comparison program executions compare sets resource hierarchies top-down manner structural difference operator takes program events operands yields program event group peg result resources original program events structural difference operation works hierarchical set union operation operator applied iteratively build single set resource hierarchies characterizes number distinct program runs figure shows application structural difference operator program events top set resource hierarchies describes event middle set describes bottom figure shows result resources common executions outlined mixed dash dot code code module examples resources resources unique outlined dot solid boxes match figure algorithm find structural difference program events page moving single execution model collection program events stored program event group peg interface peg centered single set resource hierarchies constructed structural difference operator represents components program events collection program events stored multi-dimensional program space users navigate space visualize form contents make queries structure contents developed aggregation operators viewing peg performance data list aggregation operator applied hierarchy selected node yields performance result list values single cluster aggregation operator groups requested performance data group values represented average group defined metrics multi-execution peg discrete distance metric binary function performance results differ interval metric calculated performance results discrete distance metric building block clusfigure structural difference operator machine poona code module module main foo bar process tester sync objects messages process tester machine poona code module module main foo car machine poona code module module main foo bar car process tester semaphores messages program event program event program event group semaphores sync objects sync objects execution execution execution page tering differencing performance results performance difference operator takes inputs executions returns list foci discrete distance metric yields answer true list computed hierarchically shown figure iterate resource nodes program event starting focus represents entire program execution currentfocus performance difference noted check specific foci metric provide display performance difference results part prototype figure metric focus attention immediately performance version construct specific foci operation call magnify figure definition focus node resource hierarchy resource hierarchy original focus form set foci replacing resource children lower level hierarchy result magnify operation applied focus set foci previous metrics aim describe changed metric describe performance changed investigating approaches performance distance metric euclidean distance weighted average performance result values goal quantitative measure performance differs executions weigh rank performance bottlenecks figure algorithm performance difference operator perfdiff performance difference operator searches performance results metric requested program events returning list foci results figure algorithm magnify magnify returns set foci constructed making step descents resource hierarchy starting focus answer enqueue pendingqueue wholeprogram isempty pendingqueue currentfocus dequeue pendingqueue currentfocus currentfocus true answer answer currentfocus magnify currentfocus enqueue pendingqueue return answer focus answer children answer answer return answer page case studies test model existing scientific applications implemented preliminary prototype experiment management performance tool prototype written tcl extended tree widget resource hierarchy loading display differencing implemented directly tcl test design examined data collected tuning parallel programs provide examples prototype compare implementations based alternate communication libraries evaluate performance program evolves versions track data scalability analysis case experiment management system simplifies speeds programmer task comparing alternate implementations porting pvm application mpi study compared structure versions parallel message-passing fft code called ported pvm mpi message passing libraries application solves navier-stokes equation dimensions scientist porting application directed feedback resulting performance application idea performance degradation step provide feedback structural differences versions figure show resource hierarchies resulted applying structural difference operator program events -node run nspvm pvm version -node run nsmpif mpi version ibm spthis display quick differed code environment runs left figure shows code machine memory process syncobject resources program events code hierarchy modules dfft runs leaf procedures strip strip appeared program event message hierarchy shows message tags tags figure resource hierarchies program event group nspvm nsmpif peg display developer navigate resource hierarchies quickly differed structurally program runs display organized resource hierarchies figure addition integer run identifier rid run labeled resources appeared run labeled rid run resources run labeled sum rids resources labeled appeared runs show views peg display left module expanded display results expanding message node individual message tags page represent mpi message tags rest represent message tags pvm version selecting resources display performance data program event include resource evolving application performance tuning shared memory application protein-folding application called fold recently developed chemical engineering department tuning effort reported detail analyzed program versions performance data study automate identification version ran versions fold steps performance tuning study researchers conducting study located problems version simple port wisconsin cluster workstations cow sgi powerchallenge problem identified serial portion code consumed execution time nodes version changed data partitioning relieve bottleneck problem identified false sharing data blocks version padded aligned data improve cache behavior present selected results demonstrate benefit experiment management approach navigating large space resources data involved complete performance tuning study examined structural differences versions version version merged program events applying structural difference operator generated program event group peg peg display distinguishes foci valid program events memory hierarchy shows data change kind occurred data structures memory hierarchy version examined performance differences applying performance difference operator metric memoryblockingtime perfdiff operator pairwise compares performance data program events results presented perfdiff display shown figure display shows memory blocking behavior differed runs differed process differences localized data structures gmpart scalability study study compared executions parallel global circulation message-passing code called ocean ran code nodes wisconsin cow merge cluster performance difference features explore behavior application scaling figure shows program event group display program event group built applying structural difference operator set resource nodes union resource hierarchies original program events views figure demonstrate prototype ability represent application environments study runs 
re-used common set machine nodes shown display nodes labelled cow cow cow cow common executions tagged nodes cow cow cow cow unique -node program run tagged remaining machine nodes -node runs tagged display shows processes string comparison yields limited information process unique display demonstrates prototype ability provide interface naming mechanism types program resources found multi-execution performance tuning environment show results multi-execution query figure requested metrics cputime syncwaittime iowaittime executions application nodes sun sparcstation cluster data collected paradyn stored form paradyn histograms result query paradyn histograms display result xmgr related work extensive work parallel profiling tools limited amount work tools displays performance data multiple runs debugging area work find bugs comparing execution program version comparing program output user-selected variables guard compares program debugged version program detect differences variable values user-defined points execution comparisons made simple complex data types programs compared written languages run heterogeneous environments defined difference operators simple complex data types compare complex structures factor machine dependent data representations returning boolean result variable values differed matching points computation unlike approach programmer separately determine points comparison items comparison version propage gram recent efforts defined program similarity mtool includes metric compares observed predicted execution times granularity individual basic blocks approach memory tuning defines difference predicted observed execution time memory bottleneck mendes defines similarity execution graphs trace transformation approach performance prediction define similarity graphs degree largest isomorphic graphs induced subgraphs original graphs distance graphs defined number vertices original graphs saavedra smith metrics program similarity program characteristic similarity normalized squared euclidean distance execution time similarity addressing similar problem structural difference performance difference operators approach provide extensible framework structural execution comparison performance difference calculated levels detail metrics wisconsin program slicing project uw-madison investigates methods determining syntactic semantic differences versions sequential source code focus precise characterization identification differences program versions limited sequential pascal codes examines source code identifying differences executions code differing environments physical life sciences work automate store experimental data interactive data exploration scientific data visualization subject ongoing research restrict scope research identifying issues multi-execution environment combined paradyn devise enable side-by-side linked visualization data multiple executions parallel application inifigure results performance difference operator metric memoryblockingtime nodes shown represent resource combinations performance difference detected program events starting left node wholeprogram means performance change runs process nodes performance changed processes level details individual shared data structures shared index structure gmpart gmpart gmpart gmpart shared data structures listed index data structures listed common runs memoryblockingtime changed snapshot selecting nodes process process detailed display children visualization performance data node showing plots values run launched selecting node display page tial effort address problems match phases program runs execution time simply displayed runs ability correlate point graph figure resource hierarchies program event group ocean program event group represents executions pvm application ocean run nodes result performing consecutive structural difference operations show views peg display left module machine expanded display results expanding process node figure results metrics cputime time sync wait program event group page point execution graph ipsallowed linked visualization data runs matching normalizing total execution time ribler abrams virginia developed alternative methods visualizing categorical trace data including recent work visualizing multiple traces simultaneously representation program space experiment management infrastructure automated comparison program runs represents direction defining performance tool closely maps actual process programmers tune codes automation focus user attention small critical areas change conclusions taking experiment management view performance tuning describe application behavior lifetime variety environments code ports multi-execution view valuable feedback scientist developing maintaining parallel code working expand prototype richer set data types web-based interface service developers engaged geographically distributed cooperative program development additional performance displays investigating object oriented database data storage exploring techniques improve paradyn on-thefly diagnosis capabilities feedback experiment management system wheeler top population geneticist delivers scathing critique field chronicle higher education february miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november reed scalable performance analysis pablo performance analysis environment press editor proc scalable parallel libraries conference pages los alamitos foster kesselman globus metacomputing infrastructure toolkit international journal supercomputer applications dongarra geist manchek sunderam integrated pvm framework supports heterogeneous network computing computers physics reinhardt larus wood tempest typhoon user-level shared memory annual international symposium computer architecture april eisenhauer kraemer stasko vetter schwan falcon on-line monitoring steering large-scale parallel programs symposium frontiers massively parallel computation mclean virginia february kunchithapadam miller integrating debugger performance tool steering debugging performance tools parallel computing systems ieee computer society press simmons hayes brown reed fink kohn baden flexible communication mechanisms dynamic structured applications irregular santa barbara august larus miller shared-memory performance profiling acm sigplan symposium principles practice parallel programming las vegas nevada june yan sarukhai mehra performance measurement visualization modeling parallel distributed programs aims toolkit software practice experience spe april williams hoel pase mpp apprentice performance tool delivering performance cray programming environments massively parallel distributed systems monte verita heath etheridge visualizing performance parallel programs ieee software september karavanic myllymaki livny miller integrated visualization parallel program perforpage mance data parallel computing ioannidis livny conceptual schemas multi-faceted tools desktop scientific experiment management international journal intelligent cooperative information systems december sosic abramson guard relative debugger software practice experience kohn williams atexpert journal parallel distributed computing hollingsworth miller dynamic control performance monitoring large scale parallel systems international conference supercomputing tokyo july ousterhout tcl toolkit addison-wesley publishing company reading brighton tree widget tcl tools o-reilly associates bruce irvin barton miller multi-application support parallel program performance tool technical report cs-tr- february computer sciences department wisconsin madison goldberg hennessy performance debugging shared memory multiprocessor programs mtool proceedings supercomputing pages albuquerque november mendes performance prediction trace transformation brazilian symposium computer architecture florianopolis september saavedra smith analysis benchmark characteristics benchmark performance prediction technical report computer science technical report usc-cs- southern california horwitz reps efficient comparison program slices acta informatica ribler mathur abrams visualizing modeling categorical time series data technical report department computer science virginia polytechnic institute state august author biographies karen karavanic working doctoral degree computer sciences department wisconsin madison received degrees computer science york wisconsin karavanic holds nasa graduate student research fellowship barton miller received degree computer science california san diego degrees computer science 
california berkeley wisconsin madison professor computer sciences department research interests include parallel distributed program measurement debugging extensible operating systems network management naming services user interfaces directs paradyn parallel performance tool project developing next-generation performance tools massively parallel computers workstation clusters miller program co-chair acm sigmetrics symposium parallel distributed tools general chair acm sigmetrics symposium parallel distributed tools chaired acm onr workshop parallel distributed debugging editorial boards ieee transactions parallel distributed systems computing systems international journal parallel processing 
abstract primary problem performance measurement high-level parallel programming languages map lowlevel events high-level programming constructs discuss aspects problem presents methods performance tools map performance data provide accurate performance information programmers discuss static mapping dynamic mapping technique data structure called set active sentences methods requires cooperation compilers performance tools describe nature amount cooperation required mapping methods orthogonal describe combined complete tool concentrate mapping upward layers abstraction techniques independent mapping direction introduction application programs built multiple layers abstraction performance tools elements layer relate elements layers mapping represent relations abstraction levels performance characteristics program elements performance information measured abstraction relevant levels maps work supported part wright laboratory avionics directorate air force material command usaf grant arpa order cdaand department energy grant de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government identify performance characteristics common programming models developed framework discuss performance characteristics programs written programming models framework called noun-verb model parallel program performance explanation model nouns program elements performance measurements made verbs potential actions noun performed noun fortran nouns include programs subroutines forall loops arrays statements verbs fortran include statement execution array assignment reduction subroutine execution file instance program construct verb called sentence sentence consists verb set participating nouns cost cost sentence measured terms resources time memory channel bandwidth performance information consists aggregated costs measured execution collection sentences collection nouns verbs software hardware layer defines level abstraction nouns verbs level abstraction related nouns verbs levels abstraction mappings mapping expresses high-level language constructs implemented low-level software hardware mappings performance information collected arbitrary levels abstraction related language level nouns verbs build mappings layers abstraction performance tools collect mapping information information forms real systems compilers emit symbolic debugging information programming tools map memory addresses source code lines data structures common symbolic debugging information seldom complete set mapping data needed performance tools list data structures line code mapping execution activity data structures mechanisms mapping high-level parallel performance data bruce irvin barton miller rbi informix bart wisc informix software washington portland computer sciences department wisconsin dayton street madison typically mapping information stored application data-structures execution run-time system determine data-toprocessor mappings run time knowledge hardware resources run-time systems information program address space traditionally well-defined run-time systems application programming libraries communicate mapping information performance tools mappings one-to-one one-to-many many-toone many-to-many shown figure figure shows examples type mapping one-to-one mappings shown row table figure simple handle performance tool performance information measured sentence sentence maps sentence maps sentences one-to-many shown row correct assignment performance data difficult case tools split measured data equally sentences measured sentence maps splitting assumes equal distribution low-level work high-level code handle one-to-many mappings merging sentences measured sentence maps technique paradyn performance tools makes assumption distribution performance data helps identify high-level programming constructs implementations merged optimizing compiler avoids misleading programmer overly precise information many-to-one many-to-many mappings shown fourth rows figure reduced types mappings case aggregate sum average performance data low-level sentences treat result one-to-one one-to-many mapping show examples cases sections types mapping information mapping information include noun verb definitions detailed descriptions nouns verbs map nouns verbs section describe generic interface communicating mapping information performance tools sections describe information communicated compilers tools prior application execution static information execution dynamic information table figure shows components mapping information noun verb definitions describe performance tool set nouns verbs levels abstraction contained application mapping definitions equivalence classes performance data performance data collected source sentence presented relation source sentence destination sentence simple definition mapping information handle types mappings listed figure build many-to-one mapping defining mappings source sentences destination sentence build one-to-many many-to-many mappings similar combinations basic one-to-one mapping definition differences types mappings exploited interpreted performance tool mappings static mapping information static mapping information mapping information type mapping assign low-level costs high-levelstructure one-to-one low-level message send implements high-level reduction measurements equivalent measurements one-to-many low-level function implements reductions cost split evenly merge set assign cost entire set many-to-one low-level functions implement source line aggregate costs assign cost line many-to-many source code lines implemented overlapping set low-level functions aggregate costs treat one-to-many mapping figure types upward mappings provided performance tool prior execution application program illustrate static mapping information present figure figure shows subset static mapping information fortran program mapping information defines mapping compiler generated function fortran source code lines records define source-level nouns line line source-level verb executes records defines base level noun compiler generated function cmpe corr verb cpu utilization finally records define mappings cpu utilization base level function execution source code lines mapping information statements lines source code implemented single low-level routine performance measurement tool measure cpu utilization cmpe corr present information execution source code lines performance tool split execution costs source code lines merge lines inseparable unit make interpretations mappings static mapping information application program executable image separate file auxiliary database static location location mapping information communicated performance tools mappings high-level abstractions method communicating static mapping information discussed section simple method compilers describe important languagespecific program-specific information performance tools information defined statically performance tools process execution application program avoid competition resources application program static mapping information provide information mappings determined application execution noun line abstraction fortran description line source file usr src prog main fcm noun line abstraction fortran description line source file usr src prog main fcm verb executes abstraction fortran description units cpu noun cmpe corr abstraction base description compiler generated function source code verb cpu utilization abstraction base description units cpu mapping source cmpe corr cpu utilization destination line executes mapping source cmpe corr cpu utilization destination line executes figure examples static mapping information dynamic mapping information dynamic mapping information includes mapping information generated application execution includes types information static mapping information figure differs static mapping information communicated performance tools program execution application dynamically allocates parallel data objects application dynamically communicate definition noun performance tool application dynamically distributes data object parallel processing nodes application dynamically define mapping object processor nodes performance tool performance tool dynamic mapping information run time relate performance measurements abstract program constructs activities section discuss important techniques collecting dynamic mapping 
adaptive cost model parallel program instrumentation jeffrey hollingsworth barton miller computer science department wisconsin maryland west dayton street college park madison hollings umd bart wisc abstract software based instrumentation frequently measure performance parallel distributed programs software instrumentation introduce perturbation program measured paper present data collection cost system programmers feedback impact data collection application addition introduce technique permits programmers define perturbation application tolerate regulate amount instrumentation ensure threshold exceeded describe implementation cost model presents results measure instrumentation overhead real applications introduction monitoring critical understanding performance execution parallel distributed application technical economic reasons software based monitoring generally measure applications software based monitoring introduces overhead application alter performance paper present manage perturbation caused data collection approach based instrumentation cost system ensures data collection analysis accomplished controlling performance overhead instrumentation unique feature approach lets programmer control overhead introduced monitoring simply subjected presenting author work supported part wright laboratory avionics directorate air force material command usaf grant arpa order nsf grants ccrand cdadepartment energy grant de-fg office naval research grant -jhollingsworth supported part arpa graduate fellowship high performance computing government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government handle instrumentation overhead avoid introducing place previous paper approach performance monitoring called dynamic instrumentation dynamic instrumentation delays instrumenting application program execution permitting dynamic insertion alteration instrumentation program execution strategy enabling instrumentation needed greatly reduces amount data collected perturbation caused instrumentation system instrumentation requests impact program performance purpose cost system control instrumentation overhead environment dynamic instrumentation manage perturbation caused instrumentation developed instrumentation cost system ensure data collection analysis excessively alter performance application studied model associates cost resource resources include processors interconnection networks disks data analysis workstations cost system divided parts predicted cost observed cost predicted cost computed instrumentation request received observed cost instrumentation enabled computing predicted cost instrumentation data collection starts decide requested data worth cost collection user requests performance data predicted cost collection application run-time decide impact collecting data high warrant collection predictive information feedback reduce defer instrumentation request higher-level performance analysis tools cost prediction control aggressively instrument program search performance bottlenecks cases control instrumentation overhead tools quickly isolate performance problem examples situation section predicting cost data collection prior instrumentation execution data important make actual cost data collection matches predicted cost observed cost tracks impact enabled instrumentation application computing verify actual impact instrumentation held predefined limits observed cost exceeds limits feedback provided user higher-level tool feedback dynamically maintain approximately fixed level instrumentation overhead part cost model effective measure perturbation caused instrumentation regulate section summarize previous work dynamic instrumentation automated control instrumentation search model section introduces cost model describes compute perturbation due instrumentation section show cost model control level instrumentation overhead sections describe initial implementation parts cost model present results show closely predicts actual perturbation real applications running unix workstation thinking machines cmin section present short case study effectiveness higher level performance tools cost system section discusses related work conclusions presented section dynamic instrumentation search model cost system builds previous work dynamic instrumentation search tools performance bottlenecks briefly review work recent work performance monitoring tools focused areas programmers understand source performance problems providing raw performance data efficiently collect performance data large long running applications section summarize work address problems data collection critical problem parallel program performance measurement system understand performance parallel programs collect data fullsized data sets running large numbers processors collecting large amounts data excessively slow program execution distort collected data variety approaches efficiently collect performance data common approaches event tracing statistical sampling techniques limitations volume data gather granularity data collected approach data collection called dynamic instrumentation defers instrumenting program execution approach permits dynamic insertion alteration instrumentation program execution time program execution consumer performance data performance consultant request dynamic instrumentation system start collecting metric combination resources satisfy request instrumentation code generated inserted application program consumer performance data longer performance data instrumentation code removed application program meet challenges providing efficient detailed instrumentation needed make radical traditional performance data collection wanted instrumentation approach usable variety high level tools needed simple interface interface developed based abstractions resources metrics resources similar nodes axis search model metrics time varying functions characterize aspect parallel program performance metrics computed subset resources system cpu utilization computed single procedure executing processor entire application dynamic instrumentation types runtime code synthesis library commonly primitive functions included application executable image small bits code called trampolines generated inserted application collection specific metric focus requested types trampolines base trampoline point application instrumented mini-trampoline call instrumentation library topic performance measurement investigating programmers make sense collected performance data search model methodology structured programmers quickly precisely isolate performance problem examine large amount extraneous information based answering separate questions application performing poorly bottleneck problem occur iteratively refining answer questions precisely describe programmers reason program performing expected deliver answers posing questions automate search process performance question programmers application running slowly answer question types problems bottleneck parallel program represent potential bottlenecks hypotheses tests hypotheses represent fundamental types bottlenecks occur parallel programs independent program studied hypothesis program synchronization bound tests boolean functions program exhibits specific performance behavior related hypothesis expressed terms thresholds test evaluate true time spent waiting synchronization searching axis classify type problem parallel application fix problem specific information required knowing program synchronization bound suggests synchronization operations large application hundreds thousands operations find synchronization operation causing problem isolate bottleneck specific resource search axis axis formed collection logically independent resource hierarchies resource hierarchies include synchronization objects source code threads processes processors disks multiple levels hierarchy leaf nodes instances resources application searching axis iterative consists traveling individual resource hierarchies programs general parallel programs distinct phases execution simple program phases execution initialization computation output single phase program performance similar enters phase behavior program change radically program enters phase execution performance bottlenecks change result decomposing program execution phases convenient programmers understand performance program component search model search model axis axis programmers exploit phase behavior programs find performance bottlenecks searching axis involves testing current hypotheses current focus intervals time application execution choose interval time program initialization key component search model ability automatically search 
performance bottlenecks automation accomplished making refinements axes requiring user involved automated refinement manual user directed searching hybrid combinations manual automated searching dynamic instrumentation implemented part paradyn parallel program performance monitoring environment initial implementation search model model called performance consultant incorporated paradyn cost model dynamic instrumentation data collected point program longer remains fixed entire program execution time request instrumentation received instrumentation overhead point change addition types instrumentation requests decidedly effects program performance model associates instrumentation cost resource resources include processors interconnection networks disks data analysis workstations cost system divided parts predicted cost observed cost predicted cost computed instrumentation request received estimate overhead desired instrumentation observed cost computed instrumentation executes notification perturbation exceeded user expectations essence observed cost model performance metric techniques computing performance metrics dynamic instrumentation monitoring performance problems search model previous section implement model predicted cost knowing expected effect instrumentation request performance tools programmers opportunity decide instrumentation request worth expected cost developed predicted cost model assess overhead instrumentation request information performance consultant control amount instrumentation enabled program section describe predicted cost model predicted cost expected overhead collecting data compute metric focus combination resources compute predicted cost instrumentation request arrives instrumentation inserted application predicted cost expressed percentage utilization resource system required collect desired data important question resources included model individual copies resource counted separately cpu considered resource group processors track cost instance resource maximum predicted cost instance resource compare threshold gain experience predicted cost model evaluate choices make model concrete compute expected cpu perturbation dynamic instrumentation cpu time perturbation due insertion instrumentation primitives points program executable image predict cpu time perturbation single point program pieces information instrumentation inserted point cost executing instrumentation frequency execution point figure shows predicted instrumentation cost computed information multiply overhead predicates primitives point point expected execution frequency compute predicted perturbation sum information points predicted cost instrumentation request metric definitions enumerate instrumentation primitives predicates inserted based measurements dynamic instrumentation precise cost instrumentation primitive trampoline request difficult part estimating frequency execution point application processes primitive overheads predicted cost observed cost static event frequency observed cycle counts super scalar parameter cache parameters clock frequency metric manager instrumentation manager code count inst cycles figure computing predicted observed costs data execution frequency points static model procedure call frequency approach wild guess adjust based runtime data initial accurate associate point program expected frequency point static based point type model types points system calls message passing routines normal procedure calls part effort required implement dynamic instrumentation define constants predicted cost conjunction observed cost critical values estimates perfect effectively application executes cost information updated based actual values application monitored total predicted cpu time perturbation sum predicted cpu time perturbation instrumentation point denote predicted cost application cpred observed cost predicted cost based model instrumentation perturbs program execution good idea check model matches reality observed cost model observed cost affect application collecting data purpose check overhead data collection exceed pre-defined levels exceeds levels report higher level consumers data observed cost acts alarm system report instrumentation hand threshold higher predicted cost actual cost differ predicted cost resource contention application data collection affect cost collecting data consume large percentage resource interconnection network application resource impact application small alternatively data collection resource application heavily major impact application performance perturbation effects difficult fully predict priori measuring instrumentation vital uncertain parameter predicted cost model execution frequency point result goal observed cost model verify compute observed cost model add small amount instrumentation instrumentation record execution time information periodically sampled application based values compute observed cost aggregate perturbation exceeds user defined threshold report event figure shows observed event execution frequency compute predicted cost denote observed cost cobs observed cost performance metric characterize type bottleneck parallel program developed isolating bottlenecks parallel programs search model difference bottleneck interested created data collection system programmer treat potential bottleneck application bottleneck synchronization blocking time search model search model observed cost expressed additional hypotheses axis isolated specific resources axis characterized temporally axis predicted cost control perturbation computing predicted cost part story equal importance information fundamental question perturbation application tolerate applications tolerate amounts perturbation instrumented program longer representative original addition depending desired accuracy coarse measurement session final tuning programmers tolerate perturbation application accommodate varying programmer control amount perturbation tool inflicts application developed technique lets programmer measurement session set tolerable perturbation application system resource thresholds moderate instrumentation inserted application goal perturbation threshold ensure total cost data collected exceed pre-defined threshold resource request instrumentation received predicted cost computed request accommodated exceeding thresholds processed request deferred describe predicted cost search model manual search mode predicted cost simply acts check request hypothesis evaluated undue perturbation automated search mode interaction predicted cost model search process complex recall automated searching develop ordered list refinements test work list adding instrumentation evaluating results predicted cost model ordered list request instrumentation test test request deferred instrumentation overhead high stop requesting instrumentation program continue execute find refinement true start refinements bottleneck evaluating set hypotheses pre-defined time interval hypotheses true stop set hypotheses move group list refinements perturbation threshold regulates number hypotheses potential performance problems considered time raising threshold search system tests higher perturbation decrease accuracy results changing threshold change hypotheses tested simply tested implementation describe initial implementation cost model added cost model paradyn parallel performance tools paradyn runs network workstations running pvm parallel hardware thinking machines cmwe describe results case study conducted measure accuracy observed predicted cost models case study involved sequential applications running unix workstation parallel application running cmwe found wide variety degrees instrumentation inserted measured program running time instrumentation original running time observed cost estimate initial implementation cost model includes direct cpu cost instrumentation reasonable approximation machines cmthe cmuses gang scheduling applications context switched processor interconnection network time dynamic instrumentation implemented machine instrumentation share time quanta application perturbation interconnection network purpose observed cost model report time consumed instrumentation simplest implement add additional instrumentation system record time spent executing instrumentation code overhead required execute meta-instrumentation expensive expensive instrumentation measure cheap accurate measure cost instrumentation developed implementation observed cost model approximate information requires additional instruction instrumentation point trampoline implement observed cost model added additional instruction trampoline record number machine cycles required 
information dynamic instrumentation reduce perturbation effects collecting dynamic mapping information data structure called set active sentences discover verb mappings difficult detect dynamic instrumentation mapping point function procedure line code application dynamic mappings constructed run-time system routine allocates parallel data objects distributes processors return point routine defined mapping point mapping data objects processor nodes determined prior point goal identify mapping points application instrument code reports mapping information performance tool instrument points adding source code calls performance tool dynamic instrumentation insert mapping instrumentation run time dynamic instrumentation technique external tool binary image running executable collect performance data basic technique defines points instrumentation inserted predicates guard firing instrumentation code primitives implement counters timers dynamic instrumentation advantage traditional static techniques performance tools instrument points needed provide performance data point instrumentation execution perturbations dynamic mapping instrumentation define subset points consisting points generate mapping information typically subset language programming library includes return points subroutines data structures allocated distributions parallel processors determined application executes performance tool insert mapping instrumentation beginning execution leave insert delete mapping instrumentation execution technique reduces run-time perturbation miss mapping decisions noun verb definitions set active sentences dynamic mapping information difficult determine simply instrumenting mapping points application verb mappings layers abstraction difficult detect implementation layer hidden layers software engineering reasons section describe set active sentences sas data structure dynamically map concurrent sentences layers abstraction describe sas high performance fortran describe kinds questions asked answered sas describe limitations sas approach description sas set active sentences sas data structure records current execution state level abstraction similar procedure call stack track active functions sentence level type information description noun definition level abstraction descriptive information verb definition level abstraction descriptive information mapping definition source sentence destination sentence figure types mapping information asum sum bmax maxval figure hpf code abstraction active adds sas sentence inactive deletes sas sentences contained sas concurrently considered dynamically map hpf code fragment figure code concerned problem relate low-level message high-level array reduction sum reduction line maxval reduction line code imply messages processors distributed memory parallel computer assume node parallel computer holds subsections arrays node reduces subsections sending local results nodes compute global reductions assume performance tool measure lowlevel mechanisms message transfer message send receive routines monitor execution high-level code line code active array active reduction performed array answer questions messages summations finding maxval time spent sending messages summations questions specific data-parallel fortran hpf code figure representative questions language built multiple layers abstraction system explain low-level performance measurements terms high-level programming constructs vice versa sas approach dynamic mapping defer performance questions run time measure sentences satisfy performance question explained sas track sentences active level abstraction sentence active monitoring code notifies sas sas remembers active sentences low-level sentence measured counter timer means monitoring code queries sas determine sentences active relates low-level sentences active sentences higher levels figure shows contents hypothetical sas hpf code figure represents snapshot sas moment message part computation sum array shows sentences active hpf level abstraction base level part application user code programming libraries system level code add remove sentences sas existence layers sas resembles performance tools sequential programs make monitored program function call stack program function call stack records functions active point time exploring call stack performance tool relate performance measurements function ancestors program call graph users performance tool understand function activity relates dynamic structure programs sas record active sentence sentence discovered examining call stack defined sas sentences active reduce size sas advantage run-time requests performance information eliminate uninteresting sentences sas request measurements array sas avoid keeping sentences figure sas message hpf line executes hpf sums base processor sends message line represents active sentence performance questions meaning sum cost summations processor send cost sends processor sum processor send cost sends summed sum processor send cost sends summed figure performance questions performance questions sas track performance questions asked nouns verbs define performance question vector sentences meaning performance question performance measurements resource utilization made sentences question active figure shows performance questions meanings hpf code questions figure consist sentences noun verb easily generalize questions complex sentences altering operation sas monitoring code sas answer types questions listed figure component performance question represents predicate satisfied monitoring code measure cpu time wall-clock time channel bandwidth execution cost question make sas flexible extending definition performance questions extension include boolean disjunction negation incurring added cost evaluating complex expressions distributed memory defined sas global data structure target hardware systems support shared global memory globally shared memory store sas today parallel systems globally shared memory pay synchronization cost contention globally shared data structure fortunately sas approach duplicate sas node parallel computer application code duplicated single program multiple data spmd programs individual sas operate independently long performance questions asked require information sass performance questions listed figure answered sharing information nodes interesting performance questions answered information sentence activity node distributed database system server process performs disk reads behalf clients measure server disk reads correspond client query sas information answer performance question server reads disk client query active distributed sas client sas server client sas server sas communicate performance question answered client sas send sentence client query active server sas sentence active inactive limitations sas approach sas approach relating low-level performance information high-level activities limitations figure asynchronous sentence activations sas time advances downward user process kernel func write disk write disk write disk write sas func executes kernel writes disk active inactive sas approach handle asynchronous activation sentences unix system measure kernel disk writes occur behalf function user process figure shows time-lines hypothetical unix process kernel user process makes write system call kernel kernel writes information disk actual writes disk occur column figure shows sas records activities figure shows sas function execution sentence kernel disk write sentence time kernel disk writes behalf function func measured sas sentence activity notifications sas unnecessary execution costs code figure performance questions array activation notifications array sas pay run-time cost notification eliminate cost dynamically removing notifications executing code sentences ordered performance questions current definition performance question question messages summation syntactically equivalent question summations occur messages advantage sentence order performance questions distinguish performance questions study cm-fortran paradyn paradyn performance measurement tool 
dynamic instrumentation measure performance data requested users paradyn starts application executing waits user requests measure performance metrics instruments running application rewriting application executing binary image sends stream performance measurements back user limiting instrumentation requested data paradyn greatly reduce instrumentation intrusion users measure large long-running applications large-scale parallel computers paradyn includes performance display modules users view performance metric streams graphically execution applications paradyn includes automated module called performance consultant users find performance problems applications paradyn receives information levels abstraction resources metrics mapping information interfaces paradyn daemons import static mapping information paradyn information format pif files load application executable pif files emitted compilers programming environments external sources define source-level language code data objects contained application pif files tools explain paradyn map requests highlevel language resources metrics requests base resources metrics functions cpu time pif format external tools communicate descriptive information resources metrics paradyn language-dependent applicationdependent visualization modules receive descriptive information add meaning visual displays paradyn dynamic instrumentation library sends dynamic mapping information paradyn daemon process communication channel performance data dynamic instrumentation library linked application program measured paradyn interface procedures application describe mappings executes dynamic instrumentation library sends mapping information paradyn daemons daemons forward mapping information data manager data manager dynamic mapping information static mapping information paradyn dynamic performance instrumentation techniques turn turn flow dynamic mapping information dynamic instrumentation applications avoid cost emitting mapping information run paradyn paradyn users turn mapping information collection needed paradyn users turn turn dynamic mapping instrumentation points eventually tie enabling disabling individual mapping instrumentation points requests performance information fortran-specific resources metrics static dynamic mapping interfaces sections paradyn measures important resources metrics unique fortran runtime system cmrts section describe details paradyn measures performance data fortran parallel assignment statements parallel arrays measures cmrts-specific activities broadcast messages point-to-point messages reductions argument processing performance data parallel arrays arrays fundamental source parallelism dataparallel fortran data objects memory nodes cmsystem performance fortran program depends greatly efficiency computation communication arrays paradyn measures fortran arrays step process paradyn dynamic instrumentation library detects array allocations deallocations forwards resource mapping information paradyn array allocated call cmrts allocation routine dynamic instrumentation library notifies paradyn array establishes unique identifier array tells paradyn dynamic mapping interface section subregion array stored node system paradyn information build cmfarrays hierarchy shown figure figure shows module bow fcm functions corner arrays arrays corner called tot expanded show subregions step occurs user requests performance metric array user chooses array measure paradyn data manager maps array proper cmrts identifier system node sends message parallel debugging interface dynamic instrumentation set active sentences sas section module located node system sas module sets boolean variable true requested array active sets variable false array inactive cmrts node code block dispatcher notifies sas array activation deactivation sending input arguments node code block sas sas searches arguments arrays requested paradyn collect metrics paradyn dynamically inserts instrumentation code node-level subroutines metric measured array dynamicallyinserted instrumentation code checks array node-global boolean variable discussed measuring metric paradyn constrain metric array interest paradyn easily existing visualization modules time plots bar charts tables visual display performance information data objects visualization modules simply treat data object resource paradyn visualization interface open build specialized visualization modules advantage properties geometric structure unique arrays figure cmf-level axis parallel code constructs parallel code constructs fortran programmers manipulate parallel arrays code constructs include parallel assignment statements forall iterators intrinsic operations sum min transpose paradyn measures parallel code constructs mapping statement node code blocks implement paradyn receives mapping information pif files section create fortran pif files simple utility parses fortran compiler output files utility scans compiler output files lists parallel statements parallel arrays node-code blocks produces pif file defines statements arrays paradyn describes mappings statements code blocks paradyn user interface displays statements cmfstmts hierarchy axis display shown figure users interact axis display choose resources cmfstmts hierarchy cmfarrays hierarchy combination hierarchies users choose resources hierarchies cmrts-level abstraction base level abstraction cmrts metrics paradyn dynamic instrumentation system includes language describing measure metrics language called metric description language mdl users precisely turn process-clock timers wall-clock timers increment decrement counters paradyn compiles descriptions code inserted running applications precisely moment metric requested mdl define metrics specific fortran cmrts shown table figure table lists metric description metric measures metrics constrained parallel arrays subsections arrays parallel assignment statements combinations assignment statements arrays metrics cover activities verbs understand performance fortran applications summary important problems collecting storing communicating mapping information performance tools high-level parallel programming languages format interface static dynamic mapping information presented set active sentences method identifying complex dynamic activity mappings bibliography adve wang mellor-crummey reed anderson kennedy integrated compilation performance analysis environment data parallel programming technical report crpc goldberg john hennessey performance debugging shared memory multiprocessor programs mtool supercomputing pages november graham kessler mckusick gprof call graph execution profiler acm sigplan symposium compiler construction june anoop gupta margaret martonosi tom anderson memspy analyzing memory system bottlenecks programs performance evaluation review june jeffrey hollingsworth barton miller jon cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference bruce irvin barton miller performance tool high-level parallel programming languages karsten decker rene rehmann editors programming environments massively parallel distributed systems pages birkhauser verlag alvin lebeck david wood cache profiling spec benchmarks case study ieee computer october barton miller mark callaghan jonathan cargille jeffrey hollingsworth bruce irvin karen karavanic krishna kunchithapadam tia newhall paradyn parallel performance measurement tools ieee computer november steve sistare don allen rich bowker karen jourdenais josh simons rich title data visualization performance analysis prism programming environment programming environments parallel computing pages north-holland pure software incorporated menlo park quantify user guide thinking machines corporation cambridge fortran manual january metric description cm-for tran cmf vel computations computation time count computation operations time spent computing results reductions reduction time summations summation time maxval count maxval time minval count minval time count array reductions time spent reducing arrays count array summations time spent summing arrays count maxval reductions time spent computing maxvals count minval reductions time spent computing minvals array transformations transformation time rotations rotation time shifts shift time transposes transpose time count array transformations time spent transforming arrays count array rotations time spent 
rotations count array shifts time spent shifting arrays count array transposes time spent transposing arrays scans scan time count array scans time spent scanning arrays sorts sort time count array sorts time spent sorting arrays cm-runtime cmr vel argument processing time time spent receiving arguments cmcontrol processor broadcasts broadcast time count broadcast operations time spent broadcasting cleanups cleanup time count resets node vector units time spent resetting node vector units idle time time spent waiting control processor node activations count node activations control processor point-to-point operations point-to-point time count inter-node communication operations time spent sending data parallel nodes figure paradyn metrics fortran applications 
execute trampoline components instrumentation trampolines primitives small number primitives performance measured platform measured cycle counts observed cost instructions trampoline generated dynamic instrumentation system needed track number cycles required trampoline generated cost mini-trampoline machine cycles cost trampoline primitives calls cost base trampoline fixed instruction sequence executes trampoline includes code increment total observed cost cycle count total observed cost stored register dedicated task observed cycle counter precise count number instructions executed instrumentation convert instruction counts time observed cost approximation impact super-scalar processors caches approximated super-scalar processors issue instruction machine cycle dependencies operands instructions rarely instructions issued maximum rate likewise memory hierarchies add uncertainty execution time due cache misses instrumentation instructions data initial implementation approximations convert cycle counts time processor sequential experiments two-way super-scalar processor decided pick single constant factor characterize degree instrumentation super-scaling based tests typical instrumentation sequences instructions cycle observed cost model alternative analyze instrumentation sequences develop precise estimate number cycles required instrumentation block wang framework modeling instructions functional unit requirements accurate estimate account cache time measured times instrumentation primitives measurements resulted approximately cache miss primitive alternative compute cache misses model cache complex model super-scalar instruction times final step converting counted cycles time divide cycle count clock frequency machine integrating implementation observed cost dynamic instrumentation easy instrumentation system designed support reading external sources performance data hardware counters simply treat observed cost metrics normal dynamic instrumentation mechanisms report data higher level consumers performance data treating observed cost normal metric existing facilities dynamic instrumentation constrain metric resource combinations application sparc abi reserved registers purpose platforms memory perform register scavenging part pre-pass make program prior running system implementation predicted cost model based techniques compute cycle time trampoline observed cost model counting time trampoline executed estimate event frequency values calls user procedures calls system library routines future plan employ sophisticated prediction techniques developed larus evaluation cost system implemented observed cost system interested tracked actual perturbation applications investigate ran sequential programs floating point spec benchmark suite parallel application test program program recorded cost measures tno inst user cpu time needed run application program instrumentation measured unix timing commands tobs user cpu time application program dynamic instrumentation measured unix timing commands cpred cost dynamic instrumentation calculated predicted cost model instrumentation costs event frequency estimates end section cobs time cost instrumentation calculated tobs tno inst cobs cycles cost dynamic instrumentation calculated recording number machine cycles executed instrumentation difference cobs time cobs cycles represents inaccuracies calculations observed cost differences cobs time cpred represent inaccuracies calculations predicted cost accurate calculation observed cost crucial accurate calculation predicted cost important program measured performance levels instrumentation enabled base procedure profiling performance consultant base performance consultant full base amount instrumentation inserted starting dynamic instrumentation consists instrumentation record start end application application run child process unix ptrace facility procedure procedure profiling consisted turning cpu metrics user supplied procedure application similar unix utility prof base performance consultant base case enabled initial instrumentation performance consultant search bottleneck application full performance consultant full case ran performance consultant fully automated mode turn instrumentation needed interested assessing accuracy cost model cost model control number refinements considered completely overwhelm application instrumentation enabling refinements compromise configured performance consultant ten refinements sequential applications measured ear fpppp doduc applications selected reflect variety programming styles instrumentation inserted procedure boundaries wanted cross section procedure granularity procedure call frequency measured program tomcatv represent low end procedure call frequency unable measurably perturbed programs run idle sparcstation running mhz observed cost results application ear shown top figure program consists files functions tno inst program ten minutes averages procedure calls execution results shown table show cycle-counted observed cost timed observed cost total instrumentation overhead cobs time ranged cpu time un-instrumented version tno inst program measured fpppp quantum chemistry benchmark electron integral derivatives consists files procedures tno inst program minutes average procedure calls timed observed cost program ranges results show error cycle-counted observed cost cobs time cobs cycles base cpu time application program doduc monte carlo simulation time evolution thermohydraulical model nuclear reactor composed files procedures program averages procedure calls tno inst program minutes obs time cobs cycles cobs time cobs cyclesversion time time percent time percent percent application ear un-instrumented base procedure base full application fpppp un-instrumented base procedure base full application doduc un-instrumented base procedure base full figure cycle-counted timed observed overhead table shows difference cycle-count estimates observed cost cobs cycles actual timed values cobs time percentages relative uninstrumented cpu time tno inst times shown seconds timed observed cost program ranged percent tno inst program largest error observed cost metric performance consultant full search case cycle-counted observed cost time observed cost diverge additional overhead required insert delete instrumentation program conducted number experiments verify fact unable fully account components overhead continuing investigate fourth program measured parallel graph coloring application running node partition thinking machines cmthe nodes cmare mhz super-scalar sparc processors program written explicit message passing library cmmd provided tmc comparison cycle-counted observed cost time observed cost program appears figure tno inst program seconds cmjust enabling dynamic instrumentation system slowed program due addition measurement process periodic ptrace poll application performance data difference cycle-counted observed cost timed observed cost ranges obs time cobs cycles cobs time cobs cyclesversion time time percent time percent percent un-instrumented base procedure base full figure cycle-counted timed observed overhead parallel application table shows difference timed observed cost cobs time cycle-counted observed cost cobs cycles parallel graph coloring application percentages relative uninstrumented cpu time tno inst times shown seconds predicted cost gauge effective predicted cost model ran applications study observed cost metric measured predicted cost metric numbers based static predicted cost information include compensation based observed cost predicted cost ear program shown figure errors cases tno inst program procedure call case predicted cost surprising predicted cost model point execution frequency estimate calls procedures program numbers cases typical amount type instrumentation inserted search model obs time cpred cobs time cpredversion time percent time percent percent application ear base procedure base full application fpppp base procedure base full application doduc base procedure base full figure timed observed costs predicted costs table compares timed observed costs cobs time predicted cost 
model cpred sequential applications percentages relative uninstrumented cpu time tno inst times shown seconds middle section figure shows predicted cost fpppp application cases estimated cost tno inst addition largest error procedure profiling case part figure shows predicted cost doduc application errors predicted cost model ranged case largest error case instrumenting cpu time procedures finally measured predicted cost compared timed observed cost parallel graph coloring program figure shows results case case interesting predicted cost closer observed cost sequential applications reason lies number frequency procedure calls program author wrote compare graph coloring heuristics time spent graph library instrumented study non-library procedures calls instrumented happened match predicted cost model obs time cpred cobs time cpredversion time percent percent rbase procedure base full figure timed observed cost predicted cost parallel application table compares timed observed costs cobs time predicted cost model cpred graph coloring application percentages relative uninstrumented cpu time tno inst times shown seconds cost control searching current principal cost system control hypothesis evaluation performance consultant interested quantifying cost system regulate perturbation environment study cost system conducted experiments compared searching bottlenecks cost system controlled hypotheses evaluated simultaneously fixed limit number hypotheses evaluated unlimited number hypotheses evaluated application ran performance consultant times time cost limit perturbation time fixed limit refinements current hypothesis limit refinements current hypothesis limit refinements intended provide comparison alternative strategy controlling cost data collection unlimited case measure worst case impact instrumentation application interested evaluating criteria effectiveness search system wanted verify instrumentation cost held cost limit set user case interested comparing quickly performance problem isolated method run application compared bottlenecks identified performance consultant ear application performance bottleneck found cases order refinements considered slightly conclusion doduc application performance bottleneck found limit hypothesis limit perturbation high unlimited case bottleneck identified fpppp application hypothesis limit unlimited cases identified procedure bottleneck cost limit identified procedure cpu time profile application showed procedures consumed cpu time flagged bottlenecks thresholds results serial applications doduc ear fpppp shown figure time column reports amount elapsed time required performance consultant execute search applications time required search cost regulate hypothesis evaluation improvement search time ranged fpppp faster ear compared limit hypotheses cost based limit evaluate hypotheses faster hypotheses costs cost based limit permitted evaluation hypotheses simultaneously keeping overhead limit cost based limit identify problem faster unlimited search case saved time generating inserting instrumentation refinements application control method time avg cobs cycles max cobs cycles variance cobs cycles doduc hypotheses unlimited fpppp hypotheses unlimited ear hypotheses unlimited figure summary fixed cost based hypothesis evaluation table summarizes differences limit cost fixed limit hypotheses considered cost control mechanism column shows amount elapsed time required execute search column shows average cpu time perturbation reported cobs cycles fourth column shows maximum cpu time perturbation reported cobs cycles column shows variance cobs cycles verified cost control mechanism maintained instrumentation overhead target limits columns table figure summarize cost data collection application approach applications cost control hypothesis evaluation application finished execution search finished case held cpu time perturbation user defined limit cases peak cpu perturbation higher cost based limit hypothesis limit threshold applications evaluate hypotheses major impact application finally unlimited evaluation case peak cobs cycles ranged wide range cost unlimited case shows evaluate hypothesis wildly impact depending application likewise cost evaluating hypothesis depends hypothesis application regulating instrumentation based limit hypotheses evaluated result higher costs desired longer searching related work related topic part cost model work perturbation compensation goal perturbation compensation reconstruct performance unperturbed execution perturbed techniques generally require trace based instrumentation system post-mortem analysis reconstruct correct ordering events approach differs factor perturbation avoid predicted cost model quantify observed cost model area related work pablo adaptive instrumentation system pablo programmer specifies events recorded event log post mortem analysis program execution volume data collected exceeds thresholds system fall back producing event logs producing summary information amount data collected high summary information disabled approach pablo leaves underlying instrumentation place controls logging data technique advantage dynamic instrumentation disabling data collection completely removes instrumentation code latent perturbation due instrumentation code disabled execute instructions learn disabled control number hypotheses evaluated amount instrumentation changing data collected type data gathered remains constant matter perturbation conclusions future work cost model controls software instrumentation overhead based feedback feedback correlates high-level instrumentation abstractions resource limits percent cpu overhead predict amount overhead instrumentation facility provide information actual costs mechanisms built part paradyn parallel performance tool give programmer direct control instrumentation instrumentation data discarded reduce overhead buffered generation insertion instrumentation deferred expose overhead data collection class metric paradyn programmer explicit control overhead controls rate performance tool searches bottlenecks search model natural fit cost model implemented cost model paradyn demonstrated accurately track cost data collection applications working extend research directions plan incorporate additional resources cpu time cost model advantage sophisticated accurate models caches super-scalar processors system performance evaluation cooperative capacity management review vol aug jeffrey hollingsworth barton miller dynamic control performance monitoring large scale parallel systems acm international conf supercomputing tokyo japan july jeffrey hollingsworth barton miller jon cargille dynamic program instrumentation scalable performance tools scalable high-performance computing conf knoxville tenn malony performance observability phd dissertation department computer science illinois oct daniel reed ruth aydt roger noe phillip roth keith shields bradley schwartz luis tavera scalable performance analysis pablo performance analysis environment scalable parallel libraries conference anthony skjellum ieee computer society ko-yang wang precise compile-time performance prediction superscalar-based computers acm sigplan conf programming language design implementation orlando june youfeng larus static branch frequency program profile analysis ieee acm inter symposium microarchitecture nov jerry yan listgarten intrusion compensation performance evaluation parallel programs multicomputer international conference parallel distributed systems louisville oct 
shared-memory performance profiling abstract paper describes approach finding performance bottlenecks shared-memory parallel programs embodiment paradyn parallel performance tools running blizzard fine-grain distributed shared memory system approach exploits underlying system cache coherence protocol detect data sharing patterns potential performance bottlenecks presents performance measurements data-centric manner demonstration paradyn helped improve performance shared-memory application program factor introduction distributed shared memory dsm alleviates difficulty programing parallel computer hiding details communication abstraction shared address space convenient hide communication bottlenecks cripple program performance effectively shared memory programmers performance tools capable piercing abstraction relating program behavior underlying hardware actions paper describes technique collecting displaying shared-memory performance information key aspect approach detect cache block sharing patterns potential performance bottlenecks current system detects patterns low cost modified cache coherence protocol blizzard fine-grain distributed shared memory system running wisconsin cluster workstation cow key aspect technique paradyn parallel performance tools present shared-memory performance data data-centric manner relates events cache blocks program data structures shared memory programs communicate shared data underlying system hardware software responds memory communicating obtain copy data typically cached subsequent maintain global state implement coherent programming model load store actual communication depends memory system protocols program dynamic state ways difficult understand predict detecting hidden communication essential isolate eliminate shared-memory performance bottlenecks cache block migratory behavior false sharing programmer eliminate aligning padding data structures recent research focused tools custom protocols extensible memory systems offer programmers greater control shared memory systems programmer greatly reduce cost producer-consumer sharing increasing cache block size invalidate update protocol understanding program access pattern step improving shared-memory performance step memory profiling detect access patterns performance problems pattern detection mechanism integrated shared memory cache-coherence protocol incurs overhead requires programs importantly mechanism associates addresses events performance tool present measurements program level abstraction performance tool addresses relate memory accesses program data wisconsin cluster workstations cow collection sun sparcstation dual mhz ross hypersparc processors connected myricom myrinet ethernet zhichen james larus barton miller zhichen larus bart wisc computer sciences department wisconsin west dayton street madison work supported part wright laboratory avionics directorate air force material command usaf grant arpa order nsf grant mipnsf nyi award ccrand department energy grant de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government acm sigplan symposium principles practice parallel programming las vegas nevada structures conventional profiling techniques connect accesses statements execute call process shared-memory performance profiling memory profiling find performance problems built memory profiling extensive facilities paradyn performance tool work exploits blizzard custom protocols systems provide mechanisms associate shared memory communication data hardware shared-memory platform support fine-grain dsm system blizzard shasta exposes coherence protocol performance debugging underlying shared-memory hardware fast communication dsm system sort incur moderate overheads alternatively platform provide hardware features informing memory operations trap cache misses associate program memory coherence protocol actions paper illustrates memory profiling extended case study tuning sharedmemory protein folding code researchers wisconsin chemical engineering department memory profiling paradyn improved application performance factor efficiency nodes paper organized section briefly reviews features paradyn section describes approach shared-memory profiling implementation techniques section case study illustrates paradyn shared memory profiling identify eliminate performance problems section discusses automating search performance bottlenecks section describes related work paradyn basics section briefly describe basic characteristics paradyn performance tools readers familiar paradyn skip section paradyn parallel performance measurement tool runs sparc alpha power pa-risc platforms paradyn based dynamic instrumentation technology instrumentation code inserted changed removed running application standard performance metrics cpu usage blocking time paradyn instrument system hardware network activity visible application program address space paradyn basic abstractions metric focus metric time-varying function measures aspect application performance cpu utilization number procedure calls focus component running application paradyn views program collection resource hierarchies represent elements program code modules procedures machines hosts synchronization messages semaphores locks collection nodes resource hierarchy forms focus tool users request paradyn collect metrics foci interested paradyn dynamically instruments program criteria figure shows paradyn display resource hierarchies code hierarchy appears left modules program module procedures module memory profiling defined resource hierarchy memory lists program major data structures data structure list cache blocks identified memory addresses figure resource hierarchies paradyn code memory hierarchies visible shared-memory performance profiling step alleviate performance bottleneck detect shared memory systems performance problems arise excessive communication due interaction program data accesses system fixed cache coherence policy cache block values separately processors false sharing memory access produce messages false sharing shared-memory bottlenecks difficult detect statically readily apparent run time section describes technique shared-memory performance profiling pattern detection obvious place detect patterns shared-memory communication coherence protocol satisfies memory coherence protocols expressed state machine driven operations cache block recent systems including blizzard platform commercial systems sequent numa-q system implement state machines software opens possibility introducing states actions recognize access patterns indicative performance problems states actions change behavior coherence protocol provide efficient mechanism recognizing patterns transitions state machine pattern detection mechanism detects producer consumer migratory grouped read-only access patterns represent memory read represent write subscripts distinguish cache blocks superscripts distinguish processors block home node processor block originally allocated machine performs protocol actions block directorybased coherence protocols block owner processor write access migratory access pattern occurs block accessed processors turn interval processor accesses block sharing sequential concurrent coherence protocol sees migratory accesses sequence events form detect migratory sharing augmented protocol records block owner home node read write request processor arrives augmented protocol updates block lastowner field home node receives upgrade request write read-only block number sharers protocol compares requestor lastowner differ block appears migrating lastowner requestor augmented protocol records block migratory protocol clears property lastowner requestor number sharers producer-consumer access occurs block written processor subsequently read processors process repeats home node sees events migratory blocks write miss block readshared state augmented protocol compares requestor block lastowner identical block producer-consumer relationship accurate information obtained checking block sharer list requestor group access occurs cache block collection blocks abbreviation pattern home node repeatedly sees events form detect pattern augmented protocol tracks variable lastaccessed block processor accessed block records extra fields groupid guess accessingroup algorithm figure detect group accesses implementation alternatives augmenting coherence 
protocol collect additional information incurs cost space time section unrealistic expect parallel computer augmented protocol default architects build protocol hardware fortunately recent distributed shared memory dsm systems implement cache coherence protocols software offers advantages hardware ability support coherence protocol software protocols enable tools paradyn instrument measure protocol radical alternative informing memory operations set condition code trap cache miss similar operations detect protocol transitions hardware-based shared memory systems performance instrumentation maintain shadow directory tracks processors copies cache block cache miss shared address space information directory suffices determine currentblock guess lastaccessed currentblock groupid lastaccessed groupid currentblock accessingroup true lastaccessed accessingroup true currentblock guess lastaccessed currentblock groupid address currentblock curentblock accessingroup false lastaccessed currentblock figure algorithm detect group sharing actions coherence protocol perform alternative systems hardware support performance tune programs fine-grain distributed system similar blizzard shasta software layer redundant hardware shared-memory systems exposes coherence protocol performance tool hardware shared memory low latency ensures software overheads dsm system moderate performance counters existing systems sun ultrasparc record cache misses occur interval counters fully support memory performance profiling provide information cache blocks incurred misses memory profiling memory profiling associates coherence activity program data structures code forms bridge low-level coherence activities operate cache blocks programmer thinks higher level abstraction memory profiling extended paradyn ways added memoryand cache-specific performance metrics added data-centric views existing performance metrics performance metrics include frequency time coherence events messages synchronization events figure lists memory performance metrics blizzard cache coherence protocols run application address space paradyn collects metrics usual instrumentation techniques performance profiling typically associates metric control structure program tool reports cpu time messages module procedure loop statement complementary data-centric view associates metrics data structures insights program interaction memory system datacentric presentations distributed arrays data-parallel languages cache tools sequential programs data views added paradyn combine fine-grained profiling individual cache blocks scalability large data structures large programs low overhead present data added paradyn resource hierarchy shared memory figure shared-memory resources fit two-level hierarchy consisting data structures cache metric description metric description targetbarrier count application-level barrier ops targetbarrierwall time application-barriers activemessages count active messages activemessagewall time active messages bulkdatatransfers count bulk data transfers bulkdatatransferwall time bulk data transfers pagefaults count page faults pagefaultwall time page fault handling memoryblocktime wall time spent coherence misses stachereadmisses count read misses non-home nodes stachereadmisswall time non-home read miss handling homereadmisses count read misses home node homereadmisswall time home read miss handling stachewritero count write misses read-only blocks non-home nodes stachewriterowall time write misses read-only blocks non-home nodes homewritero count write misses read-only block home node homewriterowall time write misses read-only blocks home node stachewriteinv count write misses invalid blocks non-home nodes stachewriteinvwall time write misses invalid blocks non-home nodes homewriteinv count write misses invalid blocks home node homewriteinvwall time write misses invalid blocks home node invro count invalidations read-only blocks invrowall time invalidations read-only blocks invrw count invalidations writable blocks invrwwall time invalidations writable blocks polls count poll operations sentmsgs count messages selfmsgs count messages acks count acknowledges msgbytes count message bytes recvmsgs count messages received bufmsgs count messages buffered pollmsgs count poll messages figure blizzard paradyn memory performance metrics performance metrics blizzard cache coherence protocols blocks implementation paradyn creates counters timers collect performance metrics cache block data structure dynamic instrumentation insert code update counter timer paradyn data collection facility periodically reads values counters timers ships paradyn front end measure time handle coherence misses paradyn inserts code starts timer fault occurs stops timer application resumes record performance statistics cache block paradyn allocates counter timer block inserts code coherence protocol update counter timer faults block monitor contiguous data structure paradyn updates structure counter fault falls inside structure boundary major challenge memory profiling handling large number cache blocks shared-memory applications blocks form larger focus paradyn typically handles reduced overhead shipping shared memory information paradyn front end compressing shared-memory information batching messages memory profiling overhead challenge control instrumentation overhead instrumentation protocol handler discriminate monitored unmonitored block expensive number monitored blocks increases optimized instrumentation code technique called vectorization paradyn allocates vector counter timers monitored cache blocks indexes vector allocating single counters timers testing individual cache blocks vectorization reduced instrumentation overhead cost linearly proportional number monitored cache blocks constant cost vectorization test approximately cost instrumenting cache blocks simpler approach details reported figures report overhead profiling cache blocks data structures measurements version protein folding application section figures show vectorization instrumentation overhead independent number profiled cache blocks data collection overhead linearly proportional number counters timers data collection overhead counters timers number cache blocks instrumentation counter-based metrics timer-based metrics instrumentation data collection instrumentation data collection figure overhead profiling cache blocks vectorization counters timers performance metrics cache block stache block size application ran processors times seconds numbers parentheses percent increase instrumentation case number cache blocks instrumentation counter-based metrics timer-based metrics instrumentation data collection instrumentation data collection blocks blocks blocks figure overhead profiling cache blocks aggregation counters timers performance metrics data structure stache block size application program ran processors times seconds numbers parentheses percent increase instrumentation profiling entire data structure expensive profiling blocks separately instrumentation overhead independent size data structure data collection cost proportional number counters timers profiling data structure metrics incurs overhead approximately case study illustrate memory profiling identify eliminate performance bottlenecks shared-memory application tuned parallel application aid paradyn application written chemical engineering department wisconsin weighted-ensemble brownian web dynamics algomore recent versions paradyn data collection technique based shared memory reduces data collection costs rithm simulate protein association reaction folding version version application written fortran ran sgi power challenge version alternated sequential code parallel loops doacross directives converted fortran modified shared-memory programming model wisconsin cow cluster workstation started performance tuning version sequential performance bottleneck performance problem encountered serial portions application consumed significant fraction total execution time time spent handling coherence misses figure shows paradyn display execution times important routines time spent handling coherence misses function left bar chart figure shows node executes sequential code bar chart shows exefigure sequential performance bottleneck version bars label resource profiled ranuls cow wisc data procedure ranuls running host cow wisc exec inclusive metric total elapsed time spent procedure procedures calls memoryblockingtime total time spent 
page november mapping performance data high-level data views parallel program performance abstract programs written high-level parallel languages profiling tools provide performance data terms semantics high-level language high-level performance data incomplete performance problem explained terms semantics language ability view performance underlying mechanisms language correlate underlying activity language source code key techniques providing performance views ability map low-level performance data language abstractions identify kinds mapping information gathered support multiple views performance data describe mine mapping information compiler run-time environment describe information produce performance data higher levels present data terms code parallel data structures developed implementation mapping techniques data parallel fortran language running tmc cmwe augmented paradyn parallel performance tools mapping high-level language facilities study real data parallel fortran fortran applications mapping high-level language techniques allowed quickly understand applications modify obtain significant performance improvements introduction high-level parallel languages offer portable concise notations parallel programs compilers automatically map programs complex parallel machines languages free programmers difficult error-prone ineffective task parallel computations explicitly describe tool profiling performance parallel programs written high-level parallel language library paper concentrates mechanisms mapping low-level performance data high-level language control data work supported part wright laboratory avionics directorate air force material command usaf grant arpa order cdaand department energy grant de-fg government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government bruce irvin barton miller rbi informix bart wisc informix software washington portland computer sciences department wisconsin dayton street madison page november structures show techniques combined dynamic instrumentation technique on-the-fly instrumentation executable programs paradyn parallel performance tools present case studies tool profile improve performance real-world parallel applications approach tools high-level parallel languages emphasizes crucial features contributed usefulness system present performance data terms semantics programming language language abstractions insulate programmer details communication synchronization parallelization present performance data terms low-level node computing message passing difficult programmer relate information program existing tools source-level profiling commercial examples tools include mpp apprentice cray prism tmc cmand mppe maspar research world examples include pablo system universities illinois trace fortran programs present information terms source program tau oregon similar operations programs presenting performance data source code level high-level parallel language crucial sufficient language abstractions insulate programmer low-level details hide performance problem address problem feature tool programmer peel back layers examine lower level details program performance map lower-level operations source language statements caused map source language statements lower-level operations caused performance information programming layers parallel program built programmer view performance data layers map data layers mapping crucial mechanism providing high-level performance data simultaneously view lower-level performance data feature tool associate performance data data structures control structures tools associate performance metrics control structures procedures loops statements parallel languages data structure source parallelism arrays data parallel fortran objects parallel dialects associating performance information data structures provide intuitions performance problem bottleneck operations parallel arrays control profiling show main work diffused parts code facility mapping low-level performance data makes easy provide control data views data views performance study memory system behavior cprof memspy relate cache hits misses data structures sequential fortran programs algorithm animation visualization tools developed part sequential object-oriented programming systems object-oriented systems draws representation object hierarchy animates view execution information recordings object activations method invocations page november generalize ideas provide complete control data view performance section briefly describe model high-level performance data section describes provide mappings layered multi-view presentation performance data ideas built paradyn parallel performance tools section reports experiences tools study real parallel applications conclude section model high-level performance data developed framework discuss performance characteristics programs written programming models framework called noun-verb model noun program element performance measurements made verb potential action noun performed noun collection nouns verbs software hardware layer defines level abstraction nouns verbs level abstraction related nouns verbs levels abstraction mappings mapping expresses high-level language constructs implemented low-level software hardware mappings performance information collected arbitrary levels abstraction related language level nouns verbs mappings discussed detail section describe model examples data-parallel language fortran fortran implementation cmcomputers representative high-level parallel programming languages including hpf model applicable parallel programming models fortran program figure describe nouns verbs fortran language program declares multi-dimensional arrays line initializes elements array parallel assignment statement line assigns values subsection array line computes sum array line computes function upper left quadrant array assigns array line nouns fortran include program line subroutines forall loops arrays andb line statements lines verbs fortran include statement execution lines array assignment lines reduction line subroutine execution file program parameter integer asum forall asum sum forall end end figure fortran program page november execution instance program construct verb called sentence sentence consists verb set participating nouns cost cost sentence measured terms resources time memory channel bandwidth finally performance information consists aggregated costs measured execution collection sentences performance information array include measurements assignments lines reduction line performance information array include measurements assignment line method expression verb explicit meaning verb directly requested programmer program language construct implicit meaning programmer explicitly request verb occurred maintain semantics computational model high-level language programs built levels abstraction including source code language runtime libraries operating system hardware constructed systems level self-contained levels interact well-defined interfaces measure performance level measurements related constructs understood programmer model level abstraction performance measured represented distinct set nouns verbs nouns verbs level mapped nouns verbs levels cmsystems fortran program compiled sequential program set node routines sequential program executes cmcontrol processor makes calls parallel node routines parallel system routines runtime system cmrts cmrts creates arrays maps arrays processors implements fortran intrinsic functions sum max min shift rotate coordinates compute nodes parallel fortran array divided sections section assigned separate node node responsible computations involving local array sections array data non-local sections needed non-local data transferred computation proceed mappings fortran divide cmsystem levels abstraction highest level called cmf level nouns verbs fortran language middle level rts level rts level nouns include arrays allocated execution set arrays includes arrays found cmf level arrays generated compiler holding intermediate values evaluation complex expressions verbs rts level include array manipulations shift rotate put copy lowest level abstraction node level node level nouns include compute nodes 
node level verbs include compute wait broadcast communication point-to-point communication mapping relates nouns verbs level abstraction nouns verbs level mapping top-down bottom-up top-down mapping arrays nodes relate array subsection array set compute nodes bottom-up mapping node routines code lines relate cpu time recorded node routine fortran statement compiled page november mapping performance data performance tools parallel language applications performance information maps layers abstraction section mappings model provide represent relations abstraction levels nouns verbs performance information measured sentence relevant nouns verbs maps describe types mapping techniques mine mappings real systems method tracking dynamic verb mappings kinds mapping noun verb mappings parallel programming system forms simplest form static mapping information static mapping information mapping information provided performance tool prior execution application program traditionally performance tools exploited static information found debugging symbol tables explain runtime performance applications symbol tables performance tools map memory locations processor level abstraction procedures statements source code level tools traditional symbol tables identify static mappings lists program code data nouns key piece mapping information fortran programming system mapping node-level code blocks fortran-level parallel assignment statements compiler determines mappings compiles assignment statements node-level code merges separate node-level code blocks improve performance mapping information dynamic dynamic mapping information includes mapping information generated application execution differs static mapping information gathered program execution application dynamically allocates parallel data objects application dynamically communicate definition noun performance tool application dynamically distributes data object parallel compute nodes application dynamically define mapping object nodes performance tool performance tool dynamic mapping information execution relate performance measurements abstract program constructs activities mappings performance information one-to-one one-to-many many-to-one many-to-many types arise actual systems handled properly performance tools theses types mappings shown figure explanation tool handle interesting cases one-tomany many-to-many arise compiler runtime system merged activities sourcelevel constructs generated single low-level sentence implement case optimization obscured boundary source-level sentences performance tools split merge measured data compiler optimizations statements combined statement communication optimizations messages combined view performance data merged operation reported single merged set statements statepage november ments seconds synchronization blocking time split cost merged source statements assign proportion statement simply making split recursive procedure call chains gprof produce misleading results mining mapping data mining noun verb mapping data parallel programming system difficult programming systems provide information information provided non-standard ways programming languages naming nouns difficult performance tools generate unique names languages lisp explicitly identify dynamically created data objects nouns variety ways choice naming scheme depends parallel language functionality profiling tool goal naming schemes provide names intelligible programmer sufficiently disambiguous overly disambiguous desired cumulative effects detectable object function line number statement created object foo foo object allocated line function foo source file foo multiple objects created place desired effect object control structure allocated retval foo list returned function foo lisp program case lists returned foo interested cumulative behavior related return values function naming scheme scheme create undesired ambiguity cases differentiate calls memory allocation routine add names functions dynamic call stack retval foo bar list type mapping assign low-level costs tohigh-level structure one-to-one low-level message send implements high-level reduction measurements equivalent measurements one-to-many low-level function implements reductions cost split evenly merge set assign cost entire set many-to-one low-level functions implement source line aggregate costs assign cost line many-to-many source code lines implemented overlapping set low-level functions aggregate costs treat one-to-many mapping figure types upward mappings page november returned function foo called function bar similar scheme cprof memory profiler technique applied case object memory location allocated noun represent data object allocated memory location memory space re-used chance ambiguity scheme semantic meaning programmer give unique global local names dynamically allocated objects noun object allocated program execution scheme information order objects created unique object semantic meaning programmer programmer supply programmers supply extra argument calls memory allocator malloc scheme produce meaningful names puts extra burden programmer important creates non-standard interface system-supplied function languages dynamically create instances class class identifier queue instance class queue scheme similar case added type information combination schemes combining cases produce foo foo queue queue object memory address created function foo line file foo code structures simple language explicit function simple case complicated things inlining inheritance overloading type templates objects explicit names loops iterators switches simple statements require names generated simplest common approach code structures location defined foo doloop identify loop begins line fortran program contained file foo programmer insert compiler pragmas code control structures programmer give innerloop important loop languages programmers create control structures dynamically schemes proposed dynamic data objects static mapping information programming systems times deduce mapping information explicit channels information fortran provide explicit mapping information rts-level code blocks executed compute nodes cmf-level parallel assignment statements correspond parse compiler-generated listing files page november compiler-generated assembly code deduce mappings node code blocks statements parser generates tuples compiler-generated names code blocks file line number statement tuples entered paradyn information file one-to-one mappings paradyn merges statements node-level code blocks common paradyn automatically aggregates performance information node code blocks map merged group paradyn treats many-to-many mapping merging high-level nouns forming many-to-one mapping mapping points unique programming system mapping point function block line code application dynamic mappings constructed fortran system identified run-time functions allocate parallel arrays distribute compute nodes return point routine instrumented paradyn runtime instrumentation code examines return allocation function reports array compute node memory location paradyn reports fortran-specific mapping parameters paradyn paradyn interprets parameters generates mappings memory locations compute nodes fortran-level array subgrids paradyn user requests performance information array paradyn maps request instrumentation compute nodes monitors address range node-level code block runtime function called memory location parameter user requests performance information subgrid array paradyn translates memory location subset compute nodes tracking mappings active sentences dynamic mapping information difficult determine simply instrumenting mapping points application verb mappings layers abstraction difficult detect implementation layer hidden layers software engineering reasons describe set active sentences sas data structure dynamically map sentences concurrently layers abstraction describe sas high performance fortran describe kinds questions asked answered sas set active sentences sas data structure records current execution state level abstraction similar procedure call stack track active functions sentence level abstraction active adds sas sentence inactive deletes sas sentences contained sas concurrently considered 
dynamically map hpf code fragment figure code concerned problem relate low-level message high-level array reduction sum reduction maxval reduction imply messages processors distributed memory parallel comasum sum bmax maxval figure hpf code fragment page november puter assume node parallel computer holds subsections arrays node reduces subsections sending local results nodes compute global reductions assume performance tool measure low-level mechanisms message transfer message send receive routines monitor execution high-level code line code active array active operation performed array answer questions messages summations finding maxval time spent sending messages summations questions representative questions language system built multiple layers abstraction system explain low-level performance measurements terms high-level programming constructs vice versa sas approach dynamic mapping defer performance questions run time measure sentences satisfy performance question explained sas track sentences active level abstraction sentence active monitoring code notifies sas sas remembers active sentences satisfy outstanding performance question low-level sentence measured counter timer means monitoring code queries sas determine sentences active relates low-level sentences active sentences higher levels figure shows contents hypothetical sas hpf code figure represents snapshot sas moment message part computation sum array shows sentences active hpf level abstraction base level part application user code programming libraries system level code add remove sentences sas existence layers sas resembles performance tools sequential programs make monitored program function call stack program function call stack records functions active point time exploring call stack performance tool relate performance measurements function ancestors program call graph users performance tool understand function activity relates dynamic structure programs sas record active sentence sentence discovered examining call stack defined sas global data structure target hardware systems support shared global figure sas moment message hpf line executes hpf sums base processor sends message line represents active sentence page november memory globally shared memory store sas today parallel systems globally shared memory pay synchronization cost contention globally shared data structure fortunately sas approach duplicate sas node parallel computer application code duplicated single program multiple data spmd programs individual sas operate independently long performance questions asked require information sass sas approach tracking mappings asynchronous activities unix system measure kernel disk writes occur behalf function user process system writes disk occur asynchronously process execution result sas function execution sentence kernel disk write sentence time mappings kernel disk writes user function execution tracked sas case studies fortran applications paradyn performance experiments real fortran application codes section describe applications measurements applications paradyn performance information improve applications experiences applications show performance information node-level verbs helps explain performance problems difficult fully understand cmf level abstraction mapping mechanism key providing multiple views found data views performance add perspective performance studies fortran applications cases data views localize performance problems parallel arrays problems diffuse code views mappings made easy provide control data views note previous experience applications spent week study study final measurements modified application vibration analysis bow application called bow simulates oscillations bowed violin string application study variables initial transients bowed strings frictional interaction bow-hair string interface stiff strings code consists approximately lines fortran code contained single source file varying input parameters control resolution simulation length simulation simulation initial conditions code provided robert schumacher professor physics carnegie mellon began study bow examining performance characteristics application shown figure figure shows time plot primary cmf-level metrics cmf overhead run node partition cmsystem metrics constrained module subroutine statement array collected program total time measured paradyn cpus display figure shows rts-level node-level overhead costs dominate execution bow page november computation time significant cmf-level metrics accounts fraction cpu resources application display shows computation time metric uniform entire execution concluded majority application execution spent lower level rts-level node-level activities identify lower-level activities consumed majority cpu time bow peeled back layers abstraction examined rts-level node-level performance data shown figure figure shows cmf-level computation time metric measurements idle time time spent waiting cmcontrol processor argument processing time time spent receiving parameters node-level code blocks node activations frequency activation parallel nodes control processor display cost processing arguments idling higher cost computing rate node activation high microseconds node measurements suggest computation activated nodes small computation performance data shown figure led application partitioned properly application computational grain-size small cmwe knew program authors efficiently distributed aligned program data virtually costs node-tonode messages broadcasts shown large amounts idle time argument processing time node activations control processor spends large amount time deciding compute nodes nodes spend time finishing tasks machine waits control processor time data view performance determine arrays involved computations displayed computation time arrays shown figures time plots figures show computation time metric constrained arrays account computation activity application find arrays examined computation time metric dozen parallel arrays statements shown figures stood top users computation resources discovered shown time spent computation arrays small concurred earlier hypothesis computational grain-size small looked code manipulated arrays found loops shown figure immediately code achieving full parallelism code fragment part convolution small matrix multiplied row row larger matrix column row calculated parallel row computed sequentially immediately added running vector sum rows rarely long computing separately provide work computation outweigh cmallocates full time quantum process ready run cms compute nodes process requires full time quantum paradyn daemon process allocated full time quantum rarely requires full time quantum complete work application measured paradyn cmis allocated half total cpu time application execution affected scheduled half page november figure cmf-level performance data bow scan time reduction time entire execution figure node-level performance data bow page november figure performance righthand convolution matrices bow cmfarrays bow fcm calc means fortran parallel array declared function calc source file bow fcm figure performance lefthand convolution matrices bow cmfarrays bow fcm calc aleft means fortran parallel array aleft declared function calc source file bow fcm page november implicit costs starting compute nodes sending arguments computation application execute efficiently cmhardware increase grain-size altered code rows columns convolution matrix executed parallel shown figure code fragment shows allocate temporary array store intermediate values intrinsic parallel sum operation calculate final result vector storage required temporary vector small large size convolution matrix results time plot shown figure figure shows execution time application reduced substantially result idle time argument processing time reduced substantially computation time 
state art automated optimization analysis visualization modification reexecution instrumentation data collection focus steering automated paradyn instrumentation applicationpredicate evaluator debugger augmented visi process control path data path metric metric instrument perf data perf data perf data program state steering switch dynamic 
waiting shared-memory delays figure blocking time due coherence misses version cution coherence miss times node behavior nodes node similar bar chart figure clear serial part runs node bottom bars labeled wrn nodes sit idle serial code consumes total execution time nodes time due coherence misses lighter bar shows coherence miss time observation figure coherence misses parallel phase functions wrn costly find data structures incurred coherence misses coherence miss times major shared data structures application program major shared data structures rxncor tracks reaction coordinates particles part stores orientation position particles weight stores particles weights bar charts figure show coherence miss times major data structures node node data structure labeled gmrxncor data structure stores reaction coordinates data structure labeled gmweight stores weight particles bars labeled gmpart gmpart fragments particle data structure figure shows particle data structure coherence misses addition node misses parts fragment labeled gmpart node misses fragment labeled gmpart facts suggest fragment gmpart bounces back node node profiling cache blocks belonging rxncor revealed phenomena evidence pattern detection showed cache blocks rxncor migratory access pattern cache blocks part migratory producer-consumer patterns restructure folding application examining code showed parallel phase application processor moved portion particles serial code sorted particles reaction coordinates split combine simulate reaction custom protocol transfer data efficiently chose restructure application eliminate serial bottleneck performance data guided design decision eliminating coherence misses sorting splitting combining phase consume total execution time nodes severely limit program speedup modified code partitions particles reaction coordinate parallelize serial phase processor sorts splits combines particles change introduced auxiliary data structure tmpl tracks processor owns particle program restructuring called version parallelizing serial phase eliminated sequential bottleneck made computation communication nodes symmetric change improved performance factor program speedup unsatisfactory nodes memory profiling showed considerable time spent handling coherence misses waiting barriers introduced synchronization figure shows nodes total time spent handling coherence misses memoryblockingtime time barriers targetbarrierwall find high memory blocking time examined program access figure memory blocking barrier wait time version patterns data structures referenced figure visualization program access pattern shows cache blocks part migratory access pattern mentioned earlier migratory access pattern false sharing examination code confirmed data structure cache-block aligned eliminate false sharing aligned padded particles ensure particle fell inside single cache block call version alignment padding drastically reduced memory blocking time improved performance factor figure shows time spent barriers coherence misses alignment padding load imbalance figure shows coherence misses longer performance bottleneck program time spent barriers figure shows barrier time evenly divided nodes suggests load imbalance experiment statically partitioned particles processor barrier waiting times version figure shows static load balancing reduced barrier coherence miss time particles move randomly dynamical load balancing scheme general summary figure summarizes performance tuning shows speedups versions including original fortran version sgi power challenge initial version scales moderately cow nodes efficiency dropped drastically restructured program initially performed worse small number cow nodes extra work track particle belong node program scaled sequential bottleneck false sharing limited speedup aligning padding shared data structure improved performance considerably made load imbalance limiting bottleneck simple static load balancing scheme improved performance slightly coherence longer performance bottleneck adding prefetching version significantly improve performance performance optimizations carry platforms ported version application back sgi power challenge sharedmemory programming model version outperforms fortran version figure detailed experiments showed performance gain attributable eliminating serial bottleneck padding aligning contribute performance improvement sgi power challenge smp faster network sensitive false sharing speedup curves figure show speedup cow slightly speedup sgi power challenge result encouraging proper performance measurement tools performance tuning distributed shared-memory machine perform hardware shared-memory machine figure false sharing particle data structure version pattern visualization blue darkest boxes black white shows migratory access pattern green medium gray shows producer consumer access yellow light grey shows unknown pattern blocks marked block selected user blocks accessed group selected block text corner shows information selected block people blizzard version paradyn find shared-memory performance bottlenecks brian toonen tool search validate performance bottlenecks dsm system satish chandra tool monitor performance custom protocols wrote hpf compiler blizzard trishul chilimbi tool tune performance database storage management system discussion memory performance tool successful found performance bottlenecks application memory profiling helped isolate shared data structure incurred coherence misses pattern detection helped explicate algorithm sharing pattern isolate false sharing memory profiling found problems paradyn performance measurement facilities helped find sequential bottlenecks load imbalance excessive barrier time custom protocols offer powerful time-consuming option improving program performance unanticipated benefit memory profiling custom protocols improve performance automated search bottlenecks automating search bottlenecks make performance tuning difficult paradyn performance consultant searches performance bottlenecks foci testing prewritten hypotheses hypothesis specifies potential performance bottleneck terms performance metrics simple function performance metrics thresholds hypothesis cpubound performance bottleneck ratio performance metrics cpu time wall time exceeds adjustable threshold hypotheses organized tree-structured hierarchy performance consultant guides search heuristics attempt reduce search overhead find bottlenecks quickly automate search shared-memory performance bottlenecks added hypotheses shared-memory metrics integrated existfigure barrier time shows load imbalance version figure barrier memory blocking time static load balance version ing hierarchy figure shows hypothesis hierarchy rooted memory memory bottlenecks divided read miss write miss write subdivided misses due writes read-only blocks misses due writes invalid blocks hypotheses subdivide misses home non-home nodes demonstration applied performance consultant version program search results shown figure blue dark gray black white nodes problems performance consultant successfully identified excessivememoryblockingtime bottleneck performance consultant refined individual data structures parts particle data structures gmpart gmpart caused memory blocking time identified note modules renumber fold identified bottlenecks provided data code-centric views performance problem make automated search effective extending performance consultant make configurable search order search heuristics programming model related work addition systems cited previously profiling tools address shared memory programs stormwatch tool visualizes coherence protocol actions links program behavior stormwatch linked graphic views trace communication source reflect multiple levels abstraction application behavior major differences work stormwatch storm watch postmortem tool analyzes traces mechanisms dynamic instrumentation costly scalable stormwatch detailed protocol-specific view program execution figure performance tuning result number processors speed protein folding code linear speedup align pad load balance stache version sgi power challenge shared-memory align pad prefetching stache version 
restructure align pad stache version sgi power challenge fortran version restructured stache version initial version stache version figure performance bottleneck hypothesis hierarchy memory hiearchy expanded root cpubound memory read write home stache writero writeinv home stache home stache synchronization paradyn general purpose performance tool martonosi observed monitoring memory performance multiprocessor similar enforcing cache coherence noticed importance categorizing miss counts code data structures incurred misses work focused exploiting unused issue slots protocol processors monitor performance dynamically instrument protocol code addition monitoring mechanisms collected memory statistics cache misses latencies detect patterns extended cache-coherence protocols detect optimize migratory sharing behavior cox evaluated adaptive protocols bus-based directorybased systems stenstrom presented adaptive protocol advantage migratory behavior shared-memory application pattern detection serves role detect access patterns optimize communication makes implementation simpler cheaper mechanisms detect patterns migratory behavior conclusion paper describes approach shared-memory performance profiling approach consists detecting sharing patterns data-centric presentation memory performance data pattern detection reports memory access patterns possibility excessive communication pattern detection implemented augmented coherence protocol incurs additional overhead current implementation blizzardspecific approach detecting sharing pattern observing coherence events applicable systems memory profiling data-centric view performance programmer find understand performance problems shared-memory accesses organize large volume information present shared-memory resources two-level hierarchy data structure cache blocks belong data structure data structure view helps relate performance problems high-level programming language constructs cache block view helps isolate specific problems false sharing integration memory profiling paradyn existing control-oriented view complete view sharedmemory program performance approach feasible paradyn dynamic instrumentation reduces overhead monitoring installing instrumentation test case applied mechanisms identify figure results running performance consultant version blue darker boxes black white shows bottlenecks identified performance consultant bottleneck refined individual data structures gmpart gmpart gmpart gmpart gmpart modules renumber fold yellow light grey nodes show false search nodes eliminate performance problems shared-memory application paradyn improved application performance factor case study demonstrates mechanisms identify shared-memory performance problems addition shows proper performance measurement tool optimize communication distributed shared-memory machine scalable hardware shared-memory system acknowledgments sang tae kim atipat rojnuckarin providing application code insight effort tuning performance ari tamches mark callaghan guhan viswanathan provided insightful discussions ari tamches marcelo gon alves karen karavanic tia newhall oscar naim ling zheng helped understand paradyn ioannis schoinas babak falsafi helped blizzard satish chandra helped teapot mark hill suggested software dsm hardware-only systems trishul chilimbi brian toonen satish chandra feedback tool carter bennett zwaenepoel implementation performance munin acm symp operating systems principles oct chandra richards larus teapot language support writing memory coherence protocols sigplan conf programming languages design implementation pldi philadelphia chandra larus optimizing communication hpf programs fine-grain distributed memory acm sigplan symp principles practice parallel programming alexis park resort las vegas nevada june chilimbi ball eric larus stormwatch tool visualizing memory system protocols supercomputing san diego december cox fowler adaptive cache coherency detecting migratory shared data annual int symp computer architecture dahlgren dubois stenstrom combined performance gains simple cache protocol extensions annual int symp computer architecture april falsafi lebeck reinhardt schoinas hill larus rogers wood applicationspecific protocols user-level shared memory supercomputing november gupta martonosi anderson memspy analyzing memory system bottlenecks programs performance evaluation review june hill larus reinhardt wood tempest substrate portable parallel programs compcon san francisco march hollingsworth miller dynamic control performance monitoring large scale parallel systems int conf supercomputing tokyo july hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation tech report comp science department uw-madison horowitz martonosi mowry smith informing memory operations providing memory performance feedback modern processors annual int symp comp architecture philadelphia huber kim weighted-ensemble brownain dynamics simulations protein association reactions biophysical journal vol january irvin miller performance tool highlevel parallel programming languages programming environments massively parallel distributed systems birkaeuser verlag basel decker rehmann eds irvin miller mapping performance data high-level data views parallel program performance int conf supercomputing philadelphia johnson kaashoek wallach crl high performance all-software distributed shared memory acm symp operating system principles sosp copper mountain colorado december keleher dwarkadas cox zwaenepoel treadmarks distributed shared memory standard workstations operating systems ieee computer february kuskin stanford flash multiprocessor annual int symp comp architecture april lebeck wood cache profiling spec benchmarks case study ieee computer october lovett clapp sting cc-numa computer system commercial marketplace annual int symp comp architecture philadelphia martonosi ofelt heinrich integrating performance monitoring communication parallel computers acm sigmetrics conf measurement modeling comp systems philadelphia miller callaghan cargille hollingsworth irvin karavanic kunchithapadam tia newhall paradyn performance tools ieee computer november reinhardt larus wood typhoon tempest user-level shared memory int symp comp architecture april scales gharachorloo thekkath shasta low overhead software-only approach supporting finegrain shared memory int conf architectural support programming languages operating sys asplos schoinas falsafi lebeck reinhardt larus wood fine-grained access control distributed shared memory int conf architectural support prog languages operating sys asplos oct stenstrom brorsson sandberg adaptive cache coherence protocol optimized migratory sharing annual int symp comp architecture sun microelectronics ultrasparc user manual zhou iftode singh toonen shoinas hill wood relaxed consistency coherence granularity dsm systems performance evaluation acm sigplan symp principles practice parallel programming las vegas june 
increased substantially curves compute nodes spend time work time waiting control processor sum time curve figure shows portion computation time due summation operations determine improvements bow range input parameters ran versions application input sets paradyn attached results shown figure table shows actual reduction execution time uninstrumented application improves slightly increased iteration size reduction close change predicted examining figure figure runs paradyn measurements bow application suggest source-level views augmented lower level views performance demonstrated perfectly parallel application high nodelevel initialization costs spread thinly compute nodes fortran execution model cmsmall grain-size frequent node activations large amounts idling nodes wait control processor large proportions time spent receiving code-block arguments control processor computation periods nodes paradyn allowed describe measure display performance node-level implicit activities data views performance relative code views focusing parallel data strucaleft lenl aleft aleft histl ibackl crleft end figure original convolution code lines code lenl histl lenl crleft lenl aleft sum dim figure improved convolution code page november tures fine-grained computations fine-grained computations diffused statements localized parallel arrays performance problems potential improvements bow application costs implicit activities shown idle time argument processing time curves figure significant costs related implicit activities peaceman-rachford pde solver peace application called peace partial differential equation solver peaceman-rachford iteration method peaceman-rachford method factor penta-diagonal equations figure paradyn display improved bow iteration count original improved percent change min sec min sec min sec min sec min sec min sec min sec min sec min sec min sec figure execution times original improved bow times uninstrumented executions program page november implementation written vincent ervin associate professor mathematics clemson code consists approximately lines fortran code spread files control execution program varying number variables equation altering convergence coefficient varying number iterations began analysis peace examining costs cmf-level verbs time plot shown figure display shows application distinct phases execution substantial change computation time array transformation time phase boundary approximately ten minutes forty seconds execution phase exhibits low costs cmf-level verbs high overhead costs phase shows compute node utilization cmf-level verbs investigated implicit node-level costs phase moving rts level abstraction displaying metrics shown figure display shows high costs implicit verbs processing parallel code block arguments broadcasting activating parallel code blocks time spent actual computations phase phase application spends larger percentage time computing communication compute nodes investigated phase peace incurred high costs initializing compute nodes cmwe visualization displays shown find node activations phase due broadcasts small amounts data broadcast activation information costs waiting control processor activating nodes receiving code block arguments control processor artifacts broadcasts examined code views data views explain broadcasts identify data broadcast constrained measurements broadcast activity data structures cmf level data view figure shows parallel arrays broadcast order broadcast costs parallel arrays array conode broadcast exclusively minute broadcast concurrently arrays rconode bconode examined code find thatconode computed special routine parallel assignments sequential iteration loops rconode bconode computed elements conode code perform computations conode rconode bconode included forty lines code spread functions files improved peace replacing code computedconode rconode andbconode set parallel loops compute arrays simultaneously code eliminates broadcast activity greatly reduces execution time phase application time plots improved application shown similar phase displays shown figures measure effect ran original improved versions peace input sets varied size results shown figure show improvements reduce execution time range input sizes page november phase peace limited rts-level node-level implicit costs scale problem set sizes costs implicit activity decrease comparison costs cmf-level explicit activity simple bar graph visualization show computations array shifting account processing time application arrays shfter account costs arrays accessed places code equal cost code locations attempted improve sections code figure node-level broadcasts constrained cmf-level arrays peace cmfarrays newer crunch fcm ccrunch means fortran parallel array conode declared function crunch source file bow fcm input size original improved percent change min sec min sec min sec min sec min sec min sec min sec min sec min sec min sec figure execution times original improved peace page november figure cmf-level performance peace figure node-level view performance peace page november experiment source-level views performance lower-level metrics data views performance helped find fix significant performance problem peace application techniques helped point region execution performed poorly node-level symptom poor performance cmflevel node-level activities bow application data views performance helped code views performance problem localized arrays diffused statements code particle simulation psicm studied application called psicm three-dimensional particle simulation code computational fluid dynamics studies hypersonic flow studies plume flowfields code consists lines code eleven source files input sets geometry flow field number particles simulated factors code written group computational scientists numerical aerodynamic simulation laboratory nasa ames research center briefly summarize experience psicm full description study found analysis psicm showed combinations code data views performance performance analysis data-parallel programs identified single statement caused large amounts implicit node-level activity explained activity activity caused check point operation caused excessive communication slow path compute nodes control processor combination code data views showed array elements transferred time control view showed communication expensive data view showed arrays involved communication serialized result information reallocated data structures block-transfer single unit reduce node-level implicit communication costs operations conclusions work convinced multiple levels performance data combined control data views important identifying performance bottlenecks programs written high-level parallel languages mechanisms techniques mapping low-level performance information higher-level control data views crucial enabling technologies mechanisms mapping crucial insure lower-level activity mapped highlevel source language operation map high-level behavior mapped component operations set active sentences technique performing mappings work needed make techniques widely applicable difficult problem high-level language library environment finding mapping data compilers encode similar information ways array geometry distribution information fortran contained array descriptors read run-time information fortran contained compiler-generated code compiler-generated information location statepage november ments variable def information variety places variety formats effort standardize access information crucial development general purpose debugging profiling tools dynamic instrumentation paradyn tool proven vehicle implementing ideas model incorporated ideas source-level performance data mapping performance data layers abstraction data views performance paradyn performance tool tool gain substantial improvements real parallel applications experiments paradyn tool fortran applications found cmf-level views important augmented rts-level node-level views performance applications exhibit performance problems runtime system compute nodes experiments 
bow peace applications demonstrate small fraction total resources cmf-level computations cases studied lower levels understand activities entire system information lower-level activity programmers relate activity source code experiments found rts-level node-level activity constrained fortran code data structures applications code data views performance helped identify cmf-level rts-level node-level activities traditionally performance data explained terms code constructs shown data views performance lead focused explanations performance experiments found performance problems localized parallel arrays diffused code statements data views performance helpful understanding data-parallel programs data primary source parallelism synchronization programs cases studied applications allocated large data structures beginning execution routines transform data structures result performance problems found fixed concentrating program data structures code structures bibliography vikram adve jhu-chun wang john mellor-crummey daniel reed mark anderson ken kennedy integrated compilation performance analysis environment data parallel programming technical report crpc francois bodin beckman dennis gannon gotwals narayana srinivas winnicka sage object oriented toolkit class library building fortran restructuring tools oonski leonardo dagum three-dimensional direct particle simulation connection machine technical report rnr- nasa ames research center leonardo dagum konrad zhuh three-dimensional particle simulation high altitude rocket plumes technical report rnr- nasa ames research center william depauw richard helm doug kimelman john vlissades visualizing behavior object-oriented systems object-oriented programming systems languages applications conference pages page november goldberg john hennessy performance debugging shared memory multiprocessor programs mtool supercomputing pages november graham kessler mckusick gprof call graph execution profiler acm sigplan symposium compiler construction june anoop gupta margaret martonosi tom anderson memspy analyzing memory system bottlenecks programs performance evaluation review june haarslev moller framework visualizing object-oriented systems object-oriented programming systems languages applications conference pages michael heath jennifer etheridge visualizing performance parallel programs ieee software september high performance fortran forum high performance fortran language specification version january jeffrey hollingsworth barton miller dynamic control performance monitoring large scale parallel systems acm international conference supercomputing pages july jeffrey hollingsworth barton miller jon cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference bruce irvin barton miller performance tool high-level parallel programming languages karsten decker rene rehmann editors programming environments massively parallel distributed systems pages birkhauser verlag bruce irvin performance tool high-level parallel programming languages dissertation wisconsin-madison november kleyn gingrich graphtrace understanding object-oriented systems concurrently animated views object-oriented programming systems languages applications conference pages alvin lebeck david wood cache profiling spec benchmarks case study ieee computer october maspar computer corporation north mary avenue sunnyvale mppe manual barton miller mark callaghan jonathan cargille jeffrey hollingsworth bruce irvin karen karavanic krishna kunchithapadam tia newhall paradyn parallel performance measurement tools ieee computer november bernd mohr darryl brown allen malony tau portable parallel program analysis environment international conference parallel systems pages springer verlag september peaceman rachford numerical solution parabolic elliptic differential equations journal society industrial applied mathematics donald peaceman fundamentals numerical reservoir simulation elsevier scientific publishing company pure software incorporated menlo park quantify user guide daniel reed robert olson ruth aydt tara madhyastha thomas birkett david jensen bobby nazief brian totty scalable performance analysis pablo performance analysis environment skjellum editor scalable parallel libraries conference ieee computer society robert schumacher self-sustaining oscillations bowed string acustica robert schumacher analysis aperiodicities periodic waveforms journal acoustic society america steve sistare don allen rich bowker karen jourdenais josh simons rich title data visualization performance analysis prism programming environment programming environments parallel computing pages north-holland thinking machines corporation cambridge fortran manual january winifred williams timothy hoel douglas pase mpp apprentice performance tool delivering performance cray karsten decker rene rehmann editors programming environments massively parallel distributed systems birkhauser verlag 
optimizing array distributions data-parallel programs krishna kunchithapadam barton miller krishna wisc bart wisc computer sciences department wisconsin madison dayton street madison abstract data parallel programs sensitive distribution data processor nodes formulate reduction inter-node communication optimization colored graph present technique records run time inter-node communication caused movement array data nodes execution builds colored graph provide simple algorithm optimizes coloring graph describe data distributions result inter-node communication distribution information write compiler pragmas application program techniques traced execution real data-parallel application written fortran collected array access information computed distributions provide reduction program execution time compiler optimizations poor interfaces compiler runtime systems counteracted potential benefit data layouts context provide set recommendations compiler writers needed write efficient programs build generation tools parallel systems techniques developed form basis future work monitoring array access patterns generate on-the-fly redistributions arrays introduction parallel programming languages provide programmer abstractions ease development code data parallel programming languages programmer reason single thread control executes parallel large collection data mechanisms parallel execution communication synchronization handled automatically compiler details hidden programmer abstraction details simplify programmer life obscure performance problems careless naive array declarations loop structures poor performance obvious explanation performance parallel programs sensitive distribution data processing nodes good performance programmer choose algorithm matching data distribution minimizes communication figuring optimal acceptable work supported part nsf grant ccroffice naval research grant -jand department energy grant de-fg data distributions non-trivial problem simplest cases current data parallel languages require programmer data distributions goal programmer improve data distributions programs run faster work monitor execution parallel program information improve array distributions present approach based execution-time tracing post-mortem analysis dataparallel fortran program formulate optimality criterion terms graph-coloring problem provide simple techniques approximating optimal solution experiment techniques real mechanical engineering application program running tmc cmstarting unfamiliar application program information provided analyses provided clear information modifying array distribution directives program modifications resulted reduction predicted communications based weighted graph representation actual performance improvements prevented part fortran compiler generated code counter-acted distribution directives describe detail section provide set recommendations compiler writers important allowing programmers tool builders make parallel programming environments current analysis array accesses post-morten goal monitor evaluate access patterns on-the-fly program running systems support execution time data redistributions hpf specification programmers improve array distributions automatically data distribution parallel programs parallel programming environments require programmers distribution data structures target hardware message passing programs data distribution access explicit control programmer data parallel language compiler runtime system provide set data distribution pragmas describe layout parallel data structures develop initial work context parallel arrays data distribution pragmas details layout parallel array nodes parallel machine fortran study block-structured layout pragmas language fortran-d supports block cyclic layouts hpf language definition mentions arbitrary dynamically changeable permutations arrays programmer chooses simple data layout scheme lets compiler choose default layout easy examples default layout result poor performance current work problem focused static compiler analysis compiler figure good distribution control data flow graphs program explores small number canonical distributions suitable static analysis determine good data distributions access patterns dependent input data execution-time approach suggest cases ultimately envision combination static runtime analysis compiler analysis determining static access patterns runtime analysis tracking parts program amenable static analysis addition static analysis provide good starting point runtime analysis tools optimizing data distribution graph coloring problem model access patterns program execution colored graph vertex graph represents part array color vertex represents current processing node array part assigned edges graph represent assignments values arising part arrays part array assuming owner-computes model notion made precise approach finding good data distributions based graph coloring specific conservation property graph approach weights communication costs computation costs proximity graph definition define proximity graph set vertices graph vertex color element unique parallel array program forms vertex proximity graph vertex array data element set variable names application initial color vertex node data element assigned compiler number colors graph corresponds number nodes parallel machine executing application set directed edges graph edge source vertex destination vertex weight edge vertices graph corresponds fact data elements computation parallel program precisely assignment statements program written lvalue expression rvaluelist eliminate temporary variables rvalue list proximity graph statement edge rvalue lvalue edge element read element written weight edge represents number times manner defined program weight graph defined sum weights edges edges computation vertices colors data elements located nodes parallel machine contribute weight communication cost computation involving data elements located node contribute weight graph balance conservation property colors vertices satisfy conservation property number vertices colors equal vertex pairs balanced distribution array elements nodes parallel machine property important stating minimization criterion proximity graph perform optimizations data distributions define balance preserving functions operate balance preserving function define function graph words function exchanges colors vertices condition iff correspond data elements array condition note preserves balance conservation property graph corresponds data distribution original graph data elements exchanged home nodes graph optimization problem reach ideal result sequence applications function produces sequence color exchanges data redistributions reduces weight graph communication costs sequence found data distribution resulting sequence applications lead communication program execution optimal assuming computation costs negligible practice hope find sequence color exchanges minimizes weight graph communication required motivate balance conservation property restrictions number vertices color trivial solution assign color vertices parallel arrays stored node effectively reducing application sequential trivial coloring communication cost interesting parallel programmers balance conservation property ensuring balanced data distribution nodes parallel machine proximity graph model spatial temporal locality communication compiler optimizes communication block-transfers caching optimization factored constructing proximity graph steps optimizing array distributions problem optimizing array distributions divided steps collecting dynamic array data build proximity graph computing array distribution re-coloring graph converting distribution back pragmas specifiable source language describe variations step describe variations explored experiments data collection trace granularity storage model section based counting data movements pair array elements referenced program statement basic trade-off post-mortem versus on-the-fly evaluation data collected generating trace record execution program statement collection traces processed construct proximity graph alternatively data summarized program executing require state space proportional number pairs array locations referenced execution potentially large square program total array space amount primary memory needed post-mortem tracing simply size memory buffer traces written secondary storage process on-line reduction traces written directly secondary storage secondary 
storage space requirements proportional length program execution technique reducing amount data space needed on-the-fly data collection data blocking array divided blocks data recorded terms block array location resides blocks formed dividing array equal size rectangles data blocking reduce size secondary storage space needed post-mortem tracing regular patterns access array benefit technique irregular patterns occur index arrays perform poorly technique granularity trace data impact size proximity graph blocking factor increased maximum number edges vertices graph decreases complexity computing colorings data blocked time moment constructing proximity graph data combined instrumentation lost details recovered stages computing improved distribution graph coloring algorithms array access data collected build proximity graph graph optimize array distributions initial coloring vertices based current assignment array locations processor nodes initial coloring evaluate amount inter-node communication caused coloring array distribution compute coloring attempts reduce amount inter-node communication assumption reduced communication result improved program performance computing optimal coloring graph np-complete heuristics simple greedy algorithms preferable fast possibilities include genetic algorithms simulated annealing algorithms based optimization problems basic tradeoff complexity algorithm quality solution simple fast algorithm context application steering realizing distribution mapping coloring language pragmas colorings produced optimization algorithm expressed terms datadistribution pragmas provided source language pragmas source language powerful express data distribution patterns produced coloring extracting data distribution proximity graph form pattern-matching formal description array distribution directives language matched proximity distribution simpler approach investigate small number array distribution specifications expressible source language easy compute weight proximity graph based distribution compare weight computed coloring enumerations result weights closest computed coloring candidates investigation approach simply animate visualize data distributions produced graph coloring algorithm programmer identify global patterns picture map array distribution pragma block cyclic distribution patterns easy recognize manner expect practical tool combination techniques data access patterns application depend problem size degree parallelism construct detailed proximity graph small problem running small number nodes powerful optimization techniques good solutions graph coloring distribution-to-pragma mapping problems cost detailed analysis amortized large number runs application large data sets carefully chosen training data-sets finding distributions work large-scale executions application results experimental testbed experiment ideas previous section chose mechanical engineering application written fortran application drbem dual reciprocity boundary element method written members mechanical engineering department knowledge semantics program studies application lines long distributed source files drbem non-linear solution technique heat-transfer vibration analysis applications technique non-linearities solved boundary integral problems boundary element methods relies green theorem reduce two-dimensional area problem onedimensional line integral line-integral solved discretizing solvings sets linear equations application program reads initial conditions file sets system linear equations solves equations series time steps finally writes results file sequence viscous dissipation convection computation transient effect curing linearsystems solution repeated large number times case obtain convergence small array sizes significant impact execution time program array sizes result execution time minute full-scale run arrays sizes hour complete trace access individual array elements hand-instrumented program write array geometry data access information files hand-instrumentation tedious initial study availability def information compiler instrumentation step straight-forward automate ultimately expect binary rewriting dynamic instrumentation program versions run -node partition cmcomputer vector units applications compiled fortran version optimization enabled trace data collected instrumented runs build proximity graph investigations section describe algorithms experiments algorithms experiments cover small subset possibilities enumerated section data collection trace granularity storage experiments studied single problem size involving arrays size volume trace data small application program instrumented trace data accesses post-morten filter vary trace granularity advantage approach data collected single run application times problem size constructed proximity graphs based trace granularities full tracing tracing assuming blocking factor tracing assuming blocking factor computing improved distribution graph coloring algorithms compute coloring proximity graphs constructed previous step simple greedy algorithm coloring algorithm written fast heuristic similar restricted version kernighan-lin optimization algorithm examine -neighbors kernighan-lin algorithm examines arbitrary n-neighbors realizing distribution mapping coloring language pragmas map distribution optimized proximity graphs simple visualization approach assist programmer identifying regular patterns distributions experiments set scripts extract coloring information arrays redistributed coloring algorithm plot picture original modified distributions immediately identify nature redistributions pragmas distributions pictures evaluating tracing coloring remapping steps experiments report difference weights proximity graphs default distribution distribution produced coloring algorithm reduction weights graphs upper bound reduction execution times application coloring algorithm set results shows behavior graph coloring algorithm variation tracing granularity metric evaluating coloring algorithm reduction weight graph ideal scenario reduction graph weight manifest reduction execution time distribution set results present nature distributions obtained coloring algorithm step collection scripts draw pictures array coloring screen colors graph colors simple easy-to-identify patterns evaluating coloring algorithm table summarizes performance greedy graph coloring algorithm column represents trace granularity trace block size means array elements rectangular blocks dimensions represented single vertex proximity graph larger results proximity graph smaller number vertices edges column size proximity graph vertex edge sets proximity graph fourth columns show initial weight graph weight greedy coloring algorithm percentage change graph weights block size graph size initial graph weight final graph weight change table proximity graph data drbem results table grouped sets rows set represents number array locations represented vertex proximity graph row element vertex set rows elements vertex set elements vertex execution time algorithm sensitive number edges proximity graph order magnitude reduction running times granularity group blocking factor increased interesting note case blocking granularities blocking trace data perturb coloring algorithm reduction weight proximity graph differences original distributions show qualitative variation blocking factors default distribution chosen compiler column-major ordering arrays blocking treats elements columns initial colors identical loses essential information produces poor proximity graph blocking heuristics reduce trace sizes preserve initial distribution patterns lead accurate proximity graphs based mapping information collected tracing application arrays application redistributed drm temp drm temp scopy drm temp dfx drm temp dfy discuss made two-dimensional arrays redistributions vectors significant names form function array visualizing array redistributions intuitive feel coloring algorithm redistributed mentioned arrays extracted geometry information arrays original traces distributions displayed information picture distributions screen colors graph colors blocking redistribution arrays drm temp drm temp scopy immediately apparent fortran compiler allocated arrays co-locating elements column coloring algorithm co-located elements rows rotation original picture unmistakable granularities rotation axis equally apparent blocks pictures provide insight distribution differed original arrays small blocking 
geometries interesting blockings provided visual insight redistribution arrays performed blockings respect graph colorings pictures remaining arrays drm temp dfx drm temp dfy similar striking previous arrays compiler originally allocated arrays co-locating elements column distribution arrays showed wavefront pattern distribution bottom arrays higher values row column indices original optimized distributions shown figure evaluating effect redistributions based observations made previous section modified distribution arrays drm temp drm temp scopy pragmas provided fortran impossible redistribute arrays coloring language supported arbitrary distribution primitives hpf rebuilt application program geometries arrays modified favor co-location elements rows geometry modifications close optimal discernible effect execution times application section discusses reasons absence performance improvements original distribution array drm temp dfx optimized distribution array drm temp dfx figure redistribution array drm temp dfx user compiler initial results initially encouraged significant reduction weight proximity graph application expected comparable reduction execution time redistributions change runtime fortran compiler interface inquiry functions runtime system array geometry description function arrays redistributed specifications turned compiler ignoring distributions default layout number distribution directives compiler generate exact distribution wanted fortran compiler show propensity column-major distributions wanted row-major distributions arrays end compiler layout arrays n-row m-column blocks equal wanted ran applications sub-optimal distributions expected decrease runtime change slight increase runtimes fortran application functions determine print size geometry array compiler option examined names communication functions points code called turned case distribution default distribution compiler inserted runtime system functions redistribute arrays canonical form performing parallel operation functions redistribute results back distribution essence compiler undoing optimizations testing simple kernels matrix multiplication application program fairly complex interactions arrays started work small kernels understand compiler matrix multiplication simple kernel knew optimal data distribution wrote parallel versions kernel intrinsic matmul dotproduct functions case varied distribution source destination arrays involved computation noted case distributions default compiler generated code redistribute arrays canonical form fortran generate parallel code programmer parallel constructs intrinsic functions constructs intrinsic functions constrains programmer canonical distribution distribution sub-optimal operation involved operations matrix multiplication canonical distribution requires individual node-to-node communication communication hidden runtime system programmer specifies optimal distribution compiler undoes optimization conform runtime system interface runtime system re-redistributes operands back optimal configuration needless redundant data moves place recommendations compiler support experience based compiler runtime system small collection programs make general recommendations parallel-compiler writers compiler trust programmer data distributions canonical found difficult compiler accept data layout generate efficient code corollary previous recommendation case automated analysis compiler makes application provide manual interfaces comparable quality knowledgeable programmers perform optimizations code interface compiler runtime system made broader runtime system provide matrix multiplication clones suited combinations operand layout narrower runtime system single matrix multiplication function guaranteed work operands distributions compiler data movements current interface compiler runtime system make optimizations guarantee undone recommendations paramount importance programmers benefit kinds data distribution pragmas strategies fortran make data distribution pragmas redundant addition compiler writers provide tool builders detailed information compile-time analysis problems faced specific fortran compilers provide reasonable amount information tool builders write tools compiler consistent internal namespace identify parallel data objects fortran compiler descriptors identify arrays meaning descriptor depending array parameter subroutine local one-to-one mapping descriptors array data compiler provide mapping descriptor names source level names tools hoc techniques present results programmer usable form source-level instrumentation study information array compilers provided summary dependence analysis form def-use points code tool builders binary rewriting runtime instrumentation programs approach simpler source instrumentation compiler modification tool writers experiment programs easier obtain binaries source code compiler provide information kind optimizations performs correlation specifications made user optimizations compiler analysis external tools conclusion work presented graph-coloring based model analyzing data access patterns application simple algorithm produces reorderings distributions result reduced communication experiments real-world application test kernels show compiler runtime system interfaces improved programmers tools make optimized data layout pragmas provided set features tool builders compilers parallel systems work complements approaches distributions static analyses initial guess tune data program execution typical data parallel compilers treat array distributions optimize code organization data movement provide additional dimension choosing effective data distributions context work forms basis generating on-the-fly data redistributions arrays hillis steele data parallel algorithms communications acm december cmfortran manual online document thinking machines corp version c-star manual online document thinking machines corp version fox hiranandani kennedy koelbel kramer tseng fortran-d language specification technical report computer rice high performance fortran language specification high performance fortran forum version kremer mellor-crummey kennedy carle automatic data layout distributed-memory machines programming environment technical report crpc-tr rice rogers pingali process decomposition locality proc conf programming language design implementation portland oregon june kremer np-completeness dynamic remapping proceedings fourth international workshop compilers parallel computers december whitley foundations genetic algorithms kaufmann publishers san mateo california johnson aragon mcgeoch schevon optimization simulated annealing experimental evaluation operations research may-june evans minieka optimization algorithms networks graphs dekker york mccormick defanti brown visualization scientific computing computer graphics november larus ball rewriting executable files measure program behavior software practice experience feb hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high-performance computing conf knoxville tenn kernighan lin efficient heuristic procedure partitioning graphs bell systems technical journal 
page october fuzz revisited re-examination reliability unix utilities services abstract tested reliability large collection basic unix utility programs x-window applications servers network services simple testing method subjecting programs random input stream testing methods tools largely automatic simple tested programs versions unix operating system including commercial systems freely-available gnu utilities linux report programs failed systems identify categorize failures result testing crash core dump hang infinite loop worst case basic programs x-window applications crash network services tested x-window servers study parallels study tested basic unix utilities systems compared noticeably improved reliability significant rates failure reliability basic utilities gnu linux noticeably commercial systems tested utility programs checked return codes memory allocation library routines simulating unavailability virtual memory crash half programs tested content indicators testing debugging programs utilities general terms random testing reliability unix barton miller bart wisc david koski cjin pheow lee vivekananda maganty dkoski wisc cjin wisc vivek wisc ravi murthy ajitkumar natarajan jeff steidl ravim wisc ajitk wisc steidl cae wisc computer sciences department wisconsin dayton street madison work supported part wright laboratory avionics directorate air force material command usaf grant arpa order nsf grants ccrand cdadepartment energy grant de-fg office naval research grant -jthe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory avionics directorate government page october introduction published results study reliability standard unix utility programs study showed simple simplistic random testing techniques crash hang utility programs years repeated significantly extended study basic techniques subjecting programs random input streams distressingly large number unix utilities crash tests essence testing program called fuzz generator emits types random output streams random streams fed wide variety unix utilities conservative crude measure reliability program considered unreliable crashes core dump hangs loops indefinitely type testing effective finding real bugs real programs proposing replacement systematic formal testing quote study rich body research program testing verification approach substitute formal verification testing procedures inexpensive mechanism identify bugs increase system reliability coarse notion correctness study program detected faulty crashes hangs loops indefinitely goal complement replace existing test procedures study parts test utility programs unix platforms including platforms tested study platforms commercial vendors tests type conducted including random streams study streams newly generated current study identified categorized bugs caused failures test network services feeding random input streams fuzz-based client test x-window applications servers feeding random input streams additional robustness tests unix utility programs check return system calls specifically tested calls memory allocation library routines malloc family simulating unavailability additional virtual memory goal studies find bugs simple automated techniques techniques intended expose errors common programming practices major results study years previously-tested versions unix made noticeable improvements reliability utilities failure rate systems distressingly high worse bugs reported present code releases failure rate utilities commercial versions unix tested sun ibm sgi dec ranged failure rate utilities freely-distributed linux version unix secondlowest paper failure means crashing core dump hanging looping indefinitely page october failure rate public gnu utilities lowest study crash network services versions unix tested half x-window applications tested crash random input data streams significant applications crash random legal x-event streams crash server versions unix tested sending random data streams server section describes basic tests performed unix utilities results tests analyze categorize failure compare results systems tested section reports testing network services section reports testing x-window applications servers memory allocation library-call tests section section presents concluding comments page october basic tests section reports results repeating basic study study tested reliability utilities feeding variations random input streams study tested large number unix utilities vendors platforms limited amount testing seventh platform current study included type tests unix platforms including commercial systems systems study included current study tests performed machines wisconsin-madison campus fall machines belonging members testing team tests repeated verified winter section describes tools basic tests section describes tests unix platforms run platforms include -versions systems -versions systems section presents results testing describes failures detected tests basic fuzz tools fuzz program basically generator random characters produces continuous string characters standard output file perform types tests depending options fuzz fuzz capable producing printable control characters printable characters groups nul character delay character option account delay characters passing pipe user locate characters caused utility crash option seed random number generator provide repeatable tests fuzz record output stream file addition printing standard output file examined options randomly insert newline characters output stream limit length output stream fuzz test eqn equation processor fuzz outfile eqn output stream characters length stream recorded file outfile fuzz tools include set shell scripts automate testing process crash detected presence core file crash recorded log file test interrupted person performing tests hang recorded log file crash hang subsequently examined ensure valid core files generated program received sigabrt signal typically generated calling abort library routine cases considered crashes basic tests tested unix utilities operating system platforms systems sunos hp-ux aix solaris irix ultrix nextstep recent commercial software distributions time tests commercial systems sunos hp-ux aix tested study results earlier page october study included comparison systems tested free software distributions gnu tools free software foundation written variety authors world-wide linux freely distributed version unix operating system originally written linus torvalds system extensively changed extended authors world-wide systems tested listed table utility tested random input streams streams varied combinations parameters section tested utilities streams generated random seeds study random seeds basic test results current study tested unix utilities utility typically systems tested list includes commonly utilities shells compilers document formatters list includes obscure utilities units unit conversion utility similar utilities grouped table table utility tables specific listed table section summarizes results basic testing section examines failures section compares current results study basic tests include window-based utilities tests window-based application programs section quantitative results results tests table observations examidentifying letter study vendor architecture operating system sun microsystems sun sunos sparcstation sunos hewlett packard bsd nfs system hp-ux ibm aix aix sun microsystems sparcstation solaris silicon graphics indy irix dec decstation ultrix rev colorstation nextstep gnu free software foundation sunos nextstep linux cyrix slackware table list systems tested page october ining table noticeable 
improvement reliability study failure rate sunos hp-ux aix failure rate distressingly high ease fuzz testing public availability fuzz tools interesting compare results testing commercial systems results testing freeware gnu linux commercial systems study average failure rate linux failure rate gnu utilities failure rate reasonable globally scattered group programmers formal testing support software engineering standards produce code reliable measure commercially produced code utilities gnu linux failure rates systems systems explanation scale software supported large computer company extensive free software groups companies customers commitment support software platforms configurations versions operating system older versions hardware system software generic irix ultrix gnu linux gas gas awk gawk bib bibtex gcc gcc ccom cfe cfe obj compress gzip dbx gdb gdb gdb ditroff troff ptroff eqn deqn neqn neqn geqn lex flex flex plot psplot bash soelim gsoelim tbl dtbl gtbl yacc bison table similar utilities utilities listed line table similar function vary systems listed meant identical listed comparison purposes page october utility sunos hp-ux aix solaris irix ultrix gnu linux adb awk bib calendar cat ccom checkeq checknr col colcrt colrm comm compress cpp csh ctags ctree dbx deroff diction diff ditroff eqn table list utilities tested results tests crashed hung page october expand fmt fold ftp graph grep head indent join latex lex lint mail mail make nroff plot prolog psdit ptx refer rev utility sunos hp-ux aix solaris irix ultrix gnu linux table list utilities tested results tests crashed hung page october elitist explanation substitute excellent programmers people write support gnu utilities typically skilled profession fun intellectual challenge people exist corporate softsed soelim sort spell spline split strings strip style sum tail tbl tee telnet tex tsort uniq units vgrind yacc tested crash hang utility sunos hp-ux aix solaris irix ultrix gnu linux table list utilities tested results tests crashed hung page october ware groups users gnu utilities cases mind bug exists find fix ubiquitous source code advantage situation free software personal touch improves communication authors users users incentive reporting bugs gnu utilities individual bug report send person typically answers shows personal interest report large companies require submit bug report anonymous address osbugs bigcompany responses mail slow user hear resolution bug structure corporate software development testing release process year repair made long delays discouraging programmer time bug-fix deployed programmer long forgotten problem gratification solving person problem distributing source code factor quality gnu linux systems users encouraged involved identifying problems computer vendors under-estimating widely distributing source code lessons learned traditional manufacturing industries steel automobiles learned computer industry flexibility responsiveness major key long term survival crashes hangs study examined program crashed hung identify failure source code utilities sunos solaris ultrix hp-ux gnu linux source code nextstep aix irix program failure system source code categorized results reported table letters table entries describe systems entry applies identifying letters column table common failures describe details pointer array errors pointers array subscripts dominate results tests errors novice programmer make surprising find production code cases programmer made implicit assumptions contents data processed assumptions caused programmer insufficient checks loop termination conditions presence errors argues minimally garbage-collected languages fulltime array bounds checking sloppy programmer detect problems pointer errors found study simple increment pointer past page october end array error ctags representative file ctags char line bufsiz line getc inf eof note termination condition loop include tests based size array line array subscripting errors common failures study errors appeared routines character input scanning input line error input appears file char string getch string termination condition loop checks input operation ignores size buffer data read string common type error string processing termination condition loop check size array bibtex file strpascal void null terminate char dangerous input functions common errors dangerous input functions notorious function problem parameter limit length input data causing reliability problems flaw permitted major breach internet security programmer making implicit assumptions structure data processed manual page solaris system wisely warning length input line exceeds size indeterminate behavior result reason strongly recommended avoided favor fgets fgets function includes argument limit maximum length input line library input output routines integrated language collection procedures called newer languages job integrating input operation definition type class operator definition operator character strings include information length page october utility array pointer input functions signed characters divide eof check source code adb sshho bib hau ccom checkeq col sha ain colcrt csh sha ctags dbx deroff sshaou diction shhu ditroff shou eqn sshhu ain fmt ftp sshaou ain indent shogl join lex sshhaugl shu mail make table list utilities crashed hung categorized letters entry describe system failure occurred table description system letters page october array typical char buff bufsize cin buff representation unix character string carry information size array stored set maximum input line size input output class cin width function requires extra explicit action programmer default case dangerous behavior signed characters conversion numbers size problems problem compounded characters symbolic numeric forms type char signed -bit integer unix systems presence sign bit confusnroff shou ain plot prolog ptx sshh refer shu ahn spell sha sou spline strings style shh telnet sshau ain tsort sha sshhoul ain uniq sshau units sshao ain vgrind number bits presence sign bit system dependent programmer sign bit declaration include unsigned utility array pointer input functions signed characters divide eof check source code table list utilities crashed hung categorized letters entry describe system failure occurred table description system letters page october ing error prone possibility sign-extension arithmetic eqn file lookup register int register char tblsize pointed signed character integer characters pointed high-order bit making negative subsequently subscript end-of-file checks checking end-of-file case programmer making implicit assumptions structure input data common dangerous assumption end-of-file occur complete input line end-of-file immediately follow newline character assumption simplify structure application code leaves application vulnerable crashing hanging comparison results study compare results study interesting raw numbers examined bugs caused failures distressing phenomenon emerged bugs discovered approximately reported present exact form study widely published languages code made freely anonymous ftp exact random data streams testing freely ftp identification failures found made freely ftp included code fragments file line number errant code 
records copies fuzz tools bug identifications fetched ftp site bugs found study present study masked original bugs fixing original bugs re-testing exposed techniques study simple automatic difficult understand vendor partake free easy source reliability improvements standard printable characters high-order bit safe assume characters read input page october network services fuzz testing techniques effective finding reliability problems real programs natural question domains techniques applied application fuzz techniques test network services internet network services identified host port number hosts support collection services remote login rlogind telnetd file transfer ftpd user information fingerd time synchronization protocols timed remote procedures calls test services wrote simple program called portjig attach network port send random data fuzz generator testing configuration illustrated figure figure testing network services unix services typically listed file called services test script selected service file random data tested tcp connection-based udp datagram-based services years ago informally tested network services unix systems crash utilities ftpd telnetd ran current tests sunos nextstep linux study crash services tested unix system result bodes network reliability safety curiously crash client programs network services telnet ftp table fuzz portjig service page october x-window applications servers target fuzz testing window system application programs increasing number application programs based graphical user interfaces x-window based applications servers natural targets fuzz testing applications written recently basic unix utilities high failure rates random input tests server proved resistant crashing section describes tools test window server applications section describes tests performed section presents results applying tests applications x-window fuzz tools send random input x-window server applications interposed testing tools client server interposed program called xwinjig generate random input modify regular communication stream x-window application server xwinjig program pretends server applications pretends client real server x-window system capable running machines multiple displays server separate tcp port displays ports numbered display number display standard default display change default display setting display environment variable higher-numbered display xwinjig listens port connects real server standard port server authentication mechanism xwinjig mimic circumvent provide proof authentication reading user xauthority file sending authorization cookie server circumvent authentication disabling access control checking server executing command xhost x-window tests testing x-window server applications combination variations random input streams techniques test server applications test applications input type closer valid input previous potentially tests deeper layers input processing code technique listed important simulates user randomly keyboard mouse application tested combination types types random input type legal random input completely random messages xwinjig concocts random series bytes ships server client message garbled messages xwinjig randomly inserts deletes modifies parts message stream application server random events xwinjig track message boundaries defined protocol manual xwinjig randomly inserts events proper size valid xwinjig implementations called xjig winjig combined features call xwinjig section reports combined results testing tools event message server client interest client happened server side event time key pressed page october opcodes range sequence number time stamp payload random legal events protocol conformant messages logically correct individually sequence events valid values things x-y coordinates window information window geometry parent child relationships event time stamps sequence numbers obtained monitoring client server traffic generate events xwinjig program options control rate injection events frequency method randomizing event stream direction operation client server vice versa event types keyboard mouse events events x-window test results tested version x-window server sunos ultrix systems x-window applications tested sunos testing systems significant time takes complete type testing x-window application programs include distributed vendor locally written freely distributed purchased party vendors quantitative results results tests x-window applications table conclusion draw fuzz testing techniques effective testing programs based graphical user interfaces result encourage type testing window-based systems macintosh test inputs types represent failure server associate libraries reasonable argue errors occur application programs counteract good software design practice programs reasonable error checking external interfaces case crash checks localize problem convince programmer code checks result bug reports software vendor type inputs valid data past basic checks library type test input produced condemning result legitimate input event streams programs tested crashed application programs sources failed type input errors type common users time selected large amounts text window accidentally pasted wrong window x-window system hang results crashes cases x-window application hang exclusive control input keyboard mouse means user select window terminate hung application user workstation remotely kill application crashes hangs identified failures x-window applications tested study section describe errors found general type page october utility input data stream types section combination input mix types legal events type bitmap emacs ghostview idraw mosaic mxrn netscape puzzle rxvt xboard xcalc xclipboard xclock xconsole xcutsel xditview xdvi xedit xev xfig xfontsel xgas xgc xmag xman xmh xminesweep xneko table list applications tested results tests crashed type input hung type input combination input types caused crash listed tests run sunos page october programming errors found similar found basic tests xpaint application crashes common error pointers dereferencing null pointer input library function returns window height structure subsequent code awkward places pointer check null code structure appearance evolving incremental fixes systematic overhaul checking null values found xsnow application creates snowflakes screen drops bottom bug utility sufficiently check return values library functions xcreateregion returns null pointer subsequently passed xpointinregion library functions including xpointinregion check arguments validity interests performance client side libraries scrupulously check message server errors trust client part pass correct arguments check return values xpaint xpbiff xpostit xsnow xspread xterm xtv xweather xxgdb tested crash hang utility input data stream types section combination input mix types legal events type table list applications tested results tests crashed type input hung type input combination input types caused crash listed tests run sunos page october memory allocation calls applied random testing techniques interface application programs system call library created library standard unix library simulate error conditions limited experiment replacing family library routines dynamic memory allocation routines malloc library function allocates memory heap extending program virtual address space null return malloc typically means virtual memory process insufficient swap space system imposed resource constraints common dangerous programming practice ignore return values memory allocation routines failure check return result dereferencing null pointer extracted object files malloc family functions standard library binary rewriting utility rename symbols 
creating object file original library call names called libjig linking library intercept calls malloc figure call malloc user program system library libjig calling real malloc routines libjig control average percent time malloc fails figure intercepting calls memory allocation routine tested programs bin usr ucb directories system running sunos programs source code readily made malloc crashed library utilities crashed listed table memory allocation routines return typically user system resource limit reached common swap space full note utilities listed table programmer situation occurs finger users logged login log super-user fix situation memory allocation routines considered calloc malloc realloc program libjig library malloc void sym table modified void malloc randomly return malloc malloc page october check amount disk space case investigated programs simply dereference address returned malloc checking programs checked return values place programs check case program shows amount disk space checked calls malloc calls library routine getmntent calls malloc checking return code program strong weakest link testing technique modifying return call library easily applied library routine common programming error checking return file operations open read write libjig find potential bugs calls utilities crashed bar login rup tsort finger ruptime users checknr graph man rusers vplot ctags iostat mkstr sdiff deroff rsh symorder xsend table utilities crashed malloc returns tested sunos page october conclusions revisited original testing study expectation difficult find bugs versions utilities tested study surprised ways continued prevalence bugs basic unix utilities bit disturbing simplicity performing random testing demonstrated effectiveness irresistible corporate testing groups basic utilities simply fall cracks major flashy components kernel compiler glory marketing impact companies assign utilities groups reliability network services x-window servers good news basic system components attention computer companies honed high level reliability x-window applications prone failure basic utilities applications generally newer basic utilities hope designed engineering techniques large additional complexity constructing visual interface burden hanging x-window application server ignore input hanging application terminated remotely fourth reliability freely-distributed gnu linux software surprisingly good noticeably commercially produced software difficult result programmer quality culture programming environment general burden supported software developers large companies make concrete software development environments culture hope produce higher quality software modern compilers languages development tools helping develop reliable programs clear tools easily abused primitive tools assembly language programmers proud point good shown section problem missing input field-width specification library found operator versions software released time results represent snapshot versions time testing things left study random testing applied kernel calls randomly generated command-line parameters utilities checking return codes library routines extended input output types calls procedure call interface checked libjig areas system software amenable type testing system call interface ideal candidate calling routines random parameter values produce interesting results operating systems scrutiny gave unix problems found systems tested interpreted unix worse systems popular apple macintosh ibm systems receive level testing page october source code related papers note source binary code fuzz tools unix windows web page ftp grilled wisc fuzz recent paper applying fuzz testing techniques applications running windows found ftp grilled wisc technical papers fuzz-nt pdf acknowledgments gratefully mike powell observations software development process cargille miller binary wrapping technique instrumenting object code sigplan notices june miller fredrikson empirical study reliability unix utilities communications acm december appears german translation fatale fehlertr chtigkeit eine eimpirische studie zur zuverlassigkeit von unix-utilties march ftp grilled wisc technical papers fuzz pdf rochlis eichin microscope tweezers worm mit perspective communications acm june spafford internet worm crisis aftermath communications acm june consortium protocol manual reilly associates 
data stream data import schema tdata mapping gdata view graphical filter rasterization vdata screenimage drawing gif jpeg output 
paradyn parallel performance measurement tools barton miller mark callaghan jonathan cargille jeffrey hollingsworth bruce irvin karen karavanic krishna kunchithapadam tia newhall bart markc jon hollings rbi karavan krishna newhall wisc computer sciences department wisconsin madison dayton street madison abstract paradyn performance measurement tool parallel distributed programs paradyn technologies scales long running programs hours days large thousand node systems automates search performance bottlenecks provide precise performance data procedure statement level paradyn based dynamic notion performance instrumentation measurement unmodified executable files execution performance instrumentation inserted application program modified execution instrumentation controlled performance consultant module automatically directs placement instrumentation performance consultant well-defined notion performance bottlenecks program structure associate bottlenecks specific specific parts program paradyn controls instrumentation overhead monitoring cost data collection limiting instrumentation user controllable threshold instrumentation paradyn easily configured accept operating system hardware application specific performance data open interface performance visualization simple programming library visualizations interface paradyn paradyn gather present performance data terms high-level parallel languages data parallel fortran measure programs massively parallel computers workstation clusters heterogeneous combinations systems introduction paradyn tool measuring performance large-scale parallel programs goal designing performance tool provide detailed flexible performance information incurring space time overhead typically trace-based tools paradyn achieves goal dynamically instrumenting application automatically controlling instrumentation search performance problems dynamic instrumentation defer inserting instrumentation executing program moment needed removing longer needed work supported part department energy grant de-fg office naval research grant -jnsf grant ccrand nsf infrastructure grant cdahollingsworth supported part arpa graduate fellowship high performance computing paradyn performance consultant decides insert instrumentation guiding principles characteristics describe principles guided design paradyn description summarize features paradyn incorporate principles scalability measure long running programs hours days large node parallel machines large data sets correctness debugging test program small data sets confident program work correctly larger data sets performance tuning case real application programs program data set size increase resources saturate bottlenecks measure large programs hundreds modules thousands procedures mechanisms instrumentation program control data display gracefully handle large number program components paradyn dynamic instrumentation instrument parts program relevant finding current performance problem starts high-level problems total synchronization blocking blocking memory delays program small amount instrumentation inserted find problems general problems found instrumentation inserted find specific problem detailed instrumentation inserted classes problems exist automate search performance problems approach performance measurement identify parts program consuming resources direct programmer parts automating search performance information enables paradyn dynamically select performance data collect collect goal tool identify parts program limiting performance require programmer performance consultant module paradyn well-defined notion called search model types performance problems found programs components contained current program performance consultant information search model guide placement modification dynamic instrumentation provide well-defined data abstractions simple data abstractions unify design performance tool simplify organization paradyn important abstractions collecting communicating analyzing presenting performance data metric-focus grids time-histograms metric-focus grid based lists vectors information vector list performance metrics cpu time blocking time message rates rates number active processors vector list individual program components selection procedures processor nodes disks message channels barrier instances combination vectors produces matrix metric listed program component elements matrix single values current average min max time-histograms time-histograms fixed-size data structures record behavior metric varies time time-histogram important tool recording time-varying data long running programs support heterogeneous environments parallel computing environments range clusters workstations massively parallel computers heterogeneity arises processor architectures sparc pa-risc operating systems osf solaris sunos programming models native operating system functions pvm programming languages hpf isolating dimensions abstractions performance tool simplify porting adding support pvm requires communication process creation operations underlying support unix operating system chip architecture programming language support stays paradyn works domains measures programs running heterogeneous combinations domains current hardware platforms include tmc cmsparcs- tation including multiprocessors pa-risc operating systems include tmc cmost sunos solaris programming models include unix ipc solaris thread synchronization primitives cmcmmd fortran cm-rts pvm support high-level parallel languages users high-level parallel programming languages accurate performance information relevant source code programs experience performance problems lowest levels hardware software systems programmers ability peel back layers abstraction examine low-level problems maintaining high-level source code paradyn supports facility allowing high-level language programmers view performance program terms high-level objects arrays loops data parallel fortran terms primitive objects nodes messages open interfaces visualization data sources graphical tabular displays important mechanisms understanding performance data projects paragraph pablo developed large collection visualization routines tool leverage existing visualizations paradyn set standard visualizations time-histograms bar graphs tables profiles simple interface incorporate displays sources equally important ability incorporate sources performance data cache miss data processor network traffic network interfaces paging activity operating system paradyn instrumentation configurable performance quantity mapped program address space including sources data paradyn requires change configuration file streamlined impediments tool installation require fetching files ftp running tool special system privileges modify system directories case users modify source program special compiling techniques dynamic instrumentation paradyn avoids modify recompile re-link application characteristic shared implementations binary rewriting qpt pixie dynamic instrumentation attach already-running program parallel database server monitor performance interval detach dynamic performance measurement paradyn differs previous performance measurement tools program instrumentation performance evaluation execution application program work execution comparing paradyn previous tools raises questions questions include transient effects periodic effects program run long time answers questions based observation measuring long-running programs execution times hours days seconds insert instrumentation start evaluating data chance interesting behaviors missed program runs hours minute transient operation total execution time interesting performance tuning program repeatedly performs operation detect behavior cumulative effect operations large short running programs finish paradyn chance isolate performance problem case paradyn save state search performance problems re-run program complete search section describe measurement methodology present overview structure paradyn tools section presents mechanism dynamic instrumentation implementation details section describes paradyn performance consultant automated module controls dynamic instrumentation searches performance problems section describe paradyn open interface visualizations provide feel paradyn section includes examples measurement sessions real application programs conclude section system overview section overview paradyn system present basic abstractions paradyn describe basic components basic abstractions paradyn built simple powerful data abstractions abstractions unify internal structure system giving users consistent view system data presents abstraction metric-focus grid metrics time-varying functions characterize aspect parallel program performance examples include cpu utilization memory usage 
counts floating point operations focus specification part program expressed terms program resources typical resource types include synchronization objects source code objects procedures basic blocks threads processes processors disks resources separated hierarchies representing class objects parallel application resource hierarchy cpus processor focus components resource hierarchy focus synchronization objects accessed single procedure processor combination list metrics list foci forms matrix called grid paradyn metric focus performance consultant visualizations receive performance data metric-focus grids paradyn stores performance data internally data structure called time histogram time histogram fixed-size array elements buckets store values metric successive time intervals parameters determine granularity data stored time histograms initial bucket width time interval number buckets parameters supplied higher level consumers performance data program runs longer initial bucket width times number buckets double bucket width re-bucket previous values change bucket width time interval change sampling rate performance data reducing instrumentation overhead process repeats time fill buckets result rate data collection decreases logarithmically maintaining reasonable representation metric time-varying behavior components system paradyn consists main paradyn process paradyn daemons external visualization processes central part tool multi-threaded process includes performance consultant visualization manager data manager user interface manager communication threads defined set interfaces constructed module request service module figure shows paradyn architecture data manager handles requests threads data collection delivers performance data paradyn daemon requesting thread maintains distributes information metrics resource hierarchies defined application user interface manager thread developed tcl user visual access system main controls performance data performance consultant controls automated search performance problems requesting receiving performance data data manager visualization manager starts visualization processes visualization thread created paradyn external visualization process started job visualization thread handle communication external visualization process paradyn modules paradyn daemon platform-dependent parts paradyn instrumentation manager implements dynamic instrumentation responsible inserting requested paradyn performance consultant paradyn daemon application processes visualization manager visi thread visi thread manager user interface manager data metric manager instrumentation manager metric manager instrumentation manager application processes histogram visualization tabular summary table visualization cpu messages figure overview paradyn structure dotted ovals threads solid ovals processes instrumentation executing processes monitors interface paradyn process paradyn daemon supports main functions process control performance data delivery performance data requests delivery high-level language mapping data daemon services requests paradyn process control performance data delivers performance data application paradyn encapsulating platform dependencies daemons remote procedure call interface easily handle heterogeneous applications support daemons versions unix tmc cmand networks workstations running pvm configuration files paradyn configuration language paradyn configuration language pcl describe architecture operating system environment language dependent characteristics applications platforms pcl users create metrics instrumentation incorporate visualizations alternate paradyn demons set display analysis options command lines starting applications details metric definition part pcl presented section default pcl file describes paradyn basic metrics instrumentation visualizations daemons user provide additional pcl file personalized settings options users create application-specific pcl file describes details application run dynamic instrumentation paradyn dynamic instrumentation instrument parts program relevant finding current performance problem dynamic instrumentation defers instrumenting program execution dynamically inserts alters deletes instrumentation program execution section describes dynamic instrumentation interface implementation dynamic instrumentation collects mapping information high-level language views users describe metrics section discuss paradyn performance consultant controls dynamic instrumentation find performance problems dynamic instrumentation interface requests dynamic instrumentation made terms metric-focus grid section paradyn daemon translates instrumentation requests instructions inserted application translation two-step process metric-focus requests translated machine independent abstractions metric manager machine independent representation converted machine instructions instrumentation manager counters timers types instrumentation inserted application counters integer counts frequency event timers measure amount time spent performing tasks wall-time process-time units points primitives predicates points primitives predicates provide simple machine independent set operations building blocks dynamic instrumentation points locations application code instrumentation inserted primitives simple operations change counter timer predicates boolean expressions guard execution primitives essentially statements inserting predicates primitives correct points program wide variety metrics computed points system procedure entry procedure exit individual call statements future points extended include basic blocks individual statements provide primitives set counter add counter subtract counter set timer start timer stop timer predicates simple conditional statements consist expression action expression computed counters constants parameters procedure procedure return numeric relational operators primitives predicates combined create metrics shown figure computes amount time spent sending messages behalf procedure foo descendents fooflg counter track foo stack incremented entry decremented exit foo fooflg predicate control msgtime timer primitives called entry exit sendmsg foo active primitives executed foo sendmsg dest ptr cnt size fooflg starttimer msgtme proctime fooflg stoptimer msgtme addcounter fooflg subcounter fooflg figure metric computation translation metric-focus specifications points primitives predicates metric definitions contained pcl configuration files definitions simplify addition metrics porting paradyn systems user customization provide standard library metric descriptions users tools add library metric descriptions pcl consist definitions constraints metric definitions resource constraints generic apply platforms specific platform programming model metric definition template describes compute metric resource combinations consists series code fragments create primitives predicates compute desired metric compute metric combination resource constraints make metric definitions compact modular divide metric definition parts base metric series resource constraints base metric defines metric computed entire application procedures processes processors resource constraint defines restrict base metric instance resource resource hierarchies resource constraints translate instrumentation predicate instrumentation generation instrumentation manager encapsulates architecture-specific knowledge locates allowable instrumentation points performs final translation points primitives predicates machine-level instrumentation paradyn initially connected application process instrumentation manager identifies potential instrumentation points scanning application applications binary image procedure entry exit procedure call sites detected noted points paradyn connected application instrumentation manager waits requests daemon metric manager translates small code fragments called trampolines inserts program types trampolines base trampolines mini-trampolines base trampoline point active instrumentation base trampoline inserted program replacing machine instruction point branch trampoline relocating replaced instruction base trampoline base trampoline slots calling mini-trampolines relocated instruction mini-trampolines code evaluate specific predicate invoke single primitive mini-trampoline primitive predicate point creating mini-trampoline requires generating machine instructions primitives predicates requested metric manager instructions assembled instrumentation manager transferred application process variation unix ptrace interface generated code includes register save restore operations data collection instrumentation inserted application data begins flowing back higherlevel clients current active timer counter periodically sampled transported paradyn daemon data manager note instrumentation track 
precise performance metric sampling rate determines paradyn sees samples counters timers paradyn basic data type easily integrate performance data external sources operating systems variety performance data read user processes examples include statistics virtual memory cpu machines provide hardware-based counters source performance information ibm power cray y-mp sequent symmetry systems provide detailed counters processor events data external sources treated identically paradyn instrumentation external data constrained performance metrics relate back specific parts program read cumulative number page faults process read counter procedure call approximate number page faults procedure internal dynamic instrumentation resource discovery important dynamic instrumentation resource discovery process determining resources application information build resource hierarchies resource information application determined statically paradyn connected application point procedures called types synchronization libraries linked application aspects resource discovery deferred program executing information files read written execution determined files accessed collect runtime resource information instrumentation inserted application program insert instrumentation technique normal instrumentation record file names open requests important dynamic instrumentation collection dynamic mapping information high-level languages paradyn daemons collect mapping information statically sources symbol tables parallel languages defer mapping data structures processor nodes runtime languages change data mappings execution cases dynamically instrument runtime mapping routines paradyn daemons send information data manager data manager information support language specific views performance data section search model performance consultant goal paradyn assist user locating performance problems program performance problem part program contributes significant amount time execution single execution program problems assist finding performance problems paradyn well-defined model called search model organizes information program performance performance problems found searching space defined paradyn performance consultant module search model automate searching performance problems conduct search performance consultant data gathered dynamic instrumentation describe search model detail describe performance consultant automates searching paradyn search model search model abstracts aspects parallel program affect performance based answering questions application performing poorly performance problem problem occur answer question system includes hypotheses potential performance problems parallel programs collect performance data test problems exist program answering question isolate performance problem specific program resource disk system synchronization variable procedure identify problem occurs isolate problem specific phase program execution finding performance problem iterative process refining answers questions axis performance question asked programmers application running slowly axis represents broad types problems parallel program run slowly potential performance problems represented hypotheses tests hypotheses represent fundamental types performance problems occur parallel programs independent program studied algorithms hypothesis program synchronization bound hypotheses represent activities universal parallel computation small set couple dozen provided tool builder cover performance problems hypotheses refined precise hypotheses dependence relationships hypotheses define search hierarchy axis dependencies form directed acyclic graph searching axis involves traversing graph figure shows partial axis hierarchy current hypothesis highsyncblockingtime hypothesis reached concluding syncbottleneck exists program toplevelhypothesis syncbottleneck highsyncblockingtime frequentsyncoperations figure sample axis hypotheses figure shows portion axis representing types synchronization bottlenecks shaded node shows hypothesis considered tests boolean functions evaluate validity hypothesis tests expressed terms threshold metrics calculated instrumentation manager synchronization blocking time greater execution time axis performance question programmers part application running slowly axis represents classes resources parts program performance problem lies searching axis classifies type performance problem searching axis pinpoints problem specific program components search show program synchronization bound subsequent search isolate hot synchronization object thousands program axis represents foci measured hierarchy axis multiple levels leaf nodes instances resources application resource hierarchy refined independently trees figure represent sample resource hierarchies axis display real application shown figure root leftmost hierarchy figure syncobject level types synchronization semaphore message spinlock barrier spinlock barrier nodes individual locks barriers application children message node types messages children semaphore node semaphore groups application semaphore group individual semaphores individual locks individual barriers group group individual message cpus semaphores individual cpu syncobject semaphore barrierspinlock machine procedure tags main main message input figure sample axis class hierarchies shaded nodes show current focus oval objects defined search model triangles static based application rectangles dynamically runtime identified paradyn resource hierarchies include classes memory process shown components axis created times nodes defined statically application starts application execution root resource hierarchy statically defined search model represent resources specific high-level parallel programming languages representing high-level language abstraction axis language-specific axis resource hierarchies correspond resources found language data-parallel fortran axis include data-parallel array hierarchy high-level language resource map collections resources base level maintains mappings resources axes builds mappings data-parallel arrays understood programmers details related message communication programmers ignore mappings translate focus higher-level focus lower-level separating programming abstractions axes searches concentrate abstraction time tools advantage language abstractions explore search space performance problem refined high-level abstraction programmer peel back layers abstraction continue search lower level low-level search starts focus generated applying mappings current higher-level focus axis performance question programmers time application run slowly programs distinct phases execution axis represents periods time types performance problems occur simple program phases execution initialization computation output single phase program performance uniform program enters phase behavior performance problems change radically result decomposing program execution phases convenient programmers understand performance program searching axis involves testing hypotheses focus intervals time application execution full description searching axis scope paper performance consultant performance consultant module paradyn discovers performance problems searching space defined search model ability automatically search performance problems key feature performance consultant refinements made axes requiring user involved determine list refinements children current nodes axis order list internally-defined hints finally select refinements ordered list selected refinement true item ordered refinement list paradyn conduct fully automatic search user make individual manual refinements direct search combine methods feedback search process underway provided search history graph shg search history graph records refinements considered axes result testing refinements figure shows actual shg display sample application programs node graph represents single step search process refinement axes nodes colored current state hypothesis represents tested pink tested true blue tested false green tested orange arcs refinements color-coded axis refinement made refinements axis blue refinements axis purple node label node axis explored refinements considered root node include node axis cpubottleneck step search limited single refinement complete focus search space represented node determined reading path root node node consideration shg represents refinements made rejected current path exploration easily determined blue true nodes root leaf display options figure de-emphasize node types smaller 
font size follow blue nodes figure search discovered program cpu bound procedure postcallbookwork module noncom machine partition mendota open visualization interface paradyn simple library remote procedure call interface access performance data real-time visualization modules visi paradyn external processes library interface performance visualizations implemented visi paradyn visi time-histograms strip plots bar charts tables examples displays section difficult build visi provide data commercial data visualization packages avs incorporate visualization displays systems paragraph pablo visi interface library provide performance data evaluating performance predicates application steering logging performance data experiment management user selects visi menu paradyn menus select foci program components metrics display visi started initial list foci metrics display visi add delete foci metrics calls procedure visi library handles menus selection result visi isolated details paradyn internal structure user interface selection list performance metrics list foci easily pictured dimensional array basically table visi library class called datagrid visi programmer interface performance data datagrid appears visi programmer array array indexed metric focus element datagrid single representing current maximum average time-histogram representing time-varying behavior metric visi requests performance data paradyn request data manager requested data collected data manager send current values visi provide continuous updates additional data collected requested data collected data manager instrumentation manager start collecting visi longer data part system instrumentation data removed visi accesses performance data datagrid standard overloaded array operations optionally visi library notify visi potentially interesting events occur events include arrival data samples disabling selected focus-metric pair fold event time histograms phase created axis visi programmer register callback procedure events time histogram display fold event means curves displayed redrawn doubling time interval x-axis tabular display displaying single values focus-metric ignore events examples paradyn study parallel distributed sequential applications section demonstrate paradyn basic features show programmers paradyn find performance problems illustrate problems visualization displays draw examples measurements real applications graph coloring program based branch-and-bound search linear programming optimization code domain decomposition method application programs written people paradyn project intended solve real application problems ran tmc cmin node partition ran applications paradyn performance consultant discover isolate cpu bottleneck coloring application discover multiple problems synchronization problems cpu bottleneck linear programming code application show performance consultant displays illustrate performance problem figure shows paradyn main window stage programmer started application paradyn displaying axis resource trees nodes exhaustive exhaustive noncom cmsgtagbarrier figure main paradyn control window trees selected display paradyn ready accept user commands control application display visualizations performance data invoke performance consultant find bottlenecks user start stop application times desired execution stopping application stops flow data visualizations stops performance consultant axis display shows resource hierarchy select focus user selects node resource hierarchy user selects root procedure hierarchy leaf node machine hierarchy requested procedures machine display visualization metric focus user simply selects focus axis display selects visualization start visual menu paradyn prompt user list metrics start visualization alternate high-level language axis views displayed separate windows shown paradyn static dynamic mapping information map abstract focus base view user selects focus abstract view paradyn automatically highlights resources base view typically users start performance consultant automated search wait paradyn find performance bottleneck performance consultant running displays window similar shown figure top row performance consultant window pull menus display configuration middle area reports status search description current bottleneck indication previously true bottleneck longer present notice set refinements considered largest area display search history graph shg nodes graph colored state hypotheses discussed section nodes added shg refinements made change color reflect current state search bottlenecks bottom window buttons controlling search process graph coloring application demonstrates paradyn analysis graph coloring program called matchmaker match-maker branch-and-bound search program central manager brokers work idle processors cmmd cmexplicit message passing library program written lines code files performance consultant discovered initial cpu bottleneck match-maker seconds execution figure shows hypotheses foci considered performance consultant starting root node performance consultant considered types bottlenecks synchronization cpu virtual memory instrumentation point identified cpu bottleneck step considered refinements cpu bottleneck confirmed program cpu bound performance consultant refined cpu bottleneck specific module program noncom performance consultant isolated bottleneck procedure postcallbookwork module problem diffused processes performance consultant refine bottleneck displayed visualization bottleneck graph coloring application time histogram display cpu time procedure postcallbookwork program time histogram display figure verifies postcallbookwork responsible large percentage application cpu time exhaustive pexhaustive exhaustive exhaustive stive exhaustive initiatetc semaphoreexhaustive stack hmendotalazy array noncom mmendotax noncom ccpubound root figure performance consultant search graph coloring application figure visualization bottleneck graph coloring application message passing optimization application application called msolv domain decomposition method optimizing large-scale linear models application consists lines code programming language makes sequential constrained optimization library package called minos un-- instrumented msolv runs hour seconds -node cmpartition paradyn found bottlenecks program initialization phase found synchronization bottleneck nodes initialized bottleneck lasted minute refined performance consultant found cpu bottleneck module minos part initial computation phase performance consultant located key synchronization bottleneck persisted rest program execution search history graph isolation bottleneck appears figure msolv msolv msolv msolv spinlocksemaphore msolv msolv msolv mainiter reportdo startup heuristicdo active nodedax sparsedatx sparsen read cobj cmsolv cminos part c-stubs root figure performance consultant search msolv application performance consultant made refinements locating synchronization bottleneck discovered synchronization bottleneck program identified bottleneck due excessiveblockingtime opposed short synchronization operations performed frequently isolated synchronization bottleneck file msolv fourth refined bottleneck procedure active node finally trivially isolated problem single partition partition refinement labeled mendota partition manager performance consultant attempted isolate bottleneck processor node refinement failed bottleneck diffused processors gain understanding synchronization problem displayed bar chart showing amount time spent synchronizing application display figure shows synchronization time program synchronization time spent node display shows figure bar chart showing msolv synchronization time synchronization bottleneck diffused nodes refined conclusions paradyn parallel performance measurement tools incorporate technologies dynamic instrumentation offers chance significantly reduce measurement overhead search model embodied performance consultant means control instrumentation synergy technologies results performance tool automatically search performance problems large-scale parallel programs paradyn support high-level parallel languages lets programmers study performance programs native abstractions language addition provide detailed time-varying data program performance result programmers large applications paradyn easily small prototype application uniform data abstractions metric-focus grid time histogram simple interfaces paradyn provide easy-to-understand interfaces 
program paradyn working system remain directions growth years expanding machine environments cray high-level languages hpf sparse matrix languages problem domains application steering acknowledgments authors sherry frizell initially implemented bar chart visualization authors applications study gary lewandowski graph coloring spyros kontogiorgis msolv ball larus optimally profiling tracing programs acm symposium principles programming languages albuquerque january heath etheridge visualizing performance parallel programs ieee software sept hollingsworth irvin miller integration application system based metrics parallel program performance tool acm sigplan notices symposium principles practice parallel programming april hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high-performance computing conf knoxville tenn hollingsworth miller dynamic control performance monitoring large scale parallel systems acm international conf supercomputing tokyo july riscompiler languages programmer guide mips computer systems december ousterhout toolkit based tcl language proc usenix winter conference january reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance analysis environment scalable parallel libraries conference ieee computer society upson kamins laidlaw schlegel vroom gurwitz dam application visualization system computational environment scientific visualization vol july 
proceedings scalable high performance computing conference knoxville dynamic program instrumentation scalable performance tools jeffrey hollingsworth barton miller jon cargille hollings wisc bart wisc jon wisc computer sciences department wisconsin-madison abstract paper present technique called dynamic instrumentation efficient scalable detailed data collection large-scale parallel applications approach unique defers inserting instrumentation application execution insert change instrumentation time execution modifying application binary image instrumentation required selected analysis visualization inserted result technique collects orders magnitude data traditional data collection approaches implemented prototype dynamic instrumentation cmand present results real applications addition include recommendations operating system designers compiler writers computer architects features permit efficient monitoring large-scale parallel systems introduction efficient data collection critical problem system monitors performance parallel distributed application estimated monitoring programs reasonable level detail current risc processors easily generate megabytes processor performance data massively parallel computer nodes amount data impractical collect shortest programs understand performance parallel programs collect data full-sized data sets running large numbers processors paper present approach performance instrumentation defers instrumenting program execution permitting dynamic insertion alteration instrumentation program execution monitoring performance massively parallel programs requires instrumentation system detailed frugal scalable collect information detailed permit programmer research supported part department energy grant de-fg -er office naval research grant -jand national science foundation grants ccrand cdahollingsworth supported part arpa graduate fellowship high performance computing understand bottlenecks program frugal instrumentation overhead obscure distort bottlenecks original program instrumentation system scale large production data set sizes number processors detailed instrumentation system collect data component parallel machine correct bottlenecks programmers precisely utilization components hindering performance program ways provide frugal instrumentation make data collection efficient collect data tool builders strive make data collection efficient reduce volume data collected tool builders forced select subset data collect existing tools require decisions data collect made prior program execution deferring data collection decisions program executing customize instrumentation specific execution goals frugal detailed opposition collecting detailed information requires lot data frugality afford collect dichotomy choice data collected styles collection periodic sampling state program tracing logging events execution sampling optimizes data volume accuracy tracing optimizes accuracy data volume chose hybrid sampling tracing low data volume sampling accuracy tracing periodically sample detailed information stored event counters timers intermediate values provide data make decisions change instrumentation scalable instrumentation requires data collection remain detailed frugal number resources system grows means handle increases application code size length program execution data set size number processors providing scalable instrumentation important nature bottlenecks parallel programs change dimension increased remove obstacles deter programmers system feel recompiling application performance tool unrea-- sonable burden step required tool run standalone pre-processor appends instrumentation library application binary instrumentation enabled modifying application binary image executing technique impact application insert instrumentation insert instrumentation overhead check enabled point application execution programmer invoke tool attach running program start investigate performance dynamic approach makes collect wide variety performance data requires runtime decisions made data collect collect programmers manually control data collection difficult tedious built system called performance consultant liberates programmer needing make decisions rest paper describes instrumentation system built meet goals detailed frugal scalable section describes design system section details implementation section presents series performance benchmarks initial implementation dynamic instrumentation cmsections describe related work conclusions approach design instrumentation system designed interface higher level analysis visualization tools present abstractions tools resources metrics resources objects gather performance information metrics quantitative measures performance synchronization objectscompute object cpus cpu individual message types work matmultcompute transpose barriers individual barriers code object util cutil msg recv figure resources showing class hierarchies resource instance single resource hierarchy shape resource defined oval objects statically defined independent application triangles static based application rectangles dynamically runtime identified resources metrics abstraction provided dynamic instrumentation resources resources separated hierarchies representing class objects parallel application resource hierarchy cpus processor figure shows sample resource hierarchies left-most hierarchy code resources root hierarchy code objects level modules files constitute application study module procedures defined module individual resource instances created application starts execution execution static components top hierarchy dynamic nodes lower levels hierarchy lowest levels hierarchy representing specific resource instances added application execution resource procedure resources created program monitored information data files discovered dynamically files opened abstraction metrics metrics time varying functions characterize aspect parallel program performance examples include cpu utilization counts floating point operations memory usage defined higher level performance tools instrumentation system performance consultant assist tool builders provide standard set metrics part system metrics computed subset resources system cpu utilization computed single procedure executing processor entire application data collection model provide resource metric abstractions developed dynamic data collection model combines advantages tracing sampling approach dynamically modify program record precise information relevant state transitions counter timer data structures structures periodically sampled report performance information higher layers system control volume data collected ways collecting information needed give moment controlling sampling rate hybrid dynamic tracing sampling provide accurate information provided pure sampling periodically sample program counter compute amount time spent procedure accuracy result depend sampling rate insert code start stop timers procedure entry exit accurately record time spent procedure case sampling rate affects frequently update knowledge time accuracy time periodically sample performance metrics reasons isolate performance bottlenecks specific phases time intervals program execution higher level analysis system partial data decide additional data collected isolate performance bottleneck dynamic instrumentation collects calculates performance data sampling periodically report collected data varying sampling rate affects rate decision making granularity phase boundaries affect accuracy underlying performance data collected data stored data structure called time histogram time histogram fixed-size array elements store values performance metric successive time intervals parameters determine granularity data stored time histograms initial bucket width timer interval number buckets parameters supplied higher level consumers performance data program runs longer initial bucket width times number buckets run buckets store data case simply double bucket width re-bucket previous values addition change sampling rate bucket width process repeats time fill buckets points primitives predicates recording performance information application program accomplished points primitives predicates points well-defined locations application code instrumentation inserted primitives simple operations change counter timer predicates boolean expressions primitives determine primitive executed inserting predicates primitives correct points program wide variety metrics computed expr actn expr non-zero execute actn actn statement call primitive operand counter 
constant parameter expr operand operator operand operand operator figure description predicate language system consists primitives set counter add counter subtract counter set timer start timer stop timer predicates simple conditional statements consist expression action expression non-zero action expressions numeric relational operators operands predicate expressions counters constants point predicate inserted procedure call entry parameters procedure operands expressions predicate inserted procedure exit procedure return actions predicates calls primitives figure describes predicate facility examples primitives predicates combined create metrics shown figure shows metrics computes number times procedure foo called single primitive increment counter inserted entry point procedure foo shows metric compute number bytes transferred message passing procedure parameter add counter primitive multiplication expression fourth arguments message passing function compute number bytes transferred points procedure entry exit individual call statements future versions instrumentation points extended include basic blocks individual statements foo sendmsg dest ptr cnt size addcounter bytes param param addcounter foocount figure showing metrics figure shows slightly complex dynamic instrumentation instrumentation points compute waiting time due message passing constrained single procedure top primitives maintain counter fooflg non-zero procedure foo active lower points calls primitives start stop timer msgtme timer operations occur counter fooflg non-zero foo sendmsg dest ptr cnt size fooflg starttimer msgtme proctime fooflg stoptimer msgtme addcounter fooflg subcounter fooflg figure sample constrained metric implementation previous section defined abstractions resources metrics collect data requests enable metrics specific resource combinations translated calls primitives predicates points application processes implementation instrumentation system divided parts part metric manager translates requests metric resource combinations primitives predicates part instrumentation manager modifies code sequences application monitored metric manager metric manager role two-fold translates requests metrics primitives predicates informs higher level consumers resources monitor control amount overhead instrumentation inflict application execution metric manager designed application machine independent translation metrics primitives metric definitions definitions provided higher level performance tools provide substantial library metric definition viewed template describes compute metric resource combinations consists series code fragments create primitives predicates compute desired metric strategy enabling instrumentation needed greatly reduces amount data collected potential perturbation caused instrumentation system instrumentation requests impact program performance quantify effect metric manager includes predicted cost model predicted cost model information expected perturbation application instrumentation request metric manager metric definition compute instrumentation primitives predicates inserted instrumentation point overhead predicates primitives multiplied point expected execution frequency compute predicted perturbation overhead information predicate primitive measured hardware platform stored system configuration file execution frequency points static model procedure call frequency cost model perfectly predict impact instrumentation application data collected execution dynamically tune estimates program execution instrumentation manager instrumentation manager performs functions identifies potential instrumentation points handles requests primitives predicates inserts application program requests translated small code fragments called trampolines inserted program define types trampolines base trampolines mini-trampolines figure base trampoline point active instrumentation base trampolines slots calling mini-trampolines relocated instruction slot slot instruction call global primitives inserted processes application slots call local primitives specific process structure makes easier hardware broadcast facilities install global requests save registers setup arg restoreregisters base trampoline mini trampoline program relocated instruction local global local global primitive starttimer function figure inserting instrumentation program identifying points instrumentation inserted accomplished analyzing instructions application area compiler writers make task easier helpful additional symbol table information code data program compilers place read-only data program text code segment creates problems post-linker tools correctness debuggers performance tools ball noted problem mini-trampolines predicate primitive specific code primitive point sample instrumentation point trampolines installed appears figure creating mini-trampoline requires generating machine instructions primitives predicates requested metric manager predicate language simple requiring handful instruction types instructions assembled instrumentation manager transferred application process variation unix ptrace interface section addition code requested metric manager code generated save restore registers generated code called primitives overwrite extend points include basic blocks individual statements additional processor state condition codes saved restored figure shows sample mini-trampolines shows simple counter increment generated inline code code generated primitive figure shows instrumentation generated predicate primitive entry point sendmsg procedure figure statement translated branch based fooflg counter counter non-zero stoptimer predicate called mini-trampoline restore save basetramp add load fooflg store fooflg restore basetramp call starttimer cmp save load fooflg load msgtme figure sample mini-trampolines implement dynamic instrumentation needed efficient operating system services include data transport mechanism moving performance data parallel machine perturbation program study scalable version unix ptrace operating system target machine included features forced construct data transport responsible moving performance data parallel machine location analyzed performance data moves parallel machine program execution compete resources program study perturb advantage cmsynchronous gang scheduling avoid problem developed similar signal handler term timeslice handler handler piece user-level code called node end timeslice normal program context saved operating system top timeslice handler mechanism built data transport node buffers performance data memory application program runs transfers data end timeslice program stopped operating system execution context saved program execution state affected timeslice handlers contend program machine resources technique dilation wallclock execution time data transport virtually perturbing effect program execution machines synchronous scheduling model intel paragon model data trana exception data buffer fills nodes force timeslice end early wait end option perturbing effect sport difficult factor cost instrumentation manager make frequent instrumentation application execution scalable cost instrumentation operations grow number nodes parallel computer insert instrumentation instances procedure nodes cost inserting instrumentation single node achieve goal developed parallel broadcast based version ptrace function cmptrace application address space read written broadcast ptrace insert global instrumentation nodes unit time machines provide hardware broadcast ibm construct software message spanning tree spanning tree technique achieves logarithmic time unit time cost experimenting software mechanisms machines form broadcast facility including intel paragon accessible application software cray meiko cswe unit time operations crucial dealing issue scale tools large parallel machines performance implementation studied performance dynamic instrumentation levels report cost individual operations accounting cost exact number instruction cycles costs provide insight abilities limitations techniques insights operating system designers facilities provide provide macro benchmarks examples cost facilities macro results based simple workloads meant general guideline mileage vary explain performance instrumentation bit implementation cmthe cmis distributed memory multiprocessor nodes connected network point-to-point broadcast communication machine controlled front end processor running modified version sunos operating system processor 
nodes consist sparc processors running mhz memory network interface chip node virtual bit free running clock micro benchmarks micro benchmarks show cost individual components dynamic instrumentation report cost basic instrumentation including cost executing trampolines cost primitives predicates detailed break primitive operations report cost instrumentation support functions including data transport broadcast ptrace detailed results provide insights limitations instrumentation techniques guidance operating system designers facilities needed support efficient instrumentation aspect performance instrumentation system studied overhead trampolines inserted time primitive called figure shows cost involved trampolines time required base trampoline clock cycles time no-op slots call mini-trampolines row shows time required smallest mini-trampoline clock cycles required sparc save restore register instructions case register window overflow occurs source delay trampolines clock cycles long branches trampolines final component trampoline overhead time required setup parameters call predicate time ranges clock cycles depending type parameter clock item cycles base trampoline slots branches mini trampoline save restore registers branches parameters figure time execute trampolines intrinsic cost instrumentation time execute primitives figure shows primitives execution time clock cycles addition time execute simple predicate checks counter positive included measured times ranged clock cycles predicate clock cycles stop process timer results collected invoking primitive times tight loop recording elapsed time call counter timer passed primitive effects machine memory hierarchy factored results feel relative cost numbers compared cost primitives simple procedure calls machine one-argument procedure call returned argument clock cycles bottlenecks timers isolated time required execute part timer primitive figure shows timer primitives operations implement timer mhz clock cycle nano-seconds clock primitive cycles addcounter subcounter starttimer wall stoptimer wall starttimer process stoptimer process counter figure cost primitive operations row read clock time bit representation time wall process time bit registers involves reading bit free running network interface clock clock cycles reading high order bits memory low-order word overflow read high-order word check condition re-read clock overflowed result clock cycles read wall clock clock cycles read process time process time requires additional load subtraction factor time process running semantics timers permit multiple call starttimer made matching number stoptimer calls required stop timer time provide abstraction appears row maintain counter component timer primitives store time record timer started elapsed time stopped addition stopping timer involves extra steps compute elapsed time timer started shown compute elapsed row timers read asynchronous sampling function ensure timer consistent stopping permitting sampling time accomplished storing snapshot timer extra field fields updated overhead introduced maintain field shown row labeled consistency check time clock cycles wall process operation start stop start stop read clock maintain counter store compute elapsed consistency check figure primitive times component breakdown cost timer operations shows largest time component primitive majority time cases spent reading clock time substantially reduced processors provided clock readable user level code register access speed risc processors exception dec alpha provide clock feel type clock critical architectural feature permit building efficient performance tools numbers presented reflect time execute primitives made slight modification cmoperating system originally operating system required system call read clock overhead system call dominated cost timer primitives figure shows time execute timer primitives mapped clock system call slowed timer primitives factor ranging overcame bottleneck adding system call operating system maps kernel clock data structure user address space read clock memory speed option implement timers timer library routines supplied thinking machines results timer calls appears figure timers factor times faster vendor-supplied thinking machine timers provide process wall timer applications dynamic instrumentation timer type time feel vitally important building performance tools accessing clocks fast requiring kernel call read clock unacceptably slow default dyninst primitive tmc mapped timers trap clock start wall stop wall start process stop process figure timer overheads tmc cmthe overhead trampolines place improve implementation generated base mini-trampolines straight line code sequence reduce overhead clock cycles no-op slots branch mini-trampoline require additional complexity instrumentation manager primitive removed point primitives clock cycles significant fraction time primitives measured performance components scalable ptrace implementation determine performance piece figure outlines structure communication paths implementation ptrace requests instrumentation controller pipe timeslice handler running front end processor requests broadcast cmnetwork nodes processed ptrace requests aggregated batches instrumentation controller group amortize per-operation cost pipe communication paths shown figure divided overhead component costs fixed startup latency sending request round-trip-time represented row figure cost interpreting executing request shown row cost byte transferred shown row instrumentation controller side handler unix pipe nodes network figure communication paths scalable ptrace time micro-seconds cost controller handler component handler nodes startup cost per-operation cost per-byte cost figure component costs broadcast ptrace results show bottlenecks current ptrace implementation high cost milliseconds batch transferred due unix context-switching impact bottleneck mitigated large batch sizes amortize startup cost operations cmnetwork bandwidth unix pipe per-byte cost handler node case higher pipe byte node received temporary buffer copied desired memory location extra copying reduces effective bandwidth broadcast network measured performance data transport layer moves performance data nodes front end processor data path transport reverse shown figure data transport layer implemented timeslice handlers achieves throughput approximately sec nodes front end throughput bounded hardware architecture network capable greater bandwidth theoretical physical limit front-end processor receive network process scheduled sunos kernel sec arrive front-end limited sec pass data unix pipe front end processor transport mechanism bottleneck data pass reduce amount data transport mechanism hardware combining facilities cmto aggregate metrics components node approach ensures data required aggregate metrics remains constant machine size macro benchmarks micro benchmarks designed study performance primitive operations instrumentation system feel larger picture studied performance instrumentation system entire applications goal benchmarks study aggregate impact instrumentation system real applications conducted type benchmarks evaluated system performed tool makes multiple requests change instrumentation compared overhead dynamic instrumentation existing tools dynamic tests ran parallel applications cmthe application domaindecomposition method optimizing large-scale linear models program database simulator implements parallel grace hash join algorithm simulated shared-nothing environment programs written compared execution time un-instrumented application execution time instrumented application measured cost instrumentation overhead components instrumentation study performance consultant system takes full advantage dynamic instrumentation drive instrumentation results tests shown figure column original execution time shows time run application instrumentation program ran hour couple minutes column execution time instrumentation shows 
total execution time dynamic instrumentation understand time spent divided overhead instrumentation categories null handler time actual handler time direct perturbation types overhead represent time spent end-oftimeslice handlers null handler time cost running end-of-timeslice code instrumentation enabled actual handler time time process ptrace requests collect data nodes differences applications actual handler time due larger volume performance data transferred database application cmuses synchronous gang scheduling overhead time handlers directly perturb performance program dilates execution similar time-shared jobs impact application execution type overhead represents direct perturbation application due instrumentation inserted modest amount applications performance consultant requests instrumentation requires set tests selected sequential applications compared overhead system unix profilers prof gprof made benchmark instrumentation cost compared existing techniques dynamic instrumentation enabled cpu time metric procedure program advantage dynamic instrumentation ability adapt data collection benefits attachable performance tool require application recompiled addition dynamic instrumentation collects intermediate values study time varying performance application traditional prof compiled ran program prof gprof profiling enabled results running dynamic instrumentation prof gprof sequential applications suma components overhead original execution time null actual directapplication execution time instrumentation handlers handlers perturbation decomp hash-join figure cost ptrace operations table shows overhead dynamic instrumentation performance consultant applications running cmall times minutes seconds overhead minutes seconds application original dynamic inst prof gprof multicomm tycho figure overhead sequential cpu profilers marized figure application multicomm math programming application solves multi-commodity network flow problem mutual capacity constraints written mixture fortran application dynamic instrumentation overhead prof gprof overheads prof gprof instrument internals library application makes heavy integer divide library function sparc machines application tycho cache simulator written spends time repeatedly calling small procedures application dynamic instrumentation high overhead compared prof gprof overheads dynamic instrumentation higher perprocedure overhead invoke minitrampoline start stop timer procedure called contrast prof increments counter periodic sampling approximate cpu time procedure gprof identify caller callee relationship procedure sequential macro benchmarks dynamic instrumentation higher per-operation overhead traditional unix profiling surprising dynamic instrumentation direct timing sampling overhead techniques procedure call frequency high blindly instrumenting procedures necessarily granularity data collection flexibility afforded dynamic instrumentation instrument levels procedures modules loops makes collect data granularity application related work systems built defer instrumentation compilation qpt mtool binary re-writing insert instrumentation object file compiled assembled systems require data collection decisions made prior program execution system defers instrumentation program started execute tam facility provided intel paragon tam static set performance instrumentation profiles prof style sampling full event tracing insert instrumentation program loaded memory prior execution method inserting instrumentation similar data collection dynamic major area related work techniques modifying program started execution number correctness debuggers built modify executing program assertion checking conditional breakpoints jeff brown developed debugger cray computers provided feature kessler xerox parc built system dynamic modification program insert breakpoints work wahbe fast data breakpoints employ sophisticated program analysis techniques minimize overhead instrumentation data breakpoints massalin application code patchup synthesis operating system modify program automatically schedule thread block conclusion design implementation data collection strategy meets goals detailed frugal scalable current implementation runs thinking machine cmusing explicit message passing programs written fortran cost primitive operations instruction times application perturbation real applications tested system simple interface metrics resources makes easy instrumentation system higher level performance tools addition provided specific recommendations compiler writers operating systems designers machine architects features monitor large parallel systems compilers provide additional symbol table information post-linker tools correctly relate machine activity back source program operating systems provide scalable versions services ptrace make clock access cheap cheaper memory accesses architects provide high resolution clocks easy access user-level programs work part ongoing project called paradyn design build complete performance measurement environment large-scale parallel machines future plan conduct detailed case study performance consultant dynamic instrumentation interactions real applications process studying refining predicated cost model work underway provide dynamic instrumentation intel paragon clusters workstations pvm acknowledgements adam greenberg tmc helping benchmark cmos timers babak falsafi providing memory mapped timers cmwe authors applications study mark hill madhusudhan talluri tycho spyros kontogiorgis decomp tia newhall hash-join gary schultz multicomm ball larus optimally profiling tracing programs acm symposium principles programming languages albuquerque january brown application code instrumenation technology los alamos debugger los alamos national laboratory october dongarra geist manchek sunderam integrated pvm framework supports heterogeneous network computing computers physics march-april goldberg hennessy performance debugging shared memory multiprocessor programs mtool supercomputing albuquerque nov hollingsworth irvin miller integration application system based metrics parallel program performance tool acm sigplan symposium principals practice parallel programming april hollingsworth miller dynamic control performance monitoring large scale parallel systems acm international conf supercomputing tokyo july kessler fast breakpoints design implementation acm sigplan conf programming language design implementation white plains june massalin threads input output synthesis kernel acm symp operating systems principles litchfield park dec osterhout usenix winter conf jan ries anderson auld breazeal callaghan richards smith paragon performance monitoring environment supercomputing portland nov schneider dewitt performance evaluation parallel join algorithms shared-nothing multiprocessor environment tech report dept comp sci wisconsin april sites alpha architecture manual digital press wahbe lucco graham practical data breakpoints design implementation acm sigplan conf programming language design implementation albuquerque june 
experiment management support parallel performance tuning karen karavanic dissertation submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison copyright karen karavanic rights reserved experiment management support parallel performance tuning karen karavanic supervision professor barton miller wisconsin madison development high-performance parallel system application evolutionary process begin models simulations initial implementation program code incrementally modified continues evolve applications lifespan step key question developers performance change question arises comparing implementation models simulations versions implementation algorithm communication numeric library language studying code behavior varying number type processors type network type processes input data set work load scheduling algorithm benchmarking regression testing present design prototype implementation experiment management environment designed answer performance questions span multiple program executions stages lifespan application developed concise representation set executions collected life application model information experiments application including components code executed execution environment performance data collected gathered program space developed techniques automating comparison measured executions structural difference operator determines differences source code runtime environment performance difference operator compares performance results reports results differ amount present case studies exploring operators large-scale parallel applications developed approach automated performance diagnosis application data gathered previous executions guide search performance bottlenecks adding historical knowledge application means tool perform effective diagnosis evaluated technique versions mpi application ibm found reductions time needed locate performance bottlenecks iii acknowledgments advisor bart miller past years encouragement guidance support guiding periods intense deadline-driven work gift knowing strength wisdom david wood marvin solomon miron livny time effort spent reading dissertation providing valuable criticisms suggestions improving work entire committee marvin solomon miron livny david wood gregory moses lively discussion dissertation defense gratefully acknowledge financial support provided nasa gsrp fellowship program united states department energy national science foundation members paradyn performance tools research group past present provided technical discussions ideas advice encouragement attended practice talks expect people shared technical discussions guidance interesting ideas including douglas pase members ibm parallel tools group poughkeepsie joann ordille john mary zosel mary vernon janet wiener jerry yan bob hood steve huss-lederman doug kimmelman grateful special people provided meals rides beverages laughter occasional roof head lots positive energy stages dissertation work elizabeth webster richard russell phil kaveny mary losaiv rdo mom beth martinson terry mika steve swartz michael rawdon doug pase alain kagi doug burger anne portabella rich maclin beth cole tia newhall systers fellow starfish folks nancy pullen dissertators group shared lives taught eat live toads sam pottle abundance loving encouragement chocolate champagne contents abstract acknowledgments iii contents introduction motivation contributions roadmap related work parallel performance tuning automating parallel performance diagnosis scientific experiment management comparing program versions runs summary program space spacemap eventmap performance results focus retrieving information program space choosing program events spacemap combining eventmaps structural merge operator structural difference operator performance difference matching mapping resources making selections eventmap implementation considerations existing experiment management systems implementing program space object relational dbms implementation strategies summary case studies applying experiment management approach common performance activities draco performance tuning shared memory application comparing alternate implementations porting pvm application mpi summary historical data performance diagnosis introduction paradyn performance consultant types search directives experiments results pruning priority directives thresholds determined historical data historical data code versions discussion conclusions summary directions future research dissertation summary directions future research chapter introduction motivation development high-performance parallel system application evolutionary process begin models simulations initial implementation program code incrementally modified tune performance continues evolve applications lifespan step key question developers performance change question arises comparing implementation models simulations versions implementation algorithm communication numeric library language studying code behavior varying number type processors type network type processes input data set work load scheduling algorithm benchmarking regression testing broad utility type comparison current generation parallel performance tools focuses measuring performance single program execution dissertation describes design prototype implementation performance tool designed answer performance questions span multiple program executions stages lifespan application recent work general area scientific experiment management focuses providing means record data generated experiments includes potentially distributed large varying store experimental data descriptions experimental methodology indexing information link data source view performance tuning specialized instance scientific experimentation complete partial application execution viewed experiment definition performance tool traditional single program execution approach broader inherently multi-execution approach engineers scientists engaged studying improving behavior medium large scale parallel scientific codes analogous chemists biologists carrying experiments lab bench complete partial program run simulation result program model experiment analogous biologist gene-expression experiment chemist chromatography study scientific experimentation archetype basis designing experiment management environment parallel performance environment directly application system developers creators models simulation environments represents qualitative change state art model information experiments application including components code executed execution environment performance data collected gathered program space performance data forms stored program space including scalars tables traces graphs program space includes descriptive data metadata characterize execution examples types metadata environment variable settings compiler options build executable description machine run combinations code execution environment form multi-dimensional program space dimension axis variation point individual experiment program space represents instances program selected points lifetime modified ported architectures tuned compiled options compiler program space views serve user interface system experiment management tool enables exploration space simple naming mechanism selection query facility set visualizations examining behavior version program behavior version program environments common task developers libraries variety platforms require complete performance picture performance single platform important performance platforms performance tuning multiple executions answer deceptively simple question changed run program key component work ability automatically describe differences runs program structural differences differences program source code resources runtime performance variation resources change run difference information necessarily simple measure total execution time complex measure derived details program structure items compared include analytical performance prediction previous execution code set performance thresholds application required meet exceed incomplete set data selected intervals execution automated comparison techniques potential applications compare actual execution predicted desired performance measure application compare dictinct time intervals single program execution complex environment comparison techniques resource allocation metacomputing distributed heterogeneous computers high-speed networks perform scientific computation previously dedicated supercomputers effective resource allocation environment requires knowledge past performance variety architectures machine configurations contributions dissertation describe solutions key problems arise constructing complete experiment management based performance tool developed representation space executions developed techniques 
quantitatively automatically comparing executions tested variety performance related tasks finally evidence utility well-organized accessible store application performance data developed studied approach automated performance diagnosis historic performance data dynamic instrumentation research contribution thesis concise representation set executions collected life application model information experiments application including components code executed execution environment performance data collected gathered program space refer experiment program event program space comprises spacemap eventmaps collection performance results spacemap descriptive data characterizes program events distinguishing program events program space examples descriptive data stored spacemap input data set characteristics environment variable settings compiler options build executable description machine run code version number laboratory eventmap detailed list program event resources individual function names machine components serves interface performance results naming scheme potentially large collection performance data performance results measured values execution behavior total cpu time function program space designed accommodate stored performance data forms including scalars tables traces graphs research contribution set techniques automating comparison measured executions developed techniques determining difference program runs difference computed operators structural difference operator compares eventmaps reports resources differ performance difference operator compares collections performance results reports results differ amount implemented prototype computes difference operators performed case studies explore large-scale parallel applications contribution research investigation historical data contained program space improving performance diagnosis harvesting historical knowledge requires store performance data gathered previous program runs research explores opportunities exploiting collection data focus data gathering analysis efforts critical sections large application approach complex performance evaluation conducted minimum user intervention present approach automated diagnosis application data gathered previous executions guide search performance bottlenecks method leverages repetitive nature performance tuning process rare parallel application examined performance tool adding historical knowledge application means tool effective rely assumptions applications starting point existing diagnostic research tool paradyn parallel performance tool paradyn performance consultant performs online automated bottleneck detection single execution parallel serial program modified performance consultant incorporating types historical knowledge application performance tool search performance problems pruning directives tool ignore resources priorities tool aspects application run-time environment thresholds tool specific values measure application actual performance directives guide online performance diagnosis enhanced version paradyn evaluated technique testing versions mpi application ibm found reductions time needed locate performance bottlenecks roadmap discuss related work chapter chapter presents program space flexible uniform mechanism describing naming selections space executions lifetime application includes flexible canonical representation called resource normal form storing variety program performance data automatic analysis techniques developed describe techniques describing representing comparing multiple versions runs program chapter present results case studies initial prototype implementation experiment management system chapter describe historical performance data improving diagnosis abilities paradyn performance consultant summarize results discuss future research directions chapter chapter related work chapter discuss array research efforts closely related dissertation section examine parallel performance tools section survey approaches automating parallel performance diagnosis section discuss scientific experiment management section surveys work involves comparing program versions summarize section parallel performance tuning performance tuning cyclic process involves repeating series steps acceptable application performance achieved formulate hypotheses application behavior gather data support dismiss hypothesis analyze data direct inspection analytical techniques combination change code environment experimentally based hypotheses parallel applications tuned times ported platform code revision categorize performance tool research efforts identifying steps tool designed accomplish guide part performance tools narrowly defined mechanism gathering data step aide human formulating hypotheses application behavior step single observed program run common approach work manually knowledgable expert conducting tuning study frequently visualization tools recently research focused automating diagnostic process steps projects attempting redefine performance tuning interactive run-time activity perform steering adjustments debugging fixes application runs step completing spectrum current research focused complete automation steps tool includes performance measurement analysis code environment adjustments improve performance research self-tuning applications include code trigger based measured performance values prelude full execution online application running tools detailed address single iterations steps tuning process approach provide framework incorporate existing techniques step performance tuning cycle extend scope include repeated iterations hondroudakis procter proposed term tuning large refer complete process tuning opposed single instance running performance tool iteration program recent survey high performance computing professionals cited maintaining performance related information tuning sessions proposed storing tuning information generally accessible database techniques tuning similar applications automating parallel performance diagnosis variety research projects address issues automating diagnosis parallel programs work limited proposed designs architectures tools automate process tools implemented partially automate diagnostic portion tuning task section survey tools cray developed tools provide automated diagnosis performance bottlenecks atexpert expert system analyze performance data gathered autotasking fortran compiling environment performance characteristics matched source set performance rules results generate specific advice programmer tuning code cray mpp apprentice generates diagnostic feedback advice programmer necessarily general providing direct guidance programmer atexpert apprentice closely tied parallelizing compiler post-mortem tools generate performance measurements application execution perform analysis execution completed s-check tool developed nist partially automated approach diagnose performance-critical parts large-scale applications tool artificially introduced delays statistical technique design experiments dex focus attention synchronization points potential performance bottlenecks approach called synthetic-perturbation screening parts experimental setup narrowing potentially fruitful locations test manually gui tool single metric sensitivity artificially introduced delays relationship experiment management system system implement check functionality types experimentation chitra descriptions performance multiple executions form parameterized models semi-markov chains chaid-based models calculation data summarized trace files aggregation filtering reduction model parameters provide visual feedback tool user focuses attention potential problem areas multiple-execution performance tools paradyn performance consultant performs automated search application inserting removing instrumentation tests hypotheses focus programmers attention small set performance bottlenecks completely automated single button system requires user interaction complete diagnosis chose performance consultant testbed technique incorporating historical knowledge diagnosis chapter projections expert project developed partially automated performance diagnosis capabilities automated postmortem analysis tool developed parallel programs written charm object-oriented programming language narrows list performance problems found estimating reduction execution time result removing bottleneck outputs phase-specific list bottlenecks including location architectures proposed tool perform automated diagnosis poirot project proposed architecture tool automatically diagnose parallel applications range platforms project ended prototype developed work contributed analysis existing diagnostic approaches approach constructing general tool include methods found tools design included store application version data approach combines tool interface problem-solving environment knowledge-based system approach differs choosing foundation scientific experiment management environment addressing inherent 
multi-execution nature performance diagnosis kojak kit objective judgement automatic knowledge-based detection bottlenecks proposed generic automatic performance analysis environment development work builds gerndt earlier work design automated analysis tool implemented work early stages component programmable tool event trace analysis message passing programs called earl implemented specific type analysis implemented tcl script demonstrated scripts calculate execution time program region locate out-of-order message-passing determine synchronization delays incurred issuing mpi recv issuing mpi send scripts added target tool specific work historical data automated performance diagnosis multi-organization effort started europe esprit working group automatic performance analysis resources tools project focusing increased attention potential benefits automating part time-consuming difficult diagnostic process project focused defining goals performance analysis types bottlenecks typical parallel codes written openmp mpi hpf objective tool completely automated performance diagnosis variety common platforms tool require infrastructure developing experiment management system representation program resources members group actively engaged sharing results participating design contrast stated goals working group focused developing inclusive set bottlenecks focused effects adding historical knowledge existing mechanism locating bottlenecks scientific experiment management variety ongoing research efforts attempting provide flexible computer support scientific experimentation work categorized part scientific experimentation process addressed work focuses support individual scientist lab office work focuses techniques organization storage access large central data store accessed large number distributed scientists work support large-scale scientific data stores includes datafoundry project llnl researchers developing solutions storing large collections scientific data includes metadata summary information characterizes larger full set stored data extensible computational chemistry environment ecce project pacific northwest national laboratory includes design implementation experiment management system computational chemists project includes focus scientific metadata attempts provide central store scientists record experimental methods raw input output data object-oriented database system underlying storage engine basis set advisor stores information algorithms calculate chemical results performs automated fit selection chemists solve related problems ioannidis livny describe scientific experimentation identify unmet technological opportunities desktop experiment management system called zoo proposed solution individual scientist desktop researchers define life cycle local experimental studies iterates experimental design data collection intialization request data analysis follow-up point significant expanded role conceptual schemas play providing rich set data services needed scientific experiment support elevate role schemas manipulated user forming queries display query answers chose object-oriented data model database sets major experiment management efforts overlap functionality project ecce ecce focuses issues related serving national repository zoo focuses process happening locally single scientist works discuss potential zoo system work detail section main branch experiment-related research falls heading electronic notebooks electronic notebook system system create store retrieve share fully electronic records ways meet legal regulatory technical scientific requirements goal completely replacing scientists notebooks entails development signature verification security features data evidence paper notebooks doe electronic notebook project developed electronic notebooks variety sites enable sharing heterogeneous data geographically dispersed collaborators focused simple notebook interface web browsers handling non-text data sketches developing general-purpose information sharing utility opposed work targeted specifically parallel performance tuning notebook-like approach possibility eventual gui system comparing program versions runs research efforts developed approaches comparing programs program executions section briefly survey approaches incorporated structural behavioral comparison operators closely related research effort takes multi-execution approach correctness debugging referred relative debugging guard compares program debugged version program detect differences variable values user-defined points execution comparisons made simple complex data types programs compared written languages run heterogeneous environments program comparison limited user-defined variable location pairs defined difference operators simple complex data types compare complex structures factor machine dependent data representations difference operation determines equal notion quantifying difference approach correctness debugging environment sufficient performance debugging comparison programs inherent performance prediction problem seek include performance predictions models scope tuning approach broadening definition program execution include models predictions examples predictive tools toolkit mtool toolkit developed block sarukkai automates predictive analysis task compare actual versus predicted total execution time work include effort compare results platforms environments code mtool includes metric compares observed predicted execution times granularity individual basic blocks approach memory tuning defines difference predicted observed execution time memory bottleneck approach comparing program executions found trace transformation approach performance prediction mendes represent parallel program directed graph node represents trace event edge defines happensbefore relation defined lamport stable program defined program resulting execution graphs identical identical similarity graphs defined degree largest isomorphic graphs induced subgraphs original graphs distance graphs defined n-s number vertices original graphs original graphs isomorphic approach method comparing structural quantitative differences program similarity metrics work saavedra smith developed machine-independent model sequential program execution characterize machine performance program execution developed benchmark consists abstract operations model code platform based number type abstract operator included code metrics program similarity program characteristic similarity normalized squared euclidean distance execution time similarity coefficient variation variable represents time abstract operation defined thirteen parameters calculating program similarity types operations memory bandwidth single precision addition division approach extended develop program-level performance distance metric experiment management system wisconsin program slicing project uw-madison investigated methods determining syntactic semantic differences versions sequential source code foundational work defined slice program respect component set program components affect values variables component horwitz alternative partitioning algorithm goal identifying changed parts sequential pascal program version version classifying semantic textual difference code versions defined number semantically textually changed components version number flow control dependence edges graph representation version wang developed comparison algorithm detects syntactic differences sequential pascal program versions constructing comparing variant parse trees results visualized simple textual side-by-side display versions differences color coded reps investigated program integration merging versions pascal program semantically acceptable slicing project work focuses precise characterization identification differences program versions interesting possibility future research incorporate program slicing techniques tool means performing precise structural difference code hierarchies research efforts examined methods visualization performance data compare versions programs ribler virginia developed alternative methods visualizing categorical trace data including recent work simultaneously visualizing multiple traces ipsallowed visualization data runs matching normalizing total execution time previous work combined paradyn devise enable side-by-side linked visualization data multiple executions parallel application open problems remain matching phases program runs execution time problem mapping resources program versions similar problem mapping resource requirements resources problem received recent attention advent metacomputing environments environments mapping fit job request resources work brune paderborn center parallel computing describes language 
api resource service description rsd goal provide cross-platform mechanism resource request returning information machine platform metacomputing environment gehring presents algorithm generating formal descriptions dynamic execution behavior distributed programs goal schedules load balancers routing systems resource service description project goal allowing resources services complex heterogeneous computing systems metacomputing environments description language designed resources provider requestor classad matchmaking framework condor semistructured data model represent potentially resources resource requests term semistructured data refers data structure structure explicitly defined relational databases data contained bibtex files classad task complex addition resource attributes constraints met match made constraints represent variety conditions people research group machine independently parties goals summary chapter reviewed state art research areas related work parallel performance tools experiment management systems techniques comparing program versions executions viewing parallel performance tuning specialized instance scientific experiment management approach previously investigated similarly creating adaptive parallel performance tool approach based historical application performance data previously suggested implemented chapter program space program space representation collection performance results program versions runs runtime environments refer program space functionality needed store retrieve large collection data pertaining application structure behavior directly developer studying application behavior means organizing navigating potentially large amount data incorporated performance tools past performance included conclusions current performance topmost level program space describe program executions distinguish runs versions application fine-grained level detailed description individual program run refer specific parts data finally representation collected performance data creating program space motivated design goals provide intuitive user interface highlights differences application behavior program runs helps relate differences code environment provide uniform naming mechanism interface performance data accommodate large quantity heterogeneous incomplete distributed data variety visualization data exploration tools address dynamic nature data program runs types performance results added time efficient practical implementation built top commonly database management systems provide answers common performance related questions addressed tools incorporate single program run questions include scaling behavior code results gathered compare platforms performance function improve compiled optimization performance requirements met whats highest amount waiting time run nodes accurate predictive model address goals developed program space program space data describing collection program events program event individual complete partial run program simulation predictive model number program events represented space program events related group code versions defined user combine unrelated programs program space program events represented program space repeated runs identical parameters runs performed modified source code input data sets platforms program space comprises spacemap eventmaps collection performance results spacemap descriptive data characterizes program events distinguishing program events program space examples descriptive data stored spacemap input data set characteristics platform description code version number laboratory eventmap detailed list program event resources individual function names machine components serves interface performance results naming scheme potentially large collection performance data performance results measured values execution behavior total cpu time function point view spacemap eventmap classes information collected sources view represent unified body attributes query section examine components program space spacemap eventmap performance results detail sections section describe retrieving information program space section discuss implementation considerations section present chapter summary spacemap spacemap organized collection metadata descriptive data characterizes collection program events examples input data set characteristics platform description code version number algorithm compiler options laboratory information distinguishing program event entire collection considered metadata context list attributes serve semantically meaningful metadata varies applications reason require attributes limit total number attributes restriction spacemap execution uniquely specifiable selecting combination attribute values property restrictive practice enforced adding attribute eid assigning unique identifier program event attribute stored spacemap labels axis program space attribute values translate coordinates resulting multi-dimensional space defined axes execution point space coordinates determined specific attribute values illustrate concept multi-dimensional space simple program space pictured figure data program events attributes values column shown eid conceptually zoom point program space find eventmap performance results pertaining single program event characterization complete set application data multi-dimensional space apply multi-dimensional database techniques data cube operator eid platformsize inputdata code version original original newsolver original efficiently perform queries program space functionality data cube operator efficient aggregation operators n-dimensional space simplified simple types attribute values integer character character string practice values complex user-defined aggregate types simple identifiers inputdata describe input data set string description input consisting size grid represented data source start time seconds file actual input data set located heterogeneous environment attribute platformsize shown integer represented list processor types counts spacemap serves interface data contained program space navigating spacemap user visualize query program space structure contents selecting valid combination values spacemap corresponds selecting program events data stored program space result selection eventmap display showing details single program execution collection executions depending stored executions match specification selected discuss extracting information program space detail section underlying implementation issues section eventmap eventmap structural information program event gathered compile- execution-time information previous section spacemap represents experiment metadata eventmap hand represents components program execution program structure execution environment program space eventmap program event describes represents program structure serves index performance results program events added program space eventmaps created adding data program event step definitions related eventmap listed figure organize program resources classes aspect application figure complete collection data forms program space illustration cluster data visualizations represents data eventmap performance results application numbers refer eid column table inset shows contents spacemap program space platform size code version input data set platformsize inputdata version original newsolver represent structure class tree called resource hierarchy similar representation paradyn program resources include program code application processes machine nodes synchronization points data structures files class resources unique view application code hierarchy source code based view application machine hierarchy view application runtime environment resource hierarchy collection related program resources root node resource hierarchy represents complete program execution label entire resource hierarchy descendant root node represents program resource view move root node level hierarchy represents finer-grained description program code hierarchy level nodes represent modules level function nodes level loops basic block nodes resource hierarchy figure root level level program-level view figure definitions related eventmap definition eventmap forest composed unique resource hierarchies eventmap definition resource hierarchy tree form resource set children resource hierarchy definition resource pair resource label set unique event identifiers application represents behavior program level modulelevel view source code level function-level view level 
resource hierarchy set resources level leaf level partition set nodes lower level module level figure testutil main vect partition set leaf nodes level hierarchy superscript notation refers level children root node resource hierarchy code hierarchy figure shows set functions partitioned modules code testutil main vect printstatus verifya verifyb main vect addel vect findel vect print figure shows sample eventmap parallel application called tester eventmap figure level resource hierarchy represents view application program view module view function view vect addel verifya printstatus mainmain testutil vect vect findel vect print code verifyb set code machine process code hierarchy nodes represent program modules functions machine hierarchy node cpu tester executed process hierarchy node process resources hierarchies shown follow pattern paradyn data easily incorporate data environments natural process resources children machine resources resource representation logical physical component program execution single resource represent aspect program environment executes process function cpu variable figure leaf node labeled verifya represents resource function verifya module testutil semantic meaning attached resource relevant tool user affect model functionality program execution component uniquely represented single resource internal node resource hierarchy tree represents set resources testutil single resource represents aggregation set printstatus verifya verifyb define measurement cpu time testutil sum cpu time printstatus verifya verifyb resource formed concatenating labels unique path resource hierarchy root node representing resource resource represents function verifya shaded figure code testutil verifya performance results performance datum collected program execution stored program space tuple form eis unique program event identifier eid metric measurable execution characteristic cpu time focus constraint specification narrows scope data part application function time interval specifies time execution data collected performance result scalar complex object performance result uniquely identified eid metric focus time interval represented collection performance results heterogeneous results single program execution include types data figure eventmap program tester vect addel verifya printstatus mainmain testutil vect vect findel vect print tester tester tester process machine cpu cpu cpu cpu tester code verifyb time series traces practice rarely complete set performance results null valid combinations system extensible types performance results include reason types performance results added access methods serving uniform interface focus performance measurement ability parts program applies interested measuring cpu time total entire program run total single function constrain view program selected part focus figure focus selection resources eventmap restrictive rules selecting root node resource hierarchy represents unconstrained view program selecting node narrows view include leaf nodes descendents selected node shaded nodes figure represent constraint functions verifya verifyb process tester running cpu hierarchies focus defines state condition selected hierarchy true time selecting machine function foo results narrowing scope data pertaining function foo ran machine naming performance results based eventmap resource hierarchies call naming scheme resource normal form convert selected set resource nodes resource normal form concatenating selections resource hierarchy shaded selection figure represented code testutil verifya machine process call focus results selecting root node resource hierarchy root focus retrieving information program space populated program space data collection program events view extract data variety ways discuss basic queries specialized operators structural difference discrete distance performance difference querying viewing data execution form question execution comparing answers features program space structure questions inherently multi-execution defer discussion implementation underlying storage query facility section choosing program events spacemap questions asked making selections collection attributes values spacemap queries metadata made selecting particfigure definition focus definition focus formed selecting resource node resource hierarchies eventmap level resource hierarchy total number resource hierarchies nodes selected levels hierarchies ular attribute values spacemap result form filter eventmap screens program events selected values figure selecting platform inputdata codeversion newsolver yields eventmap representing single program event program event selecting platform yields eventmap representing program events note selection result program event result selecting codeversion newsolver questions form results compare platforms asked platforms including recent spacemap metrics compare combining eventmaps structural merge operator selection made spacemap refers program event answer computed merging eventmaps form single representation multiple program events combine eventmaps structural merge operator result single merged eventmap represents distinct program executions calculate structural merge eventmaps compare sets resource hierarchies top-down manner isolate resource hierarchies members program executions matching common pairs root nodes pair level level comparison resource hierarchies continuing top manner rule resource hierarchy nodes match merge node result check children nodes leaf nodes examined fail find match node node match identified level hierarchy entire subtree rooted node added result labeled execution label applying structural merge operator eventmaps yields single eventmap result resources original eventmaps structural merge operation works hierarchical set union operation resources result eventmap merged resources represent resources found multiple executions structural merge operator takes eventmaps operands yields eventmap figure shows algorithm structural merge operator forms eventmaps note required define merge operator individual resources figure comparison function determine resources match defined resource hierarchy attributes unique hierarchy common attributes show simple match function figure match function resource string labels basis determineventmap returns eventmap match return figure algorithm find structural merge eventmaps ing resource difference discuss resource matching section structural merge operation properties commutativity associativity idempotency applied iteratively build single eventmap resources number distinct program events figure shows application structural merge operator eventmaps top set resource hierarchies describes execution middle set describes bottom figure shows result resources common executions lightly shaded code code module examples resources resources unique drawn darkly shaded clear code module bar unique code module car unique note results semaphores resource returns resource return figure merging resources matching pairs resources merged match resource returns boolean return true return false figure algorithm match messages hierarchies children labeled merge nodes root nodes semaphores messages hierarchies considered equivalent non-equivalent hierarchies merged structural difference operator structural difference operator compares eventmaps returns list figure structural merge operator machine poona code module module main foo bar process tester sync objects messages process tester machine poona code module module main foo car machine poona code module module main foo bar car process tester semaphores messages eventmap eventmap eventmap semaphores sync objects sync objects resources occur eventmaps goal comparing performance program executions natural question code environments tests differ perform test runs identical code running identical dedicated platforms resource hierarchy execution identical counterpart execution performance data 
meaningfully compared focus valid individual executions comparison complex cases code run time environment differ test runs determine common set valid resources accomplished structural difference operator spacemap user invoke structural difference operator operator takes input eventmaps returns eventmap nodes valid input eventmaps structural difference operator implemented structural merge operator section result merge filtered differing resource nodes displayed present examples structural difference operator chapter performance difference performance difference operator answers question performance vary program events automates overwhelming task detecting performance potentially large datasets takes inputs merged eventmap filters resources valid included program events returns foci discrete distance metric figure yields answer true list computed hierarchically shown figure iterate resource nodes eventmap starting focus represents entire program execution root focus performance difference noted check specific foci metric metric draw attention immediately performance version approach detailed performance differences undetected situation occur performance differences cancel figure discrete distance operator binary function performance results differ interval performance results discrete distance undefined performance result null discrete distance metric building block clustering differencing performance results figure algorithm performance difference operator perfdiff performance difference operator searches performance results metric requested executions returning list foci results input eventmap collection performance results output set foci true false undefined perfdiff eventmap metric returns set focus answer enqueue pendingqueue eventmapgetrootfocus isempty pendingqueue currentfocus dequeue pendingqueue currentfocus currentfocus true answer answer currentfocus magnify currentfocus enqueue pendingqueue return answer higher-level focus tests false performance change cpu time higher function lower net change entire module case comparison modules show performance difference test individual functions trade-off performance gain stopping testing earlier possibility false negative results re-examine issue experience performance difference operator applied large scale applications construct specific foci operation call magnify figure definition focus node resource hierarchy resource hierarchy original focus form set foci replacing figure focus partial ordering data diagram demonstrates ordering based focus original nodes darkly shaded newly added nodes lightly shaded focus left root focus represents program middle group foci formed taking single step root focus paths group shows foci formed taking single step foci middle group stepping set foci called magnification resource children lower level hierarchy result magnify operation applied focus set foci questions performance requirements met accurate predictive model select program event testing program event represents simulation previous run apply performance difference operator question scaling behavior code select platform sizes spacemap apply performance difference operator relevant metric execution time select specific designed performance difference display focus tool user attention parts application behavior changed run node represents metric-focus pair differing performance metric-focus pairs equal performance results omitted potentially large amount information application performance distilled user overwhelmed full set data figure algorithm magnify magnify returns set foci constructed making step descents resource hierarchy starting focus focus answer children return answer ffn answer answer illustrate performance difference operator display present simple show structural performance data program events figure top box show eventmap code contained modules main calc functions main calculate application ran single machine node figure explanation performance difference display show complete set information application top box shows resources merged eventmap eventmaps identical middle box details refinement steps bottom box shows performance data code machine main main calc calculate node step magnification axis focus machine code machine node code code calc machine node code code calc calculate machine node focus cputime iotime oldalgorithm code machine sec sec newalgorithm code machine sec sec oldalgorithm code main machine neverdown sec sec newalgorithm code main machine neverdown sec sec oldalgorithm code calc machine neverdown sec sec newalgorithm code calc machine neverdown sec sec oldalgorithm code main main machine neverdown sec sec newalgorithm code main main machine neverdown sec sec oldalgorithm code calc calculate machine neverdown sec sec newalgorithm code calc calculate machine neverdown sec sec contents eventmap application data middle figure shows focus magnification resulted pair performance results checked difference program space performance data metrics cputime iotime program versions version result attempting optimize function calculate code function main changed versions performance data shown bottom figure figure sketch contents performance difference display results applying performance difference operator metric cputime program events shown annotated display numbering steps starting point root focus represented left node labeled wholeprogram step figure represents magnification machine hierarchy node step represents magnification code hierarchy calc step represents magnification code hierarchy function calculate label node resource results magnification step reach program space performance data metrics cputime iotime program versions show snapshot performance difference display prototype chapter figure sketch performance difference display contents figure numbered step match textual explanation wholeprogram node calc calculate contents performance difference display matching mapping resources previous section structural merge operator general queries eventmaps matching technique simpler cases sufficient cases practice resources change run program -node application run nodes machine run nodes machine run similarly process run relate performance results previous run current run performance difference operator establish equivalency map differently named resources mapping link resources executions names treat equivalent experimented preliminary forms mapping area warrants study discuss current approach mapping approaches resource mapping approach map conservatively one-to-one mappings resource nodes match fit category approach map aggressively allowing mapping nodes slightly including one-to-many many-to-many mappings approach determined performance-related task performed interested learning changed structurally runs program conservative mapping yield inclusive list determine performance differing program runs include machine node pointing localized failure congestion constrast comparing performance program runs aggressive mapping strategy result performance comparisons greater number pairs resources mapping machine nodes inexact categorical definition performance node compared mapping versions function performance change resulted code change determined apply structural merge operator resource hierarchies invoke match function pair resources find nodes differ resources remain unmatched step manually mapped mappings eventmap single virtual eventmap avoid exponential explosion maintaining list mappings pair eventmaps program space mapping individual resources set directives form map resourcename virtualresourcename user input file gui selecting pairs resources map virtual resource refers refer resource nodes mapping node original resource applying complete set mappings eventmap yields virtual eventmap node map differently named nodes distinct event maps approach list mappings program space manual mapping resource nodes ability map kinds resource nodes automatically machine hierarchy define match function based attributes machinenode machinenode machinenode cpu machinenode cpu machinenode machinenode 
map machine hierarchies independently divide child nodes hierarchy equivalence classes performed adding intermediate level hierarchy node resulting equivalence class test selected pairs hierarchy equality matching equivalence classes pairs hierarchy classes pair equal number equivalence classes original resource hierarchies check cardinality equivalence class cardinality equal pair pair classes mappable mappable pair equivalence classes generate list pair wise mappings making selections eventmap performance results retrieved selecting focus eventmap metric list metrics focus selecting valid focus eventmap acts filter list metrics answer performance results user performs queries performance results uniform manner types performance results stored requested metric focus answer query mix results types performance results eventmap retrieved selecting program event spacemap questions form performance function foo improve compiled optimization select runs optimization levels interest spacemap select function foo resulting eventmap relevant metric cpu time list metrics answer include performance results function foo program events selected optimization levels highest waiting time run nodes select runs values platform size greater spacemap select waiting time metric aggregate resulting list waiting time values question scaling behavior code select runs platform sizes spacemap root focus eventmap relevant performance metric execution time implementation considerations real world problems approach designing underlying database support program space discuss relevant issues briefly survey features experiment management systems compare experimental performance environment present design implementing program space section briefly discuss approaches existing experiment management systems looked existing approaches providing database support scientific experimentation zoo project uw-madison opm project lawrence berkeley laboratory projects researched database scientists running experiments similarity reported results features mentioned researchers implemented released tools mentioned important full implementation experiment management system list features related performance environment comment applicability schemas commodity objects zoo opm schemas manipulated shared reused scientist stored objects zoo meta database accessed web browser opm radical departure traditional database approach user direct access schema performance tuning environment shares schemas enable schemas evolve experimentation database sharing projects mention databases shared scientists projects single experiment involve data multiple sources sharing directly applies performance environment queries span multiple databases allowing queries span databases enable application users developers experimental results locally ability results laboratories section mechanism launching experiments feature usefully added performance environment part current design experiments environment program simulation runs monitoring tools place simple practicality automating launch scalability study push single button mechanism converting data ascii files database objects environment means ability add program events database resource hierarchies performance results input ascii files levels integrity enforcement incomplete information human error performance environment metric focus pairs data gaps data time intervals single program event performance difference operator condition focus valid program events compared performance results exist focus versioning part potential extensible resource definition approach resources representing source code enhanced include actual filenames versions files integration functionality revision control system incorporated match function resources extension object oriented features zoo data model moose query language fox found object oriented features detail section summary found overlap performance study determined scientific experimentation principal storage engine system implemented zoo opm determined impractical project produced complete version features needed fully implement tool illustrate relationship program space zoo present design experiment management system implemented zoo schema program space shown figure follow representation zoo documentation addition ovals represent abstract data types user defined methods main classes eventmap spacemap performance result type performance result stored database requires adt defined child type performanceresult method functions common lookup features getvalue starttime endtime getmaxvalue starttime endtime enables queries performed heterogeneous collection data examples queries discussing written zoo fox query language figure schema program space paradyn data attributevalue eid eventmap hierarchy getrootnode resource getparent getchildren metric focus starttime endtime pdhistogram parent children rid spacemap match machine resource code resource eid method return has-part setof inheritance integer character string boolean floating point getvalue start end performanceresult adt eid getvalue start end select eventmaps choosing attributes spacemap show attribute selected selectedattribute selectedvalue eventmap spacemap members select hierarchy selectedattribute selectedvalue eid eid select performance results eventmap eventmap performanceresult select getvalue starttime endtime selectedfocus focus selectedmetric metric eid eid select greatest cputime program recorded program event select max performanceresult select getvalue start end focus rootfocus metric cputime implementing program space object relational dbms object-relational database management system ordbms combination traditional relational database management system newer object-related functionality additional functionality include user-defined abstract data types adts user-defined methods constructed types sets tuples arrays sequences inheritance major database vendors ibm oracle informix provide amount object support partial compliance current sql draft standard particulars implementation vary long object features discussed implement program space top database product present vendor supplies full range object functionality oracle provide inheritance implementation strategies relational database management system rdbms storage engine underlying object oriented model zoo project approach experiment management software difficulties amount work required implement transformations object-oriented queries underlying database poor performance examples poor fit rdbms dynamic nature schemas difficulty schema changing time attributes added initial database design complete long total database size large practically achieved creating schema copying data needed traditional rdbms schema generally manipulated users typically familiar data definition language users system add performance result types resource types system eventmap structure resources introduce additional difficulties rdbms define match function type resource node hierarchy requires adt clean implementation performance results require user-defined methods extensible type performance result added system inheritance leave open possibility future enhancement distributed version program space enable scientists laboratories working application share performance data recent research xml interface specification describing data web designed data interchange web includes features handling incomplete data varying data schemas xml document analogous relation database dtd equivalent database schema scientific experiment database projects discussed section approach direct access schema research underway add features make sharing data web realistic alternative xml-ql proposed query language xml features needed shared distributed data store field chemistry researchers constructed chemical markup language set xml definitions commonly research community summary chapter presented representation set related program executions called program space complete program space eventmap collection performance results spacemap describing execution-level characteristics program runs versions distinguished structural merge operator ordered comparison program executions building eventmap represents multiple program runs method representing individual performance results operators retrieving information program space simple queries discrete distance performance difference concluded discussion implementation 
issues chapter present examples prototype implementation program space performing variety tasks common performance studies chapter case studies applying experiment management approach common performance activities demonstrating utility experiment management approach performance studies necessitates testing practical situations existing parallel codes end implemented prototype experiment management system structural performance data parallel applications designed small study representative common essential tasks carried laboratories involved writing parallel applications project gathered data study characteristics common environments performance related studies carried project solving problems physics computer science high end computing technology scientists involved primarily computer scientists computation large performance scalability key concerns efficiently simulation computed higher quality result obtained simulation specific algorithms underlying code evolve time concurrently porting tuning efforts study techniques structural performance data examine results runs program platforms data research project involving engineers computer scientists wisconsin syracuse developing application perform radiation hydrodynamics simulations examined data sequential version application platforms study evaluated performance shared memory program evolved versions performance tuning study study structural difference operator compare program versions constructed communication libraries prototype core functionality program space reads resource hierarchies test data paradyn sessions spacemap eventmap displays facility retrieving viewing performance data performance difference operator wrote code tcl extended tree widget blt library draco study examined versions scientific code called draco development team researchers rochester wisconsin developed laboratory laser energy draco adaptive lagrangianeulerian code perform radiation hydrodynamics simulations related direct laser driven inertial confinement fusion variety physics packages employed time step simulate development system computational methods implemented physics packages result packages computationaly intensive simulation code performance tuned parallelized focus draco study sequential code version improved enable finer-grained solutions physics problem simulated computed describe prototype tool sequential version code written fortran application ported sgi irix sparc solaris paradyn researchers begin examining application performance study paradyn dynamic instrumentation large complex application approximately lines source code functions counting libraries divided modules main resource hierarchies sparc platform contained nodes total including resource nodes representing libraries library functions remainder section describe prototype examine data runs draco application execution sgi version execution sparc version repeated execution runs assigned eid paradyn export feature save performance data resource information runs code export writes internal paradyn histogram file header information metric focus time interval size start time number values list time data pairs writes index file list individual data files resource definition file lists names resources paradyn session step load application data prototype application draco refers entire program space building initialized program events string directory data files list application attributes spacemap figure shows views resulting spacemap view left lists attributes describe individual program events view shows spacemap attribute headings expanded show list valid values attributes recorded attributes concurrency sequential parallel platformsize number machine nodes program run operating system num dimensions referring underlying physics simulation algorithm eid unique identifier assigned system program event step navigating experimental data selecting attributes spacemap viewing resulting eventmap figure spacemap draco application chose program events sparc platform selecting solaris attribute pressing show eventmap button result shown figure display show result applying structural merge operator program events program event assigned unique identifier tag resource structural display numeric label showing sum eids program events resource case merged program events figure merged eventmap draco runs eids numeric label resource unique program event numeric label resource common children resource nodes shown hidden clicking parent node snapshot display expanding code module node expection changed versions source code revisions occurred times program run machine quick verify merged eventmap impractical require visually check numeric labels ten thousand nodes hierarchies display structural difference figure shows changed program events case process identifiers note nodes root process placeholders displayed show location process-related resources eventmap distinguish placeholders numeric labels label resource common program events figure shows eventmap draco program events code figure result structural difference operator applied draco program events hierarchy expanded program runs distinguished unique identifiers program run sgi platform program runs sparc platform note modules top list occurred irix-based runs modules occurred sparc-based runs common software engineering practices affecting ability match equivalent resources module equivalent module semantic perspective platform slightly figure merged eventmap draco program events mapping naming convention functions listed irix version included default module sparc version mapping transform resources semantically similar modules considered equivalent needed simple mapping directives accomplish goal map code code figure eventmap draco program events mapping map code code map code code default module result mapping shown figure performance tuning shared memory application goal study test performance difference operator examine potential utility performance study data previously completed performance tuning study protein-folding application called fold developed chemical engineering department eventual target platform application sgi powerchallenge sequential version application written fortran performance tuning study reported detail conducted engineers ported application sgi powerchallenge wisconsin cluster workstations cow cluster sun sparcstation -mhz hypersparc processors myricom myrinet interface running solaris release cow application run blizzard distributed shared memory system paradyn gather performance data blizzard tuned application ported back sgi powerchallenge analyzed program versions performance data study completed ran versions fold steps performance tuning study version starting point tuning study resulted porting cow problem identified serial portion code version consumed execution time nodes source code modified change data partitioning relieve bottleneck resulting version version exhibited problem false sharing data blocks data padded aligned improve cache behavior resulting version present selected results demonstrate benefit experiment management approach navigating large space resources data involved complete performance tuning study version version merged eventmaps applied structural difference operator figure resulting eventmap display distinguishes foci valid eventmaps memory hierarchy shows data partitioning change occurred form eighteen data structures storing particle data gmpart restructuring implemented alleviate performance bottleneck caused frequent data movement nodes applied performance difference operator metric memoryblockingtime performance difference operator compares individual pairs performance results reports differ threshold section progresses performance data partial order defined resource normal form magnification path magnification measured difference data delta figure present performance difference display protein folding application study display shows memory blocking behavior differed runs differed process differences localized data structures gmpart gmpart gmpart gmpart note symbol part data structure imply parent node part resource hierarchy ability verify performance level granularity automates common time consuming task actual tuning project actual performance 
study zeroing performance versions time-consuming task actual study approximately personweeks demonstrated technique actual toy problems shorten time required draw meaningful conclusions application evolving behavior validates technique similar porting tuning efforts common facet high performance software development figure result applying structural difference operator fold versions comparing alternate implementations porting pvm application mpi study examine versions parallel application developed communication libraries pvm mpi goal provide feedback tool user directing attention structural application changed application porting communication library application parallel message-passing fft code solves navier-stokes equation figure results performance difference operator metric memoryblockingtime nodes shown represent resource combinations performance difference detected program events starting left node wholeprogram means performance change runs process nodes performance changed processes level details individual shared data structures shared index structure gmpart gmpart gmpart gmpart shared data structures listed index data structures listed common runs memoryblockingtime changed snapshot selecting nodes process process detailed display children visualization performance data node showing plots values run launched selecting node display dimensions obtained code scientists ibm research haifa history illustrate typical candidate experiment-management based approach performance study version application written sequential fortran transformed parallelized mpi finally rewritten pvm versions application mpi pvm versions examined learn differences versions newly developed methods tool compare structure versions application port pvm mpi message passing libraries scientist porting application directed feedback resulting performance application idea performance degradation original authors code minimal knowledge application design code structure figure show eventmap resulted applying structural difference operator eventmaps representing -node run nspvm pvm version -node run nsmpif mpi version ibm spthis display quick differed code environment runs figure shows snapshots resulting eventmap pvm version assigned eid mpi version assigned eid resources common labeled display left shows portion code hierarchy expanded code hierarchy modules dfft runs leaf level procedures strip strip strip strip appeared execution message hierarchy shows message tags tags represent mpi message tags rest represent message tags pvm version selecting focus eventmap display performance data section shown utility eventmap interface highlighting differences code versions necessitated porting communication library summary chapter presented examples prototype examine performance data gathered scientific application ported platform compare implementations based alternate communication libraries evaluate performance program evolves versions case experiment managefigure resource hierarchies eventmap nspvm nsmpif eventmap display developer navigate resource hierarchies quickly differed structurally program runs display organized resource hierarchies figure chapter addition integer event identifier eid run labeled resources appeared run labeled eid run resources run labeled sum eids resources labeled appeared runs note early prototype version term program event group refer eventmap ment system allowed tasks typically involved performance tuning developing parallel applications completed simply quickly chapter historical data performance diagnosis introduction chapter describes historical performance data data gathered previous executions application increase effectiveness automated performance diagnosis accurate performance diagnosis parallel distributed programs difficult time-consuming task recent survey scientists actively engaged parallel performance tuning reported average time tuning task weeks longer recent research examined approaches automating simplifying process diagnosing single program run present approach automated diagnosis application data gathered previous executions guide search performance bottlenecks method leverages repetitive nature performance tuning process rare parallel application examined performance tool adding historical knowledge application means tool perform effective diagnosis starting point existing diagnostic research tool paradyn parallel performance tool paradyn performance consultant performs online automated bottleneck detection single execution parallel serial program modified performance consultant incorporating types historical knowledge application performance tool search performance problems chose performance consultant foundation reasons online tool presents challenges types tools trace-based post-morem analysis application steering approach generalized wide array challenges unique online approach assure work applied online tools development api dynamic instrumentation ibm dynamic probe class library dpcl beta release set library functions tool developers incorporate dynamic instrumentation tools suggest tools online approach future general search strategy performance consultant works studying unfamiliar applications systematic investigation application depend assumptions application runtime environment yields information wide range programs practice noticed time sat application miss data interesting events possibly stop completion due inherent instrumentation cost limits natural tension generally single button approach performance diagnosis application-specific knowledge-dependent approach goal replace performance consultant single button model augment search strategy cases prior knowledge program studied knowledge incorporate types historical performance data tool search performance problems goals set studies shorten time required identify important bottlenecks evaluate strategy measuring comparing total time find bottlenecks historical information decrease amount unhelpful instrumentation practical limit total amount instrumentation place time minimize inaccuracy results due perturbation decreasing unhelpful instrumentation cases search continue reach limit halt evaluate strategy measuring total amount instrumentation time find bottlenecks determine precise location significant bottlenecks results performance tuning obtained testing identifies small number welldefined potential problem areas practical limits total amount instrumentation result important bottlenecks fully explored limited resources test bottlenecks measure identifying set important bottlenecks execution evaluating effect historical information finding bottlenecks set save performance structural data successive executions application extract knowledge diagnosis collection data form search directives types directives pruning directives tool ignore resources priorities tool aspects application runtime environment thresholds tool specific values measure application actual performance directives guide online performance diagnosis enhanced version paradyn evaluated technique testing mpi application ibm reductions time needed locate performance bottlenecks provide description performance consultant changed describe mechanisms including historical data diagnostic tool section present experiments results section finish discussions conclusions section paradyn performance consultant paradyn application profiler dynamic instrumentation insert delete measurement instrumentation program runs approach results small amount data contrast tracing methods result possibly unusably large data files paradyn program represented resource hierarchies specific parts program identified focus simpler single execution version representational scheme chapter fact starting point developing multi-execution model paradyn performance consultant capitalizes dynamic instrumentation automate bottleneck detection program execution starts searching bottlenecks issuing instrumentation requests collect data set pre-defined performance hypotheses root focus program hypothesis based continuously measured computed paradyn metrics fixed threshold full collection hypotheses organized tree hypotheses lower tree identify specific problems higher starts search measuring total time spent computation synchronization waiting compares values predefined user set thresholds figure performance consultant search progress items toplevelhypothesis added result refining hypothesis nodes excessivesyncwaitingtime excessiveioblockingtime tested false node color pink node cpubound blue tested true expanded refinement nodes bubba channel anneal outchan graph tested 
performance tool high-level parallel programming languages bruce irvin barton miller rbi wisc bart wisc computer sciences department wisconsin-madison dayton street madison wisconsin abstract users high-level parallel programming languages require accurate performance information relevant source code programs performance problems lowest levels hardware software systems programmers peel back layers abstraction examine low-level problems maintaining high-level source code ultimately caused problem paper present model explanation performance information programs built multiple levels abstraction level abstraction includes collection nouns code data objects verbs activities performance information measured nouns verbs performance information mapped level level maintain relationships low-level activities high-level code relationships implicit model build paramap performance tool fortran language practice guided substantial improvements real fortran applications describe design implementation tool show simple tabular graphical performance displays helped find performance problems applications case found performance information levels related parallel fortran arrays subsequently reduce application execution time half bruce irvin barton miller research supported part department energy grant de-fg office naval research grant -jand national science foundation grants ccrand cda-- introduction high-level parallel programming languages promise make programmers lives easier offer portable conceptually compact notations parallel programs compilers automatically map programs complex parallel machines freeing programmers difficult error-prone ineffective task parallel computations explicitly effective performance measurement tools high-level parallel programming languages difficult build account implicit low-level activities created compilers present performance information activities terms source code language paper present model explanation performance measurements high-level parallel applications organize high-level parallel application set abstraction layers corresponds set layers software application built layer abstraction consists collection nouns representing code data elements verbs runtime actions mapping functions relate nouns verbs layer abstraction nouns verbs layers abstraction mapping functions preserve relationships low-level system-dependent activities performed behalf high-level system-independent code constructs mapping functions performance information easily obtained current tools guide designed implemented paramap performance tool fortran programs running cmsystems paramap allowed study large long running applications significantly improve execution times case paramap summarizes system performance source code level terms fortran arrays array subsections statements performance problems fully understood source code level paramap user peel back layers abstraction view runtime system processor activity retaining mappings fortran constructs section paper describes model fortran language discusses applied parallel languages fortran section describes design paramap section demonstrates paramap fortran programs section discusses related approaches problem providing performance information users high-level languages section summarizes concludes paper discussion based tools utilize dynamic instrumentation automated bottleneck searching context generation performance tools model major goal research identify performance characteristics common programming models achieve goal developed framework discuss performance characteristics programming models section informal description noun-verb model parallel program performance explanation model nouns structural elements program verbs actions nouns performed nouns collection nouns verbs software hardware layer called level abstraction nouns verbs level abstraction related nouns verbs levels abstraction mappings mapping expresses notion high-level language constructs implemented low-level software hardware mappings performance information collected lower levels related language level nouns verbs mapping static meaning determined runtime dynamic meaning determined runtime possibly program execution describing model fortran language characteristics representative high-level parallel programming languages fortran dataparallel language permits parallel elemental operations multi-dimensional arrays fortran extends fortran fortran array features similar hpf model applicable parallel programming models including parallel object-oriented languages functional languages logic programming languages parallel runtime systems coordination languages high-level application libraries briefly describe model languages section nouns verbs noun program element performance measurements made verb potential action noun performed noun fortran program figure describe nouns verbs fortran language program declares multi-dimensional arrays line initializes elements array parallel assignment statement line assigns values subsection array line computes sum array line computes function upper left quadrant array assigns array alternate terminology objects methods feel terms overused chosen nouns verbs line nouns fortran include programs line subroutines forall loops arrays line statements lines verbs fortran include statement execution lines array assignment lines reduction line subroutine execution file program parameter integer asum forall asum sum forall end end figure fortran program execution instance program construct verb called sentence sentence consists verb set participating nouns cost cost sentence measured time memory channel bandwidth finally performance information consists aggregated costs measured execution collection sentences performance information array figure include measurements assignments lines reduction line performance information array include measurements assignment line levels abstraction mapping high-level language programs built levels abstraction including source code language runtime libraries operating system hardware constructed systems level self-contained levels interact well-defined interfaces general measure performance level measurements related constructs understood programmer model level abstraction performance measured represented distinct set nouns verbs nouns verbs level mapped nouns verbs levels cmsystems fortran program compiled sequential program set node routines figure sequential program executes cmcontrol processor makes calls discussion nodal style execution fortran programs cmnode executes separate fortran program parallel node routines parallel system routines runtime system cmrts cmrts creates arrays maps arrays processors implements fortran intrinsic functions sum max min shift rotate coordinates processor nodes parallel fortran array divided subgrids subgrid assigned separate node node responsible computations involving local array subgrids array data non-local subgrids needed non-local data transferred computation proceed cmf level rts level node level system control processor sequential runtime node node array subgrids rts routines cmf object code system cmf object code cmf source code figure cmexecution fortran program shaded areas user code labels edge levels abstraction representation fortran figure shows division cmsystem levels abstraction model highest level called cmf level nouns verbs fortran language discussed section middle level rts level rts level nouns include arrays allocated execution set arrays includes arrays found cmf level arrays generated compiler holding intermediate values evaluation complex expressions verbs rts level include array manipulations shift rotate put copy lowest level abstraction node level node level nouns include processor nodes node level verbs include compute wait broadcast communication point-to-point communication mapping function relating nouns verbs level abstraction nouns verbs level mapping top-down bottom-up top-down mapping arrays nodes relate array subsection array set processor nodes bottom-up mapping node routines code lines relate cpu time recorded node routine fortran statement compiled mappings static dynamic static mappings independent time context mapping node level object routines cmf level statements static mapping determined compile time dynamic mappings time varying relationships fortran 
programming assignment faq wisconsin-madison computer sciences department fall barton miller programming assignment faq frequently asked questions answers thing process disk back execution time terminates completes process extra context switches process multiple disk end happen remaining end process disk queue single time process queue usual completes end queue wait sequence continues operations completed order operations occur start clock cycle simulator step clock simulator major operations occur operations handled order running process execution context switch handle completing disk operation start disk operation handle newly arriving process note operations occur clock handle trace records cpu time field trace record cpu time field process dispatched running time context switch context switch handle trace records bytes disk trace record bytes disk disk performed process modified wed dec cst bart 
sample code wisconsin-madison computer sciences department fall barton miller sample code page links files sample code shown class simple queue strings header file simplequeue code implment class simplequeue main program drive main makefile build code makefile template class simple queue header file includes class definition code templatequeue main program drive main makefile build code makefile simple demo threads semaphores file main modified thu oct cdt bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday november nbsp student nbsp signature nbsp paging tlb virtual memory architecture parameters note parameters quiz bit virtual addresses byte page size terabytes real memory page tables stored real memory page tables start page boundary design tlb memory mapping architecture cache -way set associative rows back page draw diagram tlb showing size field tlb bits input tlb describe outputs tlb include read protection bit write protection bit page tlb pte protection bits included tlb address hits tlb bypass page table bits page table wouldn check permissions pages addresses tlb describe features add tlb prevent tlb flushed context switch describe make processor add process field tlb tag field process field processor status word field psw loaded current process context switch memory mapping tables quiz diagram tlb modified wed nov cst bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday october nbsp student nbsp signature nbsp multi-level paging virtual memory architecture parameters bit virtual addresses byte page size terabytes real memory level page tables stored real memory ram page tables start page boundary level page tables maximum size fit single page frame permission extra bits show virtual address mapped real address show fields address interpreted size field bits maximum number entries table hold maximum size table bytes draw label diagram answer question back page needed first-level page table entries times bits bytes bits rounded multiple bits maximum size second-level page table entries entries page size second-level pte ppn bits fits nicely bit word bytes page hold -byte entries bytes times modified wed oct cst bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday october nbsp student nbsp signature nbsp scheduling deadlock question deadlock resource graphs intersection deadlock section lecture notes deadlock situation resource graph lecture notes draw resource graph intersection deadlock identify resources processes involved deadlock resource process node directed graph process acquired resource edge resource process process waiting resource edge process resource question scheduling sjf sctf scheduling difficult build real operating system algorithms require knowledge future real systems guess program sjf sctf easy build simulator job descriptions trace records statistical distributions cpu time number operations start process arrival job total cpu demand characteristic program behavior makes exponential queues good approximation sctf depend fact recent past behavior program good predictor future behavior characteristic give high priority jobs recent low cpu demand give jobs recent high cpu demand lower priority modified mon oct cst bart 
introduction operating systems lecture notes wisconsin-madison computer sciences department barton miller lecture notes note lectures print week lectures review notes class bring class won spend time lecture writing updating sections notes sections marked finished note non-university wisconsin students teachers print notes reproduction requires permission author section overview processes synchronization scheduling section introduction processes section dispatching creating processes section entering exiting kernel section independent cooperating processes section synchronization milk problem section semaphores section semaphore readers writers section monitors section message systems section semaphore implementation section scheduling cpu scheduling section deadlock memory management virtual memory section storage allocation section sharing main memory section base bounds segmentation section paging section translation buffers inverted page tables section virtual memory page faults section page selection replacement section clock algorithm thrashing section working sets file systems section devices section files disk management section unix demos disk allocation section directories section windows file system section file system crash recovery section disk scheduling protection security section protection security section security abuses section security improvmenets encryption section reliability modified thu aug cdt bart copyright barton miller 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday october nbsp student nbsp signature nbsp monitors save life write code provide synchronization control access couple pedestrian bridges bridges cross dangerous shark-infested river picture illustrates problem provided written procedure called crossbridge bridgenum don long takes execute procedure person process cross bridge bridgenum valid values person starting east shore end west shore person starting west shore end east shore procedure returns action completed monitors synchronization mechanism solution syntax presented lecture monitors simply classes extra monitor keyword condition variables follow classic hoare semantics person process processes arrive randomly write procedure called person called people wanting cross river write additional procedures solution obey rules bridge strong hold person time additional people break bridge fall river eaten person wanting cross river bridges time people bridge approximately order arrived initially bridges unoccupied busy waiting hint person procedure monitor procedure call procedures bridgecontrol monitor similar readers writers problem bridgecontrol river void person int river getbridge crossbridge river monitor class bridgecontrol private int busy cond waitlist public bridgecontrol busy busy int getbridge note busy waiting int modified tue oct cdt bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday october nbsp student nbsp signature nbsp dining philosophers classic synchronization problem presented dijkstra dining philosophers problem problem philosophers sitting round table philosophers repeat forever things order eat sleep philosopher plate spaghetti front fork plate important rule philosopher forks eat philosopher acquire fork left plate fork plate reach table forks eating put free forks code attempts solve problem philosopher call method parameter indicating philosopher code stuck deadlock fix code stuck philosopher eat time constructor called main function philosopher processes threads created executing method eat sleep methods provided written don long takes complete philosopher int ---by philosopher forks opposite order break cyclic dependency ---grab left grab fork fork ---grab grab left fork fork eat fork fork sleep modified wed sep cdt bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday september nbsp student nbsp signature nbsp concurrent cooperating processes programs describe output program run output describe possibilities general important facts program made concurrent processes don order run dispatcher switch processes dispatcher eventually continually switch back processes process starve initialization code setting initial values shared variables completed processes run variables shared processes time variable referenced appears expression read memory time variable set appears left-hand size assignment operator written memory reading writing single words ints atomic nbsp problem nbsp initialization int int process process describe output concise write answer slightly verbose description while-loop executing process chance set spinning busy waiting nbsp problem nbsp initialization int int process cout process cout describe output output badc bacd difference depends dispatcher switches processes time set time set modified tue sep cdt bart 
final exam wisconsin-madison computer sciences department spring bart miller final exam student signature problem points scored points total problem alice bob charlene send message doug message private doug read doug show message alice bob charlene decide public-key encryption persons private keys public keys person reliably people alice bob charlene write message describe public-key encryption prepare message doug describe doug read verify message make describe doug keys problem virtual memory architecture parameters bit virtual addresses byte page size segments virtual address gigabytes real memory segment page tables stored real memory segment page tables start byte boundary virtual page read write valid bits problem show virtual address mapped real address show fields address interpreted size field bits maximum number entries table hold maximum size table bytes draw label diagram answer question problem page tables memory system large sparsely populated describe technique memory system store tables efficiently explain technique improve storage efficiency page tables problem virtual memory system part describe tlb memory system cache -way set associative rows draw diagram tlb showing size field bits bits input tlb describe outputs tlb problem file descriptor data structures contiguous linked unix inode block group pointers describe efficiently structure handles sequential access large files contiguous allocation linked allocation unix inodes block group allocation problem due mother day rush hired marshal field department store provide synchronization revolving door door pictured job people flowing directions door constraints door compartments compartment hold person door revolves direction people wait line side door empty compartment person exit compartment person enter people waiting inside person direction move door turn written procedure called turndoor rotates door degrees idea long procedure takes execute rotate door person squash written procedures called enterdoor leavedoor moves person calling routine revolving door idea long procedures execute program starts assume door completely empty open compartments facing inside assume waiting line monitors condition variables wait wakeup calls synchronization mechanism class homeworks write code enterstore leavestore procedures procedures called person process enter leave store procedures return person process safely entered exited store write code procedure enterstore leavestore call turndoor hint enterstore leavestore procedures monitor call procedures monitor const int const int monitor class line public line queuecount void waitinline private condition queue int queuecount line waitinline queuecount queuecount queue wait queuecount-return monitor class door public door private modified tue cdt bart 
venezuela workshop high performance computing agenda nbsp nbsp nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento sponsored nsf conicit usb april puerto cruz venezuela tuesday april session agenda noon arrive puerto cruz nbsp introductions overview barton miller wisconsin carlos figueira universidad simon bolivar paradyn parallel performance tool project barton miller wisconsin slides suma scientific metacomputer carlos figueira universidad simon bolivar slides break challenges compiling scientific computing david padua illinois urbana-champaign slides runtime program evolution jeffrey hollingsworth maryland slides reception wednesday april session agenda parallel systems case studies mar blanca universidad simon bolivar experience construction complex environments artificial vision rina sur universidad central venezuela break tera-scale performance asci program jeffrey brown los alamos national laboratory trends high performance computing enhancing performance computational grid jack dongarra tennessee oak ridge national lab slides nbsp performance characterization metacomputing systems emilio hernandez consejo nacional investigaciones cientificas tecnologica conicit migration user level tba tba-slides nbsp lunch nbsp group activity discussion nbsp dinner thursday april session agenda grid networking infrastructure carl kesselman information sciences institute southern california slides achieving application performance computational grid francine berman california san deigo slides break compelling venezuelan academic community hpc services luis universidad los andes slides high performance computing venezuelan industry emilio agust informatica negocios tecnologia slides nbsp lunch nbsp high performance multidimensional databases joel saltz maryland slides performance visualization usability reusability diane rover michigan state slides nbsp return flight caracas nbsp modified sun jul cdt bart 
coding standards wisconsin-madison computer sciences department fall barton miller coding standards write programs important stylistic things make program clear well-structured list requirements check return system library calls class file non-template classes interface definition part class file implementation methods file indent statements part control-flow statement choose reasonable number characters make indent consistently constants code constant values preferably defined const declaration public data members bad idea general talk bart acceptable program prior permission comments file comment top authors names function method comment beginning summarizing obvious long functions method include comment reasonable intervals intervals break function logical chunks comment summarize chunk makefile program default rule build program class method standard template library stl standard library function strtok strtok modified thu jun cdt bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday november nbsp student nbsp signature nbsp page replacement question answer questions true false give sentence justification exceed sentences process number program fewer number page frames run slowly number run slightly faster true definition working set sufficient page frames store working set adding page frames won significantly improve performance won significantly decrease number page faults page frames number page faults climb lot process working set size change depending number processes running false process working set determined process memory pattern virtual time track behavior unaffected processes question page replacement algorithms describe case pattern algorithm poor job scheduling memory lru lfu fifo min lru case page frames referencing continuous sequential cycle pages end generate page fault subsequent page lfu case page frames frequently referencing pages page page page fault page frequently page forced recently fifo page brought early forced generating unnecessary page fault min min calculates optimal page replacement job modified wed nov cst bart 
programming assignment wisconsin-madison computer sciences department fall barton miller programming assignment due monday september processes unix fork processing goals assignment chance familiarize programming language learn facilities library functions provided unix experience process creation program starting facilities unix fourth experience making program robust resistant crashing assignment write shell program starts programs shell called read input lines standard input parse command arguments start process running command start shell provide prompt wait command line form foobar starts program stored file called foobar arguments program details unix linux manual pages familiar unix manuals online man facility great working assignments wanted fork create process system call works type man fork unix manual organized sections interested sections section commands cat section unix system calls calls directly unix kernel fork open read typically section unix library routines section calls atof strcpy details online manual discussion sections program details shell loop end-of-file waiting line standard input standard stream classes information input output read book man fstream line command arguments form cmd arg argk items separated blank characters spaces tabs shell fork child process overlay exec command file named cmd shell parent process default waiting child process optionally end command input character means parent process wait child process complete prompting command command line processed shell list character strings argument including command arguments passed parameters exec command execvp make program handle input lines long command names arguments deal gracefully command lines arbitrarily long gracefully reject make break program classes class represents abstraction questions testing program test program start simple programs pass parameters test running standard unix linux utilities program crash matter weird input suppose input zero-value characters bytes lines characters result input routines occur test robustness program run files stored directory list files lot nonsense characters real programs executed program crash processing sort reasonable error message displayed -bart public program -datafiles deliverables program handin directory set turn programs copy files public handin login proj makefile include readme file indicating lab machines build program tux nova worked home operating system build code handin directories close time program due details handing program hand print-out program output program sample files provide announce class find files honors credit addition work shell handle standard input output redirect command modified wed sep cdt bart 
arrays mapped processor nodes allocated mappings nodes array sub-regions recorded runtime verb mappings explicit implicit explicit mapping high level verb directly implemented lower level verb sum reduction line figure directly implemented node level additions mapping cmf level sum operations node level additions explicit implicit mappings lower level verb helps maintain semantics higher level verb sum reduction implemented cmsystem partial reductions processor node final reduction partial results cmbroadcast network creation parallelism broadcast communication caused reduction implicit directly cmf level sum statement mapping cmf level sum operations creation parallelism broadcast communication implicit mapping parallel programming models hundreds parallel programming languages proposed implemented distributed general find model describing performance aspects languages entire classes languages section briefly describe nouns verbs levels abstraction mappings languages jade task-parallel language accesses shared data structures synchronize tasks jade withonly block coarse grained task specifies shared objects access executing jade runtime system ensures withonly block access allowing block execute representation jade model withonly blocks shared data objects nouns accesses shared data objects verbs execution withonly block explicitly map execution statements block accesses shared memory objects implicitly map time spent waiting objects sisal parallel functional language achieved performance comparable fortran applications sisal programmer creates functional loops expose code parallel optimization techniques independent loops automatically scheduled parallel processors nouns sisal program include functions loops expressions functional language primary verb sisal evaluation lower level implicitly mapped verbs include scheduling synchronization parallel loop iterations portable runtime systems considered languages performance measurement point view share characteristics traditional languages portable runtime system implements level abstraction composed multiple levels pvm daemon workstation set connections route messages pvm operations potentially map multiple daemon operations effects performance pvm operation measure pvm system measure pvm level verbs daemon level verbs map achieve understanding performance paramap fortran performance measurement tool model guide design implementation performance measurement systems high-level parallel languages evaluate model role gain experience mapping actual parallel language system built performance measurement tool fortran tool called paramap measures performance information nouns verbs levels abstraction cmf rts node discussed section maps performance information levels section describes design implementation paramap section demonstrate tool actual fortran applications overview design paramap description fortran section measured nouns cmf level abstraction include subroutines statements arrays verbs include array assignment reduction subroutine execution statement execution rts level paramap measures cost array manipulations shift copy move node level paramap measures computation cpu time waiting broadcast communication point-to-point communication node level difficult measure directly approximate measuring process time node-level routines perform point-to-point communications paramap simple tcl interface give users post mortem access performance information user constructs sentences nouns verbs asks tool measured cost constructed sentences costs provided formats count number times sentence recorded total time cost sentence time histogram showing cost sentence graphed time level abstraction separated interface current level selected user user construct sentences nouns verbs current level paramap mappings compute costs high-level sentences user asks cost sentence paramap automatically maps noun verb lower levels aggregates lower level costs returning cost user user asks cost array assignment statements paramap map request explicit computations code blocks implicit runtime system activities shifting broadcasting array user selects sub-region array paramap provide information processors elements selected subregion stored paramap mappings implement contexts context set nouns verbs selected user purpose constraining performance information lower levels paramap user select noun array verb reduction cmf level tool create context user peels back layers abstraction moving rts node level paramap context constrain set nouns verbs visible user nouns verbs map reduction array constructing sentences paramap constrains performance information collected reductions array contexts users evaluate low-level performance impact high-level nouns verbs implementation user instruments application program compiling paramap compiler driver driver standard fortran compiler automatically inserts probes subroutine boundaries sequential user object code links application instrumented version runtime system cmrts instrumented cmrts monitors rts level sentences control processor node level sentences processor nodes performance information noun verb gathered formats count time time histogram time histogram discrete representation performance metric time counters timers time histograms constant size formats paramap record long running executions amount space short executions addition performance data paramap collects mapping information node rts level sentences explained language level fortran nouns verbs mapped lower levels static mappings symbol tables line number maps collected compilation dynamic mappings array layouts collected execution compiler optimizations obscure mappings fortran statements code blocks fortran compiler compiles statement individual code blocks cooptimizes resulting code blocks reduce total cost execution result single code block correspond fortran statements performance information gathered code block mapped statements map fortran statements co-optimized code blocks divide individual code block costs fortran statements method assumes equal portion code block computations performed behalf statement assumption hold optimization techniques paramap joins groups cooptimized statements inseparable statement lists statement list simply group statements code blocks optimized paramap users select individual statement noun co-optimized statements statement lists selected unique feature paramap ability provide performance information parallel fortran arrays paramap users request costs entire arrays rectangular subgrids arrays tool maps requests processor nodes selected array subgrid stored paramap collects performance information node level granularity accurate performance information array subgrids partially overlap processor nodes user chooses subgrid partially overlaps processor node paramap asks user expand shrink subgrid fits array distribution perfectly paramap records cmrts array distribution data structures called array geometries map subregions fortran array processor nodes geometry specifies shape size array determines array laid memory paramap instrumentation records array geometry array allocated associates geometry performance information recorded array processor nodes measurement computation waiting communication cost tagged memory location routine executed memory location cmf arrays processed tags create vector performance information set values routine executed array processed node paramap maps node routine tags routine names application symbol table maps array tags array names associative table updated time control processor allocates array tags implement mappings paramap satisfy sentence queries noun verb user node level computation maps array assignments involving array tag combinations supported memory required counters timers time histograms tag combinations large section discuss selective dynamic instrumentation support arbitrarily complex sentence mappings application executes instrumentation probes update counters timers time histograms memory application exits application exits instrumented cmrts collects performance mapping data processors stores file 
programming assignment wisconsin-madison computer sciences department fall barton miller programming assignment due wednesday october message-based producer consumer program goal assignment experience writing program runs parallel unix message passing pipes write program processes structure reader process read input file line time reader line input pass process munch munch scan line replace blank character asterisk character pass line process munch munch scan line convert lower case letters upper case convert pass line process writer writer write line output file synchronization communication processes communicate unix pipes pipe system call create pipes write send read recv skeleton program simple pipe version producer consumer program compiling program program remember -wall -pedantic note include files skeleton program program details program create unix processes start program fork additional processes fork system call note exec process reader read input line line longer characters truncate characters null byte end throw extra characters manual page entry function index making writing munch easier manual page entries islower toupper making writing munch easier read function names lower upper thread writer count number lines print number cout deliverables public program data test file print data file hand output program program completed meet itai demonstrate running program make modify files turn program turn programs copy files makefile readme program public handin login proj makefile modified fri oct cdt bart 
problem set wisconsin-madison computer sciences department fall barton miller problem set problem disk cylinders tracks surfaces cylinder sectors track cylinders numbered edge disk inside disk revolves milliseconds disks spinning arm movement costs milliseconds one-half millisecond cylinder arm moved disk request sector cylinder track sector requests disk queue arm cylinder beginning sector read head long complete queue service discipline fcfs long complete queue service discipline sstf order requests performed sstf make decision based shortest seek time ignoring rotational latency long complete queue service discipline arm moving higher cylinder numbers order requests performed problem general takes disk reads find descriptor file blocks read disk unix version sections lecture notes locate descriptor file named assume data block root directory present memory beginning operation relevant disk blocks main memory assume directory files block long disk operation numbers change directory files larger block problem operating system crashes leaves data stores disk inconsistent state inconsistent state file system data structures correctly describe files directories descriptors free lists happen takes disk reads writes update file descriptors free list system validate file system data structures figure fix allocation scheme based block pointers free block list unix crash block free list allocation scheme based block groups free block bit map demos crash block marked free bit-map suppose disk block appears free list map file action safely make matters worse make suppose disk block appears files time action safely modified tue nov cst bart 
programming assignment wisconsin-madison computer sciences department fall barton miller programming assignment due thursday december simulating cpu scheduling algorithms goal assignment evaluate cpu scheduling algorithms trace data local unix systems test algorithms assignment write program reads trace data simulates cpu scheduling track performance statistics print completion trace file trace files trace files records processes run computer system line file record process records program ran starting time amount cpu time number disk operations performed specifically line trace file form commandname starttime cputime iocount pieces separated number blank characters spaces tabs commandname character string maximum length characters program starttime time millisecond increments ths midnight time program arrived system cputime total cpu time seconds program iocount records total number bytes disk program disk occurs full blocks blocks bytes ignore types network keyboard display lines trace files sorted program starting time program information program structured continuous loop reads trace records advances time important events program maintain notion current time clock simulator variable holds current time clock tick clock start time advances time program runs simulated cpu idle waiting things happen simulator running process running complete case update performance statistics remove process run ready queues process start disk case block process completed disk complete process completed back run ready queue process arrive ready start case current time simulator matches arrival time jobs trace file jobs ready queues scheduling algorithms details scheduling algorithm implement isolated single class program scheduling algorithm versions version program implement round robin scheduling process runs completes time slice blocks disk terminates disk completes job arrives process arrives disk completes running process time slice running process interrupted test time slices version program implement exponential queues process runs completes time slice blocks disk terminates disk completes job arrives time process interrupted process completion back queues end queue correct priority priority levels base smallest time slice process full time slice decrease priority double slice process half time slice increase priority half slice version program implement stcp scheduling version sorting ready queue total cpu time remains process newly arrived process disk completing preempt running process running interrupted back queue cpu time remaining simulator details important details versions context switch takes taking process execution takes starting process execute takes process operation blocks operation completed process perform number operations based iocount field trace record blocks round iocount multiple iooperations trunc iocount iooperations count cputime field calculate process block divide cputime field number operations round millisecond note assuming operations evenly distributed execution program operation occurs end cpu burst cputime divide evenly number operations cpu burst smaller disk number operations greater number milliseconds cputime excess operations end process extra context switches operation examples cputime number operations process start operation execution process execute execute cputime number operations process execute case additional cpu burst disk cputime number operations process start operation execution operations end cpu burst disk operations amount time computer disk disk operation time operation completed start time performance data simulator trace performance statistics print results simulator completes statistics average completion time act job calculate run time difference completion time arrival time act average jobs trace file minimum maximum completion time compute minimum maximum completion times jobs throughput number jobs divide number jobs executed total running time simulator utilization amount time spent computation include idle time time spent context switches print total percentage running time simulator software design issues good design assignment save literally thousands lines code crucial class version program class queuing version program priority queue sorted priority levels version priority queue sorted remaining cpu time parts program re-use versions plenty time assignment don delay started work design initial structure classes talk deliverables hand program readme makefile previous assignments include copy code scheduling algorithm copy code rest program labeled commented simulator print statistics simulator run hand text file output required run program readme file describe files test files assignment found directory -bart public program -datafiles file data large results turn files testing turn results files modified wed dec cst bart 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday october nbsp student nbsp signature nbsp implementing semaphores messages write code class simulates general semaphore messages synchronization mechanism solution include methods implement constructor methods skeleton solution fill details make additions feel semaphore class processes synchronize additional server process implement semaphores server running executing server function don write code creates processes message passing mailbox class presented lecture summarized class exists ready write class mailbox string constructor creates mailbox object points mailbox named string mailbox named exist created mailbox exist mailbox object point existing mailbox processes talk mailbox process construct mailbox object mailbox limit number mailboxes process void send string send message mailbox mailbox full send block room message mailbox assume mailbox big hold messages void recv string receive entire message mailbox stores mailbox empty recv block message nbsp nbsp nbsp nbsp nbsp nbsp nbsp note solution ways solving problem implement logic semaphore keeping counts queues server process nice solution wanted show alternative approach semaphore represented mailbox bit complicated interesting solution server generate unique serial number semaphore instance number make mailbox blocking single sends receives semaphore initialized starting extra messages mailbox ---this class client class semaphore private mailbox sem string semname public semaphore int ---ask server unique number semaphore mailbox mailbox mailbox server mailbox resp mailbox resp getpid send resp getpid resprecv semname ---create mailbox semaphore instance sem mailbox semname ---use separate process initialization don ---have worry blocking queue full fork int semsend exit semaphore delete sem void string semrecv void semsend nbsp nbsp ----this function run server void server mailbox inbox mailbox server int count string inboxrecv mailbox outbox mailbox outboxsend sem count delete outbox count modified thu oct cdt bart 
final project presentations final project presentations monday december noon computer sciences fuzz testing mac examination application utility reliability random input fred moore greg cooksey nbsp abstract tested reliability command-line unix utilities graphical applications mac feeding random input previous studies technique proven effective causing application failures unix linux windows applications report application failures crashes core dump hangs infinite loop source code identify categorize failures provide suggested fixes testing crashed command-line utilities considerably lower rate failure observed cases previous studies found graphical applications reliable tested passed crashed hung cracking installshield trialware matt anderson eric lantz nbsp abstract installshield commonly installation scripting program newest versions include feature called installshield activation service software wrapper enforce trial-version limitations executable library wrapper employs anticircumvention methods including stripping symbols encoding independent server processes debugger detection static binary modification dynamic code modification demonstrate method bypassing protections generate unhindered executable method involves removing debugger checks rebuilding original jump table short-cutting jumps execute installshield code successfully remove protections test executable wrapped activation service code executable produced completely free trial limitations project demonstrates modern commercial anti-cracking techniques vulnerable circumvention explain anti-cracking methods limit types circumvention techniques employ reducing linux boot time mohamed eldawy andrew phelps nate rosenblum nbsp abstract linux boot process comprised numerous complex subsystems minutes execute modern hardware interactions subsystems complicated obscure opportunities reducing time achieve responsive system state present detailed analysis system boot identifying high-cost subsystems kernel initialization process ide subsystem offers compelling component dominating boot process makes attractive target optimizations demonstrate modification ide device subsystem yields significant improvements identify potential optimizations areas boot process compare work efforts reducing linux boot time offer suggestions future work security avoidance windows application dynamic instrumentation sriya santhanam janani thanigachalam nbsp abstract numerous commodity windows-based applications free evaluation copies limited periods time applications constitute prime candidates security attacks dynamic instrumentation capabilities provided dyninst api demonstrate attack attack strategy generic time-limited trial applications microsoft runtime library chosen target application -day trial version securecrt windows attack methodology program inspection runtime code modification applicable stripped unstripped windows binaries implementation evaluation wsclock load control linux vikas garg mike ottum nbsp abstract linux global lru-based replacement policy goal evaluate page replacement policy linux measure performance heavy memory loads implementation wsclock load control implemented wsclock load control algorithms wsclock load control algorithms implemented independent measure impact load control global lru policy behavior wsclock normal scheduler addition measuring impact wsclock load control show heavy load linux preference batch tasks interactive tasks resulting priority inversion wsclock maintains correct priorities providing constant response rate interactive tasks system load increases implementation wsclock load control linux kernel nidhi aggarwal kyle rupnow nbsp abstract abstract replaced existing linux kernel page replacement policy wsclock page replacement policy wsclock effective existing policy combination working set clock algorithms benefit locality access working set simple implement tested implementation benchmarks representing range workloads including intensive workloads compute-intensive workloads interactive workloads kernel included load control fewer page faults individual benchmarks benchmarks page faults improve kernel includes wsclock feature fewer page faults baseline case kernel including wsclock load control outperforms baseline kernel individual benchmarks multiple benchmarks run simultaneously wsclock load control kernel fewer page faults baseline kernel return home page modified mon dec cst bart 
problem set wisconsin-madison computer sciences department fall barton miller problem set problem designing memory mapping hardware machine memory addressing segments paged machine -bit virtual address process segments page size bytes segment tables page tables stored main memory start byte address segment table entry ste points page table page table entry pte points page real memory pte read-enable bit write-enable bit bit set page machine support physical memories gigabytes draw diagram memory map show pieces virtual address tables generate physical address size field page faults memory protection traps large bytes full-sized good idea bounds field ste bounds field units bytes pages double page size keeping bit virtual address problem add tlb memory mapping architecture problem cache -way set associative rows draw diagram tlb showing size field tlb bits input tlb describe outputs tlb flush clear tlb change make tlb avoid clear problem page replacement algorithms describe case algorithm poor job scheduling memory lru lfu fifo problem demand paging system measure resource utilizations cpu utilization paging disk improve cpu utilization faster cpu bigger disk faster disk increase degree multiprogramming decrease degree multiprogramming 
quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday november nbsp student nbsp signature nbsp file systems updating file descriptors file operations inode updated modified part operation updated provide sentence explanation reading block existing file updated changing structure file reading contents change needed alternative answer updated inode field accessed time updated overwriting block middle existing file updated changing structure file blocks beling allocated simply changing existing block change needed alternative answer updated inode field modified time updated writing block appending end file updated changing structure file adding block inode modified unix file sizes original unix file system version bsd lecture notes assume disk blocks sectors bytes pointer disk block requires bytes largest file design show work expression make credit expression correct full credit shouldn calculate final numeric answer unix file system inode direct pointers data blocks i-node pointer single-indirect block pointers additional data blocks pointer double-indirect block pointers blocks pointers additional data blocks pointer triple-indirect block pointers blocks pointers blocks pointers additional data blocks data blocks pointed i-node data blocks pointed single-indirect block data blocks pointed double-indirect block data blocks pointed triple-indirect block total number blocks number bytes block total number bytes modified wed nov cst bart 


quiz wisconsin-madison computer sciences department fall barton miller quiz wednesday december nbsp student nbsp signature nbsp updating file system information disk writing block file on-disk things updated write file data data block disk block free list update inode file descriptor order operations safely recover system crash disk block free list write data block update inode file descriptor access small files disk accesses needed read contents small byte file assume directory points file memory ram structures cached ram traditional unix file system disk accesses needed bring contents data file memory access read inode memory access read data block pointed inode windows file system ntfs disk accesses needed bring contents data file memory read mft entry file small data portion direct attribute contained completely mft entry recovering crash operating system crashes leaves data stores disk inconsistent state inconsistent state file system data structures correctly describe blocks files descriptors inodes free lists happen takes disk reads writes update file inodes file descriptors free list remember multiple processes users updating files time interval operating system rebooted validate file system data structures figure fix assume allocation scheme based unix inodes free space block bit map crash describe algorithm boot time determine file system consistent state consistant state means blocks free list inode blocks valid data removed block bitmap question block marked free free block double-check make system behaving properly recovery algorithm system rebooted create bit map memory blocks free start root directory traverse file system tree inode record bit map disk blocks allocated descriptor alternatively scan disk directly inodes recording bit map disk blocks allocated descriptor bit map free list inconsistencies compare bit map disk show files bit map files bit map step blocks free allocated file modified wed dec cst bart 

problem set wisconsin-madison computer sciences department fall bart miller problem set problem hired wisconsin department transportation computerize traffic control -way intersection pictured east-west street one-way westbound north-south street two-way rules intersection car process arriving intersection call procedure enter indir outdir indir outdir parameters defined constants north south east west parameter indir direction enter intersection outdir direction leave intersection procedure returns safe proceed intersection leaving intersection car process call procedure leave outdir outdir defined cars proceed straight make legal turns turns illegal cars waiting north east directions proceed time safely cars waiting north east directions safely proceed time alternate prevents starvation east-west street single lane north-south street lanes direction write code enter leave methods assume supplied written procedure called idea long procedure takes execute write versions program programs program written semaphores synchronization mechanism assume car process define global variables including semaphores initialized write code cars program written monitors augmented monitors shown lecture notes assume car process describe monitor cars monitor describe data maintained monitor initial values describe methods monitor synchronization describe code cars call monitors properly synchronized call monitor rule difficult obey program written messages assume processes communicating messages processes shared memory mail box unique character string communications methods send receive mailbox constructor send operation mbox send string contents contents send message send operation block assume error cases unknown mail box handled send message queued mail box receive operation string response mbox receive receive operation blocks message delivered message message arrives receiver blocked receive returns receive returns response filled contents message constructor mailbox string mailboxname constructor creates object points mailbox mailboxname process send message mailbox foo receive message mailbox foo mailbox mbox mailbox foo access mailbox mailboxname string naming mail box names waitqueue trafficcop design code executed process programs assume car process create extra processes find problem system binary semaphores declare variables class binsem perform constructor binp binv methods variables binary semaphores implement general semaphores system define class called gensem write code constructor genp genv methods problem system general semaphores declare variables class gensem perform constructor genp genv methods variables general semaphores implement binary semaphores system define class called binsem write code constructor binp binv methods problem important aspect multiprocessing multiple processes concurrently compute single problem mind write program processes multiply matrices store result matrix heart program procedure called matrixmult row column multiples row row times column column stores row column assume matrices memory global processes synchronization mechanisms primitives solution problems silberschatz textbook good problems listed back chapter textbook problem sleeping barber problem problem cigarette smokers problem modified wed oct cdt bart 
programming assignment wisconsin-madison computer sciences department fall barton miller programming assignment due monday november measuring performance system calls goal assignment experience efficiency issues writing programs system programs printing correct answer sufficient program run assignment cost making system calls effect buffering ameliorating cost learn simple timing routines measure time takes read large file situations measure time read large file input routine directly calling unix read system call standard library routine fread program read input file times exact cases read size words program open input file read entire contents -byte time read system call close file program open file read file reading -bytes time bytes time program repeat cases fread call read timing issues measure elapsed times test cases start read loop program call time system call immediately loop call time difference values elapsed time record number read operations numbers calls read fread note time precise precision sufficient assignment precise measure gettimeofday call precise measurement functions gethrtime solaris input file test program large file stored -bart public program -datafiles test file bytes size notice substantial difference timings run test cases experimental method computer scientists notably sloppy experimentalists lot experimental work typically follow good experimental practice experimental method well-established regimen areas science experimental method honest form work specifically performance experiments run program cases recording results table time number calls calculate time read time byte graph results measurements graphing simple sheet graph paper excel graphing facility decide linear logarithmic axes summarize results write paragraph summarize patterns results draw conclusions write paragraph explaining conclude results goal conclusions explain patterns appeared results read bytes results read fread differ conclude fread works note performing experiment summarizing results separate steps draw conclusions present honest understandable results present basic data reader draw conclusions insert bias compiling program programs remember -wall -pedantic deliverables turn programs copy files makefile readme -bart public handin login proj makefile hand text file word form word processor document text file table results paragraphs summary conclusion graphs paper handed directly bart itai itai floor mailbox modified wed oct cdt bart 
false nodes goat partition tested true refined instances measured hypothesis exceeds threshold defined bottlenecks node search represents instrumentation data collection hypothesis focus pair node tests true meaning bottleneck found performance consultant determine specific information bottleneck considers types expansion specific hypothesis specific focus child focus defined focus obtained moving single edge resource hierarchies determining children focus method referred refinement pair tests false testing stops node refined refines true nodes specific focus hypothesis focus pair represented node directed acyclic graph called search history graph shg root node shg represents pair toplevelhypothesis wholeprogram child nodes represent refinements chosen paradyn displays shg list box form show figure depending number resources needed represent application number hypothesis focus pairs explored large prevent data requests overwhelming system capacity perturbing application point reliable results determined cost instrumentation enabled continually monitored search expansion generates instrumentation requests halted cost reaches critical threshold restarted instrumentation deletion initiated nodes test false cost return acceptable level types search directives developed mechanisms including historical data diagnostic tool pruning directives tool ignore resources priorities tool aspects application runtime environment thresholds tool specific values measure applications actual performance pruning directives instruct diagnostic tool ignore subtree resource hierarchy evaluation specific hypothesis mechanism conveying information insignificant parts application total number hypothesis focus pairs tested performance consultant large total number resources large practice frequently true top-down approach effect excluding part potentially huge search space false nodes refined prunes shrink size search space avoid overhead instrumenting small infrequently executed functions pruning search pruning directives customize search strategy environment static process model mpi version leads one-to-one correspondence process machine node n-process programs run machine nodes investigate relative performance process machine prune machine hierarchy pruning dictate search strategy employed examine reduces size total search space side effect pruning incorrectly eliminating important reason investigated methods robustness investigated pruning based historical data functions short execution time redundant hierarchies machine hierarchy processes machines map one-to-one sections hierarchies investigated pruning based general rules pruning syncobject hierarchy synchronization-related hypotheses priorities assign relative level importance focus-hypothesis pairs resources responsible behaviors interest studied allowing data collected longer time interval unlike prunes priorities exclude foci consideration instruct diagnostic tool hypothesis-focus pairs hypothesis-focus pair priority high tested true previous execution low tested false previous executions medium high priority pairs instrumented search start persistent testing continues entire program run true false conclusion reached starting high priority pairs immediately waiting default top search order refine results control search order comparison setting priority medium low ensures ordering node siblings thresholds values determine hypothesis true false focus standard version paradyn threshold set user hypothesis goal number bottlenecks reported practically range reporting large number bottlenecks yields inadequate guidance tuning effort drives cost instrumentation reporting bottlenecks failing refine bottlenecks detailed level information obtained simple visualization investigated automatically setting thresholds based historical data added functionality performance consultant hypothesis definitions custom defined built-in standard performance consultant added infrastructure input search directives write paradyn session data files paradyn front end implemented tcl commands implemented features tcl commands detailed shg setpriority hypothesisname focus high medium low specifies priority level section hypothesis-focus pair whyaxis addhypo hypothesisname parent metric metric threshold comparisonoperator expandpolicy adds hypothesis paradyn axis parent parent node whyaxis metrics calculate hypothesis performance data specific focus resulting compared threshold comparison operator expand policy dictates search continue testing focus child current hypothesis hypothesis set refinements current focus whyaxis addprune resourcename hypothesisname specifies part search space ignore section save data global phase directoryname writes contents paradyn time histograms files created directory options shown dictate global data phase-specific data written save resources dirname writes axis contents list resources file directory save shg global phase dirname writes data contained performance consultant search history graph file directory experiments results performed set experiments evaluate introduction prior knowledge performance consultant search investigated effectiveness adding pruning priority directives performance consultant measuring comparing time locate application performance bottlenecks methods studied advantages application-specific thresholds formulated historical data measuring comparing number bottlenecks successfully diagnosed number locations instrumented gather needed data finally studied pruning prioritization generated thresholds diagnosing versions application simulate common practice performance tuning successive versions implementation describe experiments detail remainder chapter pruning priority directives ran enhanced version performance consultant mpi application solves poisson problem running nodes ibm ran application modifications saved resource hierarchies search history graph performance results run forms base case allowed run completion identify complete set bottlenecks tested variations directed searching generated pruning directives priorities combined version prunes priorities identical search thresholds runs experiment recorded time bottleneck reported tool times recorded timestamps assigned paradyn data reflect execution elapsed time paradyn performs dynamic instrumentation starting timestamp determined instant instrumentation request time required insert instrumentation application code conclusion performance hypothesis reached data collected running application minimum time interval results reported table figure table row presents time seconds tool locate percentage total bottlenecks column total interested measuring time discover bottlenecks detailed level bottlenecks important tend necks found directives prunes priorities priorities prunes general historic table time seconds find true bottlenecks search directives found search paradyn reports results tool user application running interested quickly tool discover bottlenecks column table reports time needed find bottlenecks prior knowledge serves base case measuring techniques remaining columns list results experiments adding types search directives describe detail figure graph percentage true bottlenecks found versus time seconds full set data points cases directives prunes priorities prunes priorities combined experiment investigated performance advantages obtained pruning directives data previous runs generate list pruning directives ran paradyn providing list pruning directives input modified performance configure percentage true bottlenecks found time types search directives line shows time find percentage complete set true bottlenecks prunes included general historic prunes data study summarized table sultant general prunes pruning syncobject hierarchy synchronization-related hypotheses specific application environment historic prunes pruning specific function low execution time formulated based data gathered previous executions application evaluated effects types pruning results listed prunes column table general historic pruning directives resulted improvements time locate bottlenecks substantial improvement type pruning note case general prunes performed historic prunes ability general prunes varies type application application study implemented mpi version static process model add general prune remove process hierarchy yielded good results general prune types 
advanced operating systems paper benchmarking upperalpha list-style-type upper-alpha loweralpha list-style-type lower-alpha lowerroman list-style-type lower-roman upperroman list-style-type upper-roman disc list-style-type disc circle list-style-type circle square list-style-type square wisconsin-madison computer sciences department fall barton miller paper assignment benchmarking interprocess communications assigned wednesday september due wednesday september description goal assignment experience benchmarking measuring performance operating system interprocess communication mechanisms design experiments build simple tools carry methodical experiment summarize results draw conclusions careful benchmarking subtle tricky business things simple glance turn intricate communication mechanisms unix pipe basic ipc mechanisms unix pipe earliest versions unix pipe system call executed process create ends uni-directional communication channel channel stream bytes insures ordering correct delivery pipe combined fork operation processes pass messages socketpair operation create bi-directional channel equivalent pipes internet inet stream sockets stream socket based tcp backbone internet sockets remote inter-host local communication providing abstraction pipe reliable ordered byte stream operating system supports communication sockets internet inet datagram sockets datagram socket based udp protocol stream socket remote inter-host local communication message abstraction stream addition provide reliability message ordering guarantees provide checksums message delivered contents intact simpler protocol overhead datagram sockets experience packet loss experimental set-up designed tolerate loss measurements choose version unix operating system system version solaris linux aix windows macos platform measure follow features clock precision operating system hardware provide ways measure time identify ways measuring elapsed time determine resolution precision clock read clock start end simple loop start single loop iteration increase iteration count loop difference samples greater smallest non-zero positive difference single iteration loop takes time putting simple statements timer calls repeat test measure time precise rest experiments trivial kernel call choose simple kernel call getpid measure compare elapsed time perform calls choose kernel calls suspect perform trivial operations measure time perform inter-process communication time communication mechanisms listed measure characteristics message latency latency time activity complete beginning end message passing time start send completion receive clocks hosts sufficiently aligned easiest measure message latency measure time takes complete round-trip communication divide beware nagling internet stream experiments mechanism unexpected delays disable nagling tcp nodelay socket option measure latency variety message sizes bytes watch message size limits udp throughput throughput amount data unit time case round trip measure return message entire transfer amount send large total quantity data single ack response contributes small amount time compared transfer measure throughput variety message sizes bytes watch message size limits udp experimental method computer scientists notably sloppy experimentalists lot experimental work typically follow good experimental practice experimental method well-established regimen areas science experimental method honest form work basic parts experiment identify variables variables things observe quantify identify variables related variable message size send operation effect time complete send sounds obvious consciously identify variables experiment perform hypothesis hypothesis guess hope educated guess outcome experiment hypothesis worded tested experiment stated terms experimental variables experimental apparatus obtain equipment experiment case needed computer software performance experiment record results part typically real work note important steps summarize results summarization means putting data form understand put data tables graphs statistical techniques understand raw data averages make read jim smith paper october issue cacm types means draw conclusions note performing experiment summarizing results separate steps draw conclusions present honest understandable results present basic data reader draw conclusions insert bias experimental method subtleties account experimenter subject biases description sufficient basic computer measurement experiments learning sockets ocket calls resources suggested members research group http ecst csuchico beej guide net html http docs sun doc chapter http osr doc caldera netguide contents html chapter constraints paper pages inclusive point font point spacing single-sided inch margins paper parts title title descriptive fit line page interesting titles acceptable avoid overly cute abstract paper description paper state basic ideas techniques results conclusions paper abstract introduction summary advertisement draw reader paper misleading complete understand covered paper avoid phrases paper describes technical paper mystery afraid giving ending body main part paper include introduction prepares reader remainder paper assume reader knowledgeable operating systems introduction motivate rest discussion outline approach main part paper split reasonable sections follow basics experimental method discussion reader learned paper repeat things stated earlier paper extent contribute final discussion cite paper referenced section appears end paper figures paper figures graphs diagrams boring paper performance tables graphs paper figures re-describe assignment address issues paper written correct english grammar spelling mistakes note list writing suggestions avoid common mistakes prepare paper modified wed sep cdt bart 
advanced operating systems project list wisconsin-madison computer sciences department fall barton miller project list project assigned thursday october project proposal due monday october midway interviews friday november draft report referees friday december class referee reports authors wednesday december final report due tuesday december project presentation session tuesday december time tba general comments projects intended give opportunity study area related operating systems project require test implementation measurement study analysis literature search evaluation project suggestions briefly stated intended guide areas expected expand suggestions full project descriptions freedom selecting area burden defining project issues listed project cover topic listed talk work reasonable project description write paper reports project paper structured submit conference provide details project report semester work teams people cases people project report projects project suggestions mentioned ideas class encourage develop idea kernel profiling revisited paper assignment profiled basic kernel operations including simple kernel calls interprocess communication operations behaviors explained easily techniques disposal goal project explore depth performance results tool effort kerninst preferred platform study linux machines crash burn lab dynamic instrumentation api paradyn project developed library patching code running programs interface called dyninst api programmers write tools patch code unmodified programs machine-independent tool dyninst work sparc power amd alpha simple tools built dyninst tracing debugging complex tools things checkpointing process migration idea project involves security avoidance software vendors control access piece software goal charging user copy end programs require license key stored file distributed license servers start application program obtain license permission run program previous students successfully dyninst bypass obtaining license server goal project attempt operation programs store licenses locally discuss list programs random testing programs join distinguished line projects past random input test reliability application programs unix techniques effective finding bugs widely cited work cult goal project study applications platforms repeat study command-line x-window applications interesting compare free open unix systems linux bsdi freebsd testing macos possibility product project provide update tool set developers bug reports software vendors bug fixes bugs successful project area lead conference visualizing file system layout andrea arpaci-dusseau file system viewed large complex data structure consisting superblock i-nodes indirect blocks data blocks project investigate layout local file system visualized involve understanding file system data structures linux windows traversing structures reading raw disk device determining information interesting innovating display complex information simply show blocks disk dedicated i-nodes data blocks unallocated layout individual files disk amount fragmentation age block addition present quantitative information things grouping fragmentation windows unix file system performance ntfs unix ffs designed provide good performance file system optimized good things goal project side-by-side comparison basic on-disk structures performance strategies memory caching data meta-data pre-fetching replication generate workloads tests features mobility gps idea project combine gps navigation card mobile computer laptop pda pick locale building campus develop obtain map coordinates locale provide smart display location nearby resources examples smart information person office nature room bathroom conference room administrative office make system smarter attempting obtain vertical information floor obtained inferring base station receiving needed obtain gps receiver card provide mobile device project proposal project descriptions listed intentionally expand refine develop project groups choose topic significantly emphases project proposal describe goals methods implementation outline evaluation criteria resources needed describe basic problem addressing provide detailed description approach problem description detail paragraphs provide outline features project include implementation plan evaluation plan project proposals typically double-spaced pages referee report referee paper group providing sample referee report form similar recent conference providing sample referee reports give idea real report general referee report starts summary main idea paper statement quality review main technical ideas addition marked-up copy paper typos related errors summary typos related errors authors nbsp modified mon nov cst bart 
class schedule wisconsin-madison computer sciences department fall barton miller tentative class schedule schedule reading schedule papers list announced class class mailing list schedule subject change note class scheduled -minute lectures week expected week meet average week extra time project work weeks semester watch schedule carefully make schedule coming week schedule refers numbers reading list monday wednesday friday week nbsp nbsp sep intro overview week sep labor day sep paper assignment sep week sep sep sep week sep sep paper due sep week sep sep sep week oct oct oct week oct project list oct oct week oct oct oct spring break week oct project proposal due tuesday oct oct week oct nov nov week nov nov nov week nov nov nov project midway interviews week nov nov nov thanksgiving week nov nov dec week dec pizza reading list feedback dec dec paper draft due week dec dec referee reports due dec finals week dec monday project presentation session project poster session am-noon room computer sciences dec tuesday final paper due modified sun dec cst 
post mortem analysis experience section present results paramap study performance fortran applications study examines toy illustrates performance problem found fortran applications study examines real chemical engineering code demonstrates performance information attributed arrays information attributed code statements case compiled application maximum compiler optimizations linked paramap instrumentation executed node cmstudied performance information multiple levels abstraction finally changed source code reduce runtime studies show simple tool based model organize performance information complex layered language system identify important performance problems greatly improve runtime performance simple paramap analyze program shown figure simple exhibits significant performance problem common programs written novice fortran programmers row figure shows execution time initial version program compared runtime serial version program row figure measured single processor sun sparc initial program appears slow version execution time initial parallel uninstrumented min sec initial parallel instrumented min sec serial uninstrumented sec final parallel uninstrumented sec figure execution times small analyze program paramap determine noun costs cmf level tool told array responsible majority total cpu time figure shows cost breakdown array assignments involving array cost breakdown maps noun verb sentence case sentence main assignment assignment operations involving array main lower levels summarizes lower level costs type mapping purpose lower level activity case assignments involving map small amounts explicit implicit computation large amount implicit communication explicit computation costs include time spent computing values assignments involving implicit computation costs include time spent runtime system managing memory figure costs assignments involving costs summed processor nodes map array investigate implicit communications created context sentence main assignment moved node level node level found million node broadcasts mapped sentence main assignment knew million elements compute investigated broadcasts caused transfers asked tool refine context upper left quadrant assignments elements upper left quadrant line figure tool told shrink subregion left half subregion runtime system distributed row axis processors found million broadcasts mapped left half broadcasts mapped left half million elements compute concluded broadcasts send elements control processor computation figure shows time histogram broadcasts mapped selected subregion display shows broadcasting subregion array occurred entire execution program improved program inserting array alignment pragma pragma cmf align instructs compiler map alongside processor nodes result decrease program runtime shown fourth row figure alignment pragma computations line occur parallel transfers control processor figure time histogram broadcasts map array sub-region events nodes map selected sub-region shown dual reciprocity boundary element method application parallel implementation dual reciprocity boundary element method drbem non-linear solution technique heat transfer vibration analysis applications drbem non-linearities solved boundary integral problems boundary element methods relies green theorem reduce two-dimensional area problem onedimensional line integral line-integral solved discretizing solving sets linear equations full drbem application comprised lines code spread source files application reads initial conditions file sets system linear equations solves equations series time steps finally writes results file ran program problem involving boundary elements interior elements time steps runtime initial parallel version shown row figure version time percent improvement initial min sec initial instrumented min sec cmssl gaussian elimination uninstrumented min sec eliminate unused arrays uninstrumented min sec cmssl solver uninstrumented min sec cmssl inverse uninstrumented min sec uninstrumented min sec figure runtimes parallel drbem rows show results implementing improvement separately row shows result applying improvements began analysis drbem application examining cmf level profiles verbs statement execution assignment figures verb statement execution maps execution code blocks generated compiler implement fortran statements verb assignment maps execution code blocks implicit runtime system activities allocation shifting rotating arrays profile lists nouns participated sentences involving verb nouns sorted cumulative costs measured sentences cumulative costs statement executions include explicit node-level computations map execution mapping implicit costs statement executions supported cumulative costs array assignments include costs implicit explicit lower level activities map assignment figure statement execution profile drbem line numbers listed angle brackets represent groups statements merged compiler optimization execution assignment profiles illustrate examine types nouns localize performance problems statement execution profile figure shows statements file decomp fcm responsible explicit node-level computation application examining code decomp fcm found top array shown assignment profile main figure accessed statement listed execution profile decided concentrate array main accessed concentrate code line code decomp fcm processed main implementation gaussian elimination factorization cost breakdown main shown similar figure showed twothirds node-level time mapped array spent point-to-point communication routines concluded gaussian elimination implementation caused point-to-point communications node-level computations decided gaussian elimination understood method implemented linear algebra libraries simply replace entire subroutine call library routine replaced routine call figure array assignment profile drbem table sorts fortran arrays cumulative explicit implicit costs vendor provided scientific software library cmssl gaussian elimination routine improvement reduced runtime application shown row figure figure shows large explicit computation costs lines file inverse fcm examined listed lines found array main listed assignment profile accessed lines important study processing main examine line displayed cost breakdown table figure found costs assignments involving main due point-to-point communication elements main spreading subsections main processors examined main lines identified operations point-to-point communications spreading array elements code lines part routine computed inverse matrix main routine advantage symmetries matrix found employing cmssl routine general matrix inversion improved execution time entire application shown sixth row figure array assignment profiles locating unused arrays unused arrays arrays programmer allocated runtime system program paramap cmf-level nouns recorded assignment sentences array assignment profile lists unused arrays bottom showing cumulative cost figure cost breakdown assignment operations involving main table shows low-level operations involving array implicit caused communication figure time histogram cpu time entire initial parallel drbem application display shows primary runtime contributors point-to-point communications map arrays main main sequential execution routine solve drbem application found unused arrays improved program eliminating code runtime savings shown fourth row figure minimal memory savings amounted megabytes total final major performance problem involved sequential subroutine execution time subroutine execution time measured process time control processor measured subroutine application displayed profile subroutine execution found minutes spent subroutine solve subroutine implemented solution phase application apparently parallelized decided vendor provided cmssl parallel linear system solver improve runtime performance inserted cmssl solver place solve change reduced runtime program shown fourth row figure figure illustrates key aspects behavior drbem application time figure presents process time spent performing point-to-point communications 
sample referee report form sigmetrics symposium parallel distributed tools manuscript review form copy part review form author paper title paper authors referee rate paper excellent unacceptable originality significance technical strength written presentation relevance symposium recommendation rate confident feel assessment due factors closeness topic area expertise level detail evaluated paper confidence review topic pretty well-versed topic topic understand read understands topic totally clueless reviewer give detailed comments explain ratings authors improve paper modified tue dec cst 
current scores wisconsin-madison computer sciences department fall barton miller final scores programs quizzes scores listed digits student number grades class gpa digits total stu grade avg min max modified sat dec cst bart 
work-in-progress presentations work-in-progress presentations return home page monday april linux process control filesystem jonathon giffin george kola efficient mpi collective communication file distribution local-area clusters michael brim joel sommers analysis distributed program communications nathan burnett winfred byrd comminst instrumenting process communication sumit kumar rajesh rajamani abhishek saxena implementation breakpoints mpi clark kirkman james nugent scoppia simple configurable powerful process inspection alteration dorian arnold william benton dynamic instrumentation process policing det buaklee greg smethells greg tracy modified thu mar cst bart 
final project demo schedule final project demo schedule return home page friday reliable computing worm paradigm sanjeev kulkarni sambavi muthukrishnan tuesday building broadcast tree efficient communication parallel systems sue hazlett hillary paul worm wars rob iverson tevfik kosar jerome heckenkamp jason xie middleware active reduction operations distributed systems gokul nadathur nitin bahadur fuzz testing mpi drew bernat jaime frey hao wang attacking security issues condor antony sargent justin forrester trojan condor scheduler security study florentina popovici alex mirgorodskii modified tue cdt bart 
writing suggestions upperalpha list-style-type upper-alpha loweralpha list-style-type lower-alpha lowerroman list-style-type lower-roman upperroman list-style-type upper-roman disc list-style-type disc circle list-style-type circle square list-style-type square wisconsin-madison computer sciences department barton miller writing suggestions guidelines writing papers class abstracts abstract complete summary paper summarize problem approaches solutions major results conclusions abstracts separate stand completely avoid phrases start paper describes avoid platitudes start abstract introductory section sections grand generalizations fluff start motivating problem carefully delineates problem solve avoid phrases write tested read write fork system calls write systems tested included read write fork label tables graphs guidelines tables graphs units labeled labeled heading table column legend line graph text table graph logarithmic scales helpful graph wide range data interesting characteristics data small large values plotting intrinsically exponential behavior time log scales make data hard understand obscure magnitude relationships data values log scales sparingly log-log graphs avoided line decimal points table column column numbers line implied decimal point justify numbers center column numbers consistent number decimal places present make number makes sense present precision warranted refer table figure section considered proper noun proper nouns capitalized results figure show intelligence relates shoe size results trained-monkey experiments section contractions don contractions informal properly spoken speech quotes quotes quote source book person quotes appeal fuzzy meaning word avoid sentence technique optimal understand properly introduces dependent clause generally comma introduces independent clause passive voice passive voice avoided avoid passive voice passive voice direct dilute impact prose sparingly create interesting contrast paragraph male pronouns male pronouns referring specific male person refer single person unspecified gender choices grammatically correct gender-neutral singular pronoun phrase noun pronoun user stodgy british-stype dislike choice acceptable avoid word rarely adds additional meaning sentence avoid unqualified word cases grammatically correct noun phrase cases reader make extra effort figure refers good idea number avoid phrase number paper contained number awkwardly written sentences phrase vague quantity magnitude intended subtitute words couple words precise give reader intuition unix-style function names unix documentation written typesetting common function names written parentheses fork old-style printers single fixed-width fonts parentheses distinguish function names todays modern printers word processors constrained fixed-width fonts write fork fork style distracting avoids appearance parentheses run precision accuracy precision describes significant digits present accuracy describes close correct answer digits necessarily add accuracy accuracy require digits prose avoid citations part prose style typewriters easily generate superscripts traditionally footnotes social sciences footnotes end paper chapter book typography properly superscript improperly sentences authors blathering idiots authors blathering idiots general informative reader avoid structures forces reader idea nice rewrite sentence recent study moe larry curly authors showed blathering idiots absolutely cite directly ieee journal style situation shown authors blathering idiots modified thu mar cst bart 
final project poster session final project poster session return home page refreshments served monday computer sciences nfs failure policy fingerprinting giri ravipati swetha krishnan abstract users place lot data store file systems makes reliability availability important characteristics file system characteristics difficult guarantee distributed file systems sources failure network work aims find nfs failure detection recovery mechanisms inserting faults points protocol stack kinds failures nfs packet drops packet corruption summarize client server react failures find interesting cases inappropriate errors conveyed application lack sanity checking leading kernel faults inconsistencies error handling fuzz testing biased thread scheduling andy phelps derek hower abstract parallel code increasingly common notoriously difficult write threaded applications rely mutexes control access shared data programmers easily overlook race conditions leads subtle bugs common released applications effective testing accomplished thread execution randomized allowing rare interleavings execution common authors written tool peach modifying execution programs pthreads library peach random fuzz testing approach delaying execution threads unpredictably peach authors attempted success exercise latent bugs common applications virtual machine-based attack self-checksumming code nathan rosenblum greg cooksey abstract present method defeating tamper-resistant programs unmodified commodity operating systems technique based application virtual machine technology interpose virtual harvard memory architecture operating system physical memory hardware machine split view data code presented target application defeating tamper-resistance self-checksumming code performance evaluation technique significantly costly full emulation program memory accesses dillodie removing armadillo tamper-protection kevin roundy matthew renzelmann abstract viruses spyware forms malicious software routinely employ tamper protection effort subvert anti-virus products evade detection developed techniques freely software automatically remove tamper protection applied specific commercial anti-tamper product silicon realms armadillo process recover windows executable functionally identical original tamper protection applied tamper-protection-free executables ideal inclusion anti-virus databases assuming anti-virus software remove tamper protection potential viruses automatically parallel online keyword search mrnet mark cowlishaw ting chen abstract describe study parallel online keyword search algorithm implemented tree-based overlay network tbon mrnet multicast reduction network library study throughput turnaround time algorithm small medium scale find optimum tree topology maximizing throughput show moderate scale nodes root single-level tree overloaded multiple-level topologies required optimum throughput relate experience algorithm tree-based implementations similar data-intensive algorithms implemented mapreduce paradigm study security vulnerabilities web haris volos hidayat teonadi abstract web technologies greatly extend capabilities web applications shift security cost web complex architecture lack understanding software developers security implications model enable classes vulnerabilities study focuses vulnerabilitities javascript hijacking prototype hijacking study vulnerabilities find real world web applications exposed types vulnerabilities twitter social networking service roundcube webmail modified fri cdt bart 
paper reading list wisconsin-madison computer sciences department fall barton miller tentative reading list note due copyright limitations download papers campus computers topics adding papers memory management michael schroeder jerome saltzer hardware architecture implementing protection rings communications acm march peter denning working set model program behavior communications acm richard carr john hennessy wsclock simple effective algorithm virtual memory management symposium operating systems principles sosp pacific grove california december synchronization communication hoare communicating sequential processes communications acm august hoare monitors operating system structuring concept communications acm october butler lampson david redell experiences processes monitors mesa communications acm february hugh lauer roger needham duality operating system structures operating systems review april kernels david redell yogen dalal thomas horsley hugh lauer william lynch paul mcjones hal murray stephen purcell pilot operating system personal computer communications acm february barton miller david presotto michael powell demos development distributed operating system software-practice experience april forest baskett john howard john montague task communication demos symposium operating systems principles sosp november michael young avadis tevanian richard rashid david golub jeffrey eppinger jonathan chew william bolosky david black robert baron duality memory communication implementation multiprocessor operating system symposium operating systems principles sosp austin texas november brian marsh michael scott thomas leblanc evangelos markatos first-class user-level threads symposium operating systems principles sosp asilomar california october waldspurger memory resource management vmware esx server symposium operating system design implementation boston december nelson lim hutchins fast transparent migration virtual machines usenix annual technical conference anaheim california april optional bugnion devine rosenblum disco running commodity operating systems scalable multiprocessors symposium operating system principles saint-malo france october optional sugerman venkitachalam lim virtualizing devices vmware workstation host virtual machine monitor usenix annual technical conference boston june andrea arpaci-dusseau remzi arpaci-dusseau information control gray-box systems acm symposium operating systems principles sosp banff canada october adaptable extensible systems henry massalin carlton theads input output synthesis kernel symposium operating systems principles sosp litchfield park arizona december dawson engler frans kaashoek james toole exokernel operating system architecture application-level resource management acm symposium operating systems principles sosp copper mountain resort colorado december brian bershad stefan savage przemyslaw pardyak emin gun sirer marc fiuczynski david becker craig chambers susan eggers extensibility safety performance spin operating system symposium operating systems principles copper mountain resort colorado december ariel tamches barton miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating design implementation osdi orleans february file systems mary baker john hartman michael kupfer ken shirriff john ousterhout measurements distributed file system symposium operating system principles pacific grove october mckusick joy leffler fabry fast file system unix acm trans computer systems august mendel rosenblum john ousterhout design implementation log-structured file system symposium operating systems principles asilomar california october vivek pai peter drushel willy zwaenepoel io-lite unified buffering caching system symposium operating design implementation osdi orleans february bruce walker gerald popek robert english charles kline greg thiel locus distributed operating system symposium operating systems principles sosp bretton woods hampshire november satyanarayanan john howard david nichols robert sidebotham alfred spector michael west itc distributed file system principles design symposium operating systems principles sosp orcas island washington december james kistler satyanarayanan disconnected operation coda file system symposium operating systems principles asilomar california october werner vogels file system usage windows symposium operating systems principles december kawah island resort south carolina short paper power-law functions found adamic zipf power-laws pareto ranking tutorial information dynamics lab labs october optional david patterson garth gibson randy katz case redundant array inexpensive disks raid acm sigmod international conference management data protection security anita jones william wulf design secure systems software practice experience frederick gramp robert morris unix operating system security bell laboratories technical journal october gerald popek charles kline encryption secure computer networks computing surveys december steiner neuman schiller kerberos authentication service open network systems usenix dallas february ross anderson markus kuhn tamper resistance cautionary note usenix workshop electronic commerce oakland california november dan wallach dirk balfanz drew dean edward felten extensible security architectures java symposium operating system principles saint-malo france october java security paper structured hard follow replaced generally similar topic verified code certifying compiler paper necula lee distributed systems andrew birrell roy levin roger needham michael schroeder grapevine exercise distributed computing communications acm april andrew birrell bruce jay nelson implementing remote procedure calls acm transactions computer systems february rob pike david presotto sean dorward bob flandrena ken thompson howard trickey phil winterbottom plan bell labs computer systems summer experience systems reports hugh lauer observations development operating system symposium operating systems principles sosp pacific grove california december reliability recovery jacques-louis lions lennart lebeck jean-luc fauquembergue gilles kahn wolfgang kubbat stefan levedag leonardo mazzini didier merle thomson colin halloran ariane flight failure report inquiry board european space agency report paris july http esrin esa htdocs tidc press press ariane rep html http wisc bart ariane rep html technical writing donald knuth notes technical writing unpublished article desiree thalley write wisconsin state journal sunday november roy levin david redell evaluation sosp submissions operating systems review july modified wed nov cst bart 
presentation guidelines wisconsin-madison computer sciences department spring bart miller presentation guidelines talk guidelines notes guide preparing presentations read paper times understand details un-fun parts question answer paper familiar check decide important paper details important ideas talk organized important ideas outline talk top-down design result fill time important ideas fill details explain ideas don outline talk ramble punctuate talk hour talk major sections sections introduced start talk clear start section finish section audience concentrate entire hour sections give mental resting places clear break transition sections writing log works long pause talk recovery crash section structured mini-talk rule told isn boring hear thing times lay ground work summarize important ideas talks summary slide main ideas end list open questions paper class expected suggest note responsibility paper read papers relate talking works links demos capability-like structures ports mach file descriptors unix support contrast demos paper modify kernel implement migration condor user space talk plan talk weeks talk present main ideas outline talk meet show sketch talk outline slide meet show slides requirement suggestion speaking front group difficult time nervous start relax talk progresses points presentations color slides make color purpose highlight part figure group things fonts large people read back room don cram slides full information put text present main points guide talk don sparse pictures good picture explain idea quickly spoken written words humor jokes talk good idea comfortable don distract talk audience time screen projector practice talk comfortable time time questions end talks minutes assume minutes slide average slides minute talk fewer boring people slide people time read slides slides talk synch present ideas putting slide worried forget slide write notes paper slide write big letters easy read talks contribution class important thing make good effort skill addition comments marv solomon underscore couple points bart guidelines note guidelines equally valid oral exams slides lot text put paragraph words slide choose unsatisfactory choices read slide audience stand dummy audience reads talk slide audience wishing shut read alternative common worst pictures tables charts outlines keywords slide point read pacing important make audience outline nature problem show solutions turns solution depth finally summarize mention remaining open problems remind periodically progressing solutions time detail good reasons approach bogged nit-picking questions suppose list definitions prove theorem definitions boring searching interest definitions questions details set bit-vector involved long discussion asker bored join debate worst case spend hour talking definitions theorem remember charge pacing cover long lots ways shutting heckler details don matter important point find answer slide discuss talk questions listen question carefully figure asker beware reading question repeat definition don jump conclusion sees subtle flaw argument launch detailed defense thesis mumbling daydreaming simply repeat definition hand questioners careful phrasing questions wrong technical term question figure answer question meant questions reveal fundamental misunderstanding person completely lost safe bet audience seconds back track presentation suggestions mark hill page suggestions worth reviewing prepare talk return home page modified wed feb cst bart 
sample referee reports paper title performance visualization tools case study paper authors xxxxxxxxxxxxxxxxx rate paper excellent unacceptable originality significance technical strength written presentation relevance symposium recommendation rate confident feel assessment due factors closeness topic area expertise level detail evaluated paper confidence review topic reviewer give detailed comments explain ratings authors improve paper comments author paper argues case study visualization effective performance tuning parallel program nice paper included conference major themes usefulness visualiations patterns things spacing communication events parallel fan-out communication timings uniformity durations presented work human ability work patterns suggestions easy difficult explicitly mention point early paper reason study visualization worked exposed patterns triggered human recognition problem draw conclusion wildy speculate type visualizations attempt separate pretty visualizations issue kill paper program improve result study convince visualizations provide information information specific comments page authors argue lack concrete convincing examples usefulness performance visualizations literature significant impediments widespread acceptable tools user tool-developer communities self-serving tool users don read literature ease ease installation support manuals availability problem paper worthwhile make visualization claims concrete bunch users published figure time label top bottom figure phrase order appears lot paper cases delete end tighter direct prose section work looses focus rest paper paper visualizations effectiveness section alternate strategies tuning application paragraph discussion simulation evaluate alternatives graph tone rest paper paragraph sec back point trim stay strong point presentation sec isn good rest paper prose complicated figures difficult understand fig work units work x-axis time measuring average time send message explicitly figs legends describe solid dashed dotted lines figures things padding pointing lines pretty confusing follow curves graph make line style solid dashed dotted dot-dash dot-dot-dash figure description syncrhonized communication non-blocking optimal padding paragraph simulation study change real spto run fig present version execution compare quantatively general time-line views time labeled x-axis understand magnitude issue context identifying reviewer happy discuss paper accepted revision paper title performance visualization tuning carnival paper authors xxxxxxxxxxxxxxxxxxxxxxxx rate paper excellent unacceptable originality significance technical strength written presentation relevance symposium recommendation rate confident feel assessment due factors closeness topic area expertise level detail evaluated paper confidence review topic reviewer give detailed comments explain ratings authors improve paper comments author paper describes technique identifying source waiting parallel program ideas paper didn understand explanations basic weakness paper don show information provided carnival improve application program nice walk reader steps identifying problem problem appears fix re-evaluation program don sources lack understanding explanation steps paths sounds steps basic blocks bottom avoid intro ing term basic block path sequence set depending steps steps identified things processor sounds paths meander processors reading prose sounds path processor understand paths execution sequence basic blocks delinated synchronization operations case simple words case un-confuse global synchronization barrier clear compute stuff random collections pairwise synchronization operations locks semaphores messages don understand compute paths lots non-global synchronization combinatorial growth number paths identify paths figure avoid problem figure accompanying prose gave problems line bottom lines talk source code execution time profiles nested scope left exec profile missing totally lost issues paper title half paper talks waiting time analysis half talks visualization tuning application representative title waiting time analysis performance visualization carnival mention don handle memory delays delays due multiprogromming respect memory delays things hardware counters incorporate information combine similar steps don pay attention execution length steps assuming similar easy construct cases isn true worth checking times combining modified tue feb cst 
paper reading list paper reading list return home page numbered papers required reading class papers showed indented numbered paper read presenter incorporated day presentation background saltzer reed clark end-to-end arguments system design acm trans computer systems november file systems nelson welch ousterhout caching sprite network file system acm trans computer systems february language issues carriero gelernter net linda kernel acm trans computer systems jul levy hutchinson black fine-grained mobility emerald system acm trans computer systems february distributed shared memory scales gharachorloo transparent efficient software distributed shared memory symposium operating systems principles saint malo france october stets dwarkadas hardavellas hunt kontothanassis parthasarathy scott cashmerel software coherent shared memory clustered remote-write network symposium operating systems principles saint malo france october process migration load sharing powell miller process migration demos symposium operating systems principles bretton woods october theimer lantz cheriton preemptable remote execution facility v-system symposium operating systems principles orcas island december zayas attacking process migration bottleneck symposium operating systems principles austin november litzkow tannenbaum basney livny checkpoint migration unix processes condor distributed processing system computer sciences technical report wisconsin-madison april grid distributed computing gropp lusk goals guiding design pvm mpi ieee international conference cluster computing chicago september thain tannenbaum livny distributed computing practice condor experience concurrency computation practice experience february-april thain basney son livny kangaroo approach data movement grid tenth ieee symposium high performance distributed computing hpdc san francisco california august foster globus toolkit version software service-oriented systems ifip international conference network parallel computing springer-verlag lncs foster kesselman tuecke anatomy grid enabling scalable virtual organizations international journal supercomputer applications peterson anderson culler roscoe blueprint introducing disruptive technology internet workshop hot topics networking hotnets-i october bavier bowman chun culler karlin muir peterson roscoe spalink wawrzoniak operating system support planetary-scale network services symposium networked systems design implementation nsdi march time order agreement lamport time clocks ordering events distributed system communications acm july fidge partial orders parallel debugging sigplan sigops workshop parallel distributed debugging madison wisconsin appears sigplan notices january chandy lamport distributed snapshots determining global states distributed systems acm trans computer systems february miller j-d choi breakpoints halting distributed programs int conf distributed computing systems san jose june goldberg gopal lowry strom restoring consistent global states distributed computations acm onr workshop parallel distributed debugging santa cruz tomlinson garg detecting relational global predicates distributed systems acm onr workshop parallel distributed debugging padd san diego december lamport shostak pease byzantine generals problem acm transactions programming languages systems july program replay leblanc mellor-crummey debugging passing parallel programs instant replay ieee transactions computers april netzer miller optimal tracing replay debugging message-passing parallel programs supercomputing minneapolis november november choi srinivasa deterministic replay java multithreaded applications sigmetrics symposium parallel distributed tools welches august remote procedure calls schroeder burrows performance firefly rpc acm trans computer systems february bershad anderson lazowska lightweight remote procedure call acm trans computer systems february replication fault tolerance cooper replicated distributed programs symposium operating systems principles orcas island december birman replication fault-tolerance isis system symposium operating systems principles orcas island december birman joseph reliable communication presence failures acm transactions computer systems february authentication burrows abadi needham logic authentication symposium operating systems principles litchfield park december lampson abadi burrows wobber authentication distributed systems theory practice symposium operating systems principles pacific grove october netscape communications ssl works http definityhealth marketing ssl works html hickman ssl protocol http mia ece uic papers volans ssl html mobile computing kuenning popek automated hoarding mobile computers symposium operating systems principles saint malo france october petersen spreitzer terry theimer demers flexible update propagation weakly consistent replication symposium operating systems principles saint malo france october baker zhao cheshire stone supporting mobility mosquitonet usenix technical conference san diego january cheshire baker internet mobility acm sigcomm conference stanford august lai roussopoulos tang zhao baker experiences mobile testbed wwca march zandy miller reliable network connections acm mobicom atlanta september jensen cryptocache secure sharable file cache roaming users acm sigops european workshop kolding denmark september modified wed jan cst bart 
applications combination general historic yields results comparing subcolumns prunes seconds find bottlenecks general prunes compared seconds type prunes improvement combining types pruning directives resulted reduction time locate true bottlenecks compared directives case experiment studied effects ordering search bottlenecks priorities historical data generate priorities hypothesis focus pair outlined section expected compared historical data reduce time required find major true bottlenecks priorities reduce number potential bottlenecks tested change order candidates tested shown column table obtained reduction time locate true bottlenecks improvement modest reduction obtained pruning directives reordering search introduce possibility missing bottlenecks important advantage method pruning directives final experiment tested combination prunes priorities goal improve time reduction obtained priorities avoid possibility pruning important tests search included general pruning redundant irrelevant hierarchies include historic prunes previously false hypothesis focus pairs combined approach result retesting false nodes miss behaviors due pruning obtained reduction base case finding true bottlenecks reduction seconds seconds pruning priorities thresholds determined historical data studied behavior performance consultant varying threshold values determine potential benefit automatically setting thresholds based historic data application decomposition code previous section run nodes ibm sample application strongly dominated synchronization waiting time accounts approximately total execution time total execution time processors spent waiting function exchng function main waiting time split message tags individual processes dominated wait time significant waiting occurred processes investigated quality diagnosis checking number areas reported bottlenecks individually function main combination message tag function main full results shown table threshold setting greater bottlenecks previously determined significant reported threshold set tool reported close full set bottlenecks default paradyn setting contrast resulted bottlenecks missed column shows instrumentation diagnose program run setting threshold shaded yields good results noticeably instrumentation setting final column shows efficiency metric determined dividing number bottlenecks found number hypothesis pairs tested efficiency decreases thresholds indication lowering threshold increases amount instrumentation improve result earlier studies found similar results ocean circulation modeling code pvm running sun sparcstations found optimal synchronization threshold starting point yielded incomplete diagnosis efficiency decreased number metric-focus pairs instrumented jumped threshold case differs found mpi application showing advantage application-specific historical performance data historical data code versions studied historical performance data situation application revised time tuning application developer repeats cycle profile-analyze-change performed series performance diagnoses versions mpi application ibm application implements iterative poisson function decomposition versions implementation presented gropp step study results previous runs performance consultant direct subsequent runs versions application version -dimensional version blocking send receive operators version non-blocking -dimensional version version performs -dimensional decomposition version runs code version nodes run nodes changed versions compute fixed number iterations stopping solution reached complete set results study contained synchronization bottleneck threshold setting total execution time number bottlenecks reported performance consultant total number hypothesis focus pairs tested efficiency bottlenecks found pair tested table bottlenecks found varying threshold values number bottlenecks reported rounded averaged values calculated repeated tests row shaded crossover point efficiency increasing number pairs tested yield significant gain results table results presented graphically figure started running performance consultant version search directives denote resulting time locate true bottlenecks seconds repeated diagnosis version time including general prune priority directives generated previous execution run showed decrease diagnosis time approximately examined version search directives extracted runs version found improvement diagnosis time original base case directives continued versions time running performance consultant figure time complete diagnosis search directives application versions group bars represents program version diagnosed colors bars source search directives table search directives extracted individual prior run run performance consultant resulting search history graph program resource hierarchies generate search directives subsequent runs added functionality performance consultant map focus names found directives names valid current environment section detailed discussion mapping tests mapping implemented set directives form map resourcename resourcename user input file starting paradyn applied mappings list extracted search directives read directives performance consultant increased efficiency applied pruning directives resulting list search directives read performance consultant tests section mapped pair machine resources search directives generated run meaningfully refer machine resources discovered subsequent run mapped functions modules source search directives application ersion table time seconds complete diagnosis search directives application versions times reported median values runs standard deviations ranged seconds row data application version column data source search directives performance consultant cell found row column time diagnose directives previous run time relative base version column shown parentheses code versions names changed code versions figure shows resource hierarchies combined structural difference operator versions application versions resource tagged execution identifier resource found version version resources unique execution candidates mapping module function main named oned version onednb version mapped resources code oned code onednb search directives extracted runs diagnosing runs full set mappings shown resource hierarchies mapping functionality restricted one-to-one mappings mapped machine names node runs result set search directives including total mappings map code exchng code nbexchng map code exchng exchng code nbexchng nbexchng map code oned code onednb map code sweep code nbsweep map code sweep sweep code nbsweep nbsweep figure mappings versions left show execution map versions poisson decomposition application code hierarchy expanded resource tagged execution identifier resources unique version labeled unique version labeled common labeled map unique nodes refer code modified versions including change mapping directives shown machine nodes bottom row table longer times required reach diagnosis due complete set search directives node machine case tested adding historical knowledge performance consultant greatly improved ability quickly diagnose performance bottlenecks diagnosis time reduced minimum executions historical knowledge table row represents version application diagnosed column represents source extracted search directives column time reach diagnosis search directives subsequent columns time reach diagnosis search directives sources dedicated machine time low variability run time repeated executions version completing test runs analyzed performance consultant behavior determine affected search directives added examined effects search directives base run diagnose run priority setting total high low total table similarity extracted priorities code versions show number priority directives extracted base runs row includes directives assign high priority includes directives assign low priority bottom column shows combined total column represents source priority directives combination total high priority directives unique version common versions hypothesis focus pairs tested true resulting search directives set priority high total hypothesis focus pairs tested true pairs tested true included search 
elements arrays main main serial time spent subroutine solve figure shows implicit communications serial computations degraded performance application significant amount parallel processing resources machine minutes solve executed control processor processor nodes remained idle final line figure presents total savings achieved incorporating improvements listed related work performance tools measure common denominator events procedure calls basic blocks runtime library events synchronizations events independent programming model tools measure programs written programming languages information low-level events relevant understood programmer written program high-level parallel programming language performance tools designed specific languages programming environments language specific tools knowledge programming model reduce measurement costs give detailed performance feedback specific language constructs data types language specific tools generally provide view program performance language level view information implicit lower level activity fully understand performance complex application hidden omitted user allowed separate language level lower levels allowed lower level views performance hybrid approach collect low-level events map higher levels abstraction analysis user describes low-level events combined identified high-level events approach maximum flexibility handling program performance information general problem addressed existing tools mapping event streams types performance information difficult problem performance measurement programs written high-level languages bears resemblance problem debugging optimized code problem symbolic debugger present view optimized program consistent original source code hide effects optimizations reordered statements eliminated variables altered steps computation performance measurement parallel programs written high-level languages fundamentally simpler debugging optimized code performance measurement tools reconstruct instantaneous state computation symbolic debugger stop execution program instruction identify location source code provide access variables original program performance measurement tool hand generally concerned cumulative activity program elements code constructs data objects performance measurement tools identify program elements active point rarely access values variables conclusions claim simple tool based model great advantages studying performance programs written high-level parallel languages paramap answered performance questions easily answered tools displaying performance data fortran parallel arrays quickly located primary performance problems examining runtime system processor activities maintaining high-level arrays subsections arrays evaluated low-level results array operations specific examples type analysis include localization broadcasts portion array section attribution point-to-point messages important arrays section paramap finds problems found simple profilers sequential processing bottlenecks subroutines employing mapping functions providing access array information providing time plots performance data paramap programmers traditional performance measurement analysis techniques study difficult problems found providing performance information fundamental constructs language parallel arrays fortran good step understanding application performance located array high performance costs paramap drop runtime system node level evaluate object impact system determine cumulative costs due programmer explicit requests computation programmer implicitly unknowingly caused extra runtime activity type analysis represents departure high-level language tools provide information exclusively language level intend address important performance questions paramap answer wanted cross performance information arrays performance information statements arrays assigned fortran statements present instrumentation system cross-product information expensive gather employ dynamic instrumentation system selectively insert measurement probes measure arbitrary noun verb combinations measuring combinations times high-level parallel language systems intricate sorting performance information nouns verbs levels abstraction arduous task simple applications employ automated search techniques assist evaluation real applications automated searching performance bottlenecks high-level parallel language applications require style mapping locating explaining performance bottlenecks programmers acknowledgements jens christoph maetzig original serial drbem code bruce davis brad richards initial fortran version aral gertner non-intrusive interactive profiling parasight proc acm sigplan ppeals bates wileden approach high-level debugging distributed systems acm sigsoft sigplan software engineering symposium high level debugging march brooks hansen simmons approach debugging optimized code acm sigplan proc programming language design implementation carriero gelernter applications experience linda proceedings international conference parallel processing july chandra gupta hennessy cool language parallel programming languages compilers parallel computing mit press cambridge coutant meloy ruscetta doc practical approach source-level debugging globally optimized code graham kessler mckusick gprof call graph execution profiler proceedings acm sigplan symposium compiler construction june hennessy symbolic debugging optimized code acm toplas july high performance fortran language specification version high performance fortran forum january hollingsworth irvin miller integration application system based metrics parallel program performance tool acm sigplan symposium principles practice parallel programming april hollingsworth miller dynamic control performance monitoring large scale parallel systems acm international conference supercomputing tokyo july hollingsworth miller cargille dynamic program instrumentation scalable performance tools submitted shpcc kale sinha projections scalable performance tool illinois dept computer science kesselman integrating performance analysis performance measurement parallel programs uclacs-tr- ucla los angelos kilpatrick schwan chaosmon application-specific monitoring display performance information parallel distributed systems debug lam rinard coarse-grain parallel programming jade proceedings acm sigplan symposium principles practice parallel programming april larus richards viswanathan large-grain object-oriented data-parallel programming language uw-madison computer sciences technical report november larus ball rewriting executable files measure program behavior computer sciences department wisconsin-madison march leblanc mellor-crummey fowler analyzing parallel program executions multiple views journal parallel distributed computing linden parallel program visualization parvis performance instrumentation visualization acm press york lord simmons improving performance cri unicos tools case study lusk butler user guide parallel programming system tech report anlargonne national laboratory argonne october umips-v manual mips computer systems sunnyvale malony mohr beckman gannon yang bodin kesavan implementing parallel runtime system scalable parallel systems proceedings supercomputing portland november mppe manual maspar computer corporation north mary avenue sunnyvale mcgraw skedzielewski allan oldehoeft glauert kirkham noyce thomas sisal streams iteration single assignment language languge manual version lawrence livermore national laboratory california davis march miller clark hollingsworth kierstead lim torzewski ipsthe generation parallel program measurement system ieee transactions parallel distributed systems april nardini brebbia approach free vibration analysis boundary elements boundary element methods engineering pvm user guide version oak ridge national laboratory oak ridge february ousterhout tcl embedable command language proceedings winter usnix conference washington january perl performance assertions proceedings symposium operating system principles december sistare allen bowker jourdenais simons title data visualization performance analysis prism programming environproject list spring wisconsin-madison computer sciences department spring barton miller project list return home page general comments projects intended give opportunity study area related distributed systems projects require test implementations measurement studies simulations modeling literature searches combination project suggestions briefly stated intended guide areas expand suggestions full project description freedom selecting area burden defining project issues listed project cover topic listed talk work reasonable project description typically work group important dates february project topics handed february project proposals due office march work-in-progress session group make presentation minutes questions work presentations powerpoint equivalent time limit enforced project paper drafts due referees drafts close final version paper missing final results performance numbers final status software drafts read member class comments improve paper project presentations projects presented class public form poster referee reports due back paper authors final project papers due projects fuzz testing threads join distinguished line class fuzz projects past random input test reliability application programs unix windows macos techniques effective finding bugs widely cited work cult notion randomness applied domains thread scheduling goal project test multi-threaded programs randomizing biasing thread scheduler randomization bias potential expose synchronization problems multi-thread programs choose threading environment pthreads understand type controls application program scheduling decisions manipulate controls test choose set programs test find bugs identify bugs tamper resistance software designers protect code run permissions detailed study works property called tamper resistance freeware commercial products developers protect software bad guys techniques software packages protect malicious code tampering goal project study tamper protection packages work process tool dyninst develop techniques bypass tamper protections scalable tree-based algorithms tree-based overlay network tbon simple powerful organizing program distributed system algorithm computed passing data tree taking inputs children performing computation inputs passing parent executed tbon surprisingly large number problems solved obvious sum min max complex graph merge equivalence class finding clock synchronization big advantage tbon computations run extreme scale relative ease paradyn project developed mrnet software high-performance tbon computation framework details mrnet software-based multicast reduction network scalable tools phoenix arizona november benchmarking mrnet distributed tool infrastructure lessons learned high-performance grid computing workshop held conjunction international parallel distributed processing symposium ipdps santa mexico april tree-based overlay networks scalable applications international workshop high-level parallel programming models supportive environments hips rhodes greece april stack trace analysis large scale applications international parallel distributed processing symposium long beach california march software construct tbon computations relative ease goal project identify computations tree-like structure implement mrnet benchmark performance local linux clusters careless delegation trust run java aplet browser performing computation behalf server advantage putting computation aplet reduces number times web client contact wait server computation checking fields form make reasonable server re-check values form improperly delegating trust host control lack checking malicious client server process values make server perform unintended tasks situation user embed sql queries directly text field goal project crawl web java aplets study aplet checking aplets found verify checking reproduced server identify server software bring local copy experimentation experiment live production server linux pedigree vendor proprietary incompatible version unix operating system sunos solaris ultrix unicos hp-ux aix variants irix sinix dynix balkanization unix world frustrated software developers helped standard windows system dominate recent years appeared dominant quasi-standard version unix linux standardization compete windows equal footing software developer knew ported software run linux run distributions linux linux distributors red hat tao ubuntu suse adding code distinguish distribution cases additional services top linux cases changing kernel interface software built linked incompatibilities balkanize linux world goal project study basic linux kernel runtime libraries basic utilities identify ways common distributions vary results interesting qualitatively kinds things change areas quantitatively code project description prepare pages description project expanded description project long convince reasonable achievable project trivial large revise description acceptable project description describe problem addressing working project steps results expect expect produce resources schedule project project report handout present information form content project report handout couple weeks reports pages referee report referee paper group providing sample referee report form similar past conference providing sample referee reports give idea real report general referee report starts summary main idea paper statement quality review main technical ideas addition marked-up copy paper typos related errors summary typos related errors authors nbsp modified wed cdt bart 
ment programming environments parallel computing north-holland snodgrass relational approach monitoring complex systems vol fortran manual thinking machines corporation cambridge january cmssl fortran cmedition vols thinking machines corporation cambridge january zellweger interactive high-level debugger control-flow optimized programs acm sigplan notices march 
fuzz testing results fuzz basic test results note page construction tables entries incomplete accurate list systems tested sun microsystems sun sunos sparcstation sunos hewlett packard bsd nfs system hp-ux ibm aix aix sun microsystems sparcstation solaris silicon graphics indy irix dec decstation ultrix rev colorstation nextstep gnu sunos nextstep linux cyrix slackware result basic tests utility sunos hp-ux aix solaris irix ultrix gnu linux adb tested crash hung 
fuzz testing application reliability fuzz testing application reliability page construction fuzz testing simple technique feeding random input applications random testing time-honored technique approach characteristics makes approaches input random model program behavior application type system description called black box testing command-line studies random input simply random ascii character streams x-window study windows study mac study random input included cases valid keyboard mouse events reliability criteria simple application crashes hangs considerd fail test passes note application respond manner input quietly exit result characteristics fuzz testing automated high degree results compared applications operating systems vendors encourage feedback comments links fuzz papers software mac fuzz report postscript pdf html miller cooksey moore empirical study robustness macos applications random testing international workshop random testing portland maine july windows fuzz report postscript compressed postscript gzip postscript pdf html forrester miller empirical study robustness windows applications random testing usenix windows systems symposium seattle august appears german translation empirische studie zur stabilit von nt-anwendungen september fuzz revisited report postscript compressed postscript gzip postscript pdf miller koski lee maganty murthy natarajan steidl fuzz revisited re-examination reliability unix utilities services computer sciences technical report wisconsin-madison april appears german translation empirische studie zur zuverlasskeit von unix-utilities nichts dazu gerlernt september original fuzz report postscript compressed postscript gzip postscript pdf miller fredriksen empirical study reliability unix utilities communications acm december appears german translation fatale fehlertractigkeit eine empirische studie zur zuverlassigkeit von unix-utilities march fuzz software ftp site slides fuzz-revisited talk postscript pdf summary basic test results reported fuzz tools testing systems recent testing systems tested send glad provide link report modified fri jun cdt 
venezuela workshop high performance computing figueira nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento carlos figueira universidad simon bolivar suma scientific metacomputer abstract development metacomputing system execution java bytecode additional support scientific computing development addressed talk goal extend java virtual machine model providing access distributed high performance resources execution native scientific functions suma executes kinds code sequential java bytecode parallel java bytecode communicating mpijava suma native code includes standard mathematical libraries lapack plapack modified fri nov cst bart 
venezuela workshop high performance computing brown nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento david padua illinois urbana-champaign challenges compiling scientific computing abstract introduction fortran scientific computing driving force compiling technology compiler optimization techniques strength reduction developed improve performance loops numerical codes dependence analysis originally developed detect parallelism numerical codes number strategies developed compile numerical codes distributed-memory multiprocessors progress computer technology fifty years unfulfilled dreams automatic generation programs mathematical specifications powerful packages mathematica capable deriving closed form results numerical answers require programming complex simple problems dream automatic restructuring programs parallel execution locality enhancement process developing effective parallel codes improving locality laborious programmers powerful tools ease burden postulated important goal development techniques facilitate code reuse simple library routines complete applications combined complex numerical simulations nature perspectives success important directions discussed modified fri nov cst bart 
venezuela workshop high performance computing hollingsworth nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento jeffrey hollingsworth maryland runtime program evolution abstract describe post-compiler program manipulation called dyninstapi class library machine independent program instrumentation application execution describe safely modify running programs present api machine independence describe system supports type information program modification potential off-line binary editor addition describe tcl-based command line tool developed speed creation simple tools api half talk present overview active harmony system active harmony system allowing runtime adaptation applications based observations program execution environment harmony applications written export collection options automatic runtime tuning present results database system run queries client server choice based server load modified tue nov cst bart 
venezuela workshop high performance computing miller nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento barton miller wisconsin paradyn parallel performance tool project abstract paradyn system measuring performance parallel distributed program paradyn key technologies measure large-scale heterogeneous programs requiring source code modifications recompiling relinking measure already-running programs servers automate search performance bottlenecks technology dynamic instrumentation insert change remove instrumentation code running program dynamic instrumentation modify program executing moment request made performance data paradyn inserts instrumentation code deferring instrumentation decisions runtime dynamically control amount overhead dynamic instrumentation encapsulated dyninst api library api tool builder access paradyn ability patch binary programs execution api offers machine independent interface machine-level code patching paradyn technology automation searching performance bottlenecks embodied performance consultant direct dynamic instrumentation locate parts program consuming resources describe main features mechanisms paradyn including performance consultant techniques program call graph results previous runs program current release paradyn runs solaris sparc aix ibm spwindows heterogeneous combinations systems preliminary version test dec unix alpha current ports development include linux sgi irix modified tue nov cst bart 
venezuela workshop high performance computing ibanez nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento mar blanca universidad simon bolivar parallel systems case studies abstract present steps parallelize application successfully techniques illustrated study cases medical application reconstruction angiographic images n-body problem molecular dynamics short range emphasize key aspects neccessary design implement parallel application importance start suitable sequential algorithm achieve good load balance find equilibrium amount computing communications modified thu nov cst bart 
venezuela workshop high performance computing suros nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento rina sur universidad central venezuela experience construction complex environments artificial vision abstract construction complex environments artificial vision typically team effort researchers collaborating multidisciplinary project case biomedical applications researchers computer science medicine biology work communication remote non-homogeneous hardware platforms including distributed supercomputers systems incompatible data formats operating systems distributed memories non-shared resources desirable transparent form researchers ideally experimental environment users interactive interface supplies powerful tools designing customized applications combining software components components called modules implement specific operations digital image processing segmentation filtering border extraction enhancement histograms supervised data acquisition visualization tools on-line corrections problem development techniques match similar images processed tinctures identification similar objects images important problem requires mixing graphic computation methods visualization techniques data structure manipulation optimal search methods object-oriented databases graph theory modified thu nov cst bart 
venezuela workshop high performance computing dongarra nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento jack dongarra tennessee oak ridge national lab trends high performance computing enhancing performance computational grid abstract talk provide overview high performance computing obtaining performance today processors system called netsolve users access computational resources hardware software distributed network project motivated easy-to-use efficient mechanism computational resources remotely ease obtained result interfaces require programming effort user good performance ensured load-balancing policy enables netsolve computational resource efficiently netsolve offers ability computational resources network choose solve problem retry fault-tolerance return answer user modified tue feb cst bart 
venezuela workshop high performance computing brown nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento jeffrey brown los alamos national laboratory tera-scale performance asci program abstract united states department energy doe accelerated strategic computing initiative asci program mission develop computer simulation capability doe certify safety reliability nuclear stockpile absence physical testing achieve level confidence simulations high resolution high-fidelity multi-physics computer simulation applications developed require tera-scale compute platforms asci program platforms deployed research laboratories deliver tera-flop peak performance plans deploy tera-flop capability years asci simulations exploit full potential powerful machines order meet program objectives task made difficult complexity compute platforms numerical methods developed talk provide overview asci program emphasis unique asci software development run-time environment designed develop tune large-scale parallel programs provide overview software development environments asci platforms including work ultra-scale tools initiative research collaborations universities emphasis performance measurement analysis blue mountain system los alamos national laboratory lanl lanl blue mountain system cluster forty-eight one-hundred twenty-eight processor origin computers manufactured silicon graphics incorporated sgi interconnected hippi torus topology achieving high performance complex system unique challenge single process dynamics cache reuse on-box dynamic memory performance internal network numa effects across-box message passing dynamics hippi lanl developing performance tool capability code developer understand machine resource issues map application machine avoids resource contention bottlenecks talk explore issues show current results performance tool capabilities modified fri nov cst bart 
venezuela workshop high performance computing hernandez nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento emilio hernandez consejo nacional investigaciones cientificas tecnologica conicit performance characterization metacomputing systems abstract talk explore issues related performance characterization evaluation applications running metacomputing systems address selection performance parameters methods measure estimate values focus services metacomputing system offer facilitate estimation performance parameters base discussion suma metacomputing system development modified thu nov cst bart 
venezuela workshop high performance computing kesselman nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento carl kesselman information sciences institute southern california grid networking infrastructure abstract past years rise computational grids computing infrastructure focus developments means augmenting utility high-end computing resources grid play role increasing functionality networking infrastructure talk review current status grid infrastructure illustrate examples role infrastructure play development generation networking fabric modified fri nov cst bart 
venezuela workshop high performance computing leon nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento leandro universidad los andes migration user level abstract talk presents migration mechanism implemented user level significant research field convincing results fully general solution proposed part talk describe problems solved migration mechanism concentrating crucial aspects transfer update communication links existent migration techniques presented critical sake identifying problematic adopt general mechanism migration finally talk present migration technique user level migration type copy strategy selected application operating system kernel delegation selection user select transfer data migration strategy dynamically modified migration migration user level effective lazy updating communication links means technique call update communication failure technique migrant entities notify localization service locality entities communicate migrated entity fail communication request locality localization service mechanism localization communication scheme migration user level sacrifice performance traditional functionality distributed system applied systems oriented processes objects preliminary results show latency inactivity msecs ethernet network sec modified thu nov cst bart 
directives remaining set low priority intermediate level nodes tested remaining detailed refined answers tested due cost limits case search directives resulted detailed diagnosis performed directives anticipated search directives versions effective search directives version small differences cases fact surprised run performed poorly analyzed data closely account examined sets search directives extracted runs differed shown table total priority directives common sets directives unique single set remaining occurred sets total high priority directives common unique remaining common noticed differences involved detailed focuses run performance consultant found bottleneck function exchng nodes failed refine message tag run found half node message tag combinations run tool found fewer true bottlenecks run compared found run found run examined diagnoses obtained runs bottlenecks found vary significantly runs total bottlenecks diagnosed true performance consultant runs common remaining common differences time reach diagnosis performance consultant yielded similar answers cases modifications communications primitives blocking nonblocking modifications algorithm -dimensional -dimensional decomposition bottleneck locations remained total synchronization time total execution time varied versions set resources responsible time similar investigated results multiple previous runs guide current run looked approaches combining search directives versions sets high low priority hypothesis focus pairs tested true false versions sets high priority hypothesis focus pairs tested true sets low priority hypothesis focus pairs tested false version test true resulting set directives diagnose version lists priorities result methods combination common directives additional directives unique resulting diagnosis times seconds seconds difference small conclude superiority combination method performs related similarity sets directives generated data runs similarity code platform versions discussion conclusions approach automated performance diagnosis incorporates knowledge previous runs application result performance tool learns diagnostic program run adapting search strategy obtain diagnoses quickly show performance gains obtained incorporating historical knowledge performance consultant search strategy results presented demonstrate utility approach repeated performance diagnosis similar program runs common scenario tuning parallel applications improvements achieved show approach gathering storing historical application data successfully applied problem automating performance diagnosis chapter summary directions future research dissertation summary developing efficient parallel programs challenging time consuming task advances past decade compiler tool technology tuning parallel code platform generally takes weeks months time specialists major laboratories aggressively replace machines newer models gain advantage processor speed increases situation creates opportunity tool simplify process parallel performance tuning large-scale scientific applications improvements ability tool provide meaningful focused feedback programmer tuning code result implementation leads savings machine time detailed simulation results dissertation presented approach parallel performance tools directly addresses key observations tuning process inherently repetitive involves program execution thesis scientific experiment management paradigm approach parallel performance tools incorporation data multiple program executions ability meaningfully practically navigate data approach common tasks related parallel performance porting applications tuning platform comparing versions code development investigating scalability behavior major contributions thesis program space flexible extensible representation complete multi-dimensional space program runs set mechanisms quantitatively automatically comparing program runs terms structure performance demonstration program space program comparison methods large scale parallel applications development results study incorporation historical data contained program space automated performance diagnosis demonstrated performance improvements time needed tool completely diagnose parallel application directions future research interesting research ideas emerged work dissertation discuss interesting potential avenues exploration describe ongoing work work scope dissertation progress extending research directions prototype development incorporates devise visualization tool rich variety visualizations navigating performance data includes results user interface research techniques displaying contents program space continuing research additional approaches resource mapping goal automate mapping furthest extent continuing user-specified mappings demonstrated resource mapping performed start execution study warranted extend approach cover cases resources discovered application run future work explore richer resource descriptions enable semantically meaningful mappings performed automatically prototype implementation usefully extended include performance data gathered variety monitoring predictive tools techniques developed compare actual execution predicted desired performance measure application incorporation data performance predictions performance models program space add significantly utility tool include performance tuning efforts automated scalability studies performance model validation studies addition application cross-execution studies comparison-based performance analysis compare distinct time intervals single program execution ability lookup examine compare performance results time intervals program execution direct applications environment code vary single program run range computational models dynamic environments future processes created destroyed migrated communication patterns distributed shared memory optimized data values code changed steering adjustment loop behavior change matrix distribution computation plan investigate incorporation experiment launching mechanism prototype implementation completely automated performance diagnosis involve program execution experiment launching feature found scientific experiment management systems examined technique usefully incorporated parallel performance tuning environment allowing incorporate approaches design experiments tool goals approach comparison metric describes performance changed briefly examined approaches performance distance metric euclidean distance weighted average performance result values goal quantitative measure performance differs executions weigh rank performance bottlenecks detailed study actual examples types parallel applications carried determine approaches abiteboul querying semi-structured data afrati kolaitis editors proceedings international conference database theory delphi greece abrams batongbacal ribler vazirani chitra tool dynamically characterize ensembles traces input data modeling output analysis technical report computer science department virginia polytechnic institute state june block sarukkai mehra automated performance prediction messagepassing programs proceedings supercomputing ieee computer society press box hunter hunter statistics experimenters john wiley sons york brune gehring keller monien ramme reinefeld resources services metacomputing environments parallel computing brune gehring keller reinefeld rsd resource service description schaeffer editor high performance computing systems applications hpcs annual international symposium high performance computing systems applications pages paderborn center parallel computing kluwer academic publishers censa definition electronic notebook system http censa chen markowitz overview object protocol model opm opm data management tools information systems deutsch fernandez florescu levy suciu query language xml technical report labs dietz cohen grant run ahs automatic heterogeneous supercomputing proceedings international conference parallel processing pages dongarra geist manchek sunderam integrated pvm framework supports heterogeneous network computing computers physics howlett blt toolkit harrison tcl tools reilly fahringer gerndt riley traff knowledge specification automatic performance analysis technical report esprit working group automatic performance analysis resources tools http fz-juelich november fink kohn baden flexible communication mechanisms dynamic structured applications proceedings irregular santa barbara august lawrence livermore national laboratory center applied scientific computing datafoundry data warehousing integration scientific data management http llnl gov casc datafoundry foster kesselman globus metacomputing infrastructure toolkit international journal 
venezuela workshop high performance computing nunez nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento luis universidad los andes compelling venezuelan academic community hpc services abstract present report years running national center scientific computing venezuela experience transferring technology skills hpc applications tools considered cases study computational chemistry computational engineering molecular biology future hpc envisioning user perspective academic community discussed modified fri nov cst bart 
venezuela workshop high performance computing berman nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento francine berman california san deigo achieving application performance computational grid abstract computational grids comprised distributed computational sites remote instruments data archives networks resources grids increasingly prevalent important platform high-performance computing application performance grid difficult achieve due dynamic heterogeneous performance characteristics underlying grid resources powerful paradigm achieving application performance grid adaptivity goal apples application-level scheduler project develop methodology software applying adaptivity scheduling execution grid applications apples applications demonstrate adaptivity effective powerful paradigm achieving application performance difficult environments multiple users share resources resources exhibit distinct dynamic performance characteristics computation communication data coordinated local wide-area networks talk describe methodology prototype software projects developed part apples project modified tue nov cst bart 
venezuela workshop high performance computing augustin nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento emilio agust informatica negocios tecnologia high performance computing venezuelan industry abstract present report intesa experiences high performance computing venezuelan industry emphasis oil gas review main challenge areas challenges demand hpc techniques technologies problems seismic processing interpretation reservoir modeling integral reservoir management refining process development modeling describe demands high bandwidth parallel computing high performance visualization idiosyncrasies hpc corporate environment modified mon mar cst bart 
venezuela workshop high performance computing rover nbsp nbsp venezuela workshop high performance computing seminario eeuu venezuela computaci alto rendimiento diane rover michigan state performance visualization usability reusability abstract performance visualization evaluate performance verify correctness diagnose problems gain insight structure execution behavior process creating visualizations supported visualization system deals issues creation effective displays depiction concurrent actions scalability displays presentation examines construction performance visualization systems high-performance computing hpc focus usability visualization tools users reusability visualization software developers design goals discussed limited extent past years cost-benefit tradeoff practices hpc environment remains open issue review qualities visualization systems relate usability reusability present object-oriented framework consisting low-level high-level visual objects creating displays reusable components describe software architecture markup language voml component-based development highlevel visual objects extensions architecture support paradigm called uniform resource visualization urv addresses visualization standards composing system-level views sharing visualization design knowledge modified fri nov cst bart 
supercomputer applications gehring dynamic program description basis runtime optimization technical report tr- paderborn center parallel computing paderborn germany geist mendoza myers nachtigal sachs doe electronic notebook project march status report http epm ornl gov enote status html august gerndt krumme rule-based approach automatic bottleneck detection programs shared virtual memory systems proceedings international workshop high-level programming models supportive environments hips conjunction ipps pages hawaii ieee computer society press gerndt mohr wolf pantano performance analysis cray proceedings seventh euromicro workshop parallel distributed processing ieee goldberg hennessy performance debugging shared memory multiprocessor programs mtool proceedings supercomputing pages albuquerque november gray bosworth layman pirahesh data cube relational aggregation operator generalizing group-by cross-tab sub-totals technical report msr-tr- microsoft research november grimshaw wulf legion team legion vision worldwide virtual computer communications acm january gropp lusk skjellum mpi portable parallel programming message-passing interface chapter mit press eisenhauer kraemer stasko vetter schwan falcon on-line monitoring steering large-scale parallel programs proceedings symposium frontiers massively parallel computation mclean virginia february hay xml intelligent enterprise august http iemagazine online shtml heath etheridge visualizing performance parallel programs ieee software september helm malony fickas capturing automating performance diagnosis poirot approach proceedings international parallel processing symposium pages april hollingsworth application program interface runtime code patching unpublished technical report hollingsworth buck dyninstapi programmer guide computer science department maryland college park release edition july hollingsworth keleher prediction adaptation active harmony proceedings international symposium high performance distributed computing pages chicago hollingsworth miller dynamic control performance monitoring large scale parallel systems proceedings international conference supercomputing tokyo july hondroudakis procter tuner workbench tool support tuning large fritzson editor proceedings zeusworkshop parallel programming computation pages linkoping ios press hondroudakis procter empirically derived framework classifying parallel program performance tuning problems proceedings sigmetrics symposium parallel distributed tools pages acm press august horwitz reps efficient comparison program slices acta informatica horwitz identifying semantic textual differences versions program acm sigplan notices volume proceedings acm sigplan conference programming language design implementation pages white plains york ioannidis livny conceptual schemas multi-faceted tools desktop scientific experiment management international journal intelligent cooperative information systems december ioannidis livny gupta ponnekanti zoo desktop experiment management environment proceedings international vldb conference pages bombay india september ioannidis livny haber miller tsatalos wiener desktop experiment management ieee data engineering bulletin march bruce irvin barton miller multi-application support parallel program performance tool technical report cs-tr- computer sciences department wisconsin madison february itzkowitz mcnaughton orelup hanna visualizing performance parallel supercomputers simmons hayes brown reed editors debugging performance tuning parallel computing systems pages ieee computer society press karavanic myllymaki livny miller integrated visualization parallel program performance data parallel computing keller jones metadata foundation effective experiment management technical report environmental molecular sciences laboratory pacific northwest national laboratory kerbyson papaefstathiou nudd application execution steering on-the-fly performance prediction sloot bubak hertzberger editors proceedings high performance computing networking international conference exhibition lecture notes computer science pages springer-verlag kohn williams atexpert journal parallel distributed computing kunchithapadam miller integrating debugger performance tool steering simmons hayes brown reed editors debugging performance tools parallel computing systems pages ieee computer society press lamport time clocks ordering events distributed system communications acm july livny ramakrishnan beyer chen donjerkovic lawande myllymaki wenger devise integrated querying visual exploration large datasets proceedings acm sigmod ludwig wismuller sunderam bode omis on-line monitoring interface specification version technical report institute fur informatik der technische universitat munchen february lyon snelick kacker synthetic-perturbation tuning mimd programs journal supercomputing malony hammerslag jablonowski traceview trace visualization tool ieee software september mathur abrams machine assisted software performance diagnosis methodology technical report virginia polytechnic institute state department computer science mendes performance prediction trace transformation proceedings brazilian symposium computer architecture florianopolis september miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tool ieee computer november nagel arnold weber hoppe solchenbach vampir visualization analysis mpi resources supercomputer nelson laboratory notebook technical manual technical report la-ur los alamos national laboratory los alamos ottenstein ottenstein program dependence graph software development environment proceedings acm sigsoft sigplan software engineering symposium practical software development environments volume acm sigplan notices pages pittsburgh pase dynamic probe class library dpcl tutorial guide ibm corporation development poughkeepsie york version edition june ramakrishnan database management systems wcb mcgraw-hill raman livny solomon matchmaking distributed resource management high throughput computing proceedings seventh ieee international symposium high performance distributed computing hpdc pages chicago july reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance analysis environment ieee press editor proceedings scalable parallel libraries conference pages los alamitos reinhardt larus wood tempest typhoon user-level shared memory proceedings annual international symposium computer architecture april rennhackkamp extending relational dbmss dbms magazine http dbmsmag october reps algebraic properties program integration science computer programming ribler mathur abrams visualizing modeling categorical time series data technical report department computer science virginia polytechnic institute state august ribler vetter simitci reed autopilot adaptive control distributed applications proceedings high-performance distributed computing conference july riley gurd requirements automatic perfomrance analysis technical report esprit working group automatic performance analysis resources tools http fz-juelich november saavedra smith analysis benchmark characteristics benchmark performance prediction technical report computer science technical report usc-cs- southern california shende malony cuny lindlan portable profiling tracing parallel scientific applications proceedings spdt pages welches sinha kale automatic performance analysis proceedings international conference parallel processing pages iii snelick jaja kacker lyon synthetic-perturbation techniques screening shared memory programs software practice experience august sosic abramson guard relative debugger software practice experience february waheed rover performance visualization parallel programs visualization san jose october weiser program slicing ieee transactions software engineering sejuly whaley dongarra automatically tuned linear algebra software proceedings orlando nov acm ieee wiener ioannidis moose fox aid scientists data management problems proceedings international workshop database programming languages pages york august williams hoel pase mpp apprentice performance tool delivering performance cray decker rehmann editors programming environments massively parallel distributed systems birkhauser wolf mohr earl programmable extensible toolkit analyzing event traces message passing programs technical report fzj-zam-ibforschung- szentrum juelich gmbh april larus miller shared-memory performance profiling proceedings acm sigplan symposium principles practice parallel programming las vegas nevada june yan sarukhai mehra performance measurement visualization modeling parallel distributed programs aims toolkit software practice experience april 
yang identifying syntactic differences programs software practice experience july 
performance measurement tools highlevel parallel programming languages bruce irvin dissertation submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison acknowledgments years madison exciting survived superb consistent bart miller deserves highest gratitude years advice guidance support bart shown dedication extraordinary admirable remember fraction bart taught learned imagined committee members jim goodman sangtae kim jim larus miron livny offered time effort review criticize improve work helping make process worthwhile lending insights expertise professors helped small large ways chuck dyer helping admit department bob mayo supporting year scott baden ucsd reviewing thesis proposal providing stimulating discussions ethiopian lunches library mall department staff unequaled talent dedication thea sklenar processing travel reimbursements letting win rball lorene webber acting cosmic glue department paul beebe mitali lebeck jim luttinen david parter rest computer systems lab taking computing environment waiting glenn ecklund keeping cmchugging forget ipsand paradyn projects members forever deserve admiration jeff hollingsworth jon cargille krishna kunchithapadam mark callaghan karen karavanic tia newhall ari tamches christopher maguire mike mcmenemy joerg micheel chi-ting lam marcelo goncalves oscar naim mark mcauliffe suhui chiang special jeff mark distinguished service officemates friends understanding sounding boards moral supporters providers lodging stellar geeks david mckeown john wood cliff michalski greg wilson rob netzer joann ordille dave cohrs lambert wixson paul carnine rick rasmussen renee miller alvy lebeck gary kelley informix neal wyse sequent early support encouragement work jerry yan ken stevens rest nasa ames crew support encouragement nasa hpcc program graduate research fellowship owe great debts provided parallel programs measurements presented dissertation dennis jespersen leo dagum bruce davis brad richards robert schumacher jens christoph maetzig vincent ervin finally group people reserve special gratitude jill emma parents family helped immeasurably work dedicated iii abstract users high-level parallel programming languages require accurate performance information relevant source code programs experience performance problems lowest levels hardware software systems programmers peel back layers abstraction examine low-level problems maintaining high-level source code ultimately caused problem dissertation addresses problems providing performance data users high-level parallel programming languages describes techniques providing source-level performance data programmers mapping performance data multiple layers abstraction providing data-oriented views performance present model explanation performance information high-level parallel language programs level abstraction includes collection nouns code data objects verbs activities performance information measured nouns verbs performance information mapped level level maintain relationships low-level activities high-level code relationships implicit model helped implement support performance measurement highlevel parallel language applications performance measurement tools paramap paradyn describe design implementation tools show provide performance information fortran programmers finally present results measurement studies paramap paradyn improve performance variety real fortran applications running cmparallel computers case found performance trends observed source code level data views code views performance found performance problems explained source code level cases performance tools examine lower levels abstraction find performance problems found low-level information related source-level code structures data structures finally made small applications source code achieve substantial performance improvements table contents acknowledgments abstract iii chapter introduction motivation summary results organization dissertation chapter related work tools independent programming model tools specific programming models data views performance complementary techniques summary chapter model nouns verbs levels abstraction application model actual programming models chapter mapping challenges mapping performance data types mapping information static mapping information dynamic mapping information dynamic instrumentation dynamic mapping set active sentences description sas performance questions distributed memory limitations sas approach summary chapter paramap initial experiments paramap tool implementation measurement results simple dual reciprocity boundary element method summary chapter model dynamic instrumentation paradyn parallel program performance measurement tool resources metrics system structure source-level performance data paradyn mapping performance data levels abstraction fortran-specific resources metrics performance data parallel arrays parallel code constructs vii cmrts metrics measurement fortran programs vibration analysis bow peaceman-rachford pde solver peace particle simulation psicm summary chapter conclusions summary future work chapter bibliography introduction motivation proponents high-level parallel programming languages promise make programmers lives easier parallel languages offer portable concise notations parallel programs compilers automatically map programs complex parallel machines parallel languages free programmers difficult error-prone ineffective task parallel computations explicitly high-level parallel programming languages guarantee high performance compilers unable effectively map programs target hardware programmers add pragmas rewrite code accommodate compilers architectures operating systems data sets performance measurement tools give programmers insight performance tuning past performance measurement techniques effectively applied programs written high-level parallel programming languages tools designed specific programming languages incorporated narrow view program performance designed low-level programming presented information unusable high-level programmer problems building performance tools high-level parallel programming languages important performance tools converse programmers terms source code language specifically users measure performance metrics important control construct language performance tools account implicit activity define implicit activity extra activity inserted compiler maintain illusion programming model hardware platform problem illustrated observation programmers abstract programming languages understand detailed execution programs general programmers leave hardwarespecific details compiler observed applications perform poorly high-level characteristics effectively processed compiler result unnecessarily large amounts implicit activity compilers standard hardware eventually ease problem performance tools measure implicit activity relate source code constructs ultimately required performance tools high-level parallel programming languages include dataoriented addition control-oriented views performance today parallel programming languages data structures express parallelism users effectively decompose data structures distributed memories achieve good performance performance tools relate performance measurements distributed data-structures users make effective data distribution decisions finally performance tools high-level parallel programming languages programmers study performance multiple levels abstraction implicit activity limits application performance fully understand application performance simply knowing source level control data structures caused bottlenecks due nature abstraction high-level information vague aggressively find fix performance problems beneath highest layers noted simply providing raw performance data terms processors caches communication overwhelming confusing performance tools constrain identify low-level information source code level information summary results dissertation presents methods collecting presenting performance information programs written high-level parallel programming languages shows methods effective practice methods based noun-verb model informal framework reporting performance information programs built multiple levels abstraction show model develop performance tools data-parallel fortran dialect tools present code data views performance account implicit activity users peel back layers abstraction demonstrate effectiveness tools measuring improving execution times real applications model organize complex layered programming systems associate performance information performance-critical control data structures 
source code level map implicit activity source code level users peel back layers abstraction performance problems lie beneath source code level model describes application program set levels abstraction level corresponds layer software hardware actual application program level set nouns set verbs nouns structural elements level verbs actions nouns performed nouns nouns verbs level abstraction related nouns verbs levels abstraction mappings mapping expresses notion high-level language constructs implemented low-level software hardware model measure performance information low levels easy measure map performance information source code level easy understand model independent programming system model study parallel programming language classes model implement performance tools specific language fortran model dissertation describes important contributions demonstrate performance data related data structures show today successful parallel programming systems exploit parallelism data important performance tools correlate performance information parallel data structures describe data structures represented model demonstrate performance measurements parallel arrays fortran describe compilers communicate static mapping information performance tools describe language-independent interface static mapping information implemented paradyn performance measurement system interface compilers describe nouns verbs levels abstraction program mappings nouns verbs levels static mapping information sufficient fully represent relationships levels abstraction today programming systems defer mapping decisions hardware configurations systems reassign data structures processors optimize computation communication load describe evaluate language independent mechanism communicating dynamic mapping information performance tools finally tie ideas demonstrating practice dissertation examine real applications donated today users parallel computers measuring significantly improving applications aim today users improve programs execution times show tomorrow programmers high-level parallel programming languages effectively efficiently utilize complex parallel computers organization dissertation remainder dissertation divided chapters covering relevant previous work present evaluate model middle chapters summarize outline future research directions chapter describes model detail examples data-parallel fortran illustrate important ideas model chapter describes basic techniques mapping present simple examples static mapping discuss complex problem dynamic mapping chapter describes initial implementation fortran data-parallel programming language describes measurements dual-reciprocity boundary element code presents evidence performance tools based model lead substantial improvements application performance chapter discusses dynamic performance measurement techniques discuss paradyn performance tool enhancements collection mapping information support fortran chapter concludes measurement experiments find fix substantial performance problems application finally chapter summarizes contributions thesis outlines goals future research related work prior research parallel program performance tools addressed issues related measurement high-level parallel language programs implemented performance measurement systems provide performance data relevant lowest levels abstraction messages locks basic block counts highest levels specific programming model approaches correspond goals building tools programming models tools designed single programming model chapter discuss previous tools supported users parallel programming languages conclude system addressed issues chapter single system conversed users terms source code accounted implicit activity supported study performance multiple levels abstraction provided data views performance tools independent programming model performance measurement tools sequential parallel systems measure execution characteristics independent programming model purpose discussion divide general tools categories system monitoring tools general program monitoring tools system monitoring tools provide performance information hardware system software base parallel distributed system hardware monitors measure bus activity cache activity memory activity instruction types vector performance subsystems networks operating systems monitors monitor processor utilization scheduling virtual memory activity activity system calls tools programs language execute system measurements easily related individual constructs language difficult system monitoring tools fully understand performance parallel distributed program hardware operating system monitors tuning performance system supplementing program performance measurement tools general program monitoring tools variety techniques measure common-denominator events common-denominator events include procedure calls basic blocks runtime libraries synchronization points operating system kernel information gathered probes summarized metrics analyzed displayed mapped back source code program symbolic debugging information general program monitoring tools provide extensive views performance confusing users high-level parallel programming languages tools provide execution statistics process library function basic block statement instruction application measurements independent source language languages studied user responsible understanding source constructs programming language map primitive events measured tool visualizations low-level send receive communication confuse programmers data-parallel languages general program monitoring tools include measurements message send receive events view performance confuse programmer higher level constructs data-parallel array notations programmer understand concepts sending receiving messages understand code data objects responsible messages tools specific programming models performance measurement tools designed specific languages programming environments language-specific tools knowledge programming model reduce measurement costs give detailed performance feedback tools provide information specific language constructs data types visible general low-level tools language-specific tools generally provided information lower levels abstraction effects implicit activity language-specific tools generally applicable programs written languages tools include analyses displays generally tools bound specific data collection mechanisms language terms difficult re-apply techniques languages goals model identify concepts techniques applied parallel programming languages excellent performance tools designed data-parallel programming languages connection machine prism environment debugging performance measurement tool cmfortran programs monitors subroutine runtime system events profiles cpu time types message communication similar tool called mppe provided maspar machines programs written maspar fortran tool user lines code primarily responsible program activity implicit system-level information provided terms total time spent library routines work dissertation extends ideas relating measurements parallel data structures primary source parallelism data-parallel languages extends performance measurements parallel node level abstraction perfsim performance prediction tool takes approach measuring fortran applications perfsim executes sequential part fortran program estimates running times parallel parts replacing fortran runtime system performance prediction library tool quickly estimate running time application address problem identifying performance problems assumes costs parallel library routines accurately estimated sequential activity cheaply executed experience related chapters suggests costs parallel executions unpredictable sequential activity create significant performance problems cray research product atexpert analyzes loops autotasked fortran programs cray research y-mp computers tool measures implicit costs parallelization loops orders costs loop type cost related strategy improving performance loops tool suggest specific improvements loop work extends atexpert techniques generalizing concepts implicit cost measurements providing tools directly measure implicit costs types programming constructs recent performance measurement systems extensive compiler information provide detailed performance information data-parallel fortran dialects system performance feedback fortran applications integrates fortran compiler pablo performance measurement environment result editor annotates source code lines performance information computation time message statistics system performs sophisticated analysis static dynamic trace data provide detailed language-dependent information identification loop-carried cross-processor dependencies cray research product mpp apprentice compiler-generated instrumentation cost estimates 
time count language-level events myriad programming models cray timing counting events mpp apprentice achieves scalability integration cray research compilers mpp apprentice information relevant parallel source code integration compilers performance tools achieved system mpp apprentice crucial obtaining detailed code-specific information future integration enable measurement data-specific information model program information interfaces chapters suggest accomplished independent specific compilers performance tools designed parallel functional languages static analysis tool designed functional language user view potential parallelism programs tool analyzes structure program dataflow graph determine maximum average widths graph length critical path static dataflow graph tools functional languages program dependencies determined execution runtime profiling tools account unique execution activities lazy evaluation developed functional languages haskell parvis tool presents program performance visualizations unique multilisp parallel programming language multilisp dialect lisp includes functions called futures return values asynchronously parvis user view parallelism waiting terms activities futures functional language performance tools excellent examples tools converse users terms source code language present parallelism synchronization terms functions evaluations futures compilers functional languages generate significant amounts implicit low-level activity garbage collection produce executable binaries traditional hardware systems important performance tools functional languages measure present information implicit lowlevel activity growing number performance tools designed parallel object-oriented languages notably tau official performance analysis system programming language source-level event traces display parallel performance information terms class methods rich program information database relate events source code projections tool presents language-specific performance information distributed object-oriented programming language charm chare kernel projections user display message traffic time differentiate message information message type programming environment object-oriented language cool user object characteristics affect performance reliability characteristics grouped versions called adaptations dynamically adapt application varying runtime environments tools parallel object-oriented languages relates performance measurements code tools relates performance parallel data data objects primary source parallelism languages crucial relate computation communication objects tools projections measure implicit low-level activity message communication classify purpose activity general tools concentrated source-level information performance measurement systems designed parallel logic languages gauge performance measurement tool presents high-level information programs written pcn gauge collects metrics per-procedure per-process bases displays metrics color-coded matrix tool computes metrics specific guarded case statements called implications per-implication metrics include number times implication considered number times implication succeeded failed number times implication blocked waiting input values data views performance previous tools supported data-oriented views performance memory trace tools cprof memspy successfully related cache hits misses data structures sequential fortran programs algorithm animation visualization tools developed part sequential object-oriented programming systems object-oriented systems draws representation object hierarchy animates view execution information recordings object activations method invocations performance views parallel data structures limited recent work area performance visualization focused drawing representations vectors matrices annotating representations data layouts animating views traces computation communication events work differs efforts attempted visualize animate actual data structures task considerably difficult increasing scale dimension concentrated collecting dynamic mapping information parallel data structures mapping node-level performance measurements explicit implicit activities data structures complementary techniques research event mapping tools debugging optimized code offer results methodologies related performance measurement high-level parallel languages event mapping tools programmers build abstractions describing relationships records event trace file debuggers optimized code attempt accurately represent state program execution abstraction levels optimizing compiler obscured low-level execution details event mapping hybrid approach system monitoring capable bridging gap general measurement tools language-specific tools event mapping tools generally collect low-level events map higher levels abstraction analysis user user responsible describing low-level events combined identified highlevel events responsible analyzing high-level events desired performance information approach maximum flexibility handling program performance information event definitions provided terms grammars relations constructs special language event mapping system compiles definitions automatically recognizes defined high-level events streams low-level events generally event mapping tools support multiple levels abstraction enabling user study program performance multiple views event mapping tool present information multiple levels abstraction general problem addressed existing tools mapping event streams types performance information difficult problem feel regularity events generated high-level language compilers runtime systems map aggregate performance information metrics summations general costly event mapping methods performance measurement programs written high-level languages bears resemblance problem debugging optimized code problem symbolic debugger present view optimized program consistent original source code hiding effects optimizations reordered statements eliminated variables altered steps computation resultant code direct mapping original source code representable source language work field focused identifying variables values consistent source code variable currentness providing values variables work investigated ways displaying execution optimized code terms source code performance measurement parallel programs written high-level languages fundamentally simpler debugging optimized code performance measurement tools reconstruct instantaneous state computation symbolic debugger stop execution program instruction identify location source code provide access variables original program performance measurement tool hand generally concerned cumulative activity program elements code constructs data objects performance measurement tools identify program elements active point rarely access values variables summary model augments earlier work performance tools parallel programming languages builds individual techniques general measurement tools language-specific tools event-mapping tools general performance tools offer variety data collection techniques specialized hardware library instrumentation source code instrumentation dynamic rewriting code execution model require method collection tools dissertation employ variety data collection techniques pioneered tools techniques dynamic mapping performance data practically implemented dynamic instrumentation techniques chapter demonstrate space time savings making mapping decisions dynamically language-specific performance tools demonstrated individual measurement techniques performance tools based model data-parallel language tools shown provide control code views performance adopt techniques attaching performance data code displays object-oriented language tools offer natural hierarchical structures organizing noun data demonstrate techniques interpreting compiler output mapping purposes standardization compiler-generated mapping data unsolved problem systems demonstrate potential push techniques dissertation event mapping tools introduced notions abstraction layers querying performance data adopt expand concept abstraction layer showing dynamically constrain low-level measurements inherent overhead event-mapping techniques define form performance data query restricted subset multi-level performance data collected efficiently remainder dissertation combines expands techniques provided related systems offers techniques representing performance information multiple layers abstraction accounting implicit activity automatically mapping performance data layers providing data views performance model identify performance characteristics common programming models developed framework discuss performance characteristics programs written programming models section describes noun-verb model parallel program performance explanation model nouns structural elements program verbs actions nouns performed nouns collection nouns verbs software hardware 
layer defines level abstraction nouns verbs level abstraction related nouns verbs levels abstraction mappings mapping expresses high-level language constructs implemented low-level software hardware mappings performance information collected arbitrary levels abstraction related language level nouns verbs mapping static meaning determined runtime dynamic meaning determined runtime possibly program execution providing framework comparing performance characteristics programming models model helps explain performance characteristics programming language directly accounting implicitly explicitly mapped verbs model complete view program performance model guide creating performance measurement tools alternate terminology objects methods feel terms overused chosen nouns verbs chapter describe model data-parallel language fortran language fortran implementation cmcomputers representative high-level parallel programming languages including hpf model applicable parallel programming models nouns verbs noun program element performance measurements made verb potential action noun performed noun fortran program figure describe nouns verbs fortran language program declares multi-dimensional arrays line initializes elements array parallel assignment statement line assigns values subsection array line computes sum array line computes function upper left quadrant array assigns array line identify nouns program fortran nouns include programs line subroutines forall loops arrays line statements lines verbs fortran include statement execution lines array assignment lines reduction line subroutine execution file programming languages naming nouns difficult generate unique names languages lisp explicitly identify dynamically created data objects nouns variety ways control structure allocated retval foo list returned function foo lisp program cases differentiate calls memory allocation routine add names functions dynamic call stack retval foo bar list returned function foo called function bar similar scheme cprof memory profiler objects memory location allocated noun represent data object allocated memory location give unique global local names dynamically allocated nouns noun object allocated program execution programmer supply programmers supply extra argument calls memory allocator malloc object-oriented languages dynamically created instances class class identifier queue instance class queue combination schemes produce compound code structures loops iterators switches simple statements difficult languages compilers rarely give explicit names nouns ways simplest common approach code structures location defined foo doloop identify loop begins line fortran program contained file foo programmer insert compiler pragmas code control structures programmer give innerloop important loop languages programmers create control structures dynamically schemes proposed dynamic data objects approaches advantages disadvantages single approach superior cases choose scheme languages measure group nouns sets trees graphs structures noun grouping simplifies searching set nouns organizes performance information efficient access reflects program structure set statements subroutine grouped natural structure body code groupings based noun types names performance characteristics program parameter integer asum forall asum sum forall end end figure fortran program execution instance program construct verb called sentence sentence consists verb set participating nouns cost cost sentence measured terms resources time memory channel bandwidth finally performance information consists aggregated costs measured execution collection sentences performance information array include measurements assignments lines reduction line performance information array include measurements assignment line method expression verb explicit meaning verb directly requested programmer program language construct implicit meaning programmer explicitly request verb occurred maintain semantics computational model examples implicit verbs include page faults cache misses process initialization levels abstraction high-level language programs built levels abstraction including source code language runtime libraries operating system hardware constructed systems level self-contained levels interact well-defined interfaces measure performance level measurements related constructs understood programmer model level abstraction performance measured represented distinct set nouns verbs nouns verbs level mapped nouns verbs levels cmsystems fortran program compiled sequential program set node routines sequential program executes cmcontrol processor makes calls parallel node routines parallel system routines runtime system cmrts cmrts creates arrays maps arrays processors implements fortran intrinsic functions sum max min shift rotate coordinates processor nodes parallel fortran array divided subgrids subgrid assigned separate node node responsible computations involving local array subgrids array data non-local subgrids needed non-local data transferred computation proceed figure shows division cmsystem levels abstraction model highest level called cmf level nouns verbs fortran language discussed section middle level rts level rts level nouns include arrays allocated execution set arrays includes arrays found cmf level arrays generated compiler holding intermediate values evaluation complex expressions verbs rts level include array manipulations shift rotate put copy lowest level abstraction node level node level nouns include processor nodes node level verbs include compute wait broadcast communication point-to-point communication mapping relates nouns verbs level abstraction nouns verbs level mapping top-down bottom-up top-down mapping arrays nodes relate array subsection array set processor nodes bottom-up mapping node routines code lines relate cpu time recorded node routine fortran statement compiled mappings static dynamic static mappings independent time context mapping node level object routines cmf level statements static mapping determined compile time dynamic mappings time-varying relationships fortran arrays mapped processor nodes allocated mappings nodes array subregions recorded runtime verb mappings explicit implicit explicit mapping highlevel verb directly implemented lower level verb sum reduction line figure implemented low-level addition operations mapping cmf level sum operations node level additions explicit implicit mappings lower-level verb helps maintain semantics higher-level verb sum reduction implemented cmsystem partial reductions processor node final reduction partial results cmbroadcast network parallelism broadcast communication created reduction implicit directly cmf level sum statement mapping cmf level sum operations creation parallelism broadcast communication implicit mapping figure cmexecution fortran program shaded areas user code labels edge levels abstraction representation fortran cmf level rts level node level control processor system runtime node array subgrids rts routines sequential cmf object code system cmf object code cmf source code node application model actual programming models hundreds parallel programming languages proposed implemented distributed general find model describing performance aspects languages entire classes languages section briefly describe nouns verbs levels abstraction mappings variety languages jade task-parallel language accesses shared data structures synchronize tasks jade withonly block coarse-grained task specifies shared objects access executing jade runtime system ensures withonly block access allowing block execute representation jade models withonly blocks shared data objects nouns accesses shared data objects verbs execution withonly block explicitly map execution statements block accesses shared memory objects implicitly map time spent waiting objects sisal parallel single-assignment language achieved performance comparable fortran applications sisal programmer creates functional loops expose code parallel optimization techniques independent loops automatically scheduled parallel processors 
nouns sisal program include functions loops expressions functional language primary verb sisal evaluation lower-level implicitly-mapped verbs include scheduling synchronization parallel loop iterations portable runtime systems considered languages performance measurement point view share characteristics traditional languages portable runtime system implements level abstraction composed multiple levels pvm daemon workstation set connections route messages pvm operations potentially map multiple daemon operations affects performance pvm operation parallel programming libraries class libraries considered languages portable runtime systems measure explain performance aid model library defines classes nouns verbs lparx defines concepts regions grids xarrays region abstract object representing index space grid uniform dynamic array instantiated region xarray dynamic array aggregate data objects grids distributed processors represent concepts type noun maintain mappings grid contained processors lparx supports activities region partitioning region growing xarray allocation corresponds verb algorithm ultimate high-level notation problem solution explain performance algorithms classes algorithms manipulate common data structures common primitive actions graph algorithms generally ways traversing nodes arcs graph matrix algorithms methods manipulating rows columns elements matrix represent basic elements algorithm nouns graphs nodes arcs matrices rows columns elements represent primitive operations verbs traverse visit mark add delete transpose move copy algorithmic representations problem solutions generally assume cost operations graph algorithm analysis assume fixed cost visiting marking deleting tree nodes implementation actual costs vary due unpredictable implicit low-level activities synchronization locking communication file maintaining mappings low-level implementation-dependent activities high-level structures algorithm evaluate validity cost assumptions evaluate performance analyses algorithms mapping primary problem performance measurement high-level parallel programming languages map low-level events high-level programming constructs chapter discusses important aspects problem presents methods performance tools map performance data provide accurate performance information programmers discuss static mapping dynamic mapping technique data structure called set active sentences methods requires cooperation compilers performance tools describe nature amount cooperation required mapping methods orthogonal describe combined complete tool concentrate mapping upward layers abstraction techniques independent mapping direction chapters evaluate methods actual performance tools challenges mapping performance data application programs built multiple layers abstraction performance tools nouns verbs layer relate nouns verbs layers chapter mapping represent relations abstraction levels nouns verbs performance information measured sentence relevant nouns verbs maps build mappings performance tools collect mapping information information forms real systems compilers emit symbolic debugging information programming tools map memory addresses source code lines data structures common symbolic debugging information seldom complete set mapping data needed performance tools list data structures line code mapping execution activity data structures typically mapping information stored application data-structures execution run-time system determine data-to-processor mappings run time knowledge hardware resources run-time systems information program address space traditionally well-defined run-time systems application programming libraries communicate mapping information performance tools mappings one-to-one one-to-many many-to-one many-to-many shown figure figure shows examples type mapping one-to-one mappings shown type mapping assign low-levelcosts high-level structure one-to-one low-level message send implements high-level reduction measurements equivalent measurements one-to-many low-level function implements reductions cost split evenly merge set assign cost entire set many-to-one low-level functions implement source line aggregate costs assign cost line many-to-many source code lines implemented overlapping set lowlevel functions aggregate costs treat oneto-many mapping figure types upward mappings row table figure simple handle performance tool performance information measured sentence sentence maps sentence maps sentences one-to-many shown row correct assignment performance data difficult case tools split measured data equally sentences measured sentence maps splitting assumes equal distribution low-level work high-level code handle one-to-many mappings merging sentences measured sentence maps technique tool discussed chapter makes assumption distribution performance data helps identify high-level programming constructs implementations merged optimizing compiler avoids misleading programmer overly precise information many-to-one many-to-many mappings shown fourth rows figure reduced types mappings case aggregate sum average performance data low-level sentences treat result one-to-one one-to-many mapping show examples cases chapters types mapping information mapping information include noun verb definitions detailed descriptions nouns verbs map nouns verbs section describe generic interface communicating mapping information performance tools sections describe information communicated compilers tools prior application execution static information execution dynamic information table figure shows components mapping information noun verb definitions describe performance tool set nouns verbs levels abstraction contained application mapping definitions equivalence classes performance data performance data collected source sentence presented relation source sentence destination sentence simple definition mapping information handle types mappings listed figure build many-to-one mapping defining mappings source sentences destination sentence build one-to-many many-tomany mappings similar combinations basic one-to-one mapping definition differences types mappings exploited interpreted performance tool mappings static mapping information static mapping information mapping information provided performance tool prior execution application program illustrate static mapping information present figure figure shows subset static mapping information type information description noun definition level abstraction descriptive information verb definition level abstraction descriptive information mapping definition source sentence destination sentence figure types mapping information fortran program mapping information defines mapping compiler generated function fortran source code lines records define sourcelevel nouns line line source-level verb executes records defines base level noun compiler generated function cmpe corr verb cpu utilization finally records define mappings cpu utilization base level function execution source code lines noun line abstraction fortran description line source file usr src prog main fcm noun line abstraction fortran description line source file usr src prog main fcm verb executes abstraction fortran description units cpu noun cmpe corr abstraction base description compiler generated function source code verb cpu utilization abstraction base description units cpu mapping source cmpe corr cpu utilization destination line executes mapping source cmpe corr cpu utilization destination line executes figure examples static mapping information mapping information statements lines source code implemented single low-level routine performance measurement tool measure cpu utilization cmpe corr present information execution source code lines performance tool split execution costs source code lines merge lines inseparable unit make interpretations mappings static mapping information application program executable image separate file auxiliary database static location location mapping information communicated performance tools mappings high-level abstractions method communicating static mapping information discussed section simple method compilers describe important language-specific program-specific information performance tools information defined statically performance tools process execution application program avoid competition resources application program static mapping information provide information mappings determined application execution dynamic mapping information dynamic mapping information includes mapping 
empirical study reliability unix utilities barton miller bart wisc lars fredriksen fredriksen att bryan wisc summary operating system facilities kernel utility programs typically assumed reliable recent experiments crash utility programs version unix tested report describes tests analysis program bugs caused crashes content indicators testing debugging programs utilities general term reliability unix research supported part national science foundation grants ccrand ccroffice naval research grant -jand digital equipment corporation external research grant copyright miller fredriksen introduction basic operating system facilities kernel major utility programs expect high degree reliability parts system frequently frequent implies programs well-tested working correctly make systematic statement correctness program form formal verification technology program verification advancing reached point easy apply commonly applied large systems recent experience led formal verification complete set operating system utilities onerous task form complete testing started dark stormy night authors logged workstation dial-up line home rain affected lines frequent spurious characters line race type sequence characters noise scrambled command line noise surprising surprised spurious characters causing programs crash programs included significant number basic operating system utilities reasonable expect basic utilities crash core dump receiving unusual input exit minimal error messages crash experience led bugs lurking systems regularly scenario motivated systematic test utility programs running versions unix operating system project proceeded steps construct program generate random characters program test interactive utilities programs test large number utilities random input strings crash identify strings types strings crash programs identify program crashes categorize common mistakes crashes result testing utility programs versions unix crash programs testing included versions unix underwent commercial product testing byproduct project list bug reports fixes crashed programs set tools systems community rich body research program testing verification approach substitute formal verification testing procedures inexpensive mechanism identify bugs increase system reliability coarse notion correctness study program detected faulty crashes hangs loops indefinitely goal complement replace existing test procedures type study important reasons contributes testing community large list real bugs bugs provide test cases researchers evaluate sophisticated testing verification strategies bugs found caused programming practice provided security holes internet worm finger bug found additional bugs future security holes crashes caused input carelessly type strange unexpected errors uncovered method testing fourth inadvertently feed programs noisy input edit view object module cases meaningful predictable response noisy lines reality major utilities shells editors crash interested interactions random testing traditional industrial software testing testing strategy sounds naive ability discover fatal program bugs impressive program complex finite state machine testing strategy thought random walk state space searching undefined states similar techniques areas network protocols cpu cache testing testing network protocols module inserted data stream module randomly perturbs packets destroying modifying test protocol error detection recovery features random testing evaluating complex hardware multiprocessor cache coherence protocols state space device combined memory architecture large difficult generate systematic tests multiprocessor random generation test cases helped cover large part state space simplify generation cases paper proceeds section describes tools built test utilities tools include fuzz random character generator ptyjig test interactive utilities scripts automate testing process section describes tests performed giving types input presented utilities results tests section analysis results analysis includes identification classification program bugs caused crashes section presents concluding remarks including suggestions avoiding types problems detected study commentary bugs found include appendix user manual pages fuzz ptyjig tools developed basic programs test utilities program called fuzz generates stream random characters consumed target program options fuzz control testing activity program ptyjig written test interactive utility programs interactive utilities screen editor expect standard input file characteristics terminal device addition programs scripts automate testing large number utilities fuzz generating random input strings program fuzz basically generator random characters produces continuous strings characters standard output file figure perform types tests depending options fuzz fuzz capable producing printable control characters printable characters groups null character delay character option account delay characters passing pipe user locate characters caused utility crash option seed random number generator provide repeatable tests fuzz record output stream file addition printing standard output file examined options randomly insert newline characters output stream limit length output stream complete description fuzz manual page appendix fuzz test deqn equation processor fuzz outfile deqn output stream characters length stream recorded file outfile ptyjig testing interactive utilities utility programs input output files characteristics terminal device editor mail program standard output fuzz pipe sufficient test programs ptyjig program test interactive utilities allocates pseudo-terminal file two-part device file side standard terminal device file form dev ttyp side send receive characters terminal file dev ptyp figure creating pseudo-terminal file ptyjig starts utility program ptyjig passes characters input pseudo-terminal read utility fuzz ptyjig test terminal-based screen editor fuzz outfile ptyjig output stream fuzz characters length stream recorded file output complete description ptyjig manual page appendix scripts automating tests command shell script file written type test script executes utilities set input characteristics script checks existence core file utility terminates indicating crash utility core file offending input data file saved analysis tests building software tools tools test large collection utilities running versions unix operating system utility system executed types input streams test utility program produce results crash program terminated abnormally producing core file hang program appeared loop indefinitely succeed program terminated note case correctness output date tested utilities versions unix versions summarized table versions derived form bsd bsd berkeley unix versions sunos release undergone substantial revision kernel level sco xenix version based system standard ibm aix unix released tested product supporting basic system utilities important tests covered hardware architectures systems program statement error tolerated machine program crash referencing null-value pointer type problem csh utility tested ibm complete testing progress versions unix test identifying machine vendor processor kernel letter dec vaxstation cvax bsd nfs wisconsin sun sparc sunos sunos nfs bobcat bobcat bsd nfs wisconsin sys shared-memory citrus sco xenix system rel ibm romp aos unix ibm aix unix sequent symmetry dynix table list systems tested testing covered total utility programs versions unix utilities tested system table lists names utilities tested type system utility tested detailed description utilities refer user manual systems list utilities covers substantial part commonly mail program screen editors compilers document formatting packages list includes commonly 
information generated application execution includes types information static mapping information figure differs static mapping information communicated performance tools program execution application dynamically allocates parallel data objects application dynamically communicate definition noun performance tool application dynamically distributes data object parallel processing nodes application dynamically define mapping object processor nodes performance tool performance tool dynamic mapping information run time relate performance measurements abstract program constructs activities section discuss important techniques collecting dynamic mapping information dynamic instrumentation reduce perturbation effects collecting dynamic mapping information data structure called set active sentences discover verb mappings difficult detect dynamic instrumentation dynamic mapping mapping point function procedure line code application dynamic mappings constructed run-time system routine allocates parallel data objects distributes processors return point routine defined mapping point mapping data objects processor nodes determined prior point goal identify mapping points application instrument code reports mapping information performance tool instrument points adding source code calls performance tool dynamic instrumentation insert mapping instrumentation run time dynamic instrumentation technique external tool binary image running executable collect performance data basic technique defines points instrumentation inserted predicates guard firing instrumentation code primitives implement counters timers dynamic instrumentation advantage traditional static techniques performance tools instrument points needed provide performance data point instrumentation execution perturbations dynamic mapping instrumentation define subset points consisting points generate mapping information typically subset language programming library includes return points subroutines data structures allocated distributions parallel processors determined application executes performance tool insert mapping instrumentation beginning execution leave insert delete mapping instrumentation execution technique reduces run-time perturbation miss mapping decisions noun verb definitions set active sentences dynamic mapping information difficult determine simply instrumenting mapping points application verb mappings layers abstraction difficult detect implementation layer hidden layers software engineering reasons section describe set active sentences sas data structure dynamically map concurrent sentences layers abstraction describe sas high performance fortran describe kinds questions asked answered sas describe limitations sas approach asum sum bmax maxval figure hpf code description sas set active sentences sas data structure records current execution state level abstraction similar procedure call stack track active functions sentence level abstraction active adds sas sentence inactive deletes sas sentences contained sas concurrently considered dynamically map hpf code fragment figure code concerned problem relate low-level message high-level array reduction sum reduction line maxval reduction line code imply messages processors distributed memory parallel computer assume node parallel computer holds subsections arrays node reduces subsections sending local results nodes compute global reductions assume performance tool measure low-level mechanisms message transfer message send receive routines monitor execution high-level code line code active array active reduction performed array answer questions messages summations finding maxval time spent sending messages summations questions specific data-parallel fortran hpf code figure representative questions language system built multiple layers abstraction system explain low-level performance measurements terms high-level programming constructs vice versa sas approach dynamic mapping defer performance questions run time measure sentences satisfy performance question explained sas track sentences active level abstraction sentence active monitoring code notifies sas sas remembers active sentences low-level sentence measured counter timer means monitoring code queries sas determine sentences active relates low-level sentences active sentences higher levels figure shows contents hypothetical sas hpf code figure represents snapshot sas moment message part computation sum array shows sentences active hpf level abstraction base level part application user code programming libraries system level code add remove sentences sas existence layers sas resembles performance tools sequential programs make monitored program function call stack program function call stack records functions active point time exploring call stack performance tool relate performance measurements function figure sas moment message hpf line executes hpf sums base processor sends message line represents active sentence ancestors program call graph users performance tool understand function activity relates dynamic structure programs sas record active sentence sentence discovered examining call stack defined sas sentences active reduce size sas advantage run-time requests performance information eliminate uninteresting sentences sas request measurements array sas avoid keeping sentences performance questions sas track performance questions asked nouns verbs section define performance question vector sentences meaning performance question performance measurements resource utilization made sentences question active figure shows performance questions meanings hpf code questions figure consist sentences noun verb easily generalize questions complex sentences altering operation sas performance questions meaning sum cost summations processor send cost sends processor sum processor send cost sends summed sum processor send cost sends summed figure performance questions monitoring code sas answer types questions listed figure component performance question represents predicate satisfied monitoring code measure cpu time wall-clock time channel bandwidth execution cost question make sas flexible extending definition performance questions performance question satisfied conjunction sentences active extend concept performance questions include boolean operators disjunction negation wider range performance questions extension incurs added time evaluate complex expressions distributed memory defined sas global data structure target hardware systems support shared global memory globally shared memory store sas today parallel systems globally shared memory pay synchronization cost contention globally shared data structure fortunately sas approach duplicate sas node parallel computer application code duplicated single program multiple data spmd programs individual sas operate independently long performance questions asked require information sass performance questions listed figure answered sharing information nodes interesting performance questions answered information sentence activity node distributed database system server process performs disk reads behalf clients measure server disk reads corrspond client query sas information answer performance question server reads disk client query active distributed sas client sas server client sas server sas communicate performance question answered client sas send sentence client query active server sas sentence active inactive limitations sas approach sas approach relating low-level performance information high-level activities limitations sas approach handle asynchronous activation sentences unix system measure kernel disk writes occur behalf function user process figure shows time-lines hypothetical unix process kernel figure asynchronous sentence activations sas time advances downward user process kernel func write disk write disk write disk write sas func kernel executes writes disk active inactive user process makes write system call kernel kernel writes information disk actual writes disk occur column figure shows sas records activities figure shows sas function execution sentence kernel disk write sentence time kernel 
international conference supercomputing tokyo july dynamic control performance monitoring large scale parallel systems jeffrey hollingsworth barton miller hollings wisc bart wisc computer sciences department wisconsin-madison dayton street madison wisconsin abstract performance monitoring large scale parallel computers creates dilemma collect detailed information find performance bottlenecks collecting data introduce data collection bottlenecks time users inundated volumes complex graphs tables require performance expert interpret present approach called search model addresses problems combining dynamic on-the-fly selection performance data collect decision support assist users selection presentation performance data present case study describing prototype implementation technique identify bottlenecks real programs addition reduce amount performance data collected factor ranging compared traditional sampling trace based instrumentation techniques introduction performance monitoring applications running large scale parallel computers generate vast seas useless data wealth information problem programmer forced navigate tools store process display large volume data results number speed cpus collect performance data loop basic block level explain performance problems result data impossible collect programmers tools forced select subset data collect propose paradigm based dynamic on-the-fly selection performance data collect work supported part national science foundation grants ccrand ccroffice naval research grant -jand grant sequent computer systems approach permits collect data approach great flexibility requires decisions made collect collect display collect paper introduce strategy called search model designed provide decision support selection presentation performance data describe prototype implementation performance consultant system incorporates search model search model based answer separate questions application performing poorly bottleneck problem occur answer question system includes hypotheses potential bottlenecks parallel programs collect performance data test bottlenecks exist program answering question means isolate performance bottleneck specific resource program disk system synchronization variable procedure identify problem occurs isolate bottleneck specific phase program execution finding performance problem iterative process refining answers questions address problem selecting performance data collect search model direct instrumentation collect data test step search process means collecting large amounts data anticipate user collect data system user refine view performance problem adjust instrumentation collect detailed focused information addition control granularity performance data collected dynamically adjusting sampling frequency search model addresses problem display providing decision support selecting displays analyses designed give specific advice performance bottlenecks lie program displays explain bottlenecks integrate existing display techniques associate types bottlenecks search model identifies type bottleneck program create displays result user freed sort sea pictures tables find explain performance program search model designed dynamic instrumentation paradigm post-mortem analysis section describe search model section describe prototype implementation performance consultant results running real programs discuss work relates previous performance tools finally outline plans full scale implementation search model potentially large amount performance data problem user navigate tools collect search model addresses user information overload problem providing defined logical search model assist finding performance bottlenecks section describe goals search model define search model model based answering separate questions application performing poorly bottleneck problem occur finally explain automate search main goal search model work long running applications large scale parallelism hundreds thousands processors performance problems show applications toy data sets small number processors users find real bottlenecks real applications run tools full scale version program minimize performance impact system application find existing bottlenecks create dynamic control instrumentation makes wealth performance data requiring limited amount collected time feel execution time searching approach long running programs interesting behaviors tend long time long time interval find isolate problem behavior lasts short interval time miss short impact total execution-time program small short running program fact short means time re-run short search model designed execution-time search feel programmers find searching bottlenecks running program difficult confusing make system easier provide post-mortem semantics means programmers view search place program completed execution data answer performance questions collected maintain illusion system informs user additional goals usability portability programmers write application performance tool write application style restricted specific programming model required manually add code application collect performance data required re-compile application finally search model work variety machine architectures programming styles difficult goal due diversity machines styles desire provide relevant guidance specific program specific machine permit users quickly find bottleneck extraneous details search model starts high level view iteratively refines detail causing program perform poorly users independently refine program performance search process thought traveling point dimensional space step move direction axis performance question programmers application running slowly answer question types problems bottleneck parallel program represent potential bottlenecks hypotheses tests hypotheses correspond bottlenecks program synchronization bound tests boolean functions program exhibits specific performance behavior related hypothesis time spent synchronization searching axis iterative process select hypothesis conduct test true refinements hypothesis test hypothesis application synchronization bottleneck hypothesis true refinements excessive synchronization due small work units high contention synchronization object excessive time spent waiting messages processes test hypotheses true dependence relationships hypotheses define search hierarchy axis hypothesis hypotheses pre-conditions anti-conditions relationships form directed acyclic graph searching axis involves traversing graph figure shows partial axis hierarchy current hypothesis application highioblockingtime bottleneck hypothesis reached concluding iobottleneck exists program hierarchical axis unique features system tools type problem memory bottlenecks synchronization tools display multiple types bottlenecks guide user search process define hypothesis true tests return true data collected continue verify tests conditions hypothesis remain true collect performance data definition true hypothesis working hypothesis meets test criteria confused statistical hypothesis scientific hypothesis connotations iobottleneck toplevelhypothesis frequentiooperations highioblockingtime figure sample hypothesis hierarchy structured model helps focus user problem bury details axis axis isolate type problem parallel application synchronization bottleneck large application synchronization operations search model find synchronization operation causing problem isolate bottleneck specific resource procedure lock search axis axis designed searched iteratively hierarchical organization separated hierarchies representing class resources parallel application synchronization objects code disks multiple levels hierarchy leaf nodes instances resources application left tree figure shows sample resource hierarchy root hierarchy synchronization objects level types synchronization semaphore message receive spin lock barrier spin lock barrier nodes individual locks barriers application children message receive node types mescompute object code cpus cpu frob main stuff synchronization objects individual locks barriers individual barriers locks spin semaphores group group individual semaphores individual msg recv message types figure sample axis class hierarchies highlighted object current focus oval objects defined performance consultant triangles static based application rectangles dynamically runtime identified sages 
disk writes behalf function func measured sas sentence activity notifications sas unnecessary execution costs code figure performance questions array activation notifications array sas pay runtime cost notification eliminate cost dynamically removing notifications executing code sentences ordered performance questions current definition performance question question messages summation syntactically equivalent question summations occur messages advantage sentence order performance questions distinguish performance questions summary chapter important problems collecting storing communicating mapping information performance tools high-level parallel programming languages format interface static dynamic mapping information presented set active sentences method identifying complex dynamic activity mappings chapters present experiences techniques real program performance measurement tools paramap initial experiments model structure understanding performance characteristics high-level parallel language programs guide design implementation performance measurement tools initial evaluation model role gain experience mapping actual parallel language system built performance measurement tool fortran tool called paramap measures performance information nouns verbs levels abstraction fortran level runtime system level node level maps performance information levels code data views performance chapter describes design implementation paramap demonstrates tool actual fortran applications tool post-mortem tool compact data format record performance data describe paramap simple interface static dynamic mapping information implementation cmsystems finally present case studies paramap measure improve performance toy application real chemical engineering application studies find high-level performance data fortran parallel assignments parallel arrays mapping levels abstraction data views performance understanding improving execution characteristics applications paramap tool design paramap description fortran chapter measured nouns cmf level abstraction include subroutines statements arrays verbs include array assignment reduction subroutine execution statement execution rts level paramap measures cost array manipulations shift copy move node level paramap measures computation cpu utilization waiting broadcast communication point-to-point communication node level difficult measure directly cmcomputers approximate paramap measuring process time node-level routines perform point-to-point communications paramap simple interface give users post mortem access performance information user constructs sentences nouns verbs asks tool measured cost constructed sentences costs provided formats count number times sentence recorded total time cost sentence time plots showing cost sentence graphed time level abstraction separated interface current level selected user user constructs sentences nouns verbs current level paramap static dynamic mappings compute costs high-level sentences user asks cost sentence paramap map request explicit computations low-level compiler-generated functions called code blocks implicit runtime system activities shifting broadcasting array user selects sub-region array paramap provide information processors elements selected subregion stored paramap mappings implement contexts context set nouns verbs selected user purpose constraining performance information lower levels paramap user select array verb reduction cmf level tool create context user peels back layers abstraction moving rts node level paramap constrain set nouns verbs visible user nouns verbs map reductions constructing sentences paramap constrains performance information collected reductions contexts users evaluate low-level performance impact high-level nouns verbs implementation user instruments application program compiling paramap compiler driver driver standard fortran compiler automatically inserts probes subroutine boundaries sequential user object code links application instrumented version runtime system cmrts instrumented cmrts monitors rtslevel sentences control processor node-level sentences processor nodes performance information noun verb gathered formats count time time array time array discrete constant-size representation performance metric time implemented paramap time arrays group performance data bins represent equal intervals time application total time execution exceeds capacity time array paramap instrumentation library combines adjacent bins recovers half time array storage space counters timers time arrays constant size formats paramap record long-running executions amount space short executions paramap collects mapping information nodeand rts-level sentences explained cmf level fortran nouns verbs mapped lower levels static mappings functions parallel assignment statements collected compilation dynamic mappings array layouts collected execution stored post mortem analysis compiler optimizations obscure mappings fortran statements code blocks fortran compiler compiles statement individual code blocks co-optimizes resulting code blocks reduce total cost execution result single code block correspond fortran statements performance information gathered code block mapped statements map fortran statements co-optimized code blocks divide individual code block costs fortran statements method assumes equal portion code block computations performed behalf statement assumption hold cases heavyweight computation merged lightweight computation paramap joins groups co-optimized statements inseparable statement lists statement list simply group statements code blocks optimized paramap users select individual statement noun co-optimized statements statement lists selected paramap data views performance means paramap automatically summarizes classifies low-level computation communication high-level arrays processed array processed single low-level operation paramap splits cost equally array paramap users request costs entire arrays rectangular subgrids arrays tool maps requests processor nodes selected array subgrid stored paramap collects performance information node level granularity accurate performance information array subgrids partially overlap processor nodes user chooses subgrid partially overlaps processor node paramap asks user expand shrink subgrid fits array distribution perfectly paramap receives dynamic mapping information instrumentation runtime system records cmrts array distribution data structures called array geometries map subregions fortran arrays processor nodes geometry specifies shape size array determines array laid memory paramap instrumentation records array geometry array allocated associates geometry performance information recorded array processor nodes paramap instrumentation measures computation waiting communication costs associates measurements address low-level routine executed address array processed time costs split evenly arrays processed execution paramap instrumentation builds vector performance information set values low-level routine executed array processed node paramap maps node routine addresses routine names application symbol table maps array addresses array names associative table updated time control processor allocates array mappings paramap satisfy sentence queries noun verb user node-level computation maps array assignments involving array combinations supported memory required counters timers time arrays combinations large paramap unable provide costs node-level computation maps array assignments involving array line cmf code chapter demonstrate dynamic instrumentation remove restriction application executes instrumentation probes update counters timers time arrays memory application exits application exits instrumented cmrts collects performance mapping data processors stores file port mortem analysis measurement results section present results paramap study performance fortran applications study examines toy illustrates performance problem found fortran applications study examines real chemical engineering code demonstrates performance information attributed arrays information attributed code statements case compiled application maximum compiler optimizations linked paramap instrumentation executed node cmstudied performance information multiple levels abstraction finally changed source code reduce runtime studies show simple tool based model organize performance information 
children semaphore node semaphore groups application semaphore group individual semaphores components axis created times part axis defined statically part application starts part application execution static components top hierarchy dynamic nodes lower levels hierarchy root hierarchy resource class statically defined inside tool depending hierarchy nodes root statically defined levels hierarchy defined specific machine application selected step creates nodes types resources application types nodes created depend type machine shared memory message passing style parallelism application lowest levels hierarchy representing specific resource instances added application execution resource figure shows sample resource class hierarchies shape node defined oval nodes statically defined triangle nodes defined machine application selected rectangular nodes created application execution current status search axis called focus consists current state resource class hierarchy figure shows sample axis resource hierarchies highlighted nodes show current focus component hierarchy focus shown figure spin locks cpu procedure searching performance problems axis called magnifying focus magnify focus hierarchy independently magnifying focus step process pick resource class hierarchy magnify determine children current node select potential focuses restricting magnification subset children current node finally test true hypothesis potential focus tests criteria hypothesis met potential focus added current focus list discarded sample magnification starting focus shown figure select code hierarchy list children current node hierarchy procedures frob main stuff select test choose check finally run tests conclude current hypothesis holds frob results focus spin locks cpu procedure frob test true procedure added focus axis axes isolate performance problem specific type bottleneck specific resource performance parallel programs varies parts execution program phases purpose axis isolate performance bottlenecks specific time intervals execution explain axis based post-mortem model describe approximate model execution searching axis involves testing current hypotheses current focus focuses intervals time application execution start entire execution-time program iteratively refine search smaller sub-intervals time start entire program refine bottleneck initialization interval finally isolate problem sub-interval data read memory figure shows sample time-line program execution table showing start end interval start endinterval interval interval description entire execution initialization read data init nodes compute exchange compute output figure intervals program execution represent intervals time axis hierarchical structure root entire execution program children node sub-intervals node addition sub-intervals overlap figure shows axis hypothetical application initialization interval sub-intervals read data init nodes interval exchange overlaps compute intervals final interval output end computation restricted search initialization figure sample time hierarchy approximating post-mortem semantics difficult fully built hierarchy part hierarchy time program started current time sub-intervals user defined searched sample time interval shown figure interval starts point marked start interval continues decide start collecting data interval start collection performance data start collection point marked current time interval continues unknown length time end interval searching time interval introduces questions quickly easily define start interval start collecting data start interval long current time interval end interval handle missed data due selecting time interval started data start interval start collection user selects time interval ended start collection end interval start interval start collection time endinterval unknown length current happened observation minimum data interval data interval figure potential problems changing data collection execution implies sub-interval contained time intervals hierarchy dag tree question defining start interval partially user interface problem partially search problem simple approach problem present users time histogram showing metrics updated real time select start time intervals histogram solution simple problem user pay close attention program execution alternative permit user trigger predicates start time interval evaluate true provide library predicates user choose examples predicates time selected procedure called synchronization wait time selected threshold method requires direct involvement user existing correctness debuggers spider topsys similar predicates approach programmers annotate programs calls library routines major parts computation approach effective elegant requires programmer modify code prototype implementation manual definition add trigger predicates future question long interval post-mortem model requires performance data entire time interval determine bottleneck exists interval execution complete data interval make refinements sub-intervals re-execute application conclude hypothesis true time interval interval ends approximate result test cumulative performance data current interval selected current time interval continues data aggregation window grows require minimum observation time shown minimum observation figure interval conclude data valid prevents transient conditions start interval causing false conclusions approach permits evaluating multiple hypotheses interval ends aggregating long interval meaningful trends application performance potential problems data part interval tests hypothesis true based averaging data short time start interval true entire interval effect mitigated selecting long minimum observation time permit system enter steady state long minimum reasonable interval hypothesis true indication potentially interesting subinterval problem hypotheses true long interval time build momentum due increasing window size true false stop aggregation end time interval definition post-mortem semantics aggregate entire time interval momentum problem window aggregation bounded current time interval question start collecting data testing hypotheses time interval interval begun post-mortem model averages performance entire interval interval started calculate time missed information constraint minimum observation time requiring data collected minimum percentage time interval limits impact missed data cumulative average time interval ends additional data time interval missed fourth question user re-run application hypotheses interval automated guidance axes search model direct user find performance bottlenecks step choices refinements provide guidance selecting good refinements search model includes hints hints suggestions future refinements generated side effect testing earlier refinements axis hypothesis synchronization bottleneck return hint refine axis based synchronization objects hints important characteristics hints exist order refinements alter refinements hints violate orthogonality axes hint axis refer refinements axes hints helpful narrowing choices user make require user select refinement key component search model ability automatically search performance bottlenecks accomplished making refinements axes requiring user involved automated refinement manual user directed searching hybrid combinations manual automated searching selecting refinement step process determining refinements ordering refinements finally selecting refinements children current nodes axis hints order list refinements finally select refinements ordered list true item ordered refinement list important question automated refinement long evaluate hypothesis concluding test criteria met interesting problem searching application execution refinements current time interval ends define sufficient observation time typically times minimum observation time concluded hypothesis true waiting time interval hypotheses discontinuing testing hypothesis concluding false conclude refinement false data sufficiently large fraction time interval conclude matter remainder interval 
complex layered languages system identify important performance problems greatly improve runtime performance simple paramap analyze toy program shown figure page simple misaligned arrays significant performance problem common programs written fortran programmers row table figure shows execution time initial version program compared runtime serial version program row figure measured single processor sun sparc initial program appears inefficient analyze program paramap determine noun costs cmf level data views performance find array responsible majority total cpu time figure shows cost breakdown array assignments involving array cost breakdown maps noun verb sentence case sentence main assignment assignment operations involving array main lower levels summarizes lower level costs type mapping purpose lower level activity case assignments involving map small amounts explicit implicit computation time costs shown paramap tables aggregated nodes system individual values exceed total execution time entire application version execution time initial parallel uninstrumented min sec initial parallel instrumented min sec serial uninstrumented sec final parallel uninstrumented sec figure execution times small large amount implicit communication explicit computation costs include time spent computing values assignments involving implicit computation costs include time spent runtime system managing memory investigate implicit communications created context sentence main assignment moved node level node level found million node broadcasts mapped sentence main assignment figure knew million elements compute investigated broadcasts caused transfers data view investigate subregion matrix asked paramap refine context upper left quadrant assignments elements upper left quadrant line figure page paramap told shrink subregion left half subregion runtime system distributed row axis processors found million broadcasts mapped left half broadcasts figure costs assignments involving costs summed processor nodes map array mapped left half million elements compute concluded broadcasts send elements control processor computation figure shows time plot broadcasts mapped selected subregion display shows broadcasting subregion array occurred entire execution program improved program inserting array alignment pragma pragma align instructs compiler map alongside processor nodes result decrease program runtime shown fourth row figure alignment pragma computations line occur parallel transfers control processor figure time plot broadcasts map array sub-region events nodes map selected sub-region shown dual reciprocity boundary element method application parallel implementation dual reciprocity boundary element method drbem non-linear solution technique heat-transfer vibrationanalysis applications drbem non-linearities solved boundary integral problems boundary element methods relies green theorem reduce two-dimensional area problem one-dimensional line integral line-integral solved discretizing solving sets linear equations full drbem application comprised lines code spread source files applications reads initial conditions file sets system linear equations solves equations series time steps finally writes results file ran program large problem involving boundary elements interior elements time steps run-time initial parallel version shown row figure version time change initial min sec initial instrumented min sec cmssl gauss elimination uninstrumented min sec eliminate unused arrays uninstrumented min sec cmssl solver uninstrumented min sec cmssl inverse uninstrumented min sec uninstrumented min sec figure run-times parallel drbem rows show results implementing improvement separately row shows results applying improvements began analysis drbem application examining cmf level profiles verbs statement execution assignment figures verb statement execution maps execution code blocks generated compiler implement fortran statements verb assignment maps execution code blocks implicit runtime system activities allocation shifting rotating arrays profile lists nouns participated sentences involving verb nouns sorted cumulative costs measured sentences cumulative costs statement executions include explicit node-level computations map execution mapping implicit costs statement executions supported drbem examined implicit costs statement execution hand insure paramap omission information significantly affect distribution measurements statements cumulative costs array assignments include costs implicit explicit lower level activities map assignment figure statement execution profile drbem line numbers listed angle brackets represent groups statements merged compiler optimization execution assignment profiles illustrate data views performance localize performance problems statement execution profile figure shows statements file decomp fcm responsible explicit node-level computation application examining code decomp fcm found top array shown assignment profile main figure accessed statement listed execution profile decided concentrate array main accessed concentrate code line code decomp fcm processed main implementation gaussian elimination factorization cost breakdown main shown similar figure showed two-thirds node-level time mapped array spent point-to-point communication routines concluded gaussian elimination implementation caused point-to-point communications node-level computations decided gaussian elimination understood method implemented figure array assignment profile drbem table sorts fortran arrays cumulative explicit implicit costs linear algebra libraries replace entire subroutine call library routine replaced routine call vendor provided scientific software library cmssl gaussian elimination routine improvement reduced runtime application shown row figure figure shows large explicit computation costs lines file inverse fcm examined listed lines found array main listed assignment profile accessed lines important study processing main examine line displayed cost breakdown table figure found costs assignments involving main due point-to-point communication elements main spreading subsections main processors examined main lines identified operations point-to-point communications spreading array elements code lines part routine computed inverse matrix main routine advantage symmetries matrix found employing cmssl routine general matrix inversion improved execution time entire application shown sixth row figure array assignment profiles locating unused arrays unused arrays arrays programmer allocated runtime system program paramap cmf-level nouns recorded assignment sentences array assignment profile lists unused arrays bottom showing cumulative cost drbem application found unused arrays improved program eliminating code runtime savings shown fourth row figure memory savings amounted megabytes total final major performance problem involved sequential subroutine execution time subroutine execution time measured process time control processor measured subroutine application displayed profile subroutine execution found minutes spent subroutine solve subroutine implemented solution phase application apparently parallelized decided vendor provided cmssl parallel linear system solver improve runtime performance inserted cmssl solver place solve change reduced runtime program shown fourth row figure figure illustrates key aspects behavior drbem application time figure presents process time spent performing point-to-point communications elements arrays main main serial time spent subroutine solve figure shows implicit communications serial computations degraded performance application significant amount parallel processing resources machine particfigure cost breakdown assignment operations involving main table shows low-level operations involving array implicit caused communication ular minutes solve executed control processor processor nodes remained idle final line figure presents total savings achieved incorporating improvements listed summary simple tool based model great advantages studying performance programs 
result prototype implementation techniques search model implemented prototype system study ability search model identify performance bottlenecks dynamic on-the-fly data selection wanted compare amount performance data generated method existing trace based sampling approaches validate guidance supplied performance consultant studied application programs ipsperformance tools compared results prototype study applications splash benchmark suite database application experimental method test implementation includes hypotheses shown figure dealing cpu synchronization virtual memory bottlenecks full implementation system plan permit users create modify hypotheses tests program execution simplify prototype implementation wrote hypotheses tests functions compiled system created resource classes code process synchronization object means generally select refinements hypotheses axis refinements cases procedure level refinements implemented manual version axis figure display showing axes system provided infrastructure dynamic control instrumentation trace data generated ipsperformance tool simulated dynamic data selection benefit approach permitted compare quality guidance supplied dynamic selection full tracing addition ipsruns variety platforms making large set sample data tests ipsrecords event traces program execution event procedure call synchronization operation wall-clock process time-stamps addition event-specific data addition normal ipsinstrumentation ran programs external data collectors external data collectors dedicated sampling processes collect additional information tracing collector gathered information behavior operating system page faults context switch rate collected data hardware cache miss rates bus utilization pre-processed trace files uniform time histograms time histograms simulate real-time execution histogram bucket corresponds sample delivered system simulated execution-time tool evaluating tests performance data delivered system dynamic instrumentation approximated enabling disabling data collection refined axes search model started simulation data collected evaluate top level hypotheses entire application hypothesis considered refinement made axis data specific procedure enabled collection data evaluating tests looked performance data time interval data test enabled current time simulated minimum observation time evaluating tests performance data test enabled sufficient time technique gave good approximation dynamic instrumentation instrumentation model based periodically sampling performance counters running program counter records event program specific focus procedure call counter exists procedure program focus counter specific program spin locks counter lock lock procedure lock simulated enabling disabling data collection calculate number samples collected counter multiplying long counter enabled sampling frequency compare total number samples approach needed full sampling requires data counter sample time compare results full procedure synchronization tracing ipsa simple explanation option included prototype associate explanation function hypothesis hypothesis evaluates true user request explanation explanation function called simplest explanations consist print statements describe type bottleneck hypothesis sophisticated explanations report additional information program explanation cpu bottleneck prints gprof style profile table current focus axis prototype implementation interface users navigate search axes provide command line interface explanations bottlenecks found screen dump interface appears figure future plan expand interface incorporate realtime profile tables visualizations performance data prototype implementation consists lines finally note configured performance consultant study primarly interested ability tool automatically find bottlenecks ran system mode tool searches refines bottlenecks user interaction arbitrarily set minimum observation time samples seconds depending sample rate likewise sufficient observation time set samples seconds plan explore impact parameters future water water splash benchmark programs n-body molecular dynamics application simulates intraand intermolecular potentials water molecules liquid state program primarly spin locks synchronization ran program sequent symmetry processors processors performance small large input files program run processors ran seconds performance consultant identified cpu time bottleneck attempted parallelism spent productive cpu utilization performance consultant found bottleneck seconds computation unable refine hypothesis specific process procedure single process procedure responsible cpu time explanation cpu bottleneck hypothesis supplied cpu time profile listing procedures program percent time spent provided list procedures improve validate hypothesis ipstools found program cpu bound ran program larger input file processors ran seconds case performance consultant found program synchronization bound confirmed ipsthe performance consultant identify specific lock variable responsible synchronization waiting time total execution time processes specific advice performance consultant gave case study major bottleneck changed processors larger data set showed important study performance parallel programs real datasets desired number processors important question prototype volume performance data needed find bottlenecks figure shows summary performance data collected system compared full sampling column total counters shows number counters required event types focuses search model disposal counters total counters find program bottlenecks total samples shows number samples required counters sampled msec samples number samples collected counters enabled total counters total samples cpus counters samples figure comparison full sampling dynamic instrumentation water application figure compares volume sample data generated approach full tracing ipssamples number samples appeared figure compare dynamic instrumentation ipstracing needed figure big single sample dynamic instrumentation feel bytes reasonable size byes counter identifier bytes time stamp bytes shown column size trace size actual size trace file created ipsperformance tools ratio shows ratio ipstrace size size column dynamic inst trace cpus samples size size ratio figure comparison dynamic instrumentation tracing water size megabytes dynamic approach instrumentation reduced volume performance data collected program factor ranging times compared traditional methods interesting aspect technique appears processors case shown figure dynamic instrumentation counters total samples performance consultant isolating performance problem specific lock variable needed measure lock waiting time lock performance consultant discarded locks waiting sufficient observation time collect data lock entire execution locusroute locusroute splash benchmark programs vlsi tool routing standard cells computes area resulting layout ran program processors dismay performance consultant gave information program decided run ipson program happening ipsmetrics unable explain performance program finally looked volume performance data ipssystem creating discovered program makes lot procedure calls instrumentation overhead due procedure calls problem confirmed problem ways wrote test program overhead tracing procedure call ipsinvolved feature ipsthat permits turn procedure level tracing re-ran program performance consultant found cpu time bottleneck resulting program search model verify observed instrumentation overhead system acceptable added additional hypothesis identify instrumentation bottlenecks defined spending time instrumentation significant overhead additional hypothesis identify procedure call instrumentation overhead problem program early success idea search model test instrumentation significantly alters performance encouraging plan expand functionality full implementation figures show amount performance data collected locusroute hypothesis instrumentation overhead initial version bottleneck found refinements made counters required test initial hypothesis root axis collected time interval program execution collect data refinement made shows minimum amount data gathered approach case identified instrumentation bottleneck counters examined performance consultant isolate bottleneck single procedure case dynamic 
instrumentation reduces volume performance data collected factor compared full tracing total counters total samples version counters samples initial collection hypothesis figure comparison full sampling dynamic instrumentation locusroute dynamic inst trace version samples size size ratio initial collection hypothesis figure comparison dynamic instruementation tracing locusroute shared memory join shared memory join application implementation join function relational database implements hash-join algorithm shared memory inter-process communication program written study shared-memory shared-nothing join algorithms ran program dedicated processor sequent symmetry test case ran seconds performance consultant identified bottleneck program due excessive page faults page fault data collected external sampler process collected process procedure basis system directly isolate bottleneck specific procedure identify time program execution page fault bottleneck occurred shows search model precisely isolate performance problem axis case axis isolate problem flexible approach finding bottlenecks important feature work validate result ipsperformance tools previously studied program recognized page fault problem problems program problem due creation user data program small program reduced page fault behavior improved execution time figures show volume performance data generated shared memory join application program investigated changing simulated sampling interval change amount performance data collected sampled intervals msec msec msec reduced volume performance data collected compared ipsby factor msec reduced factor ratio data collected full sampling dynamic instrumentation factor change significantly changed sampling interval sample total counters total samples interval counters samples figure comparison full sampling dynamic instrumentation shmjoin sample dynamic inst trace interval samples size size raio msec msec figure comparison dynamic instrumentation tracing shmjoin lessons learned prototype implementation helped understand interactions components system realized hypotheses axis represented refinements axis wrote hypothesis hot highly contested spin locks realized trivially re-write hot synchronization objects meant types synchronization system manual searching bottlenecks recorded search path programmer based informal analysis logs define automated searching discovered refining axis searching axis finally axis helps reduce number options step easier understand refinements made random order hand system returned hint found plan continue study people manual refinement improve automated refinement confirmed intuition find bottleneck single program programs uninteresting bottleneck start execution report fact continue search rest execution demonstrated importance running programs full sized input sets toy files type bottleneck found water application changed ran larger dataset showed importance building performance tools scale real applications large scale parallel machines finally gained confidence approach proceeding full implementation showed identify isolate performance problems dynamic instrumentation searching based partial performance data addition reduction amount performance data collected typically factor means approach scale large machines fact feel larger machines longer running programs instrumentation loop level ratios larger performance data time related work prior work managing complexity volume performance data concentrated areas performance metrics visualization data collection performance metrics address user side performance problem reducing large volumes performance data single values tables values metrics proposed parallel programs critical path npt mtool gprof metrics provide information earlier paper compared metrics variations concluded single metric optimal programs discover factors select metrics application balanced processes similar amount work large amount synchronization influences metrics search model identify characteristics program user select metric view approach complement enhancement performance metrics replacement technique manage amount performance data user visualization visualization presents large amounts performance data graphical aural problem visualizations finding specific type bottleneck tools provide rich library visualizations paragraph twenty visualizations displays configured plot values resources cpu disk utilization user left formidable task selecting visualizations resources display system improves situation associate visualizations resources specific types performance problems user select visualizations explain performance problem approaches proposed address problem efficiently collect performance data approach define set predicates describe interesting events program collect data events satisfy predicate edl issos bee approach static set predicates entire program execution lack fine granularity control approach bee permits dynamic control predicates provide guidance predicates select approach build special hardware collect performance data sequent symmetry cray y-mp provide set pro-- gramable counters collect performance data systems collect data counters user left select collect addition interesting events visible hardware data collectors approach multikron tmp hypermon build hardware generates trace data sends data reduction node file hardware-assisted trace generation eliminates perturbation cpu inter-connection network makes easy generate data swamps file system data analysis station system provide high level decision support performance parallel programs atexpert cray research rules recognize performance problems fortran programs tool solves special case problem address fortran programs automatically parallelized compiler addition post-mortem tool address reduce volume data collected conclusions presented approach called search model design performance tools addresses problems efficiently collect performance data provide users guidance find bottlenecks prototype implementation system presented case study based prototype preliminary studies showed technique reduce volume performance data collected orders magnitude based results prototype implementation started build full scale implementation thinking machines cmand plan develop version intel paragon future creating infrastructure dynamic instrumentation machines addition plan enhance graphical interface performance consultant anderson lazowska quartz tool tuning parallel program performance proc sigmetrics conference measurement modeling computer systems boston bates wileden edl basis distributed system debugging tools hawaii international conference system sciences january bemmerl bode braum hansen tremi wismuller design implementation topsys tum-info- technische universitat munchen july bruegge portable platform distributed event environments proc acm onr workshop parallel distributed debugging santa cruz appears sigplan notices december unicos file formats special files manual srcray research unicos performance utilities manual srcray research dewitt gerber multiprocessor hash-based join algorithms proc vldb conference stockholm sweden august goldberg hennessy performance debugging shared memory multiprocessor programs mtool proc supercomputing albuquerque nov graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june heath etheridge visualizing performance parallel programs ieee software september hollingsworth irvin miller integration application system based metrics parallel program performance tool proc acm sigplan symposium principals practice parallel programming williamsburg april appears sigplan notices july hollingsworth miller parallel program performance metrics comparison validation supercomputing minneapolis november malony reed hardware-based performance monitor intel ipsc hypercube international conference supercomputing amsterdam june miller clark hollingsworth kierstead lim torzewski ipsthe generation parallel program measurement system ieee transactions parallel distributed systems april mink carpenter nacht roberts multiprocessor performance measurement instrumentation ieee computer september schwan ramnath vasudevan ogle language system parallel programming ieee transactions software engineering april singh weber gupta splash stanford 
parallel applications shared-memory computer architecture news march smith debugging techniques communicating loosely-coupled processes phd thesis rochester december thakkar personal communication wybranietz haban monitoring performance measuring distributed systems operation sigmetrics santa mexico yang miller critical path analysis execution parallel distributed programs int conf distributed computing systems san jose calif june 
written high-level parallel languages paramap answered performance questions easily answered tools data views performance quickly localize primary performance problems examined runtime system processor activities maintaining high-level arrays sub-sections arrays evaluate low-level results array operations specific examples type analysis include localization broadcasts portion array section attribution point-to-point messages important arrays section figure time plot cpu time entire initial parallel drbem application display shows primary runtime contributors point-to-point communications map arrays main main sequential execution routine solve paramap finds problems found simple profilers sequential processing bottlenecks subroutines employing mapping functions providing access array information providing time plots performance data paramap programmers traditional performance measurement analysis techniques study difficult problems found providing performance information fundamental constructs language parallel arrays fortran good step understanding application performance located array high performance costs paramap drop runtime system node level evaluate object impact system tool determine cumulative costs due programmer explicit requests computation programmer implicitly unknowingly caused extra runtime activity type analysis represents departure high-level language tools provide information exclusively language level model dynamic instrumentation provide source-level views performance ability peel back layers abstraction data views performance performance tool flexible paramap tool provided important insights problem building tools high-level parallel programming languages limited static instrumentation gathering performance data mapping information static performance instrumentation limits performance data small amount collected runtime large perturbations execution performance large amounts disk storage expensive performance analysis similarly static mapping instrumentation limits relationships levels abstraction tool dynamic instrumentation dynamic mapping information tools exact mapping information chapter discuss paradyn parallel program performance measurement tool describe paradyn features support source-level performance data mapping performance data levels abstraction data views performance describe design paradyn dynamic performance instrumentation describe extended paradyn interfaces static dynamic mapping information interfaces paradyn language system provide mapping information describe paradyn imports static mapping information fortran compiler dynamic mapping information runtime system finally describe performance measurement experiments real fortran applications measured previous chapters experiments paradyn examine cmf-level views performance peel back layers abstraction needed examine data views performance find data views performance consistently combination code views helping explain performance characterisitcs data-parallel programs attempt improve performance application cases achieve significant execution time improvements range input sizes paradyn parallel program performance measurement tool paradyn performance measurement tool dynamic instrumentation measure performance data requested users paradyn starts application executing waits user requests measure performance metrics instruments running application rewriting application executing binary image sends stream performance measurements back user limiting instrumentation requested data paradyn greatly reduce instrumentation intrusion users measure large long-running applications large-scale parallel computers paradyn includes performance display modules users view performance metric streams graphically execution applications paradyn includes automated module called performance consultant users find performance problems applications performance consultant formal search strategy automatically find notify user performance problems sub-sections discuss basic characteristics paradyn important understanding enhancements high-level parallel programming languages comprehensive discussions paradyn design implementation found resources metrics resource paradyn basic abstraction structural information applications systems resource similar noun model represent objects machines processes procedures synchronization objects paradyn requires resources grouped orthogonal hierarchies figure resource hierarchy serves purposes organizes similar resources easy users locate manipulate resources related hierarchically figure quickly locate procedures contained module mod code figure resource hierarchies focus selection code processes machines mod modn hierarchy resource hierarchy paradyn performance consultant structure search performance problems performance consultant finds performance problem exists source code module modn refine location problem measuring individual procedures modn collect performance data user select focus metric focus consists resource orthogonal resource hierarchies canonical representation requested object figure selected resource resource hierarchies focus selection represents procedure module modn process machines paradyn automatically constrain performance measurements focus selected processor selected procedure metric paradyn basic abstraction measurable performance quantity metrics paradyn similar verbs model represent application activities primary difference verb describes activity measured metrics verb representing procedure execution correspond paradyn metrics procedure calls cpu time metric counts procedure executions metric times procedure executions paradyn includes set standard metrics users add descriptions collect metrics request performance data user chooses list focuses list metrics asks tool collect performance data focus metric pairs tool inserts instrumentation request inserting monitoring code running application binary image sends stream performance data back user users include external visualization modules automated analysis modules performance consultant human users interact paradyn graphical user interface system structure paradyn structured graphical user interface performance consultant performance visualizations execute user workstation parallel application program executes remote parallel system block diagram shown figure presents basic system structure paradyn section briefly describe paradyn primary structural elements sections describe enhancements support high-level parallel programming languages figure basic structure paradyn application processes daemon data manager gui application processes daemon visualization visualization application processes shown bottom figure include processes user wishes measure execute machine rest paradyn separate machines application processes started controlled paradyn daemon processes paradyn daemons control application processes handle low-level architecture-dependent details dynamic instrumentation process application symbol tables resource information transport performance data paradyn front-end paradyn fundamental representation application program contained data manager data manager exports resource hierarchies metrics parts paradyn control application processes accepts requests performance data sends streams requested performance data data manager interface focus paradyn capabilities handling high-level parallel programming languages types modules data manager interface performance visualization modules called visis request performance data graphically display resulting streams performance data forms time-plots barcharts tables users build external visi programs display data ways performance consultant data manager interface request performance data wishes test hypothesis existence location performance problem subsequently analyzes returned performance stream determines hypotheses valid forms hypotheses continues search finally paradyn graphical user interface users communicate data manager control process execution users start processes pause running processes continue execution paused processes source-level performance data paradyn basic structure paradyn supported performance measuutilities language pretty-printer utility program tested subjected types input streams types inputs intended test variety errors triggered utilities testing major variations test data including non-printable control characters including null byte maximum length input stream tests summarized table utility vax sun aix sequent adb awk bib calendar cat lib ccom checkeq checknr col colcrt colrm comm compress lib cpp csh dbx deqn deroff diction diff ditroff dtbl emacs eqn expand fmt fold ftp graph grep grn head ideal indent join latex lex lint lisp table list utilities tested systems tested part utility crashed utility hung crashed sunos sunos crashed sunos utility unavailable system utility caused operating system crash utility vax sun aix sequent mail make nroff pic plot prolog psdit ptx refer rev sed soelim sort spell spline split sql strings strip style sum tail tbl tee telnet tex troff tsort uniq units vgrind yacc tested crashed hung table list utilities tested systems tested part utility crashed utility hung crashed sunos sunos crashed sunos utility unavailable system utility caused operating system crash input streams interactive utilities slightly characteristics avoid overflowing input buffers terminal device input split random length lines terminated newline character length characters input length parameter number lines scaled factor results analysis tests unix utilities produced surprising number programs crash hang section summarize results group results common programming errors caused crashes input streams non-interactive utilities character types null character input stream size bytes printable nonprintable printable nonprintable printable nonprintable printable printable printable printable nonprintable printable nonprintable printable nonprintable printable printable printable table variations input data streams testing utilities non-interactive utility programs input streams interactive utilities character types null character input stream size strings printable nonprintable printable nonprintable printable nonprintable printable printable printable printable nonprintable printable nonprintable printable nonprintable printable printable printable table variations input data streams testing utilities interactive utility programs show programming practices caused errors side comment noticed tests programs crash terminate error message message difficult interpret basic test results summarized table result notice crash hang significant number utility programs system included list programs commonly utilities emacs popular screen editors csh c-shell programs document formatting detected types error results crashing hanging program considered crashed terminated producing core state dump file considered hung continued executing producing output input program considered hung continued produce output input stopped hung programs typically allowed execute additional minutes hung state detected programs blocked waiting input considered hung table summarizes list utility programs crash hang categorized crash showing systems crash programs notice utility crash system result due reasons reason differences processor architecture vax incorrectly tolerate null pointers architectures sun reason systems differences versions utilities local improve degrade utility reliability internal structure external specification utilities change system system interesting note commercially tested aix unix susceptible versions unix type errors tested grouped crashes categories pointer array errors checking return codes input functions sub-processes interaction effects bad error handler signed characters race conditions undetermined categories discuss error show code fragments examples error present implications error suggest fixes problem note noted text crashes hangs discovered automatic testing array input subinteraction bad error signed race source utility pointer ncrc functions processes effects handler characters condition code unknown adb vshx vxad vhxad lib ccom col vshxad csh vshra vshra deqn deroff vshad diction vhd ditroff emacs vsh eqn shx ftp vshad indent vshd join lex vshxad vshxd make nroff plot prolog vsh ptx shxd refer vshd spell vshxad style vhd telnet vshad tsort vshxad vshd uniq vshxad units vshxad vgrind table list utilities crashed categorized letters system crash occurred table pointer arrays class pointer array errors case program sequentially access cells array pointer array subscript checking exceeding range array common programming errors found tests shows error character input getch string easily fixed check maximum array length terseness programming style carried extremes form emphasized correct function ability overflow input buffer potential security hole shown recent internet worm class pointer problems caused null pointer prolog interpreter main loop incorrectly set pointer assumed valid pass loop crash caused type error occur places machines vax null pointer valid reads data location data accessed machine instructions field incorrectly accessed data pointer crash occurs machines sun null pointer error program crashes immediately path pointer set obvious extra checking needed assembly language debugger adb null pointer case pointer supposed global variable set module external global definition accidentally omitted variable declaration module expected pointer module referenced uninitialized unix pointer pointer errors bad pointer bad address write variable unintentionally overwrite data code location unpredictable error manifest tests crash lex scanner generator ptx permuted index generator examples overwriting data crash underlining text overwriting code crash assembler originally appeared result improper input routine crash occurred call standard input library routine ungetc returns character back input buffer ahead processing actual ungetc redefined program macro similar function macro error checking system version ungetc allowed buffer pointer incorrectly set macro original routine easy forget differences checking return codes checking return codes sign careless programming favorable comment current state unix examples error tests crash adb assembly language debugger col multi-column output filter ascii terminals utilities error adb interesting programming practice avoid code fragment represents loop adb procedure called loop format line lastc rdc input line rdc readchar lastc lastc return lastc initial loop reads characters terminating end line rdc routine calls readchar places character global variable named lastc rdc skip tab space characters readchar unix file read kernel call read characters readchar detects end input file set lastc rdc initial loop check end file end file detected middle line program hangs speculate end file check initial loop program author thought end file occur situation awkward handle end file location difficult program requires extra tests flags complex loop conditions possibly goto statement problem made complex diagnose extensive macros code fragment macros expanded macros made easier overlook extra test end file input functions cases character input routines loop program store locations past end array input routines read entire strings vulnerable main holes internet worm entered routine routine takes single parameter pointer character string means bounds checking tests crashed ftp telnet utilities scanf routine vulnerable input specification unbounded string field 
rement programs constructed single base level abstraction default resource hierarchies procedure process machine synchronization objects permit natural organization resources parallel programming languages level abstraction supported mechanism adding types resources support source-level performance data paradyn widened data manager interface support multiple levels abstraction allowed users switch levels abstraction paradyn graphical user interface added static mapping information interface paradyn daemon added dynamic mapping information interface paradyn dynamic instrumentation library block diagram figure shows relation paradyn structure 
shown figure primary paradyn involve data manager data manager supports arbitrary number abstractions resource hierarchy exported data manager belongs level abstraction model focus defined include resource resource hierarchy level abstraction metrics cpu time synchronization waiting time belong abstraction levels metric combined focus level abstraction focus metric form nonsensical pair request measurement procedure calls parallel array data manager signal error internally data manager understands dynamic static mappings user requests focus metric measured directly request high-level language focus metric pair data manager mappings translate request equivalent request consisting focus metric pairs measure directly passes mapped focus metric pairs paradyn daemons generation instrumentation requests mapping performance data levels abstraction paradyn receives information levels abstraction resources metrics mapping information interfaces paradyn daemons import static mapping information paradyn information format pif files load application executable pif figure updated paradyn structure data manager gui application processes daemon dynamic static abstractions resources metrics mappings language-specific visualizations sum forall sum forall mappinginformation mapping information files emitted compilers programming environments external sources define source-level language code data objects contained application pif files tools explain paradyn map requests high-level language resources metrics requests base resources metrics functions cpu time pif format external tools communicate descriptive information resources metrics paradyn language-dependent application-dependent visualization modules receive descriptive information add meaning visual displays paradyn dynamic instrumentation library sends dynamic mapping information paradyn daemon process communication channel performance data dynamic instrumentation library linked application program measured paradyn interface procedures application describe mappings executes dynamic instrumentation library sends mapping information paradyn daemons daemons forward mapping information data manager data manager dynamic mapping information static mapping information paradyn dynamic performance instrumentation techniques turn turn flow dynamic mapping information dynamic instrumentation applications avoid cost emitting mapping information run paradyn paradyn users turn mapping information collection needed paradyn users turn turn dynamic mapping instrumentation points eventually tie enabling disabling individual mapping instrumentation points requests performance information fortran-specific resources metrics static dynamic mapping interfaces paradyn measures important resources metrics unique fortran runtime system cmrts section describe details paradyn measures performance data fortran parallel assignment statements parallel arrays measures cmrts-specific activities broadcast messages point-to-point messages reductions argument processing performance data parallel arrays arrays fundamental source parallelism data-parallel fortran data objects memory nodes cmsystem performance fortran program depends greatly efficiency computation communication arrays paradyn measures fortran arrays step process paradyn dynamic instrumentation library detects array allocations deallocations forwards resource mapping information paradyn array allocated call cmrts allocation routine dynamic instrumentation library notifies paradyn array establishes unique identifier array tells paradyn dynamic mapping interface section subregion array stored node system paradyn information build cmfarrays hierarchy shown figure figure shows module bow fcm functions corner arrays arrays corner called tot expanded show subregions step occurs user requests performance metric array user chooses array measure paradyn data manager maps array proper cmrts identifier system node sends message parallel debugging interface dynamic instrumentation set active sentences sas section module located node system sas module sets boolean variable true requested array active sets variable false array inactive cmrts node code block dispatcher notifies sas array activation deactivation sending input arguments node code block sas sas searches arguments arrays requested paradyn figure cmf-level axis collect metrics paradyn dynamically inserts instrumentation code node-level subroutines metric measured array dynamically-inserted instrumentation code checks array node-global boolean variable discussed measuring metric paradyn constrain metric array interest paradyn easily existing visualization modules time plots bar charts tables visual display performance information data objects visualization modules simply treat data object resource paradyn visualization interface open build specialized visualization modules advantage properties geometric structure unique arrays parallel code constructs parallel code constructs fortran programmers manipulate parallel arrays code constructs include parallel assignment statements forall iterators intrinsic operations sum min transpose paradyn measures parallel code constructs mapping statement node code blocks implement paradyn receives mapping information pif files section create fortran pif files simple utility parses fortran compiler output files utility scans compiler output files lists parallel statements parallel arrays node-code blocks produces pif file defines statements arrays paradyn describes mappings statements code blocks paradyn user interface displays statements cmfstmts hierarchy axis display shown figure users interact axis display choose resources cmfstmts hierarchy cmfarrays hierarchy combination hierarchies users choose resources hierarchies cmrts-level abstraction base level abstraction cmrts metrics paradyn dynamic instrumentation system includes language describing measure metrics language called metric description language mdl users precisely turn process-clock timers wall-clock timers increment decrement counters paradyn compiles descriptions code inserted running applications precisely moment metric requested mdl define metrics specific fortran cmrts shown table figure table lists metric description metric measures metrics constrained parallel arrays subsections arrays parallel assignment statements combinations assignment statements arrays metrics cover activities verbs understand performance fortran applications measurement fortran programs demonstrate realistic situations concepts presented earlier chapters tool chapter evaluated paradyn support fortran tool performance experiments real fortran application codes section describe applications measurements applications paradyn performance information improve applications conclude performance information metric description computations computation time count computation operations time spent computing results reductions reduction time summations summation time maxval count maxval time minval count minval time count array reductions time spent reducing arrays count array summations time spent summing arrays count maxval reductions time spent computing maxvals count minval reductions time spent computing minvals array transformations transformation time rotations rotation time shifts shift time transposes transpose time count array transformations time spent transforming arrays count array rotations time spent rotations count array shifts time spent shifting arrays count array transposes time spent transposing arrays scans scan time count array scans time spent scanning arrays sorts sort time count array sorts time spent sorting arrays argument processing time time spent receiving arguments cmcontrol processor broadcasts broadcast time count broadcast operations time spent broadcasting cleanups cleanup time count resets node vector units time spent resetting node vector units idle time time spent waiting control processor node activations count node activations control processor point-to-point operations point-to-point time count inter-node communication operations time spent sending data parallel nodes figure paradyn metrics fortran applications double lines separation cmf-level cmrts-level metrics node-level verbs helps explain performance problems fully understood cmf level abstraction data views performance 
add perspective performance studies fortran applications cases data views localize performance problems parallel arrays problems diffuse code views vibration analysis bow application called bow simulates oscillations bowed violin string application study variables initial transients bowed strings frictional interaction bow-hair string interface stiff strings code consists approximately lines fortran code contained single source file varying input parameters control resolution simulation length simulation simulation initial conditions code provided robert schumacher professor physics carnegie mellon began study bow examining performance characteristics application shown figure figure shows time plot primary cmf-level metrics cmf overhead run node partition cmsystem metrics constrained module subroutine statement array collected program total time measured paradyn cpus display figure shows rts-level node-level overhead costs dominate execution bow computation time significant cmf-level metrics accounts fraction cpu resources application display cmallocates full time quantum process ready run cms parallel nodes process requires full time quantum paradyn daemon process allocated full time quantum rarely requires full time quantum complete work application measured paradyn cmis allocated half total cpu time shows computation time metric uniform entire execution concluded majority application execution spent rts-level node-level activities identify lower-level activities consumed majority cpu time bow peeled back layers abstraction examined cmrts-level node-level performance data shown figure figure shows cmf-level computation time metric measurements idle time time spent waiting cmcontrol processor argument processing time time spent receiving parameters node-level code blocks node activations frequency activation parallel nodes control processor figure cmf-level performance data bow scan time reduction time entire execution display cost processing arguments idling higher cost computing rate node activation high microseconds node measurements suggest computation activated nodes small computation performance data shown figure led application partitioned properly application computational grain-size small cmwe knew program authors efficiently distributed aligned program data virtually costs node-to-node messages broadcasts shown large amounts idle time argument processing time node activations figure node-level performance data bow control processor spends large amount time deciding parallel nodes nodes spend time finishing tasks machine waits control processor time data view performance determine arrays involved computations displayed computation time arrays shown figures time plots figures show computation time metric constrained arrays account computation activity application find arrays examined computation time metric dozen parallel arrays statements shown figures stood top users computation resources discovered shown time spent computation arrays small concurred earlier hypothesis computational grain-size small figure performance righthand convolution matrices looked code manipulated arrays found loops shown figure immediately code achieving full parallelism code fragment part convolution small matrix multiplied row row larger matrix column row calculated parallel row computed sequentially immediately added running vector sum rows rarely long computing separately provide work computation outweigh implicit costs starting parallel nodes sending arguments computation application execute efficiently cmhardware figure performance lefthand convolution matrices aleft lenl aleft aleft histl ibackl crleft end figure original convolution code lines code increase grain-size altered code rows columns convolution matrix executed parallel shown figure code fragment shows allocate temporary array store intermediate values intrinsic parallel sum operation calculate final result vector storage required temporary vector small large size convolution matrix results time plot shown figure figure shows execution time application reduced substantially result idle time argument processing time reduced substantially computation time increased substantially curves parallel nodes spend time work time waiting control processor sum time curve figure shows portion computation time due summations determine improvements bow range input parameters ran versions application input sets paradyn attached results shown figure table shows actual reduction execution time uninstrumented application improves slightly increased iteration size reduction close change predicted examining figure figure runs paradyn lenl histl lenl crleft lenl aleft sum dim figure improved convolution code measurements bow application suggest source-level views augmented lower level views performance demonstrated perfectly parallel application high node-level initialization costs spread thinly parallel nodes fortran execution model cmsmall grain-size frequent node activations large amounts idling nodes wait control processor large proportions time spent receiving code-block arguments control processor computation periods nodes paradyn allowed describe measure display performance node-level implicit activities data views performance relative code views focusing parallel data structures fine-grained computations fine-grained computations diffused statements localized parallel arrays figure paradyn display improved bow performance problems potential improvements bow application costs implicit activities shown idle time argument processing time curves figure significant costs related implicit activities peaceman-rachford pde solver peace application called peace partial differential equation solver peaceman-rachford iteration method peaceman-rachford method factor penta-diagonal equations implementation written vincent ervin associate professor mathematics clemson code consists approximately lines fortran code spread files control execution program varying number variables equation altering convergence coefficient varying number iterations began analysis peace examining costs cmf-level verbs time plot shown figure display shows application distinct phases execution substantial change computation time array transformation time phase iteration count original improved percent change min sec min sec min sec min sec min sec min sec min sec min sec min sec min sec figure execution times original improved bow times uninstrumented executions program figure cmf-level performance peace figure node-level view performance peace boundary approximately ten minutes forty seconds execution phase exhibits low costs cmf-level verbs high overhead costs phase shows parallel node utilization cmf-level verbs investigated implicit node-level costs phase moving cmrts level abstraction displaying metrics shown figure display shows high costs implicit verbs processing parallel code block arguments broadcasting activating parallel code blocks time spent actual computations phase phase application spends larger percentage time computing communication processor nodes investigated phase bow incurred high costs initializing parallel nodes cmwe visualization displays shown find node activations phase due broadcasts small amounts data broadcast activation information costs waiting control processor activating nodes receiving code block arguments control processor artifacts broadcasts examined code views data views explain broadcasts identify data broadcast constrained measurements broadcast activity data structures cmf level data view figure shows parallel arrays broadcast order broadcast costs parallel arrays array conode broadcast exclusively minute broadcast concurrently arrays rconode bconode examined code find conode computed special routine parallel assignments sequential iteration loops rconode bconode computed elements conode code perform computations conode rconode bconode included forty lines code spread procedures files figure node-level broadcasts constrained cmf-level arrays input size 
tsort topological sort utility fscanf input precedes input format field specifies unbounded strings program precedes declared small lengths characters place bound string field specification solving problem sub-processes code write carefully designed written follow good rules writing programs make program part program unix utilities execute utilities part work diction style utilities call deroff calls csh vgrind calls troff sub-processes called direct access raw input data stream vulnerable erroneous input access sub-processes carefully controlled insure program input sub-process checked alternatively utility programmed tolerate failure sub-process difficult interaction effects interesting errors discovered result unusual interaction parts csh careless programming string vax version csh crash string hang continuous output space characters versions csh triggers csh command history mechanism repeat command began find command csh forms error message string form event found string passed error printing routine string parameter printf function parameter printf include format items denoted describes floating point printed field characters wide format item expects additional parameter printf csh error supplied expected string generated normal random testing string path csh print floating point field characters wide seemingly infinite loop printf routine attempt pad output field sufficient leading space characters string generated hand discovering string errors prevented substituting printf call simple string printing routine puts printf historical reasons space efficiency error printing routine assumed passed strings safe print bad error handler intentions reach completion units program detects traps floating point arithmetic errors error recovery routine increments count number errors detected control returned faulty code error recurs resulting infinite loop signed characters ascii character code designed codes fall range represented bits equation processor eqn depends assumption characters read array signed -bit integers default signed unsigned characters varies compiler compiler characters compute hash function -bit character read negative number result erroneous hash index hash table range problem easily fixed unsigned values character buffer sophisticated language characters strings identified specific type related integers error crash versions adb consequence error depends address space accessed bad hash error considered subcase pointer array errors race conditions unix signal mechanism program asynchronously respond unusual events events include keyboard-selected functions kill program control-c kill program core dump controland suspend program control-z programs interrupted suspended process control characters directly taking intermediate action terminating suspending programs make cursor motions features terminal examples programs directly process special characters programs start executing place terminal device state overrides processing special characters programs exit important restore device original state program emacs receives suspend character appears ordinary control-z character triggering suspend signal emacs reading control-z reset terminal original state respond suspend terminate signals clean internal data structures generate suspend signal kernel stop program controlcharacter received input steps program terminate generating core dump race condition inherent unix signal mechanism process reset terminal exit atomic operation programs subject problem problem programs processing steps providing smaller window vulnerability undetermined errors columns table list programs source code determined crash conclusions project started simple experiment understand observed phenomenon programs crashing noisy dial-up line result testing comprehensive list utility programs versions unix appears isolated problem offer tangible products result project provide list bug reports fix utilities crash make qualitative improvement reliability unix utilities provide test method tools simple surprisingly effective claim tests exhaustive formal verification required make strong claims estimate bugs found program simple testing technique discovered wealth errors commonly term formal procedures tests discover errors easily found traditional testing practices conclusion based results testing aix unix comments results examination results tests exposed common mistakes made programmers mistakes things experienced programmers occasional reminder helpful inspection errors found suggested guidelines array checked valid bounds argument range checking full-time pointer-based array checked spoils terse elegant style experienced programmers correct programs elegant incorrect input fields bounded extension guideline unix length specification input format bad idea check system call return values checking error result response error result awkward pointer values checked paths obvious extra sanity check catch unexpected problems judiciously extend trust careful programmer program make data feed checked called defensive programming redefine eventually forget redefinition subject problems occur hidden differences argument excessive procedure overloading languages ada error handlers handle errors routines tested introduce errors obfuscate goto statements generally bad idea dijkstra observed years ago programmers difficult convince search bad pointer prolog interpreter main loop complicated interesting weaving control flow caused goto statements comments lurking bugs interesting questions buggy programs unix section commentary speculation considered editorial factual personal experience noticed encounter bugs programs ignore bugs crashes reasons difficult isolate activity caused program crash quicker slightly method current job find report bug part informal survey unix user community department comprising researchers staff students hundred unix workstations asked encountered bugs reported asked severity bugs reported users responded survey reported finding bugs report two-thirds bugs commentary users speaks quotes responses users research tool involved figured complicated changing parameters core image dbx crash preventing deal problem experience largely useless report bugs supply algorithms reproduce haven reported recovery error fast easy time effort wasted due single occurrence bug smaller time needed report don generally report problems impression years security hole mail no-one chalk time event user mistake forever fix users easy received response survey stated encountered bugs unix software number bugs unix explained evolution unix suffered features important testing mentality early years research-only tool commercial effort required complete testing part environment berkeley unix system tastes great filling competition forced race features power performance absent debate discussion reliability claims industry version system support compared product support unix dealing user complaints releasing significantly reliable product unix singled buggy operating system strengths make weaknesses visible testing programs unix easy mix-and-match modularity provided pipes standard systems undergo similar tests conclusion made unix reliability compared systems experiments left perform tested utilities directly accessible user network services receive attention simple matter construct portjig program analogous ptyjig connect network service feed output fuzz generator area examine processing command line parameters utilities simple construct parmjig start utilities command line parameters generated randoms strings fuzz generator area study operating systems unix pipes make simple apply techniques utility programs tested systems random strings fuzz file file program input comparison systems provide comprehensive statement operating system reliability fourth area random testing find security holes testing 
involving sending programs random sequences non-random key command words step fix bugs found re-apply tests re-testing discover program errors masked errors found study rounds testing needed reach limits tools making testing tools generally invite duplicate extend tests initial results coming researches match experiences report source code related papers note source binary code fuzz tools unix windows web page ftp grilled wisc fuzz recent papers repeat original tests applications unix platforms testing network services x-window applications found ftp grilled wisc technical papers fuzz-revisited pdf study applying fuzz testing techniques applications running windows found ftp grilled wisc technical papers fuzz-nt pdf acknowledgements extremely grateful jerry popek phil rush jeff fields todd robertson randy fishel locus computing corporation providing facilities support test aix unix system grateful matt thurmaier computer classroom madison wisconsin providing technical support citrus -based xenix machine dave cohrs locating race condition caused emacs crash people computer sciences department time respond survey suggestion random testing find security holes due anonymous referees dijkstra goto statement considered harmful communications acm march rochlis eichin microscope tweezers worm mit perspective communications acm june spafford internet worm crisis aftermath communications acm june wood gibson katz verifying multiprocessor cache controller random case generation computer science technical report ucb csd california berkeley january pipe fuzz utility read write write read dev ttyp dev ptyp utility ptyjig pipe fuzz figure output fuzz piped utility figure fuzz ptyjig test interactive utility dev ttyp pseudo-terminal device dev ptyp pseudo-device control terminal 
highsyncblockingtime syncbottleneck toplevelhypothesis syncbottleneck frequentsyncoperations highsyncblockingtime highsyncholdingtime highsynccontention barriers individual barriersindividual message tags synchronization objects compute object machines host frob main client stuff server code messages synchronization objectsa messages barriersa barriers messages messages host paradyn paradynd pvmd appl appl paradynd pvmd appl appl paradynd appl appl pvm host pvm host tmc create appl process start message notify paradyn start complete connect pvmd paradyn paradynd pvmd appl appl syncbottleneck syncbottlenecka excessiveblockingtimea msgtaga spmd dowork poonaa process spmd poona process spmda poonaa process spmd poonaa 
original improved percent change min sec min sec min sec min sec min sec min sec min sec min sec min sec min sec figure execution times original improved peace improved peace replacing code computed conode rconode bconode set parallel loops compute arrays simultaneously code eliminates broadcast activity greatly reduces execution time phase application time plots improved application shown similar phase displays shown figures measure effect ran original improved versions peace input sets varied size results shown figure show improvements reduce execution time range input sizes phase peace limited rts-level node-level implicit costs scale problem set sizes costs implicit activity decrease comparison costs cmf-level explicit activity summary displays barchart shown figure computations array shifting account processing time application figure arrays shfter account costs arrays accessed places code equal cost code locations attempted improve sections code experiment source-level views performance lower-level metrics data views performance helped find fix significant performance problem peace application techniques helped point region execution performed poorly nodelevel symptom poor performance cmf-level node-level activities bow application data views performance helped code views performance problem localized arrays diffused statements code particle simulation psicm application called psicm three-dimensional particle simulation code computational fluid dynamics studies hypersonic flow studies plume flowfields code consists lines code eleven source files input sets vary size geometry flow field number particles simulated factors code written group computational scientists numerical aerodynamic simulation laboratory nasa ames research center began study psicm displaying cmf-level performance characteristics shown figure figure shows time plot cmf-level metrics run node partition cmsystem display shows distinct phases execution transition phase phase approximately minutes thirty seconds execution paradyn measured verbs phase including permutafigure summary improved version peace tions array elements parallel computations sorts scans phase execution dominated implicit costs rts-level node-level verbs labeled cmf-overhead display identify lower-level activities consumed majority cpu time application phase peeled back layers abstraction examined rts-level node-level verbs shown figure figure shows main components cmf overhead costs include idle time argument processing time broadcast time displays shown determine parallel node activations phase execution corresponded broadcasts costs idling processing arguments implicit initialization costs broadcasts figure cmf-level performance psicm combination code views data views performance locate broadcasts phase display shown figure reveals single source code statement responsible broadcasts phase line code shown figure statement writes elements eleven arrays file writes file system proceed quickly arrays allocated parallel nodes system elements transferred parallel nodes control processor writes proceed actual file write operations expensive cost sending data elements nodes control processor figures show broadcast costs high elements transferred written time high rate broadcasts shown figure high costs processing arguments waiting control processor shown figure node-level performance data phase psicm figure element incurs full cost node activation divide broadcast costs components responsible array figure shows broadcast frequencies arrays array separately figure code data views performance phase psicm note code data views visible figure write cell cell cell cell vib cell cell cell cell bad cell cell cell figure statement routine print state file part fcm eliminate transferring array elements parallel nodes control processor reduced implicit costs transfer figure shows code code gathers separate one-dimensional arrays single two-dimensional array transfers array nodes control processor single transfer operation finally writes array file code triples memory space required cell arrays make permanent code one-dimensional arrays packed two-dimensional array entire execution avoid additional space time plot figure shows performance improved psicm display shows transition phase phase single broadcast request short period broadcast time implicit costs node activations eliminated phase gather parallel arrays allcell cell allcell cell allcell cell allcell cell allcell cell allcell cell allcell cell vib allcell cell bad allcell cell allcell cell allcell cell transfer cell arrays call cmf array allcell allcell write arrays file write allcell figure improved psicm code previous applications ran uninstrumented versions original improved psicm range input sizes recorded execution times table figure shows improvements phase execution amount improvement execution time improvement consistent input sizes figure performance improved psicm input size original improved percent change min sec min sec min sec min sec min sec min sec min sec min sec min sec min sec figure execution times original improved psicm times uninstrumented executions program analysis psicm suggests combinations code data views performance performance analysis data-parallel programs identified single statement caused large amounts implicit node-level activity explained activity combination code data views showed array elements transferred time suggested reallocate data structures transfer single unit reduce node-level implicit communication costs operations summary dynamic instrumentation paradyn tool proven vehicle implementing ideas model incorporated ideas source-level performance data mapping performance data layers abstraction data views performance paradyn performance tool tool gain substantial improvements real parallel applications experiments paradyn tool fortran applications found cmf-level views important augmented rts-level nodelevel views performance applications exhibit performance problems runtime system processing nodes experiments bow peace applications demonstrated small fraction total resources cmf-level computations cases studied lower levels understand activities entire system information lower-level activity programmers relate activity source code experiments found rts-level node-level activity constrained fortran code data structures applications code data views performance helped identify cmf-level rts-level node-level activities traditionally performance data explained terms code constructs shown data views performance lead focused explanations performance experiments found performance problems localized parallel arrays diffused code statements data views performance helpful understanding data-parallel programs data primary source parallelism synchronization programs cases studied applications allocated large data structures beginning execution routines transform data structures result performance problems found fixed concentrating program data structures code structures conclusions summary parallel computers larger complex programmers good tools write effective efficient programs dissertation addressed unique problems lie tools high-level parallel languages performance measurement tools explained performance tools parallel programming languages converse programmers terms source code language emphasized importance measuring implicit activity relating high-level language constructs importance data-oriented views performance discussed problems informal framework model initial implementations solutions context paramap paradyn performance tools finally demonstrated real benefits ideas high-level language performance tools measure substantially improve performance real parallel applications main ideas basic performance tools present performance data source-code level high-level performance data programmers immediately understand performance characteristics applications begin grasp performance details algorithms model source-level data includes performance 
information mapped nouns verbs source code level shown static techniques map data paramap shown dynamic mapping interfaces paradyn measurement studies consistently high-level views understand performance application programs emphasized dissertation high-level performance information sufficient abstract programming systems hide details hardware implicit low-level activities maintain illusion programming model case studies found phase execution low-level implicit activity dominated activities measured application cases peeled back layers abstraction find implicit activities caused performance problems low-level performance information limited related high-level code structures data structures measurements consistently related low-level implicit communications fortran statements arrays allowed locate array statement ultimately required implicit activity made performance improvements source code level found knowledge low-level performance costs localization costs high-level code structures data structures required allowed alter high-level code effectively mapped parallel hardware compiler good general strategy achieving parallel efficiency sacrificing portability found data-oriented views performance effective data view performance relates performance measurements data-structures processed program model data structure measured mapped profiled noun paramap paradyn tools implemented data views simple time plots bar charts tables general techniques code-oriented views data views give completely perspective application performance provide dimension orthogonal traditional code views found performance tools shown orthogonal code data views combined localize performance problems view insufficient found data-parallel applications performance problems diffuse observed code views spread statements loops subroutines focused observed data views constrained parallel vectors matrices finally shown high-level performance data mapping levels abstraction measurement implicit activity data views performance attain substantial improvements real parallel applications implemented ideas performance tools tools investigate parallel programming languages parallel applications dissertation reported results applications performance tools obtain significant execution improvements hope successes foreshadow future productivity programmers high-level parallel programming languages performance measurement tools future work encountered large number interesting ideas questions completing dissertation address document ideas questions hope addressed future achieved success application codes informal iterative process augmented educated guesses needed runs long tedious searches performance problems computer automate searches dynamic on-the-fly environment paradyn paradyn includes dynamic performance consultant module designed discover performance anomalies applied high-level language applications significant problems automating search performance problems high-level language programs performance tools understand identify locate performance problems confront applications written language general set performance problem hypotheses cover combinations applications languages systems develop hypotheses searches performance problems advantage abstraction levels intuitively abstractions group related nouns verbs reduce complexity search space searches performance problems shorter start highest level abstraction work downward alternatively attempt find general low-level problems explain terms source code language general automated search performance problems leads question performance portable hardware platforms tuning application hardware platform lead improvements hardware platforms lead application performs platform dissertation successfully improved applications making adjustments source code level presume source-level improvements portable run code platforms highlevel parallel languages provide opportunity making studies programmers write portable code ideas applicable high-level parallel programming languages successfully applied model kinds parallel languages implementations limited data-parallel fortran languages applications widely distributed support paradyn ideal performance tool independent source code language runtime system hardware system application programs recognize successful parallel programming systems programming libraries model make distinction languages libraries experience important class programming system exciting situations arise individual application libraries unstructured grid package lparx implemented pvm ideally paradyn separately support library gracefully monitor interactions time categorize parallel languages list included hundred languages today similar survey yield choices bewildering number parallel programming systems increases programmers programming system purposes parallel programming community identify desirable characteristics parallel programming systems determine languages exhibit characteristics agrees execution efficiency important feature parallel programming system discount importance usability usability involves easily language programmers accomplish objectives usability difficult quantify evaluate improve usability expect parallel programming move domain expert programmers broader community good performance tools improve usability programming system confident future work performance tools contribute area compare evaluate performance tools metrics automated performance-problem search methods portable parallel programming systems widely implementations applications provide ideal testbed comparison compare performance tools develop suite applications shared tool developers researchers provide common ground comparison portable parallel programming systems widely comparison experiments performed researchers repeated diverse hardware platforms independent groups insure accuracy make languages performance tools usable powerful cooperate closely traditionally performance tools relied symbolic debugging information compilers identify nouns verbs contained program today performance tools yearn information nouns verbs compilation decisions optimizations code layout potential instrumentation points mappings pieces information compilers compilers make information compilers provide information time develop general interface compilers tools communicate result tools compilers broader applicability greater leverage groups develop tools compilers modest effort resources reduction enormous effort required produce performance tool compiler finally apply methods performance measurement high-level parallel languages complex systems database systems operating systems real-time control systems local-area networks global internet multiple layers abstraction hide execution details ease code development achieve portability naive features lead enormous performance problems systems low-level monitoring seldom pinpoints high-level performance problems model understand detailed performance characteristics complex systems lead performance tools redefine state art bibliography vikram adve jhu-chun wang john mellor-crummey daniel reed mark anderson ken kennedy integrated compilation performance analysis environment data parallel programming technical report crpc ziya aral ilya gertner non-intrusive interactive profiling parasight acm sigplan ppeals pages arvind steve heller rishiyur nikhil programming generality parallel computers technical report mit-lcs computation structures group bal steiner tanenbaum programming languages distributed computing systems acm computing surveys peter bates jack wileden approach high-level debugging distributed systems acm sigsoft sigplan software engineering symposium high level debugging pages march francois bodin beckman dennis gannon gotwals narayana srinivas winnicka sage object oriented toolkit class library building fortran restructuring tools oonski gary brooks gilbert hansen steve simmons approach debugging optimized code acm sigplan proc programming language design implementation pages coutant meloy ruscetta doc practical approach source-level debugging globally optimized code acm sigplan proc programming language design implementation pages cray research chippewa falls unicos file formats special files manual leonardo dagum three-dimensional direct particle simulation connection machine technical report rnr- nasa ames research center leonardo dagum konrad zhuh three-dimensional particle simulation high altitude rocket plumes technical report rnr- nasa ames research center william depauw richard helm doug kimelman john vlissades visualizing behavior object-oriented systems object-oriented programming systems languages applications conference pages ian foster robert olson steven tuecke productive parallel programming pcn approach scientific programming vol 
pages john wiley sons november joan francioni jay alan jackson breaking silence auralization parallel program behavior journal parallel distributed computing march goldberg john hennessey performance debugging shared memory multiprocessor programs mtool supercomputing pages november graham kessler mckusick gprof call graph execution profiler acm sigplan symposium compiler construction june anoop gupta margaret martonosi tom anderson memspy analyzing memory system bottlenecks programs performance evaluation review june haarslev moller framework visualizing object-oriented systems objectoriented programming systems languages applications conference pages michael heath jennifer etheridge visualizing performance parallel programs ieee software september hennessy symbolic debugging optimized code acm transactions programming languages systems july high performance fortran forum high performance fortran language specification version january jeffrey hollingsworth bruce irvin barton miller integration application system based metrics parallel program performance tool acm sigplan symposium principles practice parallel programming pages april jeffrey hollingsworth barton miller dynamic control performance monitoring large scale parallel systems acm international conference supercomputing pages july jeffrey hollingsworth barton miller jon cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference hurteau singh hancu van dongen eppp performance debugger technical report crim-eppp- centre recherce informatique montreal bruce irvin barton miller performance tool high-level parallel programming languages karsten decker rene rehmann editors programming environments massively parallel distributed systems pages birkhauser verlag laxmikant kale amitabh sinha projections preliminary performance tool charm international symposium parallel processing april carl kesselman integrating performance analysis performance measurement parallel programs technical report ucla computer sciences department carol kilpatrick karsten schwan chaosmon application-specific monitoring display performance information parallel distributed systems acm onr workshop parallel program debugging pages doug kimelman pradeep mittal edith schonberg peter sweeney ko-yang wang dror zernik visualizing execution high performance fortran hpf programs technical report ibm thomas watson research center october kleyn gingrich graphtrace understanding object-oriented systems concurrently animated views object-oriented programming systems languages applications conference pages scott kohn scott baden robust parallel programming model dynamic nonuniform scientific computations scalable high performance computing conference monica lam martin rinard coarse-grain parallel programming jade acm sigplan symposium principles practice parallel programming pages april james larus thomas ball rewriting executable files measure program behavior software practice experience february alvin lebeck david wood cache profiling spec benchmarks case study ieee computer october thomas leblanc john mellor-crummey robert fowler analyzing parallel program executions multiple views journal parallel distributed computing ted lehr david black zary segall dalibor vrsalovic mkm mach kernel monitor description examples measurements technical report carnegie mellon school computer science april laura bagnall linden parallel program visualization parvis performance instrumentation visualization pages york acm press ewing lusk ralph butler user guide parallel programming system technical report anlargonne national laboratory october malony program tracing cedar technical report illinois center supercomputing research development april maspar computer corporation north mary avenue sunnyvale mppe manual james mcgraw stephen skedzielewski stephen allan rod oldehoeft john glauert chris kirkham bill noyce robert thomas sisal streams iteration single assignment language languge manual version lawrence livermore national laboratory california davis march barton miller mark callaghan jonathan cargille jeffrey hollingsworth bruce irvin karen karavanic krishna kunchithapadam tia newhall paradyn parallel performance measurement tools ieee computer november barton miller morgan clark jeff hollingsworth steven kierstead sek-see lim timothy torzewski ipsthe generation parallel program measurement system ieee transactions parallel distributed systems april barton miller cathryn macrander stuart sechrest distributed programs monitor berkeley unix software-practice experience february barton miller cui-qing yang ips interactive automatic performance measurement tool parallel distributed programs international conference distributed computing systems september mips computer systems sunnyvale umips-v manual bernd mohr darryl brown allen malony tau portable parallel program analysis environment international conference parallel systems pages springer verlag september nardini brebbia approach free vibration analysis boundary elements boundary element methods engineering peaceman rachford numerical solution parabolic elliptic differential equations journal society industrial applied mathematics donald peaceman fundamentals numerical reservoir simulation elsevier scientific publishing company sharon perl performance assertions acm symposium operating system principles pages december pure software incorporated menlo park quantify user guide daniel reed robert olson ruth aydt tara madhyastha thomas birkett david jensen bobby nazief brian totty scalable performance analysis pablo performance analysis environment skjellum editor scalable parallel libraries conference ieee computer society patrick sansom simon peyton jones profiling lazy functional languages technical report glasgow robert schumacher self-sustaining oscillations bowed string acustica robert schumacher analysis aperiodicities periodic waveforms journal acoustic society america karsten schwan rajiv ramnath sridhar vasudevan david ogle language system parallel programming ieee transactions software engineering april zary segall larry rudolph pie programming instrumentation environment parallel processing ieee software november steve sistare don allen rich bowker karen jourdenais josh simons rich title data visualization performance analysis prism programming environment programming environments parallel computing pages north-holland richard snodgrass relational approach monitoring complex systems acm transactions computer systems sunderam pvm framework parallel distributed computing concurrency practice experience december sussman saltz das gupta mavriplis ponnusamy parti primitives unstructured block structured problems computing systems engineering thakkar performance parallel applications shared-memory multiprocessor system simmons koskela editors performance instrumentation visualization pages acm press thinking machines corporation cambridge fortran manual january sivan toledo perfsim automatic performance analysis tool data-parallel fortran programs international symposium frontiers parallel systems february welbon chen-nui shippy hicks power performance monitor ibm journal research winifred williams timothy hoel douglas pase mpp apprentice performance tool delivering performance cray karsten decker rene rehmann editors programming environments massively parallel distributed systems birkhauser verlag winifred williams james kohn atexpert journal parallel distributed computing june jerry yan performance tuning aims automated instrumentation monitoring system multicomputers hawaii international conference system sciences pages january polle zellweger interactive high-level debugger control-flow optimized programs acm sigplan notices march 
maryland runtime program evolution jeff hollingsworth copyright jeffrey hollingsworth rights reserved maryland motivation software systems complex built component parts running complex varied environments tools required understand behavior systems react changing environments manage software components maryland dyninstapi api runtime code patching code added program executes permits instrumentation modification programs processor independent abstractions patching applied multiple systems includes meta-instrumentation tracks overhead inserted code maryland applications runtime code patching performance measurement recording application behavior correctness debugging fast conditional breakpoints data breakpoints execution driven simulation architecture studies testing code coverage testing forcing hard execute paths maryland advantages runtime code patching forethought needed user inserted probes special compiling linking start anytime execution insert code needed wasted checks disabled code add code execution maryland machine dependent code structure dyninst library mutator mutatee mutator app api dyninst code ptrace procfs application code snippets run-time library maryland api library functions control mutatee runtime code generation information mutatee set classes bpatch thread bpatch image bpatch snippet bpatch variableexpr bpatch block maryland representing code snippets platform independent representation code inserted apps system simple abstract syntax tree refer application state variables params includes simple looping construct permits calls application subroutines type checking ensures snippets type compatible based structural equivalence flexibility adding code maryland snippet flagvar fdvar open filename bpatch ifexpr bpatch constexpr bpatch variableexpr flagvar bpatch boolexpr bpatch bpatch variableexpr fdvar bpatch arithexpr bpatch assign bpatch constexpr bpatch constexpr filename bpatch constexpr wronly creat bpatch bpatch funccallexpr bpatch function open maryland type support dyninst access local stack variables complex types non-integer scalars structures arrays correctness debugging print contents data structures maryland implementation compiler debugger info stab records access user defined types information local variables type information variables line number text segment address mapping incremental parsing parse stabs module dyninst user define types creation types patched code permits reconstruction stripped symbols maryland api find variables defined image bpatch vector bpatch variableexpr vars appimagegetglobalvariables varssize bpatch variableexpr vars switch gettype type case bpatch scalar printf scalar type getname gettype getname case bpatch structure fieldvector fields gettype getcomponents fieldssize bpatch field fields printf field type getname gettype getname maryland code coverage testing dyninst code coverage identifies source code lines executed ensures basic block dyninst arbitrary binaries permits removing code block covered long running programs tested faster permits incremental instrumentation instrument function entry call instrument function blocks maryland cfg dominator tree dominators reduce counters instrument basic blocks leaf nodes dominator tree instrument basic blocks outgoing edge blocks dominated maryland postgres wisconsin benchmark original deletion interval sec execution time postgres basic blocks dominator info coverage postgres time interval perc ent age percentage maryland slow postgres vortex perl sim ijpeg tested programs slow ratio wrt original execution purecov basic blocks dominator info maryland dyner command utility tcl-based command line tool access dyninst features easier program simple applications simple command-line debugger fast conditional breakpoints dynamic addition printfs command summary declare create variable application cbreak insert conditional breakpoint print show contents application data structures insert code snippet application load run exit process creation manipulation maryland tcl command load application declare int counter main entry counter importantfunc entry counter main exit printf function called times counter run maryland dyninst status supported platforms sparc solaris solaris linux alpha tru unix mips irix power powerpc aix software web http umd projects dyninstapi includes tcl command tool maryland expanding application system interface past model start program execution hope model application exposes alternatives algorithms parameters performance expectations options system adapts application optimize execution maryland harmony structure tuning control applications libraries system controller capacities requirements tuning options tuning control availabilities requirements metric interface resource requirements maryland features harmony rsl bundles primary unit adaptation mutually exclusive sets application options resource requirements expected utilization option resource performance prediction expected performance selected bundles optimizing multiple applications system maryland bundles node cpu speed disk capacity memory link latency bandwidth protocol nodes communication entire application communication requirements performance entire application performance granularity switching options runtime maryland harmony api harmony startup unique interrrupts harmony bundle setup bundle definition void harmony add variable default type func harmony wait update harmony end application define options learn harmony selections receive information environment maryland architecture harmony implementation harmony process application options performance data option instantiation code option selection tcl code send recv tcp application process application process parameters cache size alternative algorithms harmony library application code parameters cache size alternative algorithms harmony library application code maryland client-server database client queryshipping server client datashipping server maryland database bundle harmonybundle dbclient node server seconds memory node client seconds memory link client server node server seconds memory node client memory seconds link client server client memory client memory maryland client response times time pons client client client clients added time clients run query-shipping client flips data-shipping maryland results pstswm solves nonlinear shallow water equations options multiple algorithms embedded code problem-specific options communication parameters combinations size nodes min max combinations min max maryland current work application resource usage potential necessarily achievable user compiler profiling performance prediction structural models poems apples scheduling heuristics applications real-time vision web server video server maryland active harmony conclusions launch forget sufficient capacities dynamic demands dynamic system-directed adaptation complete information handles running applications requires application restructuring layering dsm detailed resource requirements maryland acknowledgements co-pis pete keleher harmony bart miller dyninst graduate students harmony heonsang eom dejan perkovic cristian tapus dyninst bryan buck mustafa tikir research staff mehmet altinel funding agencies darpa doe dod nsf nist maryland 
safety-checking machine code zhichen dissertation submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison copyright zhichen rights reserved safety-checking machine code zhichen supervision professor barton miller professor thomas reps wisconsin madison importing executing untrusted foreign code everyday occurrence web servers download plug-ins applets databases load type-specific extensions operating systems load customized policies performance measurement code certification safety untrusted code crucial domains developed methods determine statically safe untrusted machine code loaded trusted host system safety-checking technique operates directly untrusted machine-code program requiring initial inputs untrusted program annotated typestate information linear constraints approach opens possibility certify code produced compiler source language eliminates dependence safety correctness compiler final product compiler checked leads decoupling safety policy language untrusted code written makes safety checking performed respect extensible set safety properties host side implemented prototype safety checker sparc machine-language programs applied safety checker examples ranging code branches code nested loops code function method calls safety checker mechanically synthesize loop invariants check examples times ranging dozens seconds acknowledgments advisors bart miller tom reps guidance encouragement privilege advisors benefit greatly daily interactions setting high standard research patience admire intuitions encyclopedic knowledge marvin solomon rastislav bodik carefully reading thesis draft provide valuable feedback entire committee bart miller tom reps marvin solomon rastislav bodik gregory moses lively discussion dissertation defense xiaodong zhang mentor friend encouraging apply graduate school feel deeply debt people ari tamches brian wylie phil roth tia newhall vic zandy ling zheng oscar naim karen karavanic andrew bernat alexandre mirgorodskii good colleagues resources finally parents zhenxiang meiling wang encouraging pursue graduate study united states wife shen son alex wife tolerating long journey support succeeded son alex giving joy iii contents acknowledgments contents iii list figures vii introduction contributions organization dissertation related work safety checking dynamic techniques static techniques work related static techniques hybrid techniques array bounds checking techniques optimizing array bounds checks techniques propagating information array bounds program-verification techniques synthesis loop invariants overview safety properties policy abstract storage model inputs safety-checking analysis phases safety-checking analysis preparation typestate propagation annotation local verification global verification typestate checking typestate system type type expressions subtyping relation typestate checking subtyping state access permissions abstract operational semantics sparc instructions overload resolution propagation type state access information typestate checking summarizing calls detecting local arrays related work annotation local verification annotation attachment safety predicates generating safety preconditions assertions local verification global verification program verification linear constraints theorem prover induction-iteration method enhancements induction-iteration method handling sparc machine language handling store instructions handling multiple loops handling procedure calls strengthening formulae incorporating generalization controlling sizes formulae sharing common computations performing simple tests assuming acyclic code fragment scalability induction-iteration method potential improvements range analysis range analysis experimental evaluation prototype implementation case studies limitations lost precision due array lost precision due type system limitations induction-iteration method summary conclusions future work limitations future research improving precision safety-checking analysis developing algorithms employing static run-time checks improving scalability safety-checking analysis employing modular checking employing analyses unsound producing proof-carrying code extending techniques safety checking enforcing security policy reverse engineering vii list figures inputs phases safety-checking analysis simple summing elements integer array host-typestate specification invocation specification access policy initial annotations memory state line assertions safety preconditions line simple language type expressions inference rules define subtyping relation subtyping pointer types rule pointer unsound flow-insensitive type checking absence aliasing information contents store statement function figure portion state lattice propagation type state access information propagation typestate results typestate propagation safety preand postconditions safety preand post-conditions alias contexts inferring type size local array attachment safety properties safety preconditions produced annotation phase weakest liberal preconditions sample sparc instructions respect postcondition viii basic induction-iteration algorithm branch delay slot handling sparc condition code weakest liberal precondition acyclic code region applying induction iteration method consecutive loops applying induction iteration method nested loops conditionals program weaken extent prevented loop-invariant induction-iteration algorithm breath-first search induction iteration binary operations symbolic expressions dataflow functions tests symbolic range analysis applied running prototype implementation sparc machine language characteristics examples performance results performance results times perform global verification range analysis normalized respect times perform global verification range analysis operator vector type introducing propagating nodes examples induction-iteration method handle introducing basic induction variable examples shown figure chapter introduction prevailing trends software development call techniques protect software component trend dynamic extensibility trusted host extended importing executing untrusted foreign code web browsers download plug-ins databases load type-specific extensions storing querying unconventional data operating systems load customized policies general functionality performance-measurement code operating systems download part application kernel application perform proposals loading application-specific policies internet routers certification safety untrusted code crucial domains trend component-based software development software components produced multiple vendors construct complete application component-based software-development model improves software reusability productivity software components sources proper protection software components essential thesis show determine statically safe untrusted machine code loaded trusted host system contrast work enforces safety restricting things expressed source language safe languages certifying compilers typed assembly languages safe code written source language produced compiler long unsafe expressed machine code philosophical difference implications code producer freedom choosing implementation language building certifying compiler language certify code produced general-purpose off-the-shelf compiler leads decoupling safety policy language untrusted code written makes safety checking performed respect extensible set safety properties host side important high-level characteristics safety-checking technique operates directly binary code ability extend host fine-grained level untrusted foreign code manipulate internal data structures host directly iii enforces default collection safety conditions prevent type violations array out-of-bounds violations address-alignment violations uninitialized variables null-pointer dereferences stack-manipulation violations addition providing ability safety criterion extended access policy host host-specified access policy lists host data accessed host functions methods called untrusted code means host grant privilege untrusted code accomplish task approach based annotating global data trusted host type information precisely typestate information untrusted code inferred analysis starts information initial memory state entry untrusted code abstractly interprets untrusted code produce safe approximation memory state program point annotates instruction safety conditions instruction obey checks conditions memory states entry program points untrusted code terms typestates linear constraints linear equalities inequalities combined quantifiers analysis typestates opposed types condition safe perform operation function types operation operands states safe 
write location stores uninitialized unsafe read typestates differ types providing information finer granularity typestate checking differs traditional type checking traditional type checking flow-insensitive analysis typestate checking flow-sensitive analysis typestates related security automata security automaton states accepting states automaton detects security-policy violation reads symbol automaton current state transition defined design typestate system captures states security automaton security-violation state typestate checking method statically assessing security violation figure illustrates inputs phases safety-checking analysis inputs safety-checking analysis include host-typestate specification invocation specification addition untrusted code host-specified access policy host typestate specification describes type state host data invocation untrusted code safety preand post-conditions calling host functions methods invocation specification binding information host resources registers memory locations represent initial inputs untrusted code combination hosttypestate specification invocation specification access policy information initial memory state time untrusted code invoked safety-checking analysis consists phases preparation typestate-propagation annotation local verification global verification phases find state instruction operates phases find safety conditions instruction obey check conditions preparation phase combines information provided host-typestate specification invocation specification access policy produce initial annotation form abstract store program entry point phase produces interprocedural control-flow graph untrusted code typestate-propagation phase takes control-flow graph initial annotation inputs abstractly interprets untrusted code produce safe approximation memory contents typestate abstract location program point annotation phase takes input typestate information discovered figure inputs phases safety-checking analysis dotted vertical line separates untrusted trusted worlds java off-the-shelf compiler ordinary binary access policy host-typestate specification invocation specification preparation initial memory state untrusted trusted typestate memory state program point annotation facts local safety global safety local global propagation conditionsconditions verification verification typestate-propagation phase traverses control-flow graph annotate instruction local global safety conditions assertions local safety preconditions conditions checked typestate information assertions restatements logical formulas facts implicit typestate information local-verification phase checks local safety conditions global-verification phase verifies global safety conditions global safety conditions perform array bounds checks null-pointer dereference checks address-alignment checks represented linear constraints advantage synergy efficient range analysis expensive powerful technique applied demand array bounds checks range analysis determines safe estimates range values register program point information determining accesses arrays bounds conditions proven results range analysis program-verification techniques induction-iteration method synthesize loop invariants untrusted code loops description safety-checking analysis synthesizes verifies safety proof noted structure safety-checker principle separate safety-checker proof generator proof verifier proof generator generates proof-carrying code pcc proof checker validates safety proof technique lift current limitations certifying compilers produce pcc automatically programs written safe source languages implemented prototype safety checker sparc machine-language programs applied safety checker examples ranging code branches code nested loops code function method calls safety checker prove met safety conditions identify places safety conditions violated times ranging tens seconds ultrasparc machine remainder dissertation call party generates untrusted foreign code code producer human code-generation tool party responsible trusted host code consumer contributions major contributions thesis technique opens possibility certify object code produced off-theshelf compilers independent source language compiler require inputs untrusted code annotated typestate information linear constraints technique extensible addition default collection safety conditions checked additional safety conditions checked host extend notion typestate ways typestates describe state information abstract locations abstract storage model extend typestates include access permissions extent untrusted code allowed access host resources iii addition typestates distinguish initialized values uninitialized typestates track pointers propose typestate-checking system perform safety-checking untrusted machine code implements inheritance polymorphism physical subtyping work introduces method coping subtyping presence mutable pointers introduce mechanism summarizing effects function calls safety preand post-conditions summaries analysis stop trusted boundaries form step checking untrusted code modular fashion make safetychecking technique scalable present technique infer information sizes types stack-allocated arrays describe symbolic range analysis suitable propagating information array bounds range analysis speed safety checking generally expensive program-verification techniques bounds checks describe prototype implementation safety-checking technique experimental studies evaluate work thesis focuses enforcing fine-grained memory protection decidable logic expressing safety conditions simple heuristics synthesizing loop invariants stress techniques originally developed verification correctness prove total partial correctness safety checking ambitious verification correctness organization dissertation dissertation organized chapters begin discussion related work chapter chapter describe safety properties enforce notion access policy present overview safety checking analysis means simple chapters describe phases safety-checking analysis starting phase chapter describe phase safety-checking analysis describe abstract storage model analysis typestate system present typestate-checking analysis recovers typestate information program point untrusted code typestate-checking system check safety untrusted machine code implements inheritance polymorphism physical subtyping describe techniques make safety-checking analysis precise efficient chapter present details annotation local-verification phases analysis chapter describe global-verification phase present induction-iteration method synthesizing loop invariants enhancements describe symbolic range analysis array bounds checking chapter present experience safety-checking technique gained prototype implementation untrusted code written sparc machine languages case studies finally chapter present conclusions suggest directions future research chapter related work chapter discuss research efforts closely related dissertation section survey techniques enforce safe program execution examine techniques statically check array out-of-bounds violations section discuss techniques synthesizing loop invariants section safety checking techniques enforce code safety fall categories dynamic static hybrid static techniques potentially efficient run-time dynamic hybrid techniques static techniques incur run-time overhead precise reject code determined safe statically dynamic technique incurs run-time cost require corrective actions case safety violation detected run-time hybrid techniques tend efficient dynamic techniques dynamic techniques require corrective actions presence safety violation survey related work compare work static techniques closest dynamic techniques safety issues addressed dynamic technique enforce code safety safety violations detected corrective action violation detected run-time corrective action simple terminating offending code complex offending code accesses shared data structures trusted host extreme dynamic techniques safety interpretation virtual machine interprets untrusted code checks safety instruction run-time bsd network packet filter utility commonly referred bpf defines language interpreted operating system network driver interpreter checks run-time memory bounds packet data statically allocated scratch memory interpretation incurs high run-time cost bpf times slower versions written statically checked proof-carrying code languages designed interpreted small limited control data structures makes unsuitable general-purpose simple enforce safety untrusted code isolate hardware-enforced address space similar operating system kernels protect user-level applications approach hardware operating system kernel prevent code address space corrupting code data address space prevent untrusted code leaving host software inconsistent state terminating releasing resources acquired untrusted 
code interact host software restricted interface apparent limitation requiring special hardware support major disadvantage approach high run-time cost cross-address-space call requires trap operating system kernel copying arguments caller callee saving restoring registers switching hardware address spaces dispatch back user level software fault isolation sfi pure software techniques achieve functionality hardware-enforced address spaces lower cost form sfi sandboxing ensures high bits memory address match sandbox region assigned foreign code vino exokernel systems sandboxing ensure extensions downloaded safe sfi hardware-enforced address spaces provide protection isolating untrusted code protection domain restricting interface interact host software sfi modifies binary code directly independent source language hardware-enforced address spaces protection provided sfi coarse-grained system fine-grained sharing sfi incurs low run-time overhead processors large number registers register spilling needed free registers sandboxing untrusted code interacts frequently code host environment untrusted components residing protection domains read operations checked overhead run-time checking amount opposed percent write operations checked checking read operations reads memory-mapped devices destructive finally sfi difficult implement correctly hard prevent code modifying protect contents stack leroy rouaix proposed theoretical model systematically placing typebased run-time checks interface routines host code provide fine-grained memory protection technique checks host requires source host api safety requirements enumerating set predetermined sensitive locations invariants locations technique related leroy rouaix technique technique typebased rely static analysis run-time checking addition technique works untrusted binary code technique instruments host api source level model safety policy chapter general finally perform type checking perform typestate checking chapter typestates provide finer grained information types typestate checking flow-sensitive analysis traditional type checking flow-insensitive analysis technique potentially precise static techniques static techniques ensure code safety advantages code potentially efficient run-time checks involved corrective action needed code misbehave static techniques enforce code safety range provide accountability techniques formal methods verify binary conforms specification logic correctness checking techniques verify binary conforms safety properties type safety techniques emphasize finding potential bugs enforcing full safety techniques check correctness program hard automate techniques check program specific safety properties manageable correctness checking expensive techniques focus finding potential bugs analysis efficiency rely analyses sound complete simplest static technique enforcing safety personal authority microsoft activex digital signatures record information origin code svr kernels users super-user privilege install kernel modules device drivers kernel approach accountability safety research projects formal methods verify binary code conforms specification logical formula memory safety properties clutterbuck carre describe technique prove programs written subset intel machine language conform specifications technique spade software tools work programs defined spade fdl spade program modelling language safety-checking analysis flow-analysis program-verification techniques flow analyses check problems unreachable code code exit reached multiple-entry loops undefined variables unused definitions redundant tests spade program verifier checks program conforms specification logical formulae boyer approach prove machine-code program memory safe consistent mathematical specification technique models semantics subset instruction set architecture isa meticulous detail giving machine code explicit formal operational semantics operational semantics logic automated reasoning system analogous supplying loop invariants floydstyle verification conditions approach requires manual construction lemmas major limitation general theorem-proving techniques proving validity arbitrary predicate first-order logic undecidable addition proving program loops satisfies preand post-condition floyd-style verification conditions involves synthesizing loop invariants general mechanically proving program conforms specification correct hard accomplish mechanically general projects focus verifying piece untrusted code specific safety properties examples projects include proof-carrying code pcc certifying compiler typed-assembly language tal work pcc based observation generally faster easier validate proof generate pcc code producer code proof code safety properties necula lee pcc statically check safety network packet filters provide safe native extensions major advantage pcc safety depends correctness proof checker small trusted party needed pcc tamper proof change makes code unsafe proof invalid identified proof checker pcc ability associate proofs end-product machine code manual generation proofs tedious error-prone type safety property considered proof system needed adding proofs code considerably increase size code times original size avoid manual construction pcc necula lee introduce notion certifying compiler compiles high-level programming language program pcc prototype compiler touchstone compiles safe subset assembly code carries proofs type safety show loop invariants type safety array bounds checks generated automatically compiler work shows relevant operational content simple type systems encoded extensions first-order predicate logic relying logic system encode types morrisett introduced notion typed assembly language tal approach type information high-level program incorporated representation program platform-independent typed intermediate form carried series transformations level target code compiler type information perform sophisticated optimizations internal errors compiler detected invoking type-checker code transformation compiler typed assembly language certifies type safety ensuring well-typed source program maps well-typed assembly program checking full safety time consuming analyses minimum sound static debugger static analysis find unsafe operations guarantee full safety make analyses sound complete interest efficiency flanagan describe interactive static debugger scheme identify program operations run-time errors dereferencing null pointer calling non-function program analysis computes value-set descriptions term program constructs flow graph connecting set descriptions evans describes extensions lclint checking tool tool statically checking programs tool perform stronger checking standard version lint detect dynamic memory errors dereferencing null pointers failure allocate deallocate memory undefined deallocated storage dangerous unexpected aliasing technique interface annotations avoid expensive interprocedural analysis reduce amount error messages analysis loops treated conditional statements detlefs describe static checker common programming errors array index out-of-bounds null-pointer dereferencing synchronization errors multi-threaded programs analysis makes linear constraints automatically synthesizes loop-invariants perform bounds checking parameterized policy specification safetychecking analysis works source-language programs makes analyses sound complete policy specifications user-supplied modifies lists variables procedure modified offer degree access control work related static techniques static techniques closest certifying compiler typed-assembly language prominent difference approach certifying compiler tal approach philosophical certifying compiler approach enforces safety preventing bad things expressible source language safe subset touchstone compiler popcorn language talx pointer arithmetic pointer casting explicit deallocation memory contrast safe code written language produced compiler long bad code philosophical difference implications code producer freedom choose language including unsafe languages assembly freedom produce code off-the-shelf compiler manually eliminates dependence safety correctness compiler pcc technique checks safety final product compiler leads decoupling safety policy source language turn makes safety checking performed respect extensible set safety properties host side approach introduce additional variable process partially programmer control code-generation idioms compiler 
defeat techniques system implementation analyses rely aware idioms compiler important difference approach certifying compiler tal approach safety properties enforce based notion typestate extensive information types addition high-level differences technical differences safety checker viewed certifier generates proofs recovering type information existed source-language program embodiment suggestion made necula lee approach safety checker differs touchstone compiler respects touchstone replaces standard method generating verification conditions vcs formulae pushed backwards program forward pass program combines generation symbolic execution contrast system forward phase typestate checking kind symbolic execution fairly standard backward phase generation chapter description typestate checking chapter description generation vcgeneration phase backwards pass program usual reason advantage propagating information backwards avoids existential quantifiers arise formulae pushed forward direction generate strongest post-conditions forward vc-generation phase quantifiers accumulate forcing work larger larger formulae safety-checking analysis mechanically synthesizes loop invariants bounds checking alignment checking touchstone generates code explicit bounds checks removes checks prove redundant comparing tal type system tal model language features instance tal models language features address exceptions existential types hand system models size alignment constraints tal tal type system support general pointers stack stack heap pointers distinguished tal declare function receives tuple argument accept heap-allocated tuple call site stack-allocated call site talx introduces special macros array subscripting updating prevent optimizer rescheduling macros expand code sequences perform array-bounds checks impose restrictions idioms compiler employ implement array subscripting tal achieves flow-sensitivity system tal blocks code labeled functions types assigned registers function system achieves flow-sensitivity typestate instruction differences interesting note safety checker programs written typed assembly language untyped machine language work required recover type information perform overload resolution propagate state access information applies java bytecode type information contained bytecode instructions finally touchstone popcorn compiler talx track aliasing information introduced abstract storage model extended typestate checking track pointers result analysis provide precise popcorn touchstone work related work detlefs technique make linear constraints automatically synthesize loop-invariants perform bounds checking parameterized policy specifications safety-checking analysis works source-language programs makes analyses sound complete policy specifications general access policies terms regions categories access permissions chapter hybrid techniques technique combines static dynamic checking requires fewer run-time checks dynamic techniques corrective actions faults occur runtime examples hybrid techniques safety checking include safe languages java mesa modula safe language defined semantics valid programs written language guaranteed safety properties employs static run-time measures avoid operations potentially harmful systems safe languages system extensions include pilot runs programs written mesa hotjava web browser extended applets written java spin extensible extended modules written modula safe language safety property build language safe language relies strong typing enforce fine-grained memory protection data abstraction techniques based types programming-language semantics including pcc certifying compilers safe languages offer finer-grained access control flexibility based physical means sfi hardware-enforced address spaces types correspond naturally computer resources protect safe languages prohibit bad things happening restricting expressiveness language consequence restricts applicability technique languages assembly code general-purpose type-safe languages java occasions functionality implemented low-level languages assembly code array bounds checking basic requirement safe program execution array accesses bounds array bounds checks essential enforcing program security buffer-overrun vulnerabilities malicious user overrun stack contents circumvent computer security checks long plagued security architects wagner report buffer overruns account today vulnerabilities based data cert advisories decade techniques performing array bounds checks include techniques optimizing array bounds checks symbolic analyses compute bounds index array program-verification techniques sections describe work areas techniques optimizing array bounds checks markstein developed analysis technique moves array bounds checks loop eliminates checks analysis determine array out-of-bounds violations analysis places array bounds checks loop modifies loop-control condition guarantees array out-of-bounds violations occur places test loop exit ensure loop perform number iterations original program gupta technique optimizing array bound checks gupta optimizations reduce program execution time object code size elimination redundant checks propagation checks loops combination multiple checks single check analysis performed reduced control-flow graph consists minimal amount data flow information range-check optimizations kolte wolfe present compiler-optimization algorithm reduce run-time overhead array bounds checks algorithm based partial redundancy elimination incorporates previously developed algorithms including gupta array bounds checking optimizations techniques perform array bounds checking introducing code perform checks checking code optimized techniques propagating information array bounds algorithms rely dataflow analysis abstract interpretation propagate information array bounds vary sophistication assertions rules propagating combining assertions assertions verbrugge intervals scalars cousot halbwachs convex polyhedra track correlations variables wagner flow-insensitive analysis analysis efficiency verbrugge flowand context-sensitive analysis harrison compile-time analysis reduce overhead due range checks compile-time techniques range propagation range analysis employed yielding bounds ranges variables points program harrison technique propagates ranges scalar intervals ranges simple symbolic bounds range information eliminate redundant range checks array subscripts verbrugge range-analysis technique called generalized constant propagation gcp gcp scalar interval domain employs flowand context-sensitive analysis attempts balance convergence precision analysis stepping ranges decreasing lower bound increasing upper bound variables failed converge fixed number iterations gcp points-to information discovered earlier analysis phase rugina rinard symbolic bounds analysis analysis gains context sensitivity representing symbolic bounds variable functions polynomials rational coefficients initial values formal parameters analysis proceeds basic block generates bounds variable entry abstractly interprets statements block compute bounds variable program point inside exit basic block based bounds build symbolic constraint system solve constraints reducing linear program coefficient variables symbolic-bound polynomials solve symbolic constraint system goal minimizing upper bounds maximizing lower bounds bodik describe method eliminate array bounds checks java programs method restricted form linear constraints called difference constraints solved efficient graph-traversal algorithm demand goal apply analysis array bounds checks selectively based profile information fall back run-time checks cold code blocks wagner formulated buffer-overrun-detection problem integer constraint problem solved linear time practice analysis flowand contextinsensitive goal finding errors cousot halbwachs method based abstract interpretation convex hulls polyhedra technique precise simply verify assertions discover assertions deduced semantics program propose range analysis array bounds checking section range analysis closest gcp differs gcp respects domain symbolic ranges perform widening operation quicker convergence sharpen analysis selecting suitable spots loops performing widening operation incorporating correlations register values gcp technique points-to information discovered earlier analysis phase current implementation range analysis context-insensitive gcp context-sensitive program-verification techniques suzuki ishihata german floyd-style program verification techniques verify absence array out-of-bound violations programs floyd-style program 
verification relies system ability synthesize loop invariants automatically suzuki ishihata introduced method called induction iteration synthesizing loop invariants german method relies simple heuristics suzuki ishihata german methods developed structured source-level programs synthesis loop invariants major problem building automatic verifier require programmer-supplied annotations system synthesize loop invariants ways synthesize loop invariants automatically heuristics difference equations abstract interpretation running program test-oriented fashion induction-iteration method katz manna wegbreit describe heuristics synthesize loop invariants approach back-substitutions performed starting postcondition produce trial loop predicates trial loop predicates loop invariants modified heuristics generate trial predicates heuristics domain specific shown examples domain integers integer arrays synthesizing loop invariants difference equations proceeds steps finding explicit expression variable iterations loop eliminating obtain invariants abstract interpretation method works forward precondition precondition hold treated data submitted input evaluator evaluator operators treated operations predicates abstract interpretation taking predicates arguments delivering predicate result evaluator encounters conditional chooses alternatives current state logically implies decision predicate negation control splits parallel branches junction nodes handled sequence operations predicates input arcs merged result merge joined previous predicate output edge form predicate output edge loop invariants synthesized running program test-oriented fashion consists steps step selects values input variables step runs program inputs collects values output variables program point step establish relations variables induction-iteration method suzuki ishihata weakest liberal preconditions synthesizing loop-invariant postcondition loop verified inductively synthesizes loop invariant true entry loop implies postcondition extended induction-iteration method machine-language programs nested loops interprocedural verification description induction-iteration method extensions found chapter adopt induction-iteration method mechanical assertions prove general required prove program conforms specification chapter overview goal check statically safe piece untrusted foreign machine code loaded trusted host system start ordinary machine code mechanically synthesize verify safety proof chief advantage approach opens possibility certify code produced general-purpose off-the-shelf compiler programs written languages work limit safety policy fixed set memory-access conditions avoided perform safety checking respect safety policy supplied host side proof-synthesis techniques employed host side approach viewed alternative proof-carrying code pcc approach pcc requires code producer create machine code proof code safe host perform proof-validation step proof-synthesis techniques employed code producer foreign side untrusted trusted boundary approach viewed ally pcc helps lift current limitations certifying compilers produce pcc automatically programs written safe source languages mechanically synthesize verify safety proof piece untrusted code analysis starts description initial inputs untrusted code access policy abstractly interprets untrusted code produce safe approximation memory state program point memory states abstract storage model information discovered program point analysis annotates instruction safety conditions instruction obey verifies conditions reminder chapter describe safety properties enforce notion access policy describe abstract storage model inputs safety-checking analysis present overview safetychecking analysis means simple safety properties policy untrusted code imported host system acceptable behaviors untrusted code behavior specifications form safety conditions include collection default safety conditions host-specified access policies default safety conditions enforce fine-grained memory protection data abstraction based strong typing default safety conditions check type violations array out-ofbounds violations address-alignment violations uninitialized values null-pointer dereferences stack-manipulation violations ensure untrusted code forge pointers operations untrusted code operate values proper types proper level initialization access policy additional flexibility allowing host host data accessed host functions methods called untrusted code means host privilege untrusted code accomplish task minimize potential damages untrusted code trusted host model view addresses passed piece untrusted code doors host data region access policy controls memory locations resources accessible pointer types memory locations reachable access policy specifies ways accessed terms types memory locations contents access policy classification memory locations regions list triples form region category access permitted region large entire address space small single variable category field set types aggregate fields access field subset meaning readable writable followable executable operable model properties location properties stored location access permission introduced pointer-typed values pointer dereferenced access permission applies values type pointer function values hold address function function pointed called untrusted code access permission includes rights examine copy perform operations covered feel safety policy suppose user asked write extension piece untrusted code finds lightweight process thread running suppose information threads stored host address space linked list defined structure thread struct thread int tid int lwpid struct thread policy extension read examine tid lwpid fields follow field stands host region region list threads stored thread tid thread lwpid thread rfo model variety safety policies roughly equivalent sandboxing original sandboxing model partitions address space protection domains modifies piece untrusted code accesses domain model sandboxing boils allowing untrusted code access memory valid addresses untrusted data region examine operate data items type address location host region dereferenced side-effects confined untrusted region approach differs sandboxing purely static make untrusted code sandboxing works situations limit memory accesses untrusted data region forbidding access data host region draconian measure instance access host data region applications simple performance instrumentation read statistics maintained host environment model aggressive policies defined allowing simple reads writes locations host data region forbidding pointers modified policies permit untrusted code follow types valid pointers host data region order traverse linked data structures aggressive policies permit untrusted code change shape host data structure allowing untrusted code modify pointers safety properties policies introduced ensure integrity host environment violated host resources accessed improperly safety policy include safety postconditions ensuring invariants defined host data restored time control returned host abstract storage model introduce abstract storage model describing memory states program point abstract storage model abstract domain safety-checking analysis model includes notion abstract store linear constraints abstract store total map abstract locations typestates abstract location summarizes physical locations heapand stackallocated objects analysis finite domain work abstract location size alignment optional attributes abstract location readable writable access policy typestate describes type state access permissions stored abstract location typestates form meet semi-lattice typestates section linear constraints linear equalities linear inequalities combined logical operators quantifiers represent safety requirements array bounds checks address alignment checks null-pointer checks inputs safety-checking analysis inputs safety-checking analysis include untrusted code host-specified access policy section host-typestate specification invocation specification inputs untrusted code provided host host-typestate specification information functions methods host called access permission access policy host functions called called host-typestate specification includes data aspect control aspect data aspect describes type state host data invocation untrusted code 
control aspect safety preconditions postconditions calling host functions methods safety preconditions postconditions form placeholder abstract locations typestate size placeholder abstract location safety precondition represent obligations actual parameter provide placeholder abstract locations postconditions typestates locations execution function verifying safety call host function method involves binding process matches actual parameters placeholder abstract locations safety preconditions update process computes memory state invocation call based safety postconditions detailed description summarize calls trusted functions section invocation specification binding information resources host registers memory locations represent parameters untrusted code host-typestate specification invocation specification access policy provide information initial memory state entry untrusted code phases safety-checking analysis starting initial memory state analysis abstractly interpret untrusted code find safe approximation memory state program point approximations memory states abstract storage model analysis finds memory state program point description state instruction operates default safety conditions access policy attach safety predicate instruction check instruction obeys safety predicate safety-checking analysis consists phases preparation typestate-propagation annotation local verification global verification illustrate phases informally means simple figure shows piece untrusted code sparc assembly language sums elements integer array running entire thesis figure shows host-typestate specification access policy invocation specification figure host-typestate specification states base address integer array size single abstract location summarize elements array safety policy states region integers region readable operable base addresses integer array size region readable operable followable invocation specification states size passed registers code additional registers untrusted code mov clr cmp bge goto clr sll cmp goto add retl nop figure simple summing elements integer array note annotation positive integer invocation untrusted code test lines figure redundant technique based annotating initial inputs untrusted code makes assumption optimization untrusted code preparation preparation phase takes host-typestate specification access policy invocation specification translates initial annotations consist linear constraints typestates inputs initial annotation initial abstract store entry untrusted code preparation phase constructs interprocedural control graph untrusted code figure initial annotations shown figure fact address passed register line column register stores base address integer array points fact size host typestate access policy invocation int initialized int rfo int int rfo integer array size abstract location summarizes elements apandeare region integers region readable operable base addresses integer array size region readable operable followable size passed registers figure host-typestate specification invocation specification access policy initial typestate initial constraints int initialized int rwfo int initialized rwo figure initial annotations convenience listed access permissions abstract location permissions stored location passed register captured linear constraint note access permissions refer registers untrusted code permitted read change registers array overwritten access permission acts surrogate elements permission note machine code register store values types program points model register memory location untrusted code stack writable typestate propagation typestate-propagation phase takes interprocedural control flow graph untrusted code initial annotations inputs abstractly interprets untrusted code annotate instruction abstract representation memory contents abstract storage model abstract representation memory characterizes memory state execution instruction phase discovers instruction line array access holding base address array representing index instruction line loads integer stores register figure summarizes memory state typestates abstract locations execution load instruction line chapter elaborate typestate-checking system phase analysis annotation annotation phase takes input typestate information discovered phase traverses untrusted code annotate instruction safety preconditions assertions safety preconditions divided local safety preconditions global safety preconditions local safety preconditions conditions checked typestate information global safety preconditions verified analysis abstract store int initialized int initialized rwo int rwfo int initialized rwo int initialized rwo figure memory state line global safety preconditions include array bounds checks address alignment checks null pointer dereference checks assertions facts derived results typestate propagation assertions local safety preconditions global safety preconditions instruction line summarized figure stores base address integer array word aligned nonnull instruction loads contents stores register local safety preconditions state location readable initialized writable followable operable global safety conditions verify array index array bounds address calculated properly aligned non-null local verification local-verification phase checks local safety preconditions performs linear scan instructions untrusted code finds local safety preconditions true line describe annotation phase local-verification phase analysis detail chapter global verification global-verification attempts verify global safety preconditions program-verification techniques presence loops induction-iteration method synthesize loop invariants make global-verification phase efficient phase incorporates symbolic range analysis propagates range information registers analysis avoid expensive program-verification techniques range analysis sufficient verassertions local safety preconditions global safety preconditions address integer array mod null readable initialized writable followable operable array bounds checks mod alignment null-pointer checks mod null figure assertions safety preconditions line ify array access bounds symbolic range analysis find line lower bound upper bound analysis verifies array out-of-bounds violations line range analysis induction-iteration method synthesize loop invariant loop lines case prove line index array upper bound prove line note size integer bytes line computed line bythesll instruction induction-iteration method automatically synthesize loop invariant invariant implies holds line turn implies holds line chapter describe global-verification phase analysis detail chapter typestate checking describe phase safety-checking analysis phase abstractly interprets untrusted code produce safe approximation memory state program point safe approximation memory state abstract storage model model represents memory state total map abstract locations typestates abstract location summarizes physical locations typestate describes properties values stored abstract location chapter organized parts part describe basic typestate system includes abstract storage model abstract operational semantics sparc machine-language instructions typestate-checking algorithm propagates typestate information typestate system incorporates subtyping relationship structures pointers analysis check safety untrusted machine code implements inheritance polymorphism physical subtyping part describe techniques strengthen basic typestate-checking analysis techniques include summarize function calls method detect stack-allocated arrays summarizing function calls analysis stop trusted boundaries typestate system safety-checking analysis based abstract storage model abstract storage model includes notion abstract store linear constraints describe linear constraints detail section abstract store total map abstract locations typestates design domain abstract stores finite domain contrast concrete stores form infinite domain general number concrete activation records unbounded presence recursion number concrete objects allocated loop size concrete linked data-structures abstract location summarizes set physical locations abstract location size offset alignment optional attributes location readable writable untrusted code absloc denote set abstract locations symbols denote individual abstract locations size align denote size alignment abstract location call abstraction location summarizes physical location summary location 
register readable writable alignment typestate records properties values stored abstract location typestate defined triple type state access define meet operation typestates typestates form meet semi-lattice meet typestates defined meet respective components describe type state access component typestate system sections type machine-language program register memory location store values types program points typestate-checking algorithm typestate-propagation phase flow-sensitive analysis determines typestate abstract location program point finding greatest fixed point set typestate-propagation equations typestate system incorporates notion subtyping structures pointers approach register memory location occurrence instruction resolved polymorphic type supertype acceptable values type expressions type component type system based physical type system siff figure shows language type expressions typestate system compared type system siff typestate system additionally includes bit-level representations integer types top bottom types parameterized size parameter iii pointer middle array alignment size constraints types shown figure type int represents signed integer bits highest bits middle bits represent sign result sign extension lowest bits represent -bit signed integer represented int -bit signed integer char -bit sign extension represented int type uint represents unsigned integer middle bits zeros bit-level representation integers express effect instructions load store partial words code fragment sparc machine language copies character pointed register location pointed register ldub stb points signed character c-like type system typestate checking lose precision checking code fragment loss precision instruction ldub loads register byte memory zero-fills highest bits type system treats unsigned integer contrast bit-level integer types figure assign type int execution load instruction preserves fact lowest bits store signed character int type denotes pointer points middle array type size introducing pointers middle array analysis handle array pointers precision program reads elements array advancing pointer initially points base address array iteration loop static type pointer inside loop pointer middle array preserves fact pointer points element array contrast ground ground types pointer base array type size pointer middle array type size ptr pointer struct union function top type bits bottom type bits type bits member labeled type offset ground int uint figure simple language type expressions stands type stands structure union member language chosen express type system bit assume untrusted code necessarily written type system conclude pointer pointer element type array type system forbid pointer arithmetic advances pointer point element array subtyping relation introduce notion subtyping type expressions adopted physical-subtyping system chandra reps takes account layout aggregate fields memory figure lists rules define type physical subtype denoted note subtype ordering conventional typestate checking ordering flipped type lattice iff figure rules top bottom ground pointer array additions physical-subtyping system integer type subtype type range represented subrange range represented signextension bits rule member states structure subtype type type member structure subtype consequence rule valid program pass structure place supertype member expected rules structures members state structure subtype prefix member supertype member rule members constraints members structures rule pointer states subtype ptr subtype ptr rule array states pointer base array subtype pointer middle array array types element type figure inference rules define subtyping relation structures top sizeof bottom sizeof ground int int member members reflexivity array pointer ptr ptr uint uint uint int physical subtype rule array crude states meet array types sizes return array size typestate-checking analysis lose precision checking programs outline solution problem section make notion subtyping safety-checking analysis section assignment legal type right-hand-side expression physical subtype type receiving location receiving location space rule array valid describes larger set states global-verification phase analysis check array bounds allowing subtyping integer types structures pointers typestate-checking analysis handle code implements inheritance polymorphism physical subtyping function accepts -bit integer legal invoke function actual parameter signed character int provided actual parameter stored register memory instruction handles sign extension properly case actual parameter physical subtype formal parameter figure shows involves subtyping structures pointers subtyping inference rules structures pointers type colorpoint subtype point function polymorphic legal pass actual parameter type colorpoint function typestate checking subtyping readers familiar problems encountered subtyping presence mutable pointers suspicious rule pointer fact rule pointer unsound traditional flow-insensitive type systems absence alias information flowinsensitive analysis account aliasing unable determine indirect modifications shared data structure indirect modifications disastrous effects figure concrete statement line clrptr point object type point indirectly variable clrptr longer fulfill obligation supply color field line figure shows contents store statement function static technique handle problem detect disastrous indistruct point int int struct colorpoint int int uint color void point y-figure subtyping pointer types rect modifications happen approaches problem found literature linear type system avoids aliases altogether indirect modifications consuming pointer smith singleton types track pointers alias constraints model shape store goal tracks non-aliasing facilitate memory reuse safe deallocation objects approach involves introducing notions immutable fields objects idea subtype type type ptr subtype ptr field subtype field immutable field pointer object field points immutable rule applies transitively approach work correctly mechanism needed enforce immutability restrictions typedef point pointptr typedef colorpoint colorpointptr colorpoint clr point void void pointptr bwptr colorpointptr clrptr clr colorpointptr clrptr pointptr bwptr clrptrcolor figure rule pointer unsound flow-insensitive type checking absence aliasing information assume type declarations shown figure figure contents store statement function figure bwptr clrptr clr clrptr clr clrptr clr clrptr bwptr bwptr bwptr bwptr clr work represents fourth technique system performs typestate checking flow-sensitive analysis tracks aliasing relationships abstract locations state descriptors resemble storage-shape graphs chase similar diagrams shown figure describe state component typestate system section inspecting storage-shape graphs program points access heap-allocated storage safely detect illegal field access occur instance shape graph arises statement figure determine access color statement represents memory-access error programs accesses rejected safety checker state state component typestate captures notion object type state operations state lattice bottom element denoted represents undefined type figure illustrates selected elements state lattice scalar type state denote uninitialized initialized values pointer type state state uninitialized pointer non-empty set abstract locations referenced elements null sets define iff aggregate type state states fields state descriptors track abstract locations represent pieces stackand heap-allocated storage figure portion state lattice null null scalars pointers aggregates resemble storage-shape graphs chase access permissions access permission subset tuple access permissions abstract location stores aggregate access permission tuple access permissions elements tuple denoting access permissions 
respective aggregate fields meet access-permission sets intersection meet tuples access permissions meet respective elements reader puzzled access policy defined terms kinds access permissions typestates kinds reason properties properties location typestates capture properties values access policies permissions abstract locations permissions values model constant access permission abstract operational semantics sparc instructions abstract store total map absloc typestate define abstract operational semantics sparc machine instruction transition function denote type state access component typestate abstract location machine-code operations overloaded typestate lattice includes top element typestate-propagation algorithm perform overload resolution on-the-fly section overload resolution determine typestate abstract location program point finding greatest fixed point set typestate-propagation equations section overload resolution instructions add falls by-product process type components typestates obtained arguments overloaded instructions identify register holds scalar pointer base address array instruction add represents addition scalars pointer indirection array-index calculation achieve define abstract operational semantics sparc machine instructions strict typestate checking propagation information instructions loop delayed non-t arrives loop entrance artifact method occurrence overloaded instruction resolved single usage kind scalar addition pointer indirection array-index calculation call single-usage restriction restriction represent significant limitation practice performing typestate checking flow sensitive typestate checking instruction add resolved pointer indirection occurrence instruction array-index calculation occurrence remainder section assume non-t values disposal propagation type state access information sake brevity figure shows rules propagating type state access information kinds add instruction scalar add array-index calculation storing aggregate field registers opnd integer constant register denote absloc denote types abstract location execution instruction define operation add opnd assumption scalar add array-index calculation store aggregate field lookup type-propagation rule opnd summary location statepropagation rule opnd summary location accesspropagation rule opnd summary location figure propagation type state access information similarly refer possibly empty sequence field names function lookup takes type integers input returns set fields offset size fields exist typestate-propagation rules scalar-add state execution add instruction typestate meet opnd execution typestate abstract locations absloc remain unchanged array-index calculation type destination register type array element type point element array state-propagation rule present single abstract location summarize entire array state destination register source register typestate-propagation rules storing aggregate field divided cases depending strong weak update abstract-location set represents set concrete locations instruction store pointer point unique concrete location summary location case receives typestate source register pointer point concrete locations summary location case destination receives meet typestate operation typestate source register typestate checking typestate-propagation algorithm works interprocedural control-flow graph nodes graph represent instructions edges represent control-flow usual fashion instruction node control-flow graph associate total maps pretypestate absloc typestate posttypestate absloc typestate maps safely approximate program states instruction respective program point define meet total maps map constructed performing meet respective elements absloc typestate defined absloc facilitate presentation define notation initialstore map abstract locations typestates abstract locations entry untrusted code initial store computed phase cfgedge set control-flow edges instruction set instructions untrusted code startnode instruction entry point foreign code incoming outgoing instruction cfgedge cfgedge denotes power set cfgedge mapping functions give control-flow edges link instruction control-flow predecessors successors interpret instruction interpret abstract operational semantics instruction section algorithm standard worklist-based algorithm starts map program points abstract locations typestate algorithm typestate propagation shown figure initially start node untrusted code worklist instruction chosen worklist examined start node pretypestate initialstore typestates abstract locations entry examined instruction meet typestates exits instruction predecessors instruction interpreted abstractly typestates abstract store exit instruction change case instruction successor examined instruction added worklist typestate propagation worklist startnode worklist empty select remove instruction worklist startnode initialstore foreach control-flow edge incoming posttypestate pretypestate oldposttypestate posttypestate posttypestate interpret pretypestate posttypestate oldposttypestate foreach control-flow edge outgoing worklist worklist figure propagation typestate nodes control-flow graph represent control-flow edge edge node represents source edge node represents target edge process repeated worklist empty figure shows results typestate propagation applied running column shows instructions left column shows abstract store execution instruction lines correspond loop initially holds base address integer array elements summarized holds size array typestate checking initiated placing mov instruction line worklist abstract interpretation mov instruction line sets contents point typestate changed instruction line worklist interpretation clr instruction line sets contents process continues worklist empty line results show holds base address integer array integer index sections describe techniques strengthen typestate-checking analysis techniques include technique summarize calls trusted functions technique determine types sizes stack-allocated arrays summarizing calls typestate untrusted code mov clr cmp bge clr sll cmp add retl nop figure results typestate propagation int rwfoe int int rwo int int rwo int rwfo int rwfo int int rwo rwo int rwfo int int rwo rwo int rwfo int int rwo rwo int rwfo int int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwfo int rwo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwo int rwfo int int rwo int rwo int rwo int rwfo int rwo int int rwo int rwo int rwo int rwo int rwfo summarizing function calls safety-checking analysis stop boundaries trusted code tracing body trusted callee analysis check call obeys safety precondition postcondition rest analysis describe method summarizing trusted calls safety preand post-conditions terms abstract locations typestates linear constraints safety preconditions describe obligations actual parameters meet postconditions provide guarantee resulting state produce safety preand post-conditions hand process errorprone desirable automate generation function summaries recent work interprocedural pointer analysis shown pointer analysis performed modular fashion techniques analyze function assuming unknown initial values parameters globals function entry point obtain summary function dataflow effect function follow-on work thesis investigate techniques create safety preand postconditions automatically represent obligation provided actual parameter placeholder abstract location placeholder short size access permissions typestate provide detailed requirements actual parameter satisfy formal parameter pointer state descriptor include placeholders represent obligations provided locations pointed actual parameter model state descriptor pointer-typed placeholder refer null placeholder placeholder null refers null actual parameter point null refers placeholder locations pointed actual parameter satisfy obligation denoted placeholder state descriptor refers null placeholder actual parameter point null locations satisfy 
detecting manipulated remote call streams abstract internet mobile code ubiquitous includes examples browser plug-ins java applets document macros paper address important vulnerability mobile code security exists remote execution systems condor globus seti home systems schedule user jobs execution remote idle machines send important system calls back local machine execution evil process remote machine manipulate user job send destructive system calls back local machine developed techniques remotely detect manipulation job submitted remote execution construct model user binary program static analysis binary analysis applicable commodity remote execution systems applications remote job execution model checks system calls arriving local machine execution allowed continue model remains valid begin finite-state machine model accepts sequences system calls build optimizations model improve precision efficiency propose program transformations renaming null call insertion significant impact precision efficiency desirable side-effect techniques obfuscate program making harder adversary reverse engineer code implemented simulated remote execution environment demonstrate optimizations transformations binary program increase precision efficiency test programs unoptimized models increase run-time moderate levels optimization run-time increases precision gains reaching introduction code moves internet forms including browser plug-ins java applets document macros operating system updates device drivers remote execution systems condor globus seti home mobile code traditionally raises basic trust issues code imported machine perform malicious actions remotely running code execute malicious modification addressing important variant case safety code executes remotely makes frequent service requests back local machine figure case concerned remotely executing process subverted make malicious requests local machine popular condor remote scheduling system remote execution environment condor user submit job program possibly jobs condor run idle machines local environment machines scattered worldwide condor jobs execute compatible machine special privilege jobs send file-access critical system calls execute home machines home local machine acts remote procedure call rpc server remote job accepting remote call requests processing call context user local system type remote execution frequent interactions machines differs execution mobile agents remote job executes completion attempting contact report back local machine remote job subverted request local machine perform dangerous destructive actions system calls subverting remote job idea quickly easily tools paper describe techniques detect remote job making requests differ intended behavior jonathon giffin somesh jha barton miller computer sciences department wisconsin madison giffin jha bart wisc work supported part office naval research grant department energy grants de-fg de-fg lawrence livermore national lab grant nsf grant eiathe government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government addressing issue local host safety protecting remote job inappropriate access data detecting modification calculated result inappropriate remote system calls local machine accepts calls valid verifying remote job generated calls correct execution vulnerable maliciously generated calls conventional authentication methods secret data fail inherently risky environment attacker present remote code including authentication mechanism key manipulate code local machine distrust calls remotely executing code ability validate requests vulnerability exists thousands machines worldwide running condor globus java applets similar systems techniques address deficiency basic approach detecting malicious system call streams perform pre-execution static analysis binary program construct model representing remote call streams process generate process executes remotely local agent operates model incrementally ensuring call received remains model call fall set expected calls determined model remote process manipulated precise model closely mirror execution behavior application noticed specification program intended behavior host-based intrusion detection approach brings benefits intrusion detection systems direct operation binary code automated construction specifications elimination false alarms protection types attacks address important source vulnerabilities request verification cryptographic authentication mechanisms trusted program model representing sequences remote system calls valid previous model construction techniques include human specification dynamic analysis dynamic analyzer completes training runs multiple execution traces build probability distributions indicating likelihood call sequence false alarms occur training runs exercise program control flows static analysis produces non-probabilistic models representing control flow paths executable models conservative producing false alarms potentially accepting attack sequence valid models finite-state machines control flow graphs generated binary code analysis construct non-deterministic finitestate automaton push-down automaton mirror flow control executable automata natural structures represent sequences remote call names push-down automata precise develop optimizations increase precision maintaining run-time efficiency evaluate program models metrics precision efficiency precision measures tightly model fits application represents improving precision reduces opportunity attack accepted valid model efficiency rates runtime impact model operation evaluate techniques models built prototype static analyzer model builder simulated remote execution environment read binary programs sparc solaris machines produce model operation simulated local agent agent receives notifications application system calls encountered execution operates model models efficient non-deterministic finitestate automaton nfa models add run-times test applications precise nfa models optimizations invaluable moderate optimization levels improve precision keeping run-time overheads optimized push-down automaton models precise overheads low precision values optimized models approach indicating opportunity adversary begin attack strategies counter mobile code manipulation exploits generally orthogonal finds greatest security level incorporating components areas solution replication form byzantine agreement remote call accepted genuine majority replicated processes executing machines generate identical call figure remote execution system calls executed home local machine local agent local host remote host remote system calls application process verify results returned mobile agents techniques limited environment frequent system call interactions wide network obfuscation program transformed operationally equivalent difficult analyze applying variant techniques improve ability construct precise state machines hamper adversary ability understand semantics program popular recent years discount obfuscation based barak section discuss theoretical results directly apply context sandboxing running program environment harm dates back early days multics operating system project crisis maintains per-process permissions limit system access webos techniques considered variety sandboxing based strong analysis binary program construction verifying model support analysis paper makes contributions areas binary analysis target commodity computational grid environments availability source code analysis assumed analysis restricted source language techniques wide applicability model optimizations develop techniques increase precision finite-state machines generate limiting opportunities attacker exploit weakness model reduce number spurious control flows generated models dead automata removal automata inlining bounded stack model hybrid model argument recovery reduces opportunities exploit present linear time -reduction algorithm simplify non-deterministic state machines reduced model non-determinism obfuscatory benefits call sites program generate requests opens technique call site renaming great 
obligation represent obligations list pre-conditions form placeholder typestate safety postconditions provide safety-checking analysis compute resulting state call summarized function represented list postconditions form alias context placeholder typestate alias context set potential aliases potential non-aliases neq placeholders alias contexts capture aliasing actual parameters affect resulting state safety preand post-conditions include linear constraints safety preconditions represent additional safety requirements postconditions provide additional information resulting memory state call make idea concrete figure shows summarizes library function gettimeofday specifies call safe null address writable location size sufficient storing type struct timeval safety postconditions execution call fields location pointed call initialized initialized integer note points null execution call placeholder irrelevant bound actual abstract location perform binding process section sparc parameters function passed registers return function stored register figure alias contexts empty ambiguity aliasing alias contexts summarize function calls precision opposed make fixed assumptions aliasing figure shows alias contexts provide precision function returns null object pointed parameter depending aliases checking call trusted function involves binding process update process binding process matches placeholders actual abstract locations checks meet obligation update process updates typestates actual locations represented placeholders safety postconditions goal summarize library functions generally complicated things pointers present focused obligations represented tree placeholders obligations represented fall back letting typestate-propagation phase trace body function binding process carried simple algorithm binding algorithm iterates formal parameters obtains respective actual parameters typestate descriptors int gettimeofday struct timeval safety precondition struct timeval ptr null struct timeval safety postcondition struct timeval int int int figure safety preand postconditions typestate aggregate typestates components enclosed component labeled offset bits closest enclosing aggregate call site traverses obligation tree checks actual parameter meets obligation establishes mapping placeholders set abstract locations represent store callsite binding process distinguishes information information intuitively placeholder represent location binding algorithm establish represent unique concrete location algorithm updating process interprets postcondition distinguishes strong update weak update depending placeholder represent unique location represent multiple locations alias context evaluates true false strong update placeholder represents unique location alias context evaluates true weak update placeholder represent multiple locations alias contexts determined true false case typestate location receives meet typestate call typestate postcondition alias context determined true false update postcondition place make safe assumption performing weak update detecting local arrays determining type bounds information arrays reside stack difficult describe method inferring subrange stack frame holds array illustrate method simple figure shows program updates local array column shows pointptr pointptr pointptr null return safety precondition pointptr ptr pointptr ptr pointptr safety postcondition neq pointptr pointptr null figure safety preand post-conditions alias contexts sparc machine code produced compiling program gcc-o version infer local array present examine live pointers time typestate-propagation algorithm reaches entry loop discussion abstract location denotes stack frame allocated add instruction line denotes point offset denotes subrange starts offset ends offset abstractly interpreting add instructions lines find points points time typestate-checking algorithm visits loop entry point column figure abstractly interpreting instructions line line reveals stores integer time typestate-checking algorithm visits loop entry points candidate local array reasoning runs create fictitious components shown right-most column figure point component instruction polymorphic usage program point pointer pointer compatible types choice compatible type system pointer array letting denote type array element compute general type steps compute size compute greatest common divisor gcd sizes slots delimited pointer consideration slot program sparc machine language time time typedef struct int int int main int main add add mov add cmp bgeu mov add cmp blu add retl figure inferring type size local array label represents entry loop int size size compute limits array assume array ends location closest live pointer stack pointer consideration global-verification phase verify local array inferred bounds compute type assuming size computed create fictitious location size give initial type slide area identified step bytes time bytes time perform meet operation covered area covered sub-area type assume type find struct int refinement needed general make refinements findings iterations typestate-checking algorithm refinement bring element type array type lattice address consideration register general form registers integer method heuristics compute bounds array affect soundness approach reasons typestate-propagation algorithm make program type correct ensure element type inferred consistent rest program global-verification phase verify inferred local array inferred bounds note matter analysis original program written terms n-dimensional array terms -dimensional array analysis treats arrays -dimensional arrays approach works original code written terms n-dimensional array layout scheme compilers n-dimensional array involves linear indexing scheme reflected linear relationships analysis infers values registers related work compare typestate-checking analysis mycroft technique recovers type information binary code mycroft technique reverse engineers programs target machine code type-inference techniques type-reconstruction algorithm based milner algorithm associates type constraints instruction static single-assignment ssa representation program type reconstruction unification mycroft technique infers recursive datatypes loops recursive procedures start annotations initial inputs untrusted code technique requires annotation abstract interpretation unification note technique detect local arrays based principle unification technique mycroft technique recovers types registers memory locations technique handle stackand heap-allocated objects technique recovers type information propagates type state access information analysis flow-sensitive mycroft flow-insensitive recovers degree flow sensitivity ssa form variables live ranges chapter annotation local verification annotation phase safety-checking analysis annotates instruction piece untrusted code safety preconditions assertions safety preconditions assert instruction obeys safety properties enforce assertions facts assist validation safety preconditions local-verification phase verifies safety preconditions validated results typestate propagation describe annotation local-verification phases illustrate means running annotation annotation phase consists steps step attaches collection safety predicates usage instruction step annotates instruction untrusted code safety preconditions assertions linear scan untrusted code attachment safety predicates instruction scalar add add array-index calculation annotation phase attaches collection safety predicates safety predicates assert instruction abides default safety conditions host-specified access policy safety predicates divided local safety predicates global safety predicates depending predicates validated typestate information illustrate local global safety predicates attached usage instruction figure summarizes safety predicates cases add scalar add array-index calculation case stores aggregate field case loads array scalar add safety predicate specifies uninitialized values predicate readable true iff readable predicate operable true iff predicate readable explicitly figure registers readable writable default safety predicates array-index calculation state opnd readable operable index bounds array predicate inbounds size low high true 
ability reduce non-determinism models uniquely naming call site program rewriting executable insert null calls dummy remote system calls points high non-determinism provide degree context sensitivity model call site renaming null call insertion additionally obfuscate code remote call stream binary rewriting obfuscation techniques likewise context-free language approximations general language generated execution trace program context-free push-down automaton finitestate machine includes run-time stack defines context-free language automata prohibitively expensive operate incrementally stack growth potentially consumes system resources stack abstractions over-approximate context-free language regular language push-down automata bounded run-time stack expensive operate require finite resources provide background condor system remote execution computational grid environment security exploits section section presents analysis techniques algorithmic fashion experimental results found section comparison previous work section related work found section conclude section descriptions areas continuing work threats remote execution common scenario important class remotely executing jobs require communication path back local machine originated job job sends critical system calls file access network communication back local machine execute context submitting user type remote execution occurs condor distributed scheduling system globus computational grid infrastructure java applets implementation research takes place context condor condor schedules jobs hosts originator organization machines belonging organizations addition scheduling remote jobs condor checkpoints migrates jobs reliability performance reasons job figure grid environment exploit lurker process attaches remote job inserting code takes control network link local agent application process local host remote host malicious remote calls lurker execute times hosts administrative domains condor prevalent execution environment scientific research year researchers condor solve -year-old unsolved combinatorial optimization problem called nug remote jobs ran processors united states italy administrative control program authors network path remote process originating host included public internet links malicious party access execution machines network links manipulated originating machine detail remote system calls condor simply variant remote procedure call rpc client stub library linked application program standard system call library stub functions library package parameters call message send message network submitting machine await result local agent submitting machine services calls unpacking request executing call packaging sending result back remote machine rpc model exposes submitting machine vulnerabilities vulnerabilities common characteristic malicious entity remote machine control job control remote system call stream malicious system call stream variety bad things submitting user simplest case malicious remote host host owner administrative privileges takes control remote job complex harder-to-track cases caused previous malicious remote jobs previously discovered vulnerability condor characteristic remote job executes typically run common low privilege user malicious user submit job forks creates process terminates child process remains running appears condor job terminated job scheduled run host lurking process detects newly arrived job dynamically attaches job takes control lurker generate malicious remote calls executed detriment machine originated innocent job figure similar results unusual attacks call stream crosses network secure machine network impersonate application process generating spoofed calls treated local host genuine imposter applets successfully impersonation attacks servers original applets communicate generating models static analysis start binary program submitted execution execution analyze program produce components checking agent modified application figure checking agent local agent incorporates model application agent receives remote system calls execution verifies authenticity call operating model execution continues model remains valid state modified application original program binary code rewritten improve model precision offering modicum obfuscation modified application executes remotely transmitting remote system calls checking agent models finite-state machines nondeterministic finite automata nfa push-down automata pda edge automaton labeled alphabet symbol identity remote system call automaton final states states operation automaton successfully cease ordered sequences symbols connected sequences edges entry state final state define language accepted automaton application language defined perfect model application precisely sequences remote system calls generated program correct execution arbitrary input construction automaton modeling application progresses stages control flow graph cfg built procedure binary cfg represents execution paths procedure figure static analyzer reads binary program produces local checking agent modified application executes remotely checking agent incorporates model application analyzer binary program checking agent modified application convert collection cfgs collection local automata local automaton models streams remote system calls generated single procedure compose automata points function calls internal application producing interprocedural automaton modeling application interprocedural automaton model incorporated checking agent figure shows language program writes string standard output main function translates sparc code figure compiled include code solely reader ease remainder section demonstrates analysis binary code compiler assembler produces source program binary code cfgs standard tool read binary code generate cfgs executable editing library eel abstract interface parse edit rewrite sparc binary executables eel builds objects representing binary analysis including cfg procedure call graph representing interprocedural calling structure program nodes cfg basic blocks linear sequences instructions edges blocks represent control main int argc char argv argc write argv line end write close line int write end int line close main save cmp ble main mov call write mov call line mov call end mov main nop main sethi dnone dnone call write mov call close mov main ret restore figure code code writes stdout command line argument text string argument provided sparc assembly code main show assembly code line end figure control flow graph main control transfers sparc code delay slot outgoing edges basic block labeled call block cfg entry save cmp ble mov call write mov call line mov call end mov nop ret restore cfg exit sethi dnone dnone call write mov call close mov close write write line end flow paths branches figure shows cfg main figure cfgs local automata procedure cfg construct nfa representing sequences calls procedure generate natural translation cfg nfa retains structure cfg labels outgoing edges basic block function call block call exists outgoing edges blocks function call labeled automaton mirrors points control flow divergence convergence cfg streams calls arise traversing flow paths formally convert control flow graph nfa set states input alphabet transition relation unique entry state set accepting states reduce space requirements nfa reduced minimized classical -reduction algorithm simultaneously determinizes automaton exponential process develop linear time reduction algorithm shown determinize automaton algorithm recognizes set states strongly connected component made -edges reachable consuming input symbol collapses single state resultant graph reduced automaton figure standard algorithms data structures reduction procedure runs linear 
iff low size high size align size predicate align true iff safety predicates state followable valid index field size non-null address properly aligned predicate followable true iff pointer type predicate assignable true iff readable writable align align align sizeof size hold instruction loads array local safety predicates instruction state base address array followable operable operand operation assumptions local safety predicates global safety predicates add opnd scalar add operable operable opnd add opnd array-index calculation operable operable opnd null inbounds sizeof opnd store aggregate field lookup followable operable forall assignable null forall align align sizeof opnd load array opnd int followable operable operable opnd readable operable assignable align inbounds sizeof opnd sizeof figure attachment safety properties registers readable writable default array index operable integer type iii abstract location surrogate elements array readable operable predicate assignable true global safety predicate ensures loading address properly aligned array index bounds array generating safety preconditions assertions safety predicates annotation phase performs linear scan machine instructions untrusted code generates safety preconditions instantiating safety predicates figure actual operands instructions instantiated safety predicates called local global safety preconditions depending precondition instantiated local global safety predicate safety preconditions annotation phase attaches assertions instruction assist verification phases assertions facts derived results typestate propagation machine code type means set values set valid operations defined values includes physical properties size alignment constraints typestate-propagation algorithm establishes location stores valid address type address alignment property assertions means give verifier access information local verification verification local safety preconditions purely local process phase generates error message violation local safety preconditions illustrate annotation local-verification phases applied running sums integer array results annotation phase shown figure assertions shown column figure entry untrusted code register stores base address integer array non-zero wordaligned similarly typestate analysis revealed stores base address array program points annotation phase generate assertions points columns figure show local global safety preconditions generated instruction untrusted code load instruction program point typestate information point register base address integer array integer array index load instruction loads arbitrary element array stores local safety preconditions state readable stored followable operable abstract location surrogate elements array readable operable global safety conditions program point state address calculated -byte aligned stored index greater equal upper bound array upper bound size array element global safety precondition states array index -byte aligned local-verification phase local process generates error message violation local safety preconditions running verify local safety preconditions true untrusted code assertions safety preconditions local global mov operable clr operable cmp operable operable bge clr sll operable followable operable operable operable readable operable cmp operable operable add operable operable retl nop figure safety preconditions produced annotation phase chapter global verification global-verification phase safety-checking analysis verifies global safety preconditions check array out-of-bounds violations address misalignment violations null-pointer dereference violations global safety preconditions represented linear constraints verify global safety preconditions advantage synergy efficient range analysis expensive powerful program-verification technique applied demand range analysis determines safe estimates range values register program point determining accesses arrays bounds apply program-verification technique safety preconditions proven results range analysis rest chapter starts introduction program verification description linear constraints represent global safety preconditions technique synthesize loop invariants symbolic range analysis perform array bounds checks key automated program verification system synthesize loop invariants describe induction-iteration method synthesizing loop invariants extensions induction-iteration method program verification floyd set cornerstone program verification idea attaching assertions statements describe behavior technique called inductive assertion method approach models program flowchart control-flow graph nodes represent program statements edges represent control flow logical assertions attached control-flow edges program correct respect assertions shown assertions true control passes edges hoare refined approach developing concise notation represent effect program construct terms logical precondition postcondition developed set axioms inference rules reasoning preand post-conditions traditionally program verification focused proving program conforms logical specification giving precondition true program inputs program entry point verifying postcondition true exit attach assertions edges program flowchart show assertions true control passes edges postcondition true paths program entry program exit programs acyclic flowcharts attachment checking assertions generating verification conditions vcs verifying vcs theorem prover generation forward backward backward approach statement postcondition verified generation finds weakest precondition precondition true statement terminates postcondition true forward approach generation finds strongest postcondition program construct precondition major difficulty automated program verification system synthesize loop invariants presence loops program loops generation process terminate due cycles program control-flow graph cope problem program partitioned loop entry points loop invariant synthesized loop loop invariant assertion assertion true loop entry implies true loop entered iteration verifying correctness program loop involves proving loop invariant implies postconditions proved loop invariant true entry loop iii loop invariant reestablished subsequent iteration proving program program conforms specification general logic difficult achieve mechanically global-verification phase analysis focuses small set conditions prevent program performing out-of-bounds array misaligned loads stores null pointer dereferences sections describe linear constraints expressing global safety conditions theorem prover induction-iteration method introduced suzuki ishihata synthesizing loop invariants unlike standard techniques program verification monolithic created properties prove induction-iteration method checks validity global safety preconditions demand-driven fashion verifies conditions time linear constraints theorem prover array-bounds null-pointer address-alignment requirements represented linear equalities inequalities theorem prover based omega library omega library represents relations sets presburger formulas formulas constructed combining affine constraints integer variables logical operations quantifiers affine constraints equality inequality constraints presburger formulas decidable give examples linear constraints index index length pointer pointer address constraint expresses array index bounds array size length constraint expresses pointer null constraint expresses address -byte aligned omega library fourier-motzkin method determine presburger formula tautology satisfiable basic operation omega library projection set linear equalities inequalities set variables projecting constraints variables produces set constraints variables integer solution original problem omega library determines set constraints integer solutions projection eliminate variables constraints involve single variable point easy check integer solution projecting set constraints generates pugh wannacott propositions represented conjunction linear equalities inequalities omega test check tautology satisfiable tautology checking tautology trivial details omega library kelly pugh induction-iteration method untrusted code loops synthesize loop invariants system synthesis loop invariants attempted means induction-iteration method present basic algorithm section describe extensions induction-iteration method chapter induction-iteration method weakest liberal precondition wlp heuristic generating loop invariants weakest 
liberal precondition statement respect postcondition denoted wlp condition statement executed state satisfying true termination terminates condition weaker satisfies weakest liberal precondition differs weakest precondition weakest liberal precondition guarantee termination technique works machine language programs extended inductioniteration method work reducible control-flow graphs description assume control-flow graph partitioned code regions cyclic natural loops acyclic control-flow graph reducible iff partitioned disjoint sets forward edge set back edge set forms dag node reached entry node edge target edge dominates source backedge control-flow graph nodes natural loop subgraph consisting set nodes nodes reached graph passing edge set connecting nodes set implementation merge natural loops share entry node reduce number loops global-verification phase analyze restriction reducible control-flow graphs represent significant limitation practice study cited muchnick showed selection real-world fortran programs reducible control-flow graphs addition irreducible control-flow graph transformed reducible technique called node splitting instruction type weakest liberal precondition comments mov opnd opnd move add opnd opnd integer add sll opnd opnd logical left shift cmp opnd icc opnd comparison opnd opnd load label branch figure weakest liberal preconditions sample sparc instructions respect postcondition method generating wlps non-conditional instructions generating weakest preconditions figure lists wlps respect postcondition sample sparc instructions figure registers icc integer condition code opnd integer constant register operations integer addition subtraction multiplication denotes occurrences replaced expression reminder chapter addr denote stored memory location address addr simplify matters omit sizes memory locations opnd represents stored address opnd weakest liberal precondition respect load instruction opnd occurrences replaced opnd show compute weakest liberal precondition store instruction section compute wlp natural loop define wlp generated back-substituting postcondition proved entry loop reached wlp loop-body define wlp loop-body wlp loop formula show compute weakest liberal precondition condition repect acyclic code region section denote induction-iteration method attempts find true entry loop loop invariant implies wlp loop-body suzuki ishihata show established showing true entry loop inv inv argument runs assumption implies implies observe equivalent wlp loop-body wlp loop-body wlp loop-body wlp loop-body induction iteration method essence iterates steps create expression current candidate loop invariant generate vcs inv inv attempt verify vcs theorem prover figure shows basic induction-iteration algorithm suzuki ishihata rewritten pseudo code algorithm perform max number iterations induction steps discussed section found practice situation sufficient set max number iterations reader puzzled algorithm tests inv tests inv test inv matches test inv performed previous iteration case inv holds vacuously true enhancements induction-iteration method made enhancements basic induction-iteration algorithm handle sparc instruction set store instructions nested loops procedure calls make global verification phase precise efficient handling sparc machine language section discuss extensions needed handle sparc instruction set including delay slots annulled instructions condition codes handle delay-slot instructions possibly annulled construct controlinduction iteration success failure create formula max number iterations case theorem prover inv true return success case theorem prover wlp inv true wlp loop-body return failure return failure figure basic induction-iteration algorithm flow graph instruction delay slot basic block basic block basic block branch instruction instruction precedes branch target instruction precedes delay-slot instruction annul bit set respective delay-slot basic block included path basic block delayed instruction replicated included fall paths figure handle condition codes model sparc condition code variable icc holds result arithmetic operation instruction cmp opnd icc hold -opnd label exit edges conditions edges form icc relop relop relational operator including illustrate code fragment annulled branch cmp ble target add line number instruction represent instruction sequence numbers represent path figure illustrates compute wlp condition program point respect path model effect cmp instruction icc label edge represents fall branch condition icc wlp icc wlp icc compute wlp acyclic code region standard technique verification-condition generation figure illustrates condition branch direction enclosed curly brackets back-substitufigure branch delay slot instruction delay slot branch target fall icc icc branch annul bit set instruction delay slot branch target fall icc icc branch annul bit set instruction delay slot tion control-flow merge point multiple outgoing edges conjunction conditions outgoing edge junction node computed performing back substitution junction node figure handling sparc condition code figure weakest liberal precondition acyclic code region wlp icc wlp weakest liberal precondition icc icc ble target control-flow graph add wlp wlp wlp wlp wlp wlp wlp wlp wlp wlp wlp branch code region control-flow edge wlp wlp wlp wlp handling store instructions compute wlp store instructions based morris general axiom assignment general framework computing weakest precondition assignments pointer-typed variables describe morris general axiom assignment define weakest liberal precondition store instructions denote addresses denote pointer dereference denote storing result produced evaluating expression memory location address omit sizes memory locations assume side-effects define definition denote arbitrary postcondition axiom computing wlp store instruction wlp stands occurrences replaced words weakest liberal precondition assignment alias replaced difficulty analyzing machine-language programs determining addresses determined cases back-substitution code fragment load store instructions mov mov verify postcondition program point show result back-substituting formula instructions code fragment line number instruction represent instruction wlp wlp wlp wlp true note destination address store instruction line source address load instruction line determined back-substitute formula mov instruction line multiple store instructions instruction sequence complicates situation determine dependences instructions point disambiguate addresses store instruction affect load instruction killed store instruction load instruction morris axiom concurrent assignment handles situation list store instructions executed sequentially denote list addresses denote list expressions arbitrary address define definition arbitrary postcondition axiom computing wlp list store instruction wlp stands occurrence replaced handling multiple loops basic induction-iteration algorithm assumes single loop program apply induction-iteration method programs multiple loops extensions needed simplify matters show extensions basic induction-iteration algorithm programs kinds loop structures consecutive loops nested loops cases combinations cases figure illustrates steps prove postcondition program consecutive loops assume loops synthesize loop invariant loop implies induction step compute establish implied conjunction true entry loop establish true entry loop apply inductioniteration method recursively loop synthesize loop invariant loop generated loop verify true entry loop synthesize loop invariant inv loop inv imply condition figure illustrates steps needed prove postcondition program nested loops assume loops compute outer loop induction-iteration method synthesize loop invariant inv loop property inv wlp inv synthesized computed case formula wlp inv obtained true entry outer loop implies 
inv true entry loop prove explicitly figure applying induction iteration method consecutive loops wlp inv inv implies program text control-flow graph test statement control-flow edge wlp inv true entry loop makes synthesizing inv local loop implementation extended induction-iteration algorithm employs backtracking strategy finding induction step overcome problem results weakening formula due irrelevant conditionals program apply strategy called generalization sectons backtracking synthesizing inv case computing wlp loop due synthesis loop invariant outer loop vely testing loop true entry loop process terminate record current trial invariant outer loop verify implies fails test true entry loop disregarding back edges paths entry program entry loop treating part program entry entry loop acyclic weak tests provide means drive backtracking process synthesizing invariants loop affect soundness technique outer loop computed back-substituting respective invariant synthesized loop analysis verify outer loop true entry outer loop figure applying induction iteration method nested loops inv wlp wlp inv program text test statement control-flow edge control-flow graph begin end handling procedure calls procedure calls complicate induction-iteration method ways handling procedure call performing back-substitution reaching procedure entry prove disprove condition iii recursion handle procedure calls back-substitution simply walk body callee inlined caller generate wlp callee function respect postcondition propagated callsite make generation efficient procedural calls tabulation procedure calls reuse previous results generation reach entry procedure check conditions true callsite conditions postconditions proven caller simplify matters present system detects rejects recursive programs principle induction-iteration method synthesize invariant entry conditions recursive functions loops strengthening formulae conditionals program weaken extent prevented loop invariant simple code fragment figure consecutive loops show fail prove index variable greater equal program point verify program point induction-iteration method produce loop subscript distinguish produced loop produced loop verify true entry loop synthesize loop invariant loop simplify things ignoring test program point produced loop induction-iteration method fail synthesize loop invariant loop strengthened induction step induction iteration stronger address problem strengthen computing disjunctive normal form wlp loop-body disjuncts turn rank candidates simple heuristic comparing disjuncts original formula propagated program point conditionals test potential candidates breadth-first strategy shown figure easy verify disjunct loop invariant loop figure shows extended induction-iteration algorithm breath-first search strategy algorithm worklist hold candidates item worklist components prev component formula tentative component prev backward link obtain respective represented formula function disjuncts returns set formulae disjuncts disjunctive normal form formula incorporating generalization breath-first strategy extended induction-iteration algorithm incorporates technique called generalization introduced suzuki ishihata generalization formula defined elimination elimination fourier-motzkin variableelimination method eliminate variables set variables generate simplified set constraints integer solution resulting generalizations turn chosen generalized formula show generalization applied running section figure conditionals program weaken extent prevented loop-invariant induction step induction step typedef struct node int presburger formula prev node ptr presburger formula max number iterations worklist list node ptr disjuncts presburger formula set presburger formua induction iteration success failure disjuncts wlp loop-body foreach worklist append node null worklist empty worklist prev prev k-case theorem prover inv true return success max number iterations theorem prover wlp inv disjuncts wlp loop-body foreach worklist append node switch return failure figure induction-iteration algorithm breath-first search controlling sizes formulae conditionals program formula consideration grow exponentially size verification condition generation reduce effect back-substitution code region performed backwards topological order respect program controlflow graph formula junction point simplified strategy effectively controls size formulas considered ultimately time spent theorem prover sharing common computations reduce number times induction-iteration algorithm performed back-substitute formulas proven reach loop entry partition formulae groups made comparable constituents invoke induction-iteration algorithm starting strongest formulas group verify stronger formula true implies formulae weaker formula true performing simple tests assuming acyclic code fragment program consecutive loops verify true entry loop synthesize loop invariants earlier loops conditions eventually part synthesized loop invariant waste effort conditions rejected reduce effect candidate expensive process verifying true entry loop perform simple test treats part program entry program entry loop acyclic performing simple test handle test case kernel device driver handle illustrate induction-iteration method applied running introduced figure section control-flow graph program shown figure instructions lines replicated model semantics delayed branches single integer variable icc model sparc condition code label control-flow graph edge condition edge line number instruction denote instruction sequence line numbers square brackets represent path verify holds line perform back-substitution starting back-substituting condition line produces instruction line entry natural loop attempt synthesize loop invariant implies set tautology verify true entry loop create formula fact true entry loop shown back-substituting path create perform back-substitution loop body starting formula reach loop entry wlp wlp icc wlp icc wlp wlp formula tautology continuing creating strengthen generalization technique mentioned section steps generalize negating produces eliminating produces iii negating produces consefigure induction iteration sll cmp mov clr cmp bge clr add retl nop clr add icc icc icc icc quently set generalized formula case tautology formula create round back-substitution variables modified loop body implies means loop invariant synthesized line invariant implies holds line turn implies holds line scalability induction-iteration method potential improvements section address scalability verification phase discuss potential improvements enhanced induction-iteration method major cost verification phase performing induction-iteration method cost determined number iterations performed invariant identified cost iteration step induction-iteration method determined cost perform generation invoke theorem prover cost invoke theorem prover dominate costs ultimately determined characteristics untrusted code experience sufficient set maximum allowable number iterations loop intuition number iteration incorporate conditionals loop iteration test loop invariant information discovered iteration limit number induction steps loop assume loops program worst-case scenario require induction steps verify safety condition program consecutive loops worst-case scenario verifying true entry loop requires synthesize loop invariant preceding loop situation preceding loop worst-case scenario happen program nested loops compute requires synthesis loop invariants loops practice worst-case scenario seldom happen variables loop initialized loop preceding loops verify true entry loop tests loops contribute proof condition outer loop enhancements previous section enhancements principle made existing prototype employ caching theorem prover represent formulas canonical form previous results perform tabulation function calls nodes multiple incoming edges reuse previous results generation efficient algorithms simple formulas people methods trade generality constraint system efficiency bodik describe method eliminate array-bounds checks java programs method restricted form linear constraints called difference 
time automaton minimization recognizes equivalent states equivalence sequences symbols accepted states identical states collapsed reducing size complexity automaton nlogn algorithm exists minimize deterministic automata easily abstracted nfa prototype version algorithm suitable nfa figure local automata local automata functions figure -reduction unique cfg entry line end main line close writeline close write write end gve call labeled fvv cfg exit call call labeled ste figure final nfa model automaton produced call site replacement -reduction performed dotted line represents path present original program accepted model abstract automaton directed graph -edges calculate strongly connected components graph states strongly connected component reach sequence -transitions states collapsed directed acyclic graph dag collapsed states remaining -edges connect strongly connected components non-edges originating state dag add copies originating states reaches sequence -edges remove -edges connect strongly connected components remove unreachable states edges graph line end main close write close write write local automata interprocedural automaton constructing interprocedural nfa extend notion single procedure nfa model model entire application local automata composed form global nfa call site replacement replace edge representing procedure call control flow automaton modeling callee common technique construct system dependence graphs wagner dean work edge representing called function control flows model function recursion handled function call call site replacement reintroduces -edges automaton reduced figure presents final automaton -reduction clarity replication automata call site replacement links multiple call sites procedure local automaton final state called automaton -edges returning call sites impossible paths exist control flow enter automaton call site return -edge figure behavior impossible actual program execution malicious user manipulating executing program edges model exploit applications thousands procedures thousands call sites imprecision addressed constructing interprocedural pda introduction impossible paths classical program analysis problem arising context insensitive analysis push-down automaton eliminates impossible paths additionally modeling state application run-time stack executing application follow impossible path return site location stored run-time stack pda context sensitive including model stack precisely mirror state running application interprocedural change construct local automata -edges added call site replacement identifier uniquely call edge return state figure -edge linking source function call edge entry state called automaton pushes return state identifier pda stack executing program pushes return address run-time stack -edges returning control flow callee pop identifier pda stack mirroring application pop return address run-time stack pop edge traversed identifier edge matches symbol top stack identifiers edges define matched sets edges return edges correspond entry edge traversed exiting called automaton pda tracks calling context impossible paths exist link local automata modified call site replacement formally interprocedural pda set states input alphabet stack alphabet transition relation unique entry state initial stack configuration set accepting states local nfa models add -edge source state call edge entry state called automaton add -edges final state called automaton back destination state call edge remove original call edge figure pda model -edges called automaton paired return edge edge traversed call initiation uniquely mark local automaton state target non-system call edge non-system call edge steps add -edge source state edge entry state destination automaton label -edge push identifier target call edge add -edge final state destination automaton target call edge label -edge pop identifier step delete original call edge line end main close write close write write pop pop pop push push cpush procedures pda program initially executed automaton denoted modeling function operating system transfers control start main pda viable model operational setting straightforward operation automaton run-time stack grow consumes system resources stack size infinite presence left recursion counter left recursion challenges wagner dean operate pda algorithm similar post algorithm context model checking push-down systems demonstrate algorithm prohibitively expensive addressing imprecision requires reasonable approach optimizations address sources imprecision imprecisions models arise impossible paths context insensitive analysis malicious argument manipulation develop optimizations target sources imprecision maintaining efficiency impossible paths discarding push-down automata viable requires impossible paths readdressed impossible paths arise final states automata spliced multiple call sites -return edges introduce divergent control flow divergence exists application developed nfa model optimizations reduce effect return edges paths model dead automata removal aleaf automaton local automaton function call edges leaf automaton remote system call edges dead models control flow interest local automaton call edge dead leaf replace call edge -edge continues recursively backward call chain eliminate impossible paths introduced linking dead automaton insert dependency calculation step prior call site replacement automata inlining recall call site replacement calls function linked local automaton borrowing suitable phrase compilers automata inlining replace call site splice unique copy called automaton impossible paths removed call site expense larger global automaton theory global automaton smaller dense false edges introduced impossible paths present generally found state space automaton increase significantly practice single-edge replacement inlining special case single-edge replacement lightweight inlining technique called automaton edge function call edge simply replaced copy edge callee inexpensive inlining states -edges added model realizes inlining gains bounded stack model revisiting idea pda model find problems infinite left recursion generally unbounded stacks solved simply limiting maximum size run-time stack model top elements stack pop edges traversed stack empty state space runtime automaton finite requiring finite memory resources correspondingly language accepted bounded-stack pda regular closely approximates context-free language regular nfa bounded stack introduces problem points left recursion recursion deeper maximum height stack destroys context sensitivity stack fills recursive symbol unwinding recursion clears stack stack symbols prior entering recursion lost hybrid model recursion effect opposite desired programs recursion typically involves minority functions initially executed automaton final states initially executed automaton remote call procedure call identified procedure call identified destination identifier call edge pid irs irs precise discard recursive symbols symbols prior entering recursion hybrid model nfa pda edges interprocedural construction accomplish call site replacement simple -edges procedure call recursive cycle stack symbol call recursive recursion adds symbols pda stack leaving previous context sensitivity intact bounded-stack pda hybrid automaton defines regular language overapproximates context-free grammar accepted true pda context insensitivity technique construct interprocedural model analysis basis local models context insensitive control flow paths equally irrespective previous execution flow evaluate predicates points divergence straightforward analysis leads degree nondeterminism local automata seek reduce reducing non-determinism decreases size frontier current states automaton run-time turn fewer outgoing edges frontier 
improving efficiency precision renaming program analysis remote call site assigned randomly generated produce stub function random behaves original call rewrite binary program randomly named function called calling remote system call stub named write call stub named essentially passing call site names onetime encryption function key stored checking agent submitting machine translates random back original call execution call sites differentiated separate calls function calls functions random names label edges automaton serve input symbol model runtime renaming reduces non-determinism model precisely program execution received call comparing figure figure automaton main fully deterministic renamed call sites alphabet change moving symbols indicating call names potentially larger set symbols defining individual call sites attacker attacks randomly generated alphabet requiring analysis recover transformations remote calls program attack renamed calls generated call sites blocking unused remote call stub linked application call site renaming produces equivalent human-readable program text acting simplistic obfuscation technique checking agent maintains transformations recovery malicious individual requires program analysis remote call names context call program rewrite binary code obfuscation techniques applicable arguments reordered mixed dummy arguments per-call-site basis general methods obscure control flow similarly pursued techniques recent paper barak presents complexity-theoretic argument proves impossibility specific class obfuscating transformations define obfuscated program virtual black box property computed analyzing obfuscated program computed input-output behavior program contrast work require computationally hard adversary recover original system calls renamed calls computationally hard adversary invert renaming function obfuscation requirement weaker virtual blackbox requirement imposed barak claiming theoretical guarantees strength obfuscation transformation observing theoretical results presented barak directly apply context null calls insertion null calls dummy remote system calls translate null operations checking agent similar effects place calls application execufigure automaton main call site renaming edges labeled function calls internal application renamed edges splice points call site replacement main line end tion context checking agent reducing nondeterminism null calls immediately call site frequently called function recall introduce impossible paths call site replacement specifically link final states local automaton function call return states inserting null calls function call return sites distinguishes return locations true return path symbol null call true return site transmitted impossible paths exiting called automaton broken run-time element renaming null call insertion reducing non-determinism paths automaton remain unchanged labeled differently attacker knowledge transformations attacks transformed automaton equivalent original provided attacker takes control call stream remote calls occur attacker assumes control remote calls restricted operation model point precise argument manipulation remote system call exists calling context influences degree manipulation malicious process call site open malicious process alter file passed argument call model checks names calls call stream accept open call valid maliciously altered context open call present additional evidence checking agent enables argument modifications detected prevented argument recovery local automata constructed recover statically determined arguments backward slicing sparc argument registers backward register slicing iterate previous instructions affect register essentially finding instructions comprise expression tree simulate instructions software recover result argument call successfully recover numeric arguments statically strings resident data space application checking agent stores recovered arguments unavailable manipulation figure backward slice register point call write function main iterates instructions affect emphasized instructions inspected instructions affect case dnone static memory location indicating data space string resides recover string simulating instructions sethi software compute memory address reading string data space similar analysis determine targets indirect calls indirect call site linked function program address identify functions slicing backward register written program point determine written entry address register slicing intraprocedural making reasonable computation unresolved issues dynamic linking dynamically linked application loads shared object code remote machine address space code non-local fairly assume remote machine standard libraries ensure correct execution remote jobs analysis local standard libraries provide accurate models dynamically linked functions straightforward implemented support dynamically linked applications libraries solaris libnsl indirect calls extensively improve handling indirect calls expect handle applications signal handling execution receipt signal control flow jump signal handler previous execution state entry exit undetectable checking agent save alarms generate instrument binary expect insert null calls entry exit points signal handlers act out-of-band notifications signal handler activity instrumentations implemented multithreading kernel user level thread swaps invisible checking agent thread swaps run-time model fail remains area future research user level thread scheduling instrumentation scheduling routines checking agent swap model thread kernel scheduling figure register slicing iterate backwards instructions modify register prior call site sethi dnone call write dnone monitor require kernel modifications consideration interpreted languages programs written languages sml java compiled intermediate form native binary code execute program native-code run-time interpreter reads intermediate representation data executes specific binary code segments based input binary code analysis build model interpreter accepts sequences remote calls generated compiled program precise model specific application built knowledge intermediate representation interpreted run-time component partial evaluation interpreter program compiled native code execution common java virtual machine implementations techniques construct program-specific models execution experimental results evaluate techniques criteria precision efficiency precise model incorporates sequences calls generated application sequences efficient model adds small run-time overhead efficient models deployed precise models security interest section prototype tool evaluate techniques models examine metrics measure precision propose method identify unsafe states automaton tests show null call insertion markedly improves precision models care additional calls overwhelm network finally examine optimizations including renaming argument recovery stack abstractions improve quality models experimental setup implemented analyzer run-time monitor simulated remote execution environment test precision efficiency automaton models analyzer examines submitted binary program outputs automaton modified binary automaton read operated stand-alone process monitor acts checking local agent communicating modified program message-passing inter-process communication monitor rpc server verifies system call encountered program accepted model monitor successfully updates automaton original system call proceeds rewritten application analyzer simulated execution environment run sun ultra mhz workstation ram running solaris simulate wide-area network add delay received remote system call equivalent round trip time computer madison wisconsin computer bologna italy include delay data transfer statically volume data transferred null calls require reply delay added null call average time call send byte buffer argument evaluation collection solaris libc kernel trap wrapper functions defines set remote system calls present analysis results test programs table program descriptions workloads table statistics workloads default program options command line switches implemented general support dynamically linked 
constraints solved efficient graph-traversal algorithm demand wagner formulated buffer-overrun detection problem integer constraint problem solved linear time practice finally profitable invariant-synthesis methods conjunction induction iteration chose induction-iteration method synthesize loop invariants works linear constraints totally mechanical conceivable techniques heuristic methods introduced katz manna wegbreit difference equations method introduced elspas abstract interpretation convex hulls cousot halbwachs cousot halbwachs method works forward program control-flow graph potential speed induction-iteration method pushing facts forward program control-flow graph preliminary investigation demonstrated substantial speedups induction-iteration method selectively pushing conditions involving array bounds forward program control-flow graph describe symbolic range analysis array-bounds checking section symbolic range analysis simpler method cousot halbwachs efficient range analysis induction-iteration method previous sections techniques cousot halbwachs powerful high cost describe simple range analysis determines safe estimates range values register program point information determining accesses arrays bounds advantage synergy efficient range analysis expensive powerful induction-iteration method apply induction-iteration method global safety preconditions proven results range analysis range-analysis algorithm standard worklist-based forward dataflow algorithm finds symbolic range register program point analysis range denoted lower upper bounds form integer constants symbolic names serve placeholders base address length array reason restrict bounds form array-bounds checks involve checking range array index subrange lengthor range pointer points array subrange base base lengthwhere base length base address length array analysis symbolic names stand unknown values quantities base length ranges form meet semi-lattice respect meet operation ranges meet defined min max top element empty range bottom element largest range function min returns smaller ifl comparable determine relative order instance min returns function max defined similarly returns greater parameters parameters comparable give dataflow transfer function machine instruction define dataflow transfer functions strict respect top element introduce basic abstract operations describing dataflow transfer functions abstract operations summarized integer arithmetic operations bounds figure non-zero integers arithmetic operations ensure operations figure binary operations symbolic expressions bounds form comparison instructions major source bounds information analysis works machine code tests forms program variables figure summarizes dataflow transfer functions forms assume ranges tests function min max defined upper bound range smaller lower bound range equivalent empty range dataflow functions variables false branch test improve precision slightly returning empty range equal ensure convergence range-analysis algorithm presence loops perform widening operation node loop dominates source loop backedge range arbitrary variable previous iteration dataflow current iteration resulting range widening operator defined sharpen basic range analysis enhancements enhancement deals selecting suitable spot loop perform widening key observation do-while loop kind dominates binary code effective perform widening test exit loop case loop iterates array loop test length strategy minimizes imprecision crude widening operation range widened loop test test true branch max min max min false branch true branch min max false branch max min figure dataflow functions tests min min comparable max max comparable immediately sharpened transfer function loop test range propagated loop backedge lengthconsequently analysis quiesces iterations enhancement utilize correlations register values test consideration establish program point constant incorporate information range analysis assuming branch tests n-c range analysis show range analysis applied running figure left column shows untrusted code sums elements integer array columns show results range analysis line shows range registers exealthough loops common source code compilers typically transform do-while then-part transformation compiler exploit fact code body do-while executed loop executes perform code-motion fear slowing execution program compiler hoist expressions body loop point then-part loop untrusted code pass pass pass mov clr cmp bge clr sll cmp add retl nop figure symbolic range analysis applied running guarded cution instruction line simplify presentation show range information propagated registers recall base address array passed register size array passed register size array passed range entry untrusted code instructions visited interpreting clr instruction line sets interpreting sll instruction line sets interpreting instruction line increments interpreting branch instruction line sets range path instructions visited time range set result performing meet range propagated edge range propagated edge interpreting instruction line sets range perform widening operation line brings range note interpreting branch instruction line path sets range pass range line result performing meet range propagated edge range propagated edge range set algorithm terminates fixed point reached knowing range implies bounds array induction-iteration method prove array accesses bounds section show range analysis speed global-verification phase test cases chapter experimental evaluation present experimental evidence demonstrate technique enforce safe code execution feasible practical describe prototype implementation safety-checking analysis present initial experience prototype applied case studies prototype implementation techniques previous chapters exception technique infer sizes types local arrays section implemented prototype safety-checker sparc machine programs safety checker takes untrusted binary code form executable object files checks untrusted code obeys default safety conditions host-specified access policy reports reasons unsafe code safety violations safety checker implemented sparc machine language programs techniques embodied essentially language independent alternative reimplementing language employ binary translation techniques achieve platform independence untrusted code written sparc machine language translate untrusted code semantically equivalent sparc code performing safety checking figure shows flow chart prototype implementation recapitulate phases safety-checking analysis mention details left previous chapters preparation phase produces initial annotation initial memory state entry untrusted code interprocedural control-flow graph produce interprocedural control-flow graph analysis identifies boundaries function symbol table figure prototype implementation sparc machine language extract functions untrusted code identify basic blocks build intraprocedural cfg identify natural loops build interprocedural cfg host typestate-specification invocation specification access policy combine interprocedural cfg initial annotation typestate propagation annotation local verification range analysis induction-iteration approximation memory program point local safety conditions global safety conditions facts preparation information starting start function untrusted code dissembles instruction identifies basic blocks builds intraprocedural control-flow graphs functions reachable start function identifies targets call instructions build static call graph find targets calls registers simple intraprocedural constant propagation algorithm performed end interprocedural control-flow graph produced based intraprocedural control-flow graphs static call graph note interprocedural control-flow graph incomplete refined typestate-propagation phase typestate information interface-based programming addresses interface functions typically stored structure calling interface function typically involves load structure call register holds loaded typestate loaded information callee typestate-propagation performed interprocedural control-flow graph initial annotation preparation phase identifies natural loops loop-nesting relationships information global-verification phase identify natural loops program implemented algorithm developed lengauer tarjan computing dominators 
functions statically link programs network libraries libresolv dynamically linked solaris machines analyze libraries techniques application program store generated automata analysis program procmail finger reveals call dynamically linked function read stored local automaton continue ignore indirect calls dynamically linked library functions monitor generates error run-time indirect call location metrics measure precision efficiency analyze precision models efficiency monitor operate precision dictates degree adversary limited attacks usefulness model counter-measure efficient operation requirement deployment real remote execution environments comparison measure automaton precision wagner dean dynamic average branching factor metric metric partitions system calls sets dangerous safe application execution model operation number dangerous calls accepted model counted operation total count averaged number operations model smaller numbers favorable adversary small opportunity exploit efficiency measurements straightforward unix utility time measure application execution time simulated environment operating model baseline measure indicating delay due simulated network transit overhead equivalent remote execution environment run-time conditions turn checking optimizations measure overhead introduced checking agent find nfa model efficient operate bounded pda disappointingly slow extra precision gained inclusion null calls bounded pda model dramatically improves efficiency nfa model evaluate models test programs respect precision efficiency baseline analyzer includes renaming argument recovery dead automaton removal single-edge replacement nfa model compare results null call placement strategies baseline trade-off performance efficiency due null call insertion null call placement strategies calls inserted calls inserted entry point function fan-in functions called functions application insert calls entry point function fan-in greater fourth instrument functions fan-in placement strategies found occasionally introduced glut null calls overwhelm network adding calls functions recursive cycles functions program description workload entropy calculates conditional probabilities packet header fields tcpdump data compute conditional probability data records random generates randomized sequence numbers seed values randomize numbers gzip compresses decompresses files compress single text file gnu finger displays information users computer display information users bart jha giffin finger displays information users computer display information users bart jha giffin procmail processes incoming mail messages process single incoming message table test program descriptions test workloads program source language lines code source compiler number functions binary instructions binary entropy gcc random fortran gzip gcc gnu finger finger gcc procmail table test programs statistics source code line counts include library code statistics binary programs include code statically linked libraries program model null calls increase null calls fan-in increase null calls fan-in increase null calls fan-in increase entropy gzip random gnu finger finger procmail table nfa run-time overheads absolute overheads execution time seconds modeling automaton entry state final state ensuring call chain generates symbol functions fan-in expected sequence greater instrumentation increases precision quality automata negatively impacting performance extra calls require additional network activity generally problem selecting good null call insertion points similar selecting optimal locations insert functions program tracing topic previous research investigate selection algorithms future implementations found null call insertion dramatically improved precision figure shows dynamic average branching factor test programs null call placement strategies instrumenting maximum level improves precision non-instrumented models order magnitude null call insertion adds edges local automata observe number edges final automaton significantly lower indicating call site replacement introduces fewer impossible paths edge count procmail model drops order magnitude state count increases modestly results demonstrate great potential introducing null calls unfortunate null call insertion expected detrimental effect application run-times null call encountered execution drops call network relay checking agent application wait response call expensive kernel trap adds network traffic table shows additional execution time resulting operation models null calls table lists bandwidth requirements insertion level null calls consume bytes bandwidth make primary observations results nfa model incredibly efficient operate run-time null calls inserted inserting null calls functions fan-in greater good balance precision gain additional overhead test programs programs require moderate bandwith instrumentation level varying bandwidth test programs due part naive null call insertion strategies expect algorithm developed ball larus reduce bandwidth requirements improve consistency collection programs effects optimizations analyzed procmail evaluate renaming argument recovery stack abstractions analyze automaton inlining surprisingly proved inefficient optimization inlining added significant overhead model construction delivered gain precision similarly found run-time characteristics hybrid model identical bounded pda examine inlining hybrid model greater detail effects renaming argument recovery selectively turned optimizations graph figure measures average branching factor dependent call site renaming argument recovery program procmail expected renaming argument recovery reduced imprecision model reduction produced renaming solely due reduction non-determinism argument recovery reduces imprecision removing arguments manipulation adversary renaming argument recovery reduce imprecision optimization figure nfa precision models included baseline optimizations entropy gzip random gnu fingerfinger procmail average branching factor nfa precision null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in program null calls fan-in null calls fan-in null calls fan-in entropy gzip random gnu finger finger procmail table null call bandwidth requirements kbps programs nfa models baseline optimizations glance counter-intuitive argument recovery reduce imprecision greater degree renaming argument recovery subset renaming static arguments distinguish call site attacker manipulate recovered argument system calls dangerous unknown arguments threat argument recovery analyzed bounded pda model procmail stack bounds figure shows average branching factors pda varying levels null call instrumentation bounded stack depth figures show run-time overheads models time scales null call insertion surprising effect operation bounded stack models added precision null calls decreases run-time overheads surprised discover cases boundedstack pda null call instrumentation efficient operate nfa model higher level precision observe higher levels null call instrumentation reduce execution times operation models precise increasing stack size produces similar effect plots instrumentation functions fan-in figure functions fan-in figure show common pattern stack bound size model efficiency improves execution context retained fewer paths model state grows past bound cost increased state begins dominate finding transition important area future research discussion metrics measuring precision dynamic average branching factor metric ignores important considerations attack consists sequence system calls single call isolation call dangerous combined calls attacker steer execution safe system calls reach portion model accepts attack sequence typical run program reach area model dangerous edges dynamic average branching factor safe edges cover potential attack downstream remote call sequence obvious dynamic metric easily overcomes objections straightforward static analogue dynamic average branching factor static average branching factor count averaged entire 
automaton states weighted equally prior complaints remain unsatisfied propose metric combines static dynamic measurements average adversarial opportunity metric requires stages computation automaton modeling application composed set attack automata identify model states attack potential monitor maintains count dangerous states encountered runtime attack potential attack beginning current state state reachable locating positions model adversary successfully insert attack counting visits states run-time comparison existing work measured dynamic average branching factor execution overhead comparison earlier work wagner dean compare nfa model model work common analyzed programs procmail finger intersect experimental set version finger wagner dean compared numbers analysis gnu finger call site renaming argument recovery single-edge replacement results wagner dean include argument recovery analogue renaming edge replacement programs observed significant discrepancy reported precision values generate investigation appears figure precision improvements renamed call sites argument recovery rename arg capture average branching factor nfa precision effects optimizations procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in figure effect stack depth null call insertion pda precision baseline optimizations figure effect stack depth null call insertion pda run-time overhead time scale baseline optimizations time scale shows trends null call insertion fan-ins figure effect stack depth null call insertion pda run-time overhead time scale source data identical figure time scale shows trends null call insertion insertion fan-in stack bound average branching factor pda precision effect stack depth procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in stack bound overhead seconds pda overhead effect stack depth sec time scale procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in sec stack bound overhead seconds pda overhead effect stack depth sec time scale procmail null calls null calls functions fan-in null calls functions fan-in null calls functions fan-in sec caused differences library code respective test platforms wagner dean analyzed programs compiled red hat linux solaris solaris older operating system includes extensive library code standard libraries solaris libc structured differently glibc linux includes functionality found glibc differences compare figure automaton socket system call glibc figure automaton function solaris libc case solaris socket function includes code maintaining backwards compatibility earlier method resolving device path networking protocol socket greatest difference functions inspected found numerous library functions similar characteristic simply linux solaris library code found solaris code complex understand influence library code base identified functions solaris libc differed significantly equivalent function glibc instrumented code identified functions generates remote system call event manner similar glibc expected average branching factor model dropped significantly figure intentionally instrument library functions incorrectly model generated semantically invalid change precision values reinforces hypothesis figure socket model solaris libc figure socket model linux glibc entry exit socket figure comparison baseline nfa models prior results wagner dean finger procmail average branching factor precision full solaris libc glibc emulation wagner dean finger procmail overhead seconds efficiency nfa model wagner dean model operation improves significantly work wagner dean figure shows overheads programs attributed model operation gain partly due implementation wagner dean wrote monitor java code runs natively highly efficient introducing negligible delay related work areas techniques goals similar considered paper applications static analysis intrusion detection statistical anomalydetection-based intrusion detection secure agentry compare techniques presented paper existing research areas work applies extends techniques wagner dean knowledge propose static analysis intrusion detection analyzed source code modifying compiler linker construct application models analysis performed binaries independent source language compiler removing user burden supply source code propose optimizations program transformations improve model precision efficiency optimizations proposed paper important contributions researchers working area vast body work applying dynamic analysis intrusion detection statistical anomalydetection-based intrusion detection systems ides statistical model normal behavior constructed collection dynamic traces program sequence system calls produced utilities strace truss generate statistical model program forrest behaviors deviate statistical model flagged anomalous guarantee manipulation theoretically statistical program model checking agent practically models suffer false alarm rates reject sequences system calls represent acceptable infrequent program behavior human inspection jobs flagged anomalous inappropriate setting pursue approach literature safe execution mobile agents malicious hosts secure agentry vast reader referred excellent summary techniques area secure agentry schneider exploring techniques area replication setting future work continue progressing number fronts foremost working expand infrastructure base static analysis techniques include points-to analysis binaries regular expression construction arguments standard points-to analysis algorithms designed higher-level source language rely datatype properties evident syntax code adapt algorithms weaklytyped sparc code arguments envision stronger slicing techniques build regular expressions arguments statically determined code analyses produce precise models research areas targeting run-time overhead reductions complex models reduce impact null call insertions investigate adaptations ball larus algorithm identify optimal code instrumentation points minimum-cost code profiling reduce overhead pda models collapse run-time values automaton state single dag representing stack configurations traversing outgoing edges single update dag equivalent individual update previous stack hope make complex precise models attractive real environments add general support dynamically linked applications signal handlers analysis engine enabling analysis larger test programs measure attack opportunities afforded models implement average adversarial opportunity metric create collection attack automata accurate measure danger inherent automaton enables develop strategies mitigate harm acknowledgments david wagner patiently answering questions work providing specification dangerous system calls david melski pointed relevance ball larus research insightful discussions tom reps static analysis hong lin initially researched solutions remote code manipulation vulnerability glenn ammons provided helpful support eel members wisa security group wisconsin valuable feedback suggestions lastly anonymous referees comments availability research tool remains development distributing time contact jonathon giffin giffin wisc updates status alexandrov ibel schauser scheiman superweb global web-based parallel computing infrastructure ieee international parallel processing symposium geneva switzerland april anstreicher brixius goux linderoth solving large quadratic assignment problems computational grids international symposium mathematical programming atlanta georgia august appel macqueen standard jersey international symposium programming language implementation logic programming passau germany august appears maluszynski wirsing eds programming language implementation logic programming lecture notes computer science springer-verlag york ball larus optimally profiling tracing programs acm transactions programming languages systems july barak goldreich impagaliazzo rudich sahai vadhan yang possibility obfuscating programs annual international cryptography conference santa barbara california august appears kilian advances cryptology crypto lecture notes computer 
algorithm nat loop algorithms muchnick book node control-flow graph dominator node control-flow paths reach node entry function node algorithm nat loop identifies natural loop back edge control-flow edge target node dominates source node reduce number natural loops global-verification phase analyze implementation merges natural loops back edges share target node important analysis treat nested loops expensive analyze typestate-propagation phase finds safe approximation memory state program point implementation replicates functions analysis achieve degree context sensitivity analysis finds parameter function pointing arrays sizes function replicated copy parameter points arrays size untrusted code accesses structures multiple array-typed fields bounds information pointers index variables figure pointer points inside structure purpose run simple range analysis demand situation arises simple range analysis executed procedure implementation combined annotation phase local verification phase check local safety conditions annotated global-verification phase takes advantage synergy range analysis induction-iteration method represent results range analysis facts induction-iteration method case studies present initial experience system applied case studies test cases include array sum running previous chapters start-timer stop-timer code paradyn performance-instrumentation suite versions btree traversal version compares keys function call hash-table lookup kernel extension implements page-replacement policy bubble sort versions heap sort manually inlined version interprocedural version stack-smashing smith paper update messagedigest algorithm functions jpvm device driver dev kerninst comprises modules dev kerninst symbol dev kerninst loggedwrites stack-smashing program sample program demonstrates advantage vulnerability unix system intruder gains access system overrunning contents stack control subsequently transferred intruder code message-digest algorithm takes input message arbitrary length produces output -bit fingerprint message digest input intended digital-signature applications large file compressed secure manner encrypted private secret key public-key cryptosystem rsa jpvm java native interface pvm java platform java native interface jni native-programming interface java code runs inside java virtual machine interoperate applications libraries written programming languages assembler jpvm verify calls jni methods pvm library functions safe obey safety preconditions dev kerninst device driver installed solaris kernel kernel instrumentation tool kerninst modify running kernel on-the-fly module dev kerninst symbol api parsing kernel symbol table module dev kerninst loggedwrites recoverable modifications made instructions data run-time kernel experimental study check api function kerninst symtab dev kerninst symbol module api function loggedwrites dev kerninst loggedwrites module major functions modules examples written dev kerninst compiled gcc version dev kerninst examples compiled sun workshop compiler figure characterizes examples terms number machine instructions number branches number loops total versus number loops number calls total versus number calls trusted functions number global safety conditions total versus number bounds checks source language test case written treat checking lower upper bounds separate safety conditions trusted function figure host function function trust check calls trusted function obey safety preconditions function experiments find safety violation implements page-replacement policy attempts dereference pointer null identified array out-of-bounds violations stack-smashing symbol table mods ging olicy imer ash ubble imer tree tree eap eap pvm smashing pvm dev kerninst symbol dev kerninst logged rites instructions branches loops loops procedure calls trusted calls global conditions bounds checks source language cccccccccccccc characteristics examples performance results ging olicy imer ash ubble imer tree tree eap eap pvm smashing pvm dev kerninst symbol dev kerninst logged rites typestate propagation annotation range analysis inductioniteration total seconds figure performance results ule dev kerninst figure summarizes time needed verify examples mhz sun ultra machine times divided times perform typestate propagation create annotations perform local verification perform range analysis perform program verification induction-iteration method time check examples ranges seconds performance results dev kerninst loggedwrites obtained based preliminary implementation features section section details features analysis handle meet array types sizes precision account correlations induction variables loop performing array bounds checks features analysis generate false warnings array out-of-bounds violations checking dev kerninst loggedwrites dev kerninst loggedwrites takes longer time check test cases largely implementation features preliminary goal minimize made existing infrastructure implementation sufficiently complete full test abilities made note dev kerninst loggedwrites stack-smashing dev kerninst symbol longer times check examples array out-of-bounds violations exhaust breadth-first search induction-iteration method conclude array of-bound violation highlight benefits typestate system symbolic range analysis provide bit-level representations integers analysis deal instructions load store partial word update stack-smashing examples technique summarize trusted functions analysis summaries host library functions hash startand stop timer btree jpvm examples dev kerninst examples simply summarize library functions checking implies examples safe library functions safe principle check library code summaries subtyping structures pointers summaries jni methods polymorphic jni function jsize getarraylength jnienv env jarray array takes type jarray parameter applicable types jintarray jobjectarray subtypes jarray java objects manipulated jni interface model types jintarray jobjectarray physical subtypes jarray summarizing jni interface functions symbolic range analysis system identify boundaries array field structure run intraprocedural version range analysis demand typestate-propagation algorithm information range register intraprocedural range analysis run function test cases array accesses range analysis eliminated total attempts synthesize loop invariants test cases eliminated synthesize loop invariants altogether resulting speedup global verification ranges median conjunction simple test treats part untrusted code acyclic code section range analysis verify dev kerninst symbol handle figure shows times performing program verification times performing range analysis normalized respect times performing global verification range analysis reason analysis stack-smashing speeded array accesses bounds array accesses bounds range analysis speed analysis figure times perform global verification range analysis normalized respect times perform global verification range analysis sum hash bubble btree btree heap heap jpvm stackjpvm ratio time induction-iteration normalized time range analysis normalized smashing sort sort sort analysis apply program-verification technique conclude array out-of-bounds violations similarly reason hash slowed conditions array-bounds checking range analysis prove array accesses bounds note range analysis eliminated synthesize loop invariants array bounds checks cases reasons range analysis lost precision due widening inability range analysis algorithm recognize correlations registers implementation range analysis perform widening operation test exit loop precision nested loops widening operation loop information outer loop lose precision potential improvement range analysis perform widening variables invariants loop widening point potential improvement identify correlations loop induction variables include pass range analysis make correlations limitations initial success analysis limitations describe limitations outline solutions lost precision due array analysis lose precision due array recall single abstract location summarize elements array model pointer array base 
science springer-verlag york belani vahdat anderson dahlin crisis wide area security architecture seventh usenix security symposium san antonio texas january chow johnson zakharov approach obfuscation control-flow sequential computer programs information security conference malaga spain october collberg thomborson low breaking abstractions unstructuring data structures ieee international conference computer languages chicago illinois denning neumann requirements model ides real-time intrusion detection system technical report sri international august esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems conference computer aided verification chicago illinois july appears emerson sistla eds computer aided verification lecture notes computer science springer-verlag york fagg moore dongarra scalable networked information processing environment snipe supercomputing san jose california november forrest hofmeyr somayaji longstaff sense unix processes ieee symposium research security privacy oakland california foster kesselman globus metacomputing infrastructure toolkit international journal supercomputer applications high performance computing summer foster kesselman eds grid blueprint computing infrastructure morgan kaufmann san francisco ghosh schwartzbard schatz learning program behavior profiles intrusion detection usenix workshop intrusion detection network monitoring santa clara california april giffin lin exploiting trusted appletserver communication unpublished manuscript http wisc giffin hohl model attacks malicious hosts mobile agents ecoop workshop mobile object systems secure internet computations brussels belgium july hopcroft log algorithm minimizing states finite automaton theory machines computations academic press york hopcroft motwani ullman introduction automata theory languages computation addison wesley boston horwitz reps program dependence graphs software engineering international conference software engineering melbourne australia jones gomard sestoft partial evaluation automatic program generation prentice hall international series computer science prentice hall englewood cliffs jersey fink levitt automated detection vulnerabilities privileged programs execution monitoring annual computer security applications conference orlando florida logic induction valid behavior specifications intrusion detection ieee symposium security privacy oakland california lamport shostak pease byzantine generals problem acm transactions programming languages systems july larus schnarr eel machineindependent executable editing sigplan conference programming language design implementation jolla california june litzkow livny mutka condor hunter idle workstations international conference distributed computer systems san jose california june miller christodorescu iverson kosar mirgorodskii popovici playing inside black box dynamic instrumentation create security holes parallel processing letters june september appears los alamos computer science institute symposium sante october reps program analysis graph reachability information software technology november december saltzer protection control information sharing multics communications acm july sander tschudin protecting mobile agents malicious hosts vigna mobile agents security lecture notes computer science springer-verlag york schneider fault-tolerant secure agentry international workshop distributed algorithms saarbrucken germany september seti home search extraterrestrial intelligence home january http setiathome ssl berkeley sun microsystems java virtual machines http java sun docs guide tip survey program slicing techniques journal programming languages september vahdat anderson dahlin belani culler eastham yoshikawa webos operating system services wide area applications seventh international symposium high performance distributed computing chicago illinois july wagner static analysis computer security techniques software assurance dissertation california berkeley fall wagner dean intrusion detection static analysis ieee symposium security privacy oakland california wang davidson hill knight protection software-based survivability mechanisms international conference dependable systems networks goteborg sweden july warrender forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy oakland california 
arbitrary array element pointer point summary location analysis loses precision determine assignment kills elements array analysis reported actual parameters host methods functions undefined jpvm examples fact defined dependenceanalysis techniques parallelizing compilers address limitation lost precision due type system typestate-checking system dissertation sophisticated handle test cases subtyping rule states meet array types sizes return array size rule analysis lose precision checking safety variable-length vector type dev kerninst loggedwrites vector type implemented template class shown template class class vector data int int tsz vector operator const data field vector array size field tsz field points slot vector operator adds additional element vector code implements operator simplified illustrated figure line type data meet tsz newtsz array line analysis generate false warning array bounds checks sketch enhancement typestate-propagation algorithm address limitation basic idea introduce node meet array types sizes propagate information node computed illustrate technique figure variables type initially points base address program point time program points visited type time program point visited introduce node variable program point meet array types record depending edge arrive program point time program point visited introduce node variable record vector operator const const unsigned newsz newsz tsz unsigned newtsz unsignedint bigger newsz newdata newtsz copy newdata data delete data data newdata tsz newtsz data return figure operator vector type time program point visited update information computed process eventually converge array typed variable static program point introduce variable record information control-flow edges assist global-verification phase assignments bold face attached controlflow edges check condition program point back-substitute condition edge similarly back-substitute condition edge perform global verification vector type field data array size tsz field equal field tsz invariant represented introducing symbolic names encoded range information shown data data array type size tsz tsz equals equals limitations induction-iteration method induction-iteration method powerful handle cases correlation figure introducing propagating nodes pass pass loop tests calculation array index obvious happen compiler optimizations strength reduction optimizations address-calculations source code programming style show examples figure examples implementation vector class earlier key solving problem uncover correlations loop tests arrayindex calculations simple solution introduce basic induction variable represent induction variables linear expressions basic induction variable examples figure introduce basic induction variable transform examples programs shown figure show induction-iteration handle examples transformed prove condition ptr line program left-hand side figure ptr fact true entry loop shown back-substituting path show steps compute performing back-substitution ptr x-ptr int int figure examples induction-iteration method handle int ptr int n-i ptr n-i ptr int int int figure introducing basic induction variable examples shown figure loop body wlp ptr wlp n-i n-i true wlp true true true loop invariant synthesized ptr verifying program right-hand side figure slightly complicated prove condition line previous fact true entry loop shown backsubstituting path tautology compute wlp wlp continuing compute strengthen carrying steps compute disjunctive normal form drop disjuncts involve non-basic induction variables iii perform generalization disjunctive normal form formula dropping disjunct involves non-basic induction variable wehave performing generalization easy verify true entry loop modified body loop implied loop invariant synthesized loop invariant implies line standard techniques muchnick identify induction variables perform transformations address limitation induction-iteration method summary experience date make observations contrary initial intuition compiler optimizations loop-invariant code motion improved register-allocation algorithms make task safety checking easier memory-usage analysis part typestate checking lose precision instructions access memory registers job register allocation precise typestate information recovered loop-invariant code motion makes induction iteration efficient making loops smaller simpler compiler optimizations strength reduction optimizations address-calculations complicate task global verification hide relationships induction-iteration method strategies make induction-iteration method effective conditions program pollute wlp loop-body compute disjunctive normal form wlp loop-body disjuncts turn rank potential candidates simple heuristic test candidate breadth-first strategy depthfirst finally forward propagation information array bounds range analysis substantially reduce time spent induction-iteration method reduces time needed verify true entry eliminate generalization synthesize loop invariant implementation safety checker results range analysis assertions assist induction-iteration method verifying interprocedural version untrusted program time verifying manually inlined version manually inlined version replicates callee functions global conditions callee functions place analysis benefits procedure abstraction expensive verify programs array out-of-bounds violations programs safe exhaust breath-first search induction-iteration method conclude array out-of-bounds violation work perform safety checking compiler information easy compiler retain hard analysis infer make analysis easier information include types sizes local arrays pointers array inside structure correlations loop induction variables hidden due compiler optimizations information correlations loop induction variables benefit range analysis induction-iteration method chapter conclusions future work dissertation presented techniques statically checking safe piece untrusted foreign code loaded executed trusted host system techniques work ordinary machine code mechanically synthesize verify safety proof chapter examine limitations technique discuss future research directions limitations major limitation techniques enforce safety properties expressible typestates linear constraints excludes liveness properties safety properties array bounds checks array non-linear subscripting checks floating-point exceptions analysis flow-sensitive interprocedural analysis propagate typestate information verification phase fairly costly due synthesize loop invariants prove safety predicates scalability analysis remains evaluated bigger applications static techniques technique incomplete analysis loses precision handling array single abstract location summarize elements array induction-iteration method incomplete linear constraints induction-iteration method prove correctness array accesses loop correctness depends data values set execution loop sentinel end array speed sequential search generalization capabilities system fall short problems care memory safety induction-iteration method fail cases loop invariant strengthened point end verifying large part partial correctness algorithm type system sophisticated handling cases type system dissertation meet array types element type numbers elements return array type size analysis lose precision checking kernel-device-driver finally analysis deal unconventional usages operations swapping non-integer values means exclusive operations future research limitations method shows promise limitations represent potential research opportunities future research make analysis precise efficient continued engineering make technique practical larger programs discuss potential research directions sections follow improving precision safety-checking analysis developing algorithms interesting research direction develop typestate system algorithms make safety-checking analysis precise natural starting point address limitations identified including handling array handling meet array types precision developing heuristics strengthen induction-iteration method array bounds checks employing static run-time checks addition improving precision safety-checking algorithms sharpen analysis incorporating run-time checking rejecting untrusted code conditions checked statically generate code perform run-time 
checks straightforward technique annotation phase analysis generates safety conditions generate run-time checks conditions fail static checking run-time checking address recovery problem fault detected run-time simplest thing terminate offending code ensure untrusted code violated violate default safety conditions access policy simply terminating offending code untrusted code accesses shared data acquires host resources general complicated actions ensure integrity host traditionally people avoid recovery problem allowing untrusted code interact trusted host well-defined interface transaction model untrusted code aborted fault occur notion typestate general dissertation type states correspond state machine operation bring operands state principle label states safe states states unsafe states safety policy include post-condition form typestates linear constraints invariants hold untrusted code terminates corrective actions generated automatically examining difference faulting state desired state typestate capture resources allocated released time fault generate corrective actions release resources improving scalability safety-checking analysis employing modular checking make safety-checking analysis scalable perform intraprocedural analysis interprocedural analysis recent work interprocedural pointer analysis shown pointer analysis performed modular fashion techniques analyze function assuming unknown initial values parameters globals function entry point obtain summary function dataflow effect function techniques create safety preand postconditions automatically employing analyses unsound make technique scalable employ analyses efficient unsound examples include treating program loops acyclic terminating analysis fixed number iterations converges principle series techniques vary efficiency power apply techniques starting efficient apply expensive techniques producing proof-carrying code argument approach safety-checker implemented complicated proof checker proof-carrying code approach noted shown thesis structure safety checker principle separate safety-checker proof generator proof checker proof generator code producer synthesize attach safety proofs machine code proof checker code consumer check validity proofs extending techniques safety checking enforcing security policy work thesis focused enforcing safety based access control form discretionary access control discretionary access control policies impose restriction usage information obtained untrusted code prevent disastrous information leaks limitation addressed mandatory access control policies accesses allowed determined basis predefined rules generalization mandatory access policy represented information flow model denning denning policy based lattice model flow policy represented partial ordered set set security classes partial order called flow relation variable assigned security class flow information variable variable permissible iff security class security class function security class returns security class variable extend safety policy dissertation region category access include flow policy denning adding fourth component security class partial ordered set instances fourth component belong set check information higher security class flows location allocated storing information lower security class limitation denning flow certification method requires variables security class priori limitation makes unsuitable certifying legacy code code information machine code volpano irvine show limitations flow certification denning overcome secure flow type system flow control type checking focus producing principal types security requirements function abstractions treating information flow certification type-checking fits perfectly typestatechecking analysis enforce safety simple extension technique extend typestate system include orthogonal secure flow type component extend safety-checking analysis perform secure flow type checking consequence typestate-checking analysis enforce discretionary mandatory access policies reverse engineering safety-checking analysis works unannotated binary recovers typestate information existed source code typestate checking analysis reverse engineer machine code code typed source language information recovered analysis unannotated binary purposes safety checking type information recovered dynamic optimizer enable optimizations impossible type information eliminate virtual function calls object-oriented programs usage information guide performance tool choose spots program insert instrumentation code gather present performance data human attractive aspect techniques forsake expensive parts analysis global verification care variable defined perform intraprocedural analysis signature function abadi cardelli theory objects monographs computer science gries schneider springer-verlag york activex http microsoft tech activex asp aigner urs lzle eliminating virtual function calls programs european conference object-oriented programming linz austria alpern schneider recognizing safety liveness distributed computing amme data dependence analysis assembly code international conference parallel architectures compilation techniques pact paris october balasundaram kennedy technique summarizing data access parallelism enhancing transformations sigplan conference programming language design implementation portland usa june bershad savage pardyak sirer fiucynski becker eggers chambers extensibility safety performance spin operating system symposium operating system principles copper mountain december birrell nelson implementing remote procedure calls acm transaction computer systems february bodik gupta soffa refining data flow information infeasible paths acm sigsoft symposium foundations software engineering sixth european software engineering conference lncs springer verlag zurith switzerland sept bodik gupta sarkar abcd eliminating array bounds checks demand sigplan conference programming language design implementation vancouver canada june boyer yuan automated proof object code widely microprocessor journal acm january callahan kennedy analysis interprocedural side effects parallel programming environment international conference supercomputing athens greece caplain finding invariant assertations proving programs international conference reliable software april chandra reps physical type checking paste sigplan-sigsoft workshop program analysis software tools engineering toulouse france september chase wegman zadeck analysis pointers structures sigplan conference programming language design implementation york chatterjee ryder landi relevant context inference acm symposium principles programming languages san antonio january cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation sigplan conference programming language design implementation vancouver canada june chiueh venkitachalam pradhan integrating segmentation paging protection safe efficient transparent software extensions acm symposium operating systems principles charleston december clutterbuck carre verification low-level code software engineering journal colby lee necula blau plesko cline certifying compiler java sigplan conference programming language design implementation vancouver canada june cousot halbwachs automatic discovery linear restraints variables program annual acm symposium principles programming languages tucson january denning lattice model secure information flow communications acm detlefs leino nelson saxe extended static checking research report compaq systems research center palo alto december dijkstra discipline programming prentice-hall englewood cliffs elspas green levitt waldinger research interactive program-proving techniques sri menlo park california engler kaashoek toole exokernel operating system architecture application-level resource management symposium operating system principles copper mountain december evans static detection dynamic memory errors acm sigplan conference programming language design implementation evans guttag horning tan lclint tool specifications check code sigsoft symposium foundations software engineering december fink knobe sarkar unified analysis array object strongly typed languages static analysis international symposium sas santa barbara june published jens oalsberg lecture notes computer science springer-verlag flanagan flatt krishnamurthi weirich catching bugs web program invariants acm sigplan conference programming language design implementation floyd assigning meanings programs proceedings symposia 
applied mathematics xix american mathematical society german automating proofs absence common runtime errors acm symposium principles programming languages tucson arizona january ghormley petrou rodrigues anderson slic extensibility system commodity operating systems usenix annual technical conference orleans louisiana june grand java language reilly associates july gupta fresh optimizing array bound checking acm sigplan conference programming language design implementation white plains york june hailpern verifying concurrent processes temporal logic lecture notes computer science goos hartmanis eds springer-verlag harbison modulaprentice hall harrison compiler analysis ranges variables ieee transactions software engineering hoare axiomatic basis computer programming communications acm october illustra information technologies illustra datablade developer kit architecture manual release javasoft java native interface specification release jpvm native methods interface pvm java platform http chmsr gatech jpvm katz manna heuristic approach program verification international conference artificial intelligence august kelly maslov pugh rosser shpeisman wonnocott omega library version interface guide omega umd http umd projects omega november kolte wolfe elimination redundant array subscript range checks acm sigplan conference programming language design implementation jolla california june leroy rouaix security properties typed applets acm sigplan-sigact symposium principles programming languages san diego january lindholm yellin java virtual machine specification edition http java sun docs books vmspec ndedition html vmspectoc doc html markstein cocke markstein optimization range checking sigplan symposium compiler construction mccanne jacobson bsd packet filter architecture user-level packet capture winter usenix conference usenix association san diego january mitchell maybury sweet mesa language manual technical report xerox palo alto research center microsoft microsoft technologies-information resources component object model-based technologies http microsoft march mycroft type-based decompilation program reconstruction type reconstruction european symposium programming esop amsterdam netherlands march miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november milner theory type polymorphism programming journal computer system sciences mogul rashid accetta packet filter efficient mechanism user-level network code acm symposium operating systems principles austin november morris general axiom assignment theoretical foundations programming methodology lecture notes international summer school directed bauer dijkstra hoare manfred broy gunther schmidt reidel publishing company morrisett tarditi cheng stone harper lee til compiler performance safety types workshop compiler support systems software tucson february morrisett walker crary glew system typed assembly language annual acm symposium principles programming languages san diego january morrisett crary glew walker stack-based typed assembly language workshop types compilation published xavier leroy atsushi ohori lecture notes computer science springer-verlag morrisett crary glew grossman samuels smith walker weirich zdancewic talx realistic typed assembly language acm workshop compiler support system software atlanda muchnick advanced compiler design implementation morgan kaufmann publishers necula compiling proofs dissertation carnegie mellon september necula lee design implementation certifying compiler acm sigplan conference programming language design implementation montreal canada june necula proof-carrying code annual acm symposium principles programming languages paris france january netscape browser plug-ins http home netscape plugins index html audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating systems principles copper mountain december pugh omega test fast practical integer programming algorithm dependence analysis supercomputing albuquerque november pugh wonnacott eliminating false data dependences omega test acm sigplan conference programming language design implementation san francisco june pugh wonnacott experience constraint-based array dependence analysis technical report cs-truniversity maryland redell dalal horsley lauer lynch mcjones murray purcell pilot operating system personal computer communications acm february rivest message-digest algorithm request comments mit laboratory computer science rsa data security april rugina rinard symbolic bounds analysis pointers array indices accessed memory regions sigplan conference programming language design implementation vancouver canada june samarati bertino ciampichetti jajodia information flow control object-oriented systems ieee transaction knowledge data engineering july august schneider fault-tolerant secure agentry international workshop distributed algorithms saarbr cken germany september seltzer endo small smith dealing disaster surviving misbehaved kernel extensions usenix symposium operating systems design implementation seattle october siff chandra ball kunchithapadam reps coping type casts seventh european software engineering conference seventh acm sigsoft symposium foundations software engineering toulouse france september smith stack smashing vulnerabilities unix operating system http destroy net machines security strom yellin extending typestate checking conditional liveness analysis ieee transactions software engineering strom yemini typestate programming language concept enhancing software reliability ieee transactions software engineering january small seltzer comparison extension technologies usenix annual technical conference san diego january smith walker morrisett alias types european symposium programming berlin germany march stonebraker inclusion types relational data base systems readings database systems edition michael stonebraker sun microsystems java plug-in overview http java sun products indexhtml october susuki ishihata implementation array bound checker acm symposium principles programming languages los angeles january tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating system design implementation orleans february verbrugge hendren generalized constant propagation study international conference compiler construction link ping sweden april volpano irvine secure flow typing computer security wadler taste linear logic mathematical foundations computer science lecture notes computer science springer-verlag gdansk poland august tamir adi automatic derivation invariants ieee transactions software engineering sejanuary tennenhouse wetherall active network architecture computer communication review april wegner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed systems security conference san diego february wegbreit synthesis loop predicates communications acm february wahbe lucco anderson graham efficient softwarebased fault isolation symposium operating system principles asheville december miller reps safety checking machine code sigplan conference programming language design implementation vancouver canada june reps miller typestate checking machine code technical report wisconsin madison july 
fine-grained dynamic instrumentation commodity operating system kernels ariel tamches dissertation submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison copyright ariel tamches rights reserved acknowledgments graduate career fortunate receive advice support encouragement people foremost debt gratitude owe thesis advisor bart miller bart responsible introducing paradyn project suggested dissertation casually mentioning day fun investigate dynamic kernel instrumentation bart well-earned reputation dedication graduate students constant encouragement dissertation written committee members marvin solomon larry landweber paul barford greg moses offered time effort improve work special due professor solomon outstanding incredibly detailed review page dissertation grateful members kerninst paradyn projects past present stimulating brainstorming sessions hacking advice matt cheyney provided invaluable impeccably timed assistance debugging kperfmon timer primitives days osdi conference submission deadline helped brainstorm tricky case instrumenting tail calls alex mirgorodskii ported kerninst -bit platforms process greatly improved quality software vic zandy begun formidable task kerninst port greatly improving control flow graph parsing register analysis thesis research benefitted support persons kerninst group pei cao jussara almeida kevin beach suggested measure optimize performance squid proxy server provided wisconsin proxy benchmark mike shapiro madhusudan talluri bryan cantrill stephen chessin provided invaluable insight workings solaris kernel single outstanding assistance mike shapiro past years graciously rapidly responded dozens detailed questions core solaris kernel members veritas software randy taylor actively showing interest kerninst serving users real world family love support times completing dissertation special due mother provided endless encouragement inspired victorious battle cancer mom work dedicated hope boy made proud abstract operating system kernel code generally immutable trend unfortunate kernel insert remove code run-time including performance measurement debugging code coverage run-time installation patches run-time optimizations research dissertation investigates dynamic run-time kernel instrumentation applications areas kernel profiling code evolution implemented dynamic kernel instrumentation kernel performance monitor run-time kernel optimizer system called kerninst component dissertation investigates fine-grained dynamic kernel instrumentation technology dynamically modify kernel code designed primitives runtime kernel code modification splicing inserts instrumentation code code replacement replaces function code part kerninst system called kerninstd implements fine-grained dynamic instrumentation solaris ultrasparc kernels component dissertation collection techniques algorithms dynamic instrumentation obtain kernel performance information techniques design implementation efficient instrumentation code obtain counts elapsed times virtual times kernel code dissertation presents means effectively calculate estimate kernel control flow graph counts basic block counts techniques algorithms embodied kernel performance tool called kperfmon case study describes kperfmon helped understand improve performance web proxy server final component dissertation introduces concept evolving code commodity operating system evolving kernel code run-time response measured environment kerninst technological infrastructure enables commodity kernels evolve proof concept describe automated kernel run-time version code positioning i-cache optimization applied run-time code positioning tcp readside stream processing routine tcp rput data code positioning reduces time tcp rput data waits i-cache misses reduces execution time improves instructions cycle contents acknowledgments abstract contents list figures introduction applications dynamic kernel instrumentation fine-grained dynamic kernel instrumentation kernel performance measurement overview kperfmon explanation major kperfmon features evolving kernels related work kernel instrumentation extensibility research kernels extensibility commodity kernels static instrumentation dynamic instrumentation user programs dynamic instrumentation kernels instrumentation summary performance measurement commodity kernels sampling-only approaches kernel performance measurement instrumentation approaches kernel performance measurement summary run-time kernel code optimization evolving kernel code run-time compiler-like optimizations user programs run-time wholesale user programs run-time optimizations evolving code research kernels run-time optimizations evolving code commodity kernels summary related work summary introduction kerninst kerninst architecture bootstrapping structural analysis control flow graph building cfg basic rules building cfg handling control-flow instructions control flow graph results parsed control flow graph results parsed structural analysis call graph structural analysis live register analysis dataflow representation basic algorithms startup algorithm phase startup algorithm phase runtime algorithm live register analysis results live register analysis analyzed summary research contributions fine-grained code splicing code replacement splicing basic code patch issues splicing relocating overwritten instruction code patch basic concept maintain semantics creating instrumentation point existed relocating tail calls relocating conditional branches relocating delay slot instruction splicing jumping code patch avoiding hazards splicing challenge insufficient displacement reach code patch solving reach problem springboards solving reach problem in-nucleus allocation un-splicing code replacement installing replacement function parsing version function run-time undoing code replacement future work splicing architectures variable length instructions splicing architectures always-delayed branches code replacement facilitate splicing improvements code replacement conclusion research contributions kernel performance measurement dynamic instrumentation event counter metrics interval counter metrics overview wall time interval counter metrics virtual time interval counter metrics start stop primitives virtualization general algorithm additional structures context switch instrumentation points multiprocessor issues virtualization vii wall time event accumulating revisited multiprocessors future work conclusion research contributions dynamic kernel instrumentation kernel application tuning introduction understanding bottlenecks first-order bottleneck file opens tracing open bottleneck file creation understanding file creation bottlenecks ufs create bottleneck lookuppn bottleneck optimizations performed addressing pathname lookup bottleneck addressing file truncation bottleneck combined effects optimizations ideas future optimizations conclusion calculating control flow graph edge counts block counts motivation algorithm results obtaining number calls function block counts future work conclusion research contributions dynamic kernel optimization evolving kernels evolving kernels run-time kernel code positioning kernel code positioning measurement i-cache bottleneck viii collecting block execution counts functions measuring block execution counts called root function obtaining relocatable representation group code code positioning choosing block ordering functions include group procedure splitting block positioning emitting installing optimized code code generation installing optimized group parsing group functions kernel code positioning case study tcp running ftp benchmark performance tcp rput data code positioning performance tcp rput data code positioning analysis code positioning limitations future work conclusion research contributions conclusion summary research contributions future work dynamic kernel instrumentation kernel performance profiling dynamic kernel optimization evolving kernels final thoughts list figures interval counter accumulation instrumentation kerninst system architecture conventional placement conditionally annulled delay instruction tail call summary structural analysis kernel information time parse function control flow graphs sparc register window overlapping dead registers solaris kernel code splicing tail call unwinding exit point instrumentation relocated conditional branch instruction general case splicing delay slot work atomic splicing suitability instructions single-instruction splicing springboards reach code patch springboard space solaris basic code replacement number statically identifiable calls kernel functions cost 
incrementing event counter event interval accumulation multiple threads cumulative thread events accumulator structure cumulative thread events pseudo-code cost cumulative thread events instrumentation primitives counted virtual time events accumulator structure counted virtual time events start accumulation counted virtual time events stop accumulation summary virtualized interval counting instrumentation primitives context switch-out instrumentation pseudo-code uniprocessor context switch-in instrumentation pseudo-code uniprocessor cost context switch instrumentation virtualization instrumentation points abbreviated hash table entry multiprocessor-safe wall time measurements copen major callees copen falloc open open spends time create create main callees lookuppn ufs create ufs create time spent primarily ufs itrunc ufs itrunc time spent ufs iupdat dnlc hit rate ufs lookup spends time ufs dirlook effect increasing dnlc size ufs lookup latency file creation performance truncation bottleneck addressed ufs itrunc optimized squid create time file truncation dnlc optimizations applied pseudo-code deriving edge counts block counts edge counts derived block counts edge counts calculated block counts sample layout optimized function group i-cache layout hot blocks tcp rput data descendants pre-optimization i-cache layout optimized tcp rput data group size optimized functions tcp rput data group measured performance improvements tcp rput data code positioning average number direct indirect calls made kernel functions chapter introduction operating system kernel code generally immutable trend unfortunate kernel insert remove code run-time including performance measurement tracing debugging code coverage testing security logging run-time installation patches run-time optimizations process-specific resource management thesis research covers dynamic run-time kernel instrumentation application areas kernel profiling code evolution implemented dynamic kernel instrumentation kernel profiler run-time optimizer system collectively called kerninst component dissertation presented chapters low-level technology called fine-grained dynamic kernel instrumentation technology primitives run-time kernel code modification splicing inserts arbitrary instrumentation code desired kernel locations code replacement atomically replaces function code part kerninst system called kerninstd implements fine-grained dynamic instrumentation solaris ultrasparc kernels component dissertation design implementation run-time kernel performance profiler built dynamic instrumentation infrastructure discussed chapter tool called kperfmon demonstrates application fine-grained dynamic kernel instrumentation significantly kperfmon powerful performance profiler giving user detailed performance information aid optimization kernel user code proof concept chapter shows kperfmon helped understand improve performance web proxy server final component dissertation presented chapter introduces concept evolving code commodity operating system evolving system change code run-time response measured environment evolving system identify problem poor performance security attack formulate solution changing existing code address problem install solution run-time kerninst technological infrastructure enables commodity kernels evolve proof concept chapter describes prototype implementation application infrastructure automated kernel run-time instruction cache optimizer implementation time code running kernel re-ordered on-the-fly i-cache performance optimization benefitted results chapter show control flow graph edge execution counts derived basic block execution counts deferring implement technically complex edge splicing primitive performed case study run-time code positioning improve end-to-end performance web fetch benchmark optimizing key tcp read-side stream processing routine tcp rput data optimization reduces time tcp rput data waits i-cache misses reduced execution time improved ipc instructions cycle optimization tcp rput data led reduction benchmark total run-time dissertation thesis statement dynamically instrument already-running commodity operating system kernel fine-grained manner technology usefully applied kernel performance measurement run-time optimization remainder chapter motivates fine-grained dynamic kernel instrumentation presents additional information core contributions dissertation applications dynamic kernel instrumentation fine-grained dynamic kernel instrumentation powerful foundation variety tools built motivation describe applications kernel profilers dynamic instrumentation insert code annotations gather performance information contents inserted code snippet depend desired performance metric gathered simple count number entries function basic block obtained inserting code increments counter location performance measurement code inserted accumulate events occur function basic block entry function instrumentation read counter representing elapsed cycle count exit function instrumentation re-read counter subtract previous obtain elapsed time cycles execution code body added accumulating total representing total number elapsed cycles kernel spends routine detail dynamic kernel instrumentation performance measurement discussed section kernel debuggers implemented fine-grained dynamic instrumentation breakpoints inserted machine code instruction splicing code snippets display kernel state console optionally pause executing thread informs debugger breakpoints conditionalized adding desired test dynamic instrumentation kernel tracing run-time logging code spliced desired tracing locations kernel code restored original state trace collected overhead tracing incurred collecting trace dynamic instrumentation contrasts static instrumentation system binary rewriter inserts code lasting entire run kernel code coverage achieved fine-grained dynamic kernel instrumentation coverage monitored splicing code sets flag function basic block control flow graph edge call graph edge desired code reached instrumentation removed flag set expense code coverage decreases time basic block edge coverage good examples utility making instrumentation fine-grained dynamic security checks department defense -level auditing form annotation installed running kernel dynamic instrumentation solaris audit events including thread creation deletion file system path lookups file system vnode creation successful unsuccessful credential checks super-user access process forks core dumps stream device operations file opens closes chdirs auditing code bracketed source code ifdef audit enabled kernel turning requires changing flag recompiling kernel rebooting dynamic instrumentation auditing package distributed independent kernel add-on installed running system run-time insertion auditing code requires finegrained splicing mechanism auditing checks occur middle kernel functions dynamic instrumentation enables automated run-time code optimization based performance feedback gathered dynamic profiling annotations automated run-time function specialization based input parameter function dynamically instrumented entry point collect histogram values desired parameter examined frequent instrumentation code removed specialized version function machine code generated constant propagation applied specialized parameter original function code spliced entry input parameter equals expected jump specialized version fall optimization remove condition call sites function analyzed actual parameter equals specialized true call site altered directly call optimized version function run-time code optimization performed dynamic instrumentation code positioning moving seldom-executed basic blocks line improve instruction cache performance function tested poor instruction cache performance inserting instrumentation measures number icache misses incurred time instrumentation removed instruction cache performance poor function basic blocks instrumented execution frequency version function infrequently executed basic blocks moved line spliced kernel specialization jump overhead eliminated redirecting call sites function technique explored chapter dynamic kernel instrumentation change kernel functionality installing process-specific version kernel resource management routine extensible operating systems focused subject worthwhile note dynamic instrumentation provide similar operation commodity kernel splicing code kernel policy function current-pid equals some-pid jump customized version fall transparent data modification 
encrypting compressing file system implemented dynamic instrumentation entry point file system read write routines code inserted data stream appropriately dynamic instrumentation detect adapt security attacks tcp denial-of-service attack server inundated tcp syn packets randomly forged addresses number packets overflow server listen queue preventing legitimate clients starting connections annotations dynamically inserted kernel routines detect attack unusually high connection attempt frequency possibly spoofed addresses instrumentation adapt attack temporarily ignoring tcp connection requests small trusted core addresses fine-grained dynamic kernel instrumentation question dissertation seeks answer fine-grained dynamic instrumentation running unmodified commodity operating system kernel technical challenges overcome answer challenges include attaching already-running kernel changing kernel code decoupling code generation splicing ensuring splicing vulnerable race condition kernel thread executing vicinity fine-grained dynamic kernel instrumentation implemented component kerninst called kerninstd privileged user-level process runs machine kernel instrumented occasional assistance pseudo device driver dev kerninst kerninstd instrumentation server applications wishing instrument kernel kerninstd decoupled instrumentation clients execute machine communicate remote procedure call interface primary kernel instrumentation feature kerninst splicing insertion instrumentation code performs desired monitoring adaptation task dissertation research contributions area instrumentation dynamic kerninst loaded instruments kernel run-time recompile reboot pause kernel fine-grained instrumentation points locations kernel code inserted machine code instruction kernel runs commodity kernel enables instrumentation real-world workloads worthwhile note recent operating system research place custom kernels dissertation shows run-time instrumentation feasible commodity kernel runs unmodified kernel contribution important requiring modified customized kernel commodity preclude instrumentation tool widespread kernel performance measurement component dissertation design development kernel performance measurement tool dynamic instrumentation implementation tool called kperfmon concrete demonstration utility fine-grained dynamic kernel instrumentation powerful performance tool features section overview kperfmon research contributions chapter complete description overview kperfmon kperfmon run-time kernel performance measurement system solaris kernel running ultrasparc processor user interface modeled part paradyn performance tools user-level performance measurement key concepts kperfmon metrics resources metric time-varying measurement elapsed time processor time number instruction cache misses resource component kernel code function basic block measurements kperfmon combining metric resource generates instrumentation code snippets locations inserted kperfmon kerninstd perform actual instrumentation major features kperfmon explained greater detail shortly kperfmon measure unmodified running commodity kernel kernel source code kerninstd instrumentation engine directly measures performance accurate tools based statistical sampling broad range performance metrics based event counter measure wall time events virtual time events major research contributions kperfmon kperfmon shows wide range kernel performance measurements gathered dynamic instrumentation unmodified commodity operating system kernel kperfmon kernel profiling tool virtualize exclude measurement time spent context switched wall time metric explanation major kperfmon features measure time spent desired piece code function basic block kperfmon generally accumulate events occurring code event logically corresponds execution code events counted hardware examples hardware-counted events include number elapsed cycles data cache misses cycles stalled branch mispredictions examples software-countable events include completed database transactions retransmitted tcp packets failed file opens general pattern event accumulation instrumentation illustrated figure metric code resource instrumentation generated insertion code entry exit point entry instrumentation reads remembers underlying event counter metric exit instrumentation re-reads event counter subtracts read entry obtain number events occurring invocation code added accumulated total metric resource combination entry exit point delimit interval figure interval counter accumulation instrumentation currval current metric underlying event counter elapsed cycles number cache misses diagram omits details making instrumentation code thread-safe discussed chapter func basicblock accumulator start currval delta currval timer start accumulator total delta inserted instrumentation instrumentation point instrumentation point code entry code exit code events accumulated metrics measured framework interval counter metrics kperfmon extensible create performance metrics software-readable monotonically increasing event counter interval counter metrics based instrumentation code template figure metric-specific part instrumentation implementation code read current underlying event counter instrumentation figure measures wall time events wall time metrics function basic block opposed virtual time metrics measure elapsed number events occur thread entry exit code including events occur thread context switched virtual time metric contrast measures events occur thread actively running code excluding events occurring context switched wall time metrics measuring elapsed latency response time events time spent blocked synchronization object kperfmon measure virtual time metrics dynamically instrumenting kernel context switch code parts virtualization instrumentation context switch instrumentation stops virtual accumulators started thread switched context switch virtual accumulators stopped due earlier switch-out thread restarted manner kperfmon virtualize wall time metric feature kernel performance profiler contribution important easy create wall time metric instrumentation hard create virtual time virtualized metrics measuring events occur cpu actively running code measured cache events branch mispredictions processor time instrumentation examples yield inclusive metrics include events occurring code measured calling function exclusive metric measures events occurring thread program counter function measured kperfmon presently inclusive metrics reasons instrumentation simpler perturbation measuring exclusive metric require additional instrumentation procedure call stop restart event accumulation inclusive metrics find performance bottlenecks quickly traversing call graph inclusive time metric shown effective automatically searching bottlenecks user code evolving kernels final contribution dissertation framework evolving kernels evolving kernel automatically run-time adapts modifies code response run-time environment evolving kernels motivated kernel up-time ideally kernel ideally off-line momentarily paused modifications code place run-time evolving kernels enable approach operating systems obvious class evolving kernel algorithms perform sort run-time kernel optimization response measured performance optimization potential evolving system adapt security attacks kernel refuses tcp connections selected trusted group response measured tcp syn flooding denial-of-service attack general phases evolving kernel framework phase measurement detection data gathered identify problem phase creates solution improved code inserted kernel phase installs code running kernel steps repeated run-time environment continuously changing step suited dynamic instrumentation demonstrated kperfmon step requiring additional low-level instrumentation features augment code splicing dissertation presents contributions area evolving kernels contribution infrastructure changing commodity kernel code run-time infrastructure general arbitrary code modifications including optimizations security patches addition code modified system calls infrastructure generic modifications created sources independence keeping kerninst philosophy decoupling code generation mechanism inserting code running kernel contribution design prototype run-time kernel optimizer aimed improving instruction cache performance kernel code pettis hansen code positioning optimization reorders basic blocks improve instruction cache performance speedups achieved small compared user-level evolving system implements full range compiler optimizations run-time implementation demonstrates infrastructure run-time optimization commodity operating system kernel primary research contribution made 
dissertation demonstrate running unmodified commodity kernel converted evolving kernel chapter related work chapter discusses work related portion kerninst research contribution dissertation fine-grained dynamic instrumentation chapter related work respect presented section contribution run-time kernel performance measurement chapter section discusses related work area work related contribution evolving kernels run-time kernel optimizations chapter discussed section kernel instrumentation put related instrumentation work context review desirable features kernel instrumentation system modify code dynamically run-time static modifications kernel require reboot effect insert arbitrary user-specified code fine-grained insert code desired kernel location insert remove code time threads executing instrumentation location provide safety guarantees contents instrumentation code run commodity operating system enabling real-world workloads instrumented run unmodified kernel impractical require customized operating system insert remove instrumentation quickly introduce perturbation inherent expense instrumentation code inserted note goals obtainable goal inserting safe code precludes ability insert arbitrary user-generated code kerninst low-level instrumentation technology achieves goals code safety responsibility code safety delegated tools built top kerninstd tools generate code inserted sections describe systems perform form instrumentation compared kerninst focus kernel instrumentation user-level instrumentation tools discussed existing kernel instrumentation systems extensibility research kernels extensible operating systems spin exokernel vino cache kernel scout synthetix user-level processes download code kernel offering coarse-grained means changing kernel code dynamically spin applications change operating system interface implementation extensions spin extensions assign handler routine specific event central dispatcher event message announcing change system state request service event handler routines written type-safe language modulaand downloaded kernel address space procedure exported modulainterface potential spin event handler calling procedure raises event spin code downloaded kernel code installed chain handlers event procedure-grained instruction-grained instrumentation addition spin customized kernel precludes running real-world programs spin coarse-grained replace routines exported modulamodule interface vino kernel similarities spin extensibility allowing processes download code kernel vino downloaded code fault-isolated restrict memory access addresses belonging process addition downloaded code executes transaction environment process misbehaves grabbing lock infinite loop kernel detects aborts transaction vino classes methods customized per-object basis code kernel customized addition overrides object methods vino offers limited number instrumentation points whole-function granularity instrumentation sites pre-coded facilitate instrumentation virtual function makes call pointer vino simply point downloaded code synthetix system extensibility fundamentally manner spin vino allowing process-based customization kernel routines synthetix single optimization partial evaluation specialization commonly executed paths kernel routines kernel routines customized directly process control spin vino synthetix customizes kernel customizes entire routines synthetix customization installed simply changing function pointer level indirection vino routines specialized pre-written level indirection call function pointer incurring slight performance penalty customization routine place requiring special code sequence precludes general fine-grained instruction-level instrumentation prohibitive sprinkle calls function pointer kernel function scout operating system communication-oriented geared network devices video displays cameras pdas scout meant configurable device running key concept scout path abstracts route software layers information flows machine path created scout global knowledge transform optimize communication providing run-time optimizations scout closely related synthetix focusing optimization specific kernel components scout instrumentation arbitrary kernel code cache kernel exokernel operating system architectures minimal kernel protects underlying hardware resources physical memory pages disk blocks allowing processes manage conventional operating system functionality transferred user-level processes instrument kernel exokernel architecture require custom application policies downloaded kernel untrusted policy code inspected safety access permissions trusted inspection happen code downloaded kernel user space assurances code changed certified safe kerninst instrumentation preferable function pointer level direction extensible kernels fine-grained overhead instrumentation code inserted kernel fine-grained dynamic instrumentation easily duplicate extensibility techniques inserting code checks current process kernel policy function unlike extensible kernels kerninst ensure instrumentation code safe assumes trusted entity supplying code inserted kernel instrumentation code trusted future kerninstd instrumentation code generated sources leverage recent research safety-checking untrusted machine code dynamic instrumentation complementary research kernels provide additional fine-grained splicing capabilities extensibility commodity kernels modern unix operating systems provide limited forms process-based extensibility realized re-engineering specific parts kernel classic vnode interface file systems added recompiling kernel rebooting svr -based kernels provide form dynamic linking kernel modules device drivers loaded run-time forms extensibility limited vnode extensibility provided file system calls kernel dynamic linking operates coarser grain entire modules loaded run-time module modified slic project investigated extensibility commodity operating systems slic re-routes events crossing kernel interfaces system calls signals virtual memory extensions downloaded kernel run user-level process interposes extensions kernel interfaces rewriting jump tables classic technique level indirection achieved call function pointer binary patching kernel routines extensions perform processing intercepted event return pass event original destination slic kerninst runs commodity kernel solaris limitations call function pointer requires well-defined kernel interface intercept events intercepting system calls changing entry kernel variable sysent table pointers routines events coarse-grained number instrumentation points order dozens hundreds thousands kerninst slic method binary patching similar spirit kerninst paradyn appears flawed binary patching slic replaces instructions jump extension making susceptible race condition kernel thread executing code modified section static instrumentation static binary rewriters eel rational object code insertion pixie atom etch provide fine-grained instrumentation user programs potentially kernels static rewriting performed executable file program run context kernel reboot instrumentation effect problem magnified instrumentation code successively refined efficient searching performance bottleneck instrument top-level routines time results show bottleneck function instrumentation removed applied function callees strategy automate search bottlenecks run-time overhead time functions instrumented algorithm prohibitive static instrumentation system program re-run time instrumentation static instrumentation systems typically instrument masse instrumentation code interest instrumented prior execution dynamic instrumentation user programs section reviews related work dynamic instrumentation user-level programs tracing development earliest work debuggers performance measurement tools earliest published works dynamic instrumentation found debuggers early mid including dec ddt berkeley imp systems envisioned limited code splicing primarily conditional breakpoints tracing variation code splicing overwrites instruction trap transfers control tool debugger performs action continuing process steps required traps tool temporarily replace trap original instruction instruction single-stepped feature assumed exist processor single-step traps back controlling tool time tool puts trap instruction back place continues application debugger capability serve foundation performance tool inserted code performance measurement primitives primary limitation mechanism instrumentation run-time expense traps expensive process single-stepping trap program instrumented controlled tool context switches program tool place time instrumentation point reached increasing run-time expense kerninst similarities dyninstapi library enables application mutator 
dynamically instrument process mutatee dyninstapi originated decoupling instrumentation mechanism paradyn gui kerninst instrumentation differs dyninstapi ways kerninst instruments kernel dyninstapi instruments user programs dyninstapi cases enables fine-grained instrumentation partly influenced kerninst support presently incomplete sparc platform dyninstapi instruments overwriting instructions discussed section overwriting instruction dangerous instrumentation code cross basic block boundaries limitation instruction unsafe code executing sequence replaced dyninstapi tolerates condition detecting pauses application performs stack trace threads instrumentation deferred hazard detected technique inherently limited user-level instrumentation kernel paused difference kerninst dyninstapi area structural analysis kerninst live registers instrumentation site emit instrumentation code saving restoring registers kerninst dynamic kernel instrumentation foundations instrumentation user code briefly reviewed development dynamic instrumentation user code origins early debuggers advanced performance tools finally recognition general-purpose nature instrumentation creation library run-time instrumentation user code shown chapter dynamic instrumentation trivially extended kernel technical obstacles overcome dynamic instrumentation kernels section reviews existing dynamic kernel instrumentation work popular mechanism kernel instrumentation today trap-based similar examples discussed user code kerninst fulfills faster run-time splicing-based mechanism unmodified modern commodity operating system kernel earliest work dynamic kernel instrumentation kernel version dec ddt debugger topsplatforms kddt work published studies published kddt ddt primarily conditional breakpoints tracing early tool called informer provided form fine-grained kernel instrumentation allowing performance measurement code inserted operating system kernel key differences kerninst informer informer ran research platform berkeley sdsa -register machine -bit address space splicing informer simple sdsa single branch instruction reach range address space words springboards arise section instrumentation code informer bracketed code save restore registers cost acceptable sdsit modern platform informer find perform structural analysis determine register usage section fourth attaching informer sdss kernel facilitated actions privileged user code perform allocate directly kernel memory assuming knowledge kernel memory map words informer deal bootstrapping running kernel section authors informer ported platform case studies published solaris operating system tool called lockstat instruments lock routines kernel form dynamic instrumentation user program lockstat communicates kernel driver dev lockstat instruments kernel replacing single instruction variations variation return instruction lock routine replaced nop execution routine continue past return instruction instrumentation code previously inserted instrumentation code end returning behalf lock routine variation instrumentation replaces return instruction branch instrumentation code method instrumentation happen fall immediately function practice occurs instrumentation code shared routines instrumentation technology lockstat attractive simplicity general kerninst primary difference lockstat kerninst lockstat requires kernel modifications instrumentation code labels identifying instrumentation sites pre-compiled kernel difference lockstat instruments small subset kernel routines instrumentation sites solaris running ultrasparc tight coupling lockstat kernel lock routines developed tandem coupling lockstat avoid problems arise general-purpose instrumentation system problems include bootstrapping tool running kernel section identifying location kernel code section handling instrumentation code located close instrumentation point reached single branch instruction section general splicing kerninst subsumes lockstat driver lockstat reach instrumentation code bit quicker kerninst lockstat replaces return instruction nop single instruction perturbation nop introduced inherent expense instrumentation code kitrace tool gathering kernel code traces replaces instructions traced trap instruction control transfer custom handler handler appends entry trace log resumes execution trap instructions inserted kernel instructions kitrace fine-grained kerninst differs kitrace respects kitrace instrument kernel sense attempt insert code kernel resuming execution kitrace trap expensive trap instruction temporarily replaced original instruction single-step performed trap instruction put back place kerninst fine-grained dynamic instrumentation desired code subsumes kitrace effectively insertion trace-collecting code ibm dynamic probes dprobes coarse-grained breakpoints tracing user kernel code linux platform essentially mechanism kitrace dprobes overwrites single instruction trap executed transfer execution kernel handler identifies specific instrumentation site probe point executes instrumentation code original instruction executed temporarily restoring single-stepping instruction trap instruction put back dprobes advance kitrace code executed trap handler limited extent user-specified general instrumentation achieved presently probe instrumentation code probe program written custom language tracing breakpoints addition limitation underlying technology dprobes presently fine-grained probe points symbolic names beginning functions probed single-step approach kitrace dprobes unsafe multiprocessors original instruction temporarily restored single-stepping purposes thread running cpu executes code execute original sequence missing opportunity trap causing instrumentation code skipped problem occur user-level variants trap-based instrumentation discussed previous section controlling tool pause application replacing trap instruction single-stepping instrumentation summary system kerninst quickly instrument running modern commodity operating system run-time fine grain fact closest related instrumentation work user programs fine-grained static common dynamic instrumentation implemented research industry tools performance measurement commodity kernels chapter presents design implementation kernel performance measurement tool kperfmon built top kerninstd section describes related work area kernel performance measurement divided performance measurement sampling-only section performance measurement instrumentation section previous section related work operates user programs discussed kernel performance measurement tools put related performance measurement work context review chapter desirable features kernel measurement system run unmodified operating system run-time providing precise approximate performance measurements introducing perturbation system extensible set performance metrics based event counting wall time virtual time inclusive exclusive variants associate metrics machine resources code synchronization objects sampling-only approaches kernel performance measurement tools measure performance periodically interrupting program operating system kernel sample present program counter register sample assigns time sample instruction sampled long period time results yield accurate profile time spent program approach performance measurement attractive require instrumentation complex engineering task user programs kernel statically dynamically low perturbation remains constant general technique applied user-level code prof gprof gprof instrumentation obtain exact edge counts program call graph timing information collected exclusively sampling additionally compaq continuous profiling system dcpi morph alpha processors running compaq alpha platforms intel vtune performance analyzer windows sampling obtain operating system user-level code profiles dcpi vtune provide access on-chip event counters cache misses extend set performance metrics simple timings tools measure unmodified binaries run commodity operating systems exceptions gprof requires program recompilation morph runs modified version compaq unix operating system attractive design simplicity sampling-only approach performance measurement fundamental limitations difficulty sampling accurately assigning events instructions causing dcpi event counter register set overflow trap handler identify instruction caused trap update statistics identification difficult modern processors imprecise interrupts delivered cycles instruction causing interrupt completed impossible processors imprecise interrupt delay fixed alpha pentium pro solution problem presented profileme project periodically profileme chooses instruction profile cpu hardware support specially added alpha chip gather detailed statistics instruction execution stage pipeline hit 
i-cache data address loaded stored instruction completes trap generated software read process statistics gathered instruction instrumentation code reads hardware counters share difficulty rely imprecise interrupt mechanism fundamental limitation sampling-only tools timer metrics measure virtual events wall time events limitation precludes metric inherently includes events blocked latency mutex blocking time wall time measured purely sampling register thread program counter sampled context switched threads presently switched sample system idle loop thread actively running switched-out thread sampled profile time assigned conceivable measure wall events sampling-only approach significantly processing sample specifically sample stack backtrace switched threads events assigned routine blocked overhead approach prohibitive accurate results dictates frequent sampling dcpi morph mandates work sample maintain acceptable perturbation expense stack back-trace blocked thread sample prohibitive additional complications arise back-traces incomplete optimized code function called calls function action tear stack frame calling causing return directly tail-call-optimization implications dynamic kernel instrumentation discussed chapter interestingly instrumentation approach kerninst easily measure wall time requires additional work measure virtual time additional instrumentation makes virtual time measurement kerninst chapter sampling tools easily measure wall time limitation sampling-only profilers gather exclusive metrics reasonable accuracy difficulty measuring inclusive metrics gprof achieves inclusive virtual time instrumenting program collect counts edges program call graph assuming call function takes amount time dubious assumption introduce unbounded errors reported results mitigated frequent sampling dcpi attempt report inclusive time results susceptible error unlike gprof dcpi statistical sampling timings counts dcpi presently flat profile attempting include time spent routine callees fourth limitation sampling-only measurement metrics code resources data resources frequently measure blocking time mutex lock object sampling tool provide metric reasons inherently wall time metric discussed easily measured sampling fundamentally associating time spent mutex routine mutex object requires identify mutex object time mutex entry routine due compiler optimizations re-use registers purposes routine impossible sample mutex object limitation sampling-only approaches set performance metrics fixed limited metrics underlying readily sampled on-chip counters cache branch mispredict misses pre-calculated counters memory contrast dynamic instrumentation kerninst create counters software sampled instrumentation sampling-only approaches performance measurement essentially complementary sixth limitation sampling-only profilers order periodic sample tools require exclusive access system performance timers dcpi writes hardware performance counters overflow amount time trigger sampling means tool wishing counters run simultaneously dcpi final analysis sampling profilers well-suited limited class performance measurements dcpi well-suited identifying processor stall cycles due events cache misses branch mispredictions individual instructions measurements already-optimized programs examine detailed pipeline behavior fine-grained pipeline measurements traditionally exclusive domain simulators limitations measuring inclusive metrics measuring wall time associating metrics non-code resources creating metrics prevent dcpi general purpose profiler instrumentation approaches kernel performance measurement straightforward means measuring kernel performance add measurements directly kernel source code approach obvious disadvantages overhead instrumentation code borne data collects interest require access kernel source code set measurements fixed adding removing data collection requires kernel source code alteration recompiling rebooting limitations manual instrumentation sufficiently popular simplicity primarily package called kstats exists solaris kernel standardizing performance measurements access user code similarly package called tnf exists standardize kernel trace collection manual instrumentation section concerned performance measurement discussion limited kstats solaris kstats facility collects counts timings hundreds kernel events kernel source code calls macros increment counter track times events occur writing virtual memory page disk tcp packet retransmission counters timers read user code kstat library library access performance information approach drawbacks overhead instrumentation incurred time event takes place performance tool interested data kstats presently collects system-wide totals source code attempt conditionalize kstat collection specific process kernel thread adding kstat counter timer instrumentation point requires recompilation kernel code dynamic instrumentation augment kstats insert kstat counting code desired kernel locations run-time advantage instrumentation overhead present tool desired collect information shown chapter dynamic instrumentation virtualize counters timers instrumenting context switch routines temporarily stop restart accumulation events thread process question switched dynamic instrumentation concert existing kstats framework providing virtualizing framework summary existing work kernel performance measurement fall categories sampling obtain performance information kernel modification tools suited entire classes performance measurements wall inclusive metrics build metrics pre-existing event counters flip side tools instrumenting kernel solaris kstats approach create event counters measure wall time requires kernel source code modification kerninst attempts achieve worlds allowing accurate performance instrumentation inserted stock commodity kernel providing infrastructure creating software event counters metrics built run-time kernel code optimization evolving kernel code section discusses related work run-time code optimization evolving kernels earlier sections work performed user level occasionally discussed comparatively research run-time kernel adaptation date run-time compiler-like optimizations user programs run-time code optimizations type evolving algorithm section discusses existing work area user-level code dynamo user-level run-time optimization system hp-ux programs running paworkstations run dynamo unmodified binary linked dynamo shared library transfers control dynamo call library dynamo interprets program instrumenting collecting sequences hot instructions traces time dynamo inject optimized version trace fragment software cache code executes trace execute full speed dynamo fragments interprocedural spanning basic blocks procedure boundaries control exit set traces fragment cache dynamo resumes interpretation reaches address exist fragment cache assuming program exhibits temporal code locality dynamo expects reach steady state execution takes place fragment cache similar spirit kerninst evolving kernel framework differences underlying mechanisms kerninst dynamo dynamo runs user-level code kerninst runs kernel extended user code difficult port dynamo operating system kernel dynamo interpretation find hot traces instrumenting sampling taking control kernel run-time interpreting difficult user space overhead kernel interpretation unacceptable entire system affected slow kernel contrast slowed process isolated effect issue dynamo code expansion dynamo inserts entire fragments software cache basic block multiple times advantage enabling optimization interprocedural path traces result code explosion number executed paths high amount code acceptable hp-pa unusually large i-cache ultrasparc-i i-caches dynamo authors note interpretation increases chances code explosion higher interpretation overhead leads dynamo aggressively speculate contents hot traces optimized put fragment cache quickly dynamo tolerates flooding fragment cache periodically flushing cache detects frequent additions theory circumstances working set code formed difference kerninst dynamo approaches evolving code centers generality dynamo interpretation hot trace found time native code executed works long code interpreted long executing natively case dynamo code optimizations practical dynamo kinds evolving code scenarios detecting adapting security attack dynamo interpret system slowdown security attack 
detected dynamo backbone general-purpose evolving code framework dynamo evolving framework fundamental steps measurement weak link general-purpose evolving systems discussed section compaq wiggins redstone dynamic optimization system similar spirit dynamo measures application emits optimized code injected running program appears remove dynamo weak link obtaining hot paths sampling variant dcpi interpretation time unpublished presentation key points exists dynamo envision limited form evolving code optimization code compiler transformations project developed microsoft research called mojo similar spirit dynamo runs programs pa-risc programs significant difference mojo dynamo means executing cold blocks dynamo interprets cold code mojo performs direct-execution simulate effects basic block mojo lightweight disassembler identify block boundaries alters ending control flow instruction returns control mojo dispatcher emitted buffer direct execution software cache helps amortize cost disassembly mojo achieved speedups dynamo showing speedups spec benchmarks run-time wholesale user programs section overview run-time application compiler optimizations general system wholesale running code installation version algorithm run-time compilers run-time code generators excellent match step evolving framework creation code monitoring deciding code installing code left unaddressed projects necessarily limitation desirable independent products building evolving system fact made generation code orthogonal issue injecting code running system monitoring berkeley dynamic feedback project presents static compiler-based approach evolving user code allowing algorithms measured chosen runtime important feature dynamic feedback system choose radically implementations opposed approach tune control variables single algorithm performs run-time compilertype optimizations unmodified algorithm dynamo wiggins redstone dynamic feedback compiler generates versions algorithm source code optimization policy requires compiler implementations algorithm dynamic feedback compiler automatically parallelizes code choosing distinct synchronization algorithms dynamic feedback algorithm generated run-time program alternately performs sampling production phases sampling phase version executed fixed interval performance measured static instrumentation longer production phase version deemed fastest sampling phase changing algorithms run-time simple iteration program main loop switches variable present algorithm production phase run fixed internal program back sampling phase allowing program adapt environment change sampling phase infrastructure dynamic feedback forms generic evolving user-code system algorithms switch arbitrarily distinct limitations compared infrastructure kerninst measurement phase evolving system dynamic feedback static instrumentation generated compiler kerninst require compiler support difference installation phase evolving system dynamic feedback chooses algorithms simply switching control variable level indirection slight variations call function pointer exists extensible kernels discussed section problems levels indirection code built priori level indirection slight performance cost incurred time code reached number sites installation code place limited places level indirection exists run-time optimizations evolving code research kernels synthesis kernel provided early research kernel specialization synthesis creation kernel call file open generates returns specialized code executive kernel calls file read write future access executive calls synthesis purely research kernel support virtual memory synthesis required specialization policies built kernel pre-compiled code templates await values parameters executable code extensible operating systems discussed section section processspecific policies installed running kernel providing limited form code adaptation extensible kernels processes generate code step evolving system install code number limitations functions replaced pre-existing level indirection typically call function pointer easy redirection complete evolving framework proposed vino extensible kernel make kernel self-measuring envisions combination static compiler-generated performance instrumentation hard-wired statistics gathering kernel run-time installed code gather traces logs performance data code built kernel detect high resource utilization off-line heuristic system suggest algorithmic change examined simulating execution inputs previously gathered traces logs algorithm deemed superior current process extensible kernel install presently unimplemented framework proposed powerful key assumption custom kernel required steps incorrect kerninst perform commodity kernel steps installing measurement trace-gathering code run-time simulating situ proposed policy algorithm installing algorithm place existing run-time optimizations evolving code commodity kernels synthetix project follow-up synthesis project performing specialization modified version commodity operating system hp-ux synthetix implementation algorithm read system call specialized per-file per-process basis specialization incremental meaning level specialization change run-time specialization optimistic allowing possibly invalid assumptions boost amount specialization provided extra code kernel called guards handle un-specializing specialized code optimistic assumptions invalid limited context read system call synthetix shown customized commodity kernel adapt code run-time differences framework synthetix kerninst synthetix runs modified version operating system synthetix requires specialized code templates guards precompiled kernel synthetix invokes common technique pre-existing level indirection call pointer easily change implementations function means slight performance penalty incurred specialized code activated limits number points kernel specialized presently single point synthetix read system call fourth synchronization algorithm synthetix avoid race condition specializing code multiprocessor assumes single thread process existing commercial kernels limited hard-wired examples adaptive execution evolving code solaris kernel hard-wired implementation adaptive execution mutex locks called adaptive locks adaptive lock solaris spin block lock held thread depending holding thread state holding thread presently running processor primitive spin primitive block policy works spin case assuming locks generally held time overhead kernel thread context switches inherently incurred waiting acquiring mutex lock blocking summary section reviewed related work area evolving systems system kerninst underlying mechanism unmodified already-running commodity operating system kernel evolving unlike existing work kerninst technology fine-grained dynamic kernel instrumentation measuring identify problem installing code kernel unified technology important kernel modification challenging performing difficult engineering mechanisms single technology considered qualitative advancement related work summary chapter presented overview related work areas dynamic kernel instrumentation applications performance profiling run-time optimization system kerninst technological infrastructure fine-grained dynamic instrumentation already-running commodity operating system kernel remaining chapters dissertation describe describes design implementation infrastructure chapter manageable coherent study applications performance profiling chapter chapter evolving kernels run-time kernel optimizations chapter chapter introduction kerninst chapter overview kerninst system components section describes steps kerninstd performs startup steps attaching running unmodified solaris kernel section performing structural analysis kernel machine code sections structural analysis information kerninstd calculates kernel run-time symbol table function names starting addresses memory per-function control flow graph basic blocks machine code level call graph information live dead registers instruction benefit working machine code effect compiler optimizations reorder remove code visible kerninstd makes structural analysis information instrumentation clients applications find kerninstd structural analysis sufficient purposes requiring access kernel source code application wanting profile file system pathname-to-vnode translations solaris relevant function named lookuppn end users application code positioning optimizer works machine code level source code applications benefit kernel source code kerninst access make fortunately applications tend kernel developers access kernel source code kernel developer 
kerninst trace specific source code line compiler debugging line number information map line number address kerninst architecture structure kerninst system shown figure applications instrument kernel interact kerninstd user-level daemon super-user privileges kerninstd communicates small pseudo-device driver dev kerninst driver allocates code patch data heaps hold instrumentation code data kerninstd maps heaps address space dev kmem standard means unix systems accessing kernel virtual memory privileged user programs kerninst instrumentation functionality kerninstd kerninstd perform actions kernel address space enlist assistance dev kerninst placing functionality kerninstd positive effects minimizes kerninst presence kernel driver executes kernel address space kerninstd ability perform operations performed user-level process bootstrapping kernel instrumentation place kerninstd attach running kernel allocating code patch area heap parsing kernel run-time symbol table obtaining permission write portion kernel address space actions present technical challenges kerninstd directly allocate kernel memory allocate code patch heap dev kerninst perform kmem alloc call allocated kerninstd write memory dev kmem instrument kerninstd functions reside memory access kernel run-time symbol table static symbol table boot time kernel unix insufficient reasons incomplete kernel contained modules loaded boot-time run-time kernel modules relocatable files figure kerninst system architecture kerninstd acts instrumentation server performing kernel instrumentation requests arrive applications dev kerninst kerninstd kernel address space code patch heap ioctl application dynamic kernel instrumentation kernel profiler tracer optimizer instrumentation request data heap location memory unknown loaded kernel dev kerninst reads kernel run-time symbol table directly kernel memory behalf kerninstd solaris linked list kernel modules symbol locations solaris similar interface driver dev ksyms kerninstd dev ksyms returns symbol table elf format associating global functions respective modules kerninstd obtains copy kernel symbol table dev kerninst emitting code patch splicing require writing kernel address space kerninstd dev kmem running ultrasparc processor solaris earlier versions write kernel area nucleus nucleus single super-page i-tlb entry reserved kernel code kernel run-time linker solaris puts kernel modules area minimize kernel i-tlb misses solaris kernel core modules unix architecture-specific part kernel krtld kernel run-time linker genunix architectureindependent part kernel nucleus writing dev kmem succeeds virtual address directly writable change code nucleus mapped d-tlb circumvent problem kerninstd instructs dev kerninst map page call segkmem mapin perform write unmap segkmem mapout releases solaris dev kmem driver write nucleus solution dev kerninst employs limitations kerninst work taught valuable lessons modifying kernel code hard ubiquity dev kmem unix systems kernel designers anticipated hot-patching kernel code bypassing limited interfaces work dev kerninst trivially write kernel code nucleus fortunately fourth lesson back-door access kernel bootstrapping dev kerninst work problems structural analysis control flow graph startup kerninstd performs structural analysis kernel machine code creating per-function control flow graph cfg basic blocks calculating call graph performing interprocedural live register analysis higher-level tools built top kerninstd kperfmon perform run-time compiler-like transformations tools benefit greatly information compilers linkers discard part kerninstd structural analysis phase attempts reconstruct subset information benefit kernel source code section discusses structural analysis steps constructing kernel control flow graphs kerninstd control flow graphs purposes needed calculate live register information section cfg accurately runtime symbol table exact locations function code set allowable instrumentation points accurate determination instrumentation points important ensure splicing takes place code opposed data embedded function gaps functions higher-level tools built top kerninstd kperfmon control flow graphs basic block code coverage tool addresses basic block similarly kperfmon find function entry exit point inserting instrumentation start stop event accumulator function exit point easily determined cfg ends basic blocks successors building cfg basic rules kerninstd creates control flow graph kernel function directly reading parsing kernel machine code memory run-time priori information kerninstd relies parsing entry addresses kernel function kernel run-time symbol table source code required information kernel run-time symbol table basic block single-entry single-exit sequence contiguous instructions kerninstd makes exceptions definition discussed section block predecessor successor edges represent flow control block construction function control flow graph begins entry address runtime symbol table basic block address parsed exceptions discussed basic block includes instructions including control flow transfer instruction control flow instruction control function return procedure call destination address recursively parsed depth-first manner basic block basic block start address parsed graph edges added address falls middle already-parsed basic block block split control flow edges showing block falling cases parsing basic block ends reaching control transfer instruction instruction included block part alreadyparsed block basic block parsing ends prematurely situation occurs cfg created depth-first traversal function code scanned sequentially assembly language functions multiple entry points kerninstd recognizes entry point function prevent overlapping functions kerninstd marks edge cfg function falling function ending basic block function prematurely pattern occurs times solaris kernel create difficulties instrumentation clients kperfmon places timing instrumentation code function exit assumption function completed function falls instrumentation point fall-through missing time spent function instrumentation simply exit function executed function falls desired function called directly building cfg handling control-flow instructions section describes parsing control flow instructions simple cases conditional branches returns calls complex register-indirect jumps implement jump tables switch statements calls function pointer sparc control transfer instructions delayed succeeding instruction delay slot instruction executing control transfer takes effect motivation delay slots hide branch latency executing instruction interim class sparc control transfer instructions branches bit annul execute delay slot instruction conditional branch annul bit set execute delay slot instruction branch unconditional branch annul bit set ignore delay slot instruction kerninstd includes non-annulled delay slot instruction basic block control transfer instruction delay slot instruction instruction basic block remains block section splicing occur cases fortunately situation arises times solaris kernel earlier study found occurs times solaris kernel kerninstd permit splicing instructions non-annulled case conditionally annulled delay slot instructions basic block branch control transfer instruction delay slot instruction executed branch logically delay slot instruction basic block reachable if-taken branch figure kerninstd organization greatly increase number basic blocks conditional branch instructions kernel annul bit set memory usage space optimization requires algorithms working control flow graph interpret conditionally annulled delay slot instructions carefully live register analysis algorithm section interpret registers written delay slot instruction written aid live register analysis algorithm exception parsing organization rule made conditionally annulled instruction sparc register window save restore instruction section exception instructions means conditionally interpret effect instruction 
register state instances occur times kernel single-instruction basic block holding conditionally annulled delay instruction created figure discussed section cases control flow instruction analyzed safe backup understanding complex control transfer instruction marking block successor edge unanalyzable important parse control flow instructions accurately reasons control flow graphs boundaries basic block locations kernel code set allowable instrumentation points basic block parsing continue destination address unknown jump control function opportunity parse basic block lost making over-cautious analysis lead algorithms cfg live register analysis return conservative results operations lead inaccurate results kperfmon arbitrarily guess unanalyzable edge exits function deciding instrumentation function exit site belongs fourth algorithms run-time basic block reordering optimization discussed chapter work unanalyzable edges graph problem jump instruction implement unknown kind jump table correctly relocating jump table sequence destination blocks changed order requires making jump table data kerninstd presently cautious encounters unanalyzable jump giving figure conventional placement conditionally annulled delay instruction delay slot instruction add basic block reachable branch single-instruction basic block efficient memory kerninst control flow graph live register analysis bne iftaken add delay slot insn if-taken if-not-taken parsing function cfg safe kerninstd presently precludes instrumentation unanalyzable function section summarizes set unanalyzable kernel functions control transfer instructions kerninstd recognizes branches branch instruction end basic block branch destination recursively parsed basic block cfg branch local interprocedural branches occur times kernel branch conditional fall-through address recursively parsed fall-through address start function jumps constant address code jumps register previously set constant address detected treated unconditional branch detection taking backwards slice register checking instructions slice set register constant pattern occurs times kernel recognizing leads precise analysis returns return sequence found end basic block standard return instructions sparc ret return retl returns standard instructions kerninstd recognizes kind return sequence jump register saved copy link register function entry unusual sequence found examining backwards slice register occurs times kernel procedure calls strict definition normal procedure call expected return end basic block transfers control kerninstd modified definition basic block entered code block execute instructions call included basic block assuming procedure call eventually return call edge represented kerninstd call graph section algorithms live register analysis manually check procedure calls basic blocks handle including procedure calls middle basic block reduces amount storage required cfg live register analysis procedure calls kernel located middle basic block variant procedure call destination register implements call function pointer occurs times kernel code traversing cfg note unanalyzable calls make conservative assumptions destination assume call return sequence confused unanalyzable jump discussed tail calls tail call called function return caller norm caller return tail call semantics call return execute faster important kerninstd properly recognize parse tail calls serve call sites return points forms tail calls common optimized sparc code form calling routine stack frame save instruction restore delay slot call tears frame includes link register figure illustrates sequence occurs times kernel tail call variant found times calling routine stack frame simply jumps callee writing link register kind tail call interesting technical showing compiler optimizations functions make procedure calls stack frame long calls tail calls variant patterns callee address register tail call function pointer presently analyzed kerninstd ramifications discussed section intraprocedural calls call destination function occurs places kernel recursion calls intraprocedural recursive cases kerninstd assumes callee function missing symbol table re-parses give function meaningful odd form procedure call destination address current address instructions sequence found assembly code wishes read program counter side effect call instruction writing current program counter link register found earlier versions kernel sequence occur solaris sparc instruction reading program counter directly important recognize sequences avoid spurious recognition function jump tables jump table implements switch statement variants end jumping address single register address sum registers individual cases identified performing backwards slice register examining slice pattern important accurately recognize jump tables unrecognized jump instruction considered unanalyzable causing kerninstd give parsing ability instrument functions slice approach modeled similar design eel facilitates search jump table patterns filtering instructions affected jump match made kind jump table information obtained destination addresses recursively parsed successor basic blocks cfg basic block ending jump table block ending conditional branch number successor blocks variable figure tail call function called makes tail call restore instruction delay slot call stack frame link register address calls return directly save call nop save call restore retl nop ret restore number unique jump table entries kinds jump tables kerninstd recognizes offset jump table sequence sets register start jump table data register typically variable controlling switch calculate byte offset jump table jump table entry loaded obtaining offset added start jump table produce destination basic block address offset jump tables occurs times kernel average successor basic blocks simple jump table contents jump table -bit absolute addresses offsets start jump table register set constant address start jump table data register determine byte offset jump table jump table entry loaded sum registers loaded address jumped kind jump table occurs times kernel average successor basic blocks tagged jump table tagged jump table entry consists byte tag control variable compared destination address tag potentially entire jump table searched find match previous versions solaris kernel contained type jump table present solaris due compiler non-loading jump jump table indirect load performed calculate destination address register set base location code register produces offset control transferred location kind jump destination basic blocks equal size laid sequentially solaris occurs assembly routines blkclr occurrences hwblkclr average successor basic blocks control flow graph results parsed cfg instrumentation applications yielding estimates perturbation number instrumentation points required section summarizes contents kernel control flow graphs presenting code size number functions basic blocks number control edges basic blocks kernel module sizes vary greatly applications interested functions specific modules information presented module result contained figure modules sorted code size column module description module code size calculated summing size parsed basic block result figure correctly excludes dead code embedded data accurate symbol table function size field column shows number functions module successfully parsed giving number simultaneous instrumentation points needed measure number function calls made code module column additional number parenthesis number functions successfully parsed column number parsed basic blocks estimating number instrumentation points needed measure code coverage columns average number basic blocks 
function average number instructions basic block estimating perturbation instrumentation code final columns give information edges cfg average number successors average number predecessors basic block module estimating amount instrumentation needed measure edge coverage module bytes fns unparsed bbs bbs insns succs preds genunix afs afs syscall interface unix ufs filesystem ufs nfs nfs syscall client common streams module meta disk base module tcp tcp streams module procfs filesystem proc scsi disk driver rpcmod rpc syscall sockfs filesystem sockfs pci pci bus nexus driver hme feps ethernet driver siemens sab escc floppy driver serial driver uata ata at-bus attachment disk controller driver krtld rpcsec kernel rpc security module ufs log logging ufs module xfb xfb driver sep audiocs audio driver dad dad disk driver tmpfs filesystem tmpfs ldterm terminal line discipline afb afb driver sep scsi scsi bus utility routines tpi local transport driver specfs filesystem specfs arp arp streams module sunw ultrasparc-iii vol volume management driver doorfs doors figure summary structural analysis kernel information modules vary greatly number functions basic blocks bytes code surprisingly vary average number blocks function lesser extent average block size control flow edge information numbers successors predecessors uniform driver udp udp streams module timod transport interface str mod kerninst kerninst driver fifofs filesystem fifo streams module keyboard tnf kernel probes driver power manager driver time sharing sched class devinfo devinfo driver ipdcm dialup ttcompat alt ioctl calls diaudio generic audio elfexec exec module elf shmsys system shared memory ptc tty pseudo driver control ptc tlimod ktli misc module winlock winlock driver hwc streams module hardware cursor support streams module mouse ptem pty hardware emulator simba simba pci pci bridge nexus driver seg drv segment device driver sad streams administrative driver sad namefs filesystem namefs lockstat lock statistics ptsl tty pseudo driver slave ptsl rootnex sun root nexus dada ata bus utility routines dada ata ata bus utility routines message-digest algorithm sysmsg system message redirection fanout driver memory driver workstation multiplexer driver ebus ebus nexus driver ptm master streams driver ptm pts slave stream pseudo terminal driver pts realtime scheduling class iwscn workstation redirection driver iwscn fdfs filesystem eide nexus driver conskbd console kbd multiplexer driver conskbd module bytes fns unparsed bbs bbs insns succs preds figure summary structural analysis kernel information modules vary greatly number functions basic blocks bytes code surprisingly vary average number blocks function lesser extent average block size control flow edge information numbers successors predecessors uniform results surprises excluding kernel core unix krtld genunix modules vary greatly total size surprising wide discrepancy average number basic blocks function modules greater number total instructions top table tended basic blocks function average number instructions basic block varied widely moderate variance line study operating system basic block lengths average number instructions basic block aid estimating perturbation introduced perblock instrumentation basic block code coverage tool instrumentation twelve instructions expect code profiled manner approximately triple size including size instrumentation uniformity control flow edges basic block averages successors predecessors summary time takes create control flow graph shown figure todmostek tod module mostek log streams log driver indirect driver tty consms mouse driver sun consms kstat kernel statistics driver pckt pckt module ksyms kernel symbols driver inst sync instance binding syscall power power driver console redirection driver sysacct acct syscall clone clone pseudodriver clone intpexec exec mod interp pseudo nexus driver pseudo ipc common ipc code pipe pipe syscall connld streams-based pipes options options driver redirmod redirection module dptbl time sharing dispatch table interactive scheduling class dptbl realtime dispatch table platmod totals module bytes fns unparsed bbs bbs insns succs preds figure summary structural analysis kernel information modules vary greatly number functions basic blocks bytes code surprisingly vary average number blocks function lesser extent average block size control flow edge information numbers successors predecessors uniform action performed kerninstd starts cost seconds reasonable greater concern control flow graph memory consumption structures hold basic blocks consume memory includes block address boundaries predecessor successor edges information facilitate searching basic blocks address include code block actual kernel code originally parsed per-function structure consumes memory storing kernel code unnecessary kerninstd read code demand dev kmem operations live register analysis fast access kernel code control flow graph results parsed functions presently parsed kerninstd section analyzes reasons parsing failures ramifications kernel functions parsed make calls routines return panic kerninstd parsing fail case assumes call return continues parse running end function list functions return kerninstd routines parsed kernel functions perform jump behaves return recognized backwards slice destination register show initialized copy link register function entry twelve assembly functions perform unique patterns unanalyzable jumps difficult routines parse correctly remaining un-parsed functions common form tail call kerninstd parse routines stack frame make indirect tail call simply jumping contents register setting link register kerninstd parsing step time seconds read function code kernel memory add code function object makes copy code parse basic blocks creating cfg update call graph section actions total figure time parse function control flow graphs times kerninstd compiled optimization level assertions disabled running mhz ultrasparc processor preliminary actions notably reading code kernel memory cfg parsing requires seconds phase kerninstd startup takes seconds recognize sequence set pattern backwards slice register destination address parse routines kerninstd assume unanalyzable jumps register fact kind tail call incorrect assumption sequences discussed earlier section addition jump table format introduced kernel code kernel upgrade code generated compiler version hundreds misidentifications occur properly recognize parse functions additional work fixed pattern conform manageable set match sequences adding undue complexity kerninstd repercussions unanalyzable jumps presently minor indirect tail calls stub functions simply perform loads obtain function pointer jump stub routines interest performance measurement optimization hand indirect tail calls non-trivial functions interest unanalyzable functions routines interest invoked booting kernel panic un-parsed functions kerninstd function structural analysis call graph call graph represents interprocedural calls branches providing complement control flow graphs maintain intraprocedural control transfers call graph constructed traversing basic blocks control flow graphs identifying calls interprocedural branch instructions fixed destination addresses register-indirect calls jumps function pointer statically unknown destination put call graph construction call graph updated incrementally function control flow graph parsed 
takes seconds call graph consumes megabytes memory kerninstd structural analysis live register analysis startup kerninstd performs dataflow analysis kernel yielding registers live future dead written read instruction register liveness information lets applications generate code snippets dead registers instrumentation point spilling stack free scratch registers live register information internally kerninstd obtain scratch register needed jumping code patch relocating overwritten instruction instrumentation point dataflow representation basic algorithms dataflow function represents effects executing code individual instruction basic block entire function liveness register dataflow function killed made live registers unaffected dataflow functions composed represent sequential execution successive composition dataflow functions instruction basic block reverse order yields dataflow function basic block dataflow functions merged union registers made live intersection registers killed intersection registers unaffected combine effects if-taken if-not-taken successors conditional branch dataflow functions require bits register kerninst represents integer registers floating point registers registers condition codes program counter processor interrupt level dataflow functions totaling bytes sparc architecture complicates matters sparc integer registers organized partially overlapping register windows time program access non-windowed integer registers called global windowed integer registers called input local output save instruction creates window shifting register window shown figure register window stack conceptually infinite topmost windows ultrasparc-i ultrasparc-ii implementations save overflows on-chip window stack trap handler writes oldest window memory restore opposite save trap underflowing on-chip window handler reads window memory register windows make live register analysis challenging places code implicitly windows kerninst dataflow function stack dataflow function windows level bytes storage register window register window frame register window frame figure sparc register window overlapping register window frame calls sets frame executing save instruction set registers registers overlap aliases previous frame registers accessed code analyzed startup algorithm phase per-block dataflow functions calculated kerninstd parses kernel control flow graphs dataflow function represents effect register liveness executing routine beginning basic block startup algorithm completes dataflow function effect executing entire routine routine entry block dataflow function startup algorithm kerninstd calculates dataflow functions basic block isolation blocks successors predecessors mentioned section calculation iterates backwards block composing dataflow effect instruction calls present basic blocks section effect callee considered effect call delay slot instruction considered call side-effect setting link register ordering consistent temporal nature backwards dataflow problems callee effect determined recursively performing live register analysis needed depth-first traversal kerninstd live register analysis interprocedural conservative dataflow result unanalyzable callee situation occurs functions cfg parsed calls pointer callees recursively analyzed due cycle call graph sparc register windows make calculating conservative result routine difficult window dataflow function section report registers made live number windows chosen routines balanced saves restores requiring one-window dataflow function routines imbalanced incorrectly guessing number stack windows confuses live register analysis unclear merge dataflow functions disagreeing number windows kerninstd work problem hard-wiring number stack windows needed dataflow functions routines single routine stubs common code presently kludged routine performs restore save commonly invoked wrapper calling function module loaded locked stubs common code indirectly recursive conservative result needed depth-first traversal call graph conservative dataflow function proper number stack windows stubs common code enables analyzing routines fail unbalanced routines kernel stubs common code attribute determined automatically control flow effects intraand interprocedural branches jump tables considered control flow graph edges basic blocks considered phase startup algorithm phase phase startup algorithm calculates per-block dataflow functions representing execution routine beginning block isolation phase intermediate results phase calculation discarded dataflow function basic block re-calculated dataflow function successor blocks steps results calculated successor block gathered results interprocedural edges interprocedural branch interprocedural fall-through gathered results calls gathered phase recursively analyzing destination routine needed dataflow function basic block isolation phase applied result edge results merged obtain dataflow function execution beginning basic block block predecessor dataflow functions re-calculated phase repeats convergence conceptually ideal store dataflow functions instruction making trivial query set scratch registers instrumentation point required storage prohibitive kerninstd information top basic block dataflow functions individual instructions calculated demand run-time section throwing dataflow functions top basic block requires storage kerninstd time space trade-off made storing dataflow functions entry function dataflow functions instruction granularity calculated run-time demand startup phases interprocedural live register analysis complete seconds runtime algorithm dataflow functions representing effects execution top basic block straightforward calculate dataflow functions beginning desired instruction run-time information calculated intermediate points phase startup algorithm dataflow function execution bottom basic block calculated merging dataflow functions block successors dataflow function representing execution part basic block isolation instruction question end basic block calculated logic phase startup algorithm finally function composed dataflow function bottom basic block obtain desired result dataflow function representing execution routine including instruction question time execute runtime algorithm depends number instructions analyzed distance instruction question end basic block number successors determines dataflow functions composed merged typical case successor blocks instructions basic block analyzed completes time calculate effect partial basic block compositions remainder merge compositions live register analysis results knowing integer registers dead instrumentation points instrumentation clients hope generate code snippets dead registers categories instrumentation points function entry exits special interest commonly instrumented kperfmon section summarizes results kerninstd interprocedural live register analysis presenting average number dead registers points kernel number dead registers vary modules module save entry points avg dead regs nonsave entry points avg dead regs exit points avg dead regs avg dead regs insn genunix afs afs syscall interface unix ufs filesystem ufs nfs nfs syscall client common streams module meta disk base module tcp tcp streams module procfs filesystem proc scsi disk driver rpcmod rpc syscall sockfs filesystem sockfs pci pci bus nexus driver hme feps ethernet driver siemens sab escc floppy driver serial driver uata ata at-bus attachment disk controller driver krtld rpcsec kernel rpc security module figure dead registers solaris kernel dead registers scratch instrumentation code kerninstd interprocedural live register analysis shows function entry points dead registers exit points dead registers interestingly average number dead registers kernel instruction approximately splits difference entry point exit point averages functions successfully parsed control flow graphs included numbers ufs log logging ufs module xfb xfb driver sep audiocs audio driver dad dad disk driver tmpfs filesystem tmpfs ldterm terminal line discipline afb afb driver sep scsi scsi bus utility routines tpi local transport driver specfs filesystem 
specfs arp arp streams module sunw ultrasparc-iii vol volume management driver doorfs doors driver udp udp streams module timod transport interface str mod kerninst kerninst driver fifofs filesystem fifo streams module keyboard tnf kernel probes driver power manager driver time sharing sched class devinfo devinfo driver ipdcm dialup ttcompat alt ioctl calls diaudio generic audio elfexec exec module elf shmsys system shared memory ptc tty pseudo driver control ptc tlimod ktli misc module winlock winlock driver hwc streams module hardware cursor support streams module mouse ptem pty hardware emulator simba simba pci pci bridge nexus driver seg drv segment device driver sad streams administrative driver sad module save entry points avg dead regs nonsave entry points avg dead regs exit points avg dead regs avg dead regs insn figure dead registers solaris kernel dead registers scratch instrumentation code kerninstd interprocedural live register analysis shows function entry points dead registers exit points dead registers interestingly average number dead registers kernel instruction approximately splits difference entry point exit point averages functions successfully parsed control flow graphs included numbers namefs filesystem namefs lockstat lock statistics ptsl tty pseudo driver slave ptsl rootnex sun root nexus dada ata bus utility routines dada ata ata bus utility routines message-digest algorithm sysmsg system message redirection fanout driver memory driver workstation multiplexer driver ebus ebus nexus driver ptm master streams driver ptm pts slave stream pseudo terminal driver pts realtime scheduling class iwscn workstation redirection driver iwscn fdfs filesystem eide nexus driver conskbd console kbd multiplexer driver conskbd todmostek tod module mostek log streams log driver indirect driver tty consms mouse driver sun consms kstat kernel statistics driver pckt pckt module ksyms kernel symbols driver inst sync instance binding syscall power power driver console redirection driver sysacct acct syscall clone clone pseudodriver clone intpexec exec mod interp pseudo nexus driver pseudo ipc common ipc code pipe pipe syscall connld streams-based pipes options options driver redirmod redirection module module save entry points avg dead regs nonsave entry points avg dead regs exit points avg dead regs avg dead regs insn figure dead registers solaris kernel dead registers scratch instrumentation code kerninstd interprocedural live register analysis shows function entry points dead registers exit points dead registers interestingly average number dead registers kernel instruction approximately splits difference entry point exit point averages functions successfully parsed control flow graphs included numbers depending code written versus assembly compiled code number dead registers depends compiler generate code optimization level results summarized figure column module description ordering figure code size number functions stack frame average number dead registers entry functions columns give similar entry point information functions begin save information number dead registers exit points functions bracketed save restore instructions exit point dead registers registers non-overlapping part register window stack pointer exit points optimized tail calls number dead registers assumes ability de-optimize sequence regular call return sequence discussed chapter final column shows average number dead registers machine code instruction kernel results surprises dead registers entry functions set stack frame save restore average functions entry point save accesses register window rest function due register window overlapping registers dead save dead registers save dead registers save entry points functions set register windows dead registers entry points functions save average dead registers ratio functions register window varies greatly afs function begins save indicating compilation optimization surprise commercial driver dptbl time sharing dispatch table interactive scheduling class dptbl realtime dispatch table platmod totals module save entry points avg dead regs nonsave entry points avg dead regs exit points avg dead regs avg dead regs insn figure dead registers solaris kernel dead registers scratch instrumentation code kerninstd interprocedural live register analysis shows function entry points dead registers exit points dead registers interestingly average number dead registers kernel instruction approximately splits difference entry point exit point averages functions successfully parsed control flow graphs included numbers expected exit points registers free high kernel-wide average dead registers surprising pleasant surprise final column showing kernel-wide average dead registers execute code snippets generated kperfmon finally interesting note average number dead registers kernel instructions roughly splits difference average number dead registers function entries exits decrease dead registers instruction linear distance exit point suggest applications freedom place instrumentation code choose instrument close exit point application instrumenting basic block code coverage find scratch registers placing instrumentation ends basic blocks block entries numbers presented dead registers conservative kerninstd ignores assumptions allowed application binary interface abi registers volatile function call conservative assumption affect result function make register kernel code sparc abi assumptions dangerous strengthen kerninstd analysis identifying majority code follow sparc abi existence user-level abi verification tools appcert suggests automated identification set functions follow abi live register analysis analyzed live register analysis performed function successfully parsed control flow graph section routines analyzed functions debug flush windows flush user windows flush sparc register window contents stack functions analyzed perform save restore instructions loop making fixed number window levels dataflow functions impossible set routines analyze correctly if-taken if-not-taken successors conditional branch dataflow functions disagreeing number window levels presently occurs assembly language functions call panic call preceded save instruction knowledge panic returns restore intentionally omitted omission kerninstd identify part function dataflow function save restore causing confusion dataflow function merged code balanced save restore count function successfully parsed cfg failed live register analysis instrumentable conservative assumption registers live function functions included figure significantly alter averages summary research contributions chapter introduced kerninst system structure actions performed kerninstd start-up unique characteristic kerninst chapter ability load performance tool unmodified commodity kernel runtime kerninst startup components allocating code patch heap obtaining structural analysis kernel code obtaining ability write kernel address space start-up kerninstd perform run-time kernel splicing subject chapter chapter fine-grained code splicing code replacement chapter presents design implementation dynamic kernel instrumentation primitives kerninst fine-grained code splicing inserts arbitrary instrumentation code machine code instruction granularity code replacement installs version function splicing overwrites machine code instruction desired instrumentation point jump code patch simplest case code patch instrumentation code generated run-time overwritten instruction jump back instruction instrumentation point shown figure net effect inserts generated code desired machine code instruction 
code replacement instruments entry point function jump version function reduce run-time overhead code replacement alters statically identifiable call sites function directly call version avoiding overhead inserted jump figure code splicing machine code instruction overwritten branch patch code desired instrumentation code overwritten instruction branch back instruction stream kernel code code patch branch dynamically generated jump back instruction overwritten instruction equivalent sequence code inserted instrumentation point instrumentation point important feature kerninst splicing code replacement mechanisms independent code generation kerninst general splice replacement machine code created code generation packages vcode dynamic compilers interpreter performing just-in-time compilation precompiled positionindependent code important feature kerninst instrumentation mechanisms require kernel source code splicing request machine code kernel code address inserted code replacement request machine code function replace application generates machine code benefit access source code placing code kernel splicing replacement require source code remainder chapter discusses kerninst performs fine-grained run-time instrumentation code replacement solaris kernel running ultrasparc processor sections describe code splicing section describes code replacement section discusses future work including porting primitives platforms section summarizes chapter including research contributions splicing basic code patch issues section presents basic issues allocation code patch filling desired instrumentation code section discusses relocating overwritten instruction instrumentation point code patch kerninstd de-couples splicing generation instrumentation code kerninstd instrumentation server accepting requests instrumentation clients splice machine code kernel instrumentation point request made instrumentation client query set dead registers instrumentation point registers instrumentation code instrumentation client generates machine code version instrumentation code version scratch registers save restore instructions free registers version case kerninstd decides bracket instrumentation code save restore instructions behest generated kerninstd version multiple snippets instrumentation code instruction require scratch registers kerninstd insert save restore instructions code patch unsafe instrument kernel trap handling code register-window-overflow trap handler inserting save infinite loop trap handlers save trap panic raising number nested traps processor maximum splice kerninstd allocate code patch code patch size total size instrumentation snippet presently installed point room save restore instructions needed space original instruction instrumentation point space jump back instruction instrumentation point returning jump code sequences varying numbers instructions depending required displacement scratch register number instruction bytes required code patch precisely determined allocated circular dependency broken assuming maximum number instructions needed perform jump -bit kernel -bit kernel calculating patch size takes allocating typically takes patch space allocated kerninstd prepares write calling mmap dev kmem typically takes write mapped memory typically takes due kernel policy deferring allocation physical backing page needed solaris directly write code patch allocated nucleus dev kmem section writing indirectly mmap works emitting completes munmap takes code patch begins instrumentation code downloaded client client sends relocatable code roughly similar elf object file emitting place code patch allocation final representation instructions sparc calls depends part location memory splicing relocating overwritten instruction code patch code patch ends relocated version instruction overwritten splicing branch semantically equivalent sequence instructions section discusses key concepts relocation demonstrates relocation interesting cases key conclusion relocation sparc instruction relocated code patch verbatim semantic equivalent sequence instructions overview relocation presented section section discusses relocation optimized tail calls section showing kerninstd instrument point previously exist callee returns caller returns section discusses relocation conditional branches allowing instrumentation control flow graph edges section discusses challenging case instrumenting delay slot instructions basic concept maintain semantics relocated code maintain semantics overwritten instruction simple case non-control-flow instructions instruction relocated verbatim code patch code sequence jump back instruction instrumentation point instructions transfer control unconditionally return jump maintaining semantics overwriting control transfer instruction delay slot generally requires relocating delay slot instruction code patch instruction overwritten splicing original delay slot instruction left place longer executed control transfer delay slot instruction delayed control-transfer instruction relocation complex fortunately code pattern exist kernel relocation requires subtle semantics overwritten instruction depend location memory instruction copies address contained program counter register maintain original semantics relocated version instruction put address instrumentation point destination register similarly sparc jump-and-link instruction copies program counter destination register jumping relocated version maintains semantics instructions address instrumentation point copied register link part jump-and-link original jump performed modified ignore link similarly sparc call instruction writes program counter equivalent relocated sequence writes address instrumentation point unconditionally jumps callee creating instrumentation point existed relocating tail calls exit point tail call technically challenging splice discussed section tail call sequence callee return caller caller return semantically performs call return place code splice instrumentation callee returns caller returns section discusses relocating tail call sequence instrumentation callee returned examples section assume common sparc tail call sequence call restore unwinding tail call sequences handled similarly tail call instrumented returns de-optimizing semantically equivalent call return figure shows original code de-optimized version code patch tail call unwinding performed paradyn order execute restore instruction unwind caller stack frame save link register stack normal call execute desired exit point instrumentation restore link register stack return paradyn algorithm attractive original code restore performed call register window frame kerninst method stack location save link register safely scratch storage space reserved operating system spill register window frame needed latest version paradyn unwinding sequence kerninst relocating conditional branches sparc conditional branch instructions interesting case instrument user request instrumentation code executed cases branch branch cases inserting instrumentation code control flow graph edges branch instructions challenging relocate pc-relative displacement maintain if-taken address relocation instruction displacement changed modified displacement fit displacement field branches relocated semantically-equivalent sequence original tail call equivalent unwound code arguments regs call restore reg reg reg delay slot restore adds reg reg current register window reg post-restore register window kernel reg add register arguments regs add reg reg reg reg reg changed register duplicates part restore add set args copy call nop copy back result copy exit point instrumentation ability place instrumentation exist original code ret restore plain restore add figure tail call unwinding exit point instrumentation original call restore sequence relocated code patch unwound de-optimized semantically equivalent sequence instrumentation code bold sequence returns ability instrument exit point exist original code instructions shown figure relocating delay slot instruction solaris kernel delay slot instruction control-transfer instruction section splicing delay slot problematic figure illustrates difficulty splice instruction delay slot call delayed control transfer instruction delay slot instruction callee execute 
transfer control code patch splicing delay slot safety performed desired effect achieved splicing delay slot control transfer instruction control transfer instructions discussed opportunity place instrumentation code relocated delay slot instruction feature implemented kerninst difficult code patch contents instrumentation executed branch branch condcheck condcode if-taken nop delay slot if-not-taken instrumentation executed branch relocated delay slot instruction branch delay slot executed fall-through jump instrumentation point address if-taken instrumentation executed branch relocated delay slot instruction branch delay slot executed if-taken jump destination overwritten branch figure relocated conditional branch instruction general case note relocated version branch enables places drop instrumentation branch branch places exist original code depending annul bit branch instruction delay slot instruction exist executed branch relocated sequence possibilities finally note sequence optimized unconditional branch original code code splicing executed instructions call bar add call bar code patch instruction bar finally code patch takes effect figure splicing delay slot work effect replacing add instruction delay slot call bar splice instruction code patch undesirable splice instruction delayed instruction chance transfer control instruction bar executed challenging case splicing instrumentation code delay slot instruction conditionally executed occurs control transfer instruction conditional branch annul bit set delay slot instruction execute branch maintaining semantics requires instrumentation code executed branch relocation conditional branches section if-taken ifnot-taken code portions solution straightforward technique work delay slot destination branch difficulty knowing control transfer instruction instruction reached possibilities parent control transfer instruction branches reach delay slot instruction path instruction dictates control resumed end code patch instruction reached delay slot parent control transfer instruction handled earlier section handled falling instruction ambiguity splicing place delay slot instruction start basic block mentioned section pattern found times solaris kernel splicing jumping code patch code patch emitted final step overwrite existing code instrumentation point jump branch instruction reaches code patch similarly un-splicing takes place putting original instruction instrumentation point back place step challenging reasons kernel running splicing taking place paused code executing instrumentation point splicing occurs raising possibility dangerous race condition solaris kernel multi-threaded increasing chances dangerous race condition assume original code instrumentation point modified priori facilitate splicing splicing un-splicing multi-threaded kernel pausing accomplished ensuring instruction replaced instrumentation point splicing instruction branch code patch un-splicing instruction original overwritten instruction instrumentation point section motivates single-instruction-write rule notes technical problem arises discusses solutions avoiding hazards splicing safety kerninstd splices overwriting single instruction instrumentation point branch code patch time instruction effect minimum make data cache unified cache instruction cache brought pipeline delay hazardous race conditions means precise time splice takes effect unknown takes effect kernel thread executing instrumentation point fetch safely execute original pre-splice code splice takes effect kernel thread fetch execute post-splice code sequence execute mix pre-splice post-splice code sequences single-instruction splicing hazard-free atomic splicing insufficient ensure safe execution sparc atomically overwrite instructions instrumentation point thread execute mix pre-splice post-splice sequences case shown figure dyninstapi paradyn user-level tools avoid problem pausing program examining back-trace threads check return instructions overwritten hazard detected splicing deferred retried technique work kernel reasons pausing kernel allowed disrupt potentially critical background activities performing back-trace threads expensive pausing inexpensive jump unanalyzable destination longjmp find reach middle overwritten instruction sequence resulting hazard fourth problem multiple-instruction splicing hard make fine-grained instrumentation point instruction basic block splice sequence spill basic block ifb reachable basic block code executing path execute inconsistent instruction sequence crash kernel splicing kerninstd overwrites single instruction dev kerninst perform undoable write undoable write overwrites instruction kernel memory additionally logs information change address original content undo effects write emergency kerninst emergency situation occurs kerninstd crashes undoable writes branch instructions splicing left place kerninstd crash causing panic module unloading re-enabled code patch heap de-allocated undoable write writing uninitialized allocated memory writing location undoable write state case splicing splicing executed instructions original figure atomic splicing splicing hazardous program counter executed instructions overwritten execution continues mix pre-splice post-splice sequences executed original original occurs instrumentation site changed branch code patch replaced branch code patch undoable write state updated undoable write takes writing nucleus undoing undoable write takes nucleus challenge insufficient displacement reach code patch safety requires single-instruction splicing architectures provide ideal instruction branch instrumentation point code patch ideal splicing instruction displacement reach code patch instrumentation point delay slot instruction implicitly executed code patch reached side effects changing program counter jumps destination address fixed pc-relative register-relative register relative jump instruction arbitrary range requires register set leading unsafe multiple-instruction splicing small ensure instruction overwritten trivially true risc architecture concern figure reviews architectures branch jump instructions suited single-instruction splicing architectures instruction suitable key limitation displacement patch area heap allocated arbitrarily code kernel modules splicing means reaching code patch matter required displacement splicing single instruction safety remainder section discusses solutions address reach problem arch instruction range delay slot side effects overwrites instruction sparc call writes jump register powerpc mips current aligned region cond alpha branch jmp register jmp figure suitability instructions single-instruction splicing architectures ideal splicing instruction displacement insufficient risc architectures guarantee single instruction overwritten splicing solving reach problem springboards kerninst general solution displacement problem called springboards springboard scratch area reachable instrumentation point suitable single splicing instruction idea splicing instruction branch unused reachable springboard performs long jump code patch instructions needed figure diagrams code splicing presence springboards code patch springboard written flushed instruction cache performing final step writing splice instruction instrumentation point ordering ensures kernel thread begin executing springboard code splice effect springboard originally scratch space safe assume thread springboard splice takes place springboard multiple instructions hazard similar replacing instruction instrumentation point springboard approach requires chunks scratch space collectively springboard heap conveniently sprinkled kernel kernel instruction reach chunk suitable instructions listed figure fortunately unix system v-based kernels solaris linux windows ideally suited space initialization termination routines dynamically loaded kernel modules kernel modules loaded run-time unloaded memory tight module initialization termination routines called module loaded module unloaded solaris routines called init fini unix svr standard routines called module load module unload linux called init module cleanup module windows figure springboards reach code patch level indirection reach code patch instrumentation point finished code patch returns directly instrumentation point instrumented code springboard code patch long jump code patch instructions 
instrumentation point jump back instruction instrumentation point instrumentation code relocated instruction device drivers driverentry routine installs pointer cleanup routine kerninstd effectively module initialization termination routines making adding springboard heap locking modules memory ensure routines called solaris locking dev kerninst call mod unload disable preventing module unloading re-loading obviates redo splicing implicitly undone module unloaded re-loaded practice kernel module approaches megabyte size figure jump instruction modest displacement sparc easily reach nearest springboard solaris module supply fini routine module unloaded core kernel modules unix krtld genunix init fini routine fortunately modules loaded contiguously kernel considered large module purposes displacement reach springboard solution works modules work case kerninst takes routines unix module kernel booting start main routines springboard space routines provide figure summarizes springboard space set current version kerninst broken nucleus outside-of-nucleus components nucleus component extra springboard space manually compiled code space dev kerninst onthe assumption driver modules loaded nucleus springboard needed kerninstd searches range resides i-cache line instrumentation point start code patch allocation takes kerninstd fills springboards contents undoable writes section takes springboard resided nucleus springboard technique ad-hoc general apply kergeneral location springboard space bytes kernel nucleus kernel nucleus total figure springboard space solaris kernel modules located nucleus chances nucleus springboard space non-nucleus springboard space nucleus space gathered ways routines boot-time start main space manually compiled dev kerninst assumption driver loaded nucleus init fini routines kernel modules nucleus nonnucleus space gathered ways memory allocated kmem alloc init fini routines kernel modules nucleus nels -bit operating systems code patch heap allocated kernel data space allocated farther code -bit systems exacerbating reach problem motivating general solution springboards solving reach problem in-nucleus allocation solution reach problem avoids allocating code patches sufficiently close respective instrumentation points technique general springboards dev kerninst access kernel internal memory allocation routines feasible discussed section running ultrasparc processor solaris kernel place kernel code area code nucleus kernel module code completely fit nucleus allocated data space nucleus space depleted sense module code fit leftover space large free space code patches springboards presently kerninstd attempts leftover nucleus space code patch heap allocation page nucleus text performed dev kerninst takes lower amortized cost instrumentation request allocation performed code patch heap run space grow un-splicing instrumentation client downloads code kernel kerninstd remove time kerninstd cases un-splicing occurs instrumentation remains site kerninstd un-splices instrumentation point replacing splicing branch instruction original overwritten instruction addition kerninstd clears undoable write state location section operation takes instruction nucleus springboard place additional needed springboard resided nucleus sifthe springboard resided nucleus safety reasons detailed shortly removing springboard deferred give thread executing springboard chance leave springboard freed case un-splicing instrumentation remains site kerninstd splices code patch remaining instrumentation snippets time spent patching kernel un-splice code paragraph undoable write information point splice effected simply writing branch instruction instrumentation point springboard cost fact slightly splicing site previously uninstrumented undoable write state updated operation completes instrumentation point nucleus instrumentation point nucleus springboard required code patch allocated initialized costs splicing previously uninstrumented site cases de-instrumentation leaves code patch springboard eventually garbage collected safety concern kernel thread presently executing context switched springboard code patch safe return objects respective heaps re-allocated importantly re-written kernel threads exited code structures springboard code patch code blocks thread executing midst remain long simply delaying milliseconds returning structure free heap safe case springboard instructions block code patch greater concern reasons instrumentation code block performs relocated instruction code patch block call mutex enter solution presently employed kerninstd wait seconds returning springboard code patch respective heaps hoping delay sufficient drain remaining threads structures proven sufficient practice solution unsatisfying safer approach implemented bracket entry exit code patch thread-safe counter increment decrement counter reflects number kernel threads presently code patch de-allocation safe concerns approach adds run-time overhead shared counter contention multiprocessor safe code increments counter effect couple instructions executed similarly code decrements counter item code patch jump back instruction instrumentation point fortunately augment technique delay achieve safety instructions execution exiting code patch block large delay sufficient ensure code completes similarly instructions execution start code patch counter incremented block counter checked sufficient delay confident execution dangerous instructions code replacement run-time kernel code replacement logically distinct complementary code splicing code splicing inserts code unmodified function code replacement installs version function note replacement function recognized kernel function kerninst function subsequently spliced replaced low-level implementation code replacement mechanisms code splicing requiring minor additions kerninstd implement installing replacement function kerninstd replaces function instrumenting entry point original code unconditionally jump code shown figure code patch needed jump code resides splicing branch instruction version function reachable version single branch springboard code replacements takes original function resides kernel nucleus springboard required required springboard resides nucleus non-nucleus springboard framework introduces run-time overhead call function replaced optimized patching function call sites directly call version function optimization applied statically identifiable call sites displacement needed reach version function range call instruction bytes sparc optimization applied calls unanalyzable destination calls function pointer call site optimizations applied addition basic framework figure additional cost optimized code replacement high dev kerninst performs expensive undoable write section call site replacing call site takes call site nucleus call site lies nucleus give large-scale replacing function kmem alloc including patching call sites takes gauge expected number call sites figure summarizes number statically identifiable calls kernel functions successfully parsed function kernel called average times standard deviation figure basic code replacement entry point instruction original function replaced unconditional non-delayed branch version function springboard needed original function springboard needed version function long jump version function instructions unconditional branch function mutex exit called times module functions parsed average calls made function module max calls made function module genunix afs afs syscall interface unix ufs filesystem ufs nfs nfs syscall client common streams module meta disk base module tcp tcp streams module procfs filesystem proc scsi disk driver rpcmod rpc syscall sockfs filesystem sockfs pci pci bus nexus driver hme feps ethernet driver siemens sab escc floppy driver serial driver uata ata at-bus attachment disk controller driver krtld rpcsec kernel rpc security module ufs log logging ufs module xfb xfb driver sep audiocs audio driver dad dad disk driver tmpfs filesystem tmpfs 
ldterm terminal line discipline afb afb driver sep scsi scsi bus utility routines tpi local transport driver specfs filesystem specfs arp arp streams module sunw ultrasparc-iii vol volume management driver doorfs doors driver udp udp streams module timod transport interface str mod kerninst kerninst driver fifofs filesystem fifo streams module keyboard figure number statically identifiable calls kernel functions functions successfully parsed included wide variance modules functions called functions module unix called average times compared average calls standard deviation calls function mutex exit called times small modules functions directly called tnf kernel probes driver power manager driver time sharing sched class devinfo devinfo driver ipdcm dialup ttcompat alt ioctl calls diaudio generic audio elfexec exec module elf shmsys system shared memory ptc tty pseudo driver control ptc tlimod ktli misc module winlock winlock driver hwc streams module hardware cursor support streams module mouse ptem pty hardware emulator simba simba pci pci bridge nexus driver seg drv segment device driver sad streams administrative driver sad namefs filesystem namefs lockstat lock statistics ptsl tty pseudo driver slave ptsl rootnex sun root nexus dada ata bus utility routines dada ata ata bus utility routines message-digest algorithm sysmsg system message redirection fanout driver memory driver workstation multiplexer driver ebus ebus nexus driver ptm master streams driver ptm pts slave stream pseudo terminal driver pts realtime scheduling class iwscn workstation redirection driver iwscn fdfs filesystem eide nexus driver conskbd console kbd multiplexer driver conskbd todmostek tod module mostek log streams log driver indirect driver tty consms mouse driver sun consms module functions parsed average calls made function module max calls made function module figure number statically identifiable calls kernel functions functions successfully parsed included wide variance modules functions called functions module unix called average times compared average calls standard deviation calls function mutex exit called times small modules functions directly called parsing version function run-time kerninstd analyzes replacement version function run-time creating control flow graph calculating live register analysis manner kernel code recognized kerninstd startup uniformity important tools built top kerninstd treat replacement function first-class kperfmon informed replacement function updates code resource display user measure replacement function undoing code replacement dynamic code replacement undone restoring patched call sites un-instrumenting jump entry original function version ordering ensures atomicity code replacement undoing takes effect kernel thread make call replacement function calls made original function kstat kernel statistics driver pckt pckt module ksyms kernel symbols driver inst sync instance binding syscall power power driver console redirection driver sysacct acct syscall clone clone pseudodriver clone intpexec exec mod interp pseudo nexus driver pseudo ipc common ipc code pipe pipe syscall connld streams-based pipes options options driver redirmod redirection module dptbl time sharing dispatch table interactive scheduling class dptbl realtime dispatch table platmod kernel-wide std dev module functions parsed average calls made function module max calls made function module figure number statically identifiable calls kernel functions functions successfully parsed included wide variance modules functions called functions module unix called average times compared average calls standard deviation calls function mutex exit called times small modules functions directly called uninstrumented original function jump uninstrumented sub-cases call made call site restored replacement function executed case call site restored original state call reach original function instrumented proceeds jump replacement function original function jump uninstrumented code replacement full effect original function jump uninstrumented original function jump uninstrumented call sites uninstrumented longer thread call replacement function directly indirectly undoing code replacement takes effect atomically thread executing replacement function code splicing concern safe free memory replacement version function springboard code replacement presently ad-hoc solution code splicing wait seconds assumption delay long thread finish executing code question section basic code replacement call sites patched removed original function lies nucleus springboard reach replacement function usual delay ensure code executing springboard removed springboard resided nucleus patched call site restored resided nucleus future work future work code splicing includes porting architectures including variable-length instructions lacking non-delayed splicing branch instructions future work code replacement primitive discussed including achieve semantics splicing run-time overhead splicing architectures variable length instructions single-instruction splicing architectures variable length instructions challenging overwrite instruction depending existing code instrumentation point unconditional jump instruction bytes overwrite instruction extra partially overwritten instruction destination branch corrupted instruction stream executed safety rules splicing augmented splice performed single branch jump instruction code patch written atomically instruction replaced requirement satisfied writing one-byte trap illegal instruction transfer control trap handler handler instrumented address offending instruction hash table undo side effects trap jump code patch port kerninst progress existence trap-based kernel tracing tools similar approach feasible splicing splicing architectures always-delayed branches single-instruction splicing difficult architectures mips branch instructions delay slot architecture delayed branch instruction splicing resulting unusual execution sequence jumping code patch instruction instrumentation point falls newly written branch instruction delay slot implicitly executed code patch reached instruction instrumentation point executed instruction originally instrumentation point relocated code patch executing ordering instructions effectively reversed instrumentation point instruction successor mutually independent reversing execution order harmless independent instrumentation point instruction independent successor successor instruction idempotent instrumentation point instruction successor code patch resulting execution sequence successor original instrumentation point instruction successor step equivalent no-op independence idempotency constraints met making single-instruction splicing always-delayed-branch architectures difficult possibility splice replacing instrumentation point instruction trap illegal instruction discussed splicing present implementation kerninstd require solution sparc architecture non-delayed unconditional branch instruction splicing code replacement facilitate splicing sections show difficult expensive splice locations mips architectures code replacement presently implemented dyninstapi paradyn user-level tools copy function extra nop instructions inserted facilitate splicing taking idea instrumentation code inlined replacement function nop instructions spliced words code replacement achieve effect splicing splice instrumentation point code replacement inline instrumentation code optimization eliminates overhead branches jumps inherent splicing worst case instrumentation point springboard code patch back instrumentation point achieve fine-grained instrumentation branch jump overheads heretofore advantage exclusive static instrumentation systems code replacement branch entry function replacement function overhead eliminated code replacement patches statically identifiable call sites directly call function improvements code replacement code replacement approximately doubles code size function presently replaced conceivable recycle original function springboard code patch space replaced safety requires determining thread presently executing 
code recycled replacement function first-class kerninstd applications function control flow graph parsed spliced replaced function kernel tools based kerninstd recognize replacement functions dev kerninst dynamically add entry kernel runtime symbol table structure replacement function recognized standard dev ksyms driver enabling function recognized system kernel debugger research needed area additional issues replacement code recognized first-class system-wide basis code replacement long-running functions unresolved issue thread middle original function code replacement function specific thread effect calls function long-running functions concern functions return executed kernel background threads paging daemon code replacement presently implemented effect conclusion research contributions chapter presented design implementation fast fine-grained code splicing completely unmodified modern commodity operating system solaris running ultrasparc run-time splicing code patches kernel safely instrument kernel pausing synchronization springboards provide general technique obtaining arbitrary reach maximum displacement single branch instruction relocating overwritten instruction code patch chapter makes contributions maintain semantics relocating overwritten instruction possibly semantically-equivalent sequence instructions relocating tail calls conditional branches code splicing additional unforeseen benefit essentially creating important instrumentation points existed ability instrument points tail call sequence exits if-taken if-not-taken case conditional branch shows instrumentation point machine code instruction satisfy instrumentation requests finally additions splicing implementation easily achieve code replacement complementary dynamic instrumentation primitive chapter kernel performance measurement dynamic instrumentation chapter presents design implementation kernel profiling tool built dynamic instrumentation tool kperfmon serves proof concept utility dynamic instrumentation important kperfmon powerful kernel profiler providing flexible extensible set performance metrics applied kernel function basic block kperfmon create wall time metric monotonically increasing software-readable counter kperfmon virtualize exclude time spent switched wall time metric instrumenting kernel context switch handlers chapter discusses design implementation performance metrics kperfmon chapter presents case study kperfmon understand optimize performance web proxy server performance measurement kperfmon combining metric code resource metric time-varying measurement elapsed cycles number data cache misses number database transactions code resource object measured metric function basic block metric resource pairing kperfmon generate instrumentation code snippet kernel location insert kperfmon instructs kerninstd splice snippets kernel instrumentation code update counter event accumulator structure kerninstd periodically samples forwarded front-end gui consumption finding bottlenecks interactive activity involving successive refinement functions basic blocks measured essential tool user decide measurements made run-time kperfmon instrumentation occurs request removed time making kernel performance profiling completely dynamic major features kperfmon commodity kperfmon measures unmodified solaris ultrasparc kernel requiring instrumentation code thread multiprocessor safe presently kperfmon implemented uniprocessor multiprocessor design issues discussed chapter dynamic overhead instrumentation incurred measured measured fine-grained code resources kernel function basic block accurate kperfmon instruments kernel directly measure performance assigning time periodic sampling program counter inclusive metrics measurements code resource accumulate events code resource call stack including time spent callees inclusive metrics shown aid automated search bottlenecks difficult measure sampling-based profiler extensible set metrics monotonically increasing software-readable counter serve event counter metric section event counter metric turn construct interval counter metric section measures number events occur execution user-specified code resource wall virtual time metrics kperfmon basic instrumentation code gathers wall time measurements thread interval event count includes events occur context switched entry exit instrumentation points wall time metrics measuring latency code block routines obtaining locks virtual time measurements optionally achieved instrumenting kernel context switch handlers exclude accumulated total events occur switched section virtual time metrics measuring processor events cpu time branch mispredicts cache stall time remainder chapter discusses design implementation kperfmon classes performance metrics event counter metrics event counter metric counter incremented occurrence event event conceptually corresponds execution point kernel code predicated logical expression event counters hardware ultrasparc registers elapsed cycles number cycles idled due i-cache misses number branch mispredictions calculated software solaris kstats software event counters dynamically created kperfmon instrumentation counting number entries desired function event counter serves performance result kperfmon foundation interval counter metrics discussed section event counters created kperfmon updated instrumentation code increments counter non-trivial aspects making instrumentation thread-safe multiprocessor-safe thread safety requires correctly incrementing counter multiple threads executing instrumentation simultaneously thread time run uniprocessor preemption occur time leads requirements kperfmon achieves thread safety locks updating counter sparc compare-and-swap instruction statistics kperfmon event counting instrumentation shown figure modifications required multiprocessors correctness processors relaxed memory consistency code sequence annotated memory barrier instruction good performance per-processor event counters maintained avoid significant cache coherency delays processors competing write access interval counter metrics overview interval counter metric accumulates number events underlying event counter metric occur thread running code resource general framework event accumulating metric shown figure page currval figure implemented event counter entry point code resource function basic block instrumentation code start accumulation inserted exit point resource instrumentation inserted stop accumulation add number events occurred start point accumulator total framework figure omits implementation details overlapping intervals conceptually thread accumulates interval count start stop interval count instrumentation measuring wall time events intervals overlap thread start stop interval wall times times thread context switch thread start stop accumulator times time units threads accumulating intervals reflected total figure page illustrates wall time accumulation presence overlapping intervals virtualization framework figure places instrumentation detect operation code size bytes scratch registers needed cost event counter increment figure cost incrementing event counter cost measured kperfmon instrument instrumentation code costs chapter mhz ultrasparc-iii running solaris exclude overhead jumping code patch executing relocated instruction event counter instrumentation occurs function entry registers free section code size cost columns describe worst case instrumentation code bracketed sparc save restore instructions context switching augmented measure virtual time events entry exit start stop instrumentation inserted atomically avoid race condition fail properly stop accumulation interval entry point instrumentation inserted thread executes continues execution past exit point instrumentation inserted interval end time incorrect kperfmon solves problem inserting stop-accumulation instrumentation stop instrumentation perform no-op unstarted accumulator poll-problem wall time accumulators mentioned measuring wall time interval counter metric thread conceptually accumulates distinct intervals sum metric grand total incorrect measurements occur thread executes exit instrumentation entry instrumentation occur blocking routines poll waits file descriptor assume instrumentation added poll entry exit points thread presently blocked poll eventually un-blocks executes exit instrumentation poll correct implementation perform no-op detecting execute entry instrumentation naive implementation mistakenly stop thread accumulation typically implementation shared accumulator structure perthread suffers problem solution per-thread accumulators leads 
extra complexity storage run-time cost section implementation wall time accumulators avoids poll problem reasonable complexity storage cost challenging feasible dealing recursion recursion handled starting interval time thread reaches code entry stopping interval time thread reaches code exit multiprocessors fast execution multiprocessors requires per-processor copies event accumulator structure avoid cache coherency overhead writing shared structure correctness requires handling migration wall time interval counter metrics section presents design implementation inclusive wall time interval counter metrics design called cumulative thread events simple efficient kperfmon design wall time metrics design limitations work multiprocessors give inaccurate results presence recursion suffers poll problem discussed limitations addressed re-design adds complexity discussed section limitations tolerable framework section preferable cumulative thread events instrumentation calculates area curve x-axis underlying event counter typically elapsed cycles y-axis number threads presently accumulating events shown figure units total thread-events thread-cycles underlying currval elapsed cycles code entry exit instrumentation identical adding entry instrumentation subtracting exit instrumentation number accumulating threads field updated rectangle added total rectangle width elapsed number events occurred update total field height number threads accumulating events time accumulator structure cumulative thread events shown figure instrumentation pseudo-code shown figure -bit word holds accumulated total intervals area curve figure word holds fields figure event interval accumulation multiple threads instrumentation code calculates area curve adding rectangles thread starts stops accumulation dashed lines start-accumulation occurs stop-accumulation occurs total event accumulator thread-events figure cumulative thread events accumulator structure accumulator occupies bit words word total accumulated intervals word sub-fields number threads presently accumulating event interval bits underlying event counter recent start stop operation bits putting numthreads lastchangevalue sub-fields single bit word updated single thread-safe compareand-swap lastchangevalue stores significant bits underlying event counter counter granularity maintained bits ghz machine bit cycle counter accumulate days worth cycles rolling thr eads curr ently elapsed events elapsed cycles accumulating vents total bits numthreads bits lastchangevalue bits units events units thread-events word word number kernel threads presently accumulating events bits underlying event counter time modification bits code updates word adjusted number threads significant bits current underlying event counter completes number threads multiplied delta underlying event counter obtain delta added total field lastchangevalue field stores significant bits event counter -bit unsigned arithmetic calculate change event counter event counter stored lastchangevalue subtraction assumes rollover occurred obtain incorrect results complete loop events occur starting stopping accumulation loop bits accumulate days worth machine cycles ghz machine -bit words updated separate compare-and-swap operations thread safety locks performance numbers start stop primitives shown figure expected similarities costs identical cumulative thread events framework desirable traits simple quick thread-safe framework wall time interval counter metrics thread-safe correctly hanfigure cumulative thread events pseudo-code start stop accumulation code identical differing calculate newnumthreads compare-and-swap limited bits ultrasparc updates phases phase word updated delta phase calculated phase word total field updated delta compare-andswap loops repeated contention multiple threads structure primitive non-blocking infinite loop compare-and-swap retried forever thread making forward progress occur phasea calculate total update accum word sub-fields values oldword timer word numthreads lastchangevalue sub-fields currval current current underlying event counter present currval-oldval lastchangevalue total oldval numthreads max oldword numthreadsif failure goto phasea fails thread updated timer word phaseb total update accum total oldtotal accum total newtotal oldtotal total cas accum total oldtotal newtotal failure goto phaseb repeat completed phase cas timer word oldword newnumthreads currval newnumthreads oldword numthreads start operation stop operation change timer word newnumthreads currval equals oldword dling overlapping accumulation intervals finally measures inclusive events automating search bottlenecks design limitations poll problem solved stop primitive checks underflow performing no-op number threads field field greater due overlapping interval accumulation thread no-op performed poll problem occurs per-thread copies accumulator structure solve problem cost significantly higher storage complexity execution costs limitation occurs presence recursion recursive call instrumented code incorrectly increment numthreads instrumentation act thread beginning accumulation overlapping interval limitation work multiprocessors assuming processor accumulator structure code fooled migration thread starts interval processor stops processor stop operation figure applied wrong accumulator re-design cumulative thread events solves problems presented section re-design significantly complex implemented virtual time interval counter metrics instrumentation accumulates virtual time events complex instrumentation code accumulates wall time events simply starting stopping accumulation code resource entry exit points accumulate wall time events virtual time events additional kernel instrumentation interval counters adapted virtual time section describes design implementation virtualized interval counting metric framework called counted virtual time events cumulative thread events counted virtual time events framework create metric underlying event counter counted virtual event instruoperation code size bytes scratch registers needed cost start accumulation stop accumulation figure cost cumulative thread events instrumentation primitives numbers measured kperfmon instrument instrumentation code keeping measured averages section page assumed sufficient scratch registers code resource exit point code resource entry point size cost starting accumulation assumes kerninstd brackets code save restore instructions free scratch registers mentation parts start stop primitives inserted code resource entry exit points instrumentation kernel context switch routines stop accumulation thread switched re-start thread resumed start stop primitives counted virtual time accumulator structure shown figure basic start stop primitives shown figure figure thread actively accumulate virtual events assuming uniprocessor numthreads field cumulative thread events accumulator needed place recursioncount field running thread accumulating events greater non-zero recursion count field number times figure counted virtual time events accumulator structure accumulator occupies bit words word total accumulated intervals word sub-fields recursion depth code resource measured bits significant bits underlying event counter accumulation started recursion count accumulation presently occurring startvalue field undefined placing recursioncount startvalue sub-fields single bit word updated single thread-safe compare-and-swap figure counted virtual time events start accumulation design closely framework figure page addition recursion count field total field read written start operation total bits recursioncount bits startvalue bits units events units thread-events word word retry oldword accum word recursioncount startvalue sub-fields oldrecursioncount oldstartvalue failure goto retry fails thread updated accum word cas accum word oldword newword newword currval oldrecursioncount change accum word newword equals oldword currval current current underlying event counter present oldstartvalue oldword startvalue oldrecursioncount oldword recursioncount running thread attempted begin accumulation start primitive increments field begins accumulation stop primitive decrements field usual proviso keeping non-negative stops accumulation changed 
recursion count field primitives work correctly recursion feature lacking cumulative thread events figure summarizes cost interval counting primitives start stop virtual time interval counter figure counted virtual time events stop accumulation stopping virtual event accumulation decrements recursioncount field adds interval accumulated total field single -bit word updated time compare-and-swap two-phase protocol phase word updated delta total field calculated phase delta update total field primitive code size bytes scratch registers needed cost virtual time event interval metric start virtual time event interval metric stop figure summary virtualized interval counting instrumentation primitives numbers include instrumentation code resource instrumentation added kernel context switch code discussed start instrumentation assumed bracketed save restore instructions due insufficient scratch registers cost included retry calculate total update accum word sub-fields values oldword accum word recursioncount startvalue sub-fields failure goto retry fails thread updated accum word cas accum word oldword newword newword oldrecursioncountoldstartvalue change accum word newword equals oldword currval current current underlying event counter present oldrecursioncount oldword recursioncount oldrecursioncount goto oldstartvalue oldword startvalue oldrecursioncount goto total currval-oldstartvalue retry update total oldrecursioncount oldtotal accum total newtotal oldtotal total failure goto retry fails thread updated accum total cas accum total oldtotal newtotal change accum total newtotal equals oldtotal virtualization general algorithm additional structures kerninst virtualizes event accumulators dynamically instrumenting kernel thread context switch handlers implementation assumes uniprocessor virtualization multiprocessors discussed section virtualization splices code kernel context switch routines switch-out stop active virtual accumulator started kernel thread presently switched switch-in restart virtual accumulator stopped recent switchout thread presently switched invariant aids implementation switch-out code presently active virtualized accumulator started exclusively running thread proof assume thread started accumulator presently running assuming uniprocessor thread runs time presently context switched switched virtualization instrumentation stopped accumulation contradiction assumption presently accumulating events thread started accumulation started accumulation thread started accumulation knowing accumulators virtualize context switch-out trivial virtualization stop presently active accumulator context switch-in instrumentation requires information accumulators stopped recent switch-out thread information implemented hash table indexed thread entries information stopped recent switch-out thread specifically per-thread information pointers virtual accumulator stopped copy recursion count field time number threads presently switched started stopped accumulator multiple hash table per-thread information pointers accumulator structure implementation combination single accumulator approach cumulative thread events per-thread accumulator copies accumulator actively running thread per-switchedout-thread information accumulators presently turned due virtualization hybrid organization compares favorably allocates per-thread copy accumulator extra complexity additional space time overhead pseudo-code context switch-out switch-in code shown figure figure context switch-out instrumentation allocates vector free list vector gather set accumulators stopped virtualization loops accumulators address global vector invoking metricspecific routine stops accumulator started code stop active accumulator specific metric underlying event counter vector holding set accumulators turned added hash table indexed thread context switch-in instrumentation code comparatively simple newly running thread index global hash table obtaining vector pointers accumulators restarted saved recursioncount fields time switch-out accumulator restarted invoking metric-specific routine depends underlying event counter finally vector accumulator addresses returned free pool hash table entry thread removed size execution cost context switchout switch-in code shown figure context switch instrumentation points virtualization requires identifying kernel context switch-out switch-in sites figure context switch-out instrumentation pseudo-code uniprocessor note synchronization instrumentation runs interrupt level context switch handlers preempted high-level interrupts ecc error traps register window overflow high interrupt level limits functions called vector stopped accumulators pre-allocated heap calling kmem alloc dangerous interrupt routine block vecofstoppedaccumulators freelist freelist pre-allocated total currval-va startvalue currval underlying event ctr accumulators stopped nextstoppedaccumptr vecofstoppedaccumulators pointer recursioncount virtual accumulators assert pil code executes high processor interrupt level nextstoppedaccumptr theaccumulatorptr nextstoppedaccumptr savedrecursioncount recursioncount nextstoppedaccumptr hash set vecofstoppedaccumulators current thread freelist free vecofstoppedaccumulators ended nextstoppedaccumulator theaccumulatorptr null place sentinel solaris kernel schedules kernel threads user-level processes kernel background tasks interrupts bound kernel thread solaris thread context switch sites depending machine state interrupt level time context switch myriad context switch points demonstrates kerninstd instrument low-level kernel routines run high priority level variants non-interrupt threads threads bound user process common case optimized variant switch zombie thread interrupt threads priority context switch routines execute low-level interrupts bound thread allowed call code block interrupt threads priority equals context switch code executes clock interrupt interrupt threads priority greater equal context switch routines execute code permitted block ecc error detection optimization kernel predicts interrupt handlers complete blocking interrupt initially bound skeletal thread execution context piggybacked figure context switch-in instrumentation pseudo-code uniprocessor context switch-out instrumentation synchronization needed code invoked high interrupt priority level prevents scheduling operation code size bytes cost context-switch virtualization code context-switch virtualization code figure cost context switch instrumentation numbers measured kerninst instrument instrumentation code times shown mhz ultrasparc-iii system running solaris vecofstoppedaccumulators hash getandremove curr thread vaptr recursioncount nextstoppedaccumptr savedrecursioncount nextstoppedaccumptr vecofstoppedaccumulators pointer vaptr nextstoppedaccumptr theaccumulatorptr accumulator restart nextstoppedaccumptr theaccumulatorptr null assert pil code executes high processor interrupt level vaptr startvalue current current underlying event counter nextstoppedaccumptr freelist free vecofstoppedaccumulators found goto needed thread vaptr pointer virtual accumulator structure restart interrupted thread process pinning interrupt block preempted skeletal thread fully initialized interrupted thread un-pinned interrupts running priority level greater scheduler block context switch code preempted rescheduled similarly interrupts preempt kperfmon virtualization code unsafe perform virtualized measurements high-level interrupt routine routine invoke fortunately high-priority interrupts block set routines small figure describes context switch points kperfmon instruments virtualization occurs context switch high-priority interrupts ecc errors instrumented kernel code interrupted high-priority interrupt kernel location switch-out switch-in point description swtch swtch respective calls resume switch-out switches non-interrupt thread common case swtch zombie call resume zombie switch-out switching just-killed thread doesn save context swtch call resume intr switch-out switches interrupt thread exit resume idle routine lowers interrupt priority level switch-in called resume resume zombie common case switching non-interrupt thread entry intr thread switch-out entry point low-priority interrupt pins interrupted thread intr thread dispatches interrupt switch-in skeletal interrupt created ready run intr thread back interrupted thread switch-out switch-out low-priority interrupt thread ran completion blocking intr thread back interrupted thread switch-in switch-in thread interrupted interrupt ran completion blocking exit resume intr switch-in un-pins thread interrupted resumes interrupt code blocks figure virtualization instrumentation points abbreviated context switch-out code spliced point register thread switched context switch-in splicing 
occurs point thread switched addition splicing occurs points interrupt priority level high prevent scheduler preempted high-level interrupts traps intr thread handles low-priority interrupts clk thread excluded table brevity handles interrupts priority level scheduler higher-level interrupts handled current thread instrumented kperfmon exclude events occur interrupt omission major problem high-priority interrupts seldom run long perform synchronization spin locks trap handlers run higher priority interrupt virtualized exceptions code directly executed thread save instruction leading register window overflow trap desirable include time virtualized totals context switch points kperfmon programmed identify function context switch function context switch code located virtualization code simple inexpensive sub-optimal cases thread switched stop accumulator restarted subsequent thread switched check optimization requires work naively implemented multiprocessor issues virtualization multiprocessor-safe alternative counted virtual time events designed design replaces cumulative thread events design section unsuitable multiprocessors central assumption previous design single thread accumulate events time assumption valid multiprocessor assumption restored per-cpu accumulators single logical accumulator represented numcpus physical accumulators start stop primitives current cpu level indirection accessing accumulator change restores invariant presently active accumulator started running thread per-cpu accumulators ensure processors actively compete write access accumulator causing undue cache coherence overhead per-cpu accumulator totals summed values read reported kperfmon single total field sum events occurring possibly overlapping time intervals multiprocessor version virtual time units thread-events events alternatively per-cpu accumulator totals reported individually allowing users gauge processor-specific bottlenecks per-cpu versions single logical accumulator virtualization framework hybrid approach accumulator cpu represent actively running thread hash table information accumulators stopped virtualization code presently switched thread hash table requires reconfiguration avoid multiprocessor cache coherence overhead presence competing write access processors straightforward solution pad hash table structures data cache block alignment ultrasparc-i data cache byte sub-blocked -byte blocks data cache -byte blocks virtualized accumulator started cpu stopped cpu thread starts accumulator migrates stops accumulator solaris migration occur thread context switched time migration previously-executed context switch-out virtualization code ensured accumulator stopped running original cpu similarly context switch-in virtualization code re-starts accumulator thread running post-migration cpu stopping virtualized accumulator cpu started important on-chip registers serving event counter elapsed cycles cache misses sync cpus naive implementation calculate interval count reading event counters cpus possibly leading spurious rollover invariant virtualization framework migration started virtual accumulator occur context switch-out instrumentation guarantees invariant thread migrates context-switched instrumentation stop active accumulators invariant ensures migrating thread leave cpu version accumulator started indefinitely problem easily solved cumulative thread events framework section invariants prevent migration middle start stop primitive migration happen middle primitive modify wrong per-cpu accumulator beginning primitive instrumentation code reads current cpu calculate address cpu-specific accumulator structure remainder primitive migration immediately calculation compare-and-swap finalized accumulator thread ignorant migrated update wrong cpu accumulator migration prevented locking thread duration primitive calling affinity set affinity clear calling splhigh temporarily set cpu interrupt level high prevent scheduling elegant solution makes primitives sensitive migration causing compare-and-swap fail failure lead entire primitive retried time running cpu full duration primitive wall time event accumulating revisited multiprocessors multiprocessor version wall time accumulators share limitations cumulative thread events section designed cumulative thread events design fooled recursion accumulating high result suffers poll problem thread mistakenly stop accumulation begun thread handle migration solution problems wall time discussed section builds virtualized timer framework previous section design odd high level basic virtualization primitives calculate wall time effort exclude events occurring context switched multiprocessor version virtualized time interval counters feasible good place begin hybrid per-cpu accumulators represent actively running threads per-thread accumulators represent switched-out threads makes wall time event accumulation multiprocessors feasible key equality guides design presented section wall time virtual time blocking time words wall time time spent actively running time spent context switched similarly wall time events virtual time events blocking time events virtual time events measured design section leaving blocking time events solve blocking time events accumulator obtained measuring events occurring accumulator stopped due virtualization specifically context switch-out active accumulator virtualization stops accumulator time interval measurement begun count events occur accumulator stopped due virtualization context switch-in virtualization re-starts accumulator turned due context switch-out thread blocking time cue stop interval measurement blocking time events measured counter virtualized accumulator information piggybacked field hash table entry shown figure solution drawbacks complexity extra storage hash table slightly expensive context switch-out switch-in code desirable reasons runtime instrumentation cost basic start stop primitives excluding context switch instrumentation slightly higher uniprocessor versions figure turn expensive primitives cumulative thread events figure additional perturbation compared virtualized accumulators bit extra code context switch-out switch-in instrumentation additional benefit design user measure class metrics blocking time complement virtual time wall time metrics final benefit design threads overlapping wall time accumulation intervals illustrated figure afflicted so-called poll problem mentioned section thread mistakenly stop accumulation behalf thread problem prevented wall time accumulator started thread stopped recursioncount field accessed thread words thread-specific copies accumulator presently active true cases case thread blocked started accumulator copy accumulator recursioncount field time switch-out presently saved hash table thread access hash table entry indexed thread making thread-specific case actively running exclusive recursioncount field accumulator started per-cpu accumulator copies running threads thread actively running started logical accumulator processor operating per-cpu version accumulator recursioncount field future work primary limitation kperfmon presently implemented instrumentation primitives work multiprocessors designs multiprocessor versions virtual time metrics section wall time metrics section important areas future work kperfmon design metrics kperfmon powerful set metrics easily extended metric virtualized resources made powerful presently code resources kernel functions basic blocks add control flow graph figure hash table entry multiprocessor-safe wall time measurements entry specific thread field context switch-in underlying event counter re-read subtracted field obtain number events occurred accumulator blocked field added accumulator total field alternatively separate total field maintained user chooses view virtual time events blocking time events separately pointer accumulator saved recursioncount restarted context switch-in specific per-cpu version underlying event counter migration occurs per-cpu version edges set resources enabling inclusive time spent basic block divided if-taken if-not-taken branches similarly call graph edges measurement time spent function invoked specific call site fall general umbrella paths basic block function granularity intraprocedural interprocedural resources extension resources hierarchy complement code resources data resources change measurements kernel lock mutex blocking 
time specific mutex object disk seek time specific file conclusion research contributions kperfmon tool dynamic instrumentation measure unmodified commodity operating system kernel instrumentation-based tool instrument unmodified kernel fine-grain kernel function basic block serve code resource turn coupled kperfmon metric sampling-based profilers measure fine-grain discussed section easily measure wall time metrics inclusive metrics metrics kperfmon extensible monotonically increasing event counter leveraged creation metric metrics accumulate wall time events virtual time events kperfmon kernel profiler virtualize wall time metric metrics kperfmon inclusive time spent callees unlike samplingbased profilers making iterative possibly automated search bottlenecks straightforward simply traverse call graph chapter dynamic kernel instrumentation kernel application tuning chapter presents case study kperfmon understand optimize performance web proxy server understanding kernel performance two-way benefit providing information tuning kernel user processes ease performance results obtained shows flexibility dynamic profiling tool full access detailed performance data describe squid web proxy server benchmark drive describe process identifying major bottlenecks description fixes resulting performance gain introduction study squid web proxy server wisconsin proxy benchmark workload drive kernel web proxies effective means reducing load web servers web clients query local proxy actual server adds security firewall caches web server contents proxy retrieves files needed server satisfy client http request cache studied performance solaris kernel running version squid web proxy server squid levels http cache memory disk incoming http requests searched squid memory cache object found squid disk cache cache desired object squid retrieves study performed kerninst ported solaris object web server study squid disk cache installed local disk running default unix file system ufs heavily loaded proxy server expect hundreds thousands simultaneous tcp connections multiplex alongside local disk activity squid create independent thread control handle request single thread multiplexes active tcp connections pending file operations non-blocking primitives version wisconsin proxy benchmark drive squid thirty synthetic client processes connect squid proxy squid turn connects synthetic web server process machines client squid server measurements discussed chapter performed squid machine client process connects squid makes http requests intervening thinking time benchmark runs stages stage requests made http objects files file requested locality stage purpose populate cache stress replacement algorithm stage client sends requests time temporal locality pattern designed lead proxy hit ratio approximately server process listens tcp port number http requests arrives parses url determine file file synthetically created server creates file size uniformly distributed time time file size understanding bottlenecks search application bottleneck squid led kernel requiring kernel profiling tool kperfmon measure performance solaris kernel running benchmark section discusses bottlenecks kperfmon helped identify measuring kernel performance yielded benefits helped understand kernel bottlenecks leading kernel optimization helped understand bottleneck caused application spends time kernel performing first-order bottleneck file opens wisconsin proxy benchmark working set size larger squid in-memory cache reasonable hypothesis squid disk bound due disk reads misses squid in-memory cache hits on-disk cache disk writes misses on-disk cache requiring file brought server obtain specific numbers time constant noise disk thrashing machine running squid led formulation hypothesis squid spends disk activity quantify profiling tool run squid determine source first-order bottleneck surprisingly turned disk reads writes quantify showed squid time spent routine storeswapoutstart called demote file squid in-memory cache on-disk cache interestingly time routine spent writing disk call open squid spending elapsed time time spent waiting select statement simply opening on-disk cache files writing explaining result requires investigating squid cache organization squid maintains file http object caching disk on-disk cache large fixed-size file collection objects cached varying sizes simplifies squid code design decision severe performance degradation squid organizes cache files three-deep hierarchy number files directory manageable hash function maps file table entry number full path file reused cached objects time general file object ejected remains disk marked invalid file reused cache object squid overwrite invalid file bottleneck open system call concern single-threaded program multiplexes file descriptors unix interface non-blocking open system call limitation contrasts read write system calls return ewouldblock block processing allowing work proceed ready file descriptors blocking opens entire squid process blocked open file blocks performance study requires understanding open slow turn requires examining operations place open system call user-level performance profilers system calls black box offer guidance understanding kernel performance tracing open bottleneck file creation dynamic nature kerninst interactively find kernel bottlenecks manner finding user-level bottlenecks function performing slowly measured determine bottleneck callees similarly profiled kerninst iterative refinement performed squid running kernel routine copen measured results rate metrics calls made concurrency applied copen shown figure figure shows file opens occurring times squid elapsed time spent routine actions performed copen examined copen calls falloc allocate entry process file descriptor table calls open perform open times routines shown figure falloc takes negligible time surprising finding squid file table allocation reported bottleneck heavy load previous study performed digital unix copen spent time open performance open examined figure copen called times sec copen clear bottleneck average kernel threads executing routine time number translates squid elapsed time squid single-threaded program figure major callees copen falloc open open accounts time spent copen negligible time spent falloc file creation diverges opening existing file create called creat flag passed open system call open called times create remaining calls open non-creating indicating hits squid on-disk cache examination latencies routines shown figure reveals time spent open consumed create file creations account squid file-opening bottleneck understanding file creation bottlenecks file creation primary bottleneck create callees examined create calls lookuppn older unix incarnations namei translate file path vnode vnode passed file system-specific creation routine results shown figure reveal file creation distinct bottlenecks path lookup lookuppn ufs file creation ufs create ufs create bottleneck ufs create bottleneck surprising ufs file creation performs local meta-data operations squid spending time time spent ufs create traced ufs itrunc invoked trunc flag passed open system call routines identical performance numbers shown figure squid elapsed time spent truncating existing files size opening determine ufs itrunc slow callees examined results shown figure ufs itrunc time spent ufs iupdat synchronously writes disk pending update file inode truncation slow inode made synfigure open spends time create concurrency curves open create overlap threads time chronously dictated unix file semantics ensure file system 
integrity case crash squid strategy overwriting existing cache files avoid meta-data updates required file deletion ineffective similar meta-data updates performed truncation lookuppn bottleneck recall figure lookuppn bottleneck extent surprising obtaining vnode path require reading directory file obtain inode disk location reading inode component path solaris optimize path lookup directory figure create main callees lookuppn ufs create lookuppn ufs create distinct bottlenecks consuming squid elapsed time figure ufs create time spent primarily ufs itrunc ufs file creation time dominated inode truncation concurrency curves ufs create ufs itrunc completely overlap lookup cache dnlc dnlc hash table indexed path component pointer cached inode hit dnlc kernel bypass disk reads directory file ufs dirlook inode ufs iget shown figure dnlc hit rate miss penalty execution ufs dirlook sufficiently high account ufs lookup bottleneck shown figure optimizations performed section discusses optimizations kernel squid address path-name lookup file truncation bottlenecks figure ufs itrunc time spent ufs iupdat file truncation slow ufs meta-data updates made synchronous ufs itrunc figure dnlc hit rate miss routine ufs dirlook invoked calls ufs lookup dnlc hit rate addressing pathname lookup bottleneck dnlc contained default entries test machine squid cache files benchmark hundreds subdirectories three-level cache hierarchy dnlc ineffective squid preponderance small files overwhelmed capacity solaris sets dnlc size based kernel variable maxusers bottleneck addressed increasing maxusers system maximum allowable rebooting dnlc size grew change effect increasing dnlc size shown figure benchmark run long warm squid disk cache minute dnlc miss rate drops correspondingly total time spent miss routine ufs dirlook drops negligible fraction squid running time ufs lookup implication lookuppn isno longer bottleneck addressing file truncation bottleneck bottleneck file truncation reduced modifying squid source code squid bottleneck ufs create prepares overwrite file truncating size bytes involves updating file inode synchronously keeping ufs semantics note truncation unnecessary data blocks added version file written specifically file size original figure ufs lookup spends time ufs dirlook low miss rate dnlc miss penalty ufs dirlook high account entire ufs lookup bottleneck ufs dirlook ufs lookup curves completely overlap dnlc lookup curve essentially checking dnlc hit miss quick size truncation expensive no-op data block freed reallocated file smaller replacing now-unused blocks end file deleted small squid totaling lines source code needed effectively address bottleneck trunc flag longer passed open system call contents file written squid code seeks end-of-file prior write removed file written fcntl call parameter freesp truncate file size present location file pointer file size smaller previous file size blocks representing now-unused end file freed file size large original file size fcntl effect optimization kperfmon re-run examine file creation performance shown figure performance greatly improved squid time spent creating disk cache files compared optimization file truncation latency optimized version squid shown figure calls ufs itrunc longer made open system call squid longer passes trunc flag opening cache files writing smarter truncation policy time squid spends updating meta-data reduced combined effects optimizations shown section increasing dnlc size reduced path lookup time figure effect increasing dnlc size ufs lookup latency twenty seconds benchmark dnlc misses account squid run time file names reused dnlc hits frequent ufs dirlook bottleneck evaporates compare figure squid run-time section avoiding unnecessary file truncating squid reduced ufs file creation time squid run-time negligible combined effects optimizations shown figure total file creation time squid run-time takes added time spent explicitly truncating file fcntl ufs freesp figure file opens squid elapsed run-time speedup figure file creation performance truncation bottleneck addressed file creation squid run time inode truncation optimization reduces figure ufs itrunc optimized squid squid longer trunc flag opening cache files truncation performed explicitly requested fcntl ufs freesp re-ran quantify squid found squid elapsed time excluding idle time select spent storeswapoutstart optimizations first-order bottleneck squid write taking squid non-idle elapsed time ideas future optimizations kernel bottlenecks identified kperfmon involve meta-data updates opening local disk file writing optimizations significantly reduced bottlenecks presented squid elapsed time spent waiting open system call complete fundamental redesign squid disk cache improve performance disk file cached http object squid huge fixed-size file disk cache managing contents file manually design bypass ufs file system synchronous meta-data update overheads sacrifice synchronous meta-data updates data loss unacceptable feature web proxy server file corruption assuming detected easily tolerated proxy server re-fetching affected file server similarly squid ufs feature synchronously updating time modification writing files measurements chapter suggest bypassing ufs managing squid disk cache manually yield major performance improvements cost significantly increasing squid code complexity conclusion figure create time file truncation dnlc optimizations applied create consumed squid run time figure number chapter shown demonstration kperfmon understand bottlenecks heavily loaded web proxy server case study shown two-way benefit kernel measurement providing information kernel application tuning bottlenecks poor dnlc performance addressed changing kernel variable bottleneck superfluous file truncating addressed changing application code shows kernel profiling application developers cases optimizations made detailed understanding kernel workings provided kperfmon information open system call high latency optimization found chapter calculating control flow graph edge counts block counts simple effective algorithm presented approximating control flow graph edge execution counts basic block execution counts edge counts provide precise profile information block counts applications on-line kernel i-cache optimization presented chapter interest tools sampling-based profilers dcpi gprof morph vtune measure edge counts directly approximation edge counts effective practice measurements solaris kernel chapter show control flow graph edge counts calculated block counts edges counts calculated edge kernel functions results show simple instrumentation measure block counts place technically difficult instrumentation measures edge counts algorithm requires function control flow graph execution count basic block graph assigns counts graph edges precisely calculated approximated algorithm based simple graph invariant sum basic block predecessor edge counts equals block edge count equals sum block successor edge counts success algorithm edge counts precisely calculated opposed approximated depends solely structure control flow graph successfully deriving edge counts contradict widely held belief block counts derived edge counts converse hold true general case proven edge counts derived block counts arbitrarily structured graphs algorithm work practice motivation edge counts run-time kernel i-cache optimization chapter edge counts guide layout basic blocks results straight-lined execution common case edge counts calculating 
function executed requires edge counting function entry basic block reached procedure call branch function discussed section avoiding measure edge counts directly defers edge splicing primitive kerninst edge splicing presently un-implemented kerninstd due jump tables jump table destination block reached branch edge instrumentation simply entry block general solution rewrite jump table data execution jump table edge jumps code patch performs desired instrumentation jumps destination block algorithm obtain edge counts simple formulas sum basic block predecessor edge counts equals block count equals sum basic block successor edge counts block count predecessor successor edge counts unknown edge count precisely calculated block count minus sum predecessor successor edge counts edge count assignment algorithm figure applied function time algorithm function control flow graph counts basic blocks set basic blocks blocks unknown predecessor successor edge count initialized include basic blocks function algorithm repeats actions set empty basic block removed set predecessor edges unknown count count calculated added set change successor edge counts remains unknown similar action performed successors block phase algorithm completes edge counts precisely derived block counts calculated phase algorithm imprecise execution counts assigned remaining edges formulas provide bound count edge knownsuccs successors blocks connected edge count precisely calculated phase unknownsuccs succs knownsuccs start invariant sum successor edge counts equals block count subtract sum successor edges sides yield figure pseudo-code deriving edge counts block counts based graph invariants sum node predecessor edge counts sum successor edge counts equals node block count phase algorithm precisely calculates edge counts phase approximates remaining edge counts initialize set basic blocks cfg remove entry set edge pred unknown exec count edge succ unknown exec count edgecount blockcount edgecount succs edgecount blockcount edgecount preds edgecount executions control flow edge block block blockcount executions basic block calculate precise edge counts preds set predecessor blocks basic block succs set successor blocks basic block edges cfg unknown count approximate remaining edge counts max blockcount edgecount knownsuccsx max blockcount edgecount knownpreds edgecount min max max knownsuccs set successors block connected edge count precisely calculated phase algorithm knownpreds set predecessors block connected edge count precisely calculated phase algorithm preds succs similarly knownpreds predecessor edges counts unknownpreds preds -knownpreds sum predecessor edge counts equals count subtracting sum predecessor edges sides yields equations give maximum bound execution count edge minimum maximum values allowed equations upper bound count edge estimate count edge assignment accurate assigning block count edge destination high alternatives policy evenly dividing maximum allowable unknown edges practice derive precise edge counts approximation seldom needed making issue unimportant give algorithm work figure pettis hansen paper control flow graph demonstrate edge measurements node measurements pettis hansen attempt calculate edge counts block counts noting assume tools resort block count edge destination poor approximation edge edge counts derived predecessor edge successor edge equal count edges assigned count unknown successor edge count block count minus count successor edge remaining unknown predecessor edge assigned block count minus count predecessor edge finally unknown successor assigned block count minus successor edge results figure results experiment determine edge counts calculated block counts results encouraging entire kernel edge counts determined block counts approximation needed edges kernel functions edge counts accurately determined block edgecount unknownsuccs blockcount edgecount knownsuccs edgecount unknownpreds blockcount edgecount knownpreds counts approximation figure edge counts derived block counts unknown count edge calculated unknown successor block unknown predecessor block repeated application rule convergence calculate edge counts augmented version figure module fns parsed edges frac individual edges counts calculated frac fns entire edge counts calculated genunix afs afs syscall interface unix ufs filesystem ufs nfs nfs syscall client common streams module meta disk base module tcp tcp streams module procfs filesystem proc scsi disk driver rpcmod rpc syscall sockfs filesystem sockfs pci pci bus nexus driver hme feps ethernet driver siemens sab escc floppy driver serial driver figure edge counts calculated block counts table ordered module total code size shows edge counts calculated block counts fourth column fraction individual edges count determined final column fraction block count block count block count block count functions edge determined row kernel-wide totals uata ata at-bus attachment disk controller driver krtld rpcsec kernel rpc security module ufs log logging ufs module xfb xfb driver sep audiocs audio driver dad dad disk driver tmpfs filesystem tmpfs ldterm terminal line discipline afb afb driver sep scsi scsi bus utility routines tpi local transport driver specfs filesystem specfs arp arp streams module sunw ultrasparc-iii vol volume management driver doorfs doors driver udp udp streams module timod transport interface str mod kerninst kerninst driver fifofs filesystem fifo streams module keyboard tnf kernel probes driver power manager driver time sharing sched class devinfo devinfo driver ipdcm dialup ttcompat alt ioctl calls diaudio generic audio elfexec exec module elf shmsys system shared memory ptc tty pseudo driver control ptc tlimod ktli misc module winlock winlock driver hwc streams module hardware cursor support streams module mouse ptem pty hardware emulator simba simba pci pci bridge nexus driver seg drv segment device driver sad streams administrative driver sad module fns parsed edges frac individual edges counts calculated frac fns entire edge counts calculated figure edge counts calculated block counts table ordered module total code size shows edge counts calculated block counts fourth column fraction individual edges count determined final column fraction functions edge determined row kernel-wide totals namefs filesystem namefs lockstat lock statistics ptsl tty pseudo driver slave ptsl rootnex sun root nexus dada ata bus utility routines dada ata ata bus utility routines message-digest algorithm sysmsg system message redirection fanout driver memory driver workstation multiplexer driver ebus ebus nexus driver ptm master streams driver ptm pts slave stream pseudo terminal driver pts realtime scheduling class iwscn workstation redirection driver iwscn fdfs filesystem eide nexus driver conskbd console kbd multiplexer driver conskbd todmostek tod module mostek log streams log driver indirect driver tty consms mouse driver sun consms kstat kernel statistics driver pckt pckt module ksyms kernel symbols driver inst sync instance binding syscall power power driver console redirection driver sysacct acct syscall clone clone pseudodriver clone intpexec exec mod interp pseudo nexus driver pseudo ipc common ipc code 
pipe pipe syscall connld streams-based pipes options options driver redirmod redirection module module fns parsed edges frac individual edges counts calculated frac fns entire edge counts calculated figure edge counts calculated block counts table ordered module total code size shows edge counts calculated block counts fourth column fraction individual edges count determined final column fraction functions edge determined row kernel-wide totals kerninstd calculates edge counts parsed kernel function approximation seconds obtaining number calls function block counts section shown edge counts accurately obtain number times function called surprisingly number calls function simply number times entry basic block executed entry block destination branch function function beginning loop structure kperfmon calculates accurate function call count subtracting execution count function entry block predecessors execution count entry basic block kernel functions control flow graphs successfully parsed functions entry block predecessor edge complicating calculation number times functions called functions blkleft copyout blkleft copyin blkleft entry block predecessor edge counts derived block counts future work vast majority kernel functions accurately derive edge execution counts block execution counts turn derived edge counts approximate intra-procedural path execution counts paper ball mataga sagiv theory results determining edge profiles accurate predictors path profiles employ previous research block counting lower perturbation knuth stevenson present algorithm finding minimum number block counters dptbl time sharing dispatch table interactive scheduling class dptbl realtime dispatch table platmod kernel-wide std dev std dev module fns parsed edges frac individual edges counts calculated frac fns entire edge counts calculated figure edge counts calculated block counts table ordered module total code size shows edge counts calculated block counts fourth column fraction individual edges count determined final column fraction functions edge determined row kernel-wide totals sufficient block execution counting ball larus show expensive determine block counts edge profiling terms minimizing total number instrumentation points tend argue edge splicing implemented kerninstd discard mechanisms chapter favor measuring edge counts directly basic block execution count measurements benefit optimization instrumentation code basic block choices scratch registers execute instrumentation code spilling register considered ball larus work demonstrated section dynamic instrumentation conditional branches frequently edge profiling expensive places splice due expense relocating overwritten instruction paper probert proofs basic block counts insufficient determine edge counts arbitrary control-flow graphs reducible graphs loops single entry point probert shows well-delimited programs control flow constructs delimiters end end source code transformation insert basic block counts sufficient derive edge counts shown set basic block counters deriving edge counts minimized viewed machine code level probert algorithm works functions control-flow graphs match well-delimited functions non-matching function require addition instrumentation dummy basic blocks edges original graph set functions edge counts precisely derived block counts isomorphic set functions probert algorithm applies holds probert work leveraged reducing number basic blocks instrumenting minimum techniques chapter usefully applied inter-procedural edge counting words obtain call graph edge counts call instructions rarely conditional call graph edge counts simply count basic block calling instruction exception occurs calls made inter-procedural branches branch conditional edge count number executions if-taken case determines call graph edge count calls destination statically determined call function pointer difficult measure call instruction number callees control flow graph edge conclusion research contributions algorithm presented determining edge counts block counts applied solaris kernel results show edges kernel precisely determined kernel functions edges determined positive results meant imply edge splicing edge counts calculated means calculating edge counts independent mechanism measure block counts work shown chapter beneficial tools directly measure edge counts sampling-based profilers chapter dynamic kernel optimization evolving kernels chapter presents mechanisms turning unmodified commodity kernel evolving evolving system code dynamically adapt run-time environment include limited dynamic optimizations security patches bug fixes ideal evolving system step development cycle performed on-line proof concept evolving kernel algorithm implemented kperfmon algorithm dynamic kernel version pettis hansen code positioning i-cache optimizations contributions implementation general-purpose infrastructure dynamic kernel optimization evidence unmodified commodity kernel made evolving on-line kernel version optimization initial case study dynamic code positioning reduced execution time kernel tcp read-side routine tcp rput data running web mirroring benchmark evolving kernels run-time kernel code positioning performance tuning debugging performed cycle steps steps performance measurement bug finding place run-time program modifications typically installed off-line operating system kernel installing off-line requires reboot prohibitive address problem framework evolving kernels designed implemented framework kernel dynamically change code adapt run-time environment framework applies equally evolving user-level code current implementation kerninst evolving kernel algorithm driven policy make mechanisms measurement data gathered identifies problem bug performance bottleneck kperfmon step change code kernel code modified solve problem mechanism depends evolving algorithm bug fixing programmer typically manually source code performance bottlenecks solved automated transformations provided feedback-directed compiler kerninstd implement specific policies accepts installs externally generated code keeping kerninstd policy providing mechanisms inserting code running kernel allowing code generated source chapter describes specific mechanism dynamic code positioning solaris kernel install code step evolving algorithm installs modified code running system kerninstd code replacement primitive section purpose source change code entire function dynamically evolving algorithm kernel user-level program general dynamic feedback chooses distinct policies run-time dynamic feedback system hard-codes components logic driving adaptive algorithm measurement code policies logic switching policies run-time compiled system priori evolving system hard-wire components demonstration mechanisms support evolving kernel implemented run-time prototype i-cache optimizations due pettis hansen procedure splitting called outlining scout optimization moves seldomexecuted cold basic blocks hot reduce i-cache pollution rarely executed code code prevalent kernel due extensive error checking basic block positioning function blocks reordered facilitate straight-lined execution common case advantages include increasing code executed conditional branches decreasing i-cache internal fragmentation due un-executed code shares line common code reduction unconditional branches pettis hansen work block positioning yielded greatest benefit procedure positioning optimization places code functions exhibit temporal locality adjacent memory reduce chances i-cache conflict misses optimizations collectively called code positioning pettis hansen implemented feedback-directed customized compiler user code applies optimizations off-line entire program contrast implementation performed kernel code run-time selected set functions optimized entire kernel code positioning performed steps function optimize chosen step requiring user involvement kperfmon determines i-cache bottleneck function block counts gathered function descendants calls frequently counts determination made functions optimize chosen function subset descendants section kerninstd parses relocatable representation functions 
section optimized re-ordering chosen installed running kernel section interestingly optimized code installed entire code positioning optimization repeated optimizing optimized code reasons discussed section kernel code positioning measurement kernel code positioning optimization starts measurement phase user specifies function evaluated optimization measurement step section determines i-cache bottleneck present code positioning performed function callees affects i-cache performance code positioning performed user-specified function call graph descendants collective set functions called function group user-specified function group root function measurement step section collects block execution counts root function subset call graph descendants intuitive basis function group gain control i-cache behavior root function executing group entered call root function control stay group root function returns knowledge flow control leveraged improve i-cache performance time i-cache bottleneck step measurement checks code positioning needed kperfmon applies metric i-cache vstall time vtime group root function yield fraction function virtual time cpu stalled due i-cache miss denominator virtual time inclusive virtualized interval count metric section underlying event counter on-chip elapsed cycle counter numerator similar underlying event counter on-chip i-cache stall cycle counter i-cache miss context switch i-cache miss cycles included function virtual time ratio threshold arbitrarily set default changed user algorithm continues assumption i-cache performance benefit code positioning ultrasparc processor modern processors decouples instruction fetching instruction execution executing instructions instruction buffer filled prefetching i-cache decoupling tolerate i-cache miss time executing instructions instruction buffer ultrasparc performance register i-cache stall cycles measures number cycles cpu spends idling due empty instruction buffer i-cache miss miss handling latency fully tolerated kperfmon interval measurements number virtualized i-cache stall cycles number virtualized cycles inclusive measurements time root function spends descendant functions i-cache misses occur times root function call stack included measurements inclusion desirable takes account descendants effect root function i-cache behavior collecting block execution counts functions phase measurement performs breadth-first traversal call graph collecting basic block execution counts function called root function stack traversal begins instrumenting root function collect basic block execution counts user-defined delay benchmark run default seconds instrumentation removed block counts examined blocks executed statically identifiable callee functions block counts measured pruning applied call graph traversal cases function block execution counts collected re-measured function called basic block execution count measured indirect function calls function pointer call graph function reached calls block counts measured functions chance included optimized group measuring block execution counts called root function block execution count instrumentation include executions root function call stack extent descendant function contributes root function i-cache behavior descendant called root function call stack kernel functions root function block executions case counted selective block counting achieved performing code positioning re-optimizing optimized code time group generated block counts high code replacement performed solely root function non-root group functions invoked optimized root function call stack technique ensures block execution counts re-optimization include executions root function call stack desired collecting block counts single pass re-optimization require predicating block counting instrumentation code test code called directly indirectly root function paradyn constraint predicates user-level instrumentation keeping instrumentation increments counter root function entered decrements counter root function exits counter acts flag tested block counting instrumentation counter non-zero root function call stack extra run-time cost thread-safety requires per-thread flags extra complexity obtaining relocatable representation group code measurement phase optimization kerninstd parses group functions relocatable representation representation optimized version function re-emitted arbitrary basic block ordering point interleaving blocks functions required procedure splitting general basic blocks reordered maintaining semantics adjusting branch displacements adding unconditional branches rewriting jump tables kerninstd obtains relocatable representation function parsing machine code control flow graph basic blocks kerninstd startup source code required step difference stored basic block relocatable basic block sequence code objects categories code objects execute pc-independent sequence non-control-flow instructions simple case represent control transfer cases code object represented location-independent manner basic block re-emitted kernel memory equivalent semantics achieve code object control transfer information avoids keeping absolute addresses intra-procedural conditional branch code object condition test delay slot instruction address if-taken if-not-taken basic blocks inter-procedural branch code objects store if-taken function block procedure call code object stores callee address callee ends part optimized group address changed code objects jump instructions implement jump tables switch statement complex store list basic block ids representing individual destinations function emitted differing ordering jump table data altered appropriately jump table object block offset instructions set register fixed address jump table instructions backpatched version function jump table data code objects significant kerninstd infrastructure additions needed parsing code objects structural information calculated matter control flow graph parsing section simplest code object represents sequence pc-independent instructions alter control flow adds loads stores control flow information stored code object ends basic block occurs basic block falls pc-independent code object stores basic block fall-through block general code object stores fall-through block start function succeeding function stored basic block code object emitted location extra code emitted jump destination function case succeeding function longer resides immediately basic block exception kerninstd parse code objects function parse control flow graph startup exception non-loading jump table occurs kernel functions section case jump semantics amenable destination block reordering jump destination non-loaded register offset jump instruction kind code object implemented future emitting traditional jump table sequence matches original semantics traditional jump table level indirection account reordering destination blocks function code objects successfully parsed excluded optimized group calls function group directed original version function code positioning choosing block ordering steps choosing ordering basic blocks optimized group set functions include optimized group determined procedure splitting applied function segregating group-wide hot blocks cold basic block ordering applied distinct hot cold sections function steps determine ordering basic blocks group emitted contiguously virtual memory implicitly performing procedure placement sample group layout shown figure functions include group functions basic block execution counts measured optimized group include hot block hot basic block measured execution frequency root function call stack greater frequency root function called threshold user-adjustable technique presented section accurately determine root function called procedure splitting procedure splitting code positioning optimizations applied function group chunk contiguous layout basic blocks hot basic blocks segregated chunk function cold basic blocks test hot block section exception function entry block hot chunk beginning chunk simplicity pettis hansen block executed hot kperfmon mimic behavior setting 
user-defined hot block threshold execution count considered cold optimization hot cold blocks single function segregated group-wide hot blocks segregated group-wide cold blocks shown figure words procedure splitting applied group-wide basis block positioning block positioning edge execution counts choose layout basic blocks optimized execute straight-line code common case kperfmon applies block positioning figure sample layout optimized function group function group consists root function ufs create descendants dnlc lookup ufs lockfs begin ufs lockfs end chunks shown scale cold chunks typically larger hot code group call functions group hot basic blocks ufs create ordered block positioning hot basic blocks dnlc lookup ordered block positioning hot basic blocks ufs lockfs begin ordered block positioning hot basic blocks ufs lockfs end ordered block positioning cold basic blocks ufs create ordered block positioning cold basic blocks dnlc lookup ordered block positioning cold basic blocks ufs lockfs begin ordered block positioning cold basic blocks ufs lockfs end ordered block positioning jump table data ufs create dnlc lookup ufs lockfs begin ufs lockfs end hot subset basic blocks ordering function hot blocks chunk block positioning applied function cold blocks chunk unimportant assuming cold blocks seldom executed remainder section discusses positioning hot basic blocks algorithm block positioning variant pettis hansen function control flow graph set hot basic blocks block execution counts edge execution counts derived algorithm chapter hot blocks chain sequence blocks emitted straight-lined code initially block chain graph edges visited ordered execution frequency highest edge connects block tail block chain block head chain chains merged process repeats edges traversed motivation chains strategy place frequently successor block immediately block branch chains eliminate unconditional branches conditional branch placing likeliest successors immediately branch fall-through case commonly executed path reversing condition tested branch instruction general number basic blocks instructions chain expected distance branches assuming edge counts accurate approximation path counts higher number instructions branches i-cache utilization lower mispredicted branch penalty chain hot blocks decision made respective ordering control flow graph edges connecting blocks contained chains inter-chain edges guide relative chain ordering intuitively inter-chain edge connects basic blocks laid contiguously higher-weighted edge led choice successor block edge led predecessor choice algorithm chain placements starts placing chain function entry block chooses chain based frequently executed inter-chain edge essentially weighted depth-first search chain graph pettis hansen add extra layer logic step attempting order chains inter-chain edges forward branches decision matches assumption made early hp-risc processors forward branches predicted modern processors dynamically update prediction logic hardware implement step emitting installing optimized code function segregated basic blocks hot cold chunks procedure splitting chosen ordering basic blocks chunks block positioning optimized group code generated installed kernel functions analyzed kernel function code generation emitting instrumentation code code patch emitting functions outlined group relocatable form group memory location presently unknown relocatable element inter-chunk branch displacement unknown distance chunks defined call instructions non-group functions address callee instruction patched proper pc-relative offset calls group functions callee callee address presently unknown jump table data relocatable element offset jump table section entries depend displacement jump instruction destination basic block represented relocatable code difference labels branch instructions emitted advantage block positioning unconditional branch destination block resides immediately block branch branch optimized leaving delay slot instruction unconditional inter-procedural branch requires extra attention destination function lies group re-emitted single branch instruction longer branch instruction displacement sufficient emitted long jump sequence constant address emitting long jumps code patches section kerninstd live register analysis helps identifying scratch register conditional branch emitted branching label represents beginning if-taken block unconditional branch delay slot emitted reach fall-through block fall-through block resides branch unconditional branch optimized yielding code sequence possibly updated offset reach if-taken block unchanged challenging case intra-procedural conditional branches occurs due code positioning if-taken block resides immediately block branch instruction case condition tested branch reversed destination branch set fall-through block branch predict bit set false conditional branch delay slot instruction executed branch depends annul bit reversal condition test means delay slot instruction executed branch setting sparc branch instructions case delay slot filled nop instruction delay slot instruction emitted immediately nop makes immediately precede fall-through basic block achieving desired effect inter-procedural conditional branches complex relocatable element emit destination function lies optimized group kperfmon assumes reached branch instruction conditional branch label representing callee emitted branch code emitted reach fall-through block intraprocedural conditional branches cases fall-through block intra-procedural resides immediately block branch extra code emitted fall-through block intra-procedural moved unconditional branch delay slot label representing block emitted final case fall-through block resides function case occurring times optimized assembly code section jump function emitted unconditional branch instruction function resides group guaranteed nearby long jump sequence installing optimized group relocatable structures emitted kerninstd request download code specific chunk ordering shown figure contiguous area kernel nucleus memory time kerninstd resolve inter-chunk branches call instructions jump table data relocatable elements linker contiguous group layout consequences implicitly performs procedure placement ensures displacement provided classes sparc branch instructions transfer control chunks pettis hansen method emitting branches hot cold basic blocks differs kerninst system branch redirected nearby stub performs long jump stubs infrequently executed transfers hot cold blocks seldom occur increase total hot code size branch hot cold block function stub end function hot blocks layout ensures hot blocks multiple functions contiguously laid minimal i-cache footprint stubs effectively small cold basic blocks reside hot chunks parsing group functions group installation kerninstd analyzes group functions kernel functions analyzed kerninstd startup control flow graphs constructed register analysis performed call graph updated first-class treatment runtime-generated code functions instrumented speedup achieved optimization measured re-optimized requirement mentioned section procedure splitting consequent interleaving functions optimized group required improving kerninstd control flow graph parsing algorithm function disjoint chunks chunk bounds provided branches properly recognized intra-procedural inter-procedural basic blocks fall function identified fortunately easy pass chunk bounds group function parsing code information immediately procedure splitting phase section group parsed functions kperfmon code resource hierarchy group functions assigned dummy module groupx unique group identifier module function colon-separated concatenation original function module function names group function function tcp rput data tcp module assigned function tcp tcp rput data concatenation avoids chance conflict group functions kernel functions long reside modules kerninstd 
placing module unique names required group functions kernel code positioning case study tcp running ftp concrete demonstration efficacy run-time kernel code positioning section presents initial results optimizing i-cache performance web retrieval benchmark study performance tcp rput data callees major tcp function processes incoming network data tcp rput data called thousands times benchmark poor i-cache performance tcp rput data execution time due delays caused i-cache misses prototype implementation code positioning percentage reduced optimization presently limited inability include group routines called function pointers code positioning reduces time invocation tcp rput data decrease execution time benchmark gnu wget tool repeatedly fetch paradyn research papers web page files linked files fetched totaling data largely comprised postscript compressed postscript pdf files benchmark contained ten simultaneous connections running wget program benchmark spends large amount time tcp code read-side tcp connection stressed routine tcp rput data processes data received ethernet connection recognized packet chose perform code positioning tcp rput data size bytes code basic blocks suggests room i-cache improvement function performance tcp rput data code positioning benchmark completes seconds code positioning applied investigate time spent kperfmon measure performance invocation tcp rput data concentrated optimizing time spent invocation tcp rput data identify performance improvement scale execution frequency tcp rput data execution frequency function processor network speed network load benchmark determine tcp rput data benefit code positioning measured amount inclusive virtual execution time tcp rput data spends i-cache misses result surprisingly high invocation tcp rput data takes sis idled waiting i-cache misses words tcp rput data spends execution time i-cache miss processing basic block execution counts tcp rput data descendants gathered section give estimate basic blocks executed benchmark running measured execution counts approximation code reached indirect function call measured measurement includes executions basic block regard group root function call stack approximate block counts estimate i-cache layout subset blocks hot based kperfmon default interpretation hot blocks executed frequently tcp rput data called result shown figure tcp rput data called frequently important function executes i-cache conclusions i-cache performance drawn figure greater -way set associativity i-cache helped performance hot subset tcp rput data descendants execute i-cache conflict misses i-cache fully associative small effectively run benchmark bottom figure estimates i-cache blocks needed hold hot basic blocks tcp rput data descendants half total i-cache size code ethernet processing code invokes tcp rput data executed thousands times total set hot basic blocks exceeds capacity i-cache performance tcp rput data code positioning code positioning performed improve inclusive i-cache performance tcp rput data figure presents i-cache layout optimized code estimated data figure i-cache conflicts group hot basic blocks fit comfortably confines direct-mapped i-cache total cache blocks i-cache size figure i-cache layout hot blocks tcp rput data descendants pre-optimization cell represents -byte i-cache block number cell hot basic blocks distinct i-cache tags fall block figure shows cache blocks totalling ultrasparc i-cache -way set associative addresses map block figure causing conflict miss cells highlighted addresses mapping i-cache block indicating conflict total cache blocks i-cache size figure i-cache layout optimized tcp rput data group i-cache conflicts hot basic blocks compare figure figure shows functions optimized group relative sizes hot cold chunks fourth column figure shows chains needed cover hot chunk ideal indicating likelihood hot code covered single path contiguously laid memory code positioning reduced benchmark end-to-end run-time seconds seconds explain speedup kperfmon measure performance improvement invocation tcp rput data code positioning reduced i-cache stall time invocation tcp rput data branch mispredict stall time virtual execution time addition ipc instructions cycle increased preand post-optimization numbers shown figure function jump table data hot chunk size bytes number chains hot chunk cold chunk size bytes group tcp tcp rput data group unix mutex enter group unix putnext group unix lock set spl spin group genunix canputnext group genunix strwakeq group genunix isuioq group timer group cksum group tcp tcp ack group genunix pollwakeup group genunix timeout group genunix div group unix ocsum group genunix allocb group unix mutex tryenter group genunix signal group genunix pollnotify group genunix timeout common group genunix kmem cache alloc group unix disp lock enter group unix disp lock exit totals figure size optimized functions tcp rput data group group version tcp rput data hot subset statically identifiable call graph descendants code positioning applied figure shows effects procedure splitting hot chunks moved cold chunks fourth column number chains hot chunk chain covering entire hot chunk ideal indicating likelihood single hot path laid contiguously covers function hot blocks analysis code positioning limitations code positioning performs indirect function calls hot basic blocks group section analyzes limitations indirect calls optimization tcp rput data system streams code general present measurements frequency indirect function calls kernel give quantitative idea present inability optimize indirect function calls constrains code positioning discuss unique technical limitation prevents dynamic optimization solaris function mutex exit system streams code indirect calls effectively limit presently optimized single streams module tcp ethernet measured hot code tcp rput data descendants frequently-executed indirect function calls calls made putnext stub routine forwards data upstream queue indirectly calling module stream put procedure call made tcp completed data processing verifying check sums stripping tcp header data block ready forward processed data upstream callees reached hot indirect function calls optimized miss opportunity include remaining upstream processing code group end system stream tcp data processing function root optimized group missed opportunity include downstream data processing code performed ethernet protocol processing give quantitative indication inability optimize indirect calls limits code positioning figure number indirect calls made kernel module figure shows direct calls direct inter-procedural branches greatly outnumber indirect calls modules make indirect calls indirect calls exist unix genunix modules utility routines invoked kernel large group indirect function call figure shows tcp makes indirect function calls unix module putnext funcmeasurement original optimized change total virtual execution time invocation i-cache stall time invocation branch mispredict stall time invocation ipc instructions cycle figure measured performance improvements tcp rput data code positioning performance tcp rput data improved due fewer i-cache stalls fewer branch mispredict stalls tion performs indirect call pulled group module functions parsed average direct calls inter-procedural branches function module average indirect calls made 
function module genunix afs afs syscall interface unix ufs filesystem ufs nfs nfs syscall client common streams module meta disk base module tcp tcp streams module procfs filesystem proc scsi disk driver rpcmod rpc syscall sockfs filesystem sockfs pci pci bus nexus driver hme feps ethernet driver siemens sab escc floppy driver serial driver uata ata at-bus attachment disk controller driver krtld rpcsec kernel rpc security module ufs log logging ufs module xfb xfb driver sep audiocs audio driver dad dad disk driver tmpfs filesystem tmpfs ldterm terminal line discipline afb afb driver sep scsi scsi bus utility routines tpi local transport driver specfs filesystem specfs arp arp streams module sunw ultrasparc-iii vol volume management driver doorfs doors driver udp udp streams module timod transport interface str mod kerninst kerninst driver fifofs filesystem fifo streams module keyboard tnf kernel probes driver power manager driver time sharing sched class figure average number direct indirect calls made kernel functions devinfo devinfo driver ipdcm dialup ttcompat alt ioctl calls diaudio generic audio elfexec exec module elf shmsys system shared memory ptc tty pseudo driver control ptc tlimod ktli misc module winlock winlock driver hwc streams module hardware cursor support streams module mouse ptem pty hardware emulator simba simba pci pci bridge nexus driver seg drv segment device driver sad streams administrative driver sad namefs filesystem namefs lockstat lock statistics ptsl tty pseudo driver slave ptsl rootnex sun root nexus dada ata bus utility routines dada ata ata bus utility routines message-digest algorithm sysmsg system message redirection fanout driver memory driver workstation multiplexer driver ebus ebus nexus driver ptm master streams driver ptm pts slave stream pseudo terminal driver pts realtime scheduling class iwscn workstation redirection driver iwscn fdfs filesystem eide nexus driver conskbd console kbd multiplexer driver conskbd todmostek tod module mostek log streams log driver indirect driver tty consms mouse driver sun consms kstat kernel statistics driver pckt pckt module ksyms kernel symbols driver inst sync instance binding syscall power power driver console redirection driver module functions parsed average direct calls inter-procedural branches function module average indirect calls made function module figure average number direct indirect calls made kernel functions future work future work improve effectiveness runtime kernel code positioning includes handling function pointers automated selection optimized group root function block ordering procedure boundaries additional inline expansions calls function pointers included optimized group recognized call graph traversal limit effectiveness code positioning optimization mentioned section calls occur times kernel employ instrumentation technique similar paradyn dynamically update contents call graph indirect calls made indirect callees measured found hot deserve inclusion group ensuring optimized callees invoked requires informing indirect call instruction callee location desired effect achieved emitting instructions immediately indirect call instructions change register callee address address group version callee previous register original location callee test needed callees indirect call instruction candidate future work remove user involvement code positioning step choosing group root function allowing steps performed automatically paradyn performance consultant shown bottlenecks automatically located non-threaded user programs call graph traversal sysacct acct syscall clone clone pseudodriver clone intpexec exec mod interp pseudo nexus driver pseudo ipc common ipc code pipe pipe syscall connld streams-based pipes options options driver redirmod redirection module dptbl time sharing dispatch table interactive scheduling class dptbl realtime dispatch table platmod kernel-wide module functions parsed average direct calls inter-procedural branches function module average indirect calls made function module figure average number direct indirect calls made kernel functions develop multi-thread aware performance consultant adapt kperfmon underlying measurement concepts metrics resources completely automating optimization evolving kernel background kperfmon periodically finds attempts optimize i-cache bottlenecks explicitly stated pettis hansen paper basic block ordering edge counts approximation path counts choosing chains end kperfmon collect path profiles group functions emitting hot sections cold sections relative placement functions group arbitrary future work situation improved performing basic block positioning procedure call bounds allowing chains basic blocks functions benefit execution longer sequences straight-lined code common case change necessarily blur bounds group functions make impossible parse control flow graphs major complexity functions code spread chunks presently supported jump table data hot basic blocks cold basic blocks note implementation increase optimized group size optimization expand hot paths duplicating basic block reside multiple hot paths path expansion increase length straight-lined code execution pettis hansen essentially order code hot path edge counts approximation path counts kperfmon path extend function call boundary removing limitation enables inter-procedural paths duplicating hot basic blocks effect inlining hot portions callees place optimized paths group optimization performed dynamo user-level run-time optimization system found path expansion generally beneficial backfire occasions due code explosion code size exceeds size i-cache dynamo runs hp-pa processor luxury unusually large dedicated i-cache remains processor tolerant code explosion ultrasparc-i processors i-cache non-root group functions invoked root function call stack invariants hold enable improved optimizations variable constant allowing constant propagation dead code elimination optimizations include inlining specialization path expansion super-blocks optimizations presently unimplemented demonstrating general-purpose back-end machine code optimizer optimizations typically performed compilers intermediate code assemblers full suite optimizations implemented dynamo shows effort optimizations achieved operating directly machine code conclusion research contributions chapter introduced notion evolving kernels change code response runtime circumstance proof concept implemented kind evolving kernel algorithm run-time version pettis hansen code positioning optimizations implementation code positioning on-line kernel version optimization adaptive algorithms tunable variables built kernel source code adaptive mutex locks solaris implementation on-line evolving algorithm kernel implementation evidence unmodified commodity operating system kernel made evolving limit research evolving systems custom kernels chapter conclusion run-time changing kernel code including performance profiling kernel debugging tracing testing code coverage inserting security auditing checks runtime dynamic optimizations process-specific resource management extensibility transparent data modification adapting security attacks thesis investigated mechanisms finegrained dynamic kernel instrumentation allowing code commodity operating system change runtime shown application performance profiling dynamic optimizations chapter summarizes research contributions dissertation discusses areas future work summary research contributions designed implemented technology fine-grained dynamic instrumentation commodity operating system kernel investigated applications kernel performance measurement evolving kernels primary question raised line research fine-grained dynamic instrumentation completely unmodified alreadyrunning modern commodity operating system kernel answered affirmative technical challenges overcome 
serve contributions bootstrapping attach instrument running kernel structural analysis kernel control flow graphs call graph live register analysis information calculated kernel source code control flow graphs important identify allowable instrumentation points understand complex instruction sequences tail calls live register usage instrumentation code avoid spilling registers stack hazard-free splicing single-instruction splicing avoids race condition thread executing instrumentation point kernel paused check condition avoid detect hazard reach problem single-instruction splicing difficult single branch jump instruction reach code patch solutions designed springboards in-nucleus code patch allocation instruction relocation instructions trivially relocated code patch control transfer instructions delay slots instructions pc-dependent tail calls trivial-to-relocate instructions reside delay slot relocation mechanism designed intractable scenario delay slot instructions destination control flow instruction unexpected result important splice finer granularity instruction level cases conditional branches if-taken fall-through points tail calls point logically call returned caller returned kperfmon demonstrates utility fine-grained dynamic kernel instrumentation importantly powerful performance tool major research contributions kperfmon measure kperfmon measure kernel function basic block dynamic unlike static instrumentation system dynamic instrumentation user instrument interest interest extensible metrics kperfmon create interval counter metrics monotonically increasing event counter classes metrics wall time metrics inclusive metrics difficult achieve sampling-based profilers virtualization wall time metric virtualized dynamic instrumentation kernel context switch code virtual time metrics easy achieve samplingbased profiler combined inclusive property difficult achieve instrumentation final component dissertation framework evolving kernels evolving kernel performs measurements identify problem generates improved code insert kernel installs code running kernel repeats process step well-suited kperfmon step performed code replacement instrumentation primitive complements code splicing contributions made area evolving kernels general framework dynamically changing commodity kernel code code replacement kernel function implementation changed run-time prototype dynamic kernel optimizer implementation code positioning run-time optimization unmodified modern commodity operating system kernel leverage built-in kernel tuning facilities unmodified commodity kernel made evolving research runtime kernel code modification limited custom kernels modified versions commodity kernels future work dynamic kernel instrumentation splicing non-nucleus instrumentation point presently guarantee code patch allocated nearby instrumentation rely outside-of-nucleus springboard space scarce unlike nucleus modules allocated close reach init fini springboard space guarantee applies outside-of-nucleus modules solution resides directed virtual memory allocation allocating kernel virtual memory pages kernel internal structures care pick page reach single branch instructions code removal unsafe possibly freeing code patches springboards kernel thread executing issue potential solution discussed section kerninst port architecture show fine-grained splicing unmodified kernel made ubiquitous creating control flow graphs performing live register analysis difficult variable-length instruction architectures risc major challenge achieving single-instruction splicing variable-length instructions discussed section convenient accept instrumentation code directly elf relocatable files kerninstd bracket instrumentation code sparc save restore instructions clients generate versions instrumentation code scratch registers determined live register analysis assuming code bracketed save restore form instrumentation code virtual registers assigned actual registers kerninstd elf standard format kernel performance profiling kperfmon instrumentation code requires numerous run multiprocessor detailed sections fortunately straightforward implement fruitful area future work combine kernel instrumentation features kerninst vic zandy completed prototype implementation kerninstd structural analysis steps linux user-level instrumentation features paradyn allowing bottleneck searches continue system calls paradyn performance consultant automatically searches bottlenecks seamless transition user-level kernel dynamic instrumentation immediately logical extension performance consultant kernel code kperfmon powerful high-level metrics number tcp re-transmissions number ethernet collisions elapsed time spent performing disk seeks average number threads blocked mutex lock measurements predicated caller identify allowing queries threads presently blocked mutex lock running procedure generally predicates extended arbitrary desired chains basic blocks provide kernel path profiling discussed section extend kperfmon resource hierarchy include data objects specific mutex objects files tcp connections ports physical disks extension provide end users higher-level view performance data easier interpret kernel tools access symbols dev ksyms benefit kerninstd updated kernel internal information code replacement change replacement code recognized first-class applications kerninstd obtain structural analysis information dynamic kernel optimization evolving kernels implementation code positioning optimization kerninst time-consuming leverage existing tool-kit provided number runtime kernel optimizations operating directly binary code avoid re-implementing optimizations implemented compilers unanswered questions evolving kernel framework traditional compiler optimizations feasible runtime access kernel source code finally vision kerninst enable fully evolving systems operations kernel compilation installation linking debugging applying patches place runtime remains feasible practical questions raised system easily debugged final thoughts dissertation make key points fine-grained dynamic kernel instrumentation applications fine-grained dynamic instrumentation completely unmodified alreadyrunning commodity operating system kernel research performed runtime production commodity kernel important show feasibility kernel code modification hope thesis research tip iceberg eventually culminates fully evolving kernels operating system off-line performance measurement apply patches debug making major developmental nature operating system ideally off-line momentarily paused running mission-critical server software ideal day made reality aho sethi ullman compilers principles techniques tools addisonwesley reading almeida cao wisconsin proxy benchmark http wisc cao wpb html anderson berc dean ghemawat henzinger leung sites vandervoorde waldspurger weihl continuous profiling cycles acm symposium operating system principles sosp saint-malo france october auslander philipose chambers eggers bershad fast effective dynamic compilation acm sigplan conference programming language design implementation pldi philadelphia bala duesterwald banerjia dynamo transparent dynamic optimization system acm sigplan conference programming language design implementation pldi vancouver june ball larus optimally profiling tracing programs acm transactions programming languages systems july ball mataga sagiv edge profiling versus path profiling showdown annual acm symposium principles programming languages popl san diego january banga mogul scalable kernel performance internet servers realistic loads usenix annual technical conference orleans june barnes chaiken gillies feedback-directed data cache optimizations acm workshop feedback-directed optimization fdo haifa israel november bershad chambers eggers maeda mcnamee pardyak savage sirer spin extensible microkernel application-specific operating system services acm sigops european workshop dagstuhl castle germany september bershad savage pardyak sirer fiucynski becker chambers eggers extensibility safety performance spin operating system acm symposium operating systems principles sosp copper mountain december bishop profile unix patching software practice experience october buck hollingsworth api runtime code patching http umd projects dyninstapi cain miller wylie callgraph-based search strategy automated performance diagnosis european conference parallel computing euro-par munich germany august casmira hunter kaeli tracing characterization windows nt-based system workloads compaq digital technical journal january http digital dtjt index html chen lerner chaiken gillies mojo dynamic optimization 
system acm workshop feedback-directed dynamic optimization fddo monterey california december chow feedback-directed selection characterization compiler optimizations acm workshop feedback-directed optimization fdo haifa israel november cockroft pettit sun performance tuning java internet sun microsystems press prentice-hall mountain view cohn lowney feedback directed optimization compaq compilation tools alpha acm workshop feedback-directed optimization fdo haifa israel november cox fowler adaptive cache coherency detecting migratory shared data international symposium computer architecture san diego cheriton duda caching model operating system kernel functionality usenix symposium operating system design implementation osdi monterey november compaq corporation dcpi profileme performance tuning alpha presentation compaq nov http tru unix compaq dcpi documentation tutoria ppt cowan audrey krasic walpole fast concurrent dynamic linking adaptive operating system international conference configurable distributed systems iccds annapolis cowan black krasic walpole consel volanschi specialization classes object framework specialization international workshop objectorientation operating systems iwooos seattle october dean hicks waldspurger weihl chrysos profileme hardware support instruction-level profiling out-of-order processors annual ieee acm international symposium microarchitecture microresearch park triangle december deaver gorton rubin wiggins redstone on-line program specializer hot chips stanford august presentation ftp hotchips pub hotc pdf deaver pdf deutsch lampson ddt time sharing debugging system manual document rev california berkeley deutsch grant flexible measurement tool software systems proceedings information processing ifip ljubljana yugoslavia deutsch personal e-mail communication february digital equipment corporation ddt dynamic debugging technique technical report dec- uddta-a-d maynard digital equipment corporation alpha microprocessor hardware manual maynard diniz rinard dynamic feedback effective technique adaptive computing acm sigplan conference programming language design implementation pldi las vegas june engler vcode retargetable extensible fast dynamic code generation system acm sigplan conference programming language design implementation pldi philadelphia engler kaashoek dpf fast flexible message demultiplexing dynamic code generation acm applications technologies architectures protocols computer communication sigcomm stanford august engler kaashoek toole operating system kernel secure programmable machine acm sigops european workshop dagstuhl castle germany september engler kaashoek toole exokernel operating system architecture application-level resource management acm symposium operating systems principles sosp copper mountain december fiuczynski bershad extensible protocol architecture application-specific networking winter usenix conference san diego january free software foundation gnu wget non-interactive downloading utility http gnu manual wgethtml mono wget html ghormley rodrigues petrou anderson slic extensibility system commodity operating systems usenix annual technical conference orleans june graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june hartman peterson bavier bigot bridges montz piltz proebsting spatscheck joust platform liquid software ieee network special edition active programmable networks july hollingsworth miller dynamic control performance monitoring large scale parallel systems seventh acm international conference supercomputing ics tokyo july hollingsworth miller cargille dynamic program instrumentation scalable performance tools scalable high performance computing conference shpcc knoxville hollingsworth miller gon alves naim zheng mdl language compiler dynamic program instrumentation international conference parallel architectures compilation techniques pact san francisco november intel corporation pentium pro processor developer manual mcgraw-hill june intel corporation vtune performance analyzer http developer intel vtune analyzer index htm kaashoek engler ganger brice hunt mazi res pinckney grimm jannotti mackenzie application performance flexibility exokernel systems acm symposium operating system principles sosp saint-malo france october kleiman vnodes architecture multiple file system types sun unix summer usenix technical conference atlanta june knuth stevenson optimal measurement points program frequency counts bit knuth structured programming goto statements acm computing surveys kuenning precise interactive measurement operating systems kernels software practice experience january lampson interactive machine language programming afips joint computer conference fall larus ball rewriting executable files measure program behavior software practice experience february larus schnarr eel machine-independent executable editing acm sigplan conference programming language design implementation pldi jolla june lee leone optimizing run-time code generation acm sigplan conference programming language design implementation pldi philadelphia massalin threads input output synthesis kernel acm symposium operating system principles sosp litchfield park december mauro kernel synchronization primitives sunworld online september http sunsite uakom sunworldonline swol- swol- insidesolaris html mauro mcdougall solaris internals core kernel components sun microsystems press prentice-hall palo alto montz mosberger malley peterson proebsting scout communications-oriented operating system workshop hot topics operating systems hotos-v orcas island moore dynamic probes generised kernel hooks interface linux usenix association proceedings annual linux showcase conference atlanta october mosberger peterson bridges malley analysis techniques improve protocol processing latency acm applications technologies architectures protocols computer communication sigcomm stanford august mosberger peterson making paths explicit scout operating system usenix symposium operating systems design implementation osdi seattle october national laboratory applied network research squid web proxy server http squid nlanr net squid necula lee safe kernel extensions run-time checking usenix symposium operating system design implementation osdi seattle october necula proof-carrying code annual acm symposium principles programming languages popl paris france january necula lee design implementation certifying compiler acm sigplan conference programming language design implementation pldi montreal canada june paradyn project technical papers web site http wisc paradyn papers index html pardyak bershad dynamic binding extensible system usenix symposium operating systems design implementation osdi seattle october pettis hansen profile guided code positioning acm sigplan conference programming language design implementation pldi white plains june ponder fateman inaccuracies program profilers software practice experience probert optimal insertion software probes well-delimited programs ieee transactions software engineering january massalin ioannidis synthesis kernel computing systems winter walpole study dynamic optimization techniques lessons directions kernel design technical report ogi-cse- oregon graduate institute science technology audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating system principles sosp copper mountain december black cowan walpole consel microlanguages operating system specialization sigplan workshop domain-specific languages dsl paris france january rational software web page purify fast detection memory leaks access errors http rational products whitepapers jsp rational software web page quantify web site http rational products quantify romer voelker lee wolman wong levy bershad instrumentation optimization win intel executables etch usenix windows workshop seattle august rosenthal evolving vnode interface summer usenix technical conference anaheim june saavedra park improving effectiveness software prefetching adaptive execution conference parallel algorithms compilation techniques pact boston october seltzer endo small smith dealing disaster surviving misbehaved kernel extensions usenix symposium operating systems design implementation osdi seattle october seltzer small self-monitoring self-adapting operating 
systems workshop hot topics operating systems hotos-vi rio rico march seltzer small smith symbiotic systems software annual workshop compiler support systems software wcsss tucson february sirer fiuczynski pardyak bershad safe dynamic linking extensible operating system annual workshop compiler support systems software wcsss tucson february sites personal communication october silicon graphics microprocessor user manual-version http sgi processors manual html small tool constructing safe extensible systems usenix conference object-oriented technologies systems coots santa april smith tracing pixie technical report csl-tr- computer systems laboratory stanford stanford november smith overcoming challenges feedback-directed optimization acm sigplan workshop dynamic adaptive compilation optimization dynamo boston january solaris abi tools appcert http sun developers tools appcert solaris manual page kstat solaris manual page lockstat solaris manual page prof solaris manual page tracing srivastava eustace atom system building customized program analysis tools acm sigplan conference programming language design implementation pldi orlando june sun microsystems ultrasparc user manual microelectronics division sun microelectronics manuals sun microsystems ultrasparc-iii user manual microelectronics division sun microelectronics manuals tamches miller fine-grained dynamic instrumentation commodity operating system kernels usenix symposium operating systems design implementation osdi orleans february tamches miller dynamic kernel instrumentation kernel application tuning international journal high performance computing applications fall united states department defense department defense trusted computer system evaluation criteria tcsec dod -std december vahalia unix internals frontiers prentice hall upper saddle river wahbe lucco anderson graham efficient software-based fault isolation acm symposium operating system principles sosp asheville december weaver germond eds sparc architecture manual sparc international prentice hall menlo park miller naim dynamic instrumentation threaded applications sigplan symposium principles practice parallel programming ppopp atlanta miller reps safety checking machine code acm sigplan conference programming language design implementation pldi vancouver june reps miller typestate checking machine code european symposium programming esop genova italy april zhang wang gloy chen smith system support automatic profiling optimization acm symposium operating system principles sosp saint-malo france october 
finding bottlenecks large scale parallel programs jeffrey kenneth hollingsworth thesis submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison copyright jeffrey kenneth hollingsworth rights reserved acknowledgements pursuing phd computer sciences long bumpy journey people meet make process bearable pleasurable advisor bart miller years advice encouragement mentoring members thesis committee readers jim larus miron livny grateful helpful suggestions improved content clarity thesis david wood ernest hanson business school probing questions defense resulting improvements thesis staff paradyn performance tools project mark callaghan bruce irvin karen karavanic krishna kunchithapadam tia newhall special jon cargille listening ranting spending time working low level cmsoftware endure grateful people provided application programs measurement mark hill spyros kontogiorgis gary lewandowski tia newhall joann ordille gary schultz madhusudhan talluri parents john sandra nurturing encouraging friends support comradery ted faber scott lewandowski karen lohman rich maclin finally dane county habitat humanity providing constructive outlet tinker research supported part department energy grant de-fg -er office naval research grant -jnational science foundation grants ccrand cdaan arpa graduate fellowship high performance computing grant sequent computer systems iii abstract thesis addresses problem locate source performance bottlenecks large-scale parallel distributed applications performance monitoring creates dilemma identifying bottleneck necessitates collecting detailed information collecting data introduce data collection bottlenecks time users inundated volumes complex graphs tables require performance expert interpret developed approach addresses problems combining dynamic on-the-fly selection performance data collect decision support assist users selection presentation performance data approach called search model make implement search model developed monitoring technique parallel programs called dynamic instrumentation premise work on-line performance debugging large scale parallelism mandatory search model closes loop data collection analysis searching performance problem iterative process refining answers questions application performing poorly bottleneck problem occur answer question tests conducted identify type bottleneck synchronization computation answering question isolates performance bottleneck specific resource program disk system synchronization variable procedure answering problem occurs isolate bottleneck specific phase program execution dynamic instrumentation differs traditional data collection defers selecting data collect program running permits insertion alteration instrumentation program execution features type data collection combines low data volume sampling accuracy tracing instrumentation precisely count time events inserted dynamically modifying binary program counters timers periodically sampled provide intermediate values search model based intermediate data made instrumentation collect information isolate bottleneck built prototype implementation search model dynamic instrumentation prototype runs thinking machine cmand network workstations running pvm study tools identified bottlenecks real programs orders magnitude data traditional techniques study dynamic instrumentation monitor long running programs introduced perturbation search model dynamic instrumentation complement individually search model applied existing post-mortem performance tools simulated machines environments dynamic instrumentation collect performance data including visualization search model dynamic instrumentation incorporated paradyn performance tools chapter introduction motivation parallel computers provide required computational power performance important tools users performance programs essential parallel computing number computational power processors parallel computers increases volume complexity performance data gathered machines explodes wealth information problem programmer forced navigate tools store process makes situation worse time data irrelevant understanding performance application problem volume performance data cost collecting minimize perturbation performance tool collect data explain performance program deciding data relevant program execution difficult information overload problem facing parallel programmers existing performance tools incorporate techniques visualization auralization metrics address problem visualization auralization provide programmers perceive program performing graphics sound metrics measurements quantify location bottleneck computing numeric values parts procedures processors program measured techniques provide programmers insight performance program small amount data techniques assumes programmer picture draw metric single approach applies parallel programs study conducted performance metrics compared head-to-head number real parallel programs addition employed technique calibrate accuracy guidance supplied metrics study showed programs metrics provided guidance metric visualization optimal guidance tools tend include types output result user forced sort sea potentially conflicting pictures tables find explain performance program excess pictures marginally search sea raw numbers address information overload problem provide decision support helps users find data understand program performance select ways display analyze goal give programmers specific advice performance bottlenecks lie program provide meaningful methodology decision support advice vital understand process performance debugging parallel programs based informal studies programmers previous performance tool ipsseveral trends inferred programmers generally start high level view performance application iteratively isolate source program poor performance process continues understand program performance start tuning thesis develops performance environment mimics manual refinement process helps automate tedious task programmer equal importance information overload problem problem collect required performance information efficiently potential volume performance data generated moderate size parallel machines significant problem tool designers estimate current risc processors generate megabytes performance data collecting basic performance information granularity procedure system calls estimate based generating traces events large scale parallel computer nodes amount data impractical collect shortest programs alternative tracing counters timers summarize performance data combinations procedures processes time varying information considered approach produces data full tracing option manage data volume short executions parallel programs understand performance nature bottlenecks programs scaled parallel programs run production size understand performance obvious solution data irrelevant collect data creates dilemma isolate bottleneck data collect find bottleneck collect data summary results dissertation pronged solution problems information overload data collection provide structured methodology called search model automate search performance bottlenecks model data collection called dynamic instrumentation introduced dynamic instrumentation permits instrumentation decisions made changed execution prongs work combine form integrated system parallel programmers efficient system answer performance questions search model answer questions application performing poorly bottleneck occur answer question developed library potential bottlenecks called hypotheses cover virtually types problems parallel application answering question yields detailed description processor synchronization object procedure disk limiting performance application answer question advantage fact parallel programs distinct phases execution bottlenecks affect phases reason search model express bottlenecks fixed set hypotheses type bottleneck parameterized components axes programmers precise information understand tune programs search model application machine independent framework isolation performance bottlenecks framework variety parallel machines makes easy programmers tune programs platforms platform independence means ideas apply equally heterogeneous combination machines single homogeneous machine major contribution thesis dynamic instrumentation dynamic instrumentation demand-driven performance monitoring key idea collect data greatly reduce volume data collected collecting data provide richer palette performance data data collection approaches addition monitor larger longer applications previously dynamic instrumentation makes analyze data collected 
execution change data collected collapses long instrumentation compilation execution analysis cycles single execution program significant advantage monitoring long running programs database servers multi-hour scientific applications integral part dynamic control program instrumentation data collection cost model regulate perturbation caused instrumentation model associates cost data collected analysis collecting performance data affects resources processors interconnection networks disks data analysis workstations cost model incorporates impact data collection resources cost model feedback search model control potential bottlenecks cost information displayed user show performance environment perturbed application program thesis calls significant shift parallel program performance debugging tools designed built make dynamically select performance data performance debugging move post-mortem activity iterative interactive execution time activity shift affords secondary benefits option integrate performance debugging correctness debugging application steering prongs work search model dynamic instrumentation separately provide solid solutions problems information overload data collection bringing ideas single system creates significant synergistic affects search model natural drive dynamic instrumentation relieve programmer tedious task selecting data collect dynamic instrumentation efficient mechanism collect data rich palette performance problems search model built initial implementation dynamic instrumentation search model implementation runs thinking machines cmand network workstations running pvm system study real applications execution times ranging minutes hour case significant bottlenecks identified tool organization thesis remainder thesis divided chapters chapter discuses previous work field middle thesis describes search model dynamic instrumentation cost model introducing idea present short study illustrate effectiveness concept final part thesis brings separate ideas describes prototype implementation includes commentary components interact study applications prototype implementation chapter defines search model describe process independently refining program performance search dimensional space axis dimension explain hypotheses evaluated combinations resources axis phases axis chapter develops process automate searching performance bottlenecks chapter proof concept implementation search model addition present small case study demonstrate effectiveness model finding real bottlenecks chapter describes data collection approach dynamic instrumentation introduce collect performance data efficient permits potentially rich variety metrics present technique permit performance instrumentation inserted running program chapter reports initial implementation dynamic instrumentation include series measurements micro primitive level macro application level quantify efficiency dynamic instrumentation chapter describes data collection analysis cost model shows model throttle interactions search model dynamic instrumentation chapter combines search model dynamic instrumentation includes performance case studies real parallel programs finally chapter summarizes contributions thesis outlines future extensions work chapter related work performance debugging tools consist parts data collection analysis presentation data collection involves deciding data collect collect collected data restricted application measured encompass statistics sources operating system measurements made software inside application dedicated hardware performance data gathered statistical samples logs interesting events data analysis reduces large quantity raw data small amount explains application performance analysis accomplished filtering data transforming numerical metrics data presentation includes deciding visual representation data managing presentation prevent user overwhelmed information past techniques avoid information overload focused providing effective ways visualize performance data thesis concentrates aspects performance debugging problems data collection information overload chapter summarize previous performance debugging environments eye handle issues note strengths weaknesses approaches information overload previous work manage volume performance data concentrated areas performance metrics performance visualization performance metrics reduce large amounts raw data numbers characterize bottlenecks parallel application performance visualization presents user visual aural abstraction parallel computation identify bottleneck application performance metrics performance metrics tool programmers reduce running time programs profile metrics performance metrics associate component parallel application frequently procedures metrics presented sorted tables important components top display profile metrics originated sequential programming simple list cpu time consumed procedure application standard unix cpu time profiler prof tool logical extension technique parallel applications total cpu time profiles process thread profiling environment connection machine type metric adding cpu time process ignores fact cpu time equal importance parallel program performance time spent sequential routine greater impact execution time program total time split simultaneous instances parallel procedure anderson lazowska developed quartz normalized process time npt metric compensate inequities treating cpu time npt normalizes cpu time procedure based effective parallelism procedure executing normalization assigns higher values indicating important sequential procedures parallel npt accurate information prof requires threads execution frequently update single shared data structure simply sequential metrics parallel applications sufficient parallel application improving procedure consumes largest amount time necessarily improve execution time inter-process dependencies parallel application influence procedures important application execution time yang miller developed critical path analysis provide accurate guidance critical path estimate improvement runtime single procedure optimized estimate upper bound extension critical path called logical zeroing estimate metrics provide detailed information improve parallel application building data structures calculating metrics require significant space time prof npt critical path analysis focused finding cpu time bottlenecks source bottlenecks parallel programs memory hierarchy necessity memory hierarchy parallel computers complex sequential machines shared memory parallel computers typically levels caches form cache coherency protocol effective memory hierarchy essential high performance applications mtool metric based tool includes information memory hierarchy mtool compares observed execution time application predicted execution time characterize influence memory hierarchy computation differences predicted observed execution times attributed memory contention extra time access non-local memory metric applicable memory bottlenecks find single metric characterize entire application tools provide sorted profiles resources commonly profiled resources cpu utilization synchronization time disk operations vectorization cache performance incas jewel analyzer examples approach tools provide wealth information programmer force select resources profile application building tool includes potentially metrics difficult alternative provide library metrics make tool extensible permit users create metrics tool ipswhich permits users create metrics algebraic expressions previously defined metrics ipsdoes built-in metric fraction actual cpu time process define metric terms process cpu time spinning time divided total user cpu time system defining metrics expressions intrinsic metrics easy extend performance tool type metrics defined user limited base metrics provided tool developer make performance tools extensible provide toolkit building metrics pputt toolkit building metrics analysis modules built top basic event stream extensible systems provide powerful tool sophisticated users convenient tool developers explore metrics users additional metrics unable functionality major problem metrics knowing previous paper compared metrics including critical path logical zeroing npt concluded single metric characterize types applications metric information valuable programmer select metrics metrics costs computation cheaper metric prof adequate calculate complex metrics current tools incorporate meta-metrics search based tools performance metrics provide 
guidance types bottlenecks metrics required types bottlenecks user left select provide guidance user tools developed treat problem finding performance bottleneck search problem systems attempt identify problem describe give advice correct prescribe atexpert cray research rules recognize performance problems fortran programs information achieved speedup overhead parallel routines sequential time select suggestions program execution time improved data presented granularity subroutines loops parallel blocks case statements recently cray research released tool mpp apprentice recognizes performance problems message passing programs cray mpp apprentice approach similar atexpert works general programming model crovella leblanc predicate profiling search system compare algorithms problem evaluate scalability algorithm define set rules test losses performance parallel program losses classified categories load imbalance starvation synchronization memory hierarchy values calibrated terms cycle times information displayed bar chart showing cycles due work sources loss information presented granularity entire application high level information type bottleneck include isolate bottleneck program components procedures processes search performance bottlenecks programmer assertions expected performance program programmer express expected cpu utilization cache miss tolerance pspec language approach post-mortem tool checks assertion failures scanning log files created program execution performance assertions programmers precise descriptions expected performance writing assertions create additional work programmer tool employs user defined predicates pmpl pmpl existing trace monitors aims picl pmpl user defined predicates control performance data logging large scale parallel computers performance predicate detected event logs circular buffer written disk analysis major limitation search-based tools fully address data collection problem tool requires user manually predicates limited granularity data collected entire application visualization approach finding performance problems parallel programs provide pictures programmers visualize problems parallel program visualization visual aural tool provide user feedback parallel program running definition includes visualization lowlevel activity parallel machine algorithm animation auralization divide existing performance visualization tools categories single visualizations type bottleneck fixed collection visualizations toolkits building user defined visualizations basic visualization representation physical machine map presents memory access patterns sequential fortran programs running vector supercomputers map shows memory dimensional grid memory location referenced location grid highlighted decays back original color similar phosphor crt screen frequently accessed memory locations refreshed frequently constant glow visualization simple effective identifying memory hot spots limitation map relate memory accesses source code tool single visualization resources parallel computation pie pie color coded time-line tracking cpu state work blocked spinning time tool show procedures executing assigning color procedure program time-lines levels abstraction individual processes displayed displays colorful provide feel program execution difficult interpret process level abstraction difficult results effective parallelism depend multiple processes procedure level colors impossible happening limitation acute authors added hand drawn plot parallelism time paper explain visualizations common visualization illustration synchronization patterns parallel computation mad debugger causality graph showing thread vertical line inter-thread communication synchronization diagonal lines great detail programmer scan large complex graph find relevant events addition scaling visualization massively parallel machines difficult visualization tools discussed single visualization providing single visualization limits types bottlenecks discovered tools developed incorporate multiple visualizations type tool paragraph supports twenty types displays displays configured plot values resources cpu disk utilization greatly increasing number performance displays visualization program programs user left formidable task selecting visualizations resources display moviola performance tool preface provide large libraries pre-defined visualizations matter visualizations tool users eventually solution problem explored systems pablo jewel systems toolkits building visualization modules user constructs visualizations building blocks method permits unlimited number visualization modules built tool includes collection pre-defined visualizations programmer start tool create visualizations major limitation systems provide assistance user creating visualizations find performance bottleneck visualizations discussed designed work program studied approach algorithm animation algorithm animation graphically represent application execution level abstraction similar programmer mental model program pancake utter programmer program represented physical machine easier understand program performance difficult part relating events physical machine back abstract model approaches express relationships ive voyeur polka zeus require programmer make calls animation routines program approach belvedere event stream user defines reduction animation operations problem algorithm animation adds burden creating debugging animations process writing parallel application variation algorithm animation auralization representing program graphically auralization animates sound combination sound pictures technique extra dimension represent application limited requires programmer select operations animation major problem visualization systems constrained tradeoff relevance re-usability provide information sufficiently high level visualization modules specific single programming paradigm worse single application wide variety applications visualization modules based low level events message passing common applications data collection performance data analyzed presented collected data collected data collected collected varies greatly systems performance data measured applications operating systems hardware data gathered ranges summary counters detailed event traces instrumentation measure programs software custom monitoring hardware hybrid combination matter approach effective data collection requires gathering detailed information parallel program minimizing perturbation data representative un-instrumented program approaches develop efficient data collection section review number data collection techniques program instrumentation application source code compiler code object linkerruntimelibrary executable cxpapablojewel qpt mtool process applicationtam ips pie cedar figure inserting instrumentation program performance instrumentation inserted application program stage compilation dashed lines tools shown italic insert instrumentation collect data application instrument application executable runs generates desired information side effect ways type instrumentation inserted manually editing source code automatically compiler linking instrumented libraries modifying linked executable approaches advantages disadvantages figure shows stages compilation tools insert instrumentation collecting data runtime library library easy collect data interactions processes ipsand cedar tracing approach runtime library instrumentation require user modify application requires re-linking program modified version library similar approach provide set instrumented primitives require user write applications primitives instant replay primitives operate events queues shared memory objects processes bbn butterfly likewise pie works programming model called mpc parallelism operations shared memory basing instrumentation set primitives performance monitoring system developed conjunction programming model collect performance information individual program constructs loops statements instrumenting runtime libraries primitives sufficient collecting data granularity requires instrumentation interspersed statements user program cxpa prism mpp apprentice modified compiler insert instrumentation desired location compiler based instrumentation affords access wealth information compilation information data loop dependencies difficult gather compiler information compiler based instrumentation program re-compiled forces decisions data collect made early edit compile run cycle large program re-compiling source code gather performance information significant barrier tool addition gather information libraries source commercial products source code readily alternatively instrumentation inserted executable 
image built approach called binary re-writing inserts instrumentation object file compiled assembled qpt mtool jprof stardent postloader style instrumentation binary rewriting advantage language independent compilers libraries modified hand modify application insert calls collect performance data jewel approach hand instrumentation user great degree selectivity tedious process finally source source translation program means automatically insert instrumentation program compiled eliminates modify compiler instrumentation system portable platforms tied single language data dependencies requires program re-compiled collect data pablo aims source source translation techniques require instrumentation inserted prior program execution system defers instrumentation program started execute tam facility provided intel paragon tam fixed set performance instrumentation profiles prof style sampling full event tracing insert instrumentation program loaded memory prior execution tam instrument program start execution requires data collection remain static program execution data collection approaches section require instrumentation remain fixed application execution monitoring long running programs desirable change instrumentation program running system instrumentation collecting data creating modified application processes desirable software based approach collect data dedicated monitoring processes operating system approach decouples monitored system application process expense easy access application data structures figure shows ways programs externally monitored passive kernel cpu processes counters dedicated collection process ips edcu parasight kernel instrumentation metric dpm mkm tmp multikron interconnection network trace processor cray ymp sequent symmetry figure inserting instrumentation system performance data system collected hardware software dashed-line objects show ways collect performance data systems approach shown italics common approach collect performance data modify operating system collect traces kernel events forward user process kernel based instrumentation advantages easy instrument application required single kernel call turn instrumentation types data context switches page faults difficult collect user process hardware kernel based approaches suffer limitations modifying kernel time consuming error prone users run modified kernel tool metric early modified kernel data collection smith spider debugger kernel based instrumentation track inter-process communication worked single machine distributed program monitor traces inter-process message passing distributed environment mach kernel monitor instruments context switches trace state processes time modifying operating system feasible desirable monitoring accomplished dedicated data collection processes external data collection facility ipsprovides capability information operating system gathered collector processes reported user operating systems collect statistics make information system calls system calls data collected directly instrumenting operating system external data collection processes special collection processes gather information specific applications parasight dedicated collection processes gather operating system application statistics shared memory filtering software based instrumentation makes track vast number metrics events application execution tools limited large amount performance data generate approach reduce amount data filter store interesting events edl segall receptacles jade predicates actions recognize desired events sequences events generate synthetic events issos meta predicates detect interesting states application require user program periodically call filtering system filtering greatly reduces amount performance data collected tools force user select desired events prior starting program tools incorporate dynamic control event recognition filter process ebba based edl permits dynamic insertion predicates bee dynamic control filtering events based event type insertion complex predicates called event interpreters topsys jewel require predicates defined program starts execution permit dynamic control enabled xab dynamic selection tracing messages message type pvm applications limitation dynamically configured filters necessitate runtime overhead data collected systems provide assistance user selecting events collect collect dynamic instrumentation approach collecting large amounts data providing dynamic filters collect data interested gathering hardware data collection approach reduce resource contention data collection system system measured build dedicated hardware data collection data collection hardware ranges passive monitors hybrid software hardware trace generation passive hardware monitors observe activity parallel computer record results analysis implemented set programmable counters record events bus memory hierarchy processor performance monitors built sequent symmetry power rsand pem monitor programmable hardware counters advantages passive monitoring include perturbation observed system simple hardware design passive monitors record information activity system difficult correlate performance information source hardware monitor cray y-mp passive track performance data process basis albeit additional overhead context switching process passive monitoring application performance debugging multi-user environment passive monitors number limitations interesting events program execution visible hardware monitor event signals counters user select events monitor approach solve visibility limitations passive hardware monitors hybrid software hardware monitor hybrid monitor zahlmonitor application signal event occurrence hardware writing special range memory locations hardware count event occurrences approach hardware collector generate trace data send data reduction station separate bus interconnection network multikron tmp hypermon examples type monitor advantage hybrid instrumentation eliminates perturbation cpu inter-connection network permits information visible application collected major limitation hybrid monitoring generate data swamps file system data reduction station tools techniques presented chapter show wide variety approaches improve performance parallel programs system made design tradeoffs common area tools improved type guidance decision support supply user data efficiently collected result subset data gathered current approaches data collection require instrumentation decisions remain fixed program execution chapter search model parallel program performance debuggers exist answer programmers questions application run expected parallel program amount performance data answer questions huge practice small amount information sufficient reveal bottleneck goal performance debuggers programmer find gems understanding large space performance data well-defined logical search model required model provide structured programmers quickly precisely isolate performance problem examine large amount extraneous information chapter describes search model system features based answering separate questions application performing poorly bottleneck problem occur deliver answers simply posing questions automate search process chapter describe achieve automation goals develop methodology performance debugging important understand programmers seek answers performance problems current tools developing ipsperformance tools opportunity observe users approached tool trends emerged common starting point display graph cpu utilization time entire program digesting information selected metrics synchronization isolated cpu utilization specific parts program processes procedures programmers considered specific information understood problem starting changing program unable isolate performance problem approach slightly data relevant phenomena explained ipswas unable relate performance operating system metrics page faults specific user functions programmers infer procedures responsible restricting page fault metric specific interval time discovered programmers asked metric ipsmade viewing data easy programmers overwhelmed choices lessons drew experience performance tool provide programmers guidance conduct iterative refinement process search process permit ways refine problem based programmer mental model data watching programmers existing tools insight develop methodology performance debugging sufficient dismay tool builders observed 
platforms fairly sophisticated performance tools parallel programers performance tools programmers manually insert code program understand performance programmers manually search bottlenecks hints automate process common programs performance insert calls timer primitives measure time spent region program idea program spends time additional timers counters inserted program re-executed refine source bottleneck step iterated times isolate program poor performance methodology performance debugging hand instrumentation similar observations programmers ipsprogrammers start global view program iteratively isolate source performance problem observations form basis organization search model goal search model programmers find bottlenecks programs define bottleneck component program execution contributes significant amount time application execution time definition single execution program bottlenecks judge difficult bottleneck improve programmer decide reduce time spent bottleneck search model designed automate search performance bottlenecks user control degree involved respond directly commands user run automated mode automated mode source performance problem iteratively refined specific location program user make manual refinement problem system continue refine problem matter good tools feel programmers continue play integral part performance tuning addition solving information overload problem search model helps manage data collection problem dynamic instrumentation affords opportunity greatly reduce volume performance data collected requires numerous choices made data collect collect providing direct control instrumentation programmers complicates formable task tuning parallel program goal search model manage dynamic instrumentation programmers enjoy low data collection overhead incurring complexity making instrumentation choices additional goals model usability portability programmers write application works specific performance tool write application style restricted specific programming model required manually add code application collect performance data instrumentation inserted transparently automatically needed finally search model work variety machine architectures programming styles difficult goal due diversity machines styles desire provide relevant guidance specific program specific machine major goals search system provide structured approach programmers understand programs permit searching automated provide drive dynamic instrumentation achieve goals developed search model permits users independently refine program performance performance bottleneck simply matter refining answers questions search process thought traveling point multi-dimensional space step move direction point refinements promising selected candidates refinement axis performance question programmers application running slowly answer question types problems bottleneck parallel program represent potential bottlenecks hypotheses tests hypotheses represent fundamental types bottlenecks occur parallel programs independent program studied hypothesis program synchronization bound hypotheses represent universal activities parallel computation small fixed set hypotheses provided tool builder cover performance problems tests boolean functions program exhibits specific performance behavior related hypothesis expressed terms thresholds test return true execution time spent waiting synchronization tests provided tool builder user user generally modify values thresholds generally time thresholds changed tool ported model parallel machine hypotheses hypotheses pre-conditions dependence relationships hypotheses define search hierarchy axis dependencies form directed acyclic graph searching axis involves traversing graph figure shows partial axis hierarchy current hypothesis application highsyncblockingtime bottleneck hypothesis reached concluding syncbottleneck exists program make relationship hypotheses tests concrete hypothesis test shown figure shows simple hypothesis syncbottleneck defines source bottleneck due excessive time spent waiting synchronization test highsynctimetest returns true average time spent waiting synchronization operations greater highsyncthreshold defined test metrics boolean expression synctime time spent waiting synchronization operations divided wall time activeprocesses number processes application details metric definition omitted shows hypothesis represents abstract type bottleneck tests define specific numeric criteria bottleneck toplevelhypothesis syncbottleneck highsyncblockingtime frequentsyncoperations figure sample hypothesis hierarchy constant highsyncthreshold metric synctime metric activeprocesses hypothesis syncbottleneck precondition test highsynctimetest description program synchronization limited test highsynctimetest return synctime activeprocesses highsyncthreshold figure pseudo code hypothesis test searching axis iterative process select hypothesis conduct test true refinements hypothesis test hypothesis application synchronization bottleneck hypothesis true refinements frequent synchronization operations time waiting synchronization operations complete test hypotheses true define hypothesis true tests return true data collected continue verify tests conditions hypothesis remain true collect performance data definition true hypothesis working hypothesis meets test criteria confused statistical hypothesis scientific hypothesis connotations hierarchical axis capable searching types bottlenecks main contributions thesis tools type problem memory bottlenecks synchronization tools display multiple types bottlenecks guide user search process structured model helps focus user problem bury details axis searching axis classify type problem parallel application fix problem specific information required knowing program synchronization bound suggests synchronization operations large application hundreds thousands operations search model find synchronization operation causing problem classify bottleneck identify resources responsible isolate bottleneck specific resource search axis axis formed collection logically independent resource hierarchies typical resource types include synchronization objects source code threads processes processors disks multiple levels hierarchy leaf nodes instances resources application searching axis iterative consists traveling individual resource hierarchies resource hierarchy refined independently axis viewed n-dimensional space number resource hierarchies left tree figure shows sample resource hierarchy root hierarchy synchronization objects level types synchronization semaphore message recv spin lock barrier spin lock barrier nodes individual locks barriers application children message recv node types messages children semaphore node semaphore groups application semaphore group individual semaphores components axis created times nodes defined statically application starts application execution static components top hierarchy dynamic nodes lower levels hierarchy root resource hierarchy statically defined depending hierarchy nodes root statically defined levels hierarchy defined specific hosts application selected step creates nodes types resources application nodes created depend types hosts style parallelism application application identify synchronization libraries included lowest levels hierarchy representing specific resource instances added application execution resource instance current status search axis called focus consists current state resource class hierarchy figure shows sample axis resource hierarchies highlighted nodes show current focus component hierarchy focus shown figure spin locks cpu procedure searching performance problems axis called magnifying focus magnify focus hierarchy independently magnifying focus step process pick resource class hierarchy magnify determine children current node select potential focuses restricting magnification subset children current compute object code cpus cpu frob main stuff synchronization objects individual locks barriers individual barriers locks spin semaphores group group individual semaphores individual msg recv message types figure sample axis class hierarchies highlighted object current focus oval objects defined search model triangles static based application rectangles dynamically runtime identified node test true hypothesis potential focus tests criteria hypothesis met potential focus added current focus list discarded sample magnification starting focus shown figure select code hierarchy list children current node hierarchy procedures frob main stuff select test choose check 
run tests conclude current hypothesis holds frob results focus spin locks cpu procedure frob test true procedure added focus axis programs general parallel programs distinct phases execution simple program phases execution initialization computation output single phase program performance similar enters phase behavior program change radically program enters phase execution performance bottlenecks change result decomposing program execution phases convenient programmers understand performance program phase analysis understand tune programs years programmers drew diagrams hand phase behavior programs manage manual memory overlays recently denning noted importance recognizing phases phase automatically memory management system parallel computing tools ipsprovide ways restrict program measurement specific phase execution experience watching programmers feature ipsconvinced phase analysis major programmers performance bottlenecks component search model axis programmers exploit phase behavior programs find performance bottlenecks searching axis involves testing current hypotheses current focus intervals time application execution choose interval time program initialization figure shows phases hypothetical program start end interval generalization axis permit nesting time-intervals refining bottlenecks nested intervals due constraints execution time searching section nested time intervals part current implementation search model important question axis define interval partially user interface problem partially search problem simple approach problem present users time histogram showing metrics updated real time select start time intervals histogram solution simple problem user pay close attention program time figure intervals program execution execution alternative permit user trigger predicates start time interval evaluate true provide library predicates user choose examples predicates time selected procedure called synchronization wait time selected threshold method requires direct involvement user existing correctness debuggers spider topsys similar predicates pmpl similar predicates trigger data recording approach programmers annotate programs calls library routines major parts computation approach effective elegant requires programmer modify code due difficulties automatically detecting phase boundaries manual interval specification searching bottlenecks execution search model designed execution time search performance problems dynamically turn data collection result isolate performance problems single pass made execution performance data searching single pass data difficult data search model designed execution time search structured search automated isolation bottlenecks post-mortem trace based tools describe evaluate based partial data search data step search evaluate tests focus addition test evaluation constrained specific interval time axis data required evaluate test average metric-focus pairs desired interval hypothesis test shown figure evaluated focus shown figure entire program execution evaluate test metrics synctime activeprocesses spinlocks cpu program execution data data program started current time hypothesis data interval started evaluate hypothesis present time sample time interval shown figure interval starts point marked start interval continues decide start collecting data interval start collection performance data start collection point marked current time interval continues unknown length time end interval handle execution time searching problems overcome long current time interval end interval conclude hypothesis true data entire interval ensure partial data representative entire phase handle missed data due selecting time interval started data start interval start collection user selects time interval ended start collection end interval question long interval ideally data entire time interval determine bottleneck exists interval execution complete data interval make refinements sub-intervals re-execute application conclude hypothesis true time interval interval ends approximate result test cumulative performance data current interval selected current time interval continues additional data collected considered evaluating hypothesis require minimum observation time shown minimum observation figure interval conclude data valid prevents transient conditions start interval causing false conclusions approach permits evaluating multiple hypotheses interval ends aggregating long interval meaningful trends application performance question make decisions based partial data important question automated refinement long evaluate hypothesis concluding test criteria met refinements execution define sufficient observation time typically times minimum observation time concluded hypothesis true waiting time interval hypotheses discontinuing testing hypothesis concluding false conclude refinement false data sufficiently large fraction time interval ensure matter remainder interval result test hypothesis question data representative entire phase ensure partial data representative ways minimum observation time filters transient phenomena averaging data minimum window time conclude hypothesis true continue gather data rest phase evaluate tests hypothesis test hypothesis false report user search valid important data collected significant fraction time interval start interval start collection time endinterval current happened data interval data interval minimum observation unknown length figure obstacles changing data collection execution fourth question start collecting data testing hypotheses time interval interval begun average performance entire interval interval started calculate time missed information constraint minimum observation time requiring data collected minimum percentage time interval limits impact missed data cumulative average time interval ends additional data time interval missed fourth question user re-run application hypotheses interval question miss important phenomena program execution collecting data phenomena occurred problem interesting bottlenecks limit performance long running program definition long time result long time interval find isolate problem behavior lasts short interval time missed short impact total execution-time program small short running program fact short means time re-run short potential problems data part interval tests hypothesis true based averaging data short time start interval true entire interval effect mitigated selecting long minimum observation time permit system enter steady state long minimum reasonable interval hypothesis true indication potentially interesting sub-interval problem hypotheses true long interval time build momentum due averaging metric values long time interval true false problem defined metric time interval average interval average high satisfy test criteria high care distribution time interval problem running average metric oscillates test threshold oscillations test metric alternate true false address problem include hysteresis parameter hysteresis parameter splits threshold determining test true parts threshold determines true test considered false determines false test true hysteresis parameter real number multiple threshold transition false true hysteresis parameter threshold transition true false effectively disables hysteresis thresholds true false false true means test true back false appendix discussion shows hysteresis parameter achieves desired damping section developed search performance bottlenecks partial data program execution chapter describe prototype implementation methodology report result applying applications search history graph axes search model guide search process provide snapshot current state search important performance problems considered tested capture temporal aspects search include abstraction called search history graph model search history graph records refinement considered axes result testing refinement isolating performance problem specific barrier require testing barrier separately search history graph barriers tested node 
graph represents single refinement axes nodes present states tested arcs refinements graph represents refinements made rejected figure shows sample search history tree search started root graph refinements made nodes automated searching key component search model ability automatically search performance bottlenecks accomplished making refinements axes requiring user involved automated refinement manual user directed searching hybrid refinements accepted refinements rejected legend iobottleneck syncbottleneck syncbottleneckwhere sync semaphores refinements syncbottleneckwhere sync spinlock syncbottleneckwhere sync spinlock code procedure foo refinements refinements figure sample search history graph combinations manual automated searching selecting refinement step process determining refinements ordering refinements selecting determine refinements children current nodes axis hints order list refinements finally select refinements ordered list true item ordered refinement list axes search model direct user constrain search performance bottlenecks step choices refinements number refinements limited order refinements greatly reduce time required isolate performance bottleneck provide guidance selecting good refinements search model includes hints hints suggestions future refinements generated side effect testing earlier refinements hints important characteristics hints exist order refinements alter refinements hints provide mechanism convey relationships axis axis hypothesis synchronization bottleneck return hint refine axis based synchronization objects explanation interface search model automatically isolate performance problem relate discovered back user matter good performance tool finding problems information related back programmer meaningful tool useless explanation interface search model conveys user causing program perform poorly explanations involve creating displays changing existing performing analyses simple textual output goals explanation interface provide sufficient context user information meaningful incorporate existing visualizations analyses provide guidance selecting visualization analyses providing context explanation important search model run automated mode make refinements reporting results user search history graph information provide context explanation assume found synchronization problem caused message tags single procedure search history graph message tags profile procedure meaningful explanation includes information provide problem important aspect explanation interface ability incorporate multiple displays analyses visualizations performance data created correctly provide quick explanations complex interactions selecting fixed set visualizations build search model limits usefulness provide standard interface visualizations analyses permits system create display alter displays user created user table displayed explanation interface highlight important items sort table illustrate bottleneck goal explanation interface provide guidance selecting visualizations analyses accomplished explanations actions hypotheses explanations triggered hypothesis evaluates true selected focus full library visualizations analyses user time search model create displays relevant addition triggered specific refinement true state axis parameters visualizations information displayed relevant focused current bottleneck chapter search model addresses problem programmer information overload combination systematic iterative search model automate search explanation results provide components performance monitoring environment programmers precise answers tune programs chapter implementation search model techniques ideas search model implemented prototype model called performance consultant study ability search model identify performance bottlenecks interested studying search model isolation study decided simulate dynamic instrumentation system top ipswhich trace based instrumentation trace data meant make multiple runs performance consultant data calibrate search system advantage ipstracing compare amount performance data generated method existing trace based sampling approaches prototype study applications splash benchmark suite database application validate guidance supplied performance consultant studied application program ipsperformance tools manual check permitted verify bottlenecks identified search model real check obvious bottlenecks omitted running programs simulating dynamic instrumentation permitted study search model isolation important evaluate search model real version dynamic data selection study combines search model dynamic instrumentation appears chapter experimental method test implementation included hypotheses shown figure including cpu synchronization virtual memory bottlenecks simplify prototype implementation wrote hypotheses tests functions compiled system experiment resource classes code process synchronization object full implementation additional resources classes experiments restricted resources classes extracted ipstrace data means generally select refinements hypotheses axis refinements cases procedure level refinements implemented manual version axis goal study evaluate search model isolation trace data generated ipsperformance tool simulated dynamic data selection benefit approach permitted compare quality guidance supplied dynamic selection full tracing addition ipsruns variety platforms making large set sample data tests ipsrecords event traces program execution event procedure call synchronization operation wall-clock process time stamps addition event specific data addition normal ipsinstrumentation ran programs external data collectors external data collectors dedicated sampling processes collect additional information tracing collector gathered information behavior operating system page faults context switch rate collected data hardware cache miss rates bus utilization application completed execution pre-processed trace files uniform time histograms time histograms simulate real-time execution histogram bucket corresponds sample delivered system simulated execution-time tool evaluating tests performance data delivered system dynamic instrumentation approximated enabling disabling data collection refined axes search model started simulation data collected evaluate top level hypotheses entire application hypothesis considered refinement made axis data specific procedure enabled collection data evaluating tests data time interval data test enabled current time considered simulated minimum observation time evaluating tests performance data test enabled sufficient time technique gave good approximation dynamic instrumentation instrumentation model based periodically sampling performance counters timers running program counter records event program specific focus procedure call counter exists figure display showing axes procedure program focus counter specific program spin locks counter lock lock procedure lock simulated enabling disabling data collection calculate number samples collected counter multiplying long counter enabled sampling frequency compare total number samples approach needed full sampling requires data counter sample time compare results full procedure synchronization tracing ipsa simple explanation option included prototype explanation function hypothesis hypothesis evaluates true user request explanation explanation function called simplest explanations consist print statements describe type bottleneck hypothesis sophisticated explanations report additional information program explanation cpu bottleneck prints gprof style profile table current focus axis finally important understand configured performance consultant study primarily interested ability tool automatically find bottlenecks ran system mode tool searches refines bottlenecks user interaction arbitrarily set minimum observation time samples seconds depending sample rate likewise sufficient observation time set samples seconds water application studied water splash benchmark programs n-body molecular dynamics application simulates intraand intermolecular potentials water molecules liquid state program primarily spin locks synchronization ran program sequent symmetry processors processors performance small large input files program run processors ran seconds performance consultant identified cpu time bottleneck attempted parallelism spent productive cpu utilization performance consultant found bottleneck seconds computation unable refine hypothesis specific process procedure single process procedure responsible cpu time explanation 
cpu bottleneck hypothesis supplied cpu time profile listing procedures program percent time spent provided list procedures improve validate hypothesis ipstools found program cpu bound ran program larger input file processors ran seconds case performance consultant found program synchronization bound confirmed ipsthe performance consultant identify specific lock variable responsible synchronization waiting time total execution time processes specific advice performance consultant gave case study major bottleneck changed processors larger data set showed important study performance parallel programs real datasets desired number processors important question prototype volume performance data needed find bottlenecks figure shows summary performance data collected system compared full sampling column total counters shows number counters required event types focuses search model disposal counters total counters find program bottlenecks total samples shows number samples required counters sampled msec samples number samples collected counters enabled figure compares volume sample data generated approach full tracing ipsthe column labeled samples number samples appears figure compare dynamic instrumentation ipstracing needed figure big single sample dynamic instrumentation twelve bytes selected reasonable size bytes counter identifier bytes time stamp bytes column size shows number samples multiplied bytes sample trace size actual size trace file created ipsper- formance tools ratio shows ratio ipstrace size size column dynamic approach instrumentation reduced volume performance data collected program factor ranging times compared traditional methods interesting aspect technique appears processor case shown figure dynamic instrumentation counters total samples performance consultant isolating performance problem specific lock variable needed measure lock waiting time lock performance consultant discarded locks waiting sufficient observation time total counters total samplescpus counters samples figure sampling dynamic instrumentation water application comparison volume data collected dynamic instrumentation full periodic sampling water application number counters examined number samples delivered shown dynamic instrumentation ipstracecpus samples size size ratio figure data dynamic instrumentation tracing water reduction data collected dynamic instrumentation compared ipstracing water program sizes kilobytes assume bytes sample collect data lock entire execution locusroute application studied locusroute splash benchmark programs vlsi tool routing standard cells computes area resulting layout ran program dedicated processor sequent symmetry dismay performance consultant gave information program decided run ipson program happening ipsmetrics unable explain performance program finally looked volume performance data ipssys- tem creating discovered program makes procedure calls instrumentation overhead due procedure calls problem confirmed problem ways wrote test program overhead tracing procedure call ipsinvolved feature ipsthat permits turn procedure level tracing re-ran program performance consultant found cpu time bottleneck resulting program search model model verify observed instrumentation overhead system acceptable added additional hypothesis identify instrumentation bottlenecks defined spending time instrumentation significant overhead additional hypothesis identify procedure call instrumentation overhead problem program pleased ability system test instrumentation bottlenecks figures show amount performance data collected locusroute hypothesis instrumentation overhead initial version bottleneck found refinements made counters required test initial hypothesis root axis collected time interval program execution collect data refinement made shows minimum amount data gathered approach case identified instrumentation bottleneck counters examined performance consultant isolate bottleneck single procedure case dynamic instrumentation reduces volume performance data collected factor compared full tracing shared memory join application study implementation join function relational database implements hash-join algorithm shared memory inter-process communication program written study shared-memory shared-nothing join algorithms ran program dedicated processor sequent symmetry test case ran seconds performance consultant identified bottleneck program due excessive page faults page fault data collected external sampler process collected total counters total samplesversion counters samples initial collection hypothesis figure full sampling dynamic instrumentation locusroute comparison volume data collected dynamic instrumentation full periodic sampling locusroute application number counters examined number samples delivered shown row shows data original set hypotheses row shows amount data collected added hypothesis data collection bottleneck dynamic instrumentation ipstraceversion samples size size ratio initial collection hypothesis figure dynamic instrumentation tracing locusroute reduction data collected dynamic instrumentation compared ipstracing locusroute program sizes kilobytes assumes bytes sample process procedure basis system directly isolate bottleneck specific procedure identify time program execution page fault bottleneck occurred shows search model precisely isolate performance problem axis case axis isolate problem flexible approach finding bottlenecks important characteristic work validate result ipsperformance tools previously studied program recognized page fault problem problems program problem due creation user data program page referenced process unix operating system traps zeros previous contents page pages previously allocated created calls dynamic memory allocation routine small program reduced page fault behavior improved execution time figures show volume performance data generated shared memory join application program investigated changing simulated sampling interval change amount performance data collected sampled intervals msec msec msec reduced volume performance data collected compared ipsby factor msec reduced factor ratio data collected full sampling dynamic instrumentation factor change significantly changed sampling interval lessons learned building early prototype main parts search model understanding interactions components search model lessons incorporated full implementation chapter realized hypotheses axis represented refinements axis wrote hypothesis highly contested hot spin locks realized trivially re-write hot synchronization objects meant types synchronization system manual searching bottlenecks recorded search path programmer based informal analysis logs define automated searching discovered refining axis searching axis finally axis helps reduce number options step easier understand refinements made random order hand system returned hint found confirmed intuition find bottleneck single program programs uninteresting bottleneck start execution important report fact continue bottlenecks rest execution sample total counters total samples interval counters samples figure full sampling dynamic instrumentation shmjoin comparison volume data collected dynamic instrumentation full periodic sampling shmjoin application row shows volume data collected sampling rate sample counter timer mili-seconds row shows increase data volume sampling rate changed mili-seconds sample dynamic instrumentation ipstrace interval samples size size ratio msec msec figure dynamic instrumentation tracing shmjoin reduction data collected dynamic instrumentation compared ipstracing shmjoin program sizes kilobytes assumes bytes sample demonstrated importance running programs full sized input sets toy files type bottleneck found water application changed ran larger dataset running production size runs showed importance building performance tools scale real applications large scale parallel machines finally prototype showed identify isolate performance problems searching partial performance data addition reduction amount performance data collected typically factor means approach scale large machines fact feel larger machines longer running programs instrumentation loop level ratios larger performance 
data time chapter dynamic instrumentation data collection critical problem parallel program performance measurement system understand performance parallel program collect data full-sized data sets running large numbers processors collecting large amounts data excessively slow program execution distort collected data noted chapter variety approaches collect efficiently performance data techniques limitations volume data generate granularity data collected chapter describe approach data collection based software instrumentation application program unlike systems insert instrumentation directly application program approach insert instrumentation data collect developed style performance data collection called dynamic instrumentation defers instrumenting program execution approach permits dynamic insertion alteration instrumentation program execution describe data collection model permits efficient detailed measurements program performance goals monitoring performance large-scale programs requires instrumentation system detailed frugal scalable collect information detailed permit programmer understand bottlenecks program frugal instrumentation overhead obscure overly distort bottlenecks original program instrumentation system scale large production data set sizes number processors detailed instrumentation system collect data component parallel machine correct bottlenecks programmers precisely utilization components hindering performance program addition understand part program data causing problem instrumentation system collect details combination components parallel machine interacting ways provide frugal instrumentation make data collection efficient collect data tool builders strive make data collection efficient reduce volume data collected tool builders forced select subset data collect existing tools require decisions data collect made prior program execution deferring data collection decisions program executing customize instrumentation specific execution goals frugal detailed opposition collecting detailed information requires lot data frugality afford collect dichotomy choice data collected styles collection summary counters timers tracing logging events execution summary information optimizes data volume accuracy tracing optimizes accuracy data volume developed hybrid sampling tracing low data volume sampling accuracy tracing periodically sample detailed information stored event counters timers intermediate values provide data make decisions change instrumentation scalable instrumentation requires data collection remain detailed frugal number resources system grows means handle increases application code size length program execution data set size number processors providing scalable instrumentation important nature bottlenecks parallel programs change dimension increased common program perform small number processors fail scale large number processors due increasing contention synchronization variables program run small input sets fail scale large input sets due increased memory requirements causing unacceptable paging behavior develop instrumentation system removes obstacles deter programmers system recompiling application performance tool unreasonable burden step required dynamic instrumentation run stand-alone pre-processor appends instrumentation library application binary instrumentation enabled modifying application binary image executing technique impact application insert instrumentation insert instrumentation overhead check enabled long-running programs re-execute program observe performance undesirable desirable monitor performance mission critical database server understand performance stop application enable monitoring combat problem point application execution programmer choose start measurement session running program start investigate performance features re-compiling starting measurements execution difficult provide static instrumentation environment easy incorporate dynamic instrumentation system portability interesting goal rich variety hardware software programming models parallel machines easiest achieve portability lowest common denominator features target platforms undesirable resulting tool ignores potentially important features specific machine chose design instrumentation environment modular manner permits implementations share commonality incorporate performance data unique features platform virtual memory statistics machines addition wanted advantage hardware facilities make implementation instrumentation efficient thinking machines cmprovides hardware combining network aggregating performance data node intel paragon hardware strategy makes build high level performance tools independent underlying hardware advantage unique features provide detailed information applications specific platforms dynamic approach makes collect wide variety performance data requires runtime decisions made data collect collect search model control dynamic instrumentation programmers tools visualizations manually control data collection design meet challenges goals detailed frugal scalable instrumentation needed make radical traditional performance data collection wanted instrumentation approach usable variety high level tools needed simple interface developed interface based abstractions resources metrics resources objects gather performance information metrics quantitative measures performance addition developed data collection model based periodic reporting counts times events inside application dynamic instrumentation interface abstraction provided dynamic instrumentation resources resources correspond axis search model separated hierarchies representing class objects parallel application resource hierarchy cpus processor resources created times application execution procedure resources created program monitored information data files discovered dynamically files opened abstraction metrics metrics time varying functions characterize aspect parallel program performance examples include cpu utilization counts floating point operations memory usage defined higher level performance tools performance consultant assist tool builders defined standard set metrics metrics computed subset resources system cpu utilization computed single procedure executing processor entire application data collection key question performance data gathering system data collected collected provide efficient detailed instrumentation system developed data collection model combines advantages tracing sampling tracing inserts instrumentation generate log interesting events program execution logged events generally include inter-processor communication procedure invocations trace record typically includes timestamps trace-based systems collect detailed information specific events program execution generate vast amounts data difficult manage approach collecting performance data insert instrumentation summarize interesting information counts times reported end program execution end-of-execution summary counters timers greatly reduces volume performance data collected summary data loses important temporal information usage patterns relationships components impractical collect performance data procedure phases execution synchronization variables processor large parallel machine approach record precise information relevant state transitions counter timer data structures structures periodically reported higher layers system periodic summaries accurate information time varying performance application requiring large amount data needed full tracing approach data collection statistical sampling statistical sampling involves periodic sampling program resources active procedure gauge program performance periodic summaries yield accurate information provided statistical sampling statistically sample program counter compute amount time spent procedure accuracy result depend sampling rate ponder fatemen describe number limitations statistical sampling approaches insert code start stop timers procedure entry exit accurately record time spent procedure case frequency summaries affects knowledge time accuracy time figure shows comparison tradeoffs approach data collection systems control volume data collected ways collecting information needed moment controlling rate collecting intermediate results periodically report performance metrics reasons isolate performance bottlenecks specific phases time intervals program execution search model partial data decide additional data collected isolate performance bottleneck dynamic instrumentation collects volume data accuracy intermediate resultsapproach temporal information event tracing bad good good statistical sampling good bad good end execution summaries good good bad periodic summaries good good good 
figure sampled counter timers types instrumentation calculates performance data periodically current data reported varying reporting rate affects rate decision making granularity phase boundaries affect accuracy underlying performance data collected data stored data structure called time histogram time histogram fixed-size array elements store values performance metric successive time intervals parameters determine granularity data stored time histograms initial bucket width time interval number buckets parameters supplied higher level consumers performance data program runs longer initial bucket width times number buckets run buckets store data case simply double bucket width merge adjacent pairs samples process repeats time fill buckets fixed size time histogram changing bucket width achieve efficiency volume performance data transferred application change bucket width change sampling rate correspond bucket width decreases frequency sampling length program execution increases result volume data transferred grows logarithmically time facilitates collecting detailed intermediate results chose software based instrumentation felt relying custom hardware impractical unnecessary impractical due cost time construct importantly ability dynamic instrumentation adjust data collected custom trace co-processors multikron tmp longer required role hardware based instrumentation efficiently count events visible software based instrumentation hardware counters measuring cache misses floating point operations bus utilization simple counters timers easily integrate performance data external sources operating systems variety performance data internally examples include statistics virtual memory statistics cpu time information read user processes number machines provide hardware based counters source performance information power cray y-mp sequent symmetry systems provide detailed counters processor events combine external information direct instrumentation precise information relate external events back specific parts program read cumulative number page faults process read counter procedure call compute number page faults procedure dynamically selected counters timers efficient data collection system permits gathering precise information programmers understand program performance addition data gathered sources combined points primitives predicates collect data insert instrumentation program developed simple defined set operations building blocks compute metrics desired resources keeping instrumentation operations simple optimize performance platform recording performance information application program accomplished points primitives predicates points well-defined locations application code instrumentation inserted points procedure entry procedure exit individual call statements future points extended include basic blocks individual statements primitives simple operations change counter timer predicates boolean expressions primitives determine primitive executed inserting predicates primitives correct points program wide variety metrics computed system consists primitives set counter add counter subtract counter set timer start timer stop timer predicates simple conditional statements consist expression action expression non-zero action expressions numeric relational operators operands predicate expressions counters constants point predicate inserted procedure call entry parameters procedure operands expressions predicate inserted procedure exit procedure return actions predicates calls primitives figure describes predicate facility examples primitives predicates combined create metrics shown figure shows metrics computes number times procedure foo called single primitive increment counter inserted entry point procedure foo shows metric compute number bytes transferred message passing procedure parameter add counter primitive multiplication expression fourth arguments expr actn expr non-zero execute actn actn statement call primitive operand counter constant parameter expr operand operator operand operand operator figure description predicate language predicates simple language consisting expressions conditional operands results type integer predicate language subset metric description language appendix message passing function compute number bytes transferred figure shows slightly complex dynamic instrumentation instrumentation points compute number times message passing routine called procedure foo top primitives maintain counter fooflag non-zero procedure foo active point increments msgssent variable increment occurs counter fooflag non-zero instrumentation mechanism previous section defined abstractions resources metrics collect data requests enable metrics specific resource combinations translated calls primitives predicates points application processes implementation instrumentation system divided parts part metric manager translates requests metric resource combinations primitives predicates part instrumentation manager modifies code sequences application foo addcounter bytes param param addcounter foocount sendmsg dest ptr cnt size figure showing metrics foo sendmsg dest ptr cnt size addcounter fooflag subcounter fooflag fooflag addcounter msgssent figure sample constrained metric monitored figure shows structure dynamic instrumentation mechanism instrumentation managersymbol application tables inst primitives code cpu time flops bytes metrics resources aggregate counters timers consumers performance data metric definitions metric manager runtime instrumentation application processes figure structure dynamic instrumentation system items top figure metrics resource aggregate counters timers interface provided higher level analysis tools metric manager metric descriptions translate requests metrics resources primitives predicates points instrumentation manager inserts instrumentation application program shown bottom metric manager metric manager roles translates requests metrics primitives predicates informs higher level consumers resources designed application machine independent translation metrics primitives metric definitions metric definition viewed template describes compute metric resource combinations consists series code fragments create primitives predicates compute desired metric create metric combination resources naive approach create metric definition resource combination require writing metric definitions choose divide metric definition parts base metric series resource constraints base metric defines metric computed entire application procedures processes processors resource constraint defines restrict base metric instance resource resource hierarchies request received compute number synchronization operations invoked specific procedure application allocate constraint counter positive desired procedure active insert instrumentation entry exit desired procedure update counter finally generate instrumentation entry point synchronization procedures check constraint counter positive constraint satisfied constraint counter positive metric counter incremented instrumentation inserted case shown figure metric definitions expressed metric description language interpreted request start collecting metric resource combination received higher layers result interpreting metrics description generate series instrumentation predicate primitive requests inserted application program application program continues execution invoke inserted instrumentation compute desired metric metric description language simple language consisting definitions metrics constraints list data type list data type enumerate instrumentation points complete description syntax metric description language appears appendix metric definitions provided higher level performance tools provide substantial library resource constraints specific resource hierarchy metrics metric definitions resource constraints generic apply platforms specific platform programming model metric definition consists clauses define units fold operator aggregation operator metric defined includes series clauses refer constraints metric includes definition counter timer metric series requests insert primitive operations points program syncfuncs barrier lock mutex metric syncops synchronization operations units operationspersecond foldoperator sum aggregationoperator sum constraint msgtagpredicate constraint processpredicate constraint procedurepredicate base counter foreach func syncfuncs append funcentry constrained addcounter syncops figure sample metric description figure shows sample metric definition compute number synchronization operations 
performed program consists list define synchronization procedures programming model metric definition line metric definition declares metric synchronization operations line defines units metric operationspersecond line defines fold operator metric sum determine adjacent samples metric combined time histogram folds options sum average fourth line defines aggregation operator sum aggregate multiple instances metric processes threads lines define constraints applied metric case message tag msgtagpredicate process processpredicate procedure procedurepredicate rest metric definition base metric base definition counter implicitly declared metric syncops foreach clause iterates procedures list syncfuncs inserts call addcounter counter syncops entry point procedures instrumentation inserted application enclosed pairs resource constraint defines counter implicitly declared constraint positive desired resource implicitly declared constraint active constraint implemented inserting primitive calls increment decrement counter status resource counter predicate guards execution primitive operations base metric compute metric constrained resource hierarchies procedure process constraint defines counter conjunctive expression counters predicate base metric primitives figure shows typical constraint clause clause defines counter positive selected procedure procedure resource hierarchy active foreach clause inserts statements subroutine call selected procedure clear set constraint counter statements insert assignment constraint counter entry return points selected procedure metric definitions written metric definition language hand translated programming language compiled dynamic instrumentation controller process implementing interpretor read metric description language evaluate metric definitions instrumentation requests arrive task metric manager resource discovery resource discovery process building resource hierarchies axis resource discovery application machine measurement session point procedures called types synchronization libraries linked application aspects resource discovery deferred program executing building resource hierarchy files read written files accessed collect runtime resource information instrumentation inserted application program insert instrumentation technique normal instrumentation record file names open requests instrumentation generation approach inserting data collection program execution means generate instrumentation code program execution modify program execution image incorporate desired instrumentation number technical hurdles overcome constraint procedurepredicate procedure counter foreach constraintcalls append precall setcounter procedurepredicate prepend postcall setcounter procedurepredicate append constraintentry setcounter procedurepredicate prepend constraintreturn setcounter procedurepredicate figure sample constraint clause runtime code generation develop code generation system efficient program execution achieved simple instrumentation primitives modify program insert instrumentation ensure correctness original program inserting instrumentation program accomplished simple runtime instrumentation compiler mechanism called trampolines generating code program execution idea number correctness debuggers built modify executing program assertion checking conditional breakpoints brown developed debugger cray computers provided feature kessler xerox parc built system dynamic modification program insert breakpoints work wahbe fast data breakpoints employ sophisticated program analysis techniques minimize overhead instrumentation data breakpoints massalin application code patch-up synthesis operating system modify program automatically schedule thread block bishop developed performance monitor patches binary program performance monitoring patches inserted breakpoint instructions required multiple context switches instrumentation point considerable performance penalty application runtime code generation performance instrumentation runtime code generation accomplished instrumentation manager performs functions identifies potential instrumentation points inserts primitives predicates application program potential instrumentation points discovered scanning application applications binary image scanning executable process monitor application starts execute instrumentation manager waits requests metric manager request arrives instrumentation manager translates small code fragments called trampolines inserts program define types trampolines base trampolines mini-trampolines figure base trampoline point active instrumentation base trampolines slots calling mini-trampolines relocated instruction slot slot instruction call global primitives inserted processes application slots call local primitives specific process structure makes easier hardware broadcast facilities install global requests identifying points instrumentation inserted accomplished analyzing instructions application area compiler writers make task easier helpful additional symbol table information code data program compilers place read-only data program text code segment creates problems postlinker tools correctness debuggers performance tools larus ball noted problem developed heuristics differentiate code data heuristics implementation solution sardent added additional information executable format facilitate post-linker tools save registers setup arg restoreregisters base trampoline mini trampoline program relocated instruction local global local global primitive starttimer function figure inserting instrumentation program base trampoline slots call instrumentation relocated instruction shows mini-trampoline instrumentation point multiple minitrampolines present multiple instrumentation primitives needed called point mini-trampolines code evaluate specific predicate invoke single primitive mini-trampoline primitive predicate point sample instrumentation point trampolines installed appears figure creating mini-trampoline requires generating machine instructions primitives predicates requested metric manager predicate language simple requiring handful instruction types instructions assembled instrumentation manager transferred application process variation unix ptrace interface addition code requested metric manager code generated save restore registers generated code called primitives overwrite extend points include basic blocks individual statements additional processor state condition codes saved restored figure shows sample mini-trampolines shows simple counter increment generated inline code code generated primitive figure shows instrumentation generated predicate primitive entry point sendmsg procedure figure statement translated branch based fooflag counter counter non-zero stoptimer predicate called mini-trampoline performance data collect move parallel machine location analyzed performance data moves parallel machine program execution compete resources program study perturb advantage cmsynchronous gang scheduling avoid problem end global scheduling quanta nodes context switch job arrange collect intermediate performance data point program stopped operating system execution context saved program execution state affected data transfer contend program machine resources restore save basetramp add load fooflg store fooflg restore basetramp call starttimer cmp save load fooflg load msgtme figure sample mini-trampolines technique dilation wall-clock execution time data transport virtually perturbing effect program execution waiting end quanta transfer data nodes works data buffer fills nodes case force timeslice end early wait end option perturbing effect machines synchronous scheduling model intel paragon model data transport difficult factor cost instrumentation manager make frequent instrumentation application execution scalable cost instrumentation operations grow number nodes parallel computer insert instrumentation instances procedure nodes cost inserting instrumentation single node achieve constant time instrumentation broadcast based version ptrace insert global instrumentation nodes unit time fortunately current version cmoperating system version ptrace runs nodes permits build broadcast based version ptrace cmapplication runs interleaved measured application machines provide hardware broadcast ibm construct software message spanning tree spanning tree technique achieves logarithmic time unit time cost machines form broadcast facility including intel paragon accessible application software cray meiko csefficient operations crucial dealing issue scale tools large parallel machines clock synchronization important question parallel tools synchronize timestamps processors full solution problem requires complex algorithms logical clocks instrumentation based counters timers located individual processors global time 
important dynamic instrumentation main concern combine samples sources processors processes threads form aggregate values combine data sources resource combination spans address space depend clocks processor provide timestamps samples granularity sampling infrequent compared clock drift typically sample metrics rate times clock synchronization algorithms ntp clock drift milli-seconds result clock drift bit uncertainty end time intervals fraction sample interval affected small aggregation complicated sampling sources potentially asynchronous samples arrive time necessarily cover time interval align samples combine data source interval time developed algorithm forward data received component sources specific time interval algorithm track earliest ending time recent sample source called current time source data ending time sample arrives re-compute current time sample advances current time aggregate sample time interval previous current time current time generated aggregate sample boundaries consecutive values current time current time computed sources result time interval aggregate sample constituent samples interval figure shows series samples arriving sources figure dashed box sample arrived inside box sample picture sample arrives source data sources simply stored likewise sample arrives data source sample stored sample arrives data sources aggregate sample generated aggregate sample sum weighted share recent sample source sum aggregation operator case noted section aggregation operator part metric description number bold shown sample component sample included aggregate aggregate sample case time interval fourth sample arrives current time advanced sample combined previous sample source case combine samples source single sample interval conclusion chapter approach data collection called dynamic instrumentation permits customized instrumentation inserted runtime outlined implement dynamic instrumentation ensure correctness original program introduced hybrid sampling tracing permits efficient collection intermediate temporal values counters timers full tracing chapter describe prototype implementation dynamic instrumentation evaluate performance prototype granularity primitive granularity applications aggregate sample samples time samples time samples samples time time figure aggregating samples sources figure shows arrival successive samples sources picture shows arrival sample sample shown dashed rectangle cases aggregate sample generated case sample completes set processes advances current time aggregate sample generated final case sample advance time results coalesced sample middle source chapter implementing dynamic instrumentation decided study performance dynamic instrumentation levels report cost individual operations accounting cost exact number instruction cycles costs provide insight abilities limitations techniques insights operating system designers facilities provide provide macro benchmarks examples cost facilities macro results based simple workloads meant general guideline mileage vary initial implementation dynamic instrumentation thinking machine cmparallel computer explain performance instrumentation bit implementation cmthe cmis distributed memory multiprocessor nodes connected network point-to-point broadcast communication machine controlled front end processor running modified version sunos operating system processor nodes consist sparc processors running mhz memory network interface chip node virtual bit free running clock micro benchmarks micro benchmarks show cost individual components dynamic instrumentation report cost basic instrumentation including cost executing trampolines cost primitives predicates detailed break primitive operations report cost instrumentation support functions including instrumentation generation instrumentation installation performance data transport detailed results provide insights limitations instrumentation techniques guidance operating system designers facilities needed support efficient instrumentation aspect performance instrumentation system studied overhead trampolines inserted primitive called figure shows cost executing trampolines time required base trampoline clock cycles machine mhz clock cycle nano-seconds time no-op slots call mini-trampolines row shows time required smallest mini-trampoline clock cycles required sparc save restore register instructions case register window overflow occurs source delay trampolines clock cycles long branches trampolines final component trampoline overhead time required setup parameters call predicate time ranges clock cycles depending type parameter item clock cycles base trampoline slots branches mini trampoline save restore registers branches parameters figure time execute trampolines table shows time clock cycles execute types trampolines time branch trampolines time setup parameters primitive intrinsic cost instrumentation time execute primitives figure shows primitives execution time clock cycles addition time execute simple predicate checks counter positive included measured times ranged clock cycles predicate clock cycles stop process timer results collected invoking primitive times tight loop recording elapsed time call counter timer passed primitive effects machine memory hierarchy factored results feel relative cost numbers compared cost primitives simple procedure calls machine oneargument procedure call returned argument clock cycles bottlenecks timers isolated time required execute part timer primitive figure shows timer primitives operations implement timer primitive clock cycles addcounter subcounter starttimer wall stoptimer wall starttimer process stoptimer process counter figure cost primitive operations cost clock cycles executing instrumentation primitives simple predicate tmc cmfirst row read clock time bit representation time wall process time bit registers involves reading bit free running network interface clock clock cycles reading high order bits memory low-order word overflow read high-order word check condition re-read clock overflowed result clock cycles read wall clock clock cycles read process time process time requires additional load subtraction factor time process running semantics timers permit multiple call starttimer made matching number stoptimer calls required stop timer time provide abstraction appears row maintain counter component timer primitives store time record timer started elapsed time stopped addition stopping timer involves extra steps compute elapsed time timer started shown compute elapsed row timers read asynchronous sampling function ensure timer consistent stopping problem starting timer compute store start time marking counter running permitting sampling time accomplished storing snapshot timer extra field fields updated overhead introduced maintain field shown row labeled consistency check breakdown cost timer operations shows largest time component primitive majority time cases spent reading clock time substantially reduced processors provided clock readable user level code register access speed risc processors exception dec alpha provide clock accurate cheap-to-read clocks critical architectural feature permit building efficient performance tools time clock cycles wall process operation start stop start stop read clock maintain counter store compute elapsed consistency check figure primitive times component numbers presented reflect time execute primitives slight modification cmoperating system made originally operating system required system call read clock overhead system call dominated cost timer primitives figure shows time execute timer primitives mapped clock system calls slowed timer primitives factor ranging overcame bottleneck adding system call operating system maps kernel clock data structure user address space read clock memory speed option implement timers timer library routines supplied thinking machines results timer calls appears figure timers factor times faster vendor-supplied 
thinking machine timers provide process wall timer applications dynamic instrumentation timer type time vitally important building performance tools accessing clocks fast requiring kernel call read clock unacceptably slow hardware support sufficient operating system designers provide access hardware clocks requiring system call overhead trampolines place improve implementation generated base mini-trampolines straight line code sequence reduce overhead clock cycles no-op slots branch mini-trampoline require additional complexity instrumentation manager primitive removed point primitives clock cycles significant fraction time primitives potential source overhead dynamic instrumentation mechanism process instrumentation requests unlike traditional compilers code generators run program executes dynamic instrumentation code generation interleaved program execution instrumentation request processing consists generating required instrumentation instructions transporting instrumentation manager application installing instrumentation generation metric instrumentation controllers chapter transport instrumentation developed broadcast based version unix default dyninstprimitive tmc timers trap mapped clock start wall stop wall start process stop process figure timer overheads tmc cmptrace command figure shows steps moving block instrumentation instrumentation manager nodes cmwe report overheads components instrumentation generation runtime code generator generate mini-trampoline number mini-trampolines instrumentation request varies greatly type request typical cost instrumentation request top half figure shows time required insert generated instrumentation application implementation scalable ptrace includes components data copied cmbroadcast network nodes fixed operation cost microseconds copy synchronize setup broadcast network byte cost microseconds copy data nodes broadcast network data transfered variation unix ptrace command controlling process application process ptrace step fixed cost microseconds due time make kernel call node check ptrace parameters ptrace per-byte cost microseconds reason high word copied generates cache flush instruction ensure instruction cache consistent measured performance data transport layer moves performance data nodes front end processor data path transport reverse shown figure data transport implemented similar mechanism scalable ptrace difference cmbroadcast network return data nodes data network performance data transport facility shown lower half figure operation overhead microseconds higher cmnetwork case due complex protocol employed cmmd data network instrumenation manager nodes nodal ptrace application front end processes figure communication paths scalable ptrace cost time microseconds component cmnetwork nodal ptrace instrumentation insert per-operation cost per-byte cost data transport per-operation cost per-byte cost figure overhead inserting instrumentation transporting data total time single move request direction sum fixed network ptrace costs number bytes transfered times sum network ptrace per-byte costs network per-byte cost microseconds lower due higher bandwidth data network ptrace component data transport operation cost microseconds higher instrumentation insertion case additional requests made read base bounds data buffer read application per-byte cost microseconds ptrace write performance cache flushed read operation front end processor transport mechanism bottleneck data pass reduce amount data transport mechanism hardware combining facilities cmto aggregate metrics components node approach ensures data required aggregate metrics remains constant machine size macro benchmarks micro benchmarks designed study performance primitive operations instrumentation system feel larger picture studied performance instrumentation system entire applications goal benchmarks study aggregate impact instrumentation system real applications conducted type benchmarks evaluated system performed tool makes multiple requests change instrumentation compared overhead dynamic instrumentation existing tools dynamic tests ran parallel applications cmthe application domaindecomposition method optimizing large-scale linear models program database simulator implements parallel grace hash join algorithm simulated shared-nothing environment programs written compared execution time un-instrumented application execution time instrumented application measured cost instrumentation overhead components instrumentation study performance consultant implementation search model system takes full advantage dynamic instrumentation drive instrumentation results tests shown figure column original execution time shows time run application instrumentation program ran hour couple minutes column execution time instrumentation shows total execution time dynamic instrumentation understand time spent divided overhead instrumentation categories null handler time actual handler time direct perturbation types overhead represent time spent end-of-timeslice handlers null handler time cost running end-of-timeslice code instrumentation enabled actual handler time time process ptrace requests collect data nodes differences applications actual handler time due larger volume performance data transferred database application cmuses synchronous gang scheduling overhead time handlers directly perturb performance program dilates execution similar time-shared jobs impact application execution type overhead represents direct perturbation application due instrumentation inserted modest amount applications performance consultant requests instrumentation requires set tests selected sequential applications compared overhead system unix profilers prof gprof made benchmark instrumentation cost compared existing techniques dynamic instrumentation enabled cpu time metric procedure program advantage dynamic instrumentation ability adapt data collection benefits attachable performance tool require application recompiled addition dynamic instrumentation collects intermediate values study time varying performance application traditional prof compiled ran program execution time components perturbation orig null actual directprogram inst handlers handlers decomp hash-join figure cost ptrace operations table shows overhead dynamic instrumentation performance consultant applications running cmall times minutes seconds prof gprof profiling enabled results running dynamic instrumentation prof gprof sequential applications summarized figure application multicomm math programming application solves multi-commodity network flow problem mutual capacity constraints written mixture fortran application dynamic instrumentation overhead prof gprof overheads prof gprof instrument internals math libraries default dynamic instrumentation instrument library routines application makes heavy integer divide library function sparc machines prof gprof higher overheads application tycho cache simulator written spends time repeatedly calling small procedures application dynamic instrumentation high overhead compared prof gprof overheads dynamic instrumentation higher perprocedure overhead invoke mini-trampoline start stop timer procedure called contrast prof increments counter periodic sampling approximate cpu time procedure gprof identify caller callee relationship procedure sequential macro benchmarks dynamic instrumentation higher per-operation overhead traditional unix profiling surprising dynamic instrumentation direct timing sampling overhead techniques procedure call frequency high blindly instrumenting procedures necessarily granularity data collection flexibility afforded dynamic instrumentation instrument levels procedures modules loops makes collect data granularity application conclusion performance implementation dynamic instrumentation current implementation runs thinking machine cmusing explicit message passing programs written fortran cost primitive operations instruction times application perturbation real applications tested dynamic instrumentation software based probes original overhead minutes seconds application time dynamic inst prof gprof multicomm tycho figure overhead sequential cpu profilers perturb execution application program chapter describe cost model characterize impact perturbation chapter instrumentation cost model strategy enabling instrumentation needed greatly reduces amount data collected perturbation caused instrumentation system instrumentation requests impact program performance manage perturbation caused instrumentation developed instrumentation cost system ensure data collection analysis excessively alter performance 
application studied model associates cost resource resources include processors interconnection networks disks data analysis workstations cost system divided parts predicted cost observed cost predicted cost computed instrumentation request received observed cost instrumentation enabled chapter describe cost models search model control impact instrumentation describe initial implementation parts cost model present results show closely predicts actual perturbation real applications essence predicted cost model performance metric techniques computing performance metrics chapter search model chapter implement model initial version predicted cost model direct cpu cost instrumentation reasonable approximation machines cmsince resources interconnect periods application stopped predicted cost dynamic instrumentation data collection overhead longer remains fixed entire program execution time request instrumentation received instrumentation overhead potentially changed addition types instrumentation requests decidedly effects program performance knowing expected effect instrumentation request performance tools programmers opportunity decide instrumentation request worth expected cost developed predicted cost model part dynamic instrumentation assess overhead instrumentation request information performance consultant control amount instrumentation enabled program section describe predicted cost model performance tools advantage predicted cost expected overhead collecting data compute metric focus combination resources compute predicted cost instrumentation request arrives instrumentation inserted application predicted cost expressed percentage utilization resource system required collect desired data important question resources included model individual copies resource counted separately cpu considered resource group processors track cost instance resource maximum predicted cost instance resource compare threshold gain experience predicted cost model evaluate choices make model concrete compute expected cpu perturbation dynamic instrumentation cpu time perturbation due insertion instrumentation primitives points program executable image predict cpu time perturbation single point program pieces information instrumentation inserted point cost executing instrumentation frequency execution point figure shows predicted instrumentation cost computed information multiply overhead predicates primitives point point expected execution frequency compute predicted perturbation sum information points predicted cost instrumentation request metric definitions enumerate instrumentation primitives predicates inserted based experiments conducted chapter precise cost instrumentation primitive trampoline request difficult part estimating frequency execution point data execution frequency points static model procedure call frequency associate point program expected frequency point static based point type model types points system calls message passing routines normal procedure calls part effort required port dynamic instrumentation define constants predicted cost conjunction observed cost critical values estimates perfect effectively application executes cost information updated based actual values application monitored computing predicted cost part story equal importance information fundamental question perturbation application tolerate applications tolerate amounts perturbation instrumented program longer representative original addition depending desired accuracy coarse measurement session final tuning programmers tolerate perturbation application accommodate varying programmer control amount perturbation tool inflicts application developed technique lets programmer measurement session set tolerable perturbation application system resource thresholds moderate instrumentation inserted application goal perturbation threshold ensure total cost data collected exceed pre-defined threshold resource request instrumentation received predicted cost computed request accommodated exceeding thresholds processed request deferred describe predicted cost search model manual search mode predicted cost simply acts check request hypothesis evaluated undue perturbation automated search mode interaction predicted cost model search process complex recall automated searching develop ordered list refinements test work list adding instrumentation evaluating results predicted cost model ordered list request instrumentation test test request deferred instrumentation overhead high stop requesting instrumentation program continue execute find refinement true sufficient observation time expired start refinements bottleneck hypothesis satisfied sufficient observation time passed stop set hypotheses move group list refinements perturbation threshold regulates number hypotheses considered time raising threshold search system tests higher perturbation decrease accuracy results changing threshold change hypotheses application processes primitive overheads predicted cost observed cost static event frequency observed cycle counts super scalar parameter cache parameters clock frequency metric manager instrumentation manager code count inst cycles figure computing predicted observed costs tested simply tested complementary approach increase speed search change order hypotheses considered decrease total instrumentation batches required recall instrumentation requests search model ordered based set heuristics promising refinements current bottleneck top list re-order refinements haphazardly addition finding ordering variation bin packing problem npcomplete multiple resource constraints instance multi-dimensional bin packing problem problem np-complete heuristics divergence optimal packing linear number dimensions resources re-order refinements future make small decrease number instrumentation batches considered observed cost predicted cost based model instrumentation perturbs program execution good idea check model matches reality observed cost model observed cost affect application collecting data purpose check overhead data collection exceed pre-defined levels exceeds levels report higher level consumers data observed cost acts alarm system report instrumentation hand threshold higher predicted cost actual cost differ predicted cost resource contention application data collection affect cost collecting data consume large percentage resource interconnection network application resource impact application small alternatively data collection resource application heavily major impact application performance perturbation effects difficult fully predict priori measuring instrumentation vital uncertain parameter predicted cost model execution frequency point result key goal observed cost model verify compute observed cost model add extra instrumentation instrumentation record execution time information periodically sampled application based values compute observed cost aggregate perturbation exceeds user defined threshold report event figure shows observed event execution frequency compute predicted cost observed cost model performance metric characterize type bottleneck parallel program developed isolating bottlenecks parallel programs search model difference bottleneck interested created data collection system programmer treat potential bottleneck application bottleneck search model level search model observed cost model expressed additional hypotheses axis isolated specific resources axis characterized temporally axis closely related topic part cost model work perturbation compensation goal perturbation compensation reconstruct performance un-perturbed execution perturbed techniques generally require trace based instrumentation system postmortem analysis reconstruct correct ordering events approach differs factor perturbation avoid predicted cost model quantify observed cost model implementation observed cost purpose observed cost model report time consumed instrumentation simplest implement add additional instrumentation system record time spent executing instrumentation code overhead required execute meta-instrumentation expensive expensive instrumentation measure cheap accurate measure cost instrumentation developed implementation observed cost model approximate information requires additional instruction base mini-trampolines conducted tests verify accuracy approximate cost model found wide variety degrees instrumentation inserted measured program running time instrumentation original running time observed cost estimate implement observed cost model added additional instruction trampoline record number machine cycles required execute trampoline components instrumentation trampolines primitives small number 
primitives performance measured platform chapter measured cycle counts observed cost instructions trampoline generated dynamic instrumentation system needed track number cycles required trampoline generated cost mini-trampoline machine cycles cost trampoline primitives calls cost base trampoline fixed instruction sequence executes trampoline includes code increment total observed cost cycle count total observed cost stored register dedicated task sparc abi reserved registers purpose platforms memory perform register scavenging part pre-pass make program prior running system observed cycle counter precise count number instructions executed instrumentation convert instruction counts time observed cost approximation impact super-scalar processors caches approximated super-scalar processors issue instruction machine cycle dependencies operands instructions rarely instructions issued maximum rate likewise memory hierarchies add uncertainty execution time due cache misses instrumentation instructions data initial implementation approximations convert cycle counts time processor sequential experiments two-way super-scalar processor decided pick single constant factor characterize degree instrumentation super-scaling based tests typical instrumentation sequences instructions cycle observed cost model alternative analyze instrumentation sequences develop precise estimate number cycles required instrumentation block wang framework modeling instructions functional unit requirements accurate estimate account cache time measured times instrumentation primitives measurements resulted approximately cache miss clock primitive alternative compute cache misses model cache complex model super-scalar instruction times final step converting counted cycles time divide cycle count clock frequency machine integrating implementation observed cost dynamic instrumentation easy instrumentation system designed support reading external sources performance data hardware counters simply treat observed cost metrics normal dynamic instrumentation mechanisms report data higher level consumers performance data treating observed cost normal metric facilities metric description language constrain metric resource combinations application implemented observed cost metric interested tracked actual perturbation applications investigate ran sequential programs floating point spec benchmark suite parallel application program unix time command measure cpu time required execute program dynamic instrumentation ran program instrumentation measured cpu time program recorded observed cost model difference sum un-instrumented cpu time observed cost measured cpu time instrumented program error observed cost program measured performance levels instrumentation enabled base procedure profiling performance consultant base performance consultant full base amount instrumentation inserted starting dynamic instrumentation consists instrumentation record start end application application run child process unix ptrace facility procedure profiling consisted turning cpu metrics user supplied procedure application performance consultant base case enabled initial instrumentation performance consultant search bottleneck application performance consultant full case ran performance consultant fully automated mode turn instrumentation needed interested assessing accuracy cost model cost model control number refinements considered completely overwhelm application instrumentation enabling refinements compromise configured performance consultant ten refinements refinements sequential applications measured ear fpppp doduc applications selected reflect variety programming styles instrumentation inserted procedure boundaries wanted cross section procedure granularity procedure call frequency measured program tomcatv represent low end procedure call frequency measurably perturb programs run idle sparcstation running mhz results application ear shown top figure program consists files functions un-instrumented version program runs ten minutes averages procedure calls execution results shown table show observed cost metric cpu time application cases total perturbation ranged cpu time un-instrumented version program measured fpppp quantum chemistry benchmark electron integral derivatives consists files procedures un-instrumented running time program minutes average procedure calls observed perturbation program ranges difference measured observed cost metric ranges percent program doduc monte carlo simulation time evolution thermo-hydraulical model nuclear reactor composed files procedures program averages procedure calls un-instrumented version runs minutes perturbation program ranged percent application cpu time program largest error observed cost metric performance consultant full search case reason divergence observed overhead measured overhead due additional overhead required insert delete instrumentation program conducted number experiments verify fact unable fully account overhead continuing investigate occurs fourth program measured parallel graph coloring application running node partition thinking machines cmthe nodes cmare mhz super-scalar sparc processors program written explicit message passing library cmmd provided tmc comparison observed cost model values actual perturbation program appears figure uninstrumented version program ran seconds actual perturbation ranges measured observed version time overhead overhead difference time percent time percent percent application ear un-instrumented base procedure base full application fpppp un-instrumented base procedure base full application doduc un-instrumented base procedure base full figure measured observed overhead table shows difference instrumented un-instrumented cpu time measured overhead observed cost model observed overhead values sequential applications final column shows difference percent cpu time observed overhead un-instrumented time measured overhead times shown seconds cpu time program enabling dynamic instrumentation system slowed program due addition measurement process periodic ptrace poll application performance data implementation predicted cost interested evaluating quality predicted cost model implementation predicted cost model based techniques compute cycle time trampoline measured observed version time overhead overhead difference time percent time percent percent un-instrumented base procedure base full figure measured observed overhead parallel application table shows difference measured overhead observed cost model observed overhead parallel graph coloring application times shown seconds observed cost model counting time trampoline executed estimate event frequency values calls user procedures calls system library routines gauge effective predicted cost model ran applications study observed cost metric measured predicted cost metric numbers based static predicted cost information include compensation based observed cost predicted cost ear program shown figure errors cases actual cpu time program procedure call case number surprising predicted cost model point execution frequency estimate calls procedures program numbers cases typical amount type instrumentation inserted search model middle section figure shows predicted cost fpppp application cases estimated cost measured cpu time addition largest error procedure profiling case part figure shows predicted cost doduc application errors predicted cost model ranged case largest error case instrumenting cpu time procedures finally measured predicted cost compared actual perturbation parallel graph coloring program figure shows results case case interesting predicted cost closer measured predicted version overhead overhead difference time percent time percent percent application ear base procedure base full application fpppp base procedure base full application doduc base procedure base full figure measured predicted overhead table compares measured overhead predicted cost model predicted overhead sequential applications times shown seconds measured cost sequential applications reason lies number frequency procedure calls program author wrote compare graph coloring heuristic time spent graph library instrumented study non-library procedures calls instrumented happened match predicted cost model chapter observed 
predicted cost model regulate impact performance instrumentation application studied quality cost model real programs chapter combine search model dynamic instrumentation cost models measure performance real applications measured predicted version overhead overhead difference time percent time percent percent base procedure base full figure measured predicted overhead parallel application table compares measured overhead predicted cost model predicted overhead graph coloring application times shown seconds chapter bringing previous chapters components required build performance monitoring environment large-scale parallel computing search model dynamic instrumentation data collection cost model chapter bring ideas describe ideas integrated parallel performance monitoring tool report performance real programs written application programmers running thinking machines cmfor applications found bottleneck accounted execution time program addition cases instrumentation perturbation application un-instrumented running time program case studies interested judging quality tool programmer tool located performance bottlenecks fix implementation ideas presented earlier chapters thesis incorporated parallel program measurement system called paradyn developed wisconsin outline paradyn structured illustrate components thesis interact real implementation describe paradyn user interface purpose provide idea performance tool incorporates search model dynamic instrumentation describe additional features incorporated paradyn make tool measuring programs paradyn ongoing project implementation group effort paradyn runs cmand network workstations running pvm paradyn performance tools suite modular collection tools measure understand performance large-scale parallel programs module defined interface communicate module module interface defined interfaces additional components easily added system figure shows structure paradyn system performance consultant implementation search model dynamic instrumentation integrated central part tool multi-threaded process performance consultant user interface threads communicate data collection visualization processes interactions tool user handled user interface manager thread requests collect data notifications resources delivery performance data handled data manager thread visualizations separate processes makes requests main paradyn process rpc interface visualization process thread paradyn main process handle requests user interface data manager threads performance consultant thread main paradyn process requests data collection receives performance data interface data manager visualization threads dynamic instrumentation implemented paradyn daemons paradyn daemon machine communicate main paradyn process rpc interface design philosophy paradyn module request module architecture means component system drive tool manual search mode user user interface manager thread requests data collected visualizations displayed automated mode performance consultant thread makes types requests addition visualizations enable additional data collection transparently thread driving system irrelevant threads tabular summary cpu messages visualizations paradyn paradyn daemon manager application processes metric manager manager application processes user interface performance consultant visualization manager data manager table visualization histogram visualization instrumentation instrumentation metric manager figure architecture paradyn tool suite user interface paradyn developed consists window defining application run displaying trees resource hierarchies axis additional windows response actions user typical paradyn main window appears figure options top display pull menus provide ways application measure start performance consultant start visualizations addition top row includes pull menu create visualizations time histograms tables middle area shows resource hierarchies axis forest trees row buttons bottom control application execution query status performance consultant enabled additional window appears show search process sample window appears figure top row series pull menus configure search middle area space text messages report status search sufficient observation time elapsed set refinements considered largest area graphical illustration search history graph graph color coded state node graph states include true tested false un-tested tested bottom window buttons control search process build usable performance tool implemented additional features earlier thesis needed run performance consultant machine users accommodate added load compensation factor thresholds axis search model compensation factor defined fraction time measured application running cmcomputing compensation factor easy machine synchronous gang scheduling figure main paradyn control window timer record fraction wall time user application running paradyn daemons periodically sample report performance consultant added feature user bottleneck interesting continue searching bottlenecks provide interfaces feature user select single node search history graph request refinements made node specific control combination axes permit users select nodes axis refinement axis focus involving node considered interface types bottlenecks resource future plan add similar ignore option axis permit types bottlenecks combinations ignoring node implemented changing ordering function determines refinements evaluated result semantics ignore request defer testing selected refinement refinements considered definition permits ignore mechanism control order refinements considered feature case studies process resources considered refinements saving process refinements end spmd style programs significant bottlenecks diffused processes graph coloring application application measured paradyn system graph coloring program called matchmaker match-maker programs written phd student wisconsin compare parallel graph coloring algorithms match-maker branch bound search central manager brokers work idle processors tmc explicit message passing library cmmd program written lines code files part application contained libraries provide data structures communication routines common graph coloring algorithms author algorithm specific part match-maker program consists lines files decided measure performance algorithm specific part program performance consultant ignore axis option suppress instrumentation library uninstrumented procedures separately tracked dynamic instrumentation time spent libraries automatically folded calling routines un-instrumented version program runs seconds -node cmpartition ideas presented thesis started application paradyn enabled performance consultant measure application performance consultant run automated mode discovered cpu bottleneck program seconds execution screen dump performance consultant window graph coloring application appears figure step root hypothesis bottleneck program evaluated types bottlenecks considered synchronization cpu virtual memory instrumentation point cpu bottleneck identified step refinements hypothesis considered hypothesis program cpu bound tested confirmed performance consultant refined cpu bottleneck specific module program noncom bottleneck isolated procedure postcallbookwork module problem diffused processes performance consultant refine bottleneck verified output performance consultant displaying time histogram table cpu time application procedure postcallbookwork procedure postcallbookwork responsible execution time program find bottleneck performance consultant enabled metrics total combinations axis number resource combinations indication variety hypotheses axis combinations considered total samples collected sampled instrumented version program ran seconds collecting samples average low volume data collected impressive idea data needed collected data gathered metrics enabled foci considered entire execution application case dynamic instrumentation collected samples metrics resource figure performance consultant search graph coloring application bold nodes show hypotheses foci true refined bottleneck shown due high cpu utilization file noncom resultiperformance visualization usability reusability diane rover department electrical computer engineering egr msu rover venezuela workshop hpc rover msu acknowledgements nsf acidarpa dabt -cco-pis matt mutka kurt stirewalt students aleks bakic kuk-jin lee abdul waheed rover msu outline performance visualization zation instrumentation systems visualization systems pgrt infrastructure visual objects voml uniform resource visualization components composition rover msu outline performance visualization instrumentation systems visualization systems pgrt infrastructure visual objects voml uniform resource visualization components composition rover msu performance visualization visualization process forming mental picture vision present sight software visualization typography graphic design animation modern human-computer interaction computer graphics technology facilitate human understanding effective computer software rover msu performance visualization performance visualization type software visualization includes aspects hardware performance computation system visualization visualization concurrency specific concern parallel distributed systems evaluate performance verify correctness diagnose problems gain insight structure execution behavior rover msu performance visualization static representation system state structure content large database dynamic execution behavior runtime control flow memory usage interprocessor communication graphs metrics utilization traffic application-specific views data computations rover msu examples ibm system configuration showing activity system including process tree view histogram process runtimes strip charts process system activities chapter bykimelman rosenburg roth stasko domingue brown price software visualization programming multimedia experience mit press rover msu ibm system configuration rover msu examples lucent technologies seesoftcode display showing overview files statistics code age newest code red oldest blue blue green files represent stable code seesoftvisualizes text files mapping line thin row colored statistic interest derived version control systems static analysis profiling chapter eickinstasko domingue brown price software visualization -programming multimedia experience mit press rover msu lucent technologies seesoftcode display rover msu examples georgia institute technology polka animation parallel minimum spanning tree program left view shows graph spanning tree growing inside view shows closest data structure maintained program chapter bykraemerin stasko domingue brown price software visualization -programming multimedia experience mit press rover msu georgia tech spolka animationolka animation rover msu examples stanford rivet visualization thread scheduling algorithms argus parallel rendering library visualization combines gantt charts percpu per-thread scheduling data milestones rendering process dynamic view theframebuffer generated argus dynamic display framebuffer synchronized data displayed data windows familiar application-based context user brushing views disparate views coherent hanrahan rivet project stanford http wwwgraphics stanford projects rivet rover msu stanford rivet visualization rover msu visualizations created visualizations rover msu steps visualization derive information sources software development environment static analysis program data collected program execution instrumentation systemcollects data preprocess analyze information format conversion profiling event-ordering detection abstract events global states represent display program system graphically visualization systemsupports creating views display issues effectiveness concurrency scalabililty application-specificity rover msu outline performance visualization instrumentation systems visualization systems pgrt infrastructure visual objects voml uniform resource visualization components composition rover msu instrumentation systems baseline reduced instrumentation system kernel brisk lightweight distributed portable flexible lis-ism model low-intrusion techniques lis node internal sensors user processes shared memory external sensor ism node tie tools corba extension ism lis execution environment tool integration environment rover msu performance visualization instrumentation systems visualization systems pgrt infrastructure visual objects voml uniform resource visualization components composition outline rover msu visualization systems history earliest visualization systems performance visualization tools paragraph late application-specific visualizations concurrent programs early integrated frameworks diagnosing performance problems tau paradyn pablo mid rover msu visualization systems taxonomy scope range programs machines system input visualization system visualize concurrent features content abstraction subset information program machine visualized system code versus control flow diagram method specification visualization systems provide fixed visualizations user customize visualizations chapter price instasko domingue brown price software visualization -programming multimedia experience mit press rover msu visualization systems taxonomy continued interface interaction user system interact control navigation visualization important large programs data sets presentation form system convey information medium graphical elements visualization system provide facilities eliding information synchronizing multiple views rover msu visual displays design practices characteristics context meaning information user relationships information perspective semantic context subviewmapping scaling size dimensionality graphical views data sets large number processors duration execution large multi-dim multivariate representation macroscopic microscopic views macro micro composition reading adaptive graphical display display manipulation composite view chapter heath malony rover instasko domingue brown price software visualization -programming multimedia experience mit press rover msu visual displays design practices continued perception interaction interpretation displays user support tool exploring execution behavior views options perception cognition observing patterns user interaction comparison relationships views representations gain insight behavioral characteristics multiple views small multiples cross-execution views rover msu visual displays design practices continued extraction information selection presentation information large data sets reduction filtering clustering encoding abstracting separating information seesoft polka rivet examples visualizations design practices classified rover msu usability visualization system graphical display effective definition iso definition effectiveness efficiency satisfaction users achieve goals environments iso dis dis software usability computing systems rover msu usability developer push usability engineering user-centric design parallel tools consortium researchers developers users user pull task force requirements quirements hpc software tools guidelines including software tools hpc procurements nacse projects hpcreqts performance tuning debugging support rover msu reusability definition extent software component adaptation multiple problem solutions reuse synthesizing solution problem based predefined solutions subproblems implementing software systems pre-existing software archive software artifacts reduce code development effort increase productivity improve quality software rover msu reusability issues design reuse expensive tools originate research labs likelyto reuse goal object-oriented component-based approaches java dcom impact reusability favorably tools pablo re-usable modules type reuse conflict usability typical user tool highly configurable complex user types reuse feel gui tend affect usability positively development tools design-for with-reuse strategy long-term outlook interoperable tools extensible environments rover msu outline performance visualization instrumentation systems visualization systems pgrt infrastructure visual objects voml uniform resource visualization components composition rover msu pgrt infrastructuret infrastructure interng single procedure postcallbookwork combinations performance consultant required find bottleneck interested comparing volume performance data collected dynamic instrumentation event based tracing system ipssince ipsdoes run cmwe needed estimate size trace log created ipsstyle instrumentation made 
preted prototypes wrappers libraries system guile libraries visual object ism pgrt-tie rover msu integrates software components language-based glue-and-library model based guile software environment scheme-based system extensive library interfaces features multilevel integration options interfaces instrumentation systems visualization tools xdr specificationsxdr specifications tie tool integration environment rover msu visual objects rover msu event processing information rendering architecture high-level visual objects hlvos epiraa rover msu visual object markup language voml prototyping hlvos sgml 
separate execution application turned metrics count number procedure calls made number messages application events ipslogs occur frequently application execution computing trace size events approximate size ipstrace file application made procedure calls messages result ipstrace execution megabytes dynamic instrumentation samples totaled bytes factor full tracing measured impact dynamic instrumentation application quantified perturbation ways observed cost model record perturbation application observed cost seconds perturbation application time histogram cpu utilization application observed cost appears figure compared running time un-instrumented version program version performance consultant running measured running time program inserting calls vendor supplied timer routines start end application reported total time application executing measured running time program instrumentation seconds perturbation numbers encouraging reasons perturbation range reasonable observed cost model provided accurate estimate actual perturbation finally wanted quantify perturbation application caused generating instrumentation code application execution added code instrumentation system record statistics code generation application dynamic instrumentation generated inserted mini-trampolines seconds insert instrumentation application measured paused impact inserting instrumentation figure dips cpu observed cost curves due dynamic instrumentation pausing application points sufficient observation time expired performance consultant disabling instrumentation requesting instrumentation batch refinements tested dips visually noticeable impact search system time application paused included non-execution time load compensation factor load compensation factor normal metric system users plot time histogram loss performance due users machine dynamic instrumentation code generation msolv application application measured called msolv msolv domain-decomposition method optimizing large-scale linear models application consists lines code programming language figure time histogram graph coloring application figure shows cpu time observed cost graph coloring application observed cost shown total instrumentation processors partition color original addition program makes sequential constrained optimization package minos choose instrument application specific code ignore axis option suppress instrumentation library approach treats library routines black box records performance program directly terms procedures written author application informal observations users performance tools generally programmers start measurement session measuring performance dynamic instrumentation application chapter interested instrumentation measure instrument library routine result perturbation numbers application chapters un-instrumented msolv runs hour seconds -node cmwe ran program performance consultant automated search mode performance consultant found bottlenecks program initialization phase found synchronization bottleneck nodes started bottleneck lasted minute refined performance consultant initial computation phase cpu time bottleneck module minos part identified performance consultant located key synchronization bottleneck bottleneck persisted rest program execution search history graph isolation bottleneck appears figure locating problem involved step refinement performance consultant figure performance consultant search msolv application discovered synchronization bottleneck program identified bottleneck due excessiveblockingtime opposed frequent small synchronization operations synchronization bottleneck isolated file msolv fourth bottleneck refined procedure active node problem trivially isolated single partition partition refinement labeled mendota partition manager node visible screen dump isolating bottleneck specific machine application machine trivial problem diffused processes isolation bottleneck bottleneck responsible running time program source problem processes periodically exchange values parallel prefix operation add synchronization delay due load imbalance processes msolv application measured instrumentation perturbation observed cost model perturbation program seconds difference execution time uninstrumented version program version run performance consultant seconds runtime application program varies run run instrumentation overhead application normal variation runtime dynamic instrumentation instrumentation overhead low due fact bottleneck found instrumentation required measure synchronization time critical procedure figure time histogram msolv application curves show cpu time synchronization waiting time msolv program program run partition applications elapsed wall time application hours color original finally wanted compare amount data collected dynamic instrumentation application amount trace-based system ipswould collect application made procedure calls messages result ipswould generate megabytes trace data dynamic instrumentation delivered samples totaling bytes factor full event tracing conclusion building performance tool incorporate ideas thesis time consuming worth effort demonstrate ideas combined complementary ways addition valuable lessons learned include load compensation factor performance consultant make tool usable production parallel computers important provide visual feedback automated performance tool working users author impatient suspicious providing visual cue happening important paradyn types visual feedback search including dynamic update search history graph time histograms refinements specific processes refinements considered large number processes application chapter presented case studies measuring real applications written researchers wisconsin implementation search model dynamic instrumentation cases isolate significant bottlenecks programs low perturbation application chapter summarize contribution thesis outline areas future work chapter conclusions future work conclusions thesis addressed problem locating source performance bottlenecks large-scale parallel distributed applications identified key problems solved monitor large-scale applications identifying bottleneck necessitates collecting detailed information collecting data introduce data collection bottlenecks users inundated volumes complex graphs tables require performance expert interpret solve problems developed search model combines dynamic on-the-fly selection performance data collect decision support assist users selection presentation performance data make implement search model developed monitoring technique parallel programs called dynamic instrumentation presented prototype implementation ideas showed prototype efficiently find performance problems real applications conclusion thesis on-line performance debugging large scale parallelism mandatory search model closes loop data collection analysis searching performance problem iterative process refining answers questions application performing poorly bottleneck problem occur answer question tests conducted identify type bottleneck synchronization computation answering question isolates performance bottleneck specific resource program disk system synchronization variable procedure answering problem occurs isolate bottleneck specific phase program execution dynamic instrumentation differs traditional data collection defers selecting data collect program running permits insertion alteration instrumentation program execution features type data collection combines low data volume sampling accuracy tracing instrumentation precisely count time events inserted dynamically modifying binary program counters timers periodically sampled provide intermediate values search model based intermediate data made instrumentation collect information isolate bottleneck prototype implementation search model dynamic instrumentation prototype runs thinking machine cmand network workstations running pvm presented studies demonstrate effectiveness ideas presented thesis study tool identified bottlenecks real programs orders magnitude data traditional techniques study dynamic instrumentation monitor long running programs introduced perturbation data cdocument type definition higher level elements relations elements reusable software components component semantics embedded scheme code voml head body visual-object event-declarations data-event info-structures control-structures utility-code view-initializations view event-processing ep-component preprocess-inputs info-rendition ir-component rover msu pgrt displays rover msu outline performance visualization instrumentation systems visualization systems pgrt infrastructure visual objects voml uniform resource visualization components composition rover msu uniform resource visualizationrm resource visualization urv component-based strategy constructing performance visualizations composing system-level views sharing visualization design knowledge describing visualizations interfaces uniformly monitoring analyzing parallel distributed systems viewing resources levels coordinated framework rover msu visualization construction independently executing components resource-monitoring component physical entity processor logical entity array visualization component connected collaboration mapped epira written voml rover msu system visualization scale hierarchy heterogeneity dynamics application devices level node resource rover msu application devices level node resource urv rover msu application devices level node resource urv rover msu application devices level node resource urv rover msu application devices level node resource urv rover msu visualization standards resource mon component monitoring control services resource rover msu visualization standards resource mon component monitoring control services resource visualization component implementation voml high-level visual object rover msu visualization standards resource mon component monitoring control services resource visualization component implementation voml high-level visual object component interface set services provided required components rover msu plug-in metaphorphor collaboration description connection services complex binding names services buffer types synchronization single resource multiple visualizations rover msu plug-in metaphor standardization specialize generic visualization interface collaboration services provide generic data flows reuse visualization resource family shares interface resource interface defines services rover msu epira mapping visualization components resource-moncomponents collaborations info control structures irep info control rover msu visualization design knowledgewledge description component concept component content concept implemented specialized context domain component applied searchable component specifications reusable design features visualization principles rover msu visualization composition composition creates system-level views representing multiple resources resources res res visualization issues synchronization abstraction urvs resources rover msu visualization composition synchronization separate views incorrect correlations network traffic composition synchronize join spatially temporally single graph based common independent variable rover msu visualization composition abstraction separate views hide multidimensional information relationships network traffic composition synthesize information process matrix network traffic rover msu visualization composition types union set concrete transformation rules transformational approach binary function takes urvs constructs urv composition transform matches multiple urv view descriptions replaces synchronized functionally equivalent view synthesis design activity supported framework rover msu union aggregate res res unchanged collaboration replaced transformation visualization replaced transformation aggregate separate visualization components vis vis replaced visualization vis rover msu union services define interface aggregate resource aggregrate resource coupled collaboration names services interface visualization component plug-compatible rover msu synthesis conscious activity human designer automated fully indexing ofurvsand visualization components classification scheme designer specifies set search attributes guide search component rover msu synthesis rover msu synthesis rover msu instrumentation system support challenge integration performance data unrelated resources ism proxy resources resource monitors register ism rover msu features urvrv usability reusability multi-level composable reusable distributable components urv software architecture auniform descriptions views hardware software resources aframework developers supply catalog urvs arule-based visualization composition aaccess performance views acapture visualization design practices 
ollection cost model showed track performance real applications actual cpu time finally combined search model dynamic instrumentation cost model ran prototype system real programs ideas presented thesis combine complement individually search model applied existing post-mortem performance tools simulated machines environments model viewed methodology performance debugging programmers built system dynamic instrumentation collect performance data including visualization delaying instrumentation decisions program execution broader variety data made programmers cost request future work ideas presented thesis open designing building 
performance tools dynamic automatic previous approaches ideas opportunities exist exploration investigation section identify questions briefly describe solved search model remain opportunities enhance search model search model measures performance component resource hierarchy axis procedure process machine performance program understood relationships components single resource hierarchy dynamic call graph relationships procedures important represent type information plan extend axis item resource hierarch combinations resources permit expressing call graph information types relationships resources sender receiver pairs message traffic additional major area future work lies explanation system chapters explanation system relate performance information back users initial version primitive handles text based explanations full implementation explanation system requires development sophisticated visualization interface support performance consultant creating altering visualizations addition work figure visualizations good types bottlenecks add information hypotheses axis minor enhancements decision support work search model extended support searching multiple performance bottlenecks identify bottleneck program include simple mechanism user ignore bottleneck continue searching users mark nodes searching history graph ignore complex problem searching multiple bottlenecks independent bottlenecks exist application result consumes large fraction program time satisfy test conditions case scale thresholds permit searching type double bottleneck type multiple bottleneck arrises due multi-programming parallel computers reason parallel program run fast desired due users machine time space sharing due cost inherently shared nature parallel computers important performance tool recognize compensate non-exclusive machine quantify performance degradation due competition processes information operating system long application processes waiting due processes system cmsince synchronous gang scheduling execution timer information measuring interference difficult non-gang scheduled environment potential starvation process process application de-scheduled area future work search model investigate interactions current components model search model parameters affect performance minimum observation time sufficient observation time perturbation threshold hysteresis threshold plan investigate impact changing parameters real programs observation time parameters affect quickly search model refine bottleneck interaction perturbation threshold controls refinements considered sufficient observation time determines long refinement considered dynamic instrumentation work enhance dynamic instrumentation instrumentation requests generally enabled time multiple requests overlapping instrumentation true resource constraint expressions metrics constrained procedure reduce amount instrumentation inserted application perturbation taking advantage common instrumentation expressions type optimization similar global common expression elimination inter-procedural optimization traditional compilers aspect dynamic instrumentation improved granularity instrumentation requests dynamic instrumentation works level procedure calls applications scientific code distinct operations single procedure provide meaningful performance data types programs dynamic instrumentation extended work loop statement levels design dynamic instrumentation permits technical details resolved machine state saved making call dynamic instrumentation larger procedure calls registers volatile processor condition codes undefined procedure assumptions hold instrument level requires information program determine live registers condition codes information gathered additional analysis binary image provided compiler alternatively save machine state expensive simple area current implementation dynamic instrumentation improved quality instrumentation code generated instrumentation complier naive generate code instrumentation request register delay slots utilization improved techniques required understood simple implementation issue enhancements local optimization common instrumentation expression optimizations global dynamic monitoring initially concentrated problem monitoring tuning single application closely related problem monitoring tuning machine cluster collection programs workload plan investigate ideas tune machines capacity planing area future work apply ideas techniques presented thesis applications parallel computing computer networks viewed large distributed program programs networks performance problems due coding inefficiencies resource utilization imbalances large computer networks continuously evolving capacity planing important problem addition driving problems efficient data collection information overload exist domain plan apply ideas developed dynamic monitoring decision support computer networks idea thesis broader application time histogram time histogram data structure generalized dynamic histogram variables time x-axis dynamic histograms good data structure recording distribution frequency events range distribution data arrives fold adjacent buckets bound distribution axis exceeded fold operation simple combines pairs complete buckets addition style folding reduces aliasing samples due folding application dynamic histograms record memory statistics amount memory program program running finally time arrived integrate performance correctness debuggers contributions thesis moving performance debugging interactive execution time activity dynamic code generation means hazy line correctness performance debugging vanishing activities taking place program execution techniques dynamic instrumentation insert code runtime provide efficient mechanism conditional breakpoints addition dynamic instrumentation enable widely debugger print statements runtime appendix damping test oscillations tests boolean expressions metric constant threshold test evaluated metric test close test threshold result test oscillate back true false oscillation undesirable search model search back test false searching backing creates excessive requests turn instrumentation chapter introduced hysteresis parameter damp oscillations addition hysteresis parameter matter metric test varies frequency oscillations damped show true constant threshold test false true denote metric time assumption true metrics compute threshold threshold hyst time figure graph cumulative metric time shown figure denote cumulative function time hyst hysteresis constant hyst denote time ith occurrence test changing false true time average metric larger values shown figure definition time likewise denote time ith transition test true false time average metric threshold multiplied hysteresis constant hyst hyst cumulative metric hyst true time order holds non-zero values monotonically increasing time ordering combine hyst combine hyst hystt combine hystt reduce recurrence relation closed form hyst equation expression time transition test false true terms time transition hysteresis constant wait minimum observation time concluding test true minobstime hyst iminobstimea equation shows matter metric test varies time hysteresis constant oscillations test damped analysis knowledge metric time non-negative practice largest metric cpu utilization processor additional information derive tighter bound rate oscillations damped intuition metric maximum takes time proportional maximum cumulative average increase perform analysis assume metric function maximum change cumulative function time equal maximum times time combine equations equation substitute term equation hyst hyst hyst combine hystt hyst hyst hyst reduce relation closed form hyst hyst wait minimum observation time concluding test true minobstime hyst hyst minobstime hyst smaller ratio hyst bigger bigger faster damping oscillations case don maximum metric function analysis shown hysteresis parameter desired damping affect important question set hysteresis arbitrarily proved effective meeting goal damping oscillations time prevents concluding hypothesis true long average low false appendix metric definition language introduction purpose appendix describe features metric description language mdl appendix intended language tutorial number examples final section mdl simple programming language templates instrumentation inserted application program gather information performance language parts variable definitions unit definitions metric definitions constraint definitions goal 
language describe compute metrics interesting variables program constrain metrics resources program execution procedure mdl differs languages part program specification executed request insert instrumentation received part executes inside application process measure performance modes called metric insertion insert instrumentation execution exec describing mdl typesetting conventions bold words keywords language courrier refers predefined symbols italic denotes syntactic category non-terminal grammar language lexical attributes lexical attributes mdl intended similar algol-like languages language closest lexically whitespace including spaces tabs newlines separate tokens inside string constants token slashes starts comment information start comment token end line identifiers sequence characters digits underscore character start character identifiers case sensitive predefined identifiers start dollar sign identifiers reserved keywords aggregateoperator append base constraint constrained derived foldoperator foreach metric prepend replace type units types constants languages integer real string integer literals sequence digits optionally starting minus sign real constants sequence digits period sequence digits reals optional leading minus sign front string constants start double quote sequence characters terminated double quote backslash character escape character strings embed double quotes string backslashes single backslash string variables metric description flavors variables modes evaluation metric insertion variables instrumentation execution variables instrumentation execution variables exec instrumentation request blocks metric insertion variables insert metric instantiation variable appears instrumentation request block block inserted application program everytime instrumentation block executes variable space variables mdl metric instantiation variables instrumentation execution variables metric names units constraints functions share space scoping names global variables type predefined types variables list counter timer function callsite lists metric insertion time variables aggregates predefined types elements lists metric instantiation time variables lists accessed sequentially foreach iterator directly indexing identifier int syntax declaring list listdefinition identifier identifier-list identifier-list identifier identifier-list identifier counters instrumentation execution time variables integer variables conventional languages timers instrumentation execution time variables record time events representation timers machine specific abstract data type accessed timer functions section function type structure fields instrumentation points function definition type function point entry point return list callsite calls callsite type structure fields instrumentation points subroutine call definition type callsite point precall point postcall units unit definitions assign units metric metrics units messages floating point instruction executed defined operations unit definitions express information unit definitions higher level consumers data unitdefinition unit ident string-constant constraints constraints define restrict metric single instance resource resource hierarchies constraints declare counter positive desired resource active counter constraint constraint path defines resource hierarchy part hierarchy constraint clause applies path procedure defines constraint restricts metric single procedure variable constraint implicitly initialized metric instantiation time trailing component resource path procedure constraint procedure constraining constraintdefinition constraint identifier matchpath counter statementlist matchpath identifier identifier matchpath metrics metric definition declares time varying variable describes aspect performance parallel program metric definition includes clauses define constrain metric components resource hierarchies metricdefinition metric identifier identifier metricbody metricbody metricheaderlist constraintlist basemetric metricheader stringconstant unit identifier foldoperator sum average aggregationoperator sum average min max constraintlist constraint identifier constraintlist constraint identifier basemetric base identifier statementlist statements expressions statements appearing inside instrumentation request block evaluated metric execution time statements evaluated metric interpretation statement foreach identifier identifier statement instrumentationrequest expression statement statementlist functioncall types expressions mdl expressions evaluated instrumentation execution time occur instrumentation block metric instantiation expression rval rval binaryoperator rval expression binaryoperator rval identifier integerconstant stringconstant floatconstant rval ident functioncall function calls function call identifier optional list expressions actual parameters function functioncall identifier arglistopt arglist expression arglist expression mdl includes number pre-defined functions function show executes description functions execute metric insertion time shown insert metric execution time shown exec function description addcounter counter exec adds passed counter car path insert returns component path cdr path insert returns rest path component removed lookupmodule string insert lookup passed string return module info lookupprocedure string insert lookup passed string return procedure info setcounter counter int exec sets counter passed startprocesstimer timer exec starts passed timer recording cpu time stopprocesstimer timer exec stop passed timer startwalltimer timer exec starts passed timer recording wall time stopwalltimer timer exec stops passed timer subcounter counter exec subtracts passed counter predefined variables mdl includes number predefined variables type description arg exec list int arguments procedure call modules insert list strings modules application program procedures insert list strings procedures application program constraint insert string trailing component resource path matchpath return exec int return procedure instrumentation requests instrumentation request consists description point instrumentation inserted block instrumentation insert point multiple instrumentation blocks inserted point order evaluation instrumentation affect metric control order execution instrumentation point mdl mechanism ensure instrumentation evaluated correct order instrumentation point list instrumentation requests point metric request time constraint base clauses evaluated order metric definition addition instrumentation request block appended prepended instrumentation block list point instrumentationrequest position point constrained opt statementlist position append prepend point expression type point examples shows unit definition unit called operations arg valid procedure entry pre-call points return valid procedure exit procedure return points units ops operations constraint clause demonstrates foreach statement instrumentation execution time variables argument procedure constraint definition iterates list message passing functions metric insertion time inserts calls set counter msgtagpred positive argument argv function equal target message tag constraint constraint clears counter return point message passing routine msgtagfuncs cmmd send cmmd recv constraint msgtagpred syncobject msgtag counter foreach func msgtagfuncs prepend lookupfunction func entry arg constraint setcounter msgtagpred append lookupfunction func exit setcounter msgtagpred constraint demonstrates replace clause define constraint requested lieu base metric replace clause metric definitions constrained version metric written efficiently general metric constraint clause computing times single procedure called expressed constraint counter active desired procedure called base metric procedure call check current procedure call desired efficient metric replace clause simply increments counter entry desired procedure version appears instrumentation request constrained clause means constraint replaces base metric constrained constraint clauses desired metric constraint callsperprocedure procedure replace counter append constraintentry constrained addcounter procedurecalls metric description metric records number procedures called metric procedurecalls procedure calls units callpersecond foldoperator sum constraint processconstraint constraint base counter foreach func procedures append lookupfunction func entry constrained addcounter procedurecalls anderson lazowska quartz tool tuning parallel program performance sigmetrics conference measurement modeling computer systems boston aral gertner high-level debugger profiler architecture shared-memory multiprocessors international conference supercomputing 
york butterfly product overview bbn advanced computers cambridge ball larus optimally profiling tracing programs acm symposium principles programming languages albuquerque january bates wileden edl basis distributed system debugging tools hawaii international conference system sciences january bates debugging heterogeneous distributed systems event-based models behavior acm sigplan sigops workshop parallel distributed debugging madison appears sigplan notices january bates distributed debugging tools heterogeneous distributed systems int conf distributed computing systems san jose calif june beguelin dongarra geist sunderam visualization debugging heterogeneous environment ieee computer june bemmerl bode braum hansen tremi wismuller design implementation topsys tum-info- technische universitat muenchen july bernstein bolmarcich performance visualization parallel programs shared memory multiprocessor system international conference parallel processing icpp park usa august bishop profiling unix patching software practice experience oct brantley mcauliffe ngo performance monitoring hardware instrumentation future parallel computer systems simmons koskela bucker eds addison-wesley brewer dongarra sorensen tools aid analysis memory access patterns fortran programs parallel computing brown zeus system algorithm animation multi-view editing ieee workshop visual languages kobe japan oct brown application code instrumentation technology los alamos debugger los alamos national laboratory october bruegge portable platform distributed event environments acm onr workshop parallel distributed debugging santa cruz appears sigplan notices december burkhart millen performance measurement tools multiprocessor environment ieee trans computers unicos file formats special files manual srcray research cray system architecture overview hrcray research eagan crovella leblanc performance debugging parallel performance predicates acm onr workshop parallel distributed debugging csirik frenk labbe zhang multidimensional vector bin packing acta cybernetica dewitt gerber multiprocessor hash-based join algorithms vldb conference stockholm sweden august denning working sets past present ieee transactions software engineering sejan dennis segmentation design multiprogrammed computer systems journal association computing machinery oct dongarra geist manchek sunderam integrated pvm framework supports heterogeneous network computing computers physics march-april fineman hontalas selective monitoring performance metric predicates scalable high performance computing conference williamsburg virginia april fowler leblanc mellor-crummey integrated approach parallel program debugging performance analysis large-scale multiprocessors sigplan sigops workshop parallel distributed debugging madison appears sigplan notices january francioni albright jackson debugging parallel programs sound acm onr workshop parallel distributed debugging santa cruz appears sigplan notices december friedell lapolla kochhar sistare juda visualizing behavior massively parallel programs supercomputing albuquerque nov garey graham johnson resource constrained scheduling generalized bin packing combinatorial theory garey johnson computers intractability geist heath peyton worley picl portable instrumented communication library oak ridge national laboratory goldberg hennessy performance debugging shared memory multiprocessor programs mtool supercomputing albuquerque nov graham kessler mckusick gprof call graph execution profiler sigplan symposium compiler construction boston june haban wybranietz hybrid monitor behavior performance analysis distributed systems ieee transactions software engineering feb hansen linthicum brooks experience performance analyzer multithreaded application international conference supercomputing amsterdam june heath etheridge visualizing performance parallel programs ieee software sept hecksen klar kleinoder kneibl measuring simultaneous events multiprocessor system sigmetrics conference august hollingsworth irvin miller integration application system based metrics parallel program performance tool acm sigplan symposium principals practice parallel programming williamsburg april appears sigplan notices july hollingsworth miller parallel program performance metrics comparison validation supercomputing minneapolis november homewood mclaren meiko csinterconnect proceedings world transputer congress sept hough cuny initial experiences pattern-oriented parallel debugger sigplan sigops workshop parallel distributed debugging madison appears sigplan notices january hough cuny perspective views technique enhancing parallel program visualization international conference parallel processing icpp august paragon product overview intel supercomputer systems division greenbrier parkway beaverton johnson postloading fun profit usenix winter conf jan joyce lomow slind unger monitoring distributed systems acm transactions computer systems kessler fast breakpoints design implementation acm sigplan conf programming language design implementation white plains june kinoshita experience analyzer performance tuning tool instrumentation future parallel computer systems simmons koskela bucker eds addison-wesley kohn williams atexpert journal parallel distributed computing june lamport time clocks ordering events distributed system comm acm july lange kroger gergeleit jewel design implementation distributed measurement system ieee transactions parallel distributed systems nov larus abstract execution technique efficiently tracing programs software practice experience dec leblanc mellor-crummey debugging parallel programs instant replay ieee transactions computers april leblanc mellor-crummey fowler analyzing parallel program executions multiple views journal parallel distributed computing lehr segall vrsalovic caplan chung fineman visualizing performance debugging ieee computer october lehr black segall vrsalovic mkm mach kernel monitor description examples measurements cmu carnegie-mellon pittsburgh pa-cs- march lewandowski phd thesis wisconsin-madison august malony program tracing cedar csrd report center supercomputing res dev univ illinois urbana-champaign april malony performance observability phd dissertation department computer science illinois oct malony reed hardware-based performance monitor intel ipsc hypercube international conference supercomputing amsterdam june marzullo wood tools constructing distributed reactive systems cornell january massalin threads input output synthesis kernel acm symp operating systems principles litchfield park dec mcdaniel metric kernel instrumentation system distributed environments symp operating system prin november miller macrander sechrest distributed programs monitor berkeley unix international conference distributed computing systems miller clark hollingsworth kierstead lim torzewski ipsthe generation parallel program measurement system ieee transactions parallel distributed systems april mills accuracy stability clocks synchronized network time protocol internet system computer communication review jan mills internet time synchronization network time protocol ieee transactions communications oct mink carpenter vlsi chip set multiprocessor performance measurement system performance instrumentation visualization simmons koskela eds addison-wesley mink carpenter nacht roberts multiprocessor performance measurement instrumentation ieee computer september murtagh saunders large-scale linearly constrained optimization mathematical programming jan pancake utter models visualization parallel debuggers supercomputing reno november pancake cook users parallel tools support survey results analysis scalable high-performance computing conference perl weihl performance assertion checking acm symposium operating systems principles december ponder fateman inaccuracies program profilers software practice experience reed aydt noe roth shields schwartz tavera scalable performance analysis pablo performance analysis environment scalable parallel libraries conference skjellum ieee computer society reilly instrumentation application performance tuning system instrumentation future parallel computer systems simmons koskela bucker eds addison-wesley reiser skudlarek program profiling problems solution machine language rewriting sigplan notices jan ries anderson auld breazeal callaghan richards smith paragon performance monitoring environment supercomputing portland nov schneider dewitt performance evaluation parallel join algorithms sharednothing multiprocessor environment tech report dept comp sci wisconsin april schwan ramnath vasudevan ogle language system parallel programming ieee transactions software engineering april 
segall singh snodgrass jones siewiorek integrated instrumentation environment multiprocessors ieee transactions computers january segall rudolph pie programming instrumentation environment parallel processing ieee software november singh weber gupta splash stanford parallel applications shared-memory computer architecture news march sistare allen bowker jourdenais simons title data visualization performance analysis prism programming environment programming environments parallel computing topham ibbett bemmerl eds north-holland sites alpha architecture manual digital press smith debugging techniques communicating loosely-coupled processes phd thesis rochester december smith williams sound exploratory visualization environment lowell computer science department technical report socha baily notkin voyeur graphical views parallel programs acm sigplan sigops workshop parallel distributed debugging madison appears sigplan notices january sonnenwald gopinaht haberman iii myers infosound audio aid program comprehension hawaii international conferences system sciences stasko kraemer methodology building application-specific visualizations parallel programs journal parallel distributed computing june stunkel shea grice hochschild tsao high-performance switch scalable high-performance computing conference thakkar personal communication title connection machine debugging performance analysis present future acm onr workshop parallel distributed debugging santa cruz vrsalovic performance efficient parallel programming mpc hawaii international conference system sciences january wahbe lucco graham practical data breakpoints design implementation acm sigplan conf programming language design implementation albuquerque june wang precise compile-time performance prediction superscalar-based computers acm sigplan conf programming language design implementation orlando june welbon chen-nui shippy hicks power performance monitor ibm journal research development submitted williams hoel pase mpp apprentice performance tool delivering performance cray programming environments massively parallel distributed systems northholland wybranietz haban monitoring performance measuring distributed systems operation sigmetrics santa mexico yan listgarten intrusion compensation performance evaluation parallel programs multicomputer international conference parallel distributed systems louisville oct yan performance tuning aims automated instrumentation monitoring system multicomputers hawaii international conference system sciences jan vol yang miller critical path analysis execution parallel distributed programs int conf distributed computing systems san jose calif june yang miller performance measurement parallel distributed programs structured automatic approach ieee trans software eng dec zernik rudolph animating work time debugging parallel programs foundation experience acm onr workshop parallel distributed debugging santa cruz appears sigplan notices december system performance evaluation cooperative capacity management review aug table contents acknowledgements abstract iii chapter introduction motivation summary results organization thesis chapter related work information overload performance metrics search based tools visualization data collection program instrumentation system instrumentation filtering hardware data collection chapter search model goals axis axis axis searching bottlenecks execution search history graph automated searching explanation interface chapter implementation search model experimental method water locusroute shared memory join lessons learned chapter dynamic instrumentation goals design dynamic instrumentation interface data collection points primitives predicates instrumentation mechanism metric manager instrumentation generation clock synchronization conclusion chapter implementing dynamic instrumentation micro benchmarks macro benchmarks conclusion chapter instrumentation cost model predicted cost observed cost implementation observed cost implementation predicted cost chapter bringing implementation graph coloring application msolv application conclusion chapter conclusions future work conclusions future work search model dynamic instrumentation dynamic monitoring appendix damping test oscillations appendix metric definition language introduction lexical attributes variables units constraints metrics statements expressions function calls predefined variables instrumentation requests examples vii table figures inserting instrumentation program inserting instrumentation system sample hypothesis hierarchy pseudo code hypothesis test sample axis class hierarchies intervals program execution obstacles changing data collection execution sample search history graph display showing axes sampling dynamic instrumentation water application data dynamic instrumentation tracing water full sampling dynamic instrumentation locusroute dynamic instrumentation tracing locusroute full sampling dynamic instrumentation shmjoin dynamic instrumentation tracing shmjoin sampled counter timers types instrumentation description predicate language showing metrics sample constrained metric structure dynamic instrumentation system sample metric description sample constraint clause inserting instrumentation program sample mini-trampolines aggregating samples sources time execute trampolines cost primitive operations primitive times component timer overheads tmc cmcommunication paths scalable ptrace overhead inserting instrumentation transporting data cost ptrace operations overhead sequential cpu profilers computing predicted observed costs measured observed overhead measured observed overhead parallel application measured predicted overhead viii measured predicted overhead parallel application architecture paradyn tool suite main paradyn control window performance consultant search graph coloring application time histogram graph coloring application performance consultant search msolv application time histogram msolv application graph cumulative metric time note figures color thesis detail lost black white reproduction 
cardinale yudith figueira carlos hern ndez emilio baquero eduardo berb luis bouza roberto gamess eric garc pedro universidad sim bol var gae couple projects usb received funding strategic alliance government oil industry agenda petr leo chemistry geophysics gae wanted build system gae uniform access researchers desktop computers campus distributed heterogeneous resources gae efficiently supports high level scientific programming gae offers evolved services performance fault tolerance specialized clients gae execution architecture composed heterogeneous clusters workstations specialized hardware loosely interconnected gae executes java byte code sequential parallel gae support fault tolerance recovery gae efficient execution performance modeling gae built standard flexible portable platforms java corba approach gae execution basics gae system architecture gae suma components gae performance gae fault tolerance gae parallel execution gae current prototype gae conclusions future work gae execution modes gae on-line program supplied suma sumajava main class input output redirected client machine remote node gae off-line classes input files needed application packed delivered execution results obtained gae number execution attributes provided program instance scheduling constraints classes data files preloaded gae main class program execution suma client machine gae transparently suma finds server cluster machine execution sends request message server gae execution agent designated server starts execution program dynamically loading required classes input data client sending back output gae case off-line jobs output suma requested user engine gaecoordinates execution gaereceives execution unit object client stub gaechecks permission gaeasks scheduler suitable server gaedelivers execution unit designated server gaeinteracts application monitor gaehandles results case off-line jobs scheduler gaeobtains status load information servers gaeresponds engine requests based applications requirements gaemaintains load balance servers application monitor gaeconsists coordinator application monitor slaves gaereceives status information execution agents crash exit gaeprovides information implementing gae fault tolerance based checkpointing recovery gae performance modeling profiling suma components execution agent gaeone server concurrent gaeregisters resource control gaeexecutes programs gaereceives execution unit engine gaestarts execution possibly loading classes files dynamically client gaesends result client gaefor parallel platform execution agent plays role front end gaeresource control gaeused registration suma resources servers gaekeeps static dynamic information servers memory size libraries load gaeuser control gaeused user registration gaeallows user authentication gae client stub library suma clients implementation gae services on-line off-line execution retrieving results performance profiles gae creates delivers execution unit information unit gae serves callbacks execution agents gae types clients user administrator suma optimizations gaekeep pool processes servers pre-loaded virtual machines gaeremote class loading pre-loading gaecompiling native code servers gaeothers parallel execution application performance feedback gaeprovides user relevant information performance application execution architecture gaeallows performance tuning architecture selection gaeat levels gaesuma level replicating suma components gaeexecution server level providing checkpointing recovery sequential parallel gaeparallel platforms suma predefined clusters gaea parallel platform provide gaempi gaenumerical libraries gaesupport executing parallel java applications calls mpijava gae mpijava group java classes call native implementation mpi java gae plapackjava set java classes users call functions plapack java gae plapacksuma mpisuma implementations libraries cygnus java compiler gae results comparing execution plapack interfaces java implementations gae experiment consists solving linear algebra problem factorization cluster pentium mhz mbytes ram connected mbps ethernet size bytes plapack gcc plapackjava plapacksuma gae centralized core public domain corba implementation jacorb jdk cygnus compiler gae implementations mpijava lam linux gae straightforward scheduling fault tolerance gae runs solaris linux gaebasic expandable flexible platform executing java bytecode support efficient parallel execution gaelong list future developments focus fault tolerance performance tuning modeling 
