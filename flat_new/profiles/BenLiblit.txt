open source proving grounds ben liblit computer sciences department wisconsin-madison liblit wisc open source software attractive target developing evaluating software defect detection tools position paper discusses benefits challenges encountered researcher interacting open source community cooperative bug isolation project cbi explores ways identify fix bugs widely deployed software mix lightweight instrumentation statistical modeling techniques reveal failure patterns large numbers end user runs ultimate validation cbi approach real data real users helps find real bugs real code field deployment key component project cbi offers instrumented binaries popular open source programs download open marketplace code ideas open source projects expose entire development process public includes source code grab millions lines code hour day night disciplined projects revision histories design documents regression test suites bug tracking systems release schedules trappings real software development free taking nondisclosure agreements lawyers limits potentially embarrassing defect data open source software gained marketand mind-share realistic scientific progress demonstrated open source software assumed apply equally proprietary systems software engineering general marketplace research open source considered legitimate openness facilitates feedback defect findings project developers cbi discovers bugs target applications report bug tracking systems developers bug reports compete developers attention reports clear describe important bugs gain credibility patches accepted gladly uninformative unimportant reports languish observing developers respond information provide important part evaluating tools transparency open source projects makes process easier observe time open source licenses don developers permission hinder work developer put tiny chance cbi find single bug favor case costs disadvantage stemming openness open source distributors loosely connected open source developers difficult convert developer enthusiasm large scale deployment backed commercial open source vendor red hat novell ultimately challenges challenges faced partnering large company surprise lead developer project influence third-party linux vendor pay salary simply downloads source code finding user community open source projects feel provide source obligation provide compiled binaries applications complex dependencies make difficult end users build research includes dynamic analysis deployed software source binary gap creates opportunity barter end users spend time build clean tested installable binary packages open source applications cbi exchange users download packages agree provide raw data research people told cbi releases simply easiest desired applications installed running machines approach finding users disadvantages compared piggybacking commercial release easy users hard large numbers traffic cbi accrues download links close microsoft instrumenting small fraction shrinkwrapped office requiring explicit download install naturally selects technical user base behavior representative software usage patterns general spite factors relative ease small user community makes binary distribution open source applications attractive option research involving deployed software effects shortened release cycles open source projects typically release versions earlier commercial equivalents advantage disadvantage research perspective early releases make projects dirty laundry visible hunting bugs early releases young open source projects target-rich environment feedback provided developers incorporated quickly project posted release specifically response bugs reported cbi noted enthusiastic developer response strong validation defect detection tool hand difficult software quality researchers moving target cbi depends accumulating examples good bad runs releases weeks time accumulate data single snapshot code stop tracking release users eager latest greatest wander access binary providers source users strong reason stay place commercial providers captive audience combined longer release cycles researchers operating commercial environment time collect data analysis conclusions hindsight found working open source makes easier started harder finished barriers entry low making easy crazy scheme mind tool sail sink based technical merits feedback real developers fast direct validation channel hand decentralized nature open source development means defined decision maker declare executive fiat engineering team henceforth tools millions lines code small deployments easy arrange large difficult researchers working commercial environment trade-offs mind open source proving grounds work reading cooperative bug isolation ben liblit cooperative bug isolation project http wisc cbi ben liblit alex aiken alice zheng michael jordan bug isolation remote program sampling james fenwick cindy norris editors proceedings acm sigplan conference programming language design implementation pldivolume acm sigplan notices pages acm press ben liblit alex aiken alice zheng michael jordan sampling user executions bug isolation alessandro orso adam porter editors ramss international workshop remote analysis measurement software systems pages portland oregon ben liblit mayur naik alice zheng alex aiken michael jordan public deployment cooperative bug isolation alessandro orso adam porter editors proceedings international workshop remote analysis measurement software systems ramss pages edinburgh scotland ben liblit mayur naik alice zheng alex aiken michael jordan scalable statistical bug isolation proceedings acm sigplan conference programming language design implementation chicago illinois june benjamin robert liblit cooperative bug isolation phd thesis california berkeley december alice zheng michael jordan ben liblit alex aiken statistical debugging sampled programs sebastian thrun lawrence saul bernhard sch olkopf editors advances neural information processing systems mit press cambridge 
statistical debugging simultaneous identification multiple bugs alice zheng alicez cmu carnegie mellon school computer science pittsburgh michael jordan jordan berkeley california berkeley department eecs department statistics berkeley ben liblit liblit wisc computer sciences department wisconsin-madison madison mayur naik mhn stanford computer science department stanford stanford alex aiken aiken stanford computer science department stanford stanford abstract describe statistical approach software debugging presence multiple bugs due sparse sampling issues complex interaction program predicates generic off-the-shelf algorithms fail select bug predictors taking inspiration bi-clustering algorithms propose iterative collective voting scheme program runs predicates demonstrate successful debugging results real world programs large debugging benchmark suite introduction traditional software debugging arduous task requires time effort good understanding source code scale complexity task development methods automatically debugging software essential difficult trends make endeavor increasingly realistic wide-scale deployment software establishment distributed crash report feedback systems development statistical machine learning algorithms advantage aggregate data multiple users appearing proceedings international conference machine learning pittsburgh copyright author owner statistical approach software debugging pursue based fine-grained instrumentation software distributed data collection infrastructure liblit process starts source-to-source transformation buggy program transformation creates large number instrumented sites assess truth predicates run-time state program variables time instrumentation site reached program execution instrumentation code site optionally executed probability distribution tuned minimize instrumentation impact run-time performance code site executed record true false predicate predicate observed program skips site moves predicate unobserved feedback reports counts number times predicate found true run program addition runs labeled successful failing depending exit status program instrumentation predicates automatically generated provide information locations bugs primary problem statistical debugging select bug-predicting predicates set user feedback reports sheer size data sets involved problematic approaches test programs lines code predicates handful predicates bug statistical debugging simultaneous identification multiple bugs predictors large software programs millions lines code hundreds millions candidate predicates algorithm choose sparse sampling predicates complexity interactions complicate matter simple case programs single bug automatic debugging problem posed feature selection problem binary classification context straightforward off-the-shelf techniques work case zheng found algorithms fail applied realistic cases programs multiple bugs algorithms difficulty coping issues related sampling distinguish bug predictors predicates secondary manifestations bugs paper attack multi-bug problem identify major challenges arising multi-bug case simple solutions fail section design algorithm addresses challenges section section present results experiments real programs algorithm identify previously unknown bugs compare algorithm statistical debugging techniques suite test programs conclude section multi-bug challenges multi-bug setting assume program multiple bugs failing runs labeled bug failure problem flavor clustering problem idiosyncrasies note failing runs successful runs problem retains aspect classification run exhibit bug finally importantly problem simply identifying clusters finding features identify clusters simultaneously characterize failing versus successful runs problem instance feature selection problem off-the-shelf solution order make issues concrete briefly present results applying simple algorithms realistic multi-bug problem claim algorithms sense effective choice simply highlight issues arise multi-bug setting testbed moss software plagiarism detection program large user community introduce table result applying single-bug algorithm moss data predicate passage index line passage index line passage index line passage index line variations bugs found previous versions software generate runs program varying command-line options input files turns bug manages trigger failed runs bug incorrect output rest bugs crash program ways tag failed runs exit error signal compare output results version moss bugs note experiments subsequent experiments paper pre-filter data statistical test eliminates bulk uninteresting predicates retain predicate passes simple test pred true run fails pred observed pred true run succeeds pred observed estimated empirical counts single-bug algorithm examine results running singlebug algorithm zheng moss dataset essentially classification algorithm feature selection penalty table presents top ten predicates selected algorithm predicates fall groups predicates bug-finding predicates simply count length command-line experiments longer command-lines correlated failed runs successful runs long command-lines predicates cover failed runs strong bug predictors group predicates limited usefulness reason specifically passage index predicates specific conditions satisfied instances statistical debugging simultaneous identification multiple bugs bug predicates highly indicative sub-modes bug cover runs crash due bug addition issues illustrate single-bug algorithm fail terms sensitivity specificity worth noting high degree redundancy list top ten predicates effective algorithm return single highly-predictive predicate bug clustering runs leave classification perspective attempt treat multi-bug problem standard clustering tool apply k-means clustering failed moss runs hopes resolving underlying true bug labels k-means clustering yielded similar results test programs rhythmbox exif run represented vector non-binary predicatecounts variance center normalize predicate dimension subtracting sample dividing sample standard deviation make problem easy algorithm set number clusters equal true number bugs moss repeat k-means times random initialization pick clustering smallest intracluster distance figure shows resulting bug histograms representation bin number runs failing due bug ideal bug histogram exhibit peaks distinct bugs clusters capture bugs rest clusters distinct clusters multiple bugs subsets single bug bugs scattered multiple k-means clusters closer analysis runs cluster reveals clustering fails clusters capturing usage modes program failure modes hindsight surprising usage modes salient statistically failure modes additional constraints clustering algorithms home program usage modes provide leverage bug detection clustering predicates attempt single-bug algorithm algorithms predicate redundancy significant cluster bug num runs cluster bug cluster bug cluster bug cluster bug num runs cluster bug cluster bug cluster bug figure bug histograms moss run clusters returned k-means problem users statistical debugging tool wade long list redundant predicates redundancy obvious address problem begin address issues feature selection clustering context attempt cluster predicates studying problem found interacts strongly sparsity characteristic domain suppose predicates mutually redundant sampling rate takes runs predicate pair co-observed runs observed practice runs dataset observe large values similarity redundant predicates probable observe instance close close close considerations led explore spectral clustering methods predicate clustering ability spectral approach respect transitivity spectral clustering requires similarity metric product-moment correlation coefficient pairs predicates order reduce bias arising predicate sampling process condition observation status predicates assuming predicates instrumentation sites independent conditional correlation coefficient written observed pxy pxpyradicalbigp observed observed pxy observed spectral clustering algorithm statistical debugging simultaneous identification multiple bugs cluster bug num runs cluster bug cluster bug cluster bug cluster bug cluster bug num runs cluster bug cluster bug cluster bug figure average bug histograms moss predicate clusters vary number 
clusters pick clustering smallest average intracluster distance result turned figure plots average bug histograms predicate clusters cluster count number runs exhibiting bug averaged number predicates cluster bug histograms figure single predominant peak exception cluster predictors bug clusters mixtures subsets bugs non-distinct bug histograms arise due presence refer super-bug predictors super-bug predictors general pre-conditions failure predicates measuring command-line length table super-bug predictors super-bug predictors loosely correlate failed runs tend true number successful runs moss dataset prominent super-bug predictors bugs bond predicate clusters resulting super-cluster broken weaker links leaving set scrambled predicates correspond neatly bugs issues identified issues successful multi-bug algorithm face predicates non-specific super-bug predictors make feature selection difficult multiple clusters highly supported predicates sub-bug predictors highly-specific predictors home specific aspects individual bug fail reveal general case predicate redundancy problem algorithmically terms feedback user finally interlaced issues issue sampling data collection framework samples predicate instrumentation impact performance figure predicate truth probability model running program creates subtle statistical biases linkages complicate core issues clustering feature selection algorithm algorithm propose section parts part deals sampled predicates graphical model infer truth probabilities observed data inferred probabilities serve input stage bi-clustering algorithm attempts select features jointly clustering runs predicates inferring truth probabilities based observed counts sampling process make probability statements truth predicates run hope ameliorate data sparsity problem reducing bias caused sampling isolating issues clustering feature selection figure graphical model truth probability single predicate random variable representing number times predicate observed run program denotes number times observed true actual number times predicate true run number times instrumentation site reached observe ultimate goal compute posterior truth probability predicate run moss dataset observe number times site reached poisson-like distribution runs site reached leading additional spike endow prior statistical debugging simultaneous identification multiple bugs mixture poisson distribution spike model mixture binomial distribution spike spike spikes represent sticky modes predicate true true lastly based predicate sampling process binomial distribution parameter sampling rate hypergeometric distribution conditional probabilities predicate truth probability model poi bin bin hypergeo denotes delta function endow parameters conjugate priors beta-distributed dirichlet prior distribution gamma distribution empirical bayes approach set hyperparameters data ultimate goal compute posterior truth probability case trivial examine case easier compute calculate short calculation yields posteriors collective voting approach solving multi-bug problem reposes symmetry principle predicates group runs predict runs group predicates predict approach problem perspective bi-clustering dhillon hartigan generic biclustering algorithms directly address idiosyncrasies predicate-run relationship standard distance metrics information-theoretic objectives applicable develop instance bi-clustering algorithm encapsulates specific setting statistical debugging problem algorithm essentially performs iterative collective voting process alternating updates predicate quality vote distribution runs failed run ultimately casts vote favorite predicate predicates ranked number votes receive recursive voting procedure program predicates candidates runs constituents predicate quality based votes receives runs run unit vote cast beginning run distributes fractional votes candidate predicates candidate receives vote proportional quality predicates compete run attention predictors run smaller vote predicate receives competition predicates encapsulates problem redundancy voting process iterates convergence point run firm resolve cast entire vote single predicate finally predicates ranked votes inputs algorithm posterior truth probabilities inferred procedure previous section carry calculation run predicate aij denote probability predicate true run denote set failed runs set successful runs denote quality predicate complement measure contribution predicate measure contribution complement predicate define set coupled update equations fis summationdisplay aij rijsummationtext rkj summationdisplay ijsummationtext summationdisplay aij rijsummationtext rkj summationdisplay ijsummationtext rij braceleftbigg aijqi aij braceleftbigg ijq moment decipher equations predicate null complement predicate null predicate complement true times lifetime program run statistical debugging simultaneous identification multiple bugs table summary statistics datasets lines code numbers successes failures number predicates number top predicates accounting failures voting process runs lines preds moss rhythmbox exif equation dictates predicate high quality contributes failed runs successful runs complement contributes successful runs failed runs contribution predicate run defined aij probability true run multiplied rij vote run casts predicate normalized total number votes cast run equation equation run decides vote cast predicate based predicate failure prediction strength truth probability aij equation small test suppose data set includes failed run successful run predicates complements predicate good bug predictor true failed run complement true successful run predicate generic non-informative super-bug predictor true runs initially predicates equal quality round updates failed run effectively splits vote evenly successful run vote hand receives vote failed run share vote successful run updated quality scores inf end round updates quality scores renormalized unit sum computation purposes smooth scores small additive constant essentially large number smaller results moss table presents statistics programs experiments moss pre-filter reduces number predicates voting algorithm selects predicates account failures pred bug num runs pred bug pred bug pred bug pred bug pred bug num runs pred bug pred bug pred bug figure bug histograms top moss predicates table top moss failure predictors rank predicate files filesindex language config tile size config match comment true line lengthofp config match comment true line yyout figure bug histograms top predicates numbers runs attributed predicate included parentheses top plot bug histograms homogeneous previous attempts section predicate table focuses specific bug bug represented predicate bugs represented couple prominent sub-bug predictors instance predicates account bug occurs commentmatching turned predicates check size array predicates account bug array-overrun bug sub-bug predictors account entire suite failed runs resulting bug indicators failure manually verified quality top predicates table predicates direct indicators bugs focus ninth predicate predicate turns super-bug predictor true commandline length longer super-bug predictor selected account bug reason turns lie definition predicate quality equation high score predicate contributes failed runs complement contributes successful runs cribug exception moss dataset strong predictors occur independently bugs statistical debugging simultaneous identification multiple bugs terion works bug predictors prominent predictor bug moss involves command-line flag setting option complement predicate true failed runs command-line options trigger bugs case prediction strengths predicate complement working lost algorithm fails select informative predictor bug succeeds clustering runs failing due bug run clusters apply simple single-bug algorithms select bug predictors cluster added advantage giving predicate clusters running simple univariate hypothesis test predicate run cluster yields predicate cluster top predicates streq argv true handle options strcmp argv handle options predicates equivalent 
option set rest predicates list super-bug predictors similar shown rhythmbox exif tested algorithm real-world programs multiple bugs rhythmbox graphical open-source music player bugs bugs exposes bad coding pattern related previously freed reclaimed event objects discovery bug subsequently led discovery bugs rhythmbox resulting bad coding practice liblit algorithm selects predicates rhythmbox mppriv timer null monkey media player uri vol float true dbpriv thread reaper rorder val rorder val mppriv tick timeout predicate important clue bug involving dangling object destroyed predicate pointer timer object null meaning object deallocated parts program holds object subsequent deallocated object pif denote average truth probability predicate failed run cluster pis set successful runs rank predicates test statistic two-sample bernoulli test pif pis program crash predicate predictor race condition bug monkey media player object destroyed subsequent callbacks object crash remaining predicates manifestations unknown bugs rhythmbox exif open-source image manipulation tool bugs covered predicates selected algorithm sizeof jpegsection datacount- machine readable true dataifd count false predicate clusters predicates predict bug exif machinereadable output mode function call returns null pointer crash printing ranked predicate count negative count subsequently passed function memmove crash fourth predicate secondary indicator bug exif primary indicator bug buf size ranked number predicate predicate cluster condition true program neglects allocate chunk memory crashes program stage failed runs exif dataset crashed due bug predictor ranked predictors bugs multi-bug algorithm successfully clusters failed runs bugs selects direct predictors bugs run clusters apply simple single-bug algorithms univariate hypothesis testing rank cluster correlated predicates find predicate clusters interpreting output debugging algorithm worth noting run clusters simple univariate algorithms captured correct bug predictors datasets comparison algorithms compare algorithm statistical debugging techniques presented recent literature earlier work liblit proposed predicate ranking algorithm based harmonic predicate sensitivity specificity algorithm performs heuristic projection step runs accounted top predicate eliminated liu present sober algorithm aims solve single-bug problem test derived one-sample hypothesis testing statistical debugging simultaneous identification multiple bugs compare algorithms moss rhythmbox andexif theharmonicmeanprojection method selects predicates comparable quality bi-clustering method cases sober single-bug algorithm fares worse moss selects sub-bug predictors bug predictors bug sub-bug predictors bug compare performance systematically estimate amount programmer effort required find bugs algorithm starting top ranked predictor model programmer performing breadth-first search program dependence graph reaching buggy line code cleve zeller renieris reiss effort required percentage code examined search implementation metric provided holger cleve runs atop codesurfer provided grammatech apply comparison siemens test suite hutchins single-bug variants programs suite gauge effectiveness multi-bug debugging algorithms widely large benchmark bug-hunting tools find sober performs slightly code examined point bi-clustering algorithm offers superior performance bi-clustering algorithm requires code examination average algorithms tested programs demonstrated performance matrix worse bi-cluster sober bi-cluster project sober project conclusions paper present systematic approach statistical debugging software programs presence multiple bugs unlike simpler single-bug sibling multi-bug problem compounded issues sampling sparsity complex inter-predicate relationships algorithm specifically targets pitfalls simpler algorithms proven work empirically real world programs probability inference collective voting framework potentially adjusted accommodate general bugs predicate settings cleve zeller locating program failures proceedings international conference software engineering icse louis missouri dhillon co-clustering documents words bipartite spectral graph partitioning proceedings seventh acm sigkdd international conference knowledge discovery data mining kdd san francisco california hartigan direct clustering data matrix journal american statistical association hutchins foster goradia ostrand experiments effectiveness dataflowand controlflow-based test adequacy criteria proc int conf software engeineering icse liblit aiken zheng jordan bug isolation remote program sampling proceedings acm sigplan conference programming language design implementation san diego california liblit naik zheng aiken jordan scalable statistical bug isolation proceedings acm sigplan conference programming language design implementation chicago illinois liu yan fei han midkiff sober statistical model-based bug localization proceedings joint meeting european software engineering conference acm sigsoft symposium foundations software engineering esec fseng jordan weiss spectralclustering analysisandanalgorithm advances neural information processing systems cambridge mit press renieris reiss fault localization nearest neighbor queries proc int conf automated software engineering ase ieee computer society zheng jordan liblit aiken statistical debugging sampled programs advances neural information processing systems cambridge mit press 
computer sciences department whatsat dynamic heap type inference program understanding debugging marina polishchuk ben liblit chlo schulze technical report december whatsat dynamic heap type inference program understanding debugging marina polishchuk microsoft corporation marinapo microsoft ben liblit wisconsin madison liblit wisc chlo schulze oracle corporation chloe schulze oracle december abstract programs difficult debug due lax type enforcement low-level access memory present dynamic analysis checks heap snapshots consistency program types approach builds ideas physical subtyping conservative garbage collection infer program-defined type allocated storage location identify untypable blocks reveal heap corruption type safety violations analysis exploits symbolic debug information present requires annotation recompilation list defined program types allocated heap blocks integrated analysis gnu debugger gdb describe initial experience tool small medium-sized programs introduction suppose programmer notices incorrect variable execution program debugging programmer obsupported part nsf grant ccrthis work performed wisconsin madison serve values variable points execution setting watchpoint debugger inserting print statements techniques inadequate debugger watchpoints prohibitively slow adding print statements ineffective cases memory corruption affected data structure apparent relation code corrupts programmer run static pointer analysis check erroneous memory accesses typical analyses model dependencies neighboring memory blocks bugs caused buffer overruns pointer mismanagement physical proximity memory blocks important factor designed implemented automated tool programmers understand debug program behavior physical memory level tool offers programmer low-level typed view memory allocated chunk presented inferred data type untypable defined program type compatible imposed constraints common scenario view case buffer overrun attempt deduce data structure lies corrupted location raw memory values printed variables programmer tool discover nearby memory block array type mere presence array makes buffer overrun good hypothesis array type helps programmer identify relevant code examine array bounds violations memory corrupted tool detect values stored heap blocks match feasible type block order reason corruption programmer heap corrupted task support binary search debugging strategy find illbehaving code set breakpoint location variable correct wrong iteratively narrow interval bad assignment exposed tool programmer ability treat entire heap memory good bad state search time heap corrupted usual dynamic debugging techniques binary search paper makes contributions introduce idea consistent typing heap point execution block allocated storage assigned type program type assignment satisfies set constraints imposed values stored memory size allocated block type conformance relation precedesequal based physical subtyping additional constraints imposed declared program variables debugging information give algorithm finds consistent typing snapshot heap consistent typing exists report locations conflicts user present memory visualization focuses physical layout lucid representation typed data stored remainder paper organized give overview system define basic terms section section defines subtyping relation types individual bytes section specifies constraints satisfied set typed memory locations considered consistent section algorithm find consistent typing entire heap section discusses visualization presents case studies tool section places system context related work section outlines future directions technique concludes preliminaries describe scenario solve problem finding consistent typing heap outline solution provide key definitions notation paper definitions typing map store types storage location addr store type types types defined program including structures unions pointers arrays functions storage locations include fixed set addresses holding global variables set locations hold local variables function arguments stack current program point multiple stacks multithreaded programs memory blocks dynamically allocated start program refer heap storage globals locals function arguments type information symbolic debug information present memory blocks heap storage dynamic type information unions untagged standard manner conservative garbage collectors define valid pointer block memory store storage location valid pointer point immediately end block storage common programming idiom explicitly allowed standard type constraint restricts types reside storage location analysis imposes constraints types individual bytes memory termed byte types informally byte type byte holds start program type subtype thereof byte types byte part interior multi-byte starts earlier location overview establishing store types analysis proceeds assign byte types storage locations hold valid pointers pointed-to locations key problems tool address fact programs manipulate memory values disregards declared types complicates debugging analysis treats values arise program foremost source byte type constraints symbolic debug information byte types transitively propagated variables declared program exact type presence information bytes remain wholly partly unconstrained constraints established individual bytes systematically types block typing map fully defined typing alternatives memory blocks exhausted type assigned block consistent individual byte types offset block constraints imposed connections pointers blocks cases constraints suffice determine unique consistent typing consistent typings search ordering heuristic choose descriptive type heap block algorithm applies byte type location type conflict existing byte type address conflict arises memory values symbolic debug information present found specific instances pointer declared variable usage adhere notion consistency detailed section conflicts reported user blocks marked untypable omitted whole-block type assignment notation figure establishes concise notation types derived siff array elements type written ptr pointer tuple form denotes struct denotes untagged union triple giving type starting offset field structure union structure fields ordered offset starting offset union fields unordered start offset subtyping relation reflexive closure precedesequal type notation addr place subtyping constraint addr precedesequal type mapping evident context discussion byte offsets memory block represented terms addition block start address block storage block denotes address ith byte block starting abbreviate address block simply block predicate validpointer addr asserts addr holds start valid non-null pointer byte type lattice analysis yield multiple distinct types memory location cases reveals conflict misused memory cases types fact compatible section explains construct lattice set program types model type compatibility analysis data types figure form running paper omit explicit atomic internal substructure array type size struct untagged union function returning field labeled type offset atomic idk enum ptr pointer char int double figure concise type grammar struct point double double struct shape char file fptr struct part struct point center struct shape shape struct assembly owner struct partnode struct part part struct partnode struct assembly struct point center struct partnode nodes struct assembly owner figure data types assembly-building program referent interior pointerchar double char part assemblypartpartnode point shape figure byte type lattice data types figure struct keyword types remainder section defines subtyping relation construct byte type lattice shown figure clarity omit figure subtyping definitions assumed meet lattice elements lower bound defined denotes types consistently stored address structures structure 
initial offset field physical address distinct types supertype structure type initial field relationships part point double read address holds byte part holds byte point byte double contrast structure doubles considered subtype point similar layouts definition stricter physical subtyping chandra reps structure subtype prefixes design pointer aliases arise program casts evade type system policy choice permissive alternatives change rest analysis desired programming idioms special atomic types diamond-shaped nodes top figure present latticetop denotes unconstrained memory address hold type referent describes types referent pointer interior describes non-initial bytes multi-byte atomic values pointer targets referent subtypes interior holds eight-byte double byte type double bytes type interior pointed directly bitfields typed interior addresses pointer storage location holds byte valid pointer potentially consistent pointer type pointers pointers allowed pointer referent pointer void represents pointers specific program type oval nodes lattice correspond actual types program notice primitive atomic types sibling subtypes referent stipulates atomic types simultaneously stored address special case treat void zero-length type identical referent byte type void final result convention transparent handling aliases void fully typed pointers pointers void refer address system thoughvoidwere zero-length prefix referent subtype subtyping relation extended pointers precedesequal negationslash ptr precedesequal ptr standard restriction subtyping updatable program requires form subtyping describe heap necessarily casts measures violate type safety arrays define supertype array type type elements viewed type reasoning relation analogous structures unions untagged unions require special treatment union fields consistent typing requires address assigned unique type untagged union type extend type grammar include tagged case unions tagged cases adhere subtyping relations referent relations forbid aliased pointers differentlytyped union fields union single consistent manner point execution tagged union storing apoint target pointers untagged union pointers point double target pointer part fields union common supertype additional cases introduced represent subset tagged cases single case preserves uniqueness lattice meet operation note tagged unions multiple supertypes byte type lattice tree functions function pointed referent proper subtyping relations exist function types return type covariance argument type contravariance part standard calling function arguments safe implementations endorsed standard admitted policy choice permissive alternatives change rest analysis finite type space byte type lattice unbounded number types including arrays arbitrary length pointers arbitrarily deep nesting practice finite subset types meaningful program program-declared structures unions enumerations tagged variants unions types unions arrays program int field variable type pointers program int field variable type pointers types levels indirection number tagged variants unions union-containing types potentially exponential experience multi-union structures nested unions unusual number tagged variants typically linear additional array types synthesized needed analysis satisfy size constraints section element types appearing void main carassm create assembly assembly create assembly assembly assm malloc sizeof assembly partnode node malloc sizeof partnode nodepart malloc sizeof part nodenext node assmnodes node build part shape set init part nodepart door assm return assm figure program builds simple assembly original program block bytes typed int int byte type int element type int appeared original program consistency constraints section kinds constraints storage locations restrict types heap blocks show constraints combined derive consistent heap typing point program simplicity assume -bit architecture -byte pointers -byte doubles ideas generalize -bit architectures program excerpt figure creates part simple assembly initializes shape owner assembly figure shows heap call init part line figure blocks labeled arbitrarily line number block allocation label valid pointer values shown c-style syntax rest memory assumed set returned malloc bracketed numbers figure allocated blocks values init part call figure byte ranges block constraints constraints arise concrete data values memory instant analysis applied reflect fact data types limited domains smaller set values fit allotted memory generic constraints wide variety programs valid pointer constraint validpointer addr addr precedesequal pointer valid pointer constraints infer basic type information valid pointer require typed pointer section assumes nonpointer takes valid pointer chance strategy widely employed conservative garbage collectors enumeration constraint byte type enum consistent starting byte equal defined constants enumerated type enumeration constants uniquely identifying general rule infer basic type information values rule filter reject inferred hypothesized types inconsistent observed values function pointer constraint presence shared libraries debug information functions start addresses treat function pointer type consistent word-aligned address executable code mechanism identifying code pages platform specific due difficulty reliably distinguishing code data function pointer constraints filters manner enumeration constraints character constraint program manipulates ascii text block unconstrained ascii character values stored offset block block typed char char consistent primitive primitive array type double short character constraints change type search order infer reject types constraint applied character arrays considered resort arrays primitive types rejected section programmers define additional constraints reflect application-specific types invariants heap typing algorithm accommodate arbitrary predicates approve reject type proposed location data structure consistency specifications demsky applied additional constraints selected types table shows valid pointer constraints heap snapshot figure types physical layouts consistent constraint important detail locations similar constraints non-ascii locales character repertoire advance block valid pointers value-consistent types partnode shape part assembly part assembly partnode shape table valid pointer valueconsistent types heap figure block size size-consistent types partnode shape char part assembly shape partnode float part assembly shape partnode float partnode shape int char table size constraints size-consistent types heap figure holding unconstrained consistent pointer type primitive types partnode shape value-consistent block viewed null pointer size constraints type block fill number bytes allocated block address block start allocated block block sizeof block sizeof dynamically allocated arrays tile multiple copies element type block holding dynamic array elements type satisfy sizeof block sizeof number array elements table shows size constraints illustrative size-compatible types statistical debugging compound boolean predicates piramanayagam arumuga nainar ting chen jake rosin ben liblit computer sciences department wisconsin madison arumuga tchen rosin liblit wisc abstract statistical debugging dynamic instrumentation machine learning identify predicates program state strongly predictive program failure prior approaches considered simple atomic predicates directions branches return values function calls enrich predicate vocabulary adding complex boolean formulae derived simple predicates draw three-valued logic static program structure statistical estimation techniques efficiently sift large numbers candidate boolean predicate formulae present qualitative quantitative evidence complex predicates practical precise informative demonstrate approach robust face incomplete data provided sparse random sampling typifies postdeployment statistical blocks debugging categories heap subject snapshot descriptors type constraints software type engineering constraints software relate program multiple verification locations statistical methods blocks software engineering testing debugging debugging aids distributed debugging monitors tracing pattern recognition design methodology feature evaluation selection general terms experimentation reliability keywords statistical bug isolation three-valued logic debugging effort metrics dynamic feedback analysis introduction statistical debugging improves software quality pointers single block multi-byte structures addr precedesequal pointer addr allocated block past end addr referent addr precedesequal atomic type defined figure addr interior sizeof combined rule incompatibility interior referent forbids pointers interior atomic values iii allocated block starting block block referent similar rule rule affects leaked blocks points addr precedesequal ptr addr precedesequal pointers pointed-to types compatible modulo subtyping addr precedesequal addr structure fields compatible structure addr addr sizeof array elements compatible array implied constraints imply additional constraints consistent heap typing satisfy transitively implied type constraints untagged unions induce additional type 
constraints tagged union type subtype pick constraints rules debug constraints symbolic debug information inscope variables function arguments information added type map obvious manner equality constraints figure fully constrained heap derived typing heap figure integer variable identifying program mis behaviors highly predictive subsequent program failure embodied cooperative bug isolation research supported part afosr grant nsf grant ccfpermission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee issta july london england united kingdom copyright acm project cbi techniques find bugs programs analyzing reports collected software executing hands end users cbi instrumenting compiler injects extra code evaluates simple boolean expressions called predicates program points predicates designed capture potentially interesting program behaviors results function calls directions branches values variables termination instrumented program feedback report generated records predicate observed observed found true feedback reports large user community statistical debugging find predicates predictive failure predicates ranked presented developer cbi gathers execution reports valuable cpu cycles end user machines essential make cycles worthwhile extracting type int bit information predicates isolation previous work paper explores relations predicates predicates expressions involving program variables program points related control data dependences propose capture relations building complex predicates set currently-instrumented predicates refer simple predicates predicates boolean expressions combined logical operators conjunction disjunction construct complex predicates include input statistical analysis algorithms approaches combine predicates logical operators change instrumenting compiler explicitly monitor complex predicate run time estimate complex predicate values components approach yield precise significant modifications existing infrastructure approach precise requires modifications existing infrastructure instrumenting compiler present work implement approach serves proof concept complex predicates justification incorporating instrumenting compiler future remainder paper organized section reviews statistical debugging motivates present effort find complex failure predictors section precise definition complex predicates discusses complex predictors computed efficiently section defines metrics evaluate usefulness complex predicate section discusses case studies demonstrate usefulness complex predicates section presents results experiments conducted large suite buggy test programs including assessment effect sparse random sampling complex predicates sparse random sampling technique cbi reduce runtime overhead instrumentation section discusses related work section concludes offers directions future work background cbi lightweight instrumentation collect feedback reports truth values predicates execution outcome crash non-crash execution large numbers reports collected analyzed statistical debugging techniques techniques identify bug predictors predicates true herald failure due specific bug bug predictors highlight areas code related program failure provide information correcting program faults feedback reports collected deployed software hands end users encounter bugs identified program testing cbi monitor software release direct program patches identifying bugs manifest field finding bug predictors feedback report program execution formed bit-vector bits predicate observed true final bit representing success failure generated experimental testing conditions feedback reports complete instrumented code distributed end users predicates sampled infrequently reduce computational overhead previous experiments determined sampling rates realistic deployed reports cbi assigns score predicates identifies single predictor section assumed predictor corresponds important bug bugs remain top predictor recorded feedback reports true removed consideration assumption fixing bug change behavior runs predictor originally appeared predictor remaining reports identified recorded removed manner iterative process terminates undiagnosed failed runs remain failure-predictive predicates found process iterative elimination maps predictor set program runs ideally set corresponds expression distinct bug case due statistical nature analysis incomplete feedback reports resulting sparse sampling rates single bug predicted top-ranked predicates predictors prevalent bugs found output analysis list predicates highest score iteration elimination algorithm complete list predicates scores elimination performed lists programmer identify areas program related faulty behavior liblit employed method discover previously unknown bugs widely-used applications cbi output input automated analysis tool btrace btrace finds shortest controland dataflow-feasible path program visits set bug predictors analysis programmer examine fault-predicting behavior connection bug easily identifiable predictors numerous complex overwhelm programmer examining directly scoring predicates section overview numeric scores identify predictor set predicates detailed discussion topic reader refer liblit good predictor sensitive accounts failed runs specific mis-predict failure successful runs assigning scores based sensitivity result super-bug predictors include failures bug super-bug predictors highly non-deterministic specific single failure rarely provide debugging information scoring predicates based specificity results sub-bug predictors sub-bug predictor accounts portion failures caused bug unlike super-bug predictors sub-bug predictors account significant sub-set failures debugging perfect predictors preferred sensitivity specificity balanced numeric importance score computed truth values predicate runs aggregated values obs obs number successful failed runs evaluated number successful failed runs evaluated found true values scores bug relevance calculated sensitivity log log numf numf total number failing runs good predictor predict large number failing runs specificity increase amount true increases probability failure simply reaching line defined computed increase obs obs obs taking harmonic combines scores identifying predicates highly sensitive highly specific importance increase log log numf importance score calculated predicate top result selected runs top predicate true eliminated scores recalculated remaining predicates remaining sets runs process eliminating runs continues remaining failed runs remaining predicates expected benefits complex predicates single predicate thought partitioning space runs subspaces satisfying predicate closely partitions match subspaces bug expressed predicate bug predictor bug corresponds simple predicate simple analysis sufficient analysis complex bugs produce superand sub-bug predictors richer family predicates describe complex shapes space runs good predictors bugs complicated bugs connected simple predicates single predicate accurately predict complex predicates formed simpler accurate predictors component predicate partial predictors predicates predict aspect bug sufficient program failure partial predictors sub-bug predictors classes simple predicates combined accurate predictors 
partial predictor correctly partition expressions bug predict bug large number runs occur partial predictors highly non-deterministic respect bug outscored subor super-bug predictor partial predictors improved eliminating false positives accomplished taking conjunction predicate captures aspect bug case study presented section describes bug predicted conjunction involving partial predictor sub-bug predictors correctly partition expressions bug identifying bug predict bug general sense extremely good predictors special case bug expressed combining predictors disjunction reduce false negatives result predicate correctly partitions manifestations bug combine special cases manner resulting predicate predict bug general case important note analysis find disjunction predictors individual bugs predictor set failures problematic disjunction high-ranked component predicate good predictor specific bug providing information bugs involved bug predictors result combining simple predicates conjoined disjoined eliminating false positives false negatives approach perfect predictor process continue eventually finding good predictor bug expressed terms simple predicates measured construction feedback reports aspect bug uncovered simple predicates sub-bug predictor constructed introduction complex predicates cbi analysis greatly increases number shapes set runs increasing chances finding accurate predictor bug complex predicates complex predicate defined simple predicates function conjunctive normal form cnf evaluating requires combining predicates negation operator required design negation cbi predicate predicate predicates boolean functions hundreds simple predicates involved analysis prohibitively large number reduce complexity functions predicates functions conjunction disjunction easily understood programmers revised definition conjunction disjunction commutative reflexive cases uninteresting reduces number complex predicates parenleftbign parenrightbig binary conjunctions equal number binary disjunctions evaluated set runs time revised definition complex predicate related definitions trivially extended general case measuring complex predicates predicate run true observed true run similarly define definition complex predicate true iff point execution program observed true difficulty notion complex predicates int subtype main algorithm section require debug information find consistent typings takes debug constraints account present solution combine size type constraints informally derive consistent heap typing shown figure section presents systematic algorithm finding consistent typings automatically clarity user-defined types matches arrays primitives assume debug constraints unavailable valid pointer size constraints block type shape partnode shape considered propagate char constraint block rule size constraints require block type char char precedesequalchar block type char consistent char pointer block partnode conflict arisen discuss conflicts detail section size constraints block type assembly part assembly partnode rule partnode rule conflicts shape established earlier choosing part consistent shape requires assembly consistent size constraints block lastly block type partnode due pointer field initial constraints identically-structured types consistent typing necessarily unique bytes block consistent heap typing char char char char char heap typing algorithm section present algorithm assigning types storage locations consistent typing inputs algorithm consist snapshot values program memory start addresses sizes allocated heap blocks list defined program types optional symbolic debug information giving locations sizes types in-scope variables output typing giving consistent byte types allocated bytes byte type byte allocated block type block cases globally consistent typing exists algorithm identify describe eliminate untypable blocks producing partial typing remaining blocks algorithm begins assigning types individual bytes storage values arise program valid pointers pointedto locations foremost source byte type constraints section transitively propagate byte types variables declared program exact types reporting type constraint violations user section finally systematically types memory block typing map fully defined typing alternatives blocks exhausted section pointer constraint gathering establish valid pointer constraints individual bytes section type constraint rules iii induce additional constraints conflicts referent interior arise stage blocks hold valid pointers points byte simultaneously referent pointer interior pointer situation difficult block erroneous describe conflict user mark blocks untypable disregard remainder algorithm phase typing constrains bytes subtypes pointer interior referent bytes remain unconstrained latticetop program types debug constraint gathering symbolic debug information debug constraints applied propagated transitively pointers compound types type constraint rules size constraints checked note size constraints partially enforced block large expected type larger target double bytes long longer part larger structure union array stage conflicts arise debug constraints int float location debug size constraints int two-byte block debug constraints debug pointer referent interior constraints derived previous stage conflict occurs assume execution deviated type safety static type system trusted predict run-time types report problem user back debug constraints remainder algorithm operate observed memory values declared variable types selective approach leave future work discard minimal subset problematic debug constraints keeping remainder barring conflicts conclusion phase global typing includes program types memory addresses transitively reached pointers program variables types lattice upper bounds pointer char point array characters structure initial char field bytes reachable blocks bytes unreachable blocks carry pointer referent interior constraints added previously completing heap typing initial byte type constraints assign type heap block fully enforced size constraints ensure size block type equal block size allocated bytes constrained typing completed byte block determines block type typing feasibility check typing completion begins verifying heap block assigned program type initial constraints block assigned type corrupt allocated library internal types unavailable describe problematic block user mark untypable disregard type search phase search algorithm main search phase considers types block backtracking event conflicts type verified consistent current size type optional debug constraints block update byte types bytes block reflect type propagate constraints level forward pointers block proceed block consistent type found block induced constraints block type considered outcome blocks file size conflict sizeof sizeof file part shape shape type conflict meet shape file assembly partnode partnode part partnode size explicitly conflict monitored sizeof program sizeof execution partnode shape true char char true table heap imply typing algorithm execution trace true backtrack single program block point remaining true type alternatives stages resume execution search true point time algorithm terminates source considered locations block assigned consistent single type point time types blocks welldefined failed simultaneously case observable consistent order typing exists vely estimate implemented search geometric components number adapt blocks time-sensitive exponential definition number types definition complex entire predicate block type subtype true iff byte type true search words restricted treat distributive effectively sublattice removing requirement bound optimization observed simultaneously effective debug lead constraints false enabled positives pointers refer computed initial true byte allocated false block moments heuristic type time false ordering discussed negatives section arise heap impact assumption consistent typings score prefer typing positive negative informative depending user failed succeeded types three-valued logic block section explains order conjunctions structs disjunctions large small tagged unions large small atomic types large small non-enums enums size arrays recursively sorted element type pointers recursively sorted referent type ties ordering broken arbitrarily note untagged unions omitted order treat untagged unions akin abstract base types object oriented languages block untagged union actual type specific tagged cases union instantiated allocated blocks intuitively block program-defined type showing type array primitives informative size ordering addresses issue assign large struct type block array small structures place primitives pointers find unconstrained block zeroes presented naturally array primitives array null pointers recursive sorting pointer types places typespecific pointers int generic void shallowly nested pointers void deeply nested pointers void order designed heuristically direct solution typings guarantee final heap typing globally minimal optimal respect order find yields good results practice computing solution illustrate algorithm applied running heap snapshot init part call line figure illustrate conflict handling modify values shown figure assume bytes corrupted longer hold valid pointer constraints remain shown table debug constraint collection inconsistency arises part constraint propagated variable node part requires valid pointer null bytes conflict found debug constraints discarded search continues constraints block pass typing feasibility check omitted search table summarizes steps backtracking search complete types remaining blocks considered allocation order types ordered sorting heuristic algorithm recover types remaining blocks size constraints backtracking times search final heap typing remaining blocks shown figure propagation correctness assigning type block update constraints block propagate pointer constraints forward dereference claim sufficient ensure inconsistency typed blocks overlooked proof loss generality assume inconsistency blocks levels pointer indirection intermediate block resp denote byte resp constrained resp prove claim show inconsistency detected crossing pointers order algorithm considers blocks blocks ordered constraint account assigned type propagated directly time orderings algorithm unable assign consistent type block eventually backtrack type remaining 
orderings order constraint propagation directly correspond block order ordering algorithm advances block previous consistently typed consistency guaranteed considered time cases arise assigning type type assignment requires modifying type rejected type determined byte types frozen henceforth reflect type type consistent consistent violates initial assumption conflict argument remaining orderings similar alternative scenario disconnected blocks refer block constraints imposed invalidate consistency induces constraint computed three-valued logic required predicate run arise situations predicate observed run run reach line defined program reached line predicate defined observed sampling cases predicate considered unknown analysis introduced section true true false unknown constructing compound predicates subcases true separately additional run information derived constructing compound predicate requires generating bits program run observed run observed true run case compound predicate observed true generated true components complex predicate false modifies run constraint conflict false false prime disproves prime precedesequal evaluation implemented conjunction algorithm gnu debugger true gdb popular symbolic observed debugger true program stopped unknown breakpoint shown user type three-valued whatsat truth expr table perform table heap type similarly inference true display proves typeannotated disjunction memory beginning disjunction address false computed expr implementing components validpointer observed predicate false requires truth table debugger probe predicate debuggee current heap shown allocation table state table modify three-valued debuggee truth tables memory management complex routines predicates maintain conjunction list allocated downslopep blocks reserved global location disjunction debugger debugger downslopep reads list directly debuggee address interesting space complex needed predicates record start revised address definition size number block complex address predicates quadratic instruction number allocated simple block predicates whatsat large number complex diagnostic predicates messages formed report procedure source file line number useless function analysis untypable program block complex allocated predicate extra allocation lower tracking score standard hooks exposed components gnu useless libc component implementation simple predicate contained higher shared score library predictor preloaded failure program wishes complex predicate debug adds recompilation relinking analysis definition allocation hooks complex predicate zero-initialize newly allocated blocks interesting iff importance avoid spurious max typing importance errors due importance random data values case uninitialized heap complex memory predicate score disable component predictor feature simpler order verify preferable keeping program interesting study fully combinations initializes predicates reduces memory heap burden storage storing normal running helps conditions ensure utility section visualization complex predicate typed memory presented heap type inference user whatsat pruning displays constructing memory complex contents predicates augmented simple derived type requires information generating visualization bits begins information address user three-valued choosing logic discussed whatsat section whatsat program run foo cbi continues meant forward analyze raw deployed memory software user program runs control potentially figure number shows part hundreds type-annotated thousands heap millions assembly-building measure program earlier predicate line relevance shows bug capitalized hexadecimal importance memory score address section complex predicates word raw computed memory content three-valued address bits generated interpretation runs memory small typed test datasets algorithm thousand runs double computation multiword takes atomic types ten minutes double extend turns multiple lines memory visualization complex predicates indentation field interesting labels reflect low nesting importance scores compound types figure presented shows distinct programmer proximate cases memory effort blocks compute scores structures wasted character array suggests prune labels combinations left run information address mark generated locations based estimate allocated resulting scores allocated estimate falls table shows threshold required complete list predicate memory category presented codes schedule programmer schedule exact small score application computed siemens reduces buggy program complexity suite constructing run list information jobs common case priorities input application threshold computes importance prints schedule complex predicates running jobs potentially exceed seeded schedule constructed argument-transposition calculated code category heap ways allocated interesting typed complex heap predicates allocated retained untypable heap complex freed predicate heap allocated threshold stack importance static data static max code importance static importance miscellaneous table memory redundancy category codes elimination bug predicate temporarily disable debug highest score constraints retained running schedule iteration threshold test importance inputs inputs leads highest score crash prio including queue simple mem predicates count prio simplify queue formulae global derived array list section pointers introduce element terms notations null heap consistency set check program runs usingwhatsatfinds consideration untypable blocks suggesting obs denotes outright heap number runs corruption rerunning observed program debugger backtrack number runs point prio observed queue true non-null whatsat finds number types runs blocks predicate observed infers prio queue observed points true block equal type ele obs yetprio queueshould array unknown oflist quantity pointers ele pointers denote continue estimated upper rerunning lower program bounds stopping earlier exact earlier points time upper usewhatsatto bound test whetherprio estimate queue importance guarantees ele predicate pointer pruned erroneously proper list upper pointer bound brings computed buggy maximizing call increase ele log pointer log argument numf list constraints pointer based argument passed boolean operation wrong importance order compiler equation type checker harmonic failed catch terms swap due inadequate likewise function maximized prototyping equation unfortunate increase uncommon problem obs execution decrease continues obs bad call increase part increase physical layouts upper ele bound list increase sufficiently increase similar code intended obs incorrectly obs non-fatally manipulate obs heap component type inference importance log distinguish log numf numf correctly determines constant prio maximizing queue yields upper bound whatsat quotient query note ran seconds required struct assembly upper bound center struct point term increase conjunction double set runs table observed double true observed true nodes equivalently struct set partnode runs observed true owner intersection struct assembly exceed sizes sets runs observed true observed true min likewise minimized minimum overlap set struct runs partnode observed true part struct part struct partnode struct part center struct point double double observed true minimum overlap shape struct long shape exceed owner total struct number assembly runs observed runs max obs observed observed true struct shape observed false char maximize obs door instances cases file struct maximized file min applications rule set runs observed true completely overlap applications rule sets runs char observed true nonoverlapping overlap cases sum exceeds total number runs obs figure min type-annotated heap excerpt min assembly-building program finally abb minimize obs applications abbc rules struct mentioned queue struct minimized queue happen abc false length observations int abc completely overlap head contributing max struct process struct obs queue true abc observations length int overlap abcc outcomes head min struct process runs struct fixed queue previous rule abd effectively reducing length number int runs abd rprime min head struct process struct queue abd length int abdc head struct process abe abe void size const void abe void void const void abec void void size const void realloc hook ini abf void size size const void memalign hook ini abf abf figure schedule global variables visualization preceding analysis conducted debug constraints whatsat prior knowledge prio queue list pointers debug constraints included type prio queue requires pointed-to elements type list bad prio queue pointer incompatible ele type required size constraints whatsat detects reports conflict debug constraints pointer misuse broken type correctness trashing heap manner wild pointer bug buffer overrun schedule schedule implementation job scheduler part siemens suite version schedule bug program crash inside malloc stack trace reveals crash due bad pointer dereference function pointer malloc hook point function whatsat confirms claimed type malloc hook inconsistent debug constraints satisfiable debug constraints discarded whatsat infers block process structure malloc hook assigned malloc hook holds bad process pointer function pointer whatsat explore physical memory neighborhood malloc hook reveals four-element structure array precedes malloc hook figure shows whatsat visualization area malloc hook appears address abe preceding array visible starting address abc observe malloc hook perfectly positioned receive errant process pointer neighboring array overrun bounds informed identify array code writes missing bounds check constitutes true bug whatsat queries case study completed seconds hardware watchpoint trap bad write malloc hook require rerunning program reproducing bug memory corruption bugs difficult reproduce demand bugs amenable sort iterative backtracking section whatsat provide postmortem information instance bug space space interpreter antenna array definition language adl written european space agency distributed galileo subject infrastructure repository consists correct version lines code buggy variants extensive test suite ran correct version test inputs inputs debugger breakpoint set end main point memory blocks allocated heap whatsat query completes seconds finds correct variant space untypable block untypable block bytes allocated elemdef space block allocated whatsat finds problems types block elem informal binary search suggested section reveals block corrupted assignment uninitialized local variable fields field int uninitialized receives valid pointer left stack earlier calls type elem pointer place int field block untypable correct version space runs correctly improperly initialized field code bug previously unknown knowledge previously reported published literature space test suite exif exif open source utility manipulating jpeg image metadata consists lines code split shared library main driver program ran exif breakpoint set exif loader data builds in-memory representation jpeg input file disabled zero-initialization heap blocks test exif performs initializations properly whatsat identifies untypable blocks allocated exif content add entry exif-content code question performs reallocation grow array pointers entry blocks entries realloc entries sizeof exifentry count size calculation incorrect reserves space array exifentry structures entries array pointers exifentrystructures eachexifentry larger pointer program overrun buffer extra space end array wasted uninitialized random data valid pointers whatsat determines arrays allocated untypable initially 
identified previously unreported bug release exif driver library confirmed persists latest development snapshot april lines code exif developers confirmed bug applied suggested fix whatsat identifies untypable blocks ignores remainder analysis analysis find valid heap typing exif timely manner valid typing exists individual blocks match type valid typing exists pathologically mismatched heuristic search order improving diagnostic capabilities analysis unresolvable conflicts arise late search important area future study related work chandra reps siff introduce alternate type system subtyping based physical layouts data structures describe static type checking inference rules test program conformance alternate type system contrast approach dynamic examine frozen snapshot running program heap space program heaps concrete memory values allocated block sizes refine analysis typical dynamic analyses focus specific bugs triggered run guaranteeing bugs detected subtyping relation induced byte type lattice restrictive chandra siff physical subtyping relation subtyping structure field disallow general structure prefixing char arrays storage placeholders policy choices approach permissive chandra siff subtyping variety relations constraint collection core heap typing algorithm subtyping relations context cardelli structural record subtyping relation disregards field order needlessly permissive scenario field orders fixed dynamic heap-walking tool system shares qualities garbage collector leak detector list unreachable leaked memory blocks easily extracted analysis traditional garbage collectors require data structure layout information root set possibly allocated blocks conservative garbage collectors relax requirement assuming location holding valid pointer pointer approach moves flexibly extremes type information global stack storage operate making pointer assumptions manner conservative collector ultimately information recover richer produced garbage collectors find size embedded pointers allocated block complete program types globally consistent blocks zimmermann zeller present strategies extracting heaps displaying highlight key relationships system depends debugger-provided type information augmented c-specific heuristics whatsat pointer validity testing dynamic array size computation heuristics isolated blocks notion global consistency zimmermann zeller comment heuristics make good guesses safer provide explicit disambiguation rules hand-crafted inferred program dynamic heap type inference generalizes improves heuristics defining notion global heap typing considers local values isolated blocks relationships interlinked blocks lets whatsat find globally consistent heap typings reduces eliminates hand-crafted disambiguation rules note visualization zimmermann zeller abstracts physical block locations favor box-and-arrow diagrams whatsat visualization focuses physical layout proximity representations interest depending debugging task hand problem heap corruption due pointer cast abuse longstanding inspired solutions ranging static analysis run-time instrumentation design safer language dialects approach performs programmer-directed heap validity checks interactive debugging context attempt prevent trap errors occur significantly invasive require language recompilation source annotation compiler-provided list program types run-time instrumentation list allocated blocks dynamic type tagging data structure layouts additionally analysis depends instantaneous state program heap moment time maintaining list allocated blocks record trace information program runs sense whatsat experiment minimalism monitor potentially interesting action information recovered bare minimum imposition run-time highly invasive minimally invasive approaches benefits exploring extremes helps illuminate potential runs runs selected overlap failing rprime overlap sets obs max max rprime table bounds required equation conjunction quantity bounds min max obs min min obs max max fprime fprime min table bounds required equation disjunction quantity bounds min max obs min min obs max max fprime fprime min simplicity generality preceding discussion derives bounds general set runs table lists specific bounds required equation conjunctions substituting set successful runs set failed runs place approach disjunctions similar interest space omit derivation list bounds disjunction table concrete assume successful runs failed runs observed runs assume substituting computing bounds listed table obs obs upper bound increase upper bound importance log log complex predicate generated iterative elimination step section predicate cprime scored prune computing exact score estimate importance computed upper-bound actual score making mathematically impossible beat cprime fully evaluated upperand lower-bound estimates conservative pruning complex predicates calculations threshold reduces computational intensity analysis affecting results effectiveness pruning practice examined section usability metrics 
experiments observe hundreds complex predicates similar identical high scores redundancy elimination algorithm select top predicate randomly tied top score human programmer finding predicate debugging make similar choice importance measures predictive power high-scoring predicates good bug predictors perfect predictor difficult programmer finding fixing bug debugging simple predicate aided understanding connection predicate bug predicts complex predicate programmer understand connection components set complex predicates similar high scores easily understood human preferable notion usability hard quantify measure section propose metrics selecting understandable predicates large set high-scoring predictors predicates selected metrics presented user data analyzed automated tool advantageous employ metrics metrics criteria unrelated predicate importance score making orthogonal pruning discussed section mentioned earlier objective function approximated metrics hard measure experimentally find metrics work practice effort metric models debugging effort required programmer find direct connection component predicates adapt distance metric cleve zeller purpose metric score predicate fraction code searching bug similar metric called effort complex predicate definition effort required programmer complex predicate inversely proportional smaller fraction code breadth-first bidirectional search vice-versa idea metric larger distance predicates greater effort required understand relationship large number branches search programmer track dependencies cleve zeller program dependence graph pdg model program source code perform breadth-first search starting reached count total number vertices visited search fraction code covered ratio number visited vertices total number pdg vertices correlation metric considers correlation predicates predicates easily reached apparent connection complex predicate formed provide programmer hand predicates affected shared area code connection programmer easily discern correlation predicates defined based program dependency graph single predicate define predecessor set set vertices pdg influence definition correlation predicates complex predicate defined number vertices intersection predecessor sets idea metric larger intersection predecessor sets means closely related expect correlation mitigate issue disjunctive predicates raised section disjunction predictors separate bugs scored highly predictors unrelated program faults reside areas program intersection predecessor sets smaller related predictors bug closer proximity proactive reactive pruning metrics applied proactively reactively proactive metrics removes complex predicates metric values fall threshold usefulness avoids computing scores improves performance reactive metrics retains predicates breaks ties giving higher ranks values metrics desirable computing time space concern case studies section discusses cases complex predicates prove study concerns memory access bug inexif open source image manipulation program complex predicate increasing score extremely bug predictor study input validation bug ccrypt explain complex predicates identify partial predictors automatically studies present predicates found automated analysis noted cases predicates discussed top-ranked fact removed redundancy elimination algorithm predicates manually identified full list predictors demonstrates techniques effectively filter large numbers complex predicates discussed section exif exif crashes manipulating thumbnail canon image bug function exif mnote data canon load module handling canon images snippet function count buf size return entries data malloc condition buf size true line allocation memory pointer entries data line skipped program crashes code reads entries data checking pointer valid non-deterministic bug program succeeds long uninitialized pointer accessed generated runs program input images randomly selected set canon non-canon images bug studied rarely manifests set images designed trigger sufficient failed executions run executed randomly-generated command line arguments omitting arguments triggered unrelated bugs successful executions crashes applying redundancy elimination algorithm simple predicates produces predicates account failed runs shown table studying source code program show obvious relation predictors failure predictor present crashing function comparison unrelated variables loop iterator size data stored traversed array true failures analysis assigns low score predicate buf size fact captures exact source uninitialized pointer bug nondeterministic true runs succeeded making partial predictor including complex predicates analysis produces complex predicate shown table row component complex predicate conjunction keyword start conjunction predicate offset len eliminates false positives earns high score conjunction improve score partial predictor function exif data load data calls exif mnote data canon load indirectly partial predictor capturing condition drives bug crash deep relationship find relation spending couple hours understand source code reduce importance result conjunction high score compared individually point uninitialized pointer hypothetical predicate entries data perfect bug predictor cbi instrumenting compiler instrument condition direct equivalent assumes entries data zero-initialized exif mnote data canon load returns early filling field predicate critical additional information identifies initial trigger skipping malloc sets stage eventual failure uninitialized pointer role complex predicates capture program behaviors sufficient preconditions failure ccrypt ccrypt bug crash wheneof received confirmation prompt overwriting existing file eof contexts failure examination source code quickly reveals read response user int prompt void line xreadline fin cmd return strcmp line strcmp line char xreadline file fin char myname res fgets buf initsize fin res null free buf return strategies improve debugging tools instrumentation analysis spectrum future work conclusion extensions work improved efficiency enhanced user experience backtracking reduced treating blocks pointers graph nodes edges traversing strongly connected components heap graph topological order richer error reporting include detailed trace constraint conflicts surrounding untypable blocks expect valuable diagnostic aid static program information types casts immediately follow malloc calls treated additional source constraints independent opinion dynamically observed types agree general algorithm accommodate variety subtyping policy choices application-specific consistency constraints provisions end-user customization extension analysis tool helpful wider variety programs programming styles low-level programming languages require low-level debugging completely abandon type system working non-type-safe languages low-level type-annotated view heap debugging general program understanding tasks presented algorithm infers program-defined types memory locations solution consistency defined terms constraints blend ideas physical subtyping conservative garbage collection consistent typing exists due heap corruption pointer abuse offer focused diagnostic information identify implementation works general programs requires source annotation recompilation run-time instrumentation heap allocation tracking physical data structure layouts experiences tool limited scope suggest dynamic heap type inference addition programmer toolkit lars ole andersen program analysis specialization programming language phd thesis diku copenhagen todd austin scott breach gurindar sohi efficient detection pointer array access errors pldi proceedings acm sigplan conference programming language design implementation pages york usa acm press hans-juergen boehm mark weiser garbage collection uncooperative environment software practice experience luca cardelli structural subtyping notion power type popl proceedings acm sigplan-sigact symposium principles programming languages pages york usa acm press satish chandra thomas reps physical type checking workshop program analysis software tools engineering pages brian demsky michael ernst philip guo stephen mccamant jeff perkins martin rinard inference enforcement data structure consistency null return buf calls xreadline function user input return null circumstances cases checked dereferenced prompt immediately call line xreadline returning null prompt perfect predictor failure occurring successful runs failure related bug branch line xreadline important serving moment failure prompt inevitable branch user enters eof table results exif simple predicates score predicate function file line len len jpeg data load data jpeg-data exif mnote data canon save exif-mnote-data-canon table results exif complex predicates score predicate function file line buf size true exif mnote data canon load exif-mnote-data-canon offset len exif data load data exif-data command line mapping failure programmer clear understanding code spend time tracking user-entered eof xreadline null dereference prompt requiring visual inspection source interactive debugger knowledge connection program events make good debugging decisions adding null check prompt versus ensuring xreadline returns valid pointer automated bug analysis ideally reveal chain causation programmer generated runs ccrypt randomlyselected command line arguments input files include images text archived online documentation remote desktop display system successful executions crashes failing runs crash due null dereference bugs visible test suite initial analysis simple predicates table finds xreadline top predictor failure true failed runs successful runs verifying assumptions related predicate res char scores substantially lower appearing failures large number successes reported score low knowledge nature bug programmer overlook significance additionally relationship removed redundancy elimination algorithm importantly traditional cbi analysis reveals connection predictors programmer fact sufficient condition failure subordinate predicting crash complex predicates included analysis table conjunction top predictors finding bug easily identified traditional cbi analysis reveal nature partial predictor conjunction observed successful runs true number successes failures conjoined affecting predictive power 
demonstrates connection predicates case suggesting implication detectable experiment run complete data collection results sparse sampling specifications issta proceedings rates made detection impossible likelihood unobserved run true additionally detected absence bugs intuitively unrelated bug faults program runs allowing analysis distinguish unrelated sets predictors tested result evidence complex predicate analysis automatically group related predicates ways traditional cbi analysis including discovery partial sub-bug perfect predictor hierarchies implications grouping related predictors statistically insight program structure execution features debugging reiterates complex predicates collaborate tools btrace produce execution trace set predicates cooperative bug isolation utilize techniques previously required detailed execution information generating facsimile statistical data experiments section presents quantitative data ideas presented previous sections data collected siemens test suite maintained galileo software-artifact infrastructure repository sir configurable parameters experiments sampling rate effort cutoff section default sampling rate complete data collection default effort predicates reachable exploring program considered siemens application multiple variants bugs variants print tokens variants tcas report aggregate results averaging relevant measures variants siemens application codesurfer build program dependence graphs compute effort correlation metrics section top-scoring predicates table shows number buggy variants siemens application experiments buggy programs perform statistical debugging analysis iterative redundancy elimination algorithm discussed earlier sampling rate determine top-scoring bug predictor simple predicate complex conjunction complex disjunction table reports kinds predictors appears highest score conjunctions dominate programs tested selecting conjunction top bug predictor confirms complex predicates diagnose failures accurately simple predicates siemens program variant single bug expected disjunctions needed frequently disjunctions play smaller significant role case schedule singlebug programs disjunctions helpful simple predicate perfectly aligns condition failure section explains chance observing complex predicate shrinks quadratically sampling rate conjunctions remain important sparse sampling table results ccrypt simple predicates score true successes false successes predicate function file line xreadline prompt traverse res char xreadline xalloc table results ccrypt complex predicates score true successes false successes predicate function file line xreadline prompt traverse res char xreadline xalloc type top predictor application variants simple conj disj print tokens print tokens replace schedule schedule tcas tot info table number buggy application variants experiments number percentage complex predicate top-scoring predictor results shown complete data collection sampling rate sampling siemens applications excluding tcas show conjunction top-scoring predictor tcas looping recursion function called simple predicate international symposium software testing analysis portland usa july hyunsook sebastian elbaum gregg rothermel supporting controlled experimentation testing techniques infrastructure potential impact empirical software engineering international journal david evans static detection dynamic memory errors pldi proceedings acm sigplan conference programming language design implementation pages york usa acm press exif tag parsing library http libexif net free software foundation boston usa gnu library edition july john gilmore stan shebs gdb internals february reed hastings bob joyce purify fast detection memory leaks access errors proceedings usenix winter conference pages san francisco usa usenix association monica hutchins herb foster tarak goradia thomas ostrand experiments effectiveness dataflowand control-flow-based test adequacy criteria proceedings international conference software engineering pages ieee computer society press international organization standardization iso iec programming languages international organization standardization geneva switzerland december trevor jim greg morrisett dan grossman michael hicks james cheney yanling wang cyclone safe dialect proceedings general track usenix annual technical conference pages berkeley usa usenix association richard jones paul kelly backwards-compatible bounds checking arrays pointers programs aadebug pages stephen kaufer russell lopez sesha pratap saber-c interpreter-based programming environment language proceedings usenix summer conference pages san francisco usa june usenix association alexey loginov suan hsi yong susan horwitz thomas reps debugging run-time type checking fase proceedings international conference fundamental approaches software engineering pages london springer-verlag george necula jeremy condit matthew harren scott mcpeak westley weimer ccured typesafe retrofitting legacy software acm transactions programming languages systems nicholas nethercote julian seward valgrind program supervision framework electronic notes theoretical computer science gregg rothermel roland untch chengyun chu prioritizing test cases regression testing ieee transactions software engineering michael siff satish chandra thomas ball krishna 
kunchithapadam thomas reps coping type casts oscar nierstrasz lemoine editors esec sigsoft fse volume lecture notes computer science pages springer geoffrey smith dennis volpano sound polymorphic type system dialect science computer programming bjarne steensgaard points-to analysis linear time symposium principles programming languages pages joseph steffen adding run-time checking portable compiler software practice experience filippos vokolos phyllis frankl empirical evaluation textual differencing regression testing technique icsm proceedings international conference software maintenance page washington usa ieee computer society thomas zimmermann andreas zeller visualizing memory graphs software visualization international seminar dagstuhl castle germany revised lectures volume lecture notes computer science pages springer 
observed single tcas run two-predicate conjunctions infrequently observed sampling sparse tcas experiments complex predicate top predictor effectiveness pruning restricted binary conjunction disjunction complex predicates substantially increase analysis workload vely implemented section suggests heuristics pruning complex predicates understandable programmer section describes compute upper bound predicate score figure shows measures highly effective practice average candidate complex predicates discarded effort defined definition require traversing application code computing exact scores remaining complex predicates takes average minutes pruning complex predicates upper bound importance scores computed section lower scores constituent simple predicates eliminates complex predicates pruning reduces average time required analysis minutes complex predicates remain exact scores computed roughly fourth initial pool retained potentially interesting bug predictors find techniques proposed earlier significantly reduce computational load required identify high-scoring subset complex predicates pruning based upper bound estimation applied aggressively applying stricter thresholds redundancy elimination interested complex predicate score larger simple predicate threshold eliminates average complex predicates opposed pruned moderate threshold earlier analysis takes minute average complete experiments conducted nodes heterogeneous condor cluster absolute timing measurements mentioned precise relative improvement valid application time configurations pruning aggressive pruning measured condor node effect effort figure shows number interesting conjunction disjunction predicates definition varies effort levels expected effort increases predicates evaluated interesting predicates found effect sampling rate real deployments cbi sparse random sampling simple predicates reduce performance overhead protect user privacy prior work recommended sampling rates balance data quality performance privacy concerns pair independent features observed runs chance observed raising doubts interesting complex predicates found sparsely sampled data note complex predicate values observed simple component rules table table shows average number interesting simple complex predicates found siemens application complete data collection realistic sampling rates figure shows information additional denser rates print tokens siemens applications behave similarly omitted brevity number interesting disjunctions low order tens compared interesting conjunctions sampling rates lower sharp drop number interesting conjunctions due shrinking odds observing components conjunction single run sharp drop number interesting conjunctions comparable number interesting simple predicates sampling shows interesting complex predicates found sparse realistic sampling rates puzzling trend figure curves rise interval dropping siemens applications exhibit similar bump bumps conjunction disjunction curves attributed bump simple predicates curve print tokens print tokens replace schedule schedule tcas tot info application fraction complex predicates prune effort prune score upper bound low compute exact score low compute exact score retain conjunctions print tokens print tokens replace schedule schedule tcas tot info application fraction complex predicates prune effort prune score upper bound low compute exact score low compute exact score retain disjunctions figure avoiding computing exact scores pruning complex predicates summarizes entire siemens suite simple conjunctions disjunctions application print tokens print tokens replace schedule schedule tcas dynamic tot heap type inference program understanding info debugging table marina sampling polishchuk rate microsoft number corporation interesting marinapo predicates microsoft averaged ben liblit variants wisconsin siemens madison liblit application wisc marks average chlo count schulze oracle corporation chloe interesting schulze oracle predicates abstract variant programs increase difficult number debug interesting due simple lax predicates type enforcement produce low-level access greater increase memory present number dynamic interesting analysis complex predicates checks heap snapshots additional consistency simple predicates program types approach redundant builds ideas explained physical subtyping transient increase conservative number garbage simple collection predicates infer moderate program-defined sampling type rates previously allocated storage undiscovered location initially identify untypable counterintuitive blocks closer inspection reveal heap experimental corruption results type reveals safety scenarios violations analysis exploits happen symbolic debug scenario information due present requires hoc annotation perfectly recompilation reasonable elimination list seemingly defined identical program predicates types allocated heap blocks predicates integrated analysis gnu debugger gdb score describe initial retain experience tool stringent small condition medium-sized programs categories subject descriptors software true engineering testing observed debugging runs debugging aids affect programming outcome languages language classifications true programming runs languages language sampling constructs rates lower features data types structures dynamic observed storage runs management logics number meanings runs programs studies program observed constructs true type structure general scores terms algorithms human factors languages hoc elimination reliability heuristic keywords performs dynamic type effectively inference lower constraints sampling debugging rates tools leading heap visualization increase physical number subtyping conservative interesting garbage simple predicates collection introduction suppose programmer notices incorrect variable execution program debugging programmer observe values variable points execution setting watchpoint debugger inserting print statements techniques inadequate debugger watchpoints prohibitively slow adding print statements ineffective cases memory supported part nsf grant ccrwork performed wisconsin madison permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee popl january nice france copyright acm corruption affected data structure apparent relation code corrupts programmer run static pointer analysis check erroneous memory accesses typical analyses model dependencies neighboring memory blocks bugs caused buffer overruns pointer mismanagement physical proximity memory blocks important factor designed implemented automated tool programmers understand debug program behavior physical memory level tool offers programmer low-level typed view memory allocated chunk presented inferred data type untypable defined program type compatible imposed constraints common scenario view case buffer overrun attempt deduce data structure lies corrupted location raw memory values printed variables programmer tool discover nearby memory block array type mere presence array makes buffer overrun good hypothesis array type helps programmer identify relevant code examine array bounds violations memory corrupted tool detect values stored heap blocks match feasible type block order reason corruption programmer heap corrupted task support binary search debugging strategy find ill-behaving code set breakpoint location variable correct wrong iteratively narrow interval bad assignment exposed tool programmer ability treat entire heap memory good bad state search time heap corrupted usual dynamic debugging techniques binary search paper makes contributions introduce idea consistent typing heap point execution block allocated storage assigned type program type assignment satisfies set constraints imposed values stored memory size allocated block type conformance relation precedesequal based physical subtyping additional constraints imposed declared program variables debugging information give algorithm finds consistent typing snapshot heap consistent typing exists report locations conflicts user remainder paper organized establish basic terms section define subtyping relation types individual bytes section section specifies constraints satisfied set typed memory locations considered consistent section algorithm find consistent typing entire heap section presents case studies tool section places system context related work section concludes preliminaries describe scenario solve problem finding consistent typing heap provide key definitions notation paper definitions typing map store types storage location addr store type types types defined program including structures unions pointers arrays functions storage locations include fixed set addresses holding global variables set locations hold local variables function arguments stack current program point multiple stacks multithreaded programs memory blocks dynamically allocated start program refer heap storage globals locals function arguments type information symbolic debug information present memory blocks heap storage dynamic type information unions untagged standard manner conservative garbage collectors define valid pointer block memory store storage location valid pointer point immediately end block storage common programming idiom explicitly allowed standard type constraint restricts types reside storage location analysis imposes constraints types individual bytes memory termed byte types informally byte type byte holds start program type subtype thereof byte types byte part interior multi-byte starts earlier location notation establish concise notation types derived understand siff scenario array elements type written ptr pointer tuple form denotes struct denotes untagged union triple giving type starting offset field structure union structure fields ordered offset starting offset union fields unordered start offset subtyping relation reflexive closure precedesequal type notation addr place subtyping constraint addr precedesequal type mapping evident context discussion byte offsets memory block represented terms addition block start address block storage block denotes address ith byte block starting abbreviate address block simply block predicate validpointer addr asserts addr holds start valid non-null pointer byte type lattice analysis yield multiple distinct types memory location cases reveals conflict misused memory cases types fact compatible section explains construct lattice set program types model type compatibility analysis data types figure form running paper omit explicit struct keyword struct point double struct shape char file fptr struct part struct point center struct shape shape struct assembly owner struct partnode struct part part struct partnode struct assembly struct point center struct partnode nodes struct assembly owner figure data types assembly-building program referent interior pointer char double char part assemblypartpartnode point shape figure byte type lattice data types figure types remainder section defines predicate obs obs words true run observed equation increase run observed false reduce sampling rates false occurrences recorded runs equalities longer hold result increase nonzero positive predicate interesting higher sampling rates interesting lower sampling rates related work daikon detects invariants program observing multiple program runs invariants predicates generated operators sum max combine program variables collection array objects daikon intended bug isolation monitors larger set predicates cbi makes scalable complex predicate generation difficult dodoo successfully extended work generate implications simpler measured predicates dodoo alternate clustering invariant detection find invariant implications set program runs initial clustering performed k-means algorithm program runs represented normalized vectors 
scalar variable values cbi represents run information bit-vectors effort number interesting predicates print tokens print tokens replace schedule schedule tcas conjunctions effort number interesting predicates print tokens print tokens replace schedule schedule tcas disjunctions figure variation number interesting predicates effort sampling rate number predicates conjunctions simple disjunctions figure sampling rate number interesting predicates averaged variants print tokens siemens applications similar technique applied essentially unchanged daikon implication generation extends vocabulary invariants cbi focus detection bug predictors sparse sampling conditions rarely identified invariant additionally existence implication questionable project implication revealed section interesting potentially side-effect analysis involves identified bug predictors approach paper suited goals analysis techniques cbi attempts daikon sparse sampling conditions diduce detects invariant bits program values initial training phase checking phase diduce reports invariant violation occurs relaxes invariant accept unlike daikon cbi diduce tightly couples data collection evaluation coupling daikon offline style predicate generation readily combined diduce framework sober statistical debugging tool similar cbi cbi considers predicate observed true execution sober estimates likelihood true evaluation sober data probability vector subtyping representing relation estimated chance construct byte simple type predicate lattice shown true observed figure similarity clarity collected omit data means figure similar techniques subtyping complex definitions predicate generation assumed applicable meet three-valued logic lattice elements section replaced lower bound joint-probability defined generating denotes conjunctions morgan law types applied consistently generate stored disjunctions address usability treatment metrics function types resulting found data companion technical experiments report sober compound types sparse sampling structure conditions initial complex predicate offset field generation removes key physical advantage address sober distinct predicate types scores result directly array number element actual predicate evaluations supertype complex predicates structure generated type technique initial field evaluated supertype probability values array type type connection actual elements program execution affect special usefulness atomic unknown types jones harrold diamond-shaped discuss nodes fault top localization technique figure statement present coverage latticetop denotes predicates unconstrained weighted memory failure address rate hold scoring type metric referent ideas describes discussed types paper including referent pruning techniques pointer interior applied describes directly non-initial technique bytes jones multi-byte atomic values explore pointer visualization targets program-execution referent data subtypes failure data interior compound predicates relate behavior holds multiple eight-byte program double points byte type difficult double bytes visualize presenting compound predicates type interior programmers readily pointed understand directly remains bitfields open problem typed haran interior analyze data addresses deployed software pointer classify executions storage success location holds failure byte tree-based valid classifiers pointer association rules potentially model failure consistent signals tree-based pointer classifiers type pointers encode pointers conjunctions disjunctions association rules encode disjunctions limited constant size conclusions future work demonstrated compound boolean predicates predictors bugs experiments show qualitative quantitative evidence statistical debugging techniques effectively applied complex predicates resulting analysis improved results describe methods eliminating predicate combinations consideration making task computing complex predicates feasible employs three-valued logic estimate set sizes estimate upper bound score complex predicate distances program dependence graphs quantify programmer effort involved understanding complex predicates techniques statistical debugging analysis scale handle large number candidate predicates analysis results debugging require sifting large number predicates pass automated inspection shrinking list retaining predictors remains important open problem identified bug predictors redundantly describe small set program failures bi-clustering algorithm zheng promising designed handle multiple predictors bug automated analyses process predictor lists btrace benefit richer diagnostic language offered work presented acknowledgments anne mulhern insightful comments earlier draft paper cleve zeller locating program failures icse proceedings international conference software engineering pages dodoo donovan lin ernst selecting predicates implications program analysis march draft http pag csail mit mernst pubs invariants-implications ernst cockrell griswold notkin dynamically discovering program invariants support program evolution ieee transactions software allowed pointer engineering referent feb pointer previous version appeared void icse proceedings represents pointers international conference software specific engineering program type pages los oval nodes angeles usa lattice correspond actual types elbaum supporting program controlled notice experimentation primitive testing atomic techniques types infrastructure sibling potential subtypes impact referent empirical software stipulates engineering international journal atomic types hangal simultaneously lam stored tracking software address bugs special automatic case anomaly treat detection void icse proceedings zero-length type international identical conference referent software engineering byte 
typevoid final result convention transparent handling aliases void fully typed pointers pointers void refer address system void zero-length prefix referent subtype subtyping relation extended pointers precedesequal negationslash ptr precedesequal ptr standard restriction subtyping updatable program requires form subtyping describe heap necessarily casts measures violate type safety unions untagged unions require special treatment union fields consistent typing requires address assigned unique type untagged union type extend type grammar include tagged case unions tagged cases adhere subtyping relations referent relations forbid aliased pointers differently-typed union fields union single consistent manner point execution tagged union storing point target pointers untagged union pointers point double target pointer part fields union common supertype additional cases introduced represent subset tagged cases single case preserves uniqueness lattice meet operation note tagged unions multiple supertypes byte type lattice tree finite type space byte type lattice unbounded number types including arrays arbitrary length pointers arbitrarily deep nesting practice finite subset types meaningful program program-declared structures unions enumerations tagged variants unions types unions arrays program int field variable type pointers program int field variable type pointers types levels indirection number tagged variants union-containing types potentially exponential experience multi-union structures nested unions unusual number tagged variants typically linear void main carassm create assembly assembly create assembly assembly assm malloc sizeof assembly partnode node malloc sizeof partnode nodepart malloc sizeof part nodenext node assmnodes node build part shape set init part nodepart door assm return assm figure program builds simple assembly figure allocated blocks values init part call figure additional array types synthesized needed analysis satisfy size constraints section element types appearing original program block pages york usa acm press haran karr orso porter sanil fouch techniques classifying executions deployed software support software engineering tasks ieee transactions software engineering hutchins foster goradia ostrand experiments effectiveness dataflowand controlflow-based test adequacy criteria icse proceedings international conference software engineering pages los alamitos usa ieee computer society press jain murty flynn data clustering review acm computing surveys sept jones harrold empirical evaluation tarantula automatic fault-localization technique ase proceedings ieee acm international conference automated software engineering pages york usa acm press jones orso harrold gammatella visualizing program-execution data deployed software information visualization lal lim polishchuk liblit path optimization programs application debugging sestoft editor european symposium programming pages bytes vienna austria typed mar int springer int liblit -byte aiken type zheng int jordan bug isolation element remote type program int sampling appeared pldi original proceedings program acm consistency constraints sigplan conference section programming language design kinds constraints storage locations restrict types heap blocks show constraints combined derive consistent heap typing point program simplicity assume -bit architecture -byte pointers -bytedoubles ideas generalize -bit architectures program excerpt figure creates part simple assembly initializes shape owner assembly figure shows heap call init part line figure blocks labeled arbitrarily line number block allocation label valid pointer block valid pointers value-consistent types partnode shape part assembly part assembly partnode shape table valid pointer value-consistent types heap figure values shown c-style syntax rest memory assumed set returned malloc bracketed numbers byte ranges block constraints constraints arise concrete data values memory instant analysis applied reflect fact data types limited domains smaller set values fit allotted memory constraints divide categories wide variety programs mandatory constraints valid pointer require typed pointer section validpointer addr addr precedesequal pointer assumes non-pointer takes valid pointer chance strategy widely employed conservative garbage collectors table shows valid pointer constraints heap snapshot figure types physical layouts consistent constraint important detail locations holding unconstrained consistent pointer type primitive types partnode shape value-consistent block viewed null pointer filtering constraints values infer basic type information directly reject hypothesized type part domain type accept enum potential byte type starting byte equal defined constants enumerated type similarly function pointer type consistent word-aligned address executable code employ character constraint programs manipulate ascii text block unconstrained ascii character values stored offset block block typed char char consistent primitive primitive array type detailed discussion rationale filtering constraints found technical report programmers define additional constraints reflect application-specific types invariants heap typing algorithm accommodate arbitrary predicates approve reject type proposed location data structure consistency specifications demsky applied additional constraints selected types size constraints type block fill number bytes allocated block address block start allocated block block sizeof block sizeof dynamically allocated arrays tile multiple copies element type block holding dynamic array block size size-consistent types partnode shape char part assembly shape partnode float part assembly shape partnode float partnode shape int char table size constraints size-consistent types heap figure elements type satisfy sizeof block sizeof number array elements table shows size constraints illustrative sizecompatible types blocks heap snapshot type constraints type constraints relate multiple locations blocks pointers single block multi-byte structures addr precedesequal pointer addr allocated block past end addr referent addr precedesequal atomic type addr interior sizeof combined rule incompatibility interior referent forbids pointers interior atomic values iii allocated block starting block block referent similar rule rule affects leaked blocks points addr precedesequal ptr addr precedesequal pointers pointed-to types compatible modulo subtyping addr precedesequals addr structure fields compatible structure addr addr sizeof array elements compatible array implied constraints imply additional constraints consistent heap typing satisfy transitively implied type constraints untagged unions induce additional type constraints tagged union type subtype pick constraints rules debug constraints symbolic debug information in-scope variables function arguments information added type map obvious manner equality constraints integer variable type int int subtype main algorithm section require debug information find consistent typings takes debug constraints account present solution combine size type constraints informally derive consistent heap typing shown figure section presents systematic algorithm finding consistent typings automatically clarity user-defined types matches arrays primitives assume debug constraints unavailable implementation pages york usa acm press liblit naik zheng aiken jordan scalable statistical bug isolation pldi proceedings acm sigplan conference programming language design implementation pages york usa acm press liblit cooperative bug isolation phd thesis california berkeley dec litzkow livny mutka condor hunter idle workstations proceedings international conference distributed computing systems pages june liu yan fei han midkiff sober statistical model-based bug localization esec fseproceedings european software engineering conference held jointly acm sigsoft international symposium foundations software engineering pages york usa acm press rothermel elbaum kinneer software-artifact intrastructure repository http sir unl portal sept weisstein boolean function mathworld wolfram web resource dec http mathworld wolfram booleanfunction html zheng jordan liblit naik aiken statistical debugging simultaneous identification multiple bugs icml proceedings path optimization programs application debugging star akash lal junghee lim marina polishchuk ben liblit computer sciences department wisconsin-madison akash junghee mpoli liblit wisc abstract present solve path optimization problem programs set program nodes called critical nodes find shortest path program control flow graph touches maximum number nodes control flow graphs over-approximate real program behavior adding dataflow analysis control flow graph narrow program actual behavior discard paths deemed infeasible dataflow analysis derive efficient algorithm path optimization based weighted pushdown systems present application path optimization integrating cooperative bug isolation project cbi dynamic debugging system cbi mines instrumentation feedback data find suspect program behaviors called bug predictors strongly program failure instantiating critical nodes nodes bug predictors solve shortest program path touches predictors path programmer debug software present early experience hybrid static dynamic system debugging introduction static analysis programs variety purposes including compiler optimizations verification safety properties improving program understanding static analysis advantage executions program giving strong guarantees program behavior paper present static analysis technique finding program execution sequence optimal respect criteria set program locations call critical nodes find trace program execution traces touches maximum number critical nodes shortest length traces reachability programs undecidable general over-approximate set traces program paths control flow graph solve optimization problem collection paths closely approximate actual program behavior discarding paths control flow graph deemed infeasible dataflow analysis show powerful framework weighted pushdown systems represent solve variations path optimization problem star supported part onr contracts nsf grant ccrand gift microsoft research important find paths conint void main init process void clear int null void process int switch getchar case clear break case fig buggy program fragment sider program fragment shown figure suppose crashes input line debugging program find analysis statement null clear caused null-pointer deference crash site line isolation indication actual bug construct path program entry point main crash site visits suspect line clear path touches statements shown bold figure shows program call clear process continue execution crash site closer examination path suggest break statement clear return statement paths richer understanding program behavior examining isolated statements procedures implemented path optimization algorithm integrated cooperative bug isolation project cbi create btrace debugging support tool cbi adds lightweight dynamic instrumentation software gather information runtime behavior data identifies suspect program behaviors called bug predictors strongly program failure bug predictors expose circumstances failure successfully find previously unknown bugs cbi primarily dynamic system based mining feedback data observed runs work btrace represents major effort combine cbi dynamic approach static program analysis btrace enhances cbi output giving context interpreting bug predictors cbi bug predictors set critical nodes construct path entry point program failure site touches maximum number predictors cbi associates numerical score bug predictor higher scores denoting stronger association failure extend btrace find shortest path maximizes sum scores predictors touches btrace finds path sum predictor scores predictors path maximal shorter path score user restrict attention paths unfinished calls order stack trace left failed program impose constraints order predictors touched constraints enhance utility btrace debugging purposes producing path close actual failing execution program give user substantial insight root failure present experimental results section support claim extra constraints path optimization problem solved btrace stated btrace problem control flow graph program nodes edges single node representing crash site program set critical nodes representing bug predictors function representing predictor scores find path control flow graph maximizes set critical nodes path touches minimizes length restrict search optimal path paths satisfy constraints stack trace stack trace paths reach unfinished calls order stack trace ordering list node pairs paths touch node node dataflow dataflow analysis framework paths ruled infeasible dataflow analysis requirements dataflow analysis framework section finding feasible path program exists general undecidable powerful dataflow analysis btrace return path real execution program acceptable judge usefulness path helps programmer debug program feasibility key contributions paper present algorithm optimizes path selection program criteria weighted pushdown systems provide common setting mentioned optimization constraints satisfied describe hybrid static dynamic system combines optimal path selection cbi bug predictors support debugging remainder paper organized section presents formal theory representing paths program section derives algorithm finding optimal path section considers path optimization conjunction cbi debugging programs presents experimental results demonstrating approach feasible section discusses related work area section concludes final remarks describing paths program section introduces basic theory approach section formalize set paths program pushdown system section introduces weighted pushdown systems added ability associate path emain call ret exitmain exitp call ret emain arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft exitmain exitmain arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft exitp arrowhookleft exitp exitp arrowhookleft fig control flow graph exit nodes represent entry exit points procedures dashed edges represent interprocedural control flow pushdown system models control flow graph shown single state rule cfg edge rules correspond procedure calls save return site stack rules simply pop-off top stack reveal recent return site paths program control flow graph cfg program graph nodes program statements edges represent flow control statements figure shows cfg program procedures adopt convention procedure call program represented nodes source interprocedural call edge callee entry node target interprocedural return edge callee exit node back caller figure nodes represent call main nodes represent call paths sequences nodes connected edges cfg valid path emain exitp invalid call node return node node general valid paths cfg context-free language matching call return pairs call matching return edge exit node reason natural pushdown systems describe valid paths program definition pushdown system pds triple finite sets set states set stack symbols set pushdown rules rule written arrowhookleft pds finite automaton stack input interested transition system describes language generates definition configuration pushdown system pair rules pushdown system describe transition relation configurations arrowhookleft rule uprime uuprime uprime construction pds represent paths cfg fairly straightforward shown figure transition system constructed pds mimics control flow program sequence transitions transition system ending configuration stack trace describes path cfg unfinished calls return sites sense configuration stores abstract run-time stack program transition system describes valid program make weighted pushdown systems weighted pushdown system wpds obtained associating weight pushdown rule weights set satisfies bounded idempotent semiring properties definition bounded idempotent semiring quintuple set elements called weights elements combine 
operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule operation compute weight concatenating paths operation compute weight merging parallel paths sequence rules define val definition item required wpdss efficiently explore paths item required termination figure fully constrained heap derived typing heap figure valid pointer size constraints block type shape partnode shape considered propagate char constraint block rule size constraints require block type char char precedesequal char block type char consistent char pointer block partnode conflict arisen discuss conflicts detail section size constraints block type part assembly assembly partnode rule partnode rule conflicts shape established earlier choosing part consistent shape requires assembly consistent size constraints block lastly block type partnode due pointer field heap typing algorithm section present algorithm assigning types storage locations consistent typing inputs algorithm consist snapshot values program memory start addresses sizes allocated heap blocks list defined program types optional symbolic debug information giving locations sizes types in-scope variables output typing giving consistent byte types allocated bytes byte type byte allocated block type block cases globally consistent typing exists algorithm identify describe eliminate untypable blocks producing partial typing remaining blocks algorithm begins assigning types individual bytes storage values arise program valid pointers pointed-to locations foremost source byte type constraints section transitively propagate byte types variables declared program exact types reporting type constraint violations user section finally systematically types memory block typing map fully defined typing alternatives blocks exhausted section pointer constraint gathering establish 
valid pointer constraints individual bytes section type constraint rules iii induce additional constraints conflicts referent interior arise stage blocks hold valid pointers points byte simultaneously referent pointer interior pointer situation difficult block erroneous describe conflict user mark blocks untypable disregard remainder algorithm phase typing constrains bytes subtypes pointer interior referent bytes remain unconstrained latticetop program types debug constraint gathering symbolic debug information debug constraints applied propagated transitively pointers compound types type constraint rules size constraints checked note size constraints partially enforced block large expected type larger target adouble bytes long longer part larger structure union array stage conflicts arise debug constraints int float location debug size constraints int two-byte block debug constraints debug pointer referent interior constraints derived previous stage conflict occurs assume execution deviated type safety static type system trusted predict run-time types report problem user back debug constraints remainder algorithm operate observed memory values declared variable types selective approach leave future work discard minimal subset problematic debug constraints keeping remainder barring conflicts conclusion phase global typing includes program types memory addresses transitively reached pointers program variables types lattice upper bounds pointer char point array characters structure initialcharfield bytes reachable blocks bytes unreachable blocks carry pointer referent interior constraints added previously completing heap typing initial byte type constraints assign type heap block fully enforced size constraints ensure size block type equal block size allocated bytes constrained typing completed byte block determines block type typing feasibility check verify heap block assigned program type initial constraints block assigned type corrupt allocated library internal types unavailable describe problematic block user mark untypable disregard type search phase search algorithm main search phase considers types block backtracking event conflicts type verified consistent current constraints block update byte types bytes block reflect type propagate constraints level forward pointers block proceed block consistent type found block backtrack block remaining type alternatives resume search point algorithm terminates considered block assigned consistent type types blocks failed case consistent typing exists block type considered outcome induced constraints blocks file size conflict sizeof sizeof file part shape shape type conflict meet shape file assembly partnode partnode part partnode size conflict sizeof sizeof partnode shape char char table heap typing algorithm international conference machine learning pages york usa acm press 
execution trace vely implemented search geometric number blocks exponential number types entire block type subtype byte type search restricted sublattice bound optimization effective debug constraints enabled pointers refer initial byte allocated block heap consistent typings prefer typing informative user larger types program-defined types primitives singletons arrays fewer levels pointer indirection order designed heuristically direct solution typings guarantee final heap typing globally minimal optimal respect order find yields good results practice computing solution illustrate algorithm applied running heap snapshot init part call line figure illustrate conflict handling modify values shown figure assume bytes corrupted longer hold valid pointer constraints remain shown table debug constraint collection inconsistency arises part constraint propagated variable node part requires valid pointer null bytes conflict found debug constraints discarded search continues constraints block pass typing feasibility check omitted search table summarizes steps backtracking search complete types remaining blocks considered allocation order types ordered sorting heuristic algorithm recover types remaining blocks size constraints backtracking times search final heap typing remaining blocks shown figure propagation correctness assigning type block update constraints block propagate pointer constraints forward dereference claim sufficient ensure inconsistency typed blocks overlooked blocks transitively reachable assigned consistent types order considered full proof claim contained technical report evaluation implemented algorithm gnu debugger gdb popular symbolic debugger program stopped breakpoint user type whatsat expr perform heap type inference display typeannotated memory beginning address computed expr implementing validpointer predicate requires debugger probe debuggee current heap allocation state modify debuggee memory management routines maintain list allocated blocks reserved global location debugger debugger reads list directly debuggee address space needed record start address size block code address block allocation call originated whatsat diagnostic messages report source file line number function untypable block allocated extra allocation tracking standard hooks exposed gnu libc implementation contained shared library preloaded program wishes debug recompilation relinking allocation hooks zero-initialize newly allocated blocks avoid spurious typing errors due random data values uninitialized heap memory disable feature order verify program study fully initializes heap storage normal running conditions section visualization typed memory heap type inference whatsat displays memory contents augmented type information visualization begins address user choosing whatsat whatsat foo continues forward raw memory user control figure shows part type-annotated memory visualization program experiments section line shows capitalized hexadecimal memory address abc word raw memory content address interpretation memory typed algorithm length int indentation field labels length reflect nesting compound types figure shows distinct proximate memory blocks array structures function pointers labels left address mark locations part static data section allocated labels mark stack typed heap locations freed heap locations categories memory schedule schedule small application siemens buggy program suite list jobs priorities input application computes prints schedule running jobs version schedule bug program crash inside malloc stack trace reveals crash due bad pointer dereference function pointer malloc hook point function whatsat confirms abb abbc queue queue abc length int abc head process queue abc length int abcc head process queue abd length int abd head process queue abd length int abdc head process abe abe void abe void abec void realloc hook ini abf void memalign hook ini abf abf figure schedule global variables visualization types function pointer arguments omitted brevity claimed type malloc hook inconsistent debug constraints satisfiable debug constraints discarded whatsat infers block process structure malloc hook assigned malloc hook holds bad process pointer function pointer whatsat explore physical memory neighborhood malloc hook reveals four-element structure array precedes malloc hook figure shows whatsat visualization area malloc hook appears address abe preceding array visible starting address abc observe malloc hook perfectly positioned receive errant process pointer neighboring array overrun bounds informed identify array code writes missing bounds check constitutes true bug whatsat queries case study completed seconds hardware watchpoint trap bad write malloc hook require rerunning program reproducing bug memory corruption bugs difficult reproduce demand whatsat provide postmortem information instance bug exif exif open source utility manipulating 
jpeg image metadata consists lines code split shared library main driver program ran exif breakpoint set exif loader data builds in-memory representation jpeg input file disabled zero-initialization heap blocks test exif performs initializations properly whatsat identifies untypable blocks allocated exif content add entry exif-content code question performs reallocation grow array pointers entry blocks entries realloc entries sizeof exifentry count size calculation incorrect reserves space array count exifentry structures entries array pointers exifentry structures exifentry larger pointer program overrun buffer extra space end array wasted uninitialized random data valid pointers whatsat determines arrays allocated untypable initially identified previously unreported bug release exif driver library confirmed persists latest development snapshot april lines code exif developers confirmed bug applied suggested fix whatsat identifies untypable blocks ignores remainder analysis analysis find valid heap typing exif timely manner valid typing exists individual blocks match type valid typing exists pathologically mismatched heuristic search order improving diagnostic capabilities analysis unresolvable conflicts arise late search important area future study related work chandra reps siff introduce alternate type system subtyping based physical layouts data structures describe static type checking inference rules test program conformance alternate type system contrast approach dynamic examine frozen snapshot running program heap space program heaps concrete memory values allocated block sizes refine analysis typical dynamic analyses focus specific bugs triggered run guaranteeing bugs detected subtyping relation induced byte type lattice restrictive chandra siff physical subtyping relation subtyping structure field disallow general structure prefixing char arrays storage placeholders policy choices approach permissive chandra siff subtyping variety relations constraint collection core heap typing algorithm subtyping relations context cardelli structural record subtyping relation disregards field order needlessly permissive scenario field orders fixed dynamic heap-walking tool system shares qualities garbage collector leak detector list unreachable leaked memory blocks easily extracted analysis traditional garbage collectors require data structure layout information root set possibly allocated blocks conservative garbage collectors relax requirement assuming location holding valid pointer pointer approach moves flexibly extremes ultimately information recover richer produced garbage collectors find size embedded pointers allocated block complete program types globally consistent blocks zimmermann zeller present strategies extracting heaps displaying highlight key relationships system depends debugger-provided type information augmented c-specific heuristics whatsat pointer validity testing dynamic array size computation wpds algorithms sets pushdown configurations sprime path sprime set rule heuristics isolated blocks notion global consistency zimmermann zeller acknowledge heuristics make good guesses safer provide explicit disambiguation rules hand-crafted inferred program dynamic heap type inference generalizes improves heuristics defining notion global heap typing considers local values isolated blocks relationships interlinked blocks lets whatsat find globally consistent heap typings reduces eliminates hand-crafted disambiguation rules problem heap corruption due pointer cast abuse longstanding inspired solutions ranging static analysis run-time instrumentation design safer language dialects approach performs programmer-directed heap validity checks interactive debugging context attempt prevent trap errors occur significantly invasive require language recompilation source annotation compiler-provided list program types run-time instrumentation list allocated blocks dynamic type tagging data structure layouts additionally analysis depends instantaneous state program heap moment time maintaining list allocated blocks record trace information program runs sense whatsat experiment minimalism monitor potentially interesting action information recovered bare minimum imposition run-time highly invasive minimally invasive approaches benefits exploring extremes helps illuminate potential strategies improve debugging tools instrumentation analysis spectrum conclusion low-level programming languages require low-level debugging completely abandon type system working non-type-safe languages lowlevel type-annotated view heap debugging general program understanding tasks presented algorithm infers program-defined types memory locations solution consistency defined terms constraints blend ideas physical subtyping conservative garbage collection consistent typing exists due heap corruption pointer abuse offer focused diagnostic information identify implementation works general programs requires source annotation recompilation run-time instrumentation heap allocation tracking physical data structure layouts experiences tool limited scope suggest dynamic heap type inference addition programmer toolkit andersen program analysis specialization programming language phd thesis diku copenhagen austin breach sohi efficient detection pointer array access errors pldi proceedings acm sigplan conference programming language design implementation pages york usa acm press boehm weiser garbage collection uncooperative environment software practice experience cardelli structural subtyping notion power type popl proceedings acm sigplan-sigact symposium principles programming languages pages york usa acm press chandra reps physical type checking workshop program analysis software tools engineering pages demsky ernst guo mccamant perkins rinard inference enforcement data structure consistency specifications issta proceedings international symposium software testing analysis portland usa july evans static detection dynamic memory errors pldi proceedings acm sigplan conference programming language design implementation pages york usa acm press exif tag parsing library http libexif net free software foundation boston usa gnu library edition july gilmore shebs gdb internals feb hastings joyce purify fast detection memory leaks access errors proceedings usenix winter conference pages san francisco usa usenix association hutchins foster goradia ostrand experiments effectiveness dataflowand control-flow-based test adequacy criteria proceedings international conference software engineering pages ieee computer society press international organization standardization iso iec programming languages international organization standardization geneva switzerland dec jim morrisett grossman hicks cheney wang cyclone safe dialect proceedings general track usenix annual technical conference pages berkeley usa usenix association jones kelly backwards-compatible bounds checking arrays pointers programs aadebug pages kaufer lopez pratap saber-c interpreter-based programming environment language proceedings usenix summer conference pages san francisco usa june usenix association loginov yong horwitz reps debugging run-time type checking fase proceedings international conference fundamental approaches software engineering pages london springer-verlag necula condit harren mcpeak weimer ccured type-safe retrofitting legacy software acm transactions programming languages systems nethercote seward valgrind program supervision framework electronic notes theoretical computer science polishchuk liblit schulze whatsat dynamic heap type inference program understanding debugging technical report wisconsin madison oct siff chandra ball kunchithapadam reps coping type casts nierstrasz lemoine editors esec sigsoft fse volume lecture notes computer science pages springer smith volpano sound polymorphic type system dialect science computer programming steensgaard points-to analysis linear time symposium principles programming languages pages steffen adding run-time checking portable compiler software practice experience zimmermann zeller visualizing memory graphs software visualization international seminar dagstuhl castle germany revised lectures volume lecture notes computer science pages springer 
sequences transform configuration configuration sprime denote set stacks start existing work wpdss solve problems definition letw weighted pushdown system withp configuration generalized pushdown predecessor gppc problem find regular set configurations circleplustext val path witness set paths path circleplustext val generalized pushdown successor gpsc problem find regular set configurations circleplustext val path witness set paths path circleplustext val definition avoid defining regular set configurations restricting single configuration cprime problems considered backward forward reachability problems aims find combine values paths pairs configurations find witness set paths justify reported set paths finite item definition note reachability problems require finding smallest witness set wpds algorithms find finite set finding optimal path section solve specific btrace problem defined section begin developing solution basic path optimization problem dataflow ordering constraints add back creating wpds cfg pushdown system representing paths constructed section set critical nodes notation section construct wpds solved find path path track length set critical nodes touches set elements consist subset critical nodes touched natural number length path associate path element accomplished defining weight summarize set paths set elements combine operation simply takes union weights eliminates element elements shorter path length chosen drives wpds paths shortest length extend operation takes union critical nodes sums path lengths pair elements weights reflects fact path length touches critical nodes extended path length touches critical nodes path length touches critical nodes semiring constant denotes infeasible path constant denotes empty path touches critical nodes crosses graph edges formalized definition definition bounded idempotent semiring component defined set weights power set define reduce reduce notexistential vprime vprime define reduce semiring constants complete description wpds associate pushdown rule weight arrowhookleft associate weight rule length path increased set critical nodes grows include critical node easy sequence rules describes path cfg val set critical nodes touched path length solving wpds optimal path found solving generalized pushdown reachability problems wpds scenarios crash site stack trace crash crash site stack trace start crash site entry point program crash site theorem solving gps path touches critical nodes shortest path length set paths path touches critical nodes length theorem holds paths set paths unfinished calls taking combine values paths selects subsets shortest path touches critical nodes discards longer witness set record paths justify reported path singleton-set weight path member stack trace topmost element gps gpp theorem inw solving gps gpp values valid path stack trace touches critical nodes shortest path length set paths stack trace path touches critical nodes length theorem find required values gps gpp forward reachability starting forward program backward reachability starting stack trace backwards appendix presents detailed discussion complexity solving problems wpds worst-case complexity exponential number critical nodes practically linear size program exponential complexity critical nodes unavoidable reason path optimization problem solve strict generalization traveling salesman problem objective find shortest path points touches set nodes find complexity limitation experiments obtained values find optimal path easily user-defined measure associates score critical node compute score summing scores critical nodes choose pair highest score extracting path pair optimal path advantages userdefined measure user bug predictor scores cbi make scores user give negative score critical nodes avoided path critical nodes score added ordering constraints section lets tool work interactively user find suitable path generally user give measure directly associates score path measure user decide choose shorter paths paths touch critical nodes adding ordering constraints add ordering constraints path optimization problem suppose constraint node visited node paths visit visiting easy add constraints wpds extend operation compute path simply change yield paths satisfy ordering constraint redefine reduce ordering constraint simply add clauses constraint definition extend constraints change worst case asymptotic complexity solving reachability problems wpds prune paths explored constraint cuts size weights produced extend operation adding dataflow analysis considered interpreting semantics program control flow implies wpds find infeasible paths occur execution program path assigns true branch conditional general undecidable restrict attention paths occur program execution rule infeasible paths increase chances presenting feasible near-feasible path user dataflow analysis dataflow analysis carried approximate program variable set values variable point program dataflow analysis satisfies conditions integrated wpds designing weight domain examples dataflow analyses include linear constant propagation affine relation analysis bounded idempotent semiring weight domain provided function associates pds rule cfg edge weight satisfies property possibly infinite set paths pair program nodes circleplustext vald paths infeasible vald means vald infeasible path imposes soundness guarantee dataflow analysis rule infeasible paths details classical dataflow analysis frameworks encoded weight domains found reps basic idea encode dataflow transformers capture effect executing program statement sequence statements weights extend operation composes transformers combine operation takes meet dataflow lattice translation dataflow transformers weight domain talk meet-over-all-paths configurations pushdown system solving gps weight domain combine meet values paths stack trace unique advantage gain conventional dataflow analysis wpdss change weight domain wpds definition bounded idempotent semiring component defined set weights power set set define reduced reduced defined min define reduced setbraceleftbigg vextendsingle negationslash satisfy ordering constraints bracerightbigg semiring constants satisfy ordering constraints iff constraint visit case weight rule arrowhookleft path set predictors touches length dataflow infeasible paths removed extend operation weights dataflow discarded formally path cfg val vald negationslash dataflow path length path set critical nodes touched path path satisfies ordering constraints satisfy ordering constraint vald val analysis weight domain similar property simulation esp distinct dataflow maintained property-state maintain distinct dataflow weight subset critical nodes repeating theorems present case gps stack trace results cases obtained similarly theorem wpds obtained weight domain defined definition solving gps values path stack trace visits critical nodes satisfies ordering constraints infeasible weight domain shortest path length path stack trace visits predictors satisfies ordering constraints length generally paths constant val min worst case time complexity 
presence dataflow analysis increases factor height time required applying time required applying theorem completely solves btrace problem mentioned section section presents dataflow weight domain experiments extensions dataflow analysis copy constant propagation give weight domain dataflow analysis encode copy-constant propagation weight domain similar encoding sagiv reps horwitz copy-constant propagation aims determine variable fixed constant point program interprets constant-to-variable assignments variable-tovariable assignments abstracts assignments constant ignore conditions branches var set global integer variables program zlatticetop latticetop zlatticetop intersectionsq standard constant propagation meet semilattice obtained partial order subsetsqequalcp csubsetsqequalcp latticetop set weights weight domain var var zlatticetop represents dataflow transformer summarizes effect executing sequence program statements env var state program statements executed zlatticetop variable statements executed env intersectionsqenv intersectionsqenv intersectionsqc component component define semiring operations combine operation concatenation expressions extend operation substitution formally intersectionsq uniondisplay intersectionsq semiring constants latticetop latticetop handling conditionals handling branch conditions problematic dataflow analysis presence conditions hard finding branch condition evaluate true copy-constant propagation pspace-complete resort approximate dataflow analysis give computing meet-over-all-paths translates relaxing distributivity requirement weight domain fortunately wpdss handle non-distributive weight domains relaxing definition item set weights subsetsqequal subsetsqequal subsetsqequal partial order defined subsetsqequal iff weaker property generalized reachability problems solved approximately obtaining configuration obtain weight subsetsqequal path optimization problem inaccuracy limited dataflow analysis eliminate paths dataflow analysis find infeasible find path vald acceptable rule infeasible paths flexibility putting simple treatment conditions dataflow analyses disadvantage lose strong characterization type paths eliminated copy-constant propagation extend set weights arithmetic condition associate weight rule arrowhookleft cfg edge evaluates true program state associate weight true branch conditional weight xnegationslash false branch extend operation modified evaluates condition information provided results evaluates false extend simply details found companion technical report handling local variables recent extension wpdss shows local variables handled merge functions local variables saved call merged information returned callee compute effect call treatment local variables restrict weight manage local variables procedure details construction merge functions companion technical report integrating btrace cbi formalisms section solving variety optimization problems concerned touching key program points path btrace represents application ideas enhancement statistical debugging analysis performed cooperative bug isolation project cbi failure paths cbi runtime instrumentation statistical modeling techniques diagnose bugs widely deployed software cbi identifies suspect program behaviors called bug predictors strongly program failure candidate behaviors include branch directions function call results values variables dynamic properties bug predictor assigned numerical score balances key factors predictor increases probability failure failed runs predictor accounts high-value predictors warrant close examination highly correlated failure account large portion failure rate end users key strength cbi samples behavior entire dynamic lifetime run interpreting resulting predictors located program prior failure point challenging work isolated bug predictors programmer navigate forward backward path led failure btrace constructs path hits high-ranked predictors programmer draw connections sections code seemingly unrelated act concert bring program btrace implementation implemented btrace wpds library manage exponential complexity number bug predictors efficiently encode weights abstract decision diagrams adds provided cudd library additional details semiring operations implemented adds found companion technical report btrace debugging session starts list related bug predictors believed cbi represent single bug designate list high-ranked prefix thereof critical nodes insert locations cfg branch predictors treated special case predictors associate direction conditional failure repositioned branch exploiting location semantic meaning bug predictor branch predicates make easy semantic meaning directly corresponds control flow dataflow analysis track integerand pointer-valued variables structure fields track contents memory write memory pointer replaced assignments variables address direct structure assignments expanded component-wise assignments fields structure case studies siemens suite applied btrace buggy programs siemens test suite tcas replace print tokens programs crash produce incorrect output analysis performed stack trace treating exit main failure point find btrace non-fatal bugs tcas array index error one-line function cbi instrumentation easily overlooked bug predictors btrace produces shortest path exits main revealing bug adding top-ranked predictor btrace isolates lines calls buggy function replace incorrect function return btrace top predictors yields path faulty statement predictor located disjoint chains function calls invoked main falls function bug isolated predictors directly reveal bug btrace failure path predictors print tokens off-by-one error predictors suffice steer btrace faulty line repositioning branch predictors critical nineteen cbi-suggested predictors dataflow analysis enabled correct failure path results branch predictors repositioned steer path proper direction case studies ccrypt run btrace small open source utilities ccrypt ccrypt encryption decryption tool arbitrary precision calculator written fatal bugs characterized prior work liblit detailed discussion experimental results found companion technical report ccrypt input validation bug reading end-of-file yields null string char subsequently dereferenced checked stack trace btrace builds infeasible path takes impossible shortcuts initialization code shortcuts yield null values places properly checked real bug path remains add dataflow analysis bug predictors add fourteen bug predictors dataflow analysis btrace dataflow analysis eleven bug predictors failure path feasible path correctly describes bug non-null values well-checked initialization code fatal unchecked null feasible path arises stack trace manually inserts ordering constraints require bug predictors initialization code initialization code assumed bug-free combination dataflow analysis bug predictors make manual priori assumptions unnecessary buffer overrun bad loop index arrays silently trashes memory program running eventually crash subsequent call malloc stack trace point failure suggests heap corruption real clues corruption occurred piece code cbi-identified bug predictors scattered files relationship clear examination bug predictor btrace builds path calls arrays early execution path feasible misleading arrays called early execution subsequent call arrays failure bug predictors forces path include fatal call arrays correctly reflecting true bug reading in-progress calls failure trace easily reconstruct entire stack call arrays point interest give deeper context frontier bad code cbi produces ranked lists related bug predictors suggesting distinct bugs btrace produces path list suggesting correspond single bug btrace correct lists correspond single bug cbi confused sampling noise statistical approximation incompleteness dynamic data factors btrace check letting unify equivalent bug lists cbi incorrectly held section mentioned solving wpds require time exponential number bug predictors find actual slowdown gradual absolute performance btrace good expected gps phase dominates creating initial wpds extracting witness path solved system negligible time small ccrypt application cfg nodes typical failure path btrace requires seconds find path ccrypt predictors increasing gradually seconds 
fifteen predictors adding predictors slows analysis gradually amplified adding predictor forces btrace build longer failure path larger cfg nodes typical failure path produced btrace nodes long complete analysis takes seconds predictors adding dataflow analysis slows analysis factor twelve depending configuration details analysis dataflow realistic numbers bug predictors takes thirteen seconds seconds ccrypt related work codesurfer path inspector tool weighted pushdown systems verification program drive automaton summarizing program property bad state witnesses produce faulty program path dataflow analyses encoding weights rule infeasible paths wpdss optimizing property verifying previously explored liblit aiken directly problem finding failure paths program present family analysis techniques exploit dynamic information failure sites stack traces event logs construct set paths program optimize path length number events touched unreachable single path approach general btrace incorporates techniques dataflow analysis unifying framework weighted pushdown systems difference event logs output cbi guide path-finding analysis theory presented section extended incorporate event logs adding ordering constraints appropriately restrict order events visited path pse tool finding failing paths requires user-provided description error occurred pointer assigned null dereferenced description form finite state automaton problem finding failing run reduced finding backward path drives automaton error state initial state pse solves presence pointer-based data structures aliasing work require user description bug caused crash handle pointer-based structures pse pointer analysis preprocessing step produce accurate dataflow weights definitions define semirings power set values associate path approach presented general setting lengauer theune power set operation add distributivity semiring reduction function reduce ensures form sets elements lists bug predictors derived iterative ranking elimination algorithm liblit statistical debugging algorithms cbistyle data proposed including based regularized curve fitting sparse disjunction learning probability density function estimation support vector machines random forests btrace path reconstruction predictors arising techniques require list predictors numerical scores reflecting importance study reveal statistical debugging algorithms yield btrace paths conclusions presented static analysis technique build btrace tool find optimal path program constraints imposed user bug predictors produced cbi btrace perform postmortem analysis program reconstruct program path reveals circumstances failure paths produced btrace feasible intend programmers understand bug predictors produced cbi locate bugs quickly btrace user options supply additional constraints form stack traces ordering constraints user guide tool interactively locating bug case studies show btrace path isolate chain events leading failure predictors ability lead programmer directly faulty code experiments required prove utility btrace debugging larger software systems initial results promising acknowledgments susan horwitz insightful comments earlier draft paper aho sethi ullman compilers principles techniques tools addison-wesley reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog volume liblit cooperative bug isolation phd thesis california berkeley liblit naik zheng aiken jordan scalable statistical bug isolation sigplan conf prog lang design impl lal reps balakrishnan extended weighted pushdown systems computer aided verification bouajjani esparza touili generic approach static analysis concurrent programs procedures symp princ prog lang sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci ller-olm seidl precise interprocedural analysis linear algebra symp princ prog lang ller-olm seidl analysis modular arithmetic european symp programming das lerner seigle esp path-sensitive program verification polynomial time sigplan conf prog lang design impl wegman zadeck constant propagation conditional branches symp princ prog lang ller-olm thing complexity constant propagation european symp programming lal lim polishchuk liblit btrace path optimization debugging technical report wisconsin-madison liblit aiken zheng jordan bug isolation remote program sampling sigplan conf prog lang design impl kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds somenzi colorado decision diagram package technical report colorado boulder hutchins foster goradia ostrand experiments effectiveness dataflowand control-flow-based test adequacy criteria proc int conf softw eng ieee computer society press grammatech codesurfer path inspector http grammatech products codesurfer overview html balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds computer aided verfication liblit aiken building backtrace techniques postmortem program analysis technical report csd- california berkeley manevich sridharan adams das yang pse explaining program failures postmortem static analysis found softw eng lengauer theune unstructured path problems making semirings preliminary version wads volume lecture notes computer science springer zheng jordan liblit aiken statistical debugging sampled programs thrun saul sch lkopf eds advances neural information processing systems mit press cambridge zheng statistical software debugging phd thesis univ california berkeley liu yan fei han midkiff sober statistical mmodel-based bug localization found softw eng york usa acm press jiang automatic isolation cause-effect chains machine learning technical report cse- california davis complexity solving wpds section discuss worst-case running time complexity solving wpds constructed weight domain defined definition methods outlined theorems require solving gps gpp reading configuration time required reading witness factored steps number pushdown rules size cfg proc number procedures program entry point program number critical nodes length shortest path distant cfg node height length longest descending chain semiring time required perform semiring operation avoid requiring wpds terminology specialize complexity results solving reachability problems wpds gps solved proc time gpp requires time reading constant time requires time put results stack trace option theorem obtaining optimal path case requires time proc stack trace theorem options suppose stack traces multiple failures caused bug option solve gps stack trace worst-case time complexity proc average length stack traces option requires stack trace solves gpp asks worst-case time complexity evident complexities option faster complexity grows faster increase note worst-case complexities comparisons based hold average case fact wpds wpds implementation solving gps faster solving gpp present intuition comn fig simple control flow graph plexity results stated cfg shown figure node critical node path takes left branch length path takes branch length touches critical nodes path path discarded remember path branching program increases total number paths program increases complexity linearly node critical node remember paths touches critical nodes shorter length path touched shorter branch general remember path subset set critical nodes reflected design weight domain contributes exponential complexity respect number critical nodes implementation advantage fact pds obtained cfg backward reachability easier cfgs predecessor return-site node 
scalable statistical bug isolation ben liblit computer sciences department wisconsin-madison liblit wisc mayur naik computer science department stanford mhn stanford alice zheng department electrical engineering computer science california berkeley alicez berkeley alex aiken computer science department stanford aiken stanford michael jordan department electrical engineering computer science department statistics california berkeley jordan berkeley abstract present statistical debugging algorithm isolates bugs programs multiple undiagnosed bugs earlier statistical algorithms focus solely identifying predictors correlate program failure perform poorly multiple bugs technique separates effects bugs identifies predictors individual bugs predictors reveal circumstances bugs occur frequencies failure modes making easier prioritize debugging efforts algorithm validated case studies including examples algorithm identified previously unknown significant crashing bugs widely systems categories subject descriptors software engineering software program verification statistical methods software engineering testing debugging debugging aids distributed debugging monitors tracing pattern recognition design methodology feature evaluation selection general terms experimentation reliability keywords bug isolation random sampling invariants feature selection statistical debugging research supported part nasa grant nag nsf grant nos eiaccr- aciand engdoe prime contract -engthrough memorandum agreement llnl darpa aro-muri acclimate daad- grant microsoft research information presented necessarily reflect position policy government official endorsement inferred permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee pldi june chicago illinois usa copyright acm introduction paper statistical debugging dynamic analysis identifying software failures bugs instrumented programs monitor behavior produce feedback reports instrumentation examines program behavior execution sampling complete information single run monitoring lightweight practical deploy production testing environment large user communities making gather information runs collected data analyzed interesting trends monitored executions approach instrumentation consists predicates tested program points defer discussing predicates chosen instrumentation section program point predicates sampled independently program execution program point reached predicate program point tested time program point reached feedback report consists bit indicating run program succeeded failed bit vector bit predicate observed true run denote bug incorrect behavior program denote bug profile set failing runs feedback reports share failure union bug profiles set failing runs note negationslash general bug occur runs predicate bug predictor simply predictor bug statistically section statistical debugging selects small subset set instrumented predicates predictors bugs rank predictors important sets metrics section engineers finding fixing bugs previous work focused techniques lightweight instrumentation sampling program executions studied preliminary algorithms statistical debugging presented experimental results medium-size applications single bug general technique studied regularized logistic regression standard statistical procedure select set predicates predict outcome run worked apply methods larger programs realistic conditions discovered number scalability problems large applications set numbers hundreds thousands predicates logically redundant experience redundancy regularized logistic regression choose highly redundant lists predictors redundancy evident prior work problem larger programs separate difficulty prevalence predicates predicting multiple bugs unix programs bug encountered command line flags options non-default settings unusual code paths exercised predicates implying long command line rank top predicates useless isolating individual bugs finally bugs occur rates differ orders magnitude reality failure caused bug forced lump bugs learn binary classifier predictors common bugs influence global optimum tend ranked low included problems regularized logistic regression persist variations investigated analysis body experimental work yielded key technical insights addition bug predictors find instrumented predicates kinds predicates predicates predictive non-predictors identified discarded quickly remaining predicates predict failure bug predictors super-bug predictors predicates predict failures due variety bugs sub-bug predictors predicates characterize subset instances specific bug special cases general problems give concepts superand sub-bug predictors precise technical treatment section difficulty identifying bug predictors lies misled subor super-bug predictors overwhelmed sheer number predicates sift paper makes number contributions problems present algorithm isolating multiple bugs complex applications section offers significant improvements previous work scales gracefully dimensions discussed selected predicate naturally yields information shows important number explained program failures accurate predictor validate algorithm variety experiments show improved results previously reported experiments controlled experiment show algorithm find number bugs complex application lastly algorithm discover previously unknown crashing bugs large widely open source applications show runs sufficient isolate bugs paper demonstrating approach feasible in-house automatic testing deployment end users section report effectiveness current industry practice collecting stack traces failing runs find experiments half cases stack isolating bug half stack essentially information bug finally show principle approach isolate kind failure program crashes required label run successful unsuccessful respect point greatest strength system ability automatically identify kinds bugs including classes bugs anticipate building tool relying distinction good bad executions analysis require specification program properties analyzed statistical debugging complementary approach static analyses generally require specification properties check statistical debugging identify bugs reach current static analysis techniques classes bugs amenable static analysis thought check bugs found rhythmbox open source music player good illustration potential positive interaction static analysis strong predictor failure detected algorithm revealed previously unrecognized unsafe usage pattern library api simple syntactic static analysis subsequently showed hundred instances unsafe pattern rhythmbox rest paper organized providing background section discuss algorithm section experimental results presented section including advantages previous approach based regularized logistic regression section considers variations extensions basic statistical debugging algorithm discuss related work section offer conclusions section background section describes ideas terminology needed present algorithm ideal program monitoring system gather complete execution traces provide engineer tool mine bugs complete tracing program behavior simply impractical end user tester accept required performance overhead network bandwidth combination sparse random sampling controls performance overhead client-side summarization data limits storage transmission costs briefly discuss aspects random sampling added program source-to-source transformation sampling transformation general collection statements added program designated instrumentation site sampled run unconditionally time instrumentation code reached coin flip decides instrumentation executed coin flipping simulated statistically fair manner equivalent bernoulli process potential sample skipped randomly independently program runs found sampling rate applications performance overhead instrumentation low unmeasurable compute-bound kernels exception resort simply excluding performance critical code instrumentation orthogonal sampling transformation decision instrumentation introduce concisely summarize resulting data instrumentation captures behaviors interest hunting bugs present system offers instrumentation schemes programs branches conditional track predicates indicating true false branches applies statements implicit conditionals loop tests short-circuiting logical operators returns sign function return signal success failure 
scalar-returning function call site track predicates returned negationslash scalar-pairs bugs concern boundary issues relationship variable variable constant scalar assignment identify same-typed in-scope variable constant expression track relationships negationslash pair treated distinct instrumentation site general single assignment statement multiple distinct instrumentation sites predicates instrumentation site sampled jointly precise observation single dynamic check predicates single instrumentation site write observed site sampled true false write observed true site sampled found true sampling single negative return means returns predicates negationslash observed negationslash observed true natural properties check provide good coverage program scalar values control flow set means complete predicates heap structures section isolation algorithm section presents algorithm automatically isolating multiple bugs discussed section input set feedback reports individual program runs predicate observed true execution idea algorithm simulate iterative manner human programmers typically find fix bugs identify important bug fix repeat purposes identifying bug means selecting predicate closely correlated bug profileb difficulty set runs succeed fail set failing runs corresponds bugs words sizes membership set bug profiles step infer predicates correspond individual bugs rank predicates importance step literally fix bug chosen predictor simulate bug occur discard run recursively apply entire algorithm remaining runs reality count number times observed true analysis feedback reports observed true discarding runs reduces importance predictors allowing predicates predict bugs sets failing runs rise top subsequent iterations increase scores discuss step find important bug break step sub-steps eliminate predicates predictive power typically reduces number predicates orders magnitude hundreds thousands thousands rank surviving predicates importance section code fragment null predicate null line captured branches instrumentation predicate highly correlated failure fact true program inevitably crashes important observation perfect predictor failure program multiple bugs smoking gun null line predictive power failures due unrelated bugs program bug code fragment deterministic respect null null true line program fails cases impossible observe exact conditions causing failure buffer overrun bugs program program crash depending runtime system decisions data laid memory bugs non-deterministic respect observed predicate predictor true program terminates insert line valid pointer assignment controlled conditional true occasionally call read input valid pointer bug non-deterministic respect null summarize predicate bug assume true program fails observed true program succeeds express probability true implies failure crash atomic predicate true failing runs false successful runs denote conditional probability function event event compute failure crash observed true instrumented predicate set runs number successful runs observed true number failing runs observed true estimate failure failure note bug detected simple static analysis meant concise significant application techniques notice failure unaffected set runs observed true bug independent bugs affect failure note runs observed line code checked reached line reached sampled effect failure definition failure generalizes idea deterministic non-deterministic bugs bug deterministic failure equivalently observed true successful run observed true failing run failure bug non-deterministic respect lower scores show weaker correlation predicate program failure failure measure good step algorithm code fragment original deterministic form line failure null predicate good candidate bug line unpleasant fact failure understand observe predicate true line addition failing runs reach line long run reaches line failure line shows failure high bug case decision eventually crash made earlier high failure score reflects fact predicate checked path program doomed address difficulty score predicate chance implies failure difference makes predicate observed true versus simply reaching line predicate checked line probability crashing predicate fact true increase probability failure fact coincides intuition predicate irrelevant bug recall write observed reached sampled regard true false leads definition context crash observed case observed run site predicate occurs reached reached sampled context probability subset runs site predicate reached sampled program fails estimate context context observed observed observed interesting quantity increase failure context read true increase probability failure simply reaching line sampled predicate line failure context increase cases predicate increase predictive power safely discarded section exceptions increase scores based observations important attach confidence intervals scores experiments retain predicate confidence interval based increase lies strictly removes predicates consideration high increase scores low confidence observations pruning predicates based increase desirable properties easy prove large classes irrelevant predicates scores predicate unreachable program invariant controldependent true eliminated test worth pointing test localize bugs point condition bug true crash site code fragment bug attributed success conditional branch test null line pointer dereference line bug discovered algorithm points directly conditions crash occurs line occurs stack trace statistical interpretation explained test increase programming terminology natural statistical interpretation simplified likelihood ratio hypothesis test classes trial runs program failed runs successful runs class treat predicate bernoulli random variable heads probabilities pif pis classes heads probability probability predicate observed true predicate set crashes pif bigger pis formulate statistical hypotheses null hypothesis pif pis versus alternate hypothesis pif pis pif pis estimate pif observed pis observed proportion estimates pif pis approach actual heads probabilities increase number trial runs differ due sampling probability estimates actual values results wrong answer likelihood ratio test takes uncertainty account makes statistic pif pis sample variance term data size large approximated standard gaussian random variable performed independently predicate test decides pif pis guaranteed false-positive probability choosing true sufficient condition choosing pif pis equivalent condition increase observed observed increase failure context pif pis balancing specificity sensitivity turn question ranking predicates survive pruning table shows top predicates ranking schemes explained experiments due space limitations omit additional per-predicate information source file line number interactive version analysis tools concise bug thermometer visualize information predicate length thermometer logarithmic number runs predicate observed table comparison ranking strategies moss redundancy elimination sort descending thermometer context increase predicate files filesindex language tmp false strcmp tmp false files filesindex language filesindex config winnowing window size argc additional predictors follow sort descending increase thermometer context increase predicate token filesbase line line filesbase line chars bytes filesbase line line nid line init additional predictors follow sort descending harmonic thermometer context increase predicate files filesindex language strcmp strcmp files filesindex language tmp true strcmp line line yyleng additional predictors follow small increases thermometer size runs thermometer sequence bands black band left shows context fraction entire thermometer length dark gray band shows lower bound increase confidence proportional entire thermometer length light gray band shows size confidence interval small thermometers indicating tight interval white 
space end thermometer shows number successful runs predicate observed true tables show thermometer numbers quantities make thermometer important bug greatest number failed runs observation suggests importance table shows top predicates ranked decreasing predicates increase discarded predicates table expected involved failing runs large white band thermometer reveals predicates highly non-deterministic true successful runs weakly correlated bugs furtherif reading paper color dark gray band red light gray band pink narrow dark gray bands thermometers increase scores small experience ranking strategies emphasize number failed runs similar select predicates involved failing successful runs predicates high increase scores super-bug predictors predictors include failures bug super-bug predictors account large number failures combining failures multiple bugs highly nondeterministic specific single failure high increase scores possibility importance increase table shows top predicates ranked decreasing increase score thermometers dark gray indicating increase scores close predicates job predicting failure fact program fails predicates true observe number failing runs column small predicates sub-bug predictors predictors subset failures caused bug unlike super-bug predictors experience sub-bug predictors account significant fraction failures bug provide valuable clues represent special cases suggest fundamental bug tables illustrate difficulty defining importance predicates high sensitivity meaning predicates account failed runs high specificity meaning predicates mis-predict failure successful runs information retrieval terms recall precision standard combine sensitivity specificity compute harmonic measure prefers high scores dimensions case increase measures specificity sensitivity found transformation raw counts form normalized ratio numf numf total number failed runs work logarithmic transformation moderates impact large numbers failures metric importance increase log log numf formula undefined due division case define importance table results metric individual counts individual increase scores smaller tables harmonic effectively balanced important factors predicates list high specificity sensitivity predictors accurately describes large number failures case pruning based increase score assess statistical significance importance scores computing confidence interval harmonic exact confidence intervals harmonic delta method derive approximate confidence intervals computing means variances needed applying delta method requires computing estimates underlying binomial probabilities predicates conditioning event counts non-zero redundancy elimination remaining problem results table substantial redundancy easy predicates related redundancy hides distinct bugs fewer failed runs non-deterministic predictors list discussed previously beginning set runs predicates simple iterative algorithm eliminate redundant predicates rank predicates importance remove top-ranked predicate discard runs feedback reports repeat steps set runs empty set predicates empty state easy-to-prove important property algorithm lemma set instrumented predicates set bugs bug profiles uniondisplay znegationslash algorithm chooses predicate list predicts failure due elimination algorithm chooses predicate predictive bug represented input set predicates effect covering set bugs ranked subset predicates property algorithm chooses predicate represent bug hold section algorithm selects strong sub-bug predictor natural predictor technical note lemma guarantee selected predicate positive increase score time selected predicates non-positive increase scores discarded running elimination algorithm arise elimination algorithm increase score predicate covers failing run defined section related discussion representing bug algorithm works reasons predicates redundant predict set failing runs simply removing set runs predicate true automatically reduces importance related predicates correct proportions elimination iterative importance selects good predictor step necessarily predicate covers set failing runs higher-ranked predicates selected eventually finally studied optimization eliminated logically redundant predicates instrumentation sites prior running iterative algorithm elimination algorithm proved sufficiently powerful obtained identical experimental results optimization indicating unnecessary experiments section present results applying algorithm section case studies table shows summary statistics experiments study ran programs random inputs number instrumentation sites varies size program number predicates instrumentation sites yield algorithm effective reducing number predicates user examine case rhythmbox initial set predicates reduced increase test reduction elimination algorithm yields predicates reduction case studies show similar reduction number predicates orders magnitude results discuss sampled data sampling creates additional challenges faced algorithm assume equivalent bug predictors sampled rate reached run equivalent observed disjoint sets runs treated close independent elimination algorithm address problem set sampling rates predicates inversely proportional frequency execution based training set executions set sampling rate predicate obtain expected samples predicate subsequent program executions low end sampling rate clamped minimum site expected reached fewer times sampling rate set rarely executed code higher sampling rate frequently executed code similar strategy pursued similar reasons related work validated approach comparing results experiment results obtained sampling sampling rate predicates set results identical rhythmbox moss experiments judge differences minor logically equivalent predicate chosen ranking predictors table summary statistics bug isolation experiments runs predicate counts lines code successful failing sites initial increase elimination moss ccrypt exif rhythmbox bugs slightly version extra weak predictors tail end list validation experiment validate algorithm performed experiment knew set bugs advance added bugs moss widely service detecting plagiarism software previously discovered repaired bugs moss reintroduced variations original bugs algorithm discriminate pairs bugs similar behavior distinct nature crashing bugs varies buffer overruns null file pointer dereference cases missing end-of-list check traversal hash table bucket missing out-of-memory check violation subtle invariant maintained parts complex data structure addition bugs non-deterministic crash ninth bug incorrect comment handling cases incorrect output crash include bug experiment order show bugs crashing bugs isolated techniques provided automatic self-checking human inspection recognize failing runs experiment ran correct version moss compared output versions oracle labeling runs success failure resulting labels treated identically algorithm based program crashes table shows results experiment predicates listed selected elimination algorithm order shown column initial bug thermometer predicate showing context increase scores elimination performed column effective bug thermometer showing context increase scores predicate time selected top-ranked predicate effective thermometer reflects cumulative diluting effect redundancy elimination predicates selected part experiment separately recorded exact set bugs occurred run columns table show selected predicate bug actual number failing runs selected predicate observed true bug occurs note predicate strong spike bug indicating strong predictor bug runs bugs present top-ranked predicate overwhelmingly predictor bug includes runs bugs occurred situation result misclassification failing runs algorithm observed section bug occur run simply runs bugs occur pick combination interesting case phenomenon bug buffer overruns bug strongly predicted predicate list occurs failing runs predicates examined runs bug detail found failing runs involving bug trigger bug bug overrun occurs incorrect output crash run bug overrun originally found code inspection shown overrun triggered data column algorithm find bugs occur recall part purpose sampling user 
executions accurate picture important bugs consistent goal bug problem worth fixing worth reporting bugs strong predictors list fact top predicates predictor bugs occur exception bug strong sub-bug predictor spot predictor sixth position notice rarest bug bug occurs order magnitude frequently common bug identified immediately bugs verified hand selected predicates judgment lead engineer bug elimination algorithm excellent job listing separate bugs order priority redundancy eighth position bugs report predicate correlated predicates higher list columns numbers easy spot eighth position natural cutoff mind length thermometer log scale larger magnitudes evident notice initial effective thermometers predicates essentially identical predicate position noticeably indicating predicate affected predicate listed earlier specifically companion sub-bug predictor position predicates eighth line initial effective thermometers fewer failing runs non-deterministic showing predicates strongly affected higher-ranked predicates visualizations presented drawback illustrated moss experiment easy identify predicates predicate closely related feature confirming selected predicates represent bugs fact related bug measure strongly implies predicate pprime removing runs affect importance pprime closely related pprime pprime importance drops failing runs removed interactive version analysis tools predicate final ranked list links affinity list predicates ranked ranking score decrease table moss failure predictors nonuniform sampling number failing runs exhibiting bug initial effective predicate files filesindex language line token index passage index token filesbase result true config match comment true accepting state files fileid size token index passage index line yyleng min index line start passages fileid passage index strcmp token sequence token index val passage index bytes filesbase table predictors ccrypt initial effective predicate res line outfile table predictors initial effective predicate names names count additional experiments briefly report experiments additional applications unknown bugs complete analysis results experiments browsed interactively http wisc liblit pldiccrypt analyzed ccrypt input validation bug results shown table algorithm reports predictors point directly single bug easy discover predictors bug predicate listed predicate affinity list indicating predicate sub-bug predictor predicate gnu previously reported buffer overrun results shown table outcome ccrypt predicates retained elimination predicate lists predicate top affinity list indicating predicate sub-bug predictor predicates point overrun bug crash long overrun occurs information stack point crash assist isolating bug exif table shows results exif open source image processing program predicates predictor distinct table predictors exif initial effective predicate maxlen buf size true previously unknown crashing bug twenty minutes work find verify bugs predicates additional highly correlated predicates affinity lists bugs confirmed valid exif project developers illustrate statistical debugging practice failure predictors describe enabled effectively isolate bugs failed runs exhibiting buf size show unique stack trace point termination main exif data save data exif data save data content exif data save data content exif data save data entry exif mnote data save exif mnote data canon save memcpy code vicinity call memcpy function exif mnote data canon save count memcpy buf doff entries data stack trace insight bug algorithm highlights buf size function exif mnote data canon load strong bug predictor quick inspection source code leads construct call sequence table predictors rhythmbox initial effective predicate tmp false mppriv timer false viewpriv change sig queued true histpriv true playlist manager signals dbpriv thread reaper entry entry klass klass genre artist vol float true playerpriv handling error true statusbarpriv library busy true shell shell len main exif loader data exif data load data exif mnote data canon load exif data save data exif data save data content exif data save data content exif data save data entry exif mnote data save exif mnote data canon save memcpy code vicinity predicate buf size function exif mnote data canon load count buf size return entries data malloc apparent code snippets call sequence predicate buf size true function exif mnote data canon load returns line skipping call malloc line leaving entries data uninitialized function exif mnote data canon save passes uninitialized entries data memcpy line reads eventually crashes summary algorithm enabled effectively isolate previously unknown bugs source code unfamiliar small amount time explicit specification program shouldn crash rhythmbox table shows results rhythmbox interactive graphical open source music player rhythmbox complex multi-threaded event-driven system written library providing object-oriented primitives event-driven systems event queues event performs computation possibly adds events queues static analysis today analyze event-driven systems accurately static analysis capable analyzing heap-allocated event queues sufficient precision stack inspection limited utility analyzing event-driven systems stack main event loop unchanging interesting state queues isolated distinct bugs rhythmbox predicate led discovery race condition predicate directly isolate bug predicates affinity list bug revealed turned common incorrect pattern accessing underlying object library recall section rhythmbox developers confirmed bugs enthusiastically applied patches days part quantify bugs important crashing bugs required hours isolate bugs additional bugs represented predictors isolate violations subtle heap invariants directly captured current instrumentation schemes note begun understand bugs information provided tool intend explore schemes track predicates heap structure future work runs needed recall runs case studies bugs number minimum required section estimate runs needed bug predictors identified estimates computed methodology choose predictor bug identified case studies elimination algorithm selects predictors bug pick natural sub-bug predictor chosen predictor compute importance numbers runs importancen importance runs interested minimum importance importancen threshold selected observe chosen predictors studies ranked highly importance scores lower table presents results analysis experiments number runs ranges values study list numbers bug predictor minimum number runs threshold test met number failing runs runs observed true note number runs needed bugs varies orders magnitude runs isolate bug predictors exif bug study extremely rare failing runs total population runs share bug failure exclude bug runs sufficient isolate exif bugs results degrade gracefully fewer runs predictors rare bugs dropping number independent rate bugs occur compare absolute number failures needed isolate bugs notice isolate bug predictor observations failing runs caused bug long takes observations failing runs depends frequency bug occurs sampling rate bug predictor assume failures needed isolate predictor bug failing runs predictor observed true constitute fraction runs runs required algorithm comparison logistic regression earlier work lscript -regularized logistic regression rank predicates failure-prediction strength logistic regression linearly weighted combinations predicates classify trial run successful failed regularized logistic table minimum number runs needed bug runs moss ccrypt rhythmbox exif table results 
logistic regression moss coefficient predicate passage index line passage index line passage index line passage index line regression incorporates penalty term drives coefficients giving weights important predicates output set coefficients predicates giving prediction weakness logistic regression application seeks cover set failing runs regard orthogonality selected predicates represent distinct bugs problem table top ten predicates selected logistic regression moss striking fact selected predicates sub-bug super-bug predictors predicates beginning subbug predictors bug table predicates super-bug predictors length command line predicates program crashes long command lines recall section prevalence super-bug predictors list shows difficulty making penalty term limiting number predicates selected penalty effect encouraging regularized logistic regression choose super-bug predictors cover failing runs expense poorer predictive power compared predictors individual bugs hand sub-bug predictors chosen based excellent prediction power small subsets failed runs alternatives extensions targeted algorithm finding bugs applications variations basic approach presented prove section briefly discuss possibilities focused bug finding ideas isolate predictors program event potentially early predictors program raise exception send message network write disk suspend interesting applications predictors on-line running program knowing strong predictor program failure true enable preemptive action section variations specific algorithm proposed worth investigating chosen discard runs selected elimination algorithm natural choices selected discard runs selected discard failing runs selected relabel failing runs successful runs intuition current choice idea bug manifested successful runs retaining successful runs representative correct program behavior proposal step asserting failing runs bug fixed approximation program bug simply failing runs successful runs technical level proposals differ code coverage preserve discarding runs proposal preserves code paths executed original runs proposal discards runs potentially renders paths unreached runs remain difference paths preserved translates differences failure context scores predicates proposals fact predicate complement prove predicate selected elimination algorithm increase increase increase subscripts proposal discarding runs assuming quantities defined proposal conservative sense positive predictive power proposal potentially predictors positive increase scores analysis reveals predicate negative increase score necessarily useless score negative temporarily overshadowed stronger predictors bugs anti-correlated construct examples predictors bugs result mentioned assures selected elimination algorithm increase score non-negative defined line reasoning suggests proposal discarding runs predicate increase discarded preprocessing step positive predictor selected elimination algorithm case proposal non-negative increase score reasonable eliminate predicates negative scores early related work section briefly survey related work great deal interest applying static analysis improve software quality firmly static analysis find prevent bugs dynamic approach advantages dynamic analysis observe actual run-time values making conservative static assumption run-time values sake soundness allowing simple bugs escape undetected advantage dynamic analysis mines actual user executions data ability assign accurate importance bug additionally shown dynamic analysis require explicit specification properties check find clues wide range errors including classes errors considered design analysis daikon project monitors instrumented applications discover program invariants collects extensive trace information run time mines traces offline accept reject wide variety hypothesized candidate predicates diduce project tests restricted set predicates client program attempts relate state candidate predicates manifestation bugs projects assume complete monitoring controlled test environment goal lightweight partial monitoring suitable testing deployment end users software tomography realized gamma system shares goal low-overhead distributed monitoring deployed code gamma collects code coverage data support variety code evolution tasks instrumentation exposes broader family dataand control-dependent predicates program behavior randomized sparse sampling control overhead predicates give coverage information sum predicate counters site reveals relative coverage site efforts directly apply statistical modeling principles debugging met mixed results early work area burnell horvitz program slicing conjunction bayesian belief networks filter rank bug empirical evaluation shows slicing component finds bug probabilistic model correctly identifies additional payoff small light effort measured man-years required distill experts tacit knowledge formal belief network approach illustrate strategy integrating information program structure statistical modeling process recent work podgurski apply statistical feature selection clustering multivariate visualization techniques task classifying software failure reports intent bucket report equivalence group believed share underlying features derived offline finegrained execution traces sampling approach reduces noise level data greatly restricts instrumentation schemes practical deploy controlled testing environment earlier work podgurski logistic regression select features highly predictive failure clustering identify small tight groups runs share single maximal split clusters problem similar covering bug profile sub-bug predictors contrast current industrial practice stack traces cluster failure reports equivalence classes crash reports showing stack trace top-of-stack function presumed reports failure heuristic works extent single corresponds single point failure experience moss rhythmbox exif suggests assumption hold moss find bugs unique signature stacks crash location present bug triggered bugs deterministic bugs unique stack signatures remaining bugs consistent stack signature observed variety bugs triggered bug failure variety stack states rhythmbox exif bugs caused crashes long bad behavior stacks limited studies attempt real-world deployment monitored software address host practical engineering concerns distribution installation user support data collection warehousing elbaum hardojo reported limited deployment instrumented pine binaries experiences helped guide design wide public deployment applications sampled instrumentation presently underway highly systems single failure avoided behaviors predict imminent failure automatic corrective measures prevent failure occurring software dependability framework sdf multivariate state estimation techniques model predict impending system failures instrumentation assumed complete typically domain-specific algorithm identify early warning predicates predict impending failure actual conclusions demonstrated practical scalable algorithm isolating multiple bugs complex software systems experimental results show detect wide variety anticipated unanticipated failure realistic systems modest number program executions bowring orso harrold monitoring deployed software software tomography dwyer editor proceedings acm sigplan-sigsoft workshop program analysis software tools engineering pastevolume software engineering notes pages acm press burnell horvitz structure chance melding logic probability software debugging communications acm mar chilimbi hauswirth low-overhead memory leak detection adaptive statistical profiling asplos eleventh international conference architectural support programming languages operating systems boston oct elbaum hardojo deploying instrumented software assist testing activity ramss pages ernst cockrell griswold notkin dynamically discovering program invariants support program evolution ieee transactions software engineering feb gross mcmaster porter urmanov votta proactive system maintenance software telemetry ramss pages hangal lam tracking software bugs automatic anomaly detection proceedings international conference software engineering icsepages acm press lehmann testing statistical hypotheses john wiley sons edition lehmann casella theory point estimation springer edition liblit aiken zheng jordan bug isolation remote program sampling james fenwick norris editors proceedings acm 
sigplan conference programming language design implementation pldivolume acm sigplan notices pages acm press liblit naik zheng aiken jordan public deployment cooperative bug isolation proceedings international workshop remote analysis measurement software systems ramss pages edinburgh scotland orso apiwattanapong harrold leveraging field data impact analysis regression testing proceedings european software engineering conference held jointly acm sigsoft international symposium foundations software engineering pages acm press podgurski leon francis masri minch sun wang automated support classifying software failure reports proceedings international conference software engineering icsepages ieee computer society ramss international workshop remote analysis measurement software systems schleimer wilkerson aiken winnowing local algorithms document fingerprinting acm editor proceedings acm sigmod international conference management data san diego california june pages york usa acm press zheng jordan liblit aiken statistical debugging sampled programs thrun saul sch olkopf editors advances neural information processing systems mit press cambridge 
public deployment cooperative bug isolation ben liblit liblit berkeley mayur naik mhn stanford alice zheng alicez berkeley alex aiken aiken stanford michael jordan jordan berkeley department electrical engineering computer science department statistics california berkeley berkeley computer science department serra mall stanford stanford abstract part work cooperative bug isolation cbi undertaken instrument distribute binaries number large open source projects public deployment important step large experiment involving hope hundreds thousands users measure effectiveness cbi paper describes significant engineering issues arise instrumenting source code realistic applications introduction cooperative bug isolation cbi seeks leverage huge amount computation end users software gathering bit information run program performed user community make inferences automatically bugs experienced field approach cbi based compile-time instrumentation program source code insert instrumentation test large number predicates program values execution count times predicate observed true false termination program list predicate counters uploaded central server record program research supported part nasa grant nag nsf grant nos eiaccr- aciand iisdoe prime contract -engthrough memorandum agreement llnl darpa aro-muri acclimate daad- information presented necessarily reflect position policy government official endorsement inferred terminated successfully subsequent statistical analysis predicates correlated program failure engineers values parts program sources crashes cases exact line code fault identified cbi related research efforts great potential make software development responsive efficient giving developers accurate data software deployment testing idea requires significant experimentation real preferably large user communities real applications paper reports experience preparing experiment instrumented number large open source applications listed table total million lines code made instrumented programs public process collecting feedback reports result demonstrated complete cbi system feel comfortable claiming approach technically feasible aspects system improved point components good support deployment realistic instrumented applications collection feedback reports large user community design cbi system involves interesting challenges technical social paper focus solutions technical problems designers similar systems experiments dealing existing native compilers shared libraries plugins threads briefly discuss users interact system give static dynamic measures applications instrument application lines code shared libraries plugins threads evolution check check check gaim check gimp check check gnumeric check nautilus check check check rhythmbox check table instrumented applications native compiler integration system behaves gcc extra command line flags manual annotation source code required existing configuration scripts makefiles work transparently lets instrument million lines open source code releases short turnaround simply changing environment variable builds application instrumenting compiler standard meat instrumentation source source transformation preprocessor real compiler affect stages compilation preprocessing cpp pull extra headers declare define constructs instrumented code fixed content easier fixed headers synthesizing needed constructs programmatically instrumentor compilation inject sampled instrumentation source-to-source transformation emit additional static site information temporary files step assembly asm fuse extra static site information temporary files assembled object file linking pull extra libraries common runtime support code data instrumented programs gcc path flag alternate directory find compiler stages custom scripts directory named asm extra compilation assembly work invoke native compiler stages gcc -specs file flag augment replace standard option specs file option specs file simply specfile determines gcc parses command line arguments add flags request temporary file names specfile essentially tiny domain-specific language tweaking command lines compiler stages facility care preprocessing linking augmenting cpp command lines replacing stages custom scripts static site information main compilation task inject instrumentation code phase produces static information instrumentation site includes site source file line number host function control flow graph node information specific instrumentation scheme decoding feedback reports information tie predicate counts back source level features understood programmer experience maintaining information external object file brittle existing application build scripts move rename object files build process fuse static site information assembled object file storing custom elf sections linker combines object files pads unknown section fixed modulus concatenates same-named sections link order represent static site information remains valid null-byte injection concatenation instrumented executable shared library plugin describing complete static information instrumentation sites extra sections flagged debug information means stripped debugging information post-build packaging retain copy locally assist report decoding end users download store extra information machines libraries plugins post-run reporting easy application consisted single object file simply write predicate counters order file list constitute complete report table applications involve multiple object files form shared libraries plugins note table counts shared libraries plugins part source code application additionally generally shared libraries plugins resident end user machine running environment mix code instrumented cbi code shared libraries interesting applications instrumented instrumented applications cope uninstrumented code instrumented code cope finding uninstrumented application orthogonal set problems arises static linking dynamic loading system control linker assume object files order plugins loaded late unloaded time instrumented plugin unloaded capture part feedback report immediately unloaded global predicate counters vanish address space longer accessed solution problems make object file self-managing initialization code runs loaded finalization code runs unloaded objects part main application binary initialization code runs early program execution main finalization code runs main returns afterexit called shared libraries similar plugins initialization code runs dlopen plugin mapped memory plugin finalization code runs dlclose plugin removed memory object file maintains instrumentation state object file maintains predicate counters situation global knowledge loaded object files finalization code run crash program receives fatal signal immediately gather predicate counters loaded object file feedback report maintain doubly-linked list loaded object files initialization finalization code object file adds removes file list moment time application central registry instrumented loaded object files attention fact global registry corrupted buggy program maintain global count expected size global registry walking list signal handler counter decide stop reached end list data structure prevents infinite loop memory error application introduces cycle doubly-linked list global registry damaged ways misbehaving program avoiding cycles important case handle complications checking corrupted global registry general problem completely isolate program instrumentation program unsafe languages result sanity check feedback reports central server discard ill-formed practice receive ill-formed reports number tiny fraction reports threads cbi system maintains kinds global data special attention multi-threaded applications case thread-safety hurt performance extra care fact application multithreaded compiler command line gcc -pthread flag key feature cbi system performance improved sampling instrumentation code implemented frequently skipping instrumentation executing fast path instrumentation global countdown determine instrumentation sites skip testing predicate recording result countdown chosen 
randomly geometric distribution desired sampling rate equivalent efficient tossing coin instrumentation site decide sample multi-threaded system global variable holding next-sample countdown source high contention threads simple solution problem give thread independent countdown variable equivalent giving thread coin toss behavior system per-thread countdowns indistinguishable single global countdown addition avoid locking enacting plan requires compiler support thread storage qualifier declare thread-specific storage gcc extension requires support posix threading runtime library runtime loader alter thread creation initialize thread global state --wrap flag provided gnu linker replace pthread create augmented version class data requires special handling multi-threaded applications predicate counters recall predicate counters track predicate line code observed true false efficiency low sampling rates hundred times average randomized line code predicate executed predicates tested rarely individual counter accessed rarely single thread maintain copy predicate counter shared threads critical operation counters increment basic cpu architecture atomically resorting heavyweight locking finally class data protected concurrent access includes global registry compilation units report file structures accessed rarely guarantee exclusive access guarding mutual exclusion lock user interaction user launches instrumented application run instrumented binary directly install wrapper script expected location usr bin put instrumented binary wrapper script responsibilities performs user interaction underlying application collects raw feedback report instrumented application packages transit sends report collection server information program outcome avoid adding gui infrastructure encrypted networking support applications script language python excellent library support networking desktop interaction wrapper script starts checks user run instrumented version application presents first-time opt-in dialog box shown figure dialog box briefly describes goals project consequences participating lets user decide logo icon highlighting explanatory text change reflect user current choice hyperlink button links project web site information dialog box initially presented background real application launched waiting reply run application reports data user selected preference remembered first-time opt-in dialog box shown statistical debugging sampled programs alice zheng division berkeley alicez berkeley michael jordan division department statistics berkeley jordan berkeley ben liblit division berkeley liblit berkeley alex aiken division berkeley aiken berkeley abstract present strategy automatically debugging programs sampled data thousands actual user runs goal pinpoint features correlated crashes accomplished maximizing appropriately defined utility function analogies intuitive debugging heuristics demonstrate deal types bugs occur real programs introduction software perfect debugging resource-consuming process users software bugs granted willingly run buggy programs day complaint sense user runs program ideal test suite software engineer hope effort harness information contained field tests companies netscape mozilla microsoft developed automated opt-in feedback systems user crash reports direct debugging efforts bugs affect people information users provide collect bit information user run successful end information automatically pinpoint locations bugs earlier work present program sampling framework collects data users minimal cost aggregated runs analyzed isolate bugs specifically learn classifier data set regularizing parameters features highly predictive outcome large non-zero weights limitation earlier approach methods deal types bugs paper describe design single classification utility function integrates debugging heuristics determinism features significant issue domain additional penalty term false positives included deal aspect utility levels subjective robust offer simple guidelines selection demonstrate results remain stable strong wide range reasonable parameter settings start briefly describing program sampling framework section present feature selection framework section test programs data set section experimental results section program sampling framework approach relies collect information program behavior runtime avoid paying large costs time space sparsely sample program runtime behavior scatter large number checks program code execute single run sampled results aggregated counts longer chronology information space efficient catch types bugs asks types questions instance function call return values good sanity checks programmers neglect memory corruption common class bugs check pointers prescribed ranges add large set commonly assertions code wild guesses capture interesting behavior runtime program tosses coin low heads probability independently assertion encounters decides execute assertion expensive generate random coin toss separately assertion incur large overhead program run slower executing assertion key combine coin tosses bernoulli random variables success probability number trials takes success geometric random variable probability tossing bernoulli coin subsequent runs change preference distinct sampler control panel background wrapper posts small status icon desktop status bar notification area icon visual reminder instrumented application running simple pop-up menu toggle globally disable enable sampling status figure first-time opt-in dialog box application min max evolution gaim gimp gnumeric nautilus rhythmbox table feedback report sizes bytes icon depending sampling enabled disabled globally remains present long instrumented application running menu item launches sampler control panel detailed customization data collection preferences opt-in dialog box status icon control panel work user fully informed fully control additional configuration management hooks system administrators change defaults mandatory locked-down settings settings include sampling density address report collection server reporting enabled selected applications tracking user behavior delicate matter users system administrators adapt system local concerns wrapper script launches instrumented binary subprocess check subprocess exit status result code fatal signal included report uploaded feedback collection server wrapper script compresses raw feedback report transit gzip-compatible compression huge benefit reports zeros compress average compression reports received table shows range report sizes received application largest reports bytes uploaded slow modem connection seconds submitting report wrapper checks sampling enabled globally application user changed mind program launch chance quash unwanted feedback report reaches collection server report submitted http post request encrypted ssl connection http request response server ordinarily collection server give response success code server give response wrapper script receives presents user html page feature critical security issue found requiring upgrades http reply include special reply headers update local sampling configuration client ability promote destination url future reports relocate collection server change sampling density default performance problems arise issue poison pill turns sampling future runs application intended shutoff cooperative bug isolation project discontinued future date feature learned prior experience elbaum hardojo suppress future reports individual misbehaving users needed facilities status public deployment conclude discussion experience public deployment applications listed earlier concern approach adds great deal code application fact binaries large original uninstrumented program growth disk footprint considerably smaller considers entire package typical large application fact executable code small percentage total distribution applications instrumented downloaded packages larger installed footprint disk grows actual application binaries larger original distribution application total good error crash evolution gaim gimp gnumeric nautilus rhythmbox table number reports received date received complaints times generate geometric random variable countdown sample assertion decrements countdown reaches perform assertion generate geometric random variable checking counter reached assertion expensive procedure code optimization analyze contiguous acyclic code region loopsand recursion-free compile time count maximum number assertions path region generated code decrements bulk takes fast path skips individual checks contiguous code region single check maximum threshold samples chronological order program runs huge amount space record information save space record counts assertion found true false program finishes counts program exit status back central server analysis program sampling framework non-trivial software analysis effort interested readers refer treatment subtleties detailed analyses performance impact sampling rates classification feature selection hopes catching wide range bugs add large number wild guesses code cast bigger net step identify relevant features crashes labeled output successes labeled knowing final program exit status crashed successful leaves sampling density controls tradeoff runtime overhead data sparsity set small tolerable overhead requires runs order alleviate effects sparsity problem large programs mozilla windows thousands crash reports day classification setting primary goal feature selection good feature selection corroborated classification performance case care features correctly predict classes working usual maximum likelihood setting classification regularization define maximize utility function ultimately wholly unrelated noted goals variable feature selection coincide classification classification means end demonstrate section good classification performance assures user system working correctly examine selected features make sense characteristics problem concentrate isolating bugs caused occurrence small set features assertions true crash occurs identify predicate counts positively correlated program crashing contrast care features highly correlated successes makes feature selection inherently one-sided process due sampling effects feature responsible ultimate crash observed run true case quick painless deaths program crashes actual bug occurs easy bug find wouldn crashing point top stack challenge approach single opportunity sample buggy feature program dies crashes input feature profile similar successful run classification perspective means false negatives end spectrum dealing deterministic bug false positives probability buggy feature observed true program crash program crash bug occurred deterministic bug false positives training process incur larger penalty compared false negatives designing utility function denote data point input vector non-negative integer counts output label denote classifier parameter vector prediction outcomes cases represent false negative false positive general form utility maximization classification define separate utility functions cases maximize sum expected utilities max bugs caused non-occurrence events forgotten initializations focus type bugs paper bug deterministic crashes program time observed dereferencing null pointer crash program exception note notion determinism data-dependent predicated trial runs indicator function event functions utility case regularization term interpreted prior classifier parameters bayesian terminology approximate distribution simply empirical distribution actual distribution input features determined software examination difficult highly non-gaussian discriminative classifier vector augmented trailing represent intercept term logistic function model class conditional probability decision boundary set regularization term chosen lscript norm effect driving summationtexti slightly simplify formula choose functional form add extra penalty term false positives log log log note additive constants affect outcome optimization ensure utility decision boundary fold multiplicative constants utility functions base log function freely exchangeable find expected utility function equivalent ylog log bardbl bardbl eqn akin lasso standard logistic regression parameter estimation lscript -norm regularization general expected utility function weighs class separately additional penalty term false positives parameter learning stochastic gradient ascent objective function desirable properties fast convergence rate space efficiency on-line methods improve user privacy sufficient statistics collected trial run discarded obviating permanently store user private data central server eqn concave lscript norm indicator function non-differentiable handled subgradient ascent methods practice jitter solution point non-differentiability taking small step subgradient means matter weights close essentially features positive weights selected end interpretation utility functions closely examine utility functions defined eqns case fig plots function log positive positive approaches assuming abnormalities program crash reasonable classifier based linear combination features subgradients generalization gradients defined non-differentiable points subgradient convex function sublinear function pivoted point minorizing entire convex function convex concave optimization subgradient feasible descent ascent direction details log log figure plot true positive indicator function utility function log plot 
true negative indicator function utility function log asymptotic slopes log log approaches crude smooth approximation indicator function true positive hand negative utility function negative acting penalty false negatives similarly fig plots utility functions cases utilify function upper bound effect correct classifications limited hand incorrect classifications undesirable penalty unbounded slowly deceasing negative number taking derivative ddz log log positive log sandwiched linear functions log log starts closer log approaches log asymptotically fig false positive close decision boundary additional penalty eqn larger default false positive penalty asymptotically equivalent turn roles multiplicative weights weigh relative importance classes deal imbalanced training sets class disproportionately larger time program exits successfully crashing deal successful runs crashed runs section care predicting class increasing equal balance data sets beneficial feature selection performance finally knob determinism bug deterministic setting large severely penalize false positives bug deterministic small affords slack accommodate runs failed section bug deterministic quality final features selected higher large values previous paper outlined simple feature elimination heuristics case deterministic bug elimination universal falsehood discards counter represents assertion true common data preprocessing step elimination lack failing discards counter crashes caused crash elimination successful counterexample discards counter non-zero successful run assertions true subsequent program failure model feature positive crashes weight decrease maximization process selected crash-predictive feature handles elimination lack failing heavily weighted feature positive successful run training set classifier result false positive false positive penalty term decrease weight feature chosen end utility maximization handles elimination successful counterexample model derive neatly subsumes hoc elimination heuristics earlier work case studies examples present cases studies programs bugs opposite ends determinism spectrum deterministic ccrypt small encryption utility ccryptis bug involves overwriting existing files user responds confirmation prompt eof ccrypt consistently crashes non-deterministic gnu bcthe unix command line calculator tool find feeding megabytes random input crash roughly time calling malloc strong indication heap corruption bugs inherently difficult fix inherently non-deterministic guarantee mangled heap crash ccrypt sensitivity eof inputs suggests problem interactions standard file operations randomly sampling function return values identify key operations close bug instrumented program adds instrumentation function call sample record number times return negative positive call sites interest counters lieu large user community generate runs artificially reasonable inputs run randomly selected set present absent files randomized command line flags randomized responses ccrypt prompts including occasional eof collected trial runs sampling rate result package sizes downloaded expanded disk potential issue application performance received complaints performance instrumented applications sampling apparently sparse sampled densely interactive applications spend time waiting user note applications cpu-intensive phases rhythmbox loading library thousands music files gnumeric recalculating large spreadsheet table summarizes current state data instrumented applications total number valid feedback reports received broken good runs runs exited non-zero error status runs ended crash due fatal signal note large variation crash rates gimp rhythmbox good news bad news figures bad news received reports carry statistically significant analysis results based previous experience studies lab running applications synthetic data simulate large user community sampling ten twenty thousand runs current methods achieve accurate analysis results ten times number reports received date applications situation reflects inherent aspect cbi similar approaches methods work minimum scale good news applications crash indicating potential improve state software users participating cbi addition data demonstrate complete system works instrumenting code gathering reports continue receive feedback reports daily beginning experiment invested effort attracting users step experiment crash trial runs randomly selected training remaining held cross-validation counter features constant runs leaving counters considered training process case interested behavior pointers buffers pointers array indices scalars compare pairs scalar values direct assignment scalar variable identify variables type scope record number times found greater equal additionally compare pointer null find ways recruit began collecting data public october users test advantages cbi large user communities complex applications elbaum hardojo deploying instrumented software assist testing activity ramss international workshop remote analysis measurement software systems pages liblit cooperative bug isolation project http berkeley liblit sampler liblit aiken zheng jordan bug isolation remote program sampling james fenwick norris editors proceedings acm sigplan conference programming language design implementation pldivolume acm sigplan notices pages acm press liblit aiken zheng jordan sampling user executions bug isolation proceedings workshop remote analysis measurement software systems pages portland oregon zheng jordan liblit aiken statistical debugging sampled programs advances neural information processing systems vancouver whistler british colombia canada dec 
counters constant runs data set consists runs distinct random inputs sampling rate runs randomly chosen training set hold-out set experimental results maximize utility function eqn stochastic subgradient ascent learning rate order make magnitude weights comparable feature values shifted scaled lie normalized unit variance learning parameters relative scale important regularization parameter set fixed setting model set run iterations training set process converges sooner takes roughly seconds matlab ghz pentium cpu ram smaller ccrypt dataset requires seconds values set cross-validation long time leave ultimate control values users tool important knobs controls relative importance classification performance crashed runs adjusts believed level determinism bug guidelines setting find work practice order counter effects imbalanced datasets ratio range ratio successful crashed runs crucial ccrypt data set roughly successful runs crash higher ultimately important score ccrypt score ccrypt score score figure cross-validation scores ccrypt data set cross-validation scores data set scores shown maximum free parameters correctly classify crashes false positives performance metric hold-out set confusion matrix define score sum percentages correctly classified data points class fig shows plot cross-validation score maximum number settings ccrypt data set values apparent plot values range roughly equivalent terms classification performance specifically case range suggested guideline fig shows cross-validation scores plotted values case long rough range classification performance remains settings safe classification select high quality features debugging smoking gun directly ccrypt bug traverse xreadline return call xreadline returns input terminal eof mentioned safe settings feature returned top feature rest higher ranked features sufficient conditions crash difference optimal settings separation top feature rest large order magnitude non-optimal settings classification score-wise separation smaller classification results sensitive settings fig classification score roughly constant impact classification performance expected bug non-deterministic false positives exist training set small feature selection results reasonable parameter settings classification performance top features group correlated counters point index array abnormally big top features storage arrays indx optopt storage arrays indx opterr storage arrays indx math storage arrays indx quiet storage arrays indx count fig classification performance deceptively high case offsets cross-validation score increasing number predicted non-crashes expense worse crash-prediction performance top feature sufficient condition crash false positive-inducing feature lesson bug believed deterministic positive features immediately point line file storage variable indx abnormally big indx array index runs actual array length contained integer variable count program crash long array bound violation means opportunities sampling framework observe abnormally big indx comparisons indx integer variables large set inter-correlated counters subset picked algorithm top features training run shown smoking gun indx count ranked number general rank smaller top features suffice predicting crashes pointing line code conclusions future work goal system automatically pinpoints location bugs widely deployed software tackle types bugs custom-designed utility function determinism level knob methods shown work real-world programs locate bugs range parameter settings real world programs bugs distinctly labeled set crashed runs difficult tease failure modes clustering relies macro-level usage patterns opposed microscopic difference failures on-going research extending approach deal problem multiple bugs larger programs working modifying program sampling framework denser sampling important regions code alleviate sparsity features reducing number runs required yield results acknowledgments work supported part onr muri grant nasa grant nag nsf grant nos eiaccr- aciand iisdoe prime contract -engthrough memorandum agreement llnl liblit aiken zheng jordan bug isolation remote program sampling acm sigplan pldi blum langley selection relevant features examples machine learning artificial intelligence guyon elisseeff introduction variable feature selection journal machine learning research march lehmann testing statistical hypotheses john wiley sons edition hastie tibshirani friedman elements statistical learning springer verlag 
hiriart-urruty lemarechal convex analysis minimization algorithms volume springer verlag japkowicz stephen class imbalance problem systematic study intelligent data analysis journal november 
btrace path optimization debugging akash lal akash wisc junghee lim junghee wisc marina polishchuk mpoli wisc ben liblit liblit wisc computer sciences department wisconsin-madison october abstract present solve path optimization problem programs set program nodes called critical nodes find shortest path program control flow graph touches maximum number nodes control flow graphs over-approximate real program behavior adding dataflow analysis control flow graph narrow program actual behavior discard paths deemed infeasible dataflow analysis derive efficient algorithm path optimization based weighted pushdown systems present application path optimization integrating cooperative bug isolation project cbi dynamic debugging system cbi mines instrumentation feedback data find suspect program behaviors called bug predictors strongly program failure instantiating critical nodes nodes bug predictors solve shortest program path touches predictors path programmer debug software present early experience hybrid static dynamic system debugging introduction static analysis programs variety purposes including compiler optimizations verification safety properties improving program understanding static analysis advantage executions program strong guarantees program behavior paper present static analysis technique supported part onr contracts nsf grant ccrand gift microsoft research finding program execution sequence optimal respect criteria target set program locations call critical nodes execution traces program find trace touches maximum number critical nodes shortest length traces reachability programs undecidable general over-approximate set traces program paths program control flow graph solve optimization problem graph dataflow analysis added control flow graph narrow program actual behavior discarding paths deemed infeasible dataflow analysis show powerful framework weighted pushdown systems represent solve variations path optimization problem primary motivating application implemented path optimization algorithm integrated cooperative bug isolation project cbi create btrace debugging support tool cbi automated bug isolation system adds lightweight dynamic instrumentation software gain information runtime behavior information identifies suspect program behaviors called bug predictors strongly program failure bug predictors identify circumstances failure successfully find previously unknown bugs cbi primarily dynamic system based mining feedback data observed runs work btrace represents major effort combine cbi dynamic statistical approach formal static program analysis btrace enhances cbi output giving context interpreting bug predictors cbi bug predictors set critical nodes construct path entry point program failure site touches maximum number bug predictors cbi associates numerical score bug predictor higher scores denoting stronger association failure extend btrace find shortest path maximizes sum prediction scores predictors touches btrace finds path sum predictor scores predictors path maximal shorter path score user add constraints form stack traces left failed program restrict attention paths unfinished calls order stack trace ordering constraints restrict order predictors touched constraints improve utility btrace debugging purposes producing path close actual failing execution program give user substantial insight root failure present preliminary experimental results section support claim constructing shortest path programmer smallest piece code find bug extra constraints path optimization problem solved btrace stated btrace problem control flow graph program nodes edges single node representing crash site program set critical nodes representing bug predictors function representing predictor scores find path control flow graph maximizes summationtextn set critical nodes path touches minimizes length restrict search optimal path paths satisfy constraints stack trace stack trace paths reach unfinished calls order stack trace ordering list node pairs paths touch node node dataflow dataflow analysis framework paths ruled infeasible dataflow analysis requirements dataflow analysis framework section finding feasible path program exists general undecidable powerful dataflow analysis btrace return infeasible path real execution program acceptable judge usefulness path helps programmer debug program feasibility key contributions paper present algorithm optimizes path selection program criteria weighted pushdown systems provide common setting mentioned optimization constraints satisfied describe hybrid static dynamic system combines optimal path selection cbi bug predictors support debugging remainder paper organized section presents formal theory representing paths program section derives algorithm finding optimal path section additional background cbi considers path optimization algorithm conjunction cbi debugging programs section presents experimental results section discusses related work area section concludes final remarks future work describing paths program section introduces basic theory approach section formalize set paths program pushdown system secemain cal ret exitmain exitp cal ret figure interprocedural control flow graph exit nodes represent entry exit points procedures dashed edges represent interprocedural control flow tion introduce weighted pushdown systems added ability associate path paths program control flow graph cfg program graph nodes program statements edges represent flow control statements figure shows cfg program procedures adopt convention function call program represented nodes source interprocedural call edge callee entry node target interprocedural return edge callee exit node back caller figure nodes represent call main nodes represent call paths sequences nodes connected edges cfg valid path emain exitp invalid call node return node node general valid paths cfg context-free language matching call return pairs call matching return edge exit node reason natural pushdown systems describe paths program definition pushdown system triple set states set stack symbols set pushdown rules rule written arrowhookleft emain arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft exitmain exitmain arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft exitp arrowhookleft exitp exitp arrowhookleft figure pushdown system models control flow graph shown figure pushdown system finite automaton stack input interested transition system describes language generates definition configuration pushdown system pair rules pushdown systems describe transition relation configurations arrowhookleft rule uprime uuprime uprime cfg set nodes set edges pushdown system cfg constructed constructed rules intraprocedural edge add rule arrowhookleft exit point procedure add rule arrowhookleft interprocedural call edge call site entry point callee return site add rule arrowhookleft figure shows construction cfg figure note single state difficult transition system pushdown system obtained fashion describe valid paths cfg figure shows path cfg transitions pushdown system path transition system ending configuration stack trace describes path cfg unfinished calls return sites sense configuration stores abstract run-time stack program transition system describes valid program make emain exitp emain exitp figure path cfg shown figure path pushdown system cfg superscripts rules figure justify transition created pushdown system associate path stores set bug predictors touched path set store length path order select shortest path case paths touch predictors accomplish section weighted pushdown systems describe section weighted pushdown systems weighted pushdown system wpds obtained associating weight pushdown rule weights set satisfies bounded idempotent semiring properties definition bounded 
idempotent semiring quintuple set elements called weights elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule operation compute weight concatenating paths operation compute weight merging parallel paths sequence rules define val definition item required wpdss efficiently explore paths item required termination search optimal path pushdown configurations cprime path cprime set rule sequences transform cprime denote set stacks start existing work wpdss solve problems definition weighted pushdown system cprime configuration generalized pushdown predecessor gppcprime problem find circleplustext val path cprime witness set paths path cprime circleplustext val circleplustext val path cprime witness set paths uniontext path cprime circleplustext val generalized pushdown successor gpscprime problem find circleplustext val path cprime witness set paths path cprime circleplustext val circleplustext val path cprime witness set paths uniontext path cprime circleplustext val problems considered backward forward reachability problems aims find combine values paths pair configurations find witness set paths justify reported set paths finite item definition note reachability problems require finding smallest witness set wpds algorithms find finite set presented restricted form reachability problems general wpds find regular set configurations restricted form presented sufficient capture path finding problem section presents construction finding optimal path apply general theory section specific btrace problem defined section begin developing solution basic path optimization problem dataflow ordering constraints add constraints back show basic solution extended accommodate additional features creating wpds cfg pushdown system representing paths constructed section set critical nodes notation section construct wpds solved find path path track length set critical nodes touches set elements consist subset critical nodes touched natural number length path associate path element define weight domain definition bounded idempotent semiring component defined set weights power set define reduce reduce notexistential vprime vprime define reduce semiring constants semiring weight domain represent weight set paths accomplished defining weight set elements combine operation simply takes union weights eliminates element element elements shorter path length chosen drives wpds paths shortest length extend operation takes union critical nodes sums path lengths pair elements weights reflects fact path length touches critical nodes extended path length touches critical nodes path length touches critical nodes semiring constant denotes infeasible path constant denotes empty path touches critical nodes crosses graph edges complete description wpds associate pushdown rule weight arrowhookleft associate weight braceleftbigg rule length path increased set critical nodes grows include critical node easy sequence rules describes path cfg val set critical nodes touched path length note starting weights pushdown rules semiring operations create weights element subset set critical nodes reduce operation ensures store shortest path touches set critical nodes solving wpds optimal path found solving generalized pushdown reachability problems wpds scenarios crash site stack trace crash crash site stack trace start crash site entry point program crash site theorem solving gps values path touches critical nodes shortest path length set paths path touches critical nodes length theorem holds paths set paths unfinished calls taking combine values paths selects subsets shortest path touches critical nodes discards longer witness set record paths justify reported path singleton-set weight path member stack trace top-most element gps gpp theorem solving gps gpp values valid path stack trace touches critical nodes shortest path length set paths stack trace path touches critical nodes length theorem find required values gps gpp forward reachability starting forward program backward reachability starting stack trace backwards section compares computational complexity approaches obtained values find optimal path easily user-defined measure associates score critical node compute score summing scores critical nodes choose pair highest score extracting path pair optimal path advantages user-defined measure user bug predictor scores cbi make scores user give negative score critical nodes avoided path user add critical nodes score ordering constraints section lets tool work interactively user find suitable path generally user give measure directly associates score path measure user decide choose shorter paths paths touch critical nodes terms path optimization cbi inserting predictors multiple bugs associating score paths touch predictors bug exponential complexity related number critical nodes shown section suggests create multiple wpdss bug inserting bugs predictors wpds complexity solving wpds methods outlined theorems require solving gps gpp reading configuration time required reading witness factored steps number pushdown rules size cfg proc number procedures program entry point program number critical nodes length shortest path distant cfg node height semiring length longest descending chain time required perform semiring operation avoid requiring wpds terminology specialize complexity results solving reachability problems wpds gps solved time proc gpp requires time reading constant time requires time put results stack trace option theorem obtaining optimal path case requires time proc stack trace theorem options suppose stack traces multiple failures caused bug option solve gps stack trace worst-case time complexity proc average length stack traces option requires stack trace solves gpp asks worst-case time complexity evident complexities option faster complexity grows faster increase note worst-case complexities comparisons based hold average case fact wpds wpds implementation solving gps faster solving gpp present intuition complexity results stated cfg shown figure node critical node path takes left branch length path takes branch length touches critical nodes path path discarded remember path branching program increases total number paths program increases complexity linearly node critical node remember paths touches critical nodes shorter length path touched shorter branch general remember path subset set critical nodes reflected design weight domain contributes exponential complexity respect number critical nodes exponential complexity unavoidable reason path optimization problem solve strict generalization traveling salesman problem objective find shortest path points touches set nodes adding ordering constraints add ordering constraints path optimization problem suppose constraint node visited node paths visit visiting implementation advantage fact pds obtained cfg backward reachability easier cfgs predecessor return-site node figure simple control flow graph easy add constraints wpds extend operation compute path change yield paths satisfy ordering constraint redefine reduce braceleftbigg bracerightbigg sequence rules describes path cfg val set critical nodes visited path length provided visit val path visit visiting ordering constraint simply add 
clauses constraint definition extend btrace debugging application essential user interact tool constraints provide user intuition guide optimization problem solved btrace constraints change worst case asymptotic complexity solving reachability problems wpds prune paths explored constraint cuts size weights produced extend operation adding dataflow considered interpreting semantics program control flow implies wpds find infeasible paths occur execution program path assigns true branch conditional general undecidable restrict attention paths occur program execution rule infeasible paths increase chances presenting feasible near-feasible path user dataflow analysis dataflow analysis carried approximate program variable set values variable point program dataflow analysis satisfies conditions integrated wpds designing weight domain examples dataflow analyses include uninitialized variables live variables linear constant propagation affine relation analysis bounded idempotent semiring weight domain provided function associates pds rule cfg edge weight satisfies property possibly infinite set paths pair program nodes circleplusdisplay vald paths infeasible vald dfd means vald infeasible path path executed program imposes soundness guarantee dataflow analysis rule infeasible paths computability dataflow analysis fact encoded bounded idempotent semiring briefly describe classical dataflow analysis frameworks encoded weight domains details found reps classical dataflow analysis meet semilattice intersectionsq set dataflow facts element represents set program states memory configurations meet operator intersectionsq combine dataflow facts obtained paths latticetop greatest element latticetop intersectionsq represents empty set program states program statement dataflow transformer represents effect executing statement state program effect executing path program computed composing dataflow transformers statement transformer obtained path dataflow analysis problem compute program point meet-over-all-paths solution mopn paths starting point program dataflow fact representing set states beginning program mopn represents set states arise combines values contributed path program leads computable sufficient condition computability transfer functions program statements distributive intersectionsqe intersectionsq dataflow analysis presented encoded weight domain provided conditions met dataflow transformers program statements chosen setf closed meet composition intersectionsq intersectionsq intersectionsq transformers distributive transformers strict latticetop latticetop latticetop infinite descending chains weight domain intersectionsq circledot latticetop circledot reps give encoding simple constant propagation section weight domain path dataflow transformer path vald path dataflow analysis concerned computing over-approximation set states arise program point vald latticetop path contribute set program states infeasible general requirement equation satisfied similar reasoning combine values set paths corresponds calculating contribution sets paths program states empty latticetop paths infeasible paths entry program node combine values paths applied simply mopn translation dataflow transformers weight domain talk meet-over-all-paths configurations pushdown system solving gps weight domain combine meet values paths stack trace unique advantage gain conventional dataflow analysis wpdss assume thatsd weight domain satisfies equation function associates dataflow weight rule pushdown system change weight domain wpds definition bounded idempotent semiring component defined set weights power set set define reduced reduced defined braceleftbigg min bracerightbigg define reduced set negationslash satisfy ordering constraints semiring constants satisfy ordering constraints iff constraint visit case weight rule arrowhookleft braceleftbigg path set predictors touches length dataflow infeasible paths removed extend operation weights dataflow discarded formally path cfg val vald negationslash dataflow weight path length path set critical nodes touched path path satisfies ordering constraints satisfy ordering constraints vald val analysis weight domain similar property simulation esp distinct dataflow maintained property-state maintain distinct dataflow weight subset critical nodes repeating theorems present case gps stack trace results cases obtained similarly theorem wpds obtained weight domain definition solving gps values path stack trace visits critical nodes satisfies ordering constraints infeasible weight domain shortest path length path stack trace visits predictors satisfies ordering constraints length generally paths constant val min worst case time complexity presence dataflow increases factor height time required applying time required applying theorem completely solves btrace problem mentioned section section presents dataflow weight domain experiments extensions increase practical utility dataflow analysis framework extensions dataflow analysis copy constant propagation give weight domain dataflow analysis encode copy-constant propagation weight domain similar encoding sagiv reps horwitz copy-constant propagation concerned determining variable fixed constant point program interprets constant-to-variable assignments variable-to-variable assignments abstracts assignments constant ignore conditions branches assume branches nondeterministic analysis ruling infeasible paths put conditionals var set global variables program zlatticetop latticetop zlatticetop intersectionsq standard constant propagation meet semilattice obtained partial order subsetsqequalcp subsetsqequalcp latticetop set weights weight domain var var zlatticetop represents dataflow transfer function summarize effect path env var state program path executed zlatticetop path executed env intersectionsq env intersectionsq env intersectionsq component component define semiring operations intersectionsq uniondisplay intersectionsq combine operation simply concatenation expressions extend operation substitution var weight transformer statement mapsto mapsto latticetop weight statement mapsto latticetop mapsto latticetop taking combine mapsto mapsto latticetop extend mapsto mapsto semiring constants latticetop latticetop constructs perfectly valid weight domain copy-constant propagation reason weight domain considers paths feasible fact extend non-zero weights remedy disqualify paths infeasible add interpretation branch conditions handling conditionals handling branch conditions problematic dataflow analysis presence conditions hard finding branch condition evaluate true copy-constant propagation pspace-complete resort approximate dataflow analysis give computing meet-over-all-paths translates relaxing distributivity requirement weight domain fortunately wpdss handle non-distributive weight domains relaxing definition item set weights subsetsqequal subsetsqequal subsetsqequal partial order defined subsetsqequal iff weaker property generalized reachability problems solved approximately obtaining configuration obtain weight subsetsqequal path optimization problem inaccuracy limited dataflow analysis eliminate paths dataflow potentially find infeasible find path vald acceptable rule infeasible paths flexibility putting simple treatment conditions dataflow analysis disadvantage lose strong characterization type paths eliminated copy-constant propagation bring conditions picture adding weights arithmetic condition associate weight rule arrowhookleft cfg edge execute evaluates true program state associate weight cfg edge true branch conditional weight xnegationslash false branch combine extend operations modified appearing evaluates false simple treatment conditionals extend operation defined associative implies loss precision evaluate conditions variables depend input parameters procedure condition instantiated call choose powerful treatment conditions based weakest preconditions associating weight precondition written makes extend associative simple conditions opted previous simpler treatment conditionals easier implement benefit preconditions practical setting directly evident leave judging benefit precise dataflow analyses future work handling local variables extension make dataflow analysis treatment local variables recent extension wpdss shows local variables handled merge functions local variables saved call merged information returned callee compute effect call treatment local variables restrict weight manage local variables procedure proc set procedures program 
var set global variables varpr set global variables local variables procedure proc set weights dld var var zlatticetop uniontext proc varpr varpr zlatticetop uniontext arithmetic condition extend combine operations defined applied weights set local variables drop local variables operation global variables conditional weights mismatch variables assume condition evaluates true ignore condition define merge operation calculate effect call variables varpr variables varpr define merged merged global local merged merged merged weight variables varpr assigns local variables latticetop global variables effectively discards local variables local global remove assignments local global variables merge operation needed conclude call call callee assigns note simply created weights local global variables program deal recursive calls correctly merge function carries semiring definition merge reduce set merged negationslash satisfy ordering constraints extending wpdss manner change theorem inaccuracies dataflow analysis finding bug predictors formalisms section solving variety optimization problems concerned touching key program points path btrace represents application ideas enhancement statistical debugging analysis performed cooperative bug isolation project cbi section briefly review existing cbi system paying attention kind data analysis yields ways enhanced path optimization distributed data collection cooperative bug isolation project low-overhead sampling infrastructure gathering small amounts information run program executed user community inserts instrumentation test large number predicates program values execution cbi predicate thought simple local assertion program state specific code location predicates cast wide net catch potentially interesting program behaviors branch predicates record direction branches predicates true false conditional program return predicates monitor sign function return values predicates negative positive function call site additional predicate schemes compare assigned variables nearby variables constants track behavior counts test programmerspecified assertions moderate-sized program easily hundreds thousands millions predicates injected automatically cbi instrumenting compiler cbi sparse random sampling instrumentation sites performance overhead low spreading performance cost thinly large number end users fair statistically rigorous sense aggregate sampled behavior representative true complete program behavior users runs addition predicates collected run strong predictive power moderate-sized program million distinct predicates dozen failure debugging support cbi collects feedback report run identifies run successful failed crashed number times predicate observed true collection reports cbi applies set statistical debugging techniques generate ranked list bug predictors predicates strongly program failures bug predictor assigned numerical score balances key factors predictor increases probability failure failed runs predictor accounts high-value predictors warrant close examination highly correlated failure account large portion failure rate end users bug predictor list helps human programmer identify reproduce ultimately fix bug provide direct correspondence predictor list bug initial bug predictor list clustered lists distinct failure scenarios grouping predictors behave similarly high-ranked predictors single bug predictor list direct failure lower-ranked predictors list program behaviors strongly kind failure programmer understand circumstances bug appears failure paths predicates sampled entire dynamic lifetime run reveal suspect behaviors precede actual point failure common case memory corruption bugs bad operation trashed heap occurred long eventual crash inside malloc ability make observations entire run strength cbi make interpreting bug predictors challenging programmer forward backward time earlier events caused predictor true consequences predictor true contrasts task interpreting postmortem stack trace future events considers past behavior led program terminal state reason important join isolated bug predictors extended failure paths btrace system lets reconstruct path start halt hits high-ranked bug predictors working single bug predictor path helps guide programmer attention forward backward time critical point bug predictors relate failure scenario feasible path touches programmer draw connections seemingly unrelated sections code act concert bring program evaluation implemented btrace wpds library manage exponential complexity number bug predictors abstract decision diagrams adds efficiently encode weights appendix additional details semiring operations implemented adds cudd library manipulating adds cbi instrumenting compiler cfg instrumented program handle indirect function calls general represent instrumented portion multi-component system btrace debugging session starts list related bug predictors believed cbi represent single bug designate list high-ranked prefix thereof critical nodes insert locations cfg branch predictors treated special case predictors associate direction conditional failure repositioned branch conditional form cbi reports false predictive failure point bug predictor moved node branch conditional exploiting location semantic meaning bug predictor branch predicates make easy semantic meaning directly corresponds control flow optimization compress original program cfg basic blocks converting wpds basic block connected part cfg unique entry exit nodes nodes inside connected single straight-line path weight pushdown rule arrowhookleft computed len set bug predictors inside basic block len number nodes inside obtained taking extend dataflow weights nodes wpds accurate model cfg path visits node basic block forced visit nodes basic block provided stop inside failure site basic block joined nodes requires identify failure site constructing wpds extract information cbi feedback reports dataflow analysis track integerand pointer-valued variables structure fields track contents memory write memory pointer replaced non-deterministic assignments variables address direct structure assignments expanded component-wise assignments fields structure dataflow btrace seeks shortest path procedure bug predictors experience add usefulness path programmer understands code equipped judge effect executing procedure shortest path tells addition extra edges cfg skip calls figure extra edges node node node giving btrace option bypass valuable bug predictors reached entering case studies siemens suite applied btrace buggy programs siemens test suite replace tcas print tokens programs crash produce incorrect output analysis performed stack trace treating exit main failure point find btrace non-fatal bugs tcas array index error one-line function cbi instrumentation easily overlooked bug predictors btrace produces shortest path exits main revealing bug adding top-ranked predictor btrace isolates lines calls buggy function replace incorrect function return btrace top predictors yields path faulty statement predictor located disjoint chains function calls invoked main falls function bug isolated predictors directly reveal bug btrace failure path predictors print tokens off-by-one error predictors suffice steer btrace faulty line repositioning branch predictors critical nineteen cbi-suggested predictors dataflow analysis enabled correct failure path results branch predictors repositioned steer path proper direction case studies ccrypt run btrace small open source utilities ccrypt ccrypt encryption decryption tool arbitrary precision calculator written fatal bugs characterized prior work liblit sections illustrate btrace typical debugging support role section considers performance trends case studies ccrypt ccrypt input validation bug function prompt char pointer returned xreadline dereferenced checked xreadline returns null caller prompt failure cbi identifies ranked 
lists bug predictors suggesting distinct bugs lists includes returning null xreadline eleventh strongest bug predictor related behaviors procedure higher ranked predictors present experience btrace bug predictor list scenarios case valid stack trace cbi feedback reports scenario turn dataflow weight domain definition path returned btrace bug predictors null returned xreadline dereferenced prompt adding higher ranked predictors change path significantly interesting observation add bug predictors btrace finds path suggests stack trace crash site fairly good indication bug btrace produce path illustrates bug path returns null xreadline shortest path function path bug infeasible procedure xreadline called initialization routines main check return xreadline gracefully terminate program null path obtained btrace returns null calls xreadline incorrectly takes wrong branch checks main suggests dataflow analysis user intuition correct path initialization routines rarely bug user insert ordering constraint forces btrace hit bug predictors xreadline bug predictor matter initialization code corrects infeasibility path scenario turn dataflow obtain change path till include eleventh predictor reason dataflow analysis distributive code xreadline shown figure dataflow analysis summarizes return xreadline non-constant null line non-null line values combined insert eleventh predictor line node branch return summarized eleventh predictor hit null hit path correctly avoids returning null xreadline point return checked called procedure prompt manual modifications needed ccrypt code prevent cbi instrumenting compiler fooling conditional-weight placement tracking branches instrumenting compiler rewrites simple conditionals complex form modeled btrace implementation char xreadline file fin char myname int buflen initsize char buf xalloc buflen myname char res res fgets buf initsize fin res null free buf return null strchr buf return buf figure code procedure xreadline ccrypt main yyparse init storage arrays strcpyof malloc predictor main yyparse lookup arrays strcpyof malloc predictors figure summaries paths returned btrace boxes show procedures path visits edge labels show order calls returns buffer overrun function arrays function allocates memory array wrong loop bound walk array null elements program eventually crashes subsequent call malloc stack point failure unfinished calls main yyparse strcpyof malloc order presence malloc suggests heap corruption stack real clues corruption occurred piece code statistical debugging analysis cbi identifies suspect program behaviors predictors scattered files relationship clear examination typical debugging session suppose find bug represented cbi bug predictor lists feedback reports include valid stack trace require btrace find paths ending stack configuration btrace hit single top-ranked bug predictor found arrays figure summarizes resulting path path shows call main init storage arrays touches desired bug predictor execution continues set additional calls yyparse strcpyof malloc leave stack desired final configuration path questionable cursory examination code data mining applied cbi feedback reports shows arrays called initialization time initialization code correct disregard call arrays ways reaching bug predictor insert zero-score bug predictor return-site init storage ordering constraint bug predictor arrays visited predictor init storage restrictions btrace path shown figure btrace bypasses init storage time deeming irrelevant bug revised path informative arrays called init storage subsequent call lookup spells trouble additional predictors show btrace top predictors directly produces path figure ordering constraints special intervention user top predictor arrays predictor lookup conditionally calls arrays btrace hits predictors single excursion yyparse benefit hitting predictor reason include call init storage arrays figure btrace correctly bypasses entire call showing direct failure path figure steering programmer irrelevant code path remains unchanged increase number bug predictors additional predictors syntactically close touched path figure ninth bug predictors scores suggesting low relevance include reconstructed failure path alternate predictor lists cbi produces ranked lists related bug predictors suggesting distinct bugs run btrace single top predictor list reconstructed failure path twelve additional predictors leave path unchanged path slightly predictor list homogeneous arrays code dominating upper ranks paths hit hit tendency btrace produce identical similar paths lists suggests correspond single bug spite cbi conclusions contrary correct lists correspond single bug cbi confused sampling noise statistical approximation incompleteness dynamic data factors btrace check cbi letting unify equivalent bug lists cbi incorrectly held finding emphasizes spreading predictors widely application greater heterogeneity cbi predictor list helps btrace produce correct path fewer predictors list unavailability stack trace terminal state system outstanding calls main yyparse strcpyof malloc matches stack trace reported cbi btrace path constraint critical bug predictors lookup arrays stack calls completed damage long actual crash full btrace path neatly integrates terminal stack trace high-value bug predictors reported cbi shows short execution trace consistent key pieces evidence stack trace buffer overruns memory corruption bugs scramble stack leaving current program counter point failure give btrace failure location malloc information stack resultant paths change slightly critical call sequence lookup arrays remains hitting high-valued predictors functions btrace simply takes shortest path find call malloc optimal path consistent evidence fact call lookup arrays preserved means path remains informative performance figure appearing shows analysis performance bug predictors selected predictor list measurements collected ghz athlon amd processor ram total time split key phases algorithm creating initial wpds solving generalized pushdown successor gps problem extracting witness path solved system expected gps phase dominates predictors takes time increase gradual recall predictor list fairly homogeneous yields paths vary predictors path produced predictors performance slope figure primarily due adding bug predictors factors held constant section showed solving wpds require time exponential number predictors time seconds create wpds solve gps extract witness path predictor list number predictors time seconds create wpds solve gps extract witness path predictor list figure btrace performance varying numbers predictors number bug predictors find actual slowdown gradual absolute performance btrace good figure appearing left shows similar performance profile gradual slowdown predictors represents cost adding bug predictors change result path result path grows larger predictors fourteen analysis time increases practice total length result path significant performance factor number critical nodes visited recall ninth predicates cbi-assigned scores suggests longer paths requested btrace user realistic bug predictor counts entire analysis completes seconds cfg nodes typical failure path produced btrace nodes long ccrypt significantly smaller cfg nodes typical failure path btrace requires seconds find path ccrypt predictors increasing gradually seconds fifteen predictors predictors slow analysis gradually longer failure paths larger effect adding dataflow slows analysis factor twelve depending details configuration analysis dataflow realistic numbers bug predictors takes thirteen seconds seconds ccrypt 
related work path inspector tool makes similar weighted pushdown systems makes wpdss verification program drive automaton summarizing program property bad state witnesses produce program path dataflow analyses encoding weights rule infeasible paths wpdss optimization previously explored liblit aiken directly problem finding failure paths program present family analysis techniques exploit dynamic information failure sites stack traces event logs construct set paths program optimize path length number events touched unreachable single path approach general btrace incorporates techniques dataflow analysis unifying framework weighted pushdown systems difference event logs output cbi guide path-finding analysis theory presented section extended incorporate event logs adding ordering constraints appropriately restrict order events visited path pse practical tool finding failing paths requires userprovided description error occurred pointer assigned null dereferenced description form finite state automaton problem finding failing run reduced finding backward path drives automaton error state initial state tool solves presence pointer-based data structures aliasing work require user description bug caused crash handle pointer-based structures work compared dynamic slicing concerned identifying relevant program statements affected variable point program execution static information program reduce runtime overhead dynamic slicing cbi extract small amounts dynamic information program run static analysis piece information find path program recent work zeller technique called delta debugging find cause-effect chain program events leads failure exercises fine-grained control program execution including backwards execution find cause-effect chain definitions define semirings power set values associate path approach presented general setting lengauer theune power set operation add distributivity semiring reduction function reduce ensures form sets elements conclusions future work presented static analysis technique build btrace tool find optimal path program constraints imposed user bug predictors produced cbi btrace perform postmortem analysis program reconstruct program path reveals circumstances failure paths produced btrace feasible intend programmers understand bug predictors produced cbi locate bugs quickly btrace user options supply additional constraints form stack traces ordering constraints user guide tool interactively locating bug summary experiments required prove utility btrace debugging software initial results promising future work evaluate benefit dataflow analysis improving quality path returned btrace interpret dataflow information provided bug predictors bug predictor information restrict path hits predictor open area design incremental algorithms weighted pushdown systems recompute solution time user makes small change optimization problem adding bug predictors ordering constraints fly incremental algorithms exist development substantially improve interactivity integrated btrace bug hunting system agrawal demillo spafford debugging dynamic slicing backtracking software practice experience june aho sethi ullman compilers principles techniques tools addison-wesley balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds computer aided verfication bouajjani esparza touili generic approach static analysis concurrent programs procedures symp princ prog lang pages bryant graph-based algorithms boolean function manipulation ieee trans computers das lerner seigle esp path-sensitive program verification polynomial time sigplan conf prog lang design impl pages grammatech codesurfer path inspector http grammatech products codesurfer overview html gupta soffa howard hybrid slicing integrating dynamic information static analysis acm transactions software engineering methodology oct hutchins foster goradia ostrand experiments effectiveness dataflowand control-flow-based test adequacy criteria proc int conf softw eng pages ieee computer society press inoue jihira nishimatsu kusumoto call-mark slicing efficient economical reducing slices proc int conf softw eng pages acm press kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds korel laski dynamic program slicing information processing letters oct lal reps balakrishnan extended weighted pushdown systems computer aided verification pages lengauer theune unstructured path problems making semirings preliminary version wads volume lecture notes computer science pages springer liblit cooperative bug isolation phd thesis california berkeley dec liblit aiken building backtrace techniques postmortem program analysis technical report csd- california berkeley oct liblit aiken zheng jordan bug isolation remote program sampling sigplan conf prog lang design impl liblit naik zheng aiken jordan scalable statistical bug isolation sigplan conf prog lang design impl manevich sridharan adams das yang pse explaining program failures postmortem static analysis found softw eng pages ller-olm thing complexity constant propagation european symp programming pages ller-olm seidl precise interprocedural analysis linear algebra symp princ prog lang ller-olm seidl analysis modular arithmetic european symp programming reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog volume pages sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci somenzi colorado decision diagram package technical report colorado boulder wegman zadeck constant propagation conditional branches symp princ prog lang pages zeller isolating cause-effect chains computer programs found softw eng pages implementation details worst-case running time analysis exponential number critical nodes part complexity due expensive operations weights definition reason represent weight semiring abstract decision diagram add add variant binary decision diagrams represent multi-valued functions boolean variables number critical nodes boolean variables set weight represented function braceleftbigg set similar bdds adds canonical representations function unique representation advantage compactness representations combine extend operations weights computed write denote function function recursive computing combine extend weights time proportional product sizes add representations base case recursion applying operations constant-valued functions min presence ordering constraints extend operation complicated suppose list constraints constraint pair representing node visited node denote list constraint extend weights list constraints written recursively computed 
sampling user executions bug isolation ben liblit alex aiken alice zheng michael jordan liblit aiken alicez jordan berkeley department electrical engineering computer science california berkeley berkeley introduction computer scientists program correct meets specification incorrect meet specification industrial software development economics computer science software quality monetary balancing act engineers salaries time market user expectations business concerns ship software correct embarrass alienate users ship software bugs worth fixing users uncover bugs imagined practitioners boolean notion correctness notion difficult quantify in-house testing guess field usage patterns poor guesses leave users bad shape obscure low-priority bug difficult reproduce testing lab turn affect large numbers users regular basis technical support channels provide post-deployment feedback reach engineers traditionally mechanisms informal overly dependent human intervention widespread internet connectivity makes radical change situation time feasible directly observe reality software system deployment sheer numbers user community brings resources bear exercising piece software possibly provided software authors coupled instrumentation reporting infrastructure users potentially replace guesswork real triage directing scarce engineering resources areas benefit people distributed bug hunting ways remote software monitoring interest bug hunting tools industry critics software vendors treat customers beta testers thousands millions testers effectively traditionally software failures produce grumpy user diagnostic feedback benefits recently automatic crash reporting systems created reverse problem developers overwhelmed bug reports redundant prioritize work terms bug fixes provide greatest net benefit shortest amount time writing bugzilla bug tracking database open source mozilla web browser project shows open bugs additional marked duplicates bugs reported mozilla augments manual bug reporting automated crash feedback system system shows automated crash reports ten day period accounting hours testing end users microsoft watson error reporting service collected crash reports half million separate programs experience watson shown percent software errors fifty percent user crashes high level redundancy suggests great potential harness user community distributed brute force bug hunting resource important bugs happen users trace program behavior complete invasive perfectly controlled manner lightweight instrumentation sample small amount information run merge information form aggregate picture software working failing field feedback loop flow directions aggregate error reporting direct engineers bugs engineers steer instrumentation code regions interest based observed failure trends system solve critical problems monitoring continuous instrumentation sufficiently lightweight negligible impact performance user program data collection strategy respect resource limits domains including client user storage server storage client-to-server network bandwidth instrumentation plan analysis collected data draw probable conclusions partial results progressively stronger inferences feedback data accumulates time assume complete information single run runs identical sections follow describe ongoing research address areas section describes program transformation produces fair randomized subset underlying instrumentation strategy section couple sampled instrumentation statistical analysis based logistic regression isolate buffer overrun bug fair random sampling set interesting program behaviors impractical observe instances behaviors runs times pilot study instrumented command line calculator tool trace values syntactic assignments processing megabytes random input average run lasts seconds discounting instrumentation overhead yields assignment events word identify location assignment word data rate require full internet links mbps stream single report feedback collection host traces buffered locally overhead imposed aggressive instrumentation impose unacceptable performance penalty running client application sample sparse subset behavior statistically fair randomized manner body code fragments designated instrumentation execute instrumentation fragments subset times reached users build realistic aggregate view keeping sampling density low individual user experience negligible instrumentation overhead reporting sampled event individually fold continuous event stream finite collection event counters client application counters represent compact trace summary reported analyzed program completion strategy similar arnold ryder lightweight performance profiling refinements ensure samples random sense bernoulli process instrumentation fragment equal chance executed decision made dynamically independently instrumentation opportunity program executes tossing don sample coin instrumentation site inefficient instrumentation lightweight program compilation time identify acyclic regions control flow graph function top acyclic region finite number paths forward reach back edge path finite number instrumentation sites entire acyclic region finite maximum instrumentation weight run time compute sequence random numbers geometric distribution geometrically distributed numbers give inter-arrival time events bernoulli process geometric random sequence tells instrumentation sites skip taking sample sampling density geometrically distributed number serves countdown relative instrumentation weights computed earlier sample countdown reach top acyclic region maximum instrumentation weight sample pass region skipping instrumentation fragment individually jump directly fast version code instrumentation removed fast code decrement countdown based actual path sampling sparse common case execution incur instrumentation overhead topof-region counter checks fast-path counter decrements opportunities exist refining sampling framework including interprocedural analyses identify larger acyclic regions implementation strategies compiler optimize countdown management fast path additional details preliminary experimental results published statistical debugging section discuss approach information collect isolate bugs program crash framework limits perclient overhead captures sampled subset behavior crash observed violation caused strict implications assertion failed crash interested finding statistical trends assertion hold program succeeds fail program fails important clue human programmer find reproduce fix bug approach injects instrumentation guesses ordering relationships pointer integer variables programs loosely style daikon direct scalar assignment identify same-typed variables simultaneously scope pair compiler inserts set comparisons determine assigned equal greater wild guesses include comparisons variables completely unrelated fixed relationship runs capture important relationships directly relate bug array bounds overrun appears pair variables index max index max successful runs index occasionally observed greater max failed runs recording result ordering comparison yield stream samples grows rapidly program executes exceed reasonable constraints storage network bandwidth instrumentation maintains triple counters comparison site tabulates number times observed equal greater counter triple considered sampling opportunity randomly updated skipped dynamically independently site thought simple client-side analysis applies summation reduction operator sample stream site ordering relation execution concludes counter values shipped feedback server single binary outcome failure failure pilot study full instrumentation command line calculator tool counters thirty bits interesting non-zero run sampling random input data easily fits modest storage communication resource limits hundreds thousands runs borrow techniques statistical analysis identify counters values strongly predictive program failure current approach logistic regression discriminative binary classification method linear regression fits straight line input features logistic regression s-shaped curve logistic function asymptotically approaches extreme case corresponds successful execution corresponds failure input features sampled counters coefficient assigned feature weighs relative importance feature predicting program failure model trained stochastic gradient ascent 
reach local maximum log likelihood penalty factor based -norm feature weight coefficients features runs features wild guesses irrelevant penalty factor exerts downward pressure forcing feature weights leaving small number highly relevant predictors initial experience system encouraging simulate large user community running random input data megabytes random input crashes roughly time stack traces show failed utility routine malloc suggesting heap corruption runs density train -regularized logistic regression model top ranked features largest coefficients form group well-separated magnitude rest strongly predictive features correspond instrumentation single line single function lines complete program line top loop counters correspond updates loop index function performing nontrivial memory management features correspond greater-than counters suggesting failure occurs loop index unusually large inspection suspect line quickly reveals loop wrong upper bound zeros newly allocated elements array causing run past element scribble zeros unmanaged memory hope specific invariant index exceed array length unique strong predictor -regularized logistic regression model feature model ranked reasons random noise inherent methodology sampling model training randomization crashing guaranteed program overrun buffer scribble memory crash lastly high degree redundancy instrumentation sites meaning statistical model features choose equivalent predictive power improving instrumentation scheme fine-tuning statistical analysis methodology key areas continued development performance impact sampled instrumentation reasonable sampling density runs slower instrumentation contrast unconditional instrumentation sampling incurs penalty sampling strategy large-scale distributed data collection wholly impractical full tracing details bug hunting experiment reported open problems techniques address challenges building distributed bug isolation system complete solution require study additional open problems note bug report bucketing challenge identifying failure reports represent multiple occurrences bug bug found fixed good bucketing scheme key assigning priorities basis approach exploits redundancy aggregate partial information multiple failure reports clustering algorithms machine learning applicable privacy security concerns social technological dimensions address technological facets techniques drawn secure information flow statically identify sensitive data revealed observers statistical models afford degree anonymity combine runs aggregate individual samples longer recovered adaptive refinement instrumentation based early results focus quickly targeted bugs deemphasizing code believed uninvolved combining statistical models conventional program analysis techniques make initial instrumentation plans refine plans rapidly approach conclusions suite instrumentation analysis techniques diagnosing bugs widely deployed software bug isolation begins continuous monitoring based fair sparsely sampled instrumentation statistical analysis based -regularized logistic regression builds predictive model identifies sampled features highly predictive subsequent program failure strengths user community twofold overwhelming numbers represent reality approaches designed goal leveraging strengths large user community means random sampling sparse turn control performance overhead simple reductions sampled data set client limit resource requirements allowing statistical analysis aggregate behavior logistic regression model grows progressively accurate trains data naturally adapt reflect common failures redundant failure reports benefit bug triage reflect real failure trends real users arnold ryder framework reducing cost instrumented code acm sigplan notices ernst cockrell griswold notkin dynamically discovering program invariants support program evolution ieee transactions software engineering feb hastie tibshirani friedman elements statistical learning stats springer liblit aiken zheng jordan bug isolation remote program sampling proceedings acm sigplan conference programming language design implementation san diego california june markoff microsoft reports progress averting computer crashes york times page oct mozilla mozilla bug database http bugzilla mozilla apr mozilla mozilla talkback crash data ftp ftp mozilla pub data crash-data apr zdancewic zheng nystrom myers untrusted hosts confidentiality secure program partitioning proceedings acm symposium operating systems principles sosp pages chateau lake louise banff alberta canada oct appeared acm operating systems review 
bug isolation remote program sampling ben liblit liblit berkeley alex aiken aiken berkeley alice zheng alicez berkeley michael jordan jordan berkeley department electrical engineering computer science department statistics california berkeley berkeley abstract propose low-overhead sampling infrastructure gathering information executions experienced program user community applications illustrate ways sampled instrumentation isolate bugs assertion-dense code transformed share cost assertions users lacking assertions broad guesses made predicates predict program errors process elimination whittle true bug finally non-deterministic bugs memory corruption statistical modeling based logistic regression identify program behaviors strongly correlated failure places error categories subject descriptors software engineering testing debugging distributed debugging mathematics computing probability statistics correlation regression analysis pattern recognition design methodology feature evaluation selection general terms experimentation performance reliability research supported part nasa grant nag nsf grant nos eiaccr- aciand iisdoe prime contract -engthrough memorandum agreement llnl lucent grpw fellowship information presented necessarily reflect position policy government official endorsement inferred permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee pldi june san diego california usa copyright acm keywords bug isolation random sampling assertions feature selection statistical debugging logistic regression introduction unfortunate fact essentially deployed software systems bugs users encounter bugs resources measured time money people improving software limited normal case sheer numbers user community brings resources bear testing piece software team responsible producing software paper making lemonade lemons deployed software problems speed process identifying eliminating problems learning enormous number executions performed software user community propose infrastructure information user execution program transmitted central database data gathered executions analyzed extract information helps engineers find fix problems quickly call automatic bug isolation view infrastructure benefits deployed software systems number executions actual dwarfs number executions produced testing orders magnitude software systems today essentially information user executions discarded mechanism feedback retaining small portion information valuable gathering information representative sample user executions accurate picture software allowing decisions spend scarce resources modifications bugs affect large number users higher priority bugs rare kind information impossible obtain actual user executions primary interest finding fixing quality problems information gathered user executions purposes software authors simply features commonly interested discovering code covered in-house testing executed practice traditional user feedback problems consists call unsophisticated user sophisticated technical support center networked world simply efficient accurate gather information automatically bugs sit open bug lists products extended period time engineer work bug automatically gathering data user executions automated analysis human intervention engineer finally work problem results automated analyses interim engineer identify fix simple problems quickly idea gathering data actual user executions commercial databases routinely produce extensive log files action user reports problem inspect logs similarly flight boeing generates logs subsequently combed signs problems similar examples world commercial software recent development result ubiquitous internet connectivity netscape mozilla microsoft gnome kde deployed automated opt-in crash reporting systems systems gather key information program state failure occurred stack trace register contents sending information back development organization user community helps developers effectively triage bugs crashes focus problems experienced users crash reporting progress direction existing approaches scratch surface developers users connected network crashreporting systems gather information happened crash trace information leading failure critical clues actual problem crash reporting systems report information successful runs makes difficult distinguish anomalous crash-causing behavior innocuous behavior common executions general information gathered crash-reporting systems systematic feedback systems aware crash-reporting subsequent data analysis highly manual present approach systematically gathering information program runs large distributed user community performing subsequent automatic analysis information isolating bugs initially believed interesting problem analysis data gathering data straightforward discovered designing data gathering infrastructure scale non-trivial result paper design implementation system gathers data user executions section subsequent data analysis section infrastructure designed gather information large number program executions taking place remotely central site data collected design solve problems problem method gathering information modest impact performance user program approach discussed section based sampling classical sampling measuring program performance searches elephant haystack biggest consumers time contrast needles bugs occur rarely sampling rates low maintain client performance leads concerned guaranteeing sampling statistically fair rely reported frequencies rare events develop ways reduce overhead additional code determines sample problem information client transmitted network central database gathering small amount data periodically large number clients creates significant scalability problems found discard information order program statements execute achieve sufficiently compact representations sampled data section section presents applications increasing sophistication show share cost program assertions large user base sampling user executes fraction assertions sees good performance aggregate bugs due assertion failures extremely detected section show isolate deterministic bugs benefit explicit assertions bug deterministic respect predicate true program guaranteed crash future point initially large set predicates hypothesized capture crash gradually reduced time sampled executions reveal predicates predict program failure section generalize approach isolation nondeterministic bugs bug non-deterministic respect set program predicates deterministic predicate set considered predicates perfectly predicts program crashes statistical regression techniques identify predicates highly correlated program failure section finally monitoring user executions raises privacy security concerns problems social technical discussion issues appears section sampling framework section describes sampling framework begin sampling basic blocks gradually add features describe perform sampling entire programs suppose start code check null check max total sizes sampling framework configured sample arbitrary pieces code portions original program instrumentation predicates added separately assume italicized check calls tagged sampling check call conditionally halt program assert append event trace stream update per-predicate counter record predicate true precise behavior instrumentation code concern sampling transformation sampling bernoulli suppose sample hundredth checks maintaining global counter modulo hundred simple disadvantage trivially periodic fragment loop checks execute fiftieth iteration execute sampling fair uniformly random check independently chance sampled time occurs so-called bernoulli process common repeatedly tossing coin sample based outcome tossing coin biased heads time hundred approach simple random number generator suppose rnd yields random integer uniformly distributed code fair random sampling desired density rnd check null rnd check max total sizes strategy practical problems random number generation free tossing coin slower simply check unconditionally previously straight-line code dense branches joins impede optimizations sampling sparse conditionals chance sampling run block chance instrumentation sites skipped 
determine reaching top basic block site block sampled branch fast-path code conditionallyguarded checks removed requires versions code sampled instrumentation requires predict future sampling opportunities skipped anticipating future samples requires change randomization strategy sequence biased coin tosses indicating sample indicating sample temporarily increasing sampling density bracehtipupleft bracehtipupright bracehtipupleft bracehtipupright bracehtipupleft bracehtipupright equivalent representation counts number tosses including sampled check representation predictive head sequence treated countdown telling sample top basic block checks sampling countdown advance sites sampled visit discard tosses proceed directly instrumentation-free fast path countdown fast path sample ahead countdown total sizes slow path sample imminent countdown-check null countdown getnextcountdown countdown-check max countdown getnextcountdown total sizes instrumented code extra work manage next-sample countdown fast path improved overhead single compare branch constant decrement overhead amortized entire block larger blocks instrumentation sites initial countdown check larger threshold check suffices predict larger number skipped sampling opportunities distribution countdown values sampling density chance sample opportunity chance skipped countdown appears chance numbers form geometric distribution inverse sampling density numbers geometric distribution characterize expected inter-arrival times bernoulli process repeated tossing biased coin geometrically distributed random numbers generated directly standard uniform random generator simple floating-point operations theory countdown arbitrarily large odds countdown exceeding instrumented slow path countdown reset reaches consume nextsample countdowns gradually time rate consumption slower raw coin tosses countdowns sampling encode average tosses bank pre-generated random countdowns reasonable exhaust repeat times slowly similar bank raw coin tosses blocks functions scheme blocks outlined generalizes arbitrary control flow graph region acyclic code finite number paths maximum number instrumented sites path region weight countdown threshold check top acyclic region next-sample countdown exceeds weight acyclic region entry samples execution cycle control-flow graph instrumentation weightless disregarded cycle instrumentation threshold check guarantees start threshold check execute forward cross finite number instrumentation sites reaching threshold check compute finite weight threshold check flexibility threshold check computing optimal solution np-hard simplicity present system places threshold check function entry loop back edge weights computed single bottomup traversal function control flow graph threshold check found weight simply discarded produce complete copies function body full instrumentation sample guarded decrement test next-sample countdown copy fast path decrements countdown instrumentation removed stitch variants threshold check points top acyclic region decide sample imminent branch instrumented code sample continue fast path code figure shows code layout function conditional loop dotted nodes represent instrumentation sites reduced countdown decrements fast path boxed nodes represent threshold checks added function entry back edge loop code layout strategy variation arnold ryder reduce cost code instrumented performance profiling principal change transformation geometrically distributed countdowns conjunction acyclic region weights choose code variants arnold ryder fixed sampling periods opportunities instructions apply region-specific weighting approach imposes overhead offers greater statistical rigor resultant sampled data arnold ryder studied variations trade-offs code size versus overhead choices apply function calls optimization opportunities arise presence function calls conservative treatment assumes function call countdown arbitrarily figure instrumented code layout threshold check immediately function call treatment callee compiled separately callee examination simple interprocedural analysis weightless function properties function instrumentation sites function calls weightless functions set weightless functions computed standard iterative algorithm purposes identifying acyclic regions placing threshold checks calls weightless functions invisible acyclic regions extend calls additional threshold check required call returns benefit bodies weightless functions compiled modifications threshold checks instrumented code require cloning transformation kind global countdown management initial experience suggests next-site countdown global variable expensive system implemented source-to-source transformation gcc native compiler find gcc treats countdown-decrements fast path poorly coalesce sequence decrements single countdown adjustment apparently stems conservative assumptions aliasing global variables efficient countdown management requires native compiler greater liberties optimizing decrements assist native compiler maintaining countdown local variable function function entry import current global countdown local variable thresholdchecks sampling decisions function exit export local copy back global maintain agreement functions export function call import call returns calls weightless functions simply change inspect countdown similarly bodies weightless functions import export entry exit leave countdown unchanged change conventional native compiler coalesce decrements perform standard important optimizations issues remote sampling framework statistically fair sampling program monitoring application discussed section issues peculiar monitoring large number remote sites briefly discuss main problems solution adopt usual performance penalty imposed extra monitoring code concern local storage hold results temporarily user machine network bandwidth transmit results finally storage needed hold results central server analysis retain sampled data storage requirements central server grow linearly number executions data collected execution constant size approach sample number observations large fixed set predicates sections final form data vector integers position number times observed ith predicate true typical entry predicate program point observed true times execution maintaining vector counters produces data execution size largely independent sampling density running time loss information significant order observations discarded results interpreted showing long ignoring ordering expect interesting applications require ordering information leave problem determining efficiently gather store analyze partial traces ordering information future work applications experiments outlined section report applications framework sophisticated sharing cost assertions users section isolating bug deterministic respect predicate section statistical regression techniques isolate bug non-deterministic respect considered predicate section application report overhead instrumentation applications quantify effectively efficiently bugs isolated bug isolation examples presented based finding bugs specific programs techniques general sharing cost assertions conventional usage assert calls program development disabled code ships boost performance deployed programs fail unanticipated ways helpful retain level assertion checking performance penalty excessive ccured translator analyzes programs written attempts prove pointer operations memory safe ccured inserts dynamic checks enforce memory safety run time purposes ccured simply source assertion-dense code individual assertions small fast array bounds checks testing null performance impact significant random sampling spread cost users applied sampling ccured versions olden specint benchmarks programs run completion simply measuring overhead performing dynamic checks whole-program sampling table summarizes static aspects sampling transformation applied entirety benchmark program give total number non-library functions number weightless ccured whole-program analysis weightless function identification advantage examine function body count number functions directly instrumentation site remainder functions sites call non-weightless functions functions directly instrumentation site table presents average number sites function average number threshold check points function average threshold weight points note product metrics exceed single instrumentation site fall threshold check point 
figure average site count shows density assertions code average threshold weight measures effective transformation amortizing cost countdown checks multiple sites single-site functions uncommon average threshold weight encouraging suggests amortization rates good table shows performance impact unconditional instrumentation sampled instrumentation densities baseline comparison code translated ccured dynamic memory safety checks removed report speedup slowdown relative baseline sampling denfunction counts average functions sitesbenchmark total weightless sites sites threshold checks threshold weight bisort health mst perimeter power treeadd tsp compress ijpeg table static metrics ccured benchmarks olden benchmarks listed specint benchmark bisort health mst perimeter power treeadd tsp compress ijpeg table relative performance ccured benchmarks unconditional sampled instrumentation italics marks cases sampled instrumentation outperforms unconditional instrumentation sities benchmarks compiled gcc optimization level times collected ghz pentium linux workstation megabytes ram reported speedups represent average runs run pre-generated bank geometrically distributed random countdowns unconditional instrumentation imposes slowdowns vary widely health ijpeg morethantwo thirds benchmarks run faster checks performed single check small fast suggests successful amortizing sampling overhead hand benchmarks run slower showing largest penalty cases time recovered skipping checks mask added overhead sampling benchmarks overhead relative instrumentation-free code remains large benchmarks slowdown performance improves reduce sampling density benchmarks suffer penalty relative uninstrumented code half reducing sampling density shows change time reach clear reached performance floor benchmarks perimeter tsp unable compensate samplingoverhead relative tation remaining ten run faster benchmarks treeadd compress retain high overhead relative instrumentation-free code cases penalty modest benchmarks perform sampling ijpeg moves unconditional instrumentation overhead sparse sampling statically selective sampling put instrumentation single executable easily create multiple executables subset complete instrumentation partitioning instrumentation site module function object file reasonable schemes individual executable instrumentation incurs smaller performance penalty fewer sites weightless functions interprocedural optimization section functions instrumentation sites require code duplication limits executable growth trusted code exempted instrumentation suspect code farmed larger proportion users intensive study suitable dynamic instrumentation infrastructure sites added removed time debugging intermediate results warrant experimented variants ccured benchmarks single function instrumented time fully instrumented executables range larger non-sampling counterparts average growth single-function instrumented executables small olden benchmarks larger specint applications performance uniformly good sampling site-containing functions incur slowdown versus instrumentationfree code worst single function penalty effectiveness sampling benchmarks examples sections conclude realistic deployments sampling densities effective sampling observing rare program behavior suppose interested event occurring hundred executions achieve confidence observing event run log log parenleftbigg parenrightbigg runs large number sixty million office licenses sold year market assuming licensee runs microsoft word week user base produces runs nineteen minutes achieving confidence observing event occurs thousand runs requires runs takes hours gather smaller deployments wait longer sufficient data increase sampling density sections restricted classes bugs perform analysis thousand executions techniques suited applications gather data sampling thousands executions day bug isolation predicate elimination section automatic isolation deterministic bugs recall section deterministic bug predicate true program crash point future deterministic bugs common generally easier find fix method non-deterministic bugs section instrumentation strategy case study finding deterministic bugs release ccrypt encryption tool version bug involves overwriting existing files user responds confirmation prompt eof ccrypt crashes eof sensitivity suggests problem ccrypt interactions standard file operations functions commonly return values success failure application programmers follow model error reporting randomly sampling function return values identify key operations behave differently successful versus crashed runs group function return values classes negative values positive values reduces amount information track making distinctions consistent common programming style instrument ccrypt syntactic call site returns scalar values including arithmetic types pointers call update counters depending sign result negative values zeros positive values call site triple counters program terminates examine function call interest call returned negative positive ccrypt call sites interest counters counter corresponds single predicate hypothesized behave differently successful versus crashed runs specifically pose problem assume predicates capture incorrect behavior assume predicate false correct execution true program fails deterministic bug increased risk failing nondeterministic bug eliminate predicates hypothesis disproved observed runtime behavior predicates remain describe conditions program fails elimination strategies make effort restrict instrumentation system library calls distinguish functions return status codes predicates bearing program success failure set runs discard irrelevant predicates set elimination strategies elimination universal falsehood disregard counter runs represent predicates true elimination lack failing coverage disregard triple counters failed runs counter triple true sample represent instrumentation sites reached failing executions elimination lack failing disregard counter failed runs represent predicates true failure occur elimination successful counterexample disregardany counter non-zero successful run represent predicates true subsequent program failure characterize strategies subject noise random sampling equally applicable bugs elimination successful counterexample assumes bug deterministic strategies make assumption require runs predicate true observed true note strategies independent universal falsehood lack failing coverage eliminate subset counters identified lack failing elimination strategies vary kinds runs exploit successful counterexample considers successful runs lack failing lack failing coverage failures universal falsehood data collection analysis function call update counters considered instrumentation site transform instrumentation sampled unconditional framework section lieu large user community generate runs artificially spirit fuzz project run randomly selected set present absent files randomized command line flags randomized responses ccrypt prompts including occasional eof collected trial runs sampling rate end crash applying elimination strategy independently counter traces universal falsehood discards counters runs leaving candidate predicates lack failing coverage discards counter triples crashes leaving candidate predicates lack failing discards counters crashes leaving candidate predicates successful counterexample discards counters non-zero successful run leaving candidate predicates glance elimination universal falsehood effective elimination successful counterexample poor strategies test disjoint properties combined good effect combination leaves predicates observed true failed runs observed true successful runs ccrypt trials predicates meet criterion traverse file exists return traverse xreadline return examining code shows predicates consistent circumstances bug reported occur call file exists returns output file exists confirmation prompt presented call xreadline returns user reply null input terminal eof inspection code immediately xreadline call shows programmer forgot check eof case assumes xreadline returns non-null string immediately inspects contents successfully isolated bug ccrypt fix clear file exists predicate bug fact appears list information represents condition crashes occur helpful engineer wishes reproduce bug in-house study runs file exists reports file exists xreadline returns valid response user program crash file 
exists call sampled run elimination successful counterexample correctly determines predicate imply failure eliminated consideration true smoking gun call xreadline remain ability identify direct bug related behaviors strongly imperfectly correlated failure explore idea broad correlation section buggy line code crash previously noted elimination strategies partially overlap successful counterexample distinct universal falsehood successful counterexample successful runs easily number successful trials number good features left figure progressive elimination successful counterexample successful runs accumulate crosses mark means error bars mark standard deviation analyzed lack failing general eliminates features good candidate combine successful counterexample case ccrypt leaves features general find results elimination lack failing coverage hand inherently weaker strategy combined successful counterexample left features refinement time order gain understanding elimination strategies benefit increasing number runs experimented randomized subsets complete run suite elimination successful counterexample effective thousand successful runs perform smaller suite start candidate predicates nonzero run assemble random subset fifty successful runs filter predicate set elimination successful counterexample add fifty runs fifty steps full set successful runs repeat entire process hundred times gauge rapidly expect predicate set shrink runs arrive time figure shows results crosses mark number predicates remaining vertical bars extend standard deviation short vertical bars case tells diversity hundred random subsets size results show average runs isolate twenty candidate features runs reduces count half total runs narrow set good features expect variety runs collected real users automated script greater diversity benefit analysis provide counterexamples eliminate uninteresting predicates rapidly performance impact instrumenting function return values confounds optimizations proposed section function calls instrumentation sites function calls terminate acyclic regions acyclic regions single site poor amortization sampling overhead ccrypt built object file time conservatively assume crossobject function call weightless ccrypt sampling transformation devolves simpler slower pattern checking next-sample countdown site spite performance impact sampled instrumentation minimal experimental setup similar earlier section find overhead sampling progressively sparser sampling rates shrink unconditional instrumentation performs making reasonable application section invasive instrumentation strategy requires sampling overhead control statistical debugging section automatic isolation nondeterministic bugs recall section bug nondeterministic respect set program predicates predicate set perfectly correlated program crashes case study version gnu implementation find feeding megabytes random input crash roughly time turns previously unknown buffer overrun error terminates successfully overruns buffer bug nondeterministic instrument variation previous strategyofcountertriples weabandoneliminationby successful counterexample favor statistical modeling identify behavior broadly correlated failure instrumentation strategy instrument guess randomly check large number predicates goal identify predicates capture bad behavior false program succeeds true program crashes cast extremely broad net eye pointer buffer errors pointers null pointers interest relative addresses pointers interesting capture cases pointer scans pointed-to buffer checking pointer pointer equality reveal aliasing anticipated programmer lead dangling wild pointer bugs scalar variables serve array indexes pointer offsets roles relationships scalars reveal buffer overruns unanticipated consequences negative values invalid enumeration constants variety problems direct assignment scalar variable identify local global variables scope type compare updated note bug non-deterministic runs predicates satisfy elimination successful counterexample equal greater compare pointers same-typed pointers additionally compare pointer equality null comparison bumps counters considered instrumentation site subject random sampling instrumented application terminates emits vector counter triples flag indicating completed successfully aborted fatal signal counter triples counters vast majority interest compare completely unrelated variables express relationships behave identically successful failed runs challenge find predicates matter crash prediction logistic regression find important predicates recast bug isolation statistical analysis problem run constitutes sample point consisting observed features counters binary outcome succeeded crashed numerous data points sampled runs identify subset features predict outcome equivalent machine learning problem learning binary classifier feature selection input features classification setting set data binary output training set attempt learn binary classifier good predictions test set learning process involves additional parameters values determined cross-validation set case end goal narrow set features method balance good classification performance aggressive feature selection binary classifier takes feature values inputs outputs prediction logistic regression method learning binary classifier output function assumed logistic logistic function continuous -shaped curve approaching end output interpreted probability measure data point falls class quantizing logistic function output binary classifier output greater data point classified class crash falls class successful run feature selection achieved regularizing function parameters ignore input features forcing form model predicts success failure small selection sampled features regularization important purposes expect features wild guesses correctly characterize bug techniques combined classification feature selection exist wellsuited problem methods calculate univariate correlation coefficient independently feature methods decision trees computationally intensive dataset features independent size problem potentially large computationally intensive methods logistic regression discriminative classification method make assumptions underlying distribution input crucial features arise decidedly artificial process difficult characterize simple distributions suppose training set consists data points denotes vector input predicate counters denotes output label learn good classifier maximize log likelihood training set msummationdisplay logp log output labels indicator functions terms summand logistic regression distribution modeled logistic function parameters exp logistic parameters respective roles intercept slope classifier essentially weigh relative importance feature final outcome expect input features influence success failure program place additional constraint forces accomplished subtracting penalty term based lscript norm bardbl bardbl summationtextmj tune importance regularization term regularization parameter penalized log likelihood function msummationdisplay log log bardbl bardbl assignment coefficients maximizes function represents model maximizes fidelity predictions limiting form predictions basis small number features complete feature set data collection analysis data set consists runs distinct random inputs distinct randomized sampling randomly chose runs training runs crossvalidation runs testing raw features discarded immediately elimination universal falsehood training set features effective number features training elimination lack failing eliminate features failed runs find presence absence features significantly affect quality regularized logistic regression results make magnitude parameters comparable feature values scale input features shifted scaled lie interval normalized unit sample variance suitable regularization parameter determined cross-validation model trained stochastic gradient ascent reach local maximum penalized log likelihood step size void arrays int indx int count var array ary char names save values count count ary arrays names names increment fixed amount allocate count store incr arrays var array malloc count names char malloc count sizeof copy arrays indx indx count indx arrays indx ary indx initialize elements indx count indx arrays indx null free elements count free 
ary free names figure suspect function arrays top-ranked crash-predicting features point large values indx line model converges sixty iterations training set takes roughly thirty minutes matlab ghz pentium cpu ram model trained predicates largest coefficients suggest begin bug case top ranked coefficients wellseparated magnitude rest show unmistakable trend storage arrays indx scale storage arrays indx math storage arrays indx opterr storage arrays indx func storage arrays indx base source code arrays appears figure comment earlier file suggests suite functions increasing number functions variables arrays needed logic fairly clear instance buffer reallocation idiom unfamiliar code line allocates larger chunk memory line top loop copies values smaller array line completes resize zeroing extra space comment suggests similar functions functions variables nearby largely thing storage pools text functions identical global variables count versus count versus count top ranked predicates bizarre examination variables relate real connection arrays scale tracks significant digits floating point calculations math records initial math library loaded crashes tend happen local variable indx exceeds seemingly unrelated globals line obvious hypothesis indx simply unusually large cases indx large tend larger number unrelated variables crashes occur input defines unusually large numbers arrays closer scrutiny arrays quickly reveals case allocation line requests space count items copying loop line ranges count zeroing loop line continues count count find bug storage buffer room count elements loop incorrectly bound count glimpse neighboring variables function clear arrays created copying pasting variables changing names count names count names loop bound line missed renaming logistic regression model points buggy line buggy variable reveals conditions bug appears found bug reasonable statistical analysis pointed directly mistaken count count line means buffer overrun occurs indx count line correspond predicate sampled system predicate ranked trained model smoking gun ranked reasons samples randomly model trained stochastic gradient ascent degree noise fundamental process crashing guaranteed runs sampling spotted indx count crash programs lucky meaning strict overrun crash implication manual inspection data reveals high degree redundancy instrumentation sites arrays meaning model features choose equivalent predictive power suggests counters fine-grained distinguishing behaviors fact tightly interrelated equivalent bug clear found present undiscovered time thatwecan find bugs obvious logistic regression results directed misbehaving variable line code lines approach automatically find fix bugs suggest start sort scenarios unusually large indx learning capabilities system interpret results statistically guided debugging potential make process finding fixing bugs efficient responsive end users sampling density relative performance figure relative performance unconditional sampled instrumentation performance impact instrumentation fairly dense leftmost bar figure shows instrumentation added sampling performance penalty sampling density cuts half density statistical debugging experiment penalty barely measurable lower densities show small unexpected speedups relative uninstrumented code apparently due effects relative code alignment cache behavior measurement noise unpredictable factors related work sampling long history applications focusing performance profiling optimization sampling system define trigger mechanism signals sample typical triggers include periodic hardware timers interrupts periodic software event counters nth function call cases sampling interval strictly periodic suffice hunting large performance bottlenecks systematically miss rare events digital continuous profiling infrastructure unusual choosing sampling intervals randomly random distribution uniform sample cycles samples extracted independent sample chance taking sample cycles chance taking sample cycles trigger samples based geometric distribution correctly models interval successful independent coin tosses resulting data statistically rigorous fair random sample turn grants access large domain powerful statistical analyses recent work trace collection focused program understanding techniques capturing program traces confront challenges similar face minimizing performance overhead managing large quantities captured data dynamic analysis encode compress reduce incoming trace stream real time program runs difficult directly adapt dynamic trace analysis techniques domain trace sampled incomplete effort understand debug programs selecting predicates partly inspired daikon daikon begin fairly unstructured guesses eliminate hold unlike daikon concerned gathering data production code leads sampling large number runs statistical models daikon experiments smaller number complete traces interested detecting bugs daikon focuses problem detecting program invariants diduce project attempts identify bugs analysis executions unlike daikon processing place client program study diduce attempts relate predicates manifestation bugs diduce performs complete tracing focuses discrete state time predicate transitioned true false approach probabilistic identify broad trends time correlate predicate violations increased likelihood failure software tomography realized gamma system shares goal low-overhead distributed monitoring deployed code applications date focused code coverage traditional performance monitoring tasks primary interest bug isolation privacy security noted section important program behaviors exhibited deployed software hands users scheme monitoring software postdeployment necessarily raises privacy security concerns issues complex social technical approach succeed users feel safe contributing shared data pool addressing concerns moral practical imperative experiences netscape mozilla crash feedback systems illustrative met members netscape talkback team group quality assurance engineers manage crash reports automated feedback system considerable effort designing client side system users fully informed system strictly opt-in per-failure basis disabled user optionally examine contents crash report information netscape explicit authorization figure shows sort information presented time netscape mozilla crash data submit users read understand assurances technical measures protect privacy non-technically savvy users nature sampling process affords degree anonymity collect small bit information users single run revelatory power data parts execution sensitive diffuse information leakage unacceptable type-based analyses broad heading secure information flow helpful systems statically identify parts program maniputhe netscape quality feedback agent feature gathers predefined technical information communicator sends back netscape software development team improve future versions communicator information examine information gathered agent limited information state communicator error sensitive information web sites visited messages addresses passwords profiles collected information netscape collects agent purposes fixing product defects improving quality netscape communicator data internal diagnostic purposes shared parties information netscape general privacy policy http home netscape legal notices privacy html communicator activates agent dialog box problem occurs gathered information netscape improve future versions communicator prefer disable agent figure privacy assurances netscape quality feedback agent late sensitive data avoid inserting instrumentation reveals values make difficult track bugs security-sensitive parts application trade-off present fix bugs customer provide information statistical models section attractive mechanism protecting user anonymity statistical analyses characterized set sufficient statistics collection values completely capture internal state analysis wanted compute stream numbers running total count sufficient statistics computed retaining individual numbers stream similarly logistic regression 
parameters updated trace trace discarded analysis host compromised attacker recover precise details single past trace statistical approach designed cope noise offers protection malicious users poison central database bogus data overwhelm data representing bugs fixed recent work protecting privacy preventing abuse collaborative filtering systems applicable conclusions sampling infrastructure gathering information software set runs produced user community ensure rare events accurately represented bernoulli process sampling efficient implementation process presented sample applications sharing overhead assertions predicate guessing elimination isolate deterministic bug regularized logistic regression isolate non-deterministic memory corruption error anderson berc dean ghemawat henzinger leung sites vandevoorde waldspurger weihl continuous profiling cycles acm transactions computer systems nov arnold ryder framework reducing cost instrumented code acm sigplan notices arnold sweeney approximating calling context tree sampling research report ibm watson research center yorktown heights york july association computing machinery proceedings international conference software engineering buenos aires argentina bowring orso harrold monitoring deployed software software tomography dwyer editor proceedings acm sigplan-sigsoft workshop program analysis software tools engineering pastevolume software engineering notes pages acm press breiman friedman olshen stone classification regression trees statistics probability series wadsworth publishing company belmont california broadwell harren sastry scrash system generating secure crash information proceedings usenix security symposium washington aug burrows erlingson leung vandevoorde waldspurger walker weihl efficient flexible sampling acm sigplan notices nov canny collaborative filtering privacy proceedings ieee symposium research security privacy pages oakland ieee computer society technical committee security privacy ieee computer society press carlisle olden parallelizing programs dynamic data structures distributed-memory machines phd thesis department computer science princeton june dellarocas immunizing online reputation reporting systems unfair ratings discriminatory behavior proceedings acm conference electronic commerce ecpages acm demsky rinard role-based exploration object-oriented programs proceedings international conference software engineering ernst cockrell griswold notkin dynamically discovering program invariants support program evolution ieee transactions software engineering feb esler virtual ramp overhaul maintenance vii mar golub slonim tamayo huard gaasenbeek mesirov coller loh downing caligiuri bloomfield lander molecular classification cancer class discovery class prediction gene expression monitoring science hangal lam tracking software bugs automatic anomaly detection proceedings international conference software engineering pages hastie tibshirani friedman elements statistical learning stats springer hirzel chilimbi bursty tracing framework low-overhead temporal profiling acm workshop feedback-directed dynamic optimization austin texas dec microsoft corp microsoft annual report form http microsoft msft redmond washington miller koski lee maganty murthy natarajan steidl fuzz revisited re-examination reliability unix utilities services technical report computer science department wisconsin madison necula mcpeak weimer ccured type-safe retrofitting legacy code norris james fenwick editors proceedings acm sigplan-sigact symposium principles programming languages poplvolume acm sigplan notices pages acm press reiss renieris encoding program executions proceedings international conference software engeneering icsepages ieee computer society spec standard performance evaluation corporation benchmarks http spec osg cpu cint july tibshirani hastie narasimhan chu diagnosis multiple cancer types shrunken centroids gene expression pnas traub schechter smith ephemeral instrumentation lightweight program profiling unpublished technical report department electrical engineering computer science hardward cambridge massachusetts june volpano smith type-based approach program security bidoit dauchet editors tapsoft theory practice software development volume lecture notes computer science pages springer-verlag whaley portable sampling-based profiler java virtual machines proceedings acm conference java grande pages acm press zdancewic zheng nystrom myers untrusted hosts confidentiality secure program partitioning proceedings acm symposium operating systems principles sosp pages chateau lake louise banff alberta canada oct appeared acm operating systems review 
type systems distributed data sharing star ben liblit alex aiken katherine yelick california berkeley berkeley abstract parallel programming languages multiple processors access shared data provide variety sharing mechanisms memory models understanding language support data sharing behavior critical understanding language component numerous program analysis optimization runtime clients languages provide illusion global address space intended work machines physically distributed memory distinguish kinds pointers shared data result subtle rules kinds accesses allowed application programs implicit constraints language implemented paper develops basis understanding design space sharing formalisms codifies understanding suite type checking inference systems illustrate trade-offs models introduction parallel distributed multithreaded computing environments increasingly important systems remain difficult reason data sharing ability multiple threads hold object source difficulty programming languages java titanium upc offer facilities sharing data vary subtle implicit semantically significant ways type-based approach characterizing data sharing distributed programming environments paper makes principal contributions show essential difference distributed pointers local address space global address spaces patterns access data private processor shared processors section earlier efforts distinguished concepts section show notion data sharing sharing models captured suite type systems sections show type qualifier inference automatically add detailed sharing information unannotated program approach realistic distributed programming languages section star research supported part nasa nag nsf eiaccr- acidoe de-fc ndseg fellowship information presented necessarily reflect position policy government official endorsement inferred integer literal shared private program variable function widen transmit fig common grammar expressions report results adding sharing inference real compiler parallel language highlights strengths approach present unexpected results effect underlying memory consistency model program performance experience area independent interest section background parallel applications distributed address space distinct notions data pointer local global object private shared previous work brought distinction ideas section primary thesis separate concepts section explains ideas distinct figure introduces small data manipulation language pointers pairs language extends liblit aiken features capture data sharing behavior sake brevity omit detailed formal semantics soundness proof semantics unchanged prior work extensions serve restrict programs admitted type system changing accepted programs behave run time soundness addressed briefly close section straightforward adaptation complete proof previously published related system base expression integer literal named variable predefined environment function calls similarly assume function predefined sequencing operator ordered evaluation language facilities defining functions types recursion features unnecessary exposition techniques readily extend realistic languages purposes essential aspects language data structures modeled pairs pointers data combined pairs unboxed held directly flat-structured intervening levels indirection unboxed pairs integers stored memory allocation operators return boxed values stored local processor memory allocation local processor subscript states boxed shared private informally private accessed processor allocated private produces pointer private memory cell holding pair contrast shared values examined manipulated multiple processors entire system holds private unboxed pair pair selection operator accepts pointer boxed pair produces offset pointer component pair holds private yields pointer component boxed pair yields unboxed left operand assignment pointer memory location named pointer left explicit treatment boxing offset pointers model update components data structures expression private modifies allocated pair remaining constructs model distributed memory systems allocation local produces local pointer local pointer names memory local single processor corresponds practice simple memory address make sense transfer local pointers processors global pointer names location entire distributed system akin processor address pair processor uniquely identifies processor complete distributed system address memory address processor local address space local pointers preferred data local global pointers larger slower widen operator widen coercions local global pointers clarity make coercions explicit practice coercions inserted automatically compiler transmission operator transmit models sending machine transmission implicitly dereference pointers serialize interlinked data structures evaluates unboxed tuple components tuple evaluates pointer single pointer pointed-to data intentionally leave communication semantics unspecified transmit correspond network broadcast remote procedure invocation cross-machine data exchange important invariant transmit produce representation safely remote processors reason typical transmit widened values transmitting local pointer widening forbidden local pointer meaningless originating processor representation versus sharing expression private referent supposed private processor access pointers including cheaper local pointer representation single-threaded program data local private transmit widen shared declared shared global pointer transmitted remote processor processors stored variable transmit broadcasts computed processor running processor receives pointer processor stores instance variable remote processor global pointer piece shared data finally minor variation shared transmit widen global pointer points shared data points shared data processor local pointer shared data case distinguisheslocal globalfromshared private distinction local global determines representation pointers shared private determines data illustrated examples local pointer point shared private data local pointer concurrent access processors whilelocal globalis distinct fromshared private concepts orthogonal global pointers private data problematic processor hold pointer data supposed private processor show section multiple answers question sharing information sections show statically determine data private single processor versus shared multiple processors information support number clients autonomous garbage collection reclaim private data strictly local operation coordinating processors data location management important hardware constraints make shared memory limited resource cache coherence overhead avoided private data processor sees race condition detection races private data program algorithm documentation augmented compiler validation programmers claims consistency model relaxation aggressive optimizations data processors synchronization elimination boosts performance private monitors contention security mandates careful treatment private data distributed systems mutual trust clients depends identifying data accessed processor typically processor local memory data lives data accessed local pointers local pointers suffice possibility global pointer alias location data referenced local pointers transitive reachability concern global pointer local pointer local pointer memory cell accessed remote processor sequence dereference operations widen local pointers global dereference int boxed local global shared mixed private grammar types shared mixed private mixed boxed boxed prime prime prime prime prime prime subtyping relations fig common properties type systems pointer representations data sharing patterns trivially deduced section show clients autonomous security require stronger privacy guarantees suggests solution based single definition privacy family alternatives client select type systems figure presents types subtyping relation subsections basic types unboxed integers int unboxed pairs pointers boxed values type carry qualifiers range local global shared mixed private local pointer widened equivalent global pointer local global pointers distinct physical representations manipulated machine-level operations widening coercion subtyping relation widen included explicit operator language figure hand sharing qualifiers dictate remote operations permissible forbidden general shared 
private pointers identical physical representation manipulated allowed identical machine-level operations coercion simplistic subtyping shared private pointers shared pointers functionality private pointers widened global distance private pointers unique functionality admit aggressive optimization violate language invariants observed remote processors sound type system ensure sharing qualifiers consistent aliasing local global pointers address location simultaneously location considered shared private good reasons code operates shared private data type object constructor java-like language observed earlier coercion private shared shared private shared constructor called construct private object private shared object built constructor class ultimately calls object restrictions introduced affect entire system reuse constructor code requires polymorphism find section basic utility code reused contexts imposes similar requirements type system paper subtyping polymorphism mixed sharing qualifier mixed datum shared private code manipulates mixed data ways sound subtyping relation defined figure note subtyping cross pointers restriction avoid well-known unsoundness problems result subtyping updatable late enforcement define private read written remote processor global pointers private data freely created dereferenced section presents late enforcement system typing judgments turnstileleft read environment provable expression type auxiliary expand pop functions defined figure describe types transformed constrained widening cross-processor communication observe type expansion recursively descends pairs crosses pointers expand directly communicated processor boundaries integers global pointers local pointers expand global topmost level type expand banned appearing expanding pairs pop global pointers general larger local pointers expanding local pointers global pointers inside pair change size layout pair undesirable practice languages named structure type class single consistent layout alternative deep local pointers remain size mark invalid remote processor possibility explored greater detail omitted simplicity types integers variables function applications completely standard sequencing pair construction subtyping typical manner turnstileleft int turnstileleft prime turnstileleft turnstileleft prime turnstileleft turnstileleft eprime prime turnstileleft eprime prime turnstileleft turnstileleft turnstileleft turnstileleft prime turnstileleft prime shared private allocation creates appropriately qualified local pointer alternative parametric polymorphism expressive subtype polymorphism simpler explain expand boxed boxedglobal expand pop pop expand int int pop boxedglobal boxedglobal pop pop pop pop int int fig supporting functions late enforcement notice pop defined local pointers turnstileleft shared private turnstileleft boxedlocal notice late enforcement places restrictions type data boxed create pointer shared data embedded pointers private data dereferencing local pointers standard allowed sharing qualifier global pointers dereferencing pointed-to data shared apply pointer widening result turnstileleft boxedlocal turnstileleft turnstileleft boxedglobalshared turnstileleft expand instance late enforcement restricts program behavior private data read global pointer private data visible owning processor local pointers assignment similar represents instance late enforcement restricts program behavior local pointer modify shared private data global pointer touch shared data enforce assigned embed local pointers global assignment carries additional requirement type assigned preserved type expansion turnstileleft boxedlocal turnstileleft eprime turnstileleft eprime turnstileleft boxedglobalshared turnstileleft eprime expand turnstileleft eprime widening directly applies type expansion function coerce local pointers global equivalents transmission processor boundaries requires type expansion identity global assignment typically transmit widened turnstileleft turnstileleft widen expand turnstileleft expand turnstileleft transmit expand selection propagates sharing qualifier pointer displacement obvious manner turnstileleft boxed turnstileleft boxed design implications rules point actual dereference assignment add restrictions implement late enforcement program read write private mixed data global pointer fails type check conjunction expand function rules implicitly cover case global pointers local pointers suppose local pointer private data global pointer shared location boxedlocalprivate boxedglobalprivate dereferencing yield local pointer equivalent pointer widened global points private data widened pointer points private data dereferenced assigned general late enforcement system forbids undesirable behavior private remote processor global pointer private data created copied processors data structures compared pointers memory location named pointer examined modified situations type boxedglobalprivate desirable pointer embedded tuple shared private components shared portions data structure accessed remotely private portions type checking program requires global pointers private data formed manipulated provided global pointer conservatively assumed address remote memory global pointer address local memory real distributed languages typically dynamically checked conversion global pointers back local global pointer private data converted back local pointer private data freely applicability limitations intend sharing qualifiers make data location management decisions weak guarantees offered late enforcement sufficient memory reserved private shared subscripted qualifier choose suitable region memory global pointers escape distant processors memory occupied private data examined modified remotely private data reside memory network-addressable sharable memory slower scarce reserved shared data clients make late enforcement guarantees distributed cache coherence maintained data examined remotely race condition detection systems concern global pointers private data create races similarly sequence operations private data reordered optimized freely strictest consistency models intermediate states observable processors treating lock acquisition dereference private locks eliminated compile time late enforcement late applications languages unable autonomously garbage collect late enforcement security concerns unsatisfied exposed pointers private data remaining type systems incrementally impose stricter enforcement policies accommodate concerns export enforcement languages late enforcement weak support autonomous garbage collection suggested earlier distributed programming environments support checked conversion global pointers back local system sequence actions place processor creates private data sends address remote processor processor holds global pointer private data processor destroys private data global pointer held processor live private data time processor sends global private pointer back processor processor checked conversion recover local pointer private data subsequently dereferences pointer autonomous garbage collection requires live data live local processor autonomously garbage collect steps private data unreachable memory occupies reclaimed language narrowing casts global local late enforcement support autonomous garbage collection modify late enforcement system source global pointers private data initial environment impose well-formedness requirement initial environment stipulating boxedglobalprivate part type variable function compound expressions chief source global pointers widen operator relies expand expand local pointers global figure revised expand function produces global pointers shared data notice version defined pointers private mixed data transmit longer send pointers private data processor boundaries thewidencoercion similarly restricted global assignment global dereferencing well-formed starting environment revised expand function ensures expression type boxedglobal private expand function guarantees pointers exported shared data observe pointer type boxed shared expanded restrictions type pointed-to data expand boxed shared boxedglobalshared expand pop pop expand int int fig revised type expansion function supporting export enforcement subordinate pop function unchanged figure freely transmit pointer shared memory cell turn points private data boxed shared boxed prime private 
prime identity expand export enforcement type system restricts actual values exported extend transitively level pointers sufficient support autonomous garbage collection guarantees remote processor hold live piece private data approach eliminate manage memory objects genuinely shared complements distributed garbage collection techniques stubs scions identifying private subset data collected aggressively simpler traditional purely local collection algorithms early enforcement untrusted environment address private data stored sensitive information security concerns mandate private address escape owning processor late export enforcement provide kind protection vulnerability type checking rule global dereference requires pointed-to data shared untrusted environment remote processor willfully disregards restriction transitively walk pointers ultimately reach private data global assignment similarly vulnerable runtime checks detect misbehavior static compile-time assurances attractive option complete control private addresses refine export enforcement additionally require private data transitively reachable shared memory variables functions extend well-formedness requirements initial environments obvious manner compound expressions change required type checking rules allocation late export enforcement allowed shared private boxing type early enforcement impose additional restriction shared allocation turnstileleft turnstileleft private boxedlocalprivate turnstileleft allshared turnstileleft shared boxedlocalshared allshared predicate holds pointers directly embedded type shared allshared boxed shared allshared allshared allshared allshared int true pointer private data shared memory require initial environment obey similar restrictions general private storage transitively reachable shared global memory universe shared data transitively closed consequence sharing constraint global dereference assignment rules trivially satisfied data transitively reachable global pointer shared impossible malicious remote processor disregard sharing constraint transitively reach private data applicability trade-offs export enforcement restrictive late enforcement early enforcement restrictive accepting fewer programs export early enforcement make progressively stronger guarantees meaning private programs type check early enforcement support late enforcement clients race detectors reordering optimizers autonomous garbage collection effectiveness clients reduced early enforcement treats data shared late export enforcement private set programs accepted system strict subset accepted adapted earlier proof local global soundness show late enforcement system sound soundness systems additional requirements imposed system access private data global pointer enforced directly type checking rules correctness restrictions verifiable direct inspection type checking rules operations type inference type systems easily converted type checking type inference illustrate late enforcement inference inference export early enforcement similar omitted sake brevity assume program type check disregarding sharing qualifiers local global qualifiers inferred infer qualifiers simultaneously simplicity assume local global inference place separately type inference rules produce system constraints solved rules figure additional sharing constraints arise expand function defined figure clarity presentation rules abbreviations constraint sets explicitly propagated subexpressions complete constraint set union sets constraints induced subexpressions turnstileleft int turnstileleft prime turnstileleft primeprime primeprime turnstileleft prime turnstileleft turnstileleft boxedlocal turnstileleft boxedlocal turnstileleft turnstileleft boxedglobalshared expand prime turnstileleft prime turnstileleft turnstileleft eprime prime turnstileleft eprime prime turnstileleft boxedlocal turnstileleft eprime prime prime turnstileleft eprime turnstileleft boxedglobalshared turnstileleft eprime prime prime expand turnstileleft eprime turnstileleft turnstileleft turnstileleft turnstileleft boxed turnstileleft boxed turnstileleft expand prime turnstileleft widen prime turnstileleft expand turnstileleft transmit fig type inference rules late enforcement nontrivial rule hypothesis boxedglobalshared read equality constraint boxedglobalshared constraint variables fresh solution constraints induced rules valid typing program note setting variables shared produces legitimate solution languages assume data shared safe albeit expand boxed boxed prime prime prime prime prime expand prime prime expand prime expand prime expand int int fig additional constraints induced supporting functions assume local global qualifiers assigned functions cover additional sharing constraints private shared fig constraint graph requiring choice shared private arrow encodes constraint overly conservative sharing qualifier lattice solution interested solution defined largest number private qualifiers maximally-private solution computed efficiently assume initially static typing showing pointer pair integer pointers local global equivalences figure expand type constraints prime prime obtain complete set sharing constraints identify set qualifier constants transitive lower bounds qualifier variable collect set constraint variables shared mixed transitive lower bound variables private sharing qualifier variable set private private transitive lower bound variable present earlier sharing qualifier upper bound constant transitive lower bounds final solution meat algorithm devolves graph reachability flowing forward constraint edges nodes representing type qualifiers solution computable time linear respect number sharing qualifiers fully typed program local global inference linear language designers great flexibility expose type choices source language present simpler source-level model augmented fast compiler-driven type inference fill details critical feature algorithm identifies qualifiers possibly private binds variables private lastly chooses shared mixed variables made private strategy maximizes number private qualifiers exchange driving qualifiers mixed shared figure algorithm binds private means private mixed alternative set shared drive mixed shared case mixed algorithm resolves choices favor maximizing number variables bound private clients interest related work static type systems previous proposals dealt local global shared private general result general unsafe lack generality prevents programmers enforcing data private makes difficult reason program correctness results missed opportunities optimization lack safety exhibits unsafe implicit casts pointer types impede optimization under-specified semantics optimization change program behavior unexpected ways group languages guarantees safety facility declaring private heap data languages stack private entire heap treated potentially shared java olden titanium prior work category languages techniques provide basis automatically inferring private heap data important programmers declare private data explicitly knowledge data private critical understanding parallel distributed programs jade safe language distinguishes local global pointers heap data private private data transitively reachable shared heap corresponds early enforcement system section results show security primary concern significantly flexible sharing data allowing data statically identified private making privacy-dependent analyses effective earth-c explicitly offers local global shared private type qualifiers local global inferred shared private explicitly approach shows shared private amenable inference operating fully automatically augment programmer directives broader earth-c project demonstrated identifying local private data drive analyses redundant read write removal communication optimization unsafe c-derived languages pcp upc offer shared private data type systems distinguish addresses private data narrowed global pointers shared data effect languages offer global shared local mixed private data exists run time static type system identify manner clients listed section deployed family split-c directly address notion private data data presumed shared difficult semantics required regard code reordering aggressive optimizations cilk explicitly treats memory shared states programmer responsible understanding underlying memory model provided host hardware sharing inference support aggressive optimization added burden under-specified semantics type systems similar 
escape analysis previous research focused identifying data escape stack frame thread execution early enforcement system thought identifying data escape local address space considered light late enforcement system unusual escape addresses permitted provided data referenced escaped address examined modified distance permissive escape analysis strong support traditional escape analysis clients synchronization removal knowledge earlier study takes approach similar late enforcement thread-local analysis presented aldrich defines multithreaded objects objects escape thread written conservatively defined distinct thread escaped object written considered multithreaded similar spirit late enforcement globally reachable piece data accessed remotely considered shared question akin late enforcement applied directly stack thread escape analyses warrants study experimental findings added sharing qualifiers titanium experimental java dialect high performance parallel computing unqualified assumed shared programmers declare private mixed subject validation type checker stronger private qualifiers added automatically type inference highlight bounds design space late early enforcement export enforcement yield performance results inference engine based cqual qualifier inference engine benchmarks single-program multiple-data spmd codes explicit sharing qualifiers benchmarks designed execution distributed memory multiprocessors reflect scientific focus spmd programming applications include monte carlo integration sorting sample-sort dense linear algebra lu-fact cannon fourier transform d-fft particle methods n-body particle-mesh solvers computational fluid dynamics gsrb pps amr gas whole-program sharing inference including java class library roughly additional lines takes ghz pentium linux workstation inference algorithm linear scale larger code bases studied sharing based analyses optimizations section detailed results companion report additional details incorporating sharing analysis complete programming language focus areas static prevalence inferred types dynamic tallies shared versus private allocation support data location management performance impact sharing inference consistency model relaxation static metrics table shows number static declaration sites benchmark places sharing qualifier syntactically titanium stack trivially table benchmark sizes relative counts inferred qualifiers benchmark lines sites late earlyshared mixed private shared mixed private sample-sort lu-fact cannon d-fft n-body gsrb particle-grid pps amr gas private exclude local variables tabulate heap data program inference include sites appearing benchmark application code libraries style enforcement show fraction static inferred shared mixed private review related work distributed languages private stack notion private data important omission system consistently identify large amounts private heap data benchmarks sizes largest benchmark gas private data half declaration sites benchmarks range sites benchmarks inferred private encouraging news analysis clients exploit information reinforces inference human programmer correctly place qualifiers hand maintain qualifiers time small number mixed qualifiers benchmark cases mixed found utility code shared distinct parts application parametric polymorphism subtyping find code isolated methods performs complex operations shared private data based complex run time control decisions mixed qualifier works method-based parametric polymorphism difficult apply nontrivial code factoring cases code polymorphic respect sharing polymorphic type system significantly data forced shared polymorphism important system small mixed counts suggest heap data shared processors obvious choice address global pointers clear local pointers shared data needed programs show heavy local pointers shared data shared heap data addressed local pointers numbers remain high amr gas largest benchmarks local shared pointer represents locally allocated portion larger distributed table kilobytes allocated shared private memory omitgsrbandibdue unrelated titanium bugs prevent running completion benchmark late earlyshared private shared private sample-sort cannon d-fft n-body particle-grid pps amr gas data structure processor retains local pointer data created pointer efficient access data owns earlier work demonstrated local pointers critical performance quarter half statically shared data forced global performance suffer data location management shared memory scarce costly resource instrumented benchmark tally number shared private allocations entire run table totals bytes late early enforcement observe slight differences enforcement schemes small benchmarks reported identical results table earlier table examined application code excluded libraries allocation counts apply entire program slight differences inference results library code visible slight differences allocation counts late versus early enforcement wide variation benchmarks ranging allocations shared particle-grid allocations private n-body examples extremes large small benchmarks largest benchmark gas memory intensive find allocated bytes private memory byte counts vary appreciably late early enforcement amr sees shift dramatic shift found pps late enforcement private allocation early enforcement drops table observe pps shows large difference static private declaration counts differences encompass data structures account preponderance pps runtime memory consumption running machines costly shared memory pps stands benefit greatly data location management guided sharing inference fig performance cost sequential consistency omit lu-fact gsrb due unrelated titanium bugs prevent running completion consistency model relaxation titanium fairly weak consistency model compiler hardware reorder memory operations stronger model attractive programming target unacceptably harm performance suggested section sharing inference private data accesses reordered ensuring stronger semantics language level implemented optimization sequentially consistent variant titanium figure presents benchmark running times configurations inference data assumed shared sequential consistency enforced early late enforce sequential consistency private data inferred type system weak weak consistency model titanium upper bound speedup allowing reordering benchmarks raw performance present running times normalized running time implementation sequential consistency measurements smp linux workstation pentium iii mhz cpu dram large speedup weak confirms sequential consistency costly bluntly applied sharing inference identify private data erase penalty late early variants hand inspection shows sharing inference forpiis perfect data main computational loop inferredprivate restrictions needed optimizations enforce sequential consistency early late weak versions yield identical machine code apparent performance measurement noise benchmarks modest improvement implementation weak consistency model potential speedup sharing inference limited defies conventional wisdom sequential consistency expensive potential sources inefficiency sequentially consistent versions lost optimization opportunities loop transformations additional memory fences load store instructions significant benchmarks highlights limitation experimental environment titanium compiler pentium hardware taking advantage weak consistency looser requirements significantly boost performance sequential consistency larger benchmarks cannon d-fft amr show largest performance gap weak models stand benefit sharing inference d-fft inference late early match weak model modest benefits cannon larger slowdown partly offset inference late early enforcement yield identical results cannon difference late early slowdown factors measurement noise results amr interesting key performance-critical data structures inferred private current system spmd programs amr alternating-phase structure processors exchange boundary information processor updates local portion shared grid processors communicate data shared widely amr communication phase treat data private local computation phases phases delimited global barrier operations processor processors data local computations taking place sharing inference effective 
limited form flow sensitivity keyed phases structure barriers regular practice extension techniques feasible observe benchmarks unexpected speedups sequential consistency direct penalty sequential consistency small measurement noise due secondary effects cache alignment code layout noticeable conclusions presented general approach describing data sharing behavior distributed programming languages codified approach suite type systems early enforcement resembles earlier work escape analysis export late enforcement unusual enforcing privacy closer point point escape allowing identify private data exchange weaker guarantees private means considered type systems light optimizations permit present experimental data optimizations data layout management consistency model relaxation approach conducive efficient type qualifier inference adapted suit realistic languages survey related languages suggests fall categories under-specify behavior shared data equate shared global private local approach points combinations mixed pointers local shared pointers role play agarwal bianchini chaiken johnson kranz kubiatowicz lim mackenzie yeung mit alewife machine architecture performance proc annual int symp computer architecture isca pages june aiken gay barrier inference conference record popl acm sigplan-sigact symposium principles programming languages pages san diego california january aldrich sirer chambers eggers comprehensive synchronization elimination java science computer programming published washington technical report uw-cse- october balls finite difference domain decomposition method local corrections solution poisson equation phd thesis department mechanical engineering california berkeley berger colella local adaptive mesh refinement shock hydrodynamics journal computational physics lawrence livermore laboratory report ucrlb blanchet escape analysis object oriented languages application java oopsla pages bogda olzle removing unnecessary synchronization java oopsla pages brooks iii pcp parallel extension fat free technical report ucrllawrence livermore national laboratory sept carlisle olden parallelizing programs dynamic data structures distributedmemory machines phd thesis department computer science princeton june carlson draper distributed data access proc acm sigplan symposium principles practice parallel programming ppopp pages santa barbara california july ida supercomputing research center carlson draper culler yelick brooks warren introduction upc language specification technical report ccs-tr- ida center computing sciences chandy kesselman compositional compositional parallel programming lecture notes computer science choi gupta serrano sreedhar midkiff escape analysis java oopsla pages culler dusseau goldstein krishnamurthy lumetta von eicken yelick parallel programming split-c ieee editor proceedings supercomputing portland oregon november pages spring street suite silver spring usa ieee computer society press foster cqual http bane berkeley cqual nov foster ahndrich aiken theory type qualifiers proceedings acm sigplan conference programming language design implementation pages atlanta georgia sigplan notices helmbold mcdowell computing reachable states parallel programs acm sigplan notices dec hendren tang zhu ghobrial gao xue cai ouellet compiling earth multithreaded architecture international journal parallel programming aug henglein rehof complexity subtype entailment simple types proceedings twelth annual ieee symposium logic computer science pages warsaw poland june july ieee computer society press hilfinger bonachea gay graham liblit yelick titanium language manual technical report csd- california berkeley nov liblit aiken type systems distributed data structures conference record popl acm sigplan-sigact symposium principles programming languages pages boston massachusetts january liblit aiken type systems distributed data structures technical report csd- california berkeley jan http sunsite berkeley techreppages csd- liblit aiken yelick data sharing analysis titanium technical report csd- california berkeley nov http sunsite berkeley techreppages csd- mellor-crummey compile-time support efficient data race detection sharedmemory parallel programs acm sigplan notices dec midkiff padua issues optimization parallel programs proceedings international conference parallel processing volume software pages park penn aug penn state press csrd ill myricom message passing system july version oopsla acm conference object-oriented systems languages applications volume acm sigplan notices denver oct acm press peskin mcqueen three-dimensional computational method blood flow heart immersed elastic fibers viscous incompressible fluid journal computational physics apr pike semenzato colella hilfinger parallel adaptive mesh refinement titanium proceedings ninth siam conference parallel processing scientific computing san antonio texas mar plainfoss shapiro survey distributed garbage collection techniques baker editor proceedings international workshop memory management volume lecture notes computer science ilog gentilly france inria chesnay france sept springer-verlag rinard lam design implementation evaluation jade acm transactions programming languages systems savage burrows nelson sobalvarro anderson eraser dynamic data race detector multithreaded programs acm transactions computer systems nov steensgaard thread-specific heaps multi-threaded programs hosking editor ismm proceedings international symposium memory management volume acm sigplan notices minneapolis oct acm press supercomputing technologies group mit laboratory computer science cilk manual june whaley rinard compositional pointer escape analysis java programs oopsla pages zhu hendren locality analysis parallel programs ieee transactions parallel distributed systems feb zhu hendren communication optimizations parallel programs acm sigplan notices 
titanium high-performance java dialecta kathy yelick luigi semenzato geoff pike carleton miyamoto ben liblit arvind krishnamurthy paul hilfinger susan graham david gay phil colella alex aiken computer science division california berkeley lawrence berkeley national laboratory abstract titanium language system high-performance parallel scientific computing titanium java base leveraging advantages language allowing focus attention parallel computing issues main additions java immutable classes multidimensional arrays explicitly parallel spmd model computation global address space zone-based memory management discuss features design approach report progress development titanium including current driving application three-dimensional adaptive mesh refinement parallel poisson solver overview titanium language designed support high-performance scientific applications historically languages made claim achieved significant degree scientific programmers reasons high learning curve languages dependence heroic parallelizing compiler technology consequent absence compilers tools incompatibilities languages libraries goal provide language users access modern program structuring object-oriented technology enables users write explicitly parallel code exploit understanding computation compiler optimizing compiler technology reliable predictable results starting design point titanium java chosen java reasons work supported part defense advanced research projects agency department defense contracts -cand dabt -cby department energy contracts de-fg de-ac director office computational technology research division mathematical information computational sciences -engthrough lawrence livermore national laboratory subcontract national science foundation contracts cdaby army research office contract daah microsoft graduate fellowship information presented necessarily reflect position policy government official endorsement inferred java small clean object-oriented language compared instance easy extend java popular based popular languages learning titanium requires effort acquainted java-like languages java safe language titanium safety enables user write robust programs compiler perform optimization titanium main goals order importance performance safety expressiveness performance fundamental requirement computationally demanding scientific applications design choices reflect goal instance execution model explicitly parallel eliminating parallelizing compiler distributed data structure fully defined programmer complete control layout process boundaries addition programmer type modifiers variable declarations convey locality information compiler find hard infer reliably static analysis safety meanings titanium ability detect errors statically instance titanium compiler ensure processes execute correct sequence global synchronizations ability detect report run-time errors out-ofbound indices accurately forms safety facilitate program development importantly enable precise analysis effective optimizations expressiveness priorities target customers sacrificed expressiveness goals built-in features true multi-dimensional arrays iterators points index sets including irregular first-class values span processor boundaries similar global pointers split-c titanium expressive languages comparable performance titanium based parallel spmd single program multiple data model computation model parallelism running program asynchronously processors processor data titanium processes transparently read write data resides processors titanium programs run distributed-memory shared-memory architectures support smps based java threads section titanium program written smp guaranteed run efficiently distributed-memory architecture claim language supports architectures equally summary titanium language java base strict extension java titanium compiler translates titanium portability economy prototype temporarily generating addressing problem high performance java virtual machine remainder paper outline language features relationship java omissions java features optimizations facilitated java base language driving applications motivate initial version titanium language compiler related work essence competing approaches parallel programming language library list relevant efforts libraries relative simplicity robustness libraries parallelism makes popular choice scientific computing spmd programs written fortran mpi communication synchronization form vast majority large-scale parallel scientific applications mpi lower raw performance global address space cray mpi achieves bandwidth sec global address space achieves bandwidth sec global address space compiler optimize remote accesses techniques local memory hierarchy fidil multidimensional array support titanium strongly influenced fidil maps domains titanium sacrifices expressiveness performance titanium arrays rectangular fidil maps arbitrary shapes titanium static domain types general domain rectangular domain fidil general domain type making harder optimize code common rectangular kind java-ad hpjava project includes java-ad extension java spmd-style programming main feature java-ad multidimensional distributed arrays similar hpf arrays java-ad offers interface mpi explicit communication current plan translate java-ad standard java mpi calls approach prevents optimizations implementing titanium split-c parallel execution model global address space support titanium closely related split-c titanium shares common communication layer split-c distributed memory machines extended part titanium project run shared memory machines split-c differs titanium default pointer type local global local pointer default simplifies interfacing existing sequential code global default makes easier port shared memory applications distributed memory machines split-c sequential consistency default consistency model explicit operators non-blocking operations compiler introduces non-blocking memory operations automatically dependence information parallel program analysis titanium closer regard language extensions main features titanium immutable classes explicit support parallelism multidimensional arrays mechanism programmer control memory management class public static void main string replicated variables values processes single int numberofiterations single int work proc barrier work proc barrier work figure simple synchronization immutable classes java objects accessed simplifies language adds constant overhead extra level indirection object creation destruction reduces performance programs make intensive small objects typical user-defined complexnumber class remedy problem introduced immutable classes immutable classes extensions existing class including object extended non-static fields immutable classes final restrictions compiler pass objects allocate stack objects effect behave existing java primitive types structs immutable classes special titanium types point section parallelism global synchronization important kind synchronization spmd programs global synchronization processes participate instance barrier process wait processes reach barrier figure shows typical spmd skeleton group processes simultaneously execute code shown figure synchronizing barriers program figure correct long processes initialization classes relies java rule final fields initialized constructors case barriers ensure process executes work executes work processes values execute sequence barrier statements error titanium performs global-synchronization analysis ensures compile time bugs occur global-synchronization analysis based recognizing singlevalued variables replicated variables process owns instance processes figure single-valued titanium programmer declares single-valued variables compiler verifies program structurally correct program structurally correct subexpressions satisfy set single-valued variables processes begin execution identical values variable processes terminate processes execute sequence global synchronization operations end identical values variable details aiken gay local global storage titanium process called region object contained single region local variables objects created contained region process allocates objects regions obtained communication primitives default titanium assumed global point objects region programmer declare variable points objects type region current process declaring variable local similarly local qualifier declare object field points object region distributed-memory machines local pointers significantly efficient global pointers space access objects faster smps global local pointers equivalent communication processes communicate 
reads writes object fields cloning objects copying parts arrays one-to-all communication supported broadcast method all-to-all communication exchange method methods imply global synchronization processes processes call broadcast exchange operation complete barrier method defined compiler verifies global synchronization operations maintain structural correctness program process-to-process synchronization handled java synchronized methods synchronized statement consistency model programmer synchronization constructs prevent concurrent reads writes shared objects language rules race conditions languages global address spaces programmers simple shared variables build synchronization structures spinlocks system shared variables race conditions intuitive semantics shared accesses sequential consistency states memory operations effect total order consistent processor program order machines hundreds thousands cycles memory latency local remote memory access sequential consistency expensive machine designers opted weaker consistency models processor consistency release consistency krishnamurthy yelick shown languages provide stronger model sequential consistency static analysis languages execute hardware weaker semantics exploring analysis requires good aliasing synchronization information context titanium current consistency model rely analysis adopt java consistency model weakly consistent program level roughly programmers unexpected program behavior protect conflicting variable accesses barriers locks language-specified synchronization primitives memory management titanium incorporates zone-based memory management extension java allocation specific zone zones freed explicit delete-zone operation run-time system maintains counts ensure zones deleted outstanding remain approach advantages explicit programming locality placing objects accessed zone perform garbage collection distributed-memory machines keeping count zones individual objects mitigates problems cyclical data structures cyclical data structures reclaimed long contained single zone preliminary study style memory management sequential programs found zones faster malloc free conservative garbage collection cases study compiler modified perform counting pointers zones related study stoutamire obtained speedup amr code zones improve data locality arrays points domains titanium arrays distinct java arrays multi-dimensional constructed domains index sets indexed points explicit lists integers fortran points tuples integers domains sets points code fragment shows multi-dimensional array constructed point point rectdomain double double two-dimensional points declared initialized rectangular domain initialized set points rectangle corners finally variable initialized two-dimensional array maps point double multi-dimensional iterator called foreach operate elements foreach statement executes body bound successive points domain foreach domain style iterator simplifies removal array bound checks loop body iteration order compiler reorder iterations sophisticated fragile analysis fortran compilers perform tiling optimizations titanium foreach intended enable uniprocessor optimizations generate parallelism titanium array elementwise operators writing statements expressive titanium foreach complex array-level expressions considerably difficult optimize rectdomain type represents conventional rectangular index ranges dimensions general domain type represents arbitrary index sets domain arrays rectangular foreach accepts general domains important feature modern partial differential equation solvers hard implement efficiently abstraction mechanisms extensions preceding extensions principally motivated considerations performance parallel performance lower priority extensions enhance expressiveness introduced titanium programmers provide additional overloadings standard operators array indexing syntax defining member functions special names motivation expect notations interest audience scientific programmers plan introduce form parameterized types on-going debate possibility adding facility java timely resolution intend conform closely selected specification incompatibilities ideally titanium largely superset java simplicity compatibility existing code areas incompatibility threads numerics threads current version titanium language current implementation support threads adding threads current spmd model purpose parallel execution multiple processors overlap long-latency operations disk user make java modules written threads awt titanium programs addition threads complicate global synchronization barriers analysis extended limited thread model numerics titanium adhere java standard numerics existing java implementations include support finer control ieee-floating point features exceptions rounding modes adequate attention issues optimizations prototype compiler performs standard analyses optimizations finding defs variables computing control flow paths finding moving loop invariant expressions finding induction variables performing strength reduction array index expressions omits construction control variable aforeach optimizations variable generating code rely compiler perform optimizations analysis special knowledge titanium language libraries analyses advantage safe clean semantics java titanium perform optimizations expect compilers perform code produce experiments shown perform additional straightforward optimizations compiler happen loops naive implementation loop figure yields poor results depending static type iteration arectdomain domain internal representation union rectdomains simplicity iteration singlerectdomain address calculation requires single pointer increment iteration innermost loop trivial compilers perform strength reduction address calculations required titanium arrays arbitrary stride strength reduction generate code shown figure titanium programs achieve performance competitive fortran applications properly evaluating programming language requires implement representative applications intended domain developing titanium compiler run-time system parallel non-trivial applications ported written scratch section describes applications amr foreach dsr jdouble dsr jdouble dsr assign break break break figure titanium code excerpt generated code case amr amr full -dimensional adaptive mesh refinement poisson solver complete program consists thousand lines titanium code half code belongs routine called grid generator amr extension multigrid algorithm linear solvers multigrid relaxation method grids resolutions covering entire problem domain amr grids high levels resolution cover subset problem domain area interest level covered set rectangular patches similarly parallel amr solvers distribute patches processors relax lockstep patches large communication synchronization overheads small points computation grid generator recomputes patch hierarchy based accuracy load-balances computation assigning similar amount work processor grid generator large fraction code dedicated computing boundary values interfaces coarse fine boundaries computation onerous complex linguistic support effective aid amr large titanium program interesting note global synchronization analysis section helped uncover bugs development computational kernel application models propagation electro-magnetic waves objects dimensions preprocessing step casts problem simple computation irregular bipartite graph nodes represent electric magnetic field values computation consists series leapfrog integration steps alternate half time steps electric field calculated linear function neighboring magnetic field values vice versa preliminary results time run programs listed implementation planned set optimizations incomplete sequential performance set benchmarks show sequential performance titanium code experiments multigrid poisson solver computation standard daxpy operation vectors multigrid examples compared code written combined fortran daxpy examples compared unable obtain full amr code written language performed fortran java arrays titanium arrays overhead daxpy multigrid multigrid figure performance sequential titanium compared languages computation benchmark sequential comparisons multigrid problems grid points grid graph synthetic nodes fixed degree random connectivity daxpy element vector numbers mhz ultrasparc processor present performance versions daxpy problems standard java arrays titanium arrays bounds checking turned multigrid solvers make extensive domain operators written pure java java array version compiled standard java compiler access native code java compiler machine interpreted java 
byte codes roughly order magnitude slower titanium column table shows percent increase running time titanium array version relative fortran version parallel performance titanium runs top standard posix thread library smps active message layer distributed memory multiprocessors networks workstations figure shows speedup amr -way sun enterprise smp fixed problem size performance shows overhead parallel runtime library minimal amr development running shallow grid hierarchy levels speedup limited primarily serial multigrid computation coarse grid attains linear speedups runtime overheads offset improved cache behavior smaller data sets conclusions experience java good choice base language easy extend safety features greatly simplify compiler writer task extending java easier obtaining high performance java strict language specs assuming feasible features titanium hard impossible achieve java libraries compiler perform static analysis optimizations goals project make system robust scientific computing community basis research optimization explicitly parallel programs optimizations memory hierarchy domain-specific language extensions speedup processors performance -way sun enterprise smp amr figure speedups sun ultrasparc smp acknowledgements ben greenwald joe darcy earlier contributions titanium intel hardware donations including millennium grant sun microsystems donating clumps multiprocessor hardware 
operational semantics logtm ben liblit department computer sciences wisconsin madison liblit wisc version august abstract present formal operational semantics logtm hardware-based nested transactionalmemorysystem language includes memory accesses nested closed open transactions partial rollback commit abort handlers thread spawning escape actions working document intended reflect codify current understanding logtm operation common corner cases formal semantics serves companion published discussions logtm specifically corresponds system supporting nested transactional memory logtm moravan purpose status document document presents formal operational semantics logtm hardware transactional memory system define small assembly language memory accesses transaction operations state required behavior logtm implementation executing programs language implementation-specific behavior identified intentionally left unspecified additionally semantics models forward log current logtm implementations backward logs intentional deviation forces semantics dependent particulars implementation document dense mathematical notation minimum explanatory prose intended read treated companion published descriptions logtm architecture implementation specifically describe behavior nested logtm system moravan hope document documenting logtm behavior complex corner cases treatments hint codify detail andfurthermorehas mechanically tested verified revisions required correct errors reflect futurechangestologtm http wisc multifacet papers corrected updated semantics posted additionally citations document identify version number semantics version avoid confusion respect definitions fundamentals letvectors represent possibly empty vector ordered elements empty vector written right-associative single-element prepending operator vector concatenation operator convention numeric subscripts index vector elements prime sprime double prime sprimeprime marks identify successively updated versions initial execution proceeds forward time convention informal violated awkward cases set letvectors represent set vectors elements function domain domain function set restrict domain restriction restrict undefined pair functions represent cascading union defined braceleftbigg domain function values mapsto represent function maps identical represent fresh unnamed variable type context unconstrained instructions addresses set addressable memory locations program address space elements aprime values set values stored addressable memory locations elements vprime escapestates escaped unescaped set escape states elements eprime instructions set machine instructions logtm system elements xprime yprime zprime informally represent regular execution represent commit handlers represent abort handlers instructions recursive grammar instructions read write begin commitclosed commitopenvectoryvectorz escape unescapevectoryvectorz abort setstate evectort spawnvectorx addresses escapestates vectort transstates values andvectorx vectory vectorz instructions subsection definition transstates setstate instruction special operation manage environments abort handlers run actual program memory addresses values defined granularity logging implementation -bit values logged values represents -bit values addresses -bit-aligned locations hold values program single byte read complete -bit readsets addresses set read sets elements rprime valuemaps addresses values set maps elements wprime memorymaps addresses values set main memory maps elements mprime valuemaps memorymaps types convention construction elements memorymaps complete functions valuemaps includes partial functions address blocks logtm implementations log memory operations larger granularity individual addresses current implementations log -byte blocks memory accesses -byte aligned conditions defined apply coarser granularity logtm log model distinction addresses address blocks blocks fixed set address blocks addressblock addresses blocks complete function maps address address block mapping implementation-defined remain fixed duration program addressblocks addresses blocks element-wise extension addressblock sets set addresses addresses addressblocks uniontexta aaddressblock transaction state transstates readsets valuemaps instructions instructions set transaction states elements tprime informally transaction state records set addresses read transaction map addresses values written transaction current sequence commit handlers current sequence abort handlers thread states threadids set thread ids elements dprime threadstates escapestates transstates instructions represent set thread states thread consists escape bit stack transaction states ordered vector instructions execute threadids pii piprime program consists collection named threads system state memorymaps set system states elements prime system consists main memory running program initial subset initial system states defined set states conditions hold domain addresses mapsto unescaped note require complete address address hold initial arbitrary pool active threads initially consists single thread base non-transactional state arbitrary sequence pending instructions semantics judgments judgment read starting initial system state evaluation threads instructions terminates main memory system final state judgment prime read starting system state running steps leaves system sate prime judgment prime read starting system state running single step leaves system state prime judgment turnstileleft prime read starting system state running thread single step leaves system state prime judgment turnstileleft prime read starting system state evaluation instruction thread leaves system state prime sequential execution thread management termination system begins initial state runs threads reaped halt mem initial running multiple steps obvious transitive closure running single steps step multi step prime prime primeprime primeprime thread reaped instructions left execute base nontransactional state note multiple threads reaped order reaped arbitrary similarly single steps involving thread execution interleaved arbitrarily single steps thread reaping reap unescaped prime restrict threadids prime single step system consists selecting thread allowing thread single step note selection thread execute non-deterministic model thread scheduler semantics system step domain turnstileleftd prime prime single step thread consists removing evaluating pending instruction thread fetch vectort vectorx prime mapsto vectort vectorx prime turnstileleftd primeprime turnstileleftd primeprime thread spawned escape action newly spawned thread begins base non-transactional state spawn escaped dprime domain prime dprime mapsto unescaped vectorx turnstileleftd spawnvectorx prime conflicting memory operations conflict detection allread transstates addresses set addresses read transaction transaction stack defined allread allread vectort allread vectort allwritten transstates addresses set addresses written transaction transaction stack defined allwritten allwritten vectort domain allwritten vectort allaccessed transstates addresses set addresses read written transaction transaction stack defined allaccessed vectort allread vectort allwritten vectort conflict addresses addresses address conflict relation relation intentionally left unspecified address conflicts implementation-defined nondeterministic require conflict reflexive address conflicts writeconflict threadids addresses write conflict relation defined check write dprime negationslash dprime vectort aprime allwritten vectort conflict aprime writeconflict accessconflict threadids addresses access conflict relation defined check read dprime negationslash dprime vectort aprime allaccessed vectort conflict aprime accessconflict conflict resolution read conflicts thread uncommitted transactional write conflicting address conflicting reads abort read conf writeconflict unescaped turnstileleftd abort prime turnstileleftd read prime write conflicts thread uncommitted transactional write conflicting address uncommitted transactional read conflicting address conflicting writes abort write conf accessconflict unescaped turnstileleftd abort prime turnstileleftd write prime note provide semantic rules execution conflicting reads writes base non-transactional state implied requirement instructions stall time non-conflicting logtm strong atomicity defined blundell non-conflicting memory operations escape obeyx threadids addresses condition compliance relation potential read defined obeyx dprime negationslash dprime vectort 
addressblock addressblocks allwritten vectort intentionally state semantics escaped reads violate condition implementation choose extend semantics defining behavior reads -compliant escaped read fetches current thread nested transaction stack transactional state modified escaped read escaped vectort obeyx vectort turnstileleftd read addresses memorymaps transstates values transactional fetching function nested transaction stack requires finding innermost map mapping desired address top vectort vectort deep vectort vectortprime domain vectortprime vectort map found main memory provided resort mem obeyx transstates addresses condition compliance relation potential write defined obeyx obeyx vectort addressblock addressblocks allwritten vectort obeyx threadids addresses condition compliance relation potential write defined obeyx dprime negationslash dprime vectort addressblock addressblocks allaccessed vectort intentionally state semantics escaped writes violate conditions implementation choose extend semantics defining behavior writes -compliant escaped write directly updates main memory changing transactional state escaped write mem escaped vectort obeyx vectort obeyx prime amapsto turnstileleftd write prime non-transactional transaction active reads writes proceed conflict transactional activity threads noted earlier means logtm strongly atomic defined blundell non-conflicting read base non-transactional state yields main memory read base writeconflict unescaped turnstileleftd read non-conflicting write base non-transactional state updates main memory write base accessconflict unescaped prime amapsto turnstileleftd write prime transactional non-conflicting read transaction nested transaction stack current thread thread read set updated read trans writeconflict unescaped vectory vectorz vectort vectorx prime mapsto unescaped vectory vectorz vectorx vectort turnstileleftd read prime non-conflicting write transaction stores updates running transaction map write trans accessconflict unescaped vectory vectorz vectort vectorx prime mapsto unescaped amapsto vectory vectorz vectort vectorx turnstileleftd write prime handler registration unescapes open commits commit abort handlers run merged sibling operations addhandler instructions instructions instructions instructions instructions instructions handler combining function informally arguments addhandler represent existing instruction stream run handler handler prologue handler body handler epilogue existing instruction stream run handler result instruction stream argument instructions sequenced argument order handler body empty prologue epilogue arguments simply concatenated add handler empty addhandler vectorx vectorx vectorx vectorx add handler nonempty vectorx addhandler vectorx vectorx vectorx vectorx vectorx vectorx logtm commit handlers run fifo order addhandler withvectorx commit handlervectorx appended existing commit handlersvectorx conversely logtm abort handlers run lifo order addhandler withvectorx commit handlervectorx prepended existing abort handlersvectorx transactions special setstate instruction replaces current thread escaped state transaction stack instruction restore earlier configurations running abort handlers set state vectorx prime mapsto vectort vectorx turnstileleftd setstate evectort prime beginning transaction materializes empty read set map pushes current thread nested transaction stack commit handler empty abort handler restores thread state time begin restarts begin point initial values handlers change execution notice don care transaction closed open point matters commit begin unescaped vectort vectorx setstate unescapedvectort begin vectorx prime mapsto unescaped vectort vectorx turnstileleftd begin prime abort instructions normal execution sequence discarded aborting transaction popped discarded normal instruction stream running thread likewise discarded execution continues aborting transaction abort handler abort unescaped vectorz vectort prime mapsto unescaped vectort vectorz turnstileleftd abort prime substantial deviation logtm implementation rollback interleaved execution threads claim proved -compliant program distinguish atomic non-atomic rollback informally program difference thread observes aborting thread uncommitted writes rolled back condition forbids sort peeking escaped reads normal read write conflict detection forbids peeking unescaped reads closed commit enclosing transaction applies stored writes main memory committing transaction popped discarded execution continues committing transaction commit handler rest thread normal instruction stream notice means commit handlers execute dropping isolation commit handlers running threads observe stores performed committed transaction commit top closed unescaped vectory vectorx prime mapsto unescaped vectory vectorx turnstileleftd commitclosed prime open commit enclosing transaction similar instruction-provided commit handler run open transaction transaction accumulated commit handlers continuing rest thread normal instruction stream commit top open unescaped vectoryprime vectorx vectoryprimeprime addhandler begin vectory commitopen prime mapsto unescaped vectoryprime vectoryprimeprime vectorx turnstileleftd commitopenvectory prime nested closed commit innermost read set map commit handler abort handler merged parent transaction committing transaction popped discarded commit deep closed unescaped vectort vectorx vectort vectortprime vectory vectorz vectory vectorz tprime vectory vectory vectorz vectorz prime mapsto unescaped tprime vectortprime vectorx turnstileleftd commitclosed prime obeyo transstates addresses condition compliance relation potential write defined obeyo obeyo vectort addressblock addressblocks allwritten vectort note obeyo obeyx identical contexts nested open commit writes held innermost map applied directly main memory writes -compliant committing transaction popped discarded commit abort handlers commit instruction registered parent transaction subsequently needed handlers run open transactions abort handler commit handler restore state thread commit commit instruction execute accumulated commit handlers proceed normal instruction stream commit deep open unescaped vectort vectorx vectort vectortprime vectory vectory vectorz vectoryprime addhandler vectory begin vectory commitopen vectorzprime addhandler setstate unescapedvectort vectorz commitopen vectorz tprime vectoryprime vectorzprime domain obeyo vectort prime mapsto unescaped tprime vectortprime vectory vectorx turnstileleftd commitopenvectoryvectorz prime transactions marked open closed begun -compliance atransaction designated open closed commit time -compliance checking postponed open commit intentionally state semantics open writes violate condition implementation choose extend semantics defining behavior writes escape actions hardware responsible counting nested escape actions emphasize leave semantics double escape double unescape undefined escape unescaped vectort vectorx prime mapsto escaped vectort vectorx turnstileleftd escape prime unescaping require additional processing commit abort handlers unescaping inside transaction handlers queued depending outcome transaction unescape trans escaped vectort vectorx vectort vectortprime vectory vectorz tprime vectoryprime vectorzprime vectoryprime addhandler vectory escape vectory unescape vectorzprime addhandler setstate escapedvectort vectorz unescape vectorz prime mapsto escaped tprime vectortprime vectorx turnstileleftd unescapevectoryvectorz unescaping base non-transactional state abort handler discarded commit handler run immediately unescape base escaped vectorx vectoryprime addhandler escape vectory unescape prime mapsto escaped vectoryprime vectorx turnstileleftd unescapevectory acknowledgment document result intensive discussion jayaram bobba mark hill kevin moore michelle moravan cindy rubio gonzalez michael swift david wood luke yen wisconsin madison colin blundell christopher lewis milo martin deconstructing transactional semantics subtleties atomicity proceedings fourth workshop duplicating deconstructing debunking june keven moore jayaram bobba michelle moravan mark hill david wood logtm log-based transactional memory proceedings annual international symposium high performance computer architecture austin texas february institute electrical electronics engineers michelle moravan jayaram bobba kevin moore luke yen mark hill ben liblit michaelm swift anddavida wood proceedings international conference architectural support programming languages operating systems san jose california october 
association computing machinery index mapsto vector abort abort accessconflict add handler empty add handler nonempty addhandler addressblock addressblocks addresses allaccessed allread allwritten begin begin blocks check read check write commit deep closed commit deep open commit top closed commit top open commitclosed commitopen conflict domain escape escape escaped escaped read escaped write mem escapestates fetch deep mem top halt mem initial instructions memorymaps multi step step obeyo obeyx obeyx obeyx read read base read conf read trans readsets reap restrict set state setstate spawn spawn system step threadids threadstates transstates unescape unescape base unescape trans unescaped valuemaps values write write base write conf write trans writeconflict 
cognitive perspectives role naming computer programs ben liblit andrew begel eve sweetser wisconsin madison usa liblit wisc microsoft research redmond usa andrew begel microsoft california berkeley usa sweetser berkeley abstract programming computer complex cognitively rich process paper examines ways human cognition reflected text computer programs concentrate naming assignment identifying labels programmatic constructs naming arbitrary programmers select names arbitrarily programmers choose names regular systematic ways reflect deep cognitive linguistic influences turn names carry semantic cues aid program understanding support larger software development process introduction programming languages designed precise mathematical unambiguous interpretable machines natural languages hand evolved long periods time interpreted humans rich suite cognitive processes wrong dismiss programming languages wholly unnatural programs written humans proceed directly keyboard compiler development humans read modify code produced code understood human human programmers aware code artifacts produce readable runnable human cognition reflected text computer programs cially strongly purpose paper examine impact human cognition human language text forms computer software facets software construction paper closely examines naming act assigning identifying labels programmatic constructs intensive invented words major deviation natural language dialog participants share large mutually understood fixed lexicon compiler natural language blue sgu asd equally opaque arbitrary sequences letters provided programmer consistent spelling capitalization good precisely names arbitrary programmers great freedom select names promote code understanding examine ways relating standard programming practice modern theories human language cognition in-depth treatise identifiers standard scope narrow focus primarily languages java justified fact languages dominant tools large-scale industrial software development insight gain broad potential applicability variety methodologies morphological analysis discourse analysis grammar-based deconstruction names metaphorbased deconstruction names discover rationale programmers choices identifiers remainder paper organized section describes factors influencing selection individual names encodes insection weshowthatnamesexhibit regularities derived grammars natural languages allowing combine form larger pseudo-grammatical phrases convey additional meaning code section explores fundamental programming metaphors aid understanding code direct linguistic interpretation section review phenomenon overloading controversial programming feature relates polysemy metaphorical extension word meaning lastly section reviews findings suggests directions future study meaningful names basic guidelines writing good code meaningful names humans create code humans read code names programmers select reflect human cognitive structure naming engenders strong reaction software practitioners advocate naming scheme ensure programs understandable documentation jones asserts memorability confusability names program section examine ways programmers select names embed cognitively salient information practice human beings rich source hints behavior intent code morphological metaphorical regularities programmatic representation manipulation information abstract routinely speaks virtual world exists inside computer distinguished form real world humans make pervasive metaphor structure understanding world exclusively facets world removed bodily experience metaphors presenting domain tasks reifying abstractions concrete terms making accessible people comprehend programs central naming program entities piece software studies program comprehension verified names classified groups called concept keywords programming metaphors design data abstractions illustrative collection functions listed figure functions part gnome project collection software tools building desktop applications unix environment functions written brevity show names functions elide parameters result types implementations short list function names reveals regularities morphological structure metaphors gnome druid type gnome druid set buttons sensitive gnome druid gnome druid set show finish gnome druid append page gnome druid set page gnome druid prepend page gnome druid set show gnome druid insert page fig gnome druid functions obvious patterns morphological words morphemes separated underscores programmers great freedom choose names technical considerations make disallow spaces punctuation marks underscores allowed programmers delimit multiple morphemes single lexical convention popular functions fields variables lower case letters distinct lexical conventions govern kinds names morphemes concatenated delimiting underscores commonly java names capitalizing morpheme called camel case java type names gnomedruidpage gtkcontainerclass additionally method names concatenating morphemes underscores fully capitalizing word commonly found macro names gnome druid class gnome druid aware java lexical conventions differ slightly java embedded capital letters field method names indexof underscores expect index type names remain distinctive initial capital letter vector lexically transitional programmers prefer underscores favor embedded capitals leading trailing underscores mark internal names intended general combined lexical conventions gnomedruid internal type gnome druid internal macro distinctions drawn conventions coincide profound differences names code observe names begin gnome druid lexical convention deeper metaphorical basis distinct pieces code combined problems arise programmers names unrelated things modern language facilities packages modules namespaces encapsulate code avoid problematic collisions language faciligtk software system gnome layered gtk acts single word ties programmers creating encapsulated namespaces naming conventions preponderance names defined gnome software begin gnome gnome types gnome macros effect creating metaphorical container appears functions proceedings figure twelfth apply international specific conference gnome architectural facility support druids programming languages names begin operating gnome systems druid asplos san gnomedruid jose gnome october druid creating supporting namespace nested transactional namespace memory box logtm michelle box nested moravan jayaram containers bobba mark pervasive programming hill ben metaphor liblit michael revisit swift section department computer sciences page uni moravan gnome bobba druid kmoore set lyen markhill dialog liblit boxes swift guide work user supported linear part sequence national science foundation nsf grants ccfccr- eia cnsccr- donations intel sun microsystems bobba intel foundation fellowship yen nsf graduate research fellowship hill wood significant financial interest sun microsystems views expressed necessarily nsf intel sun microsystems permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee asplos october san jose california usa copyright acm aborts transparently explicitly retry programmers invoke transactions directly calling transaction begin indirectly statically scoped atomic blocks eliminate problems posed modular software closed transaction semantics limit concurrency maintaining isolation top-level transaction commits long-running low-contention top-level transaction frequently invokes short-running nested transaction steps druid shared resource allocator closed nesting maintain isolation resource allocator updates free list pointer commits severely restricting parallelism ideally release free list pointer transactions access allocator conflicting transaction open nested transactions address concerns relaxing atomicity guarantee managing isolation higher http wisc multif abstract nested transactional memory facilitates software composition letting module invoke knowing transactions closed nested transactions extend isolation transaction toplevel transaction commits implementations flatten nested transactions top-level resulting complete abort conflict partial abort transactions open nested transactions committing transaction immediately release isolation increases parallelism expressiveness cost software hardware complexity paper extends recently-proposed flat log-based transactional memory logtm nested transactions flat logtm saves pre-transaction values log detects conflicts read write bits cache block abort invokes software handler unroll log nested logtm supports nesting segmenting log stack activation records modestly replicating bits facilitate composition nontransactional code language runtime operating system services propose escape actions trusted code run confines transactional memory system categories subject descriptors processor architectures parallel architectures general terms design languages keywords transactional memory nesting logtm introduction emerging chip multiprocessors multi-core chips energizing interest making multithreaded programming painful promising approach transactional memory system lets programmer invoke transaction transaction begin work transaction end rely system make execution atomic intermediate data isolated successful transaction commits unsuccessful conflicts concurrent transaction evin moore luke yen vid wood versity wisconsin madison vid wisc acet java synchronized methods paper focuses systems implemented hardware support htms examine software-only stm systems challenges major challenges composing software modules transactional memory system supporting software composition transactions providing high concurrency long-running transactions require contended resources invoking nontransactional language operating system services challenge facilitating software composition ideal software composition module invoke module invoke module interfaces deep knowledge module internals prevalent method locking fails provide composition ensure safety avoid deadlock programmers locks held caller callee implementations open solaris warns sophisticated operating system programmers blocking mutex surprisingly delicate dance aid software composition systems support transaction nesting transaction begin end surrounding transactions straightforward nesting called closed nesting ensures atomicity isolation top-level outermost transaction commits htms implement closed nesting flattening nested transactions top-level transaction transaction begin simply increments counter transaction end decrements commit occurs count returns functionally correct flat closed nesting degrade performance conflict transaction complete abort beginning top-level transaction partial abort improve performance aborting transaction avoiding abort possibly longer top-level transaction challenge enhancing concurrency closed nesting level abstraction open nested transaction commits enclosing transaction system releases data read written transactions access generating conflicts register commit compensating actions run transaction commits aborts actions programmers raise level abstraction providing higherlevel isolation undo semantics compensate malloc executing free simply relying garbage collection simply restoring values memory locations modified free list pointer insufficient subsequent open transactions modified challenge escaping non-transactional systems systems run top non-transactional base systems include run-time libraries language virtual machines jvms operating systems windows linux solaris system virtual machines vmware applications escape systems explicitly system calls implicitly tlb traps interrupts asm statements escapes access lower-level capabilities directly application programmers stms handle escapes easily virtualize mechanisms user-level software htms hand hardware conflict detection bits speculative buffers escape non-transactional system disable mechanisms software operate correctly presence transaction isolation aborts nested logtm paper explores challenges context recently-proposed log-based transactional memory system call flat logtm flat logtm hardware mechanisms version management conflict detection compilers run-time library software implement language-specific transactional memory policies flat logtm performs version management storing values commit place cacheable virtual memory values abort per-thread log cacheable virtual memory hardware support makes commits fast data moved library software handler unrolls log aborts htms flat logtm performs conflict detection read write bits caches adds mechanisms cache evictions transactional data flat logtm counter flatten closed nested transactions top-level transaction nested logtm makes contributions extending flat logtm mechanisms support nesting escape actions contribution closed nesting partial aborts nested logtm transactions abort separately toplevel transaction segmenting undo log replicating bits segment records values single nesting level makes log resemble standard stack activation records frame holds records level nesting nested logtm narrows conflict detection specific nesting level extending cache bits copies flattening transactions nested deeper nested logtm partial abort unrolling subset log frames clearing subset bits contribution open nesting nested logtm supports access highly contended resources transaction open nested transactions commit release isolation prior top-level transaction commit open nested transaction commits log segment removed commit compensating action records added parent log segment addition transaction bits cleared cache contribution escape actions nested logtm supports calls lower-level non-transactional system including transaction escape actions bypass transaction version management conflict detection escape actions invoked explicitly instructions implicitly part trap escape action register commit compensating actions open nested transaction nested logtm implements escape actions per-thread flag disables logging conflict detection set view escape actions enabling mechanism supporting non-transactional system activity htms trap handlers system calls execute escape actions increases variety code execute transactions reduces abort transaction due activity addition escape actions key building block implementing transactions supporting debuggers garbage collectors recent htm proposals explored support closed nesting partial aborts open nesting extend work ways including proposing escape actions implementing nesting logtm defining condition mitigating subtle open nesting semantic issues systems evaluate nested logtm versus flat logtm running 
microbenchmarks solaris -way multiprocessor simulated extension wisconsin gems sorted list b-tree microbenchmarks show benefit closed nesting partial abort show significant improvement increased concurrency provided open nesting performance benefit nesting running subset splashbenchmarks part due lack conflicts transactions workloads strided array microbenchmark demonstrates escape actions improve performance presence tlb miss traps allowing transactions continue trap transactional memory model section informally describes model closed nested transactional memory implemented flattening remainder paper evolves model support partial aborts open nesting escape actions describes model maps flat nested logtm implementations system represented memory maps addresses values set threads thread transaction level level read set write set map maps addresses updated values block function maps address possibly-larger aligned granularity memory block initially maps initial values level null thread begins transaction incrementing level subsequent reads address add block writing address adds block mapping tov replacing previous mapping inv read address generates conflict block thread write address generates conflict block thread transaction commit decrements level level updates mappings makes null transaction abort discards sets level reverts execution top-level transaction begin flat logtm background log-based transactional memory system referred flat logtm depicted figure serves framework nested transaction implementations flat logtm performs version management storing values commit place cacheable virtual memory values abort per-thread log cacheable virtual memory log consists fixed-size header thread state registers variable sized body comprising undo records figure shows in-depth transaction execution step log header thread register state including program counter step log body undo record old-block-value block old-block-value block prior transaction begin step including block block aligned virtual address processor maintains pointers log header log end write block bit set flat logtm writes undo record end log commit flat logtm discards log resetting log end pointer abort flat logtm invokes runtime software handler unroll log processing undo records last-in-first-out order starting log end pointer restoring thread state header flat logtm implements closed transactional nesting counter flatten nested transactions toplevel transaction htms flat logtm performs conflict detection read write bits caches commit abort flash clear bits flat logtm handles cache evictions transactional data extended directory protocol sticky-s sticky-m states flat logtm implements section transactional memory model forward-value map backward-value map replaces memory update-to-date memory forward map backward map mappings flat logtm updates memory place equals union means mappings replaced mappings conflict detection ensures disjoint sets flat logtm revert memory back memory humorous play wizard microsoft similar sequence-of-steps interaction popularized microsoft windows page corresponds single step sequence druid ordered linear collection pages provisions adding page start sequence prepend end append middle insert selecting page visible set metaphorical model sheaf paper folded open reveal page programmer adds removes druid pages target domain add remove real pages source domain instructive programmer chose call pages steps druid encapsulate sequence steps encapsulates presentation sequence steps user visual display critical page metaphor captures acutely fact druid pages rectangular black text white background enforces mapping gnome druid small programmatic abstraction metaphorical correspondences means unique douce presents long list metaphors found computer programs conflicting pressures impacting length names informative longer names embedded subwords informative practical limits lengths names practical limits lengths words natural languages union abort thread transaction flat logtm backward map undo thread omit proof equivalence backward forward logs understood database literature finally flat logtm bits directly maintain model read write sets blocks cache sticky-s sticky-m states conservatively overestimate set membership replaced blocks closed nesting partial abort section presents requirements closed nesting implemented partial abort requirements extend model partial aborts thread maintains separate read set write set map nesting level nesting level thread maintains read set write set map transaction begins reads writes similar base model section thread begins transaction incrementing level reading address adds block level writing address adds block level mapping tov level reading address generates conflict block compilers early programming languages fortran limited names thread level writing address generates conflict block orw thread level transaction commit significantly addition partial aborts top-level commit level remains decrement level update mappings clear closed nested commit commit level promotes committed transaction state parent transaction nesting level specifically closed nested commit level maintains isolation level taking union read write sets level level level level means set assigned set union similarly commit merges maps level level level level model assumes granularity read write conflicts generalized systems granularities tcc figure logtm node circles denote architectural state additions flat logtm required support nested logtm tag state data cpu directory cache controller timestamp cycle overflow nested logtm-specific state tag state sharer list tag state data log frame log end tmcount begin handler registers user escape escape actions exceptionmask mapping replaces mapping finally commit clears level level level decrements level top-level commit top-level abort closed nesting remains unchanged set level clear characters levels starting revert long execution tradition abbreviation transaction naming begins longer aborting names closed nested transaction informative level cumbersome results type partial abort read leaves long enclosing names quickly transactions run states unchanged finite specifically display width abort distance level clears abscissae abscissa abscissa distance ordinates sets level ordinate ordinate reverts cartesian execution distance square root begin distance transaction level abscissae distance figure presents abscissae distance extended ordinates closed distance nesting including top-level ordinates terse nested transactions abbreviated reads names writes partial complete abort words eventual enhance commit readability closed nesting expense logtm role adapt expressiveness flat logtm require support domain closed knowledge nesting decipher partial aborts extending version management dist sqrt conflict detection figure depicts linguists architectural long state observed added nested character logtm length node english buffers words varies hide inverse latency proportion log frequency writes written shown version text management closed good nesting reasons extends flat logtm tendency perthread log magnified header source code series names old-block-value blockaddress concatenations undo words records stack grow longer log frames rapidly resembling isolated stack words activation records similar typographic harris limitations make long log names frame unwieldy consists larger fixed-size expressions header programmers variable-size body leverage undo existing records mathematical garbage conventions headers attach significant meaning specifically nested small logtm names operates spatial transaction begin coordinates allocates log indices frame initializes counted number figure items nested fourth logtm overuse 
operation abbreviations lead preponderance unique symbols programmers decipher lead inhibited understanding lastly programmatic names vary semantic roles visibility code informative lessened names narrow figure shows snapshots log conflict detection bits lower half shows cache state var columns correspond variable names figure val columns show current values processor local cache upper half shows logical view log frames separated solid black line instance part frames parts dotted line separates header undo records frame previous frame pointer part header records shown undo record abbreviated variable logs pictured assume block block block part shows snapshot log conflict detection bits figure step key points multiple logging logged values level frame level frame level header includes pointer beginning level frame restoration commit abort header data including register checkpoint shown finally redundant conflict detection levels marked part read set conflict occurs thread write conflict thread read important difference bits affect abort instance suppose transaction makes read request redundant conflict detection shows sufficient abort roll back level transaction successfully resolve conflict conversely write conflict abort transaction levels part shows state level completes execution commits step figure key take-away merge operations work log data merge difference level frame encompassed level frame note sources waste level header level previous useless subsequent abort back level level header restored log traversed lifo order level final restored restart conflict detection bits show result merge operation level bit set set level commit additionally set level bit set level bits flash cleared write conflict attributed level sole writer part shows post-commit state level open closed section unlike part level versions discarded replaced compensation record abbreviated open 
figure conflict bits show level bits flash cleared level bits remain transaction point transaction read read write traversing log abort handler executes compensating action left level restores distinguishes record types examining tags shown var val step log cache var val step cache var val step cache closed level open level log log open thread current registers program counter saves parent transaction information base parent frame sets log frame pointer frame flat logtm nested logtm reuses bits detect write unique block causing add undo record end log current frame body nested logtm adds two-bit tag log record indicating undo record frame header block addresses aligned -byte blocks common undo record tag encoded free address least-significant address bits closed nested commit merges current log frame parent frame specifically nested logtm sets log frame pointer back parent frame saved transaction begin committing transaction frame committed transaction frame header remains body parent garbage header garbage headers occupy space parent frame semantic abort current transaction level traps library software handler walks body log frame backwards process undo records skip garbage headers finally restoring register state saved header transaction abort handler undo j-m log frames easily implemented software handler advantage logtm approach conflict detection closed nesting cache line bits array bits small chung find levels explicit support sufficient reads writes transaction level set ifj flattened level flattening correct behavior deeper nests removes performance benefit partial abort incoming read block generates conflict level minimum set outermost conflicting transaction similarly incoming write examines find minimum conflict cycle indicating potential deadlock nested logtm bit transaction level inform software handler rollback top-level transaction commit clears flash clear nested transaction commit level merges scope restricted ways flash clears identifier names implementation wild merge flash-or collected circuit statistical calculates data andc code ourjavacode represents cache line complete source parallel standard java assigns class logical-or libraries lines java flash-or code circuit adds defined transistors names bit line half transistors declare local word variables formal bit parameters lines local names sram cell narrowest flash scope clear transaction abort exists level back body level single method undoes log names frames average characters flash clears embedded subwords measured number figure capitalized subwords figure suggesting illustrate version combination management heavy conflict detection narrow scope closed incline nested programmers transactions figure terse shows nested largest logtm state semantic category nested consists transaction ready public commit methods top-level names transaction average step characters embedded figure note subwords public methods levelframe fewer records number write sparser step visible levelframe records entire writes program steps justify longer figure shows informative nested names logtm similar state trends transaction code performs measured closed commit lengths leaving source top-level transaction active correctness argument nested logtm closed nesting implements section closed nesting model steps stack log frames backward maps complement forward maps manner similar flat logtm complemented partial abort thread level back level undo made thread transaction levels cache bits directly implement multi-level readand write-sets due flattening represent union open nested transactions nested logtm supports open nested transactions provide greater concurrency richer semantics section generational terminology helpful transaction invoked thread level sparent thread level transaction began ancestors parent parent ancestors siblings level transactions thread begun parent including requirements open nested transaction releases isolation commit optionally registers commit compensating action handlers figure closed nesting thread begins execution non-transactional level initializes variables begins top-level level transaction step step read variable adds block conflict detection write variable adds block conflict detection version management thread begins nested level transaction step step read adds block write adds block step step write variable encounters read conflict block system resolves partial abort clears restarts execution step assume retry step succeeds adding block block step adds block block note address exist structures transaction level step block block step nested level transaction commits merging note merge mapping replace mapping finally step toplevel transaction commits updating memory mappings clearing thread level non-transactional initialize transaction begin top-level level transaction begin level partial abort write transaction commit level transaction commit level level ancestor current transaction level software ensure consistency open nested transactions raise level abstraction isolation rollback figure illustrates outer insert set transaction calls insert add multiple entries b-tree data structure making insert open nested transaction increases concurrency releasing memory-level isolation internal data structures preserve consistency data structure maintain isolation inserted entries lock flag figure outer transaction commits note outer transaction release isolation inserted entries performing commit actions calling unlock key similarly compensating actions undo forward action higher level abstraction calling delete key b-tree entry open nested transaction open commits propagating map nearest enclosing map memory clearing optionally registering commit action open compensating abort action open decrementing level mapping exists mapping max propagates propagates memory thread invokes open nested transaction open top-level ancestor commits performs commit action open open nested transaction level greater open committed open ancestors aborts system executes open open nested transaction moss argues compensating action execute state held forward action committed open executes open committed top-level ancestor transaction releases isolation processing commit compensating actions note programmers responsible ensuring actions generate additional conflicts original transaction failure result deadlock thread executes open nested transaction top-level transaction commits handlers interact clarity explain semantics case thread executes open nested transactions sibling open transactions opent open-n commit register commit compensating actions openc open-n opena open-n parent transaction open-parent ift open-parent commits commit actions executed first-in-first-out fifo order openc open-n compensating actions opena open-n discarded open-parent registers higher-level commit compensating actions open-parent open-parent conversely open-parent aborts compensating actions executed lastin-first-out lifo order open-n openthe action open-k executes moss simple semantics maps open-k committed long open nested transactions compensating actions written address ancestor section addresses potential problems arise case generally thread executes closed open nested transactions actions closest open ancestor transaction commits illustrate compensating actions multiple open transactions suppose open-parent insert set routine calls insert add multiple key pairs b-tree open-parent aborts compensating actions open-i call delete remove inserted keys open-parent commits registers higher-level delete set routine open-parent replacing individual calls delete interactions undo compensating actions open nested transactions lead strange behavior transaction open ancestors write memory location figure problems arise non-obvious interactions memorylevel undo operations parent semantic undo child problem exacerbated implementations handle interactions differently avoid making programmers reason subtle code gnumeric open source spreadsheet application corpus lines long declared names common names local variables formal parameters average length characters embedded subwords measured number underscore delimiters identifier find noteworthy metrics closely match java corpus bodies code authors purposes written languages names broader scope longer lesscommon functionswithfilescope average charactersand words andthe charactersand words earlier observed programmers common prefixes create artificial namespaces account greater average length function names compared java methods lastly analyzed source code windows server written corpus million lines code names names evenly divided global local localnamesaverage charactersand embeddedsubwords measuredbythenumber underscores inter-capitalized subwords global names average characters subwords significant increase public functions opposed types slightly smaller characters subwords average fewer type symbols shows average types windows server subword functions statistics interesting read standard deviations high refrain reporting remaining semantic categories drawing detailed conclusions pending nuanced statistical analysis treatment correlating lengths frequencies visibilities semantic roles scope present study crude preliminary analysis suggest strong underlying principles warrant closer examination grammatical sensibility programmer-defined names exist isolation interact language specific punctuation keywords build expressions statements composite constructs examine larger code fragments find evidence natural language grammar program text caprile tonella analyze function identifiers breaking individually meaningful words classifying lexical categories describing sixteen-production grammar section ways names create larger pseudo-grammatical utterances leverage natural language understanding aid code comprehension names phrase fragments purposes paper accept metaphorical assumption data things mapping reflected figure lists constituent fields make gnome dock fields nouns noun phrases programmer made english plurals precisely fields data lists single items unusual field floating items allowed indicative phrase omitted verb field holds single true false human reading code immediately conclude field true floating items allowed truthful statement dock specialized true false data factual assertions mapping override generic data things practical matter interested present state object phrases present tense occasionally encounter past future tense reason inquire past future states turn attention java class java util vector class fields capacityincrement elementcount elementdata true false data things correctly predicts noun phrase text small caps read metaphors container bottom bands floating children client area bands client rect top bands left bands floating items allowed fig constituent fields gnome dock names methods vector complex names suite schemes reflect differing frames understanding behavior purpose methods methods actions actively change state program methods non-portable implementation details advocate programmers observe restriction open nested transactions condition writes obeying data written ancestors open transaction open commit compensating actions open open writes data written open ancestors open executed thread level advantages obeying condition obeying condition effective open nested transactions b-tree open nested transactions section obey condition obeying condition frees programmers reasoning subtle issues surrounding leakage uncommitted transactional state open ancestors write datum 
isolation end open commits ancestors active obeying condition avoids subtle interactions recovery parent values semantic undo child actions open nesting logtm open nesting nested logtm requires version management conflict detection version management open nested transaction open level commits nested logtm discards open frame log making open parent level current optionally appends commit compensating action records open open newly exposed end open parent frame handler records function address variable-length argument list length insert int key int open begin leaf find leaf key entry insert leaf key lock entry isolate node entrylock open commit abort action delete key commit action unlock key insert set set open begin key insert key open commit abort action delete set figure open nested b-tree transaction abort software abort handler log restore values perform compensating actions processing log lifo order naturally produces correct interleaving restored values compensating actions moss semantics handler undoes transactional updates point open commit performing compensating action nested logtm logs store cache block transaction level open nested transaction commits semantics require log undo records needed roll back state memory transaction committed run-time system ensures presence log records immediately beginning implicit closed transaction nesting level committed open transaction level runtime system commits implicit transaction immediately begin commit operation promoting conflict information nesting level commit compensating actions execute open nested transactions lower level open committed actions conflict abort retry open transaction conflict detection beginning open nested transaction open closed nested transaction open commits nested logtm simply flash clears bits employing flash-or closed nested commit nested logtm supports maskable exceptions openlevel exception raised open begins level exceed nested logtm levels bits masking exception supports unbounded nesting converting deeply nested open transactions flattened closed transactions ignoring handlers registered commit masking exception open nested transactions enhance concurrency two-way communication enabling open-level exception software error handling full open nested semantics required communication transactions logtm raises maskable condition-o exception open writes data written ancestor violating condition exception raised execution obey simpler semantics condition programmers choose richer semantics handling masking exception case memory locations modified parent open child remain isolated part parent condition trigger false violations stack locations parent transaction reused open child true violations parent implicitly deallocated stack addresses changing stack pointer prevent unnecessary exceptions nested logtm provide mechanism identify bottom stack transaction begins mask violations addresses stack page address common case transaction begins ends language scoping level stack frame transaction begin address stack variable written child transaction figure parts illustrates version management conflict model return return incidental information effect actions names methods verb phrases imperative mood add addall addelement clear copyinto ensurecapacity insertelementat remove removeall removeallelements removeelement removeelementat removerange retainall set setelementat setsize trimtosize methods mathematical functions passively compute result alter state program methods obeying model return piece data interest caller method identified produces obeys data naming principles earlier true false data factual assertions true false returning methods verb phrase names indicative mood containsall equals isempty data things methods returning values true false singular plural noun phrase names capacity clone elementat elements firstelement hashcode indexof lastelement lastindexof size sublist conventions correctly describe thirty forty methods vector exceptions toarray tostring actual behaviors properly place category non-true false mathematical functions toarray tostring return object equivalent original vector converted form names consistent specialized java naming scheme exclusively conversion methods method strongest anomaly behavior return tat expected noun phrase naming convention play common offer matched pairs set methods manipulate object attributes object attributes method names extended identify attribute manipulate setcolor getcolor setname getname symmetric naming informative reveals attribute exists paired methods relate attribute specific italsoviolatesthe data things providing methods programmers resolve conflict inconsistently vector set setsize size setsize getsize valence cues characterize copyinto verb phrase bit generous ends dangling preposition natural language terms fragment open valence slot additional item specifically noun provided complete phrase java natural language valence cue valid nonetheless copyinto method called additional argument array vector components copied methods indexof elementat similar preposition-based hints open valence slots stem parts speech adjective requires noun modify removeall expects argument transitive verb method expects single parameter corresponds direct object english speech valence cues universal exact one-to-one correspondence method arity add method requires parameters requires share sublist method called sublistfromto open prepositions emphasize required arguments room variation programmer balance benefit valence cues concerns length readability design underlying programming language significant majority programming languages treat method names atomic object-oriented language smalltalk noteworthy exception smalltalk method names multiple words delimited colons argument segment smalltalk version insertelement named insert roster insert newhire position contrast java syntax roster insertelement newhire position smalltalk method woven arguments suggested required smalltalk programmer produce fragment argument english words open valence slots obvious choice finds smalltalk method names inject movetower highly descriptive schedulearrivalof accordingto startingat object oriented languages data personified active agents internal state fields set exported behaviors methods invoke method direct agent perform action perform calculation respect methods verb names open valence slot subject slot filled object method called roster insertelement insertelement reads imperative command issued roster subject appears immediately verb helps create extended pseudo-grammatical utterances english speaking programmers factual assertion roster record roster record factual assertion roster empty roster isempty imperative command roster remove junk roster removeall junk imperative command roster set size roster setsize noun-named methods reading possessive case equally easily provided reader access english construction computed attribute roster element roster firstelement computed attribute roster capacity roster capacity possessive reading natural complex expressions revisit issue greater depth section containers paths broaden scope issues cognition language comprehension intent undertake general review cognition computing pair models directly impact require closer inspection objects containers pointers paths describing objects predominantly container metaphor speak objects constituent fields internal state versus exported behaviors 
model consistent real-world metaphors treat composite entities containers enclose attributes metaphor carries visual depictions data structures typically show objects rectangles partitioned smaller boxes member field objects objects depicted boxes boxes objects enclose strict containment hierarchy object indirectly calls pointer java call pointer uniquely identifies single piece data holding data pointer simply records data found pictorial representations pointers presented arrows referrer referent programmer explicitly decide part complex data structure embeds directly indirect pointer java programmers deal directly java indirect embedding provided compound data types dot marks access embedded field object dock gnome detection open nested transactions recall figure shows nested logtm state nested transaction ready commit top-level transaction step figure note level frame records write step level frame records writes steps figure shows nested logtm state open transaction commits leaving top-level transaction active correctness argument sketch support open nesting nested logtm correct open transaction commit thread level performs fifo order commit actions registered committed descendent transactions discards open frame effectively promoting open nearest enclosing map memory clears release isolation data accessed parent transaction abort handler processes log lifo order performing memory undos compensation actions inverse order transaction violates condition compensating action sees ancestral memory state equivalent existed forward action committed escape actions open nested transactions promise greater concurrency semantics ill-suited invoking conventional operating system tolerate stalls aborts due data conflicts end propose escape actions transactional atomicity isolation invoke counter initializes transaction begin top-level counter counter open begin level counter counter commit compensating action open commit abort action decr counter abort run compensating action expect counter restored transaction commit executed figure violating thread initializes counter begins transaction increments counter begins open nested transaction increments counter commits open nested transaction compensating action decrement counter step aborts top-level transaction step thread updated counter expect counter restored nested logtm section raise exception step signal dangerous programming practice condition-o exception masked nested logtm implementation expected occurs processes log back commit point open nested transaction step running compensating action processes rest log restoring initial counter conversely mcdonald tcc implementation set counter kozyrakis olukotun personal communication occurs open transaction commit step writes memory input compensating action decrement complex examples strange behavior implementations programmers obey condition level performing reads writes behaves transaction register commit compensating actions effect enclosing transactions escape actions low-level escapes software nontransactional rest allowing debuggers libraries access modify uncommitted transactional data aborting transactions provide interface deal non-transactional code foreseeable future includes operating systems device drivers transactional operating systems escape actions interact non-transactional devices support non-transactional system calls escape actions implicitly begin end entering exiting kernel mode gracefully handling simple exceptions software tlb fills escape begin escape end calls provide explicit escape actions similar processor management instructions assembly code envision escape actions implement low-level functions exception handlers debuggers run-time support hidden highlevel language programmers complexity writing escape actions one-time expense library developers application developers general case study open solaris systems calls reasons applications access conventional operating system services transaction memory allocator introduction transaction invoke sbrk grow heap logtm htm continue transactional operation non-transactional kernel open solaris cede isolation control kernel memory user-level code escape actions provide bridge transactional nontransactional software summarized table escape actions suffice handle hundred open solaris system calls core services processor thread management file synchronization escape actions trivially correct read-only system calls getpid concurrent callers errors isolation compensation aborts category shown table traps tlb misses read kernel state causing user-visible transparent escape actions made correct system calls sbrk incr affect threads current process key steps invoking system calls isolating registering compensating action roll-back effects call transaction abort releasing isolation enclosing transaction commits sentinel location process virtual memory acts transactional lock kernel state writing sentinel location invoking system call dock dock container accesses embedded container field fields composite field access expressions extended long offers pointers roughly combine pointer semantics java syntax transitional form access deeply embedded subfields dock container widget requisition width section suggested english possessive construction capture member access satisfactory simple expressions roster firstelement difficult claim dock container widget requisition width effective comprehend extended field access chains programmers expressions explicitly linguistic terms operative model drilling outer containers start dock effect locks sentinel prevents transactions invoking call outer transaction commits container continue widget widget hypothesis gains credence pointer fields dot represent pointer accesses textual approximation arrow client area field gnome dock pointer dock client areaparent cross pointer retrieve parent subfield field access expressions driving directions describe path starting point final destination individual steps listed order traversed programmers casually refer crossing pointer reinforcing spatial metaphor pointers paths bridges islands data refer falling end data structure traversing pointer object orientation anaphora role deixis lastelement method java vector named roster write roster lastelement code implements lastelement longer refer roster body lastelement call size read elementdata access member fields methods explicitly naming object object implicitly assumed object lastelement method called methods single object tend tightly interdependent convention convenient greatly improves code readability creates interesting deictic shift place metaphorical data space sense inside object location benefits privileges access internal attributes object visible outsiders abbreviated names size roster size missing information implicit surrounding context refer object inside java supply keyword purpose smalltalk author gnumeric gnumeric written strongly object oriented style java referencing object superclass keyword super current class hidden access superclass fields methods object meaning constant altered execution program statement introduce object contrast natural languages subject sentence introduced subsequent sentences anaphorically refer subject pronoun nancy brought chips party brought bottle soda detienne notes anaphora rare programming languages anaphoricreferences temporal conditions execution thismethod found aspect-oriented programming incorrectly applied anaphora lead ambiguity unacceptable programming languages polysemy homonymy overloading phenomenon address overloading policy sharing functions permit overloading java java vector class overloading add methods addall methods indexof methods lastindexof methods remove methods toarray methods cases same-named methods accept numbers arguments overloaded methods identical arity differ expected types arguments distinctions compiler select method overloading disambiguated manner detected disallowed aggressive overloading turn kword open source word processor written programmer defined kwstring type represent text sequences document type overloaded methods including named insert insert method expects arguments argument position kwstring insertion place argument sequence characters represented underlying graphical toolkit sequence characters represented kword single character picture tab placeholder automatically generated text current date page number footnote anchor floating figure programmer method distinct insertpicture inserttab insertfootnote single creates conceptual grouping methods sense equivalent inserts document fragment position differ inserted methods english verb insert picture insert anchor english argue single insert verb picture anchor grammatically interchangeable kword program pictures anchors distinct insertion requires slightly code general effect caller cases making convenient simply call insert compiler determine method intended effect insert polysemic exceptions found command-line shells refer result evaluated expression csh operator overloading debate operator overloading takes view mathematical operators simply functions special names syntax sum operators addition integers built language forms addition anticipated language designers programmers define arithmetic data type representation hamilton quaternion algebra intended behavior obvious metaphorical extension addition realm languages support operator overloading programmer extend basic operators support data types defining addition quaternions similar defining function improve readability easier scan sum product object-centered times authors numerical scientific code find operator overloading skeptics counter overloaded operator perform arbitrary computation relationship basic form presence operator overloading simplest code fragments assumed consistent meaning entire word processor overloading offer overloading names operators overloadable operators include obvious arithmetic obscure define operators create objects act arrays overloading lets create so-called smart pointers function invocation operator overloaded javaallowsmethod overloading operator overloading cognitive terms deconstruct debate distinct concerns issue arbitrariness overloaded operators behavior worry overloaded operators diverge homonyms rational polysemic connection primitive counterparts true hiding entire word processor equally true insert remove data vector represent color blue skilled programmers names cognitively rational ways reason operators concern overloaded operators make harder infer behavior code difficult matter programmers read code ways goals important understand precise literal behavior code create run overloaded operators obfuscating intent understand code higher level abstraction operators extended metaphorically principled manner boon homonymic extension shift operators surprisingly widespread operator overloading homonymic defines standard operators manipulate bit-level representation numbers left shift shift motivation built-in operators based visual iconicity resemble arrows pointing left binary operators shifts bits representing left positions standard library overloads shift operators completely unrelated purpose file input output writes file data store data file file data load data file programmers add operators extend file data types technically clever trick justifies output polysemic extension shifting left input polysemic extension shifting file data simply data flowing arrow file visual metaphor compelling justify derided arbitrary overloading conclusions future work modern software incredibly complex source microsoft windows million lines code linux kernel weighs million lines managing kind complexity requires programmers draw deeply cognitive abilities discussed ways figure programmers select illustrates transactional names wrapper cognitively motivated sbrk ways system lexical call morphological conventions process data convey segment basic size information wrapper writes role sentinel metaphors prevents encourage productive threads inferences calling drawn sbrk incr domains enclosing experience transaction commits grammars aborts natural languages invoking shape sbrk successfully intricate wrapper ways registers polysemy compensating appears action overloading undoes attendant effect debates system literal call versus metaphorically case extended resetting meaning data segment find back programmers original leverage size fundamental aspects call cognition sbrk -incr natural language wrapper begins comprehension ends make code escape easier action read explicitly ensure understand practical system considerations call motivated compensating action narrowly registration study atomic role naming enclosing imperative transaction languages abort immediately expand escape scope action ends sentinels increasingly linguistically sufficient sophisticated simple programming system languages calls changed general locking cognitive mechanisms burden programmers conversely complex calls 
open transactions escape actions commit actions system language designers calls release isolation support programming enclosing cognitive transaction communicative commits task escape actions programming languages make provide linguistic system support calls safe anthropomorphism calls herbsleb manipulate data study file metaphors system describe software undoable behavior effects programming sophisticated observed intellectual process processes combines similarly aspects calls kill unlink undone data process file destroyed executing calls safely inside transaction require serialization-based technique unrestricted transactions escape actions common exceptions tlb miss handlers protection fault handlers system calls execute correctly disrupting running transactions greatly simplifies transactional programming increasing amount code run transaction requirements escape actions open transactions potential complex interactions compensation undo addition escape actions bypassing transaction conflict detection version management weak atomicity lead programming challenges result recommend escape action executed thread transaction level obey conditions condition writes data written ancestors write data written ancestors table escape actions open solaris system calls category examples read-only calls getpid times stat access mincore sync pread gettimeofday undoable calls per-process side effects natural chdir language dup umask seteuid regular nice structure seek formal mprotect mathematical undoable calls thought global study 
programming potential contribute valuable perspectives current research linguistics cognition anand clarify function sigplan ben-ari sajaniemi roles variables educators proceedings iticse pages york blackwell metaphor analogy programming abstractions vanneste bertels decker jaques editors annual workshop ppig pages ghent belgium april cannon elliott kirchhoff miller milner mitze schan whittington spencer keppel brader recommended style coding standards http psgd paul docs cstyle cstyle htm caprile tonella nomen est omen analyzing language function identifiers proceedings wcre page washington carter choosing identifiers sigplan detienne software design cognitive side effects handled chmod mkdir link mknod stime calls handled escape actions write kill fork exec umount void logtm sbrk int incr sbrk sentinel escape begin tmp sbrk incr tmp null escape end abort action sbrk -incr escape end null return tmp figure wrapper sbrk transactions effect call lock sentinel condition writes data accessed write data read written active transactions threads condition reads data written read data written active transactions threads conditions restrict escape action modifying uncommitted updates ancestor transactions threads transactions condition restricts escape action reading threads uncommitted updates conditions hold escape action operates non-transactional level begin transaction ending resumes execution thread level transaction escape action register commit compensating actions escape escape handlers differ open transaction counterparts execute escape actions escape actions violate conditions important debuggers exception handlers updates erroneous values resuming transaction reason section describes logtm escape action behavior including violations behavior cases htms differ subtle implementationdependent ways conditions hold escape actions resemble zilles bauch pause unpause escape mechanism non-isolated accesses memory support nontransactional operations escape actions maintain pause strong atomicity user-mode code zilles concurs weak atomicity prevent deadlock paused regions access transactionally isolated data zilles personal communication escape actions resemble external actions harris stm system java harris external actions special potentially costly steps maintain java memory safety pre-registration future external actions escape actions lightweight low-level mechanism language design system interactions escape actions logtm implementing escape actions nested logtm straightforward escape action requires escape flag thread figure transaction escaped escape set nested logtm behaves escape action begin sets escape escape action end clears nesting escape actions implemented software hardware action required nested escape action ends ancestor transaction aborts escape action running abort delayed escape flag cleared version management executing escape actions thread makes log reads writes access coherent memory return latest possibly uncommitted write conflict detection executing escape actions thread makes bits ignores conflicting accesses threads forced writeback correctness argument sketch nested hold executing escape actions behavior affected executing escape action thread invoked transaction level reads values written transaction memory writes data memory thread including transactionally-modified data accessed logtm violations logtm reads escape actions return recent uncommitted write thread reads data modified transaction thread violation return uncommitted data uncacheable block similarly writes blocks read modified transaction thread violation update values immediately writes invalidate remote caches forcing modified blocks back memory leave blocks sticky-s sticky-m state writes memory locations modified ancestors violation update values affect ancestors bits log methods section describes target system assumptions simulation techniques evaluating nested logtm versus flat logtm table summarizes aspects springer douce metaphors program annual workshop pyschology programming interest group carlowe ireland april gnome project gnome libraries release http gnome gnome project gnumeric release http gnome projects gnumeric goldberg robson smalltalkthe language implementation addisonwesley publishing reading green cognitive dimensions notations proceedings hci cognitive ergonomics pages herbsleb metaphorical representation collaborative software engineering proceedings wacc york usa acm press jones standard economic cultural commentary derek jones kaehler patterson taste smalltalk norton company york koffice project kword release http koffice kword laitinen estimating understandability software documents sigsoft softw eng notes lakoff johnson metaphors live chicago press chicago lewis art science smalltalk hewlett-packard professional books prentice hall international hertfordshire lopes dourish lorenz lieberherr aop naturalistic programming companion proceedings oopsla pages york maraia build master microsoft software configuration management practices addison-wesley professional september marca pascal style guidelines sigplan miller newman tests statistical explanation rank-frequency relation words written english american journal psychology ohba gondow mining concept keywords identifiers large software projects proceedings msr york sajaniemi proceedings hcc page washington sheppard curtis milliman love modern coding practices programmer performance ieee computer dec shneiderman software psychology winthrop publishers soloway empirical investigation tacit plan knowledge programming thomas schneider editors human factors computer systems pages ablex norwood stroustrup programming language addison-wesley series computer science addison-wesley publishing reading edition sun microsystems java sdk standard edition release http java sun takang grubb macredie effects comments identifier names program comprehensibility experimental investigation prog lang torvalds linux release http kernel yelick semenzato pike miyamoto liblit krishnamurthy hilfinger graham gay colella aiken titanium high-performance java dialect concurrency practice experience sept special issue java high-performance network computing zipf selected studies principle relative frequency language harvard press cambridge 
parameters system model system processors levels private cache moesi directory protocol maintains coherence highbandwidth switched interconnect single-issue in-order processor model assumes aggressive single-cycle non-memory ipc detailed memory system model includes timing intricacies transactional memory extensions simulation framework virtutech simics conjunction customized memory models built wisconsin gems simics full-system functional simulator accurately models sparc architecture support transactional memory support logtm added simics magic instructions special no-ops simics catches passes memory model experiments section presents experiments isolate performance differences nesting alternatives earlier studies examined benefits transactions locks exercising nesting sorted list versions sorted list microbenchmark table system model parameters system model settings processors ghz single-issue in-order non-memory ipc cache -way split -cycle latency cache -way unified -cycle latency memory -cycle latency directory full-bit vector sharer list migratory sharing optimization directory cache -cycle latency interconnection network hierarchical switch topology -cycle link latency logtm support escape actions correct conditions verify nested logtm performs expected illustrate conditions closed nesting partial aborts closed open nesting open outperform flattening flat sorted list microbenchmark searches shared sorted linkedlist complex elements thread repeatedly begins top-level transaction examines list elements find matching field chosen random microbenchmark versions update global shared counter level-two nested transaction points execution slist-early performs update search slist-late performs searches read-only contention occurs counter update counter updates require compensating action counter unique continuous slist-late left side figure nested logtm closed open improves performance relative flat logtm performance improves avoid complete aborts nested transactions conflict versions perform similarly top-level transaction commits level-two transaction commits limiting long closed flat extend isolation counter slist-early side figure closed nesting partial aborts offers performance improvement open nesting dramatic improvement closed abort occurs level-two transaction difference partial abort complete abort nested transaction occurs early outer transaction abort occurs level-two transaction commits forcing complete abort outer transaction subsumes open achieves performance releases isolation counter level-two transaction commits greatly increasing concurrency results illustrate closed nesting partial aborts improve performance conflicts arise nested transactions occur late top-level transaction conversely open nesting releases isolation improves performance nested transactions occur early top-level transaction b-tree microbenchmark b-tree microbenchmark represents common class concurrent data structures found applications results show closed benefit flat open represents attractive alternative restructuring workload b-tree thread makes repeated accesses shared tree randomly performing lookup probability insert tree -ary b-tree initially levels deep high level operation insert lookup executed top-level transaction inserts encounter full nodes split tree preventing back propagation splits occur level-two closed nested transaction nodes allocated shared free list open closed level-three nested transactions assume presence garbage collector compensating action open nested transactions figure illustrates speedup alternative versions b-tree relative sequential performance speedups exceed threads threads solaris threads bound processors 
speedups cost-effective multiprocessors cost times uniprocessor case chip multiprocessors bottom lines figure labeled flatand closedshow poor speedup flat closed investigation revealed insert transactions frequently contended shared free list entire insert executes single parent transaction flat closed subsume free list parent transaction write set preventing access subsequent inserts parent transaction commits partitioning free list separate lists approximating thread-private allocators eliminates bottleneck expense restructuring benchmark lines labelled flatand closedin figure show good speedup improved allocator difference flat closed discussed earlier open nesting presents appealing alternative allocators openuses open nested transaction access simple non-partitioned free list figure shows opensimple allocator performs closedsimple allocator closedpartitioned allocator results demonstrate programmer library writer choose open nested transaction complexity parallelizing allocator considerable merit approach complex allocators speedup closed open slist-late closed open slate-early figure slist speedup closed nesting partial aborts open nesting flat implementation threads speedup closedflat- closedflat- figure scalability b-tree flat closed nesting closed nesting partial aborts flatand closedor flatand closedfree lists increase concurrency data structures splashs radiosity raytrace cholesky original logtm paper converted selected splashbenchmarks replacing locks transactions leaving barriers synchronization mechanisms unchanged study found flat logtm offered good performance comparable locks modified flat transaction versions radiosity raytrace cholesky adding closed nested transactions open nesting applied data modifications undone isolation released benchmarks lend easily nested transactions radiosity nested locking replaced closed nested transactions raytrace cholesky memory allocation routines walk list elements programs nesting split large transactions smaller transactions partial abort entire list access transaction additionally code modifies list put inside nested transaction optimized raytrace prevent interactions transactions due false sharing ran benchmarks closed nesting partial aborts confirmed chung finding closed nesting programs result due part rarity aborts splashon flat nested logtm escaping open solaris escape action control transfer transactional nest non-transactional system back figure table illustrates escape actions suffice handle hundred open solaris system calls section illustrates nested logtm escaping solaris tlb traps loading tlb non-transactional kernel resuming user-level activity escape actions logtm abort active transaction preserve user kernel isolation handle tlb trap nontransactional mode restart transaction exercise implementations tlb traps singlethreaded microbenchmark walks character array stride figure displays data read rate varying array sizes nested logtm escape actions escape achieves roughly constant performance array size line abort shows escape actions performance degrades rapidly array size increases abort fails make forward progress arrays larger pages -entry tlb tlb map entire array results discussion nested logtm greatest performance improvement flag logtm open nested transactions release isolation early increasing concurrency escape actions improve performance allowing non-transactional trap code execute aborting current transaction improvement closed nested transactions performance benefit transactions abort splashresults concur chung finding closed nesting programs fact benefit splashas flat logtm rarely aborts programs part stalls recently tcc group adapted workloads aborts common partial aborts valuable specjbb processors figure violations dominated execution time flattening time closed nested reduced execution time substantially closed nesting similarly nested logtm workloads stalling mitigate benefit partial aborts conclusions transactional memory systems support closed nested transactions complete aborts flattening selective partial aborts nested transactions open nested transactions newly-proposed escape actions paper expresses behavior alternatives common model implement nesting alternatives recentlyproposed flat log-based transactional memory logtm nested logtm supports closed nesting partial aborts data rate low fetches byte misses figure scalability b-tree multiple allocators open nesting threads speedup openclosed- closedbenchmark footprint data read sec escape abort figure strided array accesses causing tlb traps handled escape actions escape aborts segmenting log stack activation records modestly cache tlb miss second-level tsb miss replicating bits open nesting allowing committing open transaction release isolation optionally save commit compensating actions log non-transactional escape actions commit compensating actions evaluate microbenchmarks demonstrate closed open nesting performance differences sorted list concurrency exposed open nesting b-tree performance improvement closed nesting splashsubset correct operation tlb traps exposed actions strided array future work includes evaluating closed nesting partial aborts open nesting benchmarks representative future workloads plan explore richer semantics open nested transactions escape actions provide complete runtime operating system support acknowledgements virtutech wisconsin condor group wisconsin computer systems lab support daniel gibson flash-or circuit kan zeffer computer architecture affiliates members wisconsin multifacet project helpful feedback work ananian asanovic kuszmaul leiserson lie unbounded transactional memory proceedings eleventh ieee symposium high-performance computer architecture feb blundell lewis martin deconstructing transactional semantics subtleties atomicity workshop duplicating deconstructing debunking wddd june blundell lewis martin unrestricted transactional memory supporting system calls transactions technical report tr-cis- pennsylvania june carlstrom chung chafi mcdonald minh hammond kozyrakis olukotun transactional execution java programs scool workshop oct chung chafi minh mcdonald carlstrom kozyrakis olukotun common case transactional behavior multithreaded programs proceedings twelfth ieee symposium high-performance computer architecture feb chung minh carlstrom kozyrakis parallelizing specjbb transactional memory podc workshop concurrency synchronization java programs june hammond wong chen carlstrom davis hertzberg prabhu wijaya kozyrakis olukotun transactional memory coherence consistency proceedings annual international symposium computer architecture june harris design choices language-based transactions technical report ucam-cl-truniversity cambridge aug harris exceptions side-effects atomic blocks podc workshop concurrency synchronization java programs jul harris fraser language support lightweight transactions proceedings sigplan conference object-oriented programming systems languages application oopsla oct harris marlow jones herlihy composable memory transactions proceedings acm sigplan symposium principles practice parallel programming ppopp june herlihy luchangco moir scherer iii software transactional memory dynamic-sized data structures twenty-second acm symposium principles distributed computing boston massachusetts july herlihy moss transactional memory architectural support lock-free data structures proceedings annual international symposium computer architecture pages korth levy silberschatz formal approach recovery compensating transactions proceedings sixteenth international conference large databases pages san francisco usa morgan kaufmann publishers lebeck wood dynamic self-invalidation reducing coherence overhead shared-memory multiprocessors proceedings annual international symposium computer architecture pages june magnusson simics full system simulation platform ieee computer feb martin sorin beckmann marty alameldeen moore hill wood multifacet general execution-driven multiprocessor simulator gems toolset computer architecture news pages sept mcdonald chung carlstrom minh chafi kozyrakis olukotun architectural semantics practical transactional memory proceedings annual international symposium computer architecture june microsystems opensolaris mutex http cvs opensolaris source xref usr src uts common mutex mohan haderle lindsay pirahesh schwarz aries transaction recovery method supporting finegranularity locking partial rollbacks write-ahead logging readings database systems pages morgan 
kaufmann publishers moore bobba moravan hill wood logtm log-based transactional memory proceedings twelfth ieee symposium high-performance computer architecture feb moss nested transactions approach reliable distributed computing phd thesis massachusetts institute technology moss nesting transactions transact keynote address june moss open nested transactions semantics support workshop memory performance issues feb moss griffeth graham abstraction recovery management sigmod proceedings acm sigmod international conference management data pages york usa acm press moss hosking nested transactional memory model preliminary architecture sketches scool workshop oct parnas criteria decomposing systems modules communications acm dec rajwar herlihy lai virtualizing transactional memory proceedings annual international symposium computer architecture june shavit touitou software transactional memory fourteenth acm symposium principles distributed computing ottawa ontario canada pages aug sun microsystems solaris manual collection man pages section system calls http docs sun app docs doc weikum theoretical foundation multi-level concurrency control proceedings acm sigact-sigmod symposium principles database systems pods pages mar weikum schek concepts applications multilevel transactions open nested transactions morgan kaufmann wisconsin multifacet gems simulator http wisc gems woo ohara torrie singh gupta splashprograms characterization methodological considerations proceedings annual international symposium computer architecture pages june wood hill cost-effective parallel computing ieee computer pages feb zilles baugh extending hardware transactional memory support non-busy waiting non-transactional actions acm sigplan workshop languages compilers hardware support transactional computing june 
estimating impact scalable pointer analysis optimization manuvir das ben liblit manuel ahndrich jakob rehof microsoft research eecs department berkeley fmanuvir maf rehofg microsoft liblit eecs berkeley abstract paper addresses question scalable controlow-insensitive pointer analyses provide level precision required make compiler optimizations rst describe alias frequency metric measures ability pointer analysis determine pairs memory accesses programs aliases kind information variety optimizations remaining independent optimization show controlow context insensitive analyses provide answer pointer analysis statically generated alias queries order understand potential run-time impact remaining queries weight alias queries dynamic execution counts obtained pro data flow-insensitive pointer analyses accurate weighted alias queries examine scalable pointer analyses inaccurate remaining alias queries context-insensitive end developed context-sensitive pointer analysis serves general engine tracing values programs knowledge rst technique performing context-sensitive analysis subtyping scales millions lines code algorithm identify fewer aliases contextinsensitive analysis introduction programs written typically make widespread pointer variables order analyze program pointers perform pointer analysis computes dereference point program superset set memory locations accessed dereference points-to sets perform alias analysis optimizing compiler memory accesses points-to sets intersect aliases alias information utilized variety optimizations including limited code scheduling register allocation loop unrolling constant propagation years wide variety algorithms pointer analysis proposed including egh ste algorithms scale large programs believed produce poor alias information reason optimizing compilers perform global pointer analysis forced make conservative assumptions potential aliases paper argue scalable pointer analyses produce precise alias information interested determining scalable pointer analyses impact variety optimizations avoid evaluating pointer analyses context speci optimization speci compiler develop metric alias frequency measures frequency pointer analysis forced assert pair statically generated memory accesses program aliases experiments show alias frequency scalable pointer analyses das algorithm das alias frequency pointer analysis result extremely encouraging alias queries scalable pointer analyses imprecise queries greatest impact optimization code queries dominate run-time programs weight responses alias queries dynamic execution counts pro data expect large gap alias frequency das algorithm pointer analysis experiments show das algorithm pointer analysis terms weighted alias frequency source remaining inaccuracy das algorithm lack context-sensitivity understand impact limitation developed algorithm context-sensitive version das algorithm generalized level golf algorithm level idea das achieve limited form context-sensitivity addition subtyping results show appreciable decrease alias frequency context-sensitivity golf general engine tracing values programs pointers indirect function calls context-sensitive manner applications program slicing tip escape analysis ruf golf rst context-sensitive analysis subtyping scales millions lines code golf improve alias frequency provide precise results context-insensitive algorithm client analysis context-sensitive section summary make contributions present alias frequency metric measuring impact pointer analysis optimization demonstrate scalable pointer analyses produce precise responses alias queries test programs show addition context-sensitivity improve alias frequency scalable pointer analyses present golf ow-insensitive pointer analysis utilizes limited amount context-sensitivity subtyping produces pointsto graph linear size program linear time points-to sets program extracted graph cfl-reachability worst-case cubic time show test programs golf linear time space requirements show limited forms context-sensitivity subtyping golf provide precision algorithms full polymorphism subtyping claim golf provide precision algorithm full polymorphic subtyping rest paper organized section motivate golf describe golf section section present alias frequency section present empirical results discuss related work section conclude section fragment program function calls shown return idi idj goal context-sensitive pointer analysis avoid confusing addresses returned function variables calls pqi points-to information computed das algorithm shown points-to graph shown nodes representing memory locations edges representing pointer relationships node single pointer edge target node represents location points-to graph includes special edges labeled nodes flow edges introduced assignments level points-to graph expressions involved assignment program implicit assignment parameter induced function call introduces edge node pointer target node indicating set symbols represented include return statement induces implicit assignments result set symbols represented includes execution program address ows pointed authors previous work rhs problem arises owing call site allowed erent call site points-to graph produced golf shown label edges arising function calls identi ers edges call site identi edges polarity indicating owing called function graph included set symbols path edge labeled edge labeled valid path calls returns matched edge labeled matched edge labeled valid path golf graph sequence labels forms string context-free language matched labels presence valid paths pair nodes determined worst-case cubic time cfl-reachability queries rhs das algorithm golf achieve scaling partly limiting edges level points-to graph uni cation type equality rules merge nodes lower levels experiments show restriction context-sensitivity level lead loss precision compared full context-sensitivity golf generalized level flow pointer analysis thought abstract computation models memory locations location set symbols holds contents abstract pointer figure location points-to contents pointer information locations encoded points-to graph nodes represent locations edges represent points-to relationships steensgaard uni cation-based algorithm ste ect assignment equate contents locations achieved unifying equating ids contents locations pointed-to representative location das algorithm extends steensgaard algorithm pushing ect assignment processing level chains points-to graph figure ect assignment introduce special edge pointed-to location pointed-to location equate contents pointed-to locations figure flow edges relate ids locations symbols source edge included target edge assignment processing represented declaratively figure type rule program correctly typed pointed-to locations contents pointed-to location subset pointed-to location golf extends das algorithm treating implicit assignments induced function calls special manner obtain context-sensitive information fxg fyg symbols locations ids sng values ptr ptr ptr welltyped fig assignment processing das algorithm figure shows points-to graph processing domains type rule gure provide declarative speci cation assignment processing fpg fyg fxg frg ptr ptr welltyped welltyped fun welltyped fig function call processing golf graph fragments represent points-to information processing call function argument call site ease exposition assume functions normalized statement fun nes function single formal parameter parameter holds return statement body labeled constraints generated function calls similar instantiation constraints polymorphic type inference hen direction constraints negative polarity reversed match direction values ect function calls golf shown figure parameter passing induces edges labeled call site identi polarity figure polarity direction values called function formal parameter function return statement function call processing represented declaratively type rules function nitions function calls figure called function generates special labeled constraints ids pointed-to locations contents pointed-to locations equated labeled constraints similar subset constraints labels restrict ways constraints composed transitively explained section 
rule invalid values arises edge labeled representing values function call site edge labeled representing values back erent call site valid paths set valid paths characterized precisely grammar shown sequence labels encountered path edges forms string path valid path sequence labels forms string context-free language recognized non-terminal declarative speci cation golf algorithm viewed set non-standard type inference rules simple language pointer related assignments set rules includes rules figure rules das algorithm handling kinds explicit assignment statements shown welltyped ptr welltyped ptr welltyped ptr welltyped correctness claim type rules figure provide speci cation correct ow-insensitive context-sensitive pointer analysis observation type rules viewed restriction type system presented rehof ahndrich type system shown correct nes algorithm full subtyping polymorphism golf type rules algorithm level subtyping level polymorphism formal connection constraint satisfaction type inference rules valid paths golf points-to graph connection provided global storage goal golf identify valid induced function calls programs include global variables functions occur global variable labeled edge produced pointsto graph reps suggested treating globals extra parameters lead large increase size points-to graph identify nodes globals call global storage nodes add loops nodes labeled call site polarity conservative approximation ensures omit values global variables similar problem occurs indirect accesses pointer valued parameters solution modify function call rule add loops call site label nodes nodes related labeled edges conservative approximation treating nodes global storage nodes operational algorithm symbol referenced program unique location demand program processed assignment time including implicit assignments generated function calls assignment locations uni satisfy type equality requirements imposed non-standard type inference rules figure section processing simple subset constraints labeled constraints delayed introducing edges locations shown figures locations uni edges locations turn loops unlabeled loops discarded labeled loops retained order capture valid golf graph edges das points-to graph practice increase edge count low processing entire program complete points-to sets produced points-to graph symbol included points-to set dereference valid path node node reps observed presence path determined cfl-reachability queries rhs single-source queries symbol program populate points-to sets global storage identify mark global storage nodes linear scan points-to graph adding linear number edges global storage node account ect edges implicitly valid path node node global storage node valid path node node valid path node node unmatched labeled edges path matched set edges words ect global storage node introduce transitivity cfl-reachability queries leads modi reachability procedure node reachable node reach stepping global storage nodes valid paths hop global storage node complexity algorithm steps assignment processing step produces points-to graph edges propagation step rst step complexity steensgaard algorithm linear space linear running-time size program implicit assignment addition single labeled edge number implicit assignments linear presence indirect calls single signature target functions call site ste step involves cfl-reachability query graph symbol program worst-case cost all-pairs cfl-reachability query graph cubic number graph nodes rhs complexity golf cubic size program cient cfl-reachability subsection explain insights ciently compute points-to sets large programs memoization rst insight simple memoization borrowed das amortize cost multiple queries avoiding repeated work experiments show points-to graph single node blob large number outgoing edges graph blob order magnitude outgoing edges node set symbols valid paths blob symbol repeat scan subgraph originating blob perform scan blob cache result share symbols reach blob pre-compute set nodes reachable blob frontier nodes set symbols reach blob symbol reach blob perform forward scan dereference nodes usual symbol reaches blob perform forward scan stop frontier nodes processed symbols append symbols reach blob points-to set frontier node symbol compose scan blob scan symbol cfl-reachability transitive treating nodes reachable symbol blob global storage node compose loss precision programs blob global storage node extremely small require memoization hand frontier nodes scan symbol arrives matching requirements valid path scan blob stop scan nodes compose scan blob fail visit nodes identify cases scan symbol continue scan frontier node simple memoization results dramatic speedup empirical evidence shows scans involve blob amortize scan cost remaining scans cover small regions graph existence blob coincidence ects presence global variables referenced program blob node accumulator large points-to sets sets poor targets improvement precise pointer analysis shrink small sets precise analysis spend considerable resources tracking global variables points-to sets reach blob targets precise analysis global storage insight transitive behaviour global storage nodes make single scan cient global storage nodes serve points divide conquer strategy form longer valid paths shorter valid paths enforcing matching requirements summary edges algorithm single cfl-reachability query based demand algorithm outlined horwitz hrs improves ciency queries adding special summary edges graph adapted algorithm handle nodes shared functions uni cation handle global storage alias frequency interested estimating impact pointer analysis compiler optimizations manner independent optimizing compiler optimization previously ned measures precision pointer analysis independent optimization average points-to set size number singleton points-to sets provide indication ability pointer analysis enable optimizations identifying memory accesses aliased propose alias frequency metric estimates precision alias information produced pointer analysis simple alias frequency program queries set alias queries query involves pair memory access expressions occuring statically program alias frequency pointer analysis percentage queries analysis refer memory location execution program simple alias frequency queries queries aliases alias queries extreme approach generating alias queries pairs memory accesses encountered program result large number pairs accesses erent functions pairs uninteresting typical optimizer optimize code function boundaries alias queries memory access expressions occur body function duplicate pairs queries represent intra-procedural optimizations performed commonly compilers expressions multiple dereference operators order limit number queries top-level memory accesses assignment expressions conditional expressions function arguments experimented erent criteria selecting queries including subexpressions nested dereferences ignoring function arguments found results remain consistent categorizing queries categorize memory accesses based require pointer information resolve symbol-access recursively symbol-access variable eld access operation symbol-access array index operation symbol-access array type remaining memory access including dereference arrow operation array index operation object pointer type pointer-access alias query relating symbol-accesses answered pointer analysis symbol-accesses refer variable aliases var var measuring pointer analysis pointer analysis produces points-to set pts expression set pts fvar gfor symbol-access answer queries involving pointer-accesses accesses aliases points-to sets overlap pts pts notice queries include aliases globals locals referenced body function measuring worst pointer analysis interested understanding gap alias 
precision scalable pointer analyses precise algorithms create arti cial lower bound analysis under-estimates alias frequency safe pointer analysis treating query involving pointer-access aliased exception golf determines pair accesses refer single stack global symbol lower bound analysis treats pairs aliases pts pts fvg lower bound analysis property precise pointer analysis alias query pointer analysis close alias frequency lower bound analysis close precise safe pointer analysis create arti cial upper bound analysis treating query involving pointer-access aliases upper bound analysis form pointer analysis program metric over-estimates alias frequency lower bound analysis pair accesses variable aliases accesses refer erent structure elds concerned erence analysis lower bound pairs accesses access pointer-access lower bound analysis treats pairs aliased pointer analyses potentially improve response queries eld distinction pairs symbol-accesses analyses including lower bound analysis equally lack eld distinction leads conservatively over-estimate precision gap pointer analysis lower bound analysis weighted alias frequency mentioned introduction estimate potential impact run-time alias queries pointer analysis produces possibly inaccurate response weight response analysis query sum dynamic execution counts num num gathered pro data accesses query weighted alias frequency queries num num queries num num small erence weighted alias frequency pointer analysis lower bound analysis means precise pointer analysis enable additional optimizations improve run-time signi cantly create dummy symbols dynamic allocation site represent heap storage lower bound analysis treat accesses heap symbol aliases pointer analyses argument applies accesses static arrays program loc ast nodes time compress ksim ijpeg perl vortex gcc word table benchmark data program table shows lines code ast node count running-time seconds golf experiments produced modular implementation golf ast toolkit extension microsoft visual compiler implementation handles features details found das implemented golf modifying rules parameter passing return statements implementation das algorithm adding cflreachability engine implementation das algorithm tested extensively usual testing veri correctness implementation golf ways performed reachability queries forward backward memoization veri results case tested implementation cflreachability treating labeled edges unlabeled verifying obtain points-to sets das algorithm benchmark programs table shows benchmark programs consisting integer benchmarks spec version microsoft word benchmark list total lines source code including comments blank lines number ast nodes accurate measure program size analysis time seconds golf averaged runs analysis time includes time analyze compilation unit excluding parse time time write object les time read object les perform uni cations compute points-to sets exhaustively static dereference points program cfl-reachability experiments conducted dell desktop running windows ram single mhz intel pentium iii processor alias precision pointer analysis table shows simple weighted alias frequencies pointer analyses obtained execution counts computation weighted alias frequency instrumenting benchmarks running spec program simple alias frequency weighted alias frequency lower golf das ste upper lower golf das ste upper compress ksim ijpeg perl vortex gcc word average table precision pointer analyses benchmark program table shows simple alias frequency lower bound analysis lower golf das algorithm das steensgaard algorithm ste upper bound analysis upper erence simple alias frequency das lower data shown weighted alias frequency obtain dynamic execution counts word inputs data shows scalable pointer analyses surprisingly close lower bound analysis das algorithm lower bound analysis alias queries benchmark programs understand loss precision scalable pointer analysis manually examined fraction queries das algorithm ers lower bound analysis found case lower bound analysis unsound straightforward eld distinction resolve query aliased gap alias frequency scalable pointer analyses pointer analysis fact data table shows erence weighted alias frequency das algorithm lower bound analysis similar erence simple alias frequency benchmark claim queries das algorithm inaccurate provide signi additional opportunity optimization benchmarks erences weighted alias frequencies analyses similar erences simple alias frequency analyses argue simple alias frequency indicator precision implementors pointer analysis access pro data optimizing compilers consume alias information produced analyses input gcc consists source les ran gcc largest source les averaged execution counts das golf table shows alias frequency das algorithm improved addition context-sensitivity benchmark word data shows practice scalable pointer analyses sacri optimization opportunity lack context-sensitivity ste data shows steensgaard algorithm surprisingly close lower bound analysis poor precision algorithm terms points-to set size table largely pollution points-to sets occurs steensgaard algorithm leads accumulation variables functions pollution result conservative alias relationships pointer variables function smaller points-to sets imply lower alias frequency smaller sets subset common symbols finally points-to set sizes arti cially ated inclusion symbols scope table table show traditional measures precision pointer analysis ect ability analysis produce good alias information das andersen previous work das shown das algorithm andersen algorithm produce identical points-to sets alias frequencies expected identical limitations measure alias frequency evaluating pointer analysis signi cantly improve alias frequency analysis including lower bound analysis adding structure eld analysis array index analysis results apply programs apply programs written java open question aggressive inter-procedural optimizers utilize alias information inter-procedurally ruf opportunities ected selection alias queries potential concern results scalable pointer analyses close lower bound analysis swamped query set pairs symbol accesses average queries require form pointer information large percentage form pointer analysis compilers expected generate large number alias queries million queries word query require reachability points-to graph amortization technique section answer alias queries extremely ciently answer queries word minutes regions program accurate analysis eliminate aliases instance linked list traversal previous current pointers results show approach rst run scalable pointer analysis apply precise shape analysis locally functions functions identi alias frequency performance precision golf performance gure chart running times golf table ratio running-time program size chart shows ratio fairly steady program size grows indicating analysis scales linearly program size golf requires roughly time memory das algorithm present detailed data space consumption low golf requires word compress ksim ijpeg perl vortex gccword average benchmark analysistime msper nodes precision scalable pointer analyses table shows precision golf measured traditional metrics table shows average size points-to sets dereference points number singleton points-to sets benchmark previous work size points-to set dereference point number program symbols including dummy symbols produced dynamic allocation sites points-to set dereference expression analyses run settings implementation omit data points-to sets indirect call sites golf improve points-to sets function pointers points-to sets single elements represent opportunites replacing conditional updates strong updates smaller points-to sets lead greater ciency subsequent analyses 
run-time overhead systems instrument code mce data shows golf produces singleton sets das algorithm benchmarks results consistent results foster ffa found improvement precision addition polymorphism pointer analysis subtyping benchmark programs larger ffa greater improvement larger programs precision full polymorphic subtyping golf approximates full polymorphic subtyping algorithm restricting subtyping polymorphism level type structure das shown level restriction subtyping loss precision das data frd onelev columns table shows level restriction polymorphism precision loss golf extracts precision analysis full polymorphism subtyping combination full polymorphism full subtyping eliminate spurious values combination limited polymorphism limited subprogram average thru-deref size singleton sets ste das golf frd onelev ste das golf frd onelev compress ksim ijpeg perl vortex gcc word table precision pointer analyses benchmark program table shows average size points-to sets static dereference points ste das golf polymorphic version steensgaard algorithm frd level restriction frd onelev table shows number dereference points singleton points-to sets found algorithms frd onelev compared directly analyses based rehof implementation polymorphic version steensgaard algorithm frd implementation analyze word typing golf unable perform direct comparison scale polymorphic subtyping large programs context-sensitive clients order populate points-to sets accumulate pointer values function callers points-to set das algorithm golf void read obj obj flockwrap lock lockwrap lock void lockwrap lock facquirelock labeled edges golf produce distinct summaries function behaviour erent call sites summaries leveraged client golf long client context-sensitive instance context-sensitive analysis tracks lockable objects summaries lockwrap produced golf conclude locked rst call lockwrap das algorithm locked call real golf related work golf mentioned introduction work golf long line research context-sensitive pointer analysis precise algorithms controlow-sensitive context-sensitive egh crl clear algorithms scale lines code previous algorithms controlow-insensitive context-sensitive pointer analysis include frd rst algorithms follow edge call graph call graph pre-computed constructed limit applicability large programs large quadratic sized call graphs due indirect calls hand frd appears scale provide degree subtyping important larger programs golf context-sensitive algorithm subtyping scales large programs extension das algorithm das apply level idea restrict polymorphism losing precision borrow caching technique speed computation golf viewed restriction rehof ahndrich general polymorphic subtyping framework modi cations account uni cation globals pointers golf viewed variant reps horwitz sagiv framework rhs golf scalable instantiation frameworks liang harrold mechanism extracting contextsensitivity context-insensitive pointer analyses approach add context-sensitivity das algorithm clear golf compare resulting analysis ruf ruf foster ffa reported empirical investigations added precision provided context-sensitive pointer analysis argue gain precision context-sensitivity results consistent extend conclusions larger programs real golf context-sensitive analysis produces polymorphic summaries function behaviour impact ow-insensitive pointer analysis issue addressed paper usefulness controlow-insensitive pointer analyses compiler optimizations conventional wisdom lack ow-sensitivity structureeld distinction severely limit usefulness scalable pointer analyses empirical evidence support belief fact studies produced results contradict idea dmm cheng hwu shown context-sensitive pointer analysis subtyping enable optimizations compiler result inspired develop scalable context-sensitive pointer analysis subtyping hind pioli shown ow-sensitivity impact precision pointer analysis diwan shown java optimization ow-insensitive pointer analysis precision exploited optimizer dmm results consistent studies previous work alias frequency estimate impact pointer analysis compiler optimizations diwan studied ect pointer analysis java optimization levels including static points-to information optimization opportunities enabled run-time improvement dmm ideally repeat study conceivable optimization pointer analysis propose weighted alias frequency practical replacement large set experimental studies avenue improvement precision suggested results run scalable analysis globally apply precise analysis locally rountev proposed idea rrl results provide evidence supports approach steensgaard algorithm scalable global analysis golf global analysis lead greater precision alias frequency measure framework identify target functions precise analysis conclusions paper provided experimental evidence support claim scalable pointer analyses provide precise alias information programs strong argument routine scalable pointer analysis optimizing compilers developed framework measuring impact pointer analysis compiler optimizations manner independent optimization optimizing compiler finally presented golf rst algorithm trace values large programs providing degree subtyping context-sensitivity method analysis large programs scalable global analysis conjunction expensive local analysis acknowledgements tom reps rakesh ghiya helpful discussions jim larus anonymous referees suggestions paper andersen program analysis specialization programming language phd thesis diku copenhagen diku report cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation proceedings acm sigplan conference programming language design implementation crl chatterjee ryder landi relevant context inference acm sigplan symposium principles programming languages das das uni cation-based pointer analysis directional assignments proceedings sigplan conference programming language design implementation dmm diwan mckinley eliot moss type-based alias analysis proceedings acm sigplan conference programming language design implementation egh emami ghiya hendren context-sensitive interprocedural points-to analysis presence function pointers proceedings acm sigplan conference programming language design implementation ffa foster ahndrich aiken polymorphic versus monomorphic ow-insensitive points-to analysis proceedings international static analysis symposium frd ahndrich rehof das scalable context-sensitive analysis instantiation constraints proceedings acm conference programming language design implementation hen henglein type inference polymorphic recursion acm trans program lang syst hind pioli assessing ects ow-sensitivity pointer alias analyses international static analysis symposium pisa italy number lncs pages springer-verlag hrs horwitz reps sagiv demand interprocedural data analysis acm sigsoft symposium foundations software engineering sigsoft software engineering notes liang harrold cient points-to analysis program analysis proceedings acm sigsoft symposium foundations software engineering liang harrold light-weight context recovery cient accurate program analyses proceedings international conference software engineering june landi ryder safe approximate algorithm interprocedural pointer aliasing proceedings acm sigplan conference programming language design implementation mce mock chambers eggers calpa tool automating selective dynamic compilation annual international symposium microarchitecture december micromonterrey california december rehof ahndrich type-based analysis polymorphic subtyping cfl-reachability proceedings annual acm symposium principles programming languages january rhs reps horwitz sagiv precise interprocedural data analysis graph reachability symposium principles programming languages popl san francisco california rrl rountev ryder landi dataow analysis program fragments proceedings european software engineering conference acm sigsoft symposium foundations software engineering ruf ruf context-sensitive alias analysis reconsidered proceedings acm sigplan conference programming language design implementation ruf ruf ective synchronization removal java proceedings sigplan conference programming language design implementation shapiro horwitz ects precision pointer analysis lncs international symposium static analysis springerverlag ste steensgaard points-to analysis linear time conference record acm symposium principles programming languages tip tip survey program slicing techniques journal programming languages wilson lam cient context-sensitive pointer analysis programs 
proceedings sigplan conference programming language design implementation 
extracting output formats executables junghee lim junghee wisc thomas reps reps wisc ben liblit liblit wisc computer sciences department wisconsin-madison abstract describe design implementation ffe file-format extractor analysis tool works stripped executables source code debugging information extracts output data formats file formats network packet formats construct hierarchical finite state machine hfsm over-approximates output data format hfsm defines language operations generate output data value-set analysis vsa aggregate structure identification asi annotate hfsms information partially characterizes output data values vsa determines over-approximation set addresses integer values data object hold program point asi analyzes memory accesses program recover information structure aggregates series filtering operations performed over-approximate hfsm finite-state machine result final answer easier understand experiments ffe uncovered bug image-conversion utility png ico introduction reverse engineering helps gain insight program internal workings performed retrieve source code program source code lost analyze program malicious virus fix bug improve performance program paper describes reverseengineering tool human understand program produces output cots commercial off-the-shelf software increasingly deployed source code documentation proprietary intermediate formats reverse engineering increasingly needed work supported part nsf grants ccfand ccrand onr contracts dayton madison usa interoperability cots tool proprietary file format interoperability inhibited tool tool chain consumer producer files format technique presented paper promotes reuse components tool chain software engineer build program process files cots software product generates tool obtain information format specification creating program act substitute consumer producer technique presented malware detection instance identify live versions malware figure format network traffic technique provide problem technique provide summary program behavior produces structure consists reduced number entities compared call graph instance make easier understand program contributions work technique extracting overapproximation program output data format including extract preliminary structure output data format elaborate structure annotating information output values sizes simplify structure provide greater understanding output data format information lead greater understanding program behavior report experimental results applying ffe applications experiments uncovered bug png ico concentrated problem extracting output file formats executables approach applied source code advantage information program variables declared types extracting input file formats remainder paper organized discusses key observations inspired work assumptions approach explains process constructing structure output data format overview infrastructure implementation based discusses elaborate structure generated step static analyses presents series filtering operations making hfsms understandable describes validated ffe presents experimental results describes related work describes future directions observations assumptions programming styles section makes observations programming styles typical application programs produce output data programming styles relevant writing output data categorized individual writes bulk writes present approaches tailored handle sections programs styles tool capable handling programs void put byte char void put long long void writes char void type switch case put byte break case put byte break void chksum put long void fill data put byte void main put long magic put long magic writes filename type put long size chksum return figure individual writes individual writes programming style write individual data items separately file network standard functions fputs fputc programs practice wrapper functions tend frequently fig shows programming style wrapper functions put byte put long writes fields output including magic numbers types sizes checksum written calling wrapper functions functions provide api append output items internal buffer buffer filled contents buffer flushed buffer written bulk individual calls wrapper functions represent individual writes referred style refer standard functions user-defined wrapper functions output functions output operation operation relevant generating output data object specifically term output operation defined call site calls output function standard library function wrapper function lines fig experience application programs coded programming style instance gzip compress png ico follow programming style typedef struct header byte magic char char type long size long chksum header void write file header header malloc magic strcpy type size chksum fwrite sizeof header write data figure bulk write bulk writes programming style structs classes manipulate headers fig shows header structure write output data header struct object created line field struct set lines finally lines object written file entirety programming style calls fwrite output operations practice observed tar cpio aggregate structures storage preparation bulk write suspect style headers applications output files consist sequence records user-supplied information current implementation user identify output functions supply additional information information outputrelevant parameter numeric written gzip source macros functions output operations call sites gzip executable compatible approach user identify output operations supplying names output functions convert gzip output operations visible procedure calls proof concept experimental study modified gzipsource code change output macro definitions explicit functions automatically identifying low-level code fragments represent output operations remains challenging problem future work address pointing memory data written bytes written details case standard functions information step approach hierarchical finite state machine hfsm represent output data format hfsm structure nesting finite automata states allowed hfsm captures commonalities organizing states hierarchy note points hfsms languages paths recursive hfsms context-free languages languages paths non-recursive hfsms regular languages call bar foo bar baz call bar call baz call baz figure fsm hierarchical fsm non-recursive hierarchical fsms exponentially succinct conventional fsms due sharing illustrated fig construction hfsm code fragment shown fig explain approach code emulates archive utility writes magic numbers file layout type size check-sum wrapper functions fig shows disassembled code generated idapro procedure involved output operation rise fsm program wrapper functions include put byte disassembled code put long writes calls functions represent output operations ffe finds output operations constructs hfsm based cfgs provided codesurfer analyzer creates reduced interprocedural control-flow graph hfsm projection interprocedural control-flow graph enter nodes exit nodes call nodes output operations fig shows outcome running ffe node hfsm output operation call put long call put long call write bytes call fill data call put long call type call chksum call put byte call put long call put long call put long figure hfsm fig shaded boxes signify calls fsms dotted lines implicit connections fsms proc type push ebp mov ebp esp esp mov eax ebpmov ebpeax cmp ebpjz short loc cmp ebpjz short loc jmp short loc loc mov eax ebpd mov esp eax call jmp short loc loc mov eax ebpa mov esp eax call loc leave retn proc chksum push ebp mov ebp esp esp mov eax 
ebpd mov esp eax call leave retn proc fill data push ebp mov ebp esp esp loc cmp ebpjz short loc movsx eax ebpmov esp eax call jmp short loc loc leave retn proc main push ebp mov ebp esp esp esp fffffff mov eax add eax add eax shr eax shl eax mov ebph eax mov eax ebph call call main mov eax ebph mov esp eax call mov eax ebpch mov esp eax call mov esp mov eax ebpce mov esp eax call call call mov eax ebpe mov esp eax call call mov eax leave retn figure disassembled code fig transparent boxes output operations shaded boxes calls sub-fsms call-site sub-fsm type call-site node represents call sub-fsm implicitly connects fsms hfsm hfsm generated tool gzip shown fig thesis hfsms including elaborations refinements hfsms explained provide basis gaining understanding program behavior regard instructive compare hfsm program call graph call graph structure programmer gain high-level understanding program fig shows part call graph gzip gzip composed control-flow graphs cfgs cfg nodes call sites hfsm produced tool appears complicated substantially complicated program call graph interprocedural control-flow graph hfsm gzip fsms nodes call sites entry call call call call call call call call entry entry call call call call entry call call entry dfd call entry call call call call call call entry call entry entry entry entry call call call call call call call call entrycall call call call call call figure hfsm gzip fragment call graph gzip existing infrastructure ffe intermediate representations irs provided codesurfer framework fig analyst powerful flexible platform investigating properties behaviors executables codesurfer includes static analyses including set analysis vsa aggregate structure identification asi executable disassembleexecutable build cfgs ida pro vsa asi connector codesurfer back-end file format extractor codesurfer figure organization codersurfer ffe interacts components vsa combined numeric-analysis pointeranalysis algorithm determines over-approximation set numeric values addresses memory location holds program point asi recovers information variables types aggregates including arrays structs variables recovered asi vsa obtain information variables values values recovered vsa asi identify refined set variables codesurfer runs vsa asi repeatedly quiescence user-supplied bound reached vsa asi quiesced bound reached codesurfer initial estimate program variables call graph control-flow graphs cfgs program procedures provided idapro idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete contrast codesurfer values vsa discovers resolve indirect jumps indirect calls supply sound over-approximation call graph discusses ways vsa asi exploited purposes augmenting hfsm static-analyses information section explain exploit static analyses mentioned elaborating hfsms set analysis hfsm generated method information understanding output format hfsm made precise annotating additional information label node information size bytes data node represents over-approximation written values interest actual parameters formal parameters output functions suppose put byteis output functions fig suppose call sites safe results final round vsa round vsa over-approximation set numeric values addresses memory location modulo treatment memory-safety violations due loss precision vsa details void put byte char outbuf outcnt uch outcnt outbufsize flush outbuf mov byte ptr esp call put byte figure code fragment put byte output function call sites call output operations calls put byte output operations actual parameter fig information obtained information collected vsa note call put byte relevant stored stack byte pointed byesp abstract memory configuration amc vsa call site instance fig illustrates values amc tool obtain overapproximation set values actual hold evaluating operand expression esp amc amounts amc contents cell cells esp point result singleton set buf ptr size count esp esp size fhvalue size size count number bytes written size size esp figure obtain information vsa kinds parameters passed output function numeric values addresses numeric values case actual parameter holds numeric explained fig size obtained asi infers size usage pattern formal parameter called function case output operation calls standard function information signature function put bytewould -byte argument put short -byte argument addresses type formal parameter pointer set addresses memory location actual parameter amc values cells actual parameter point fig case fwrite lines fig falls category address heap-allocated memory location data passed argument size tfwrite constvoid buf ptr size size size count file product parameters fwrite number bytes written fig roles kind abstract recovered vsa suggests role singleton vsa recovers singleton actual parameter output operation parameter correspond magic number reserved field set numeric valuesif vsa recovers non-singleton set numeric values parameter correspond optional field topif vsa top means actual parameter output operation parameter correspond variant data aggregate structure identification mentioned programmers frequently struct class collect data written char outpack maxpacket static void pinger void register struct icmphdr icp register int int icp struct icmphdr outpack icpicmp type icmp echo icpicmp code icpicmp cksum icpicmp seq ntransmitted icpicmp ident sendto char outpack whereto sizeof struct sockaddr figure code fragment illustrate asi information fig shows fragment ping network packet constructed writing individual data items time output operations struct object store output data multiple fields prepared shown lines fig aggregate object written lines aggregate structure identification asi unification-based flow-insensitive algorithm identify structure aggregates program read write part memory object encountered asi records memory object subdivided smaller objects consistent memory access assume user sendto gnu library function mov eax dword ptr ebp mov byte ptr eax mov edx dword ptr ebp mov byte ptr edx mov eax dword ptr ebp mov word ptr eax mov eax dword ptr ntransmitted mov edx dword ptr ebp mov word ptr edx dword ptr ntransmitted mov eax dword ptr ident mov edx dword ptr ebp mov word ptr edx global struct byte outpack byte outpack byte outpack byte outpack byte outpack figure disassembled code fragment fig outcome asi output function argument sendto pointer struct object unknown substructure asi information substructure instructions correspond assignment statements lines fig shown fig lines vsa information extent memory accessed instructions asi information subdivide portion memory accessed producing structure shown fig structure packet header consist -byte fields -byte fields asi capable recovering information structure aggregates allocated heap illustrates case output function emits completely-constructed chunk output data hfsm represents program output operations high level abstraction bulk writes structure information recovered asi identifying structure output data format fig 
pinger call sendto elaborated sequence -byte header-field writes larger packet payload filtering hfsm hard understand experimented applying series filtering operations including simplification conversion fsm regular expression inline expansion generate simpler representation output format regular expression experiments manually process easy automate simplification nodes hfsm helpful understanding output format unnecessarily complicated hfsm prevent users understanding key aspects output format portions hfsm shown fig turn top-value top-size unbounded loop includes top-valuemeans node top-size means node size cases node node set provide meaningful information node top-size top-value node set unbounded loop top-size top-value considered meaningful node node node non-top-size algorithm simplification algorithm input hfsm output trimed hfsm set status fsms meaningful exists meaningful fsm non-meaningful nodes calls non-meaningful fsms set non-meaningful fsm transform fsm self-loop node labeled top-size top-value end alg describes algorithm simplifying hfsms generated ffe idea algorithm cases mentioned fsm consists nodes top-value top-size unbounded loop includes items simplify top original fsm provide meaningful information output format size top top size top top call size top top size top top size top top call size top top figure simplification fig shows simplification shaded fsm non-meaningful fsms non-meaningful nodes simplified unbounded selfloop consisting node top-size top-value conversion regular expression convert fsm hfsm regular expression kleene construction expansion final step apply inline expansion recursion encountered applications experiments inline expansion applied worrying nontermination recursion encountered summarized strongly connected components call graph fig represents final outcome techniques size size size top top size top size size size top size top figure final result simplification conversion inline expansion validation dynamic output validate approach testing outcome algorithm regular expression matches output data produced actual runs application flex tool generating scanners compilers input specification form list pattern-action pairs pattern regular expression flex generates program repeatedly finds longest prefix remaining input matches patterns create tool testing regular expression generated algorithm describes output application give flex -pattern specification consisting action report success default pattern action report failure discussed earlier box shown fig regular expression generated technique labeled kinds information size size top singleton set numeric values singleton set numeric values top feed flex regular expression transformed basic unit -byte character table shows transformation rules applied boxes table transformation boxes size conversion singleton singleton split multiple boxes -byte box fig transformed boxes fig singleton top top transformed matches character transformed sequence boxes box fig transformed boxes fig top top transformed box self-loop box fig transformed box loop fig table describes cases size singleton top note case size top non-top outcome vsa case size set numeric values split shorthand character flex pattern size size top top size size top size top figure transformation means character box multiple boxes singleton singleton size box fig values transformed boxes fig values case size singleton shaded boxes fig show converted note process validation original values sets values understandable human subdivided values experimental results evaluated ffe applications gzip png ico ping gzip gzip gnu data-compression program fig represents outcome filtering hfsm fig size size size size top size top top size top top size top size top size top size top size top figure final result gzip table part specification gzip format xflmtimeflgcmid flg fhcrc set isizecrc compressed blocks fixed values xlf identifies compression method reserved demotes deflate compression method flg divided individual bits bit ftext bit fhcrc mtime recent modification time original file compressed xfl specific compression methods identifies type file system compression place fat filesystem amiga crc cyclic redundancy check uncompressed data isize size original input data modulo format files generated gzip rfc table outcome shown fig correctly over-approximates specification words language outcome superset output language gzip outcome magic numbers constant positions shown table -byte element mtime -byte elements toxflandos end -byte elements correspond tocrc isize applied validation process outcome flex-generated validator accepted files chosen arbitrarily internet png ico size size top size size top size top size size top size size top size size size size top top size size top top size size size top size top size top size top size size size top size top size top figure outcome png ico table unofficial specification ico format size description reserved byte type byte count byte number icons file entries count list icons width byte cursor width height byte cursor height commonly width colorcount byte number colors reserved byte planes byte bitcount byte bits pixel sizeinbytes byte size infoheader andbitmap xorbitmap fileoffset byte filepos infoheader starts repeated count times infoheader bytes variant bmp infoheader size bytes size infoheader structure width bytes icon width height bytes icon height added height xorbitmap and-bitmap planes bytes number planes bitcount bytes bits pixel compression bytes type compression imagesize bytes size image bytes uncompressed xpixelsperm bytes unused ypixelsperm bytes unused colorsused bytes unused colorsimportant bytes unused colors number-of-colors bytes color map xor-bitmap red byte red component green byte green component blue byte blue component reserved byte repeated numberofcolors times xorbitmap bitmap andbitmap monochrome bitmap png icoconverts png files windows icon-resource files fig shows final outcome compared unofficial specification ico image format table constant data items format recovered ffe fields ico format including reserved type constant values recovered technique structure fig similar table difference format recovered ffe shows loops top level sequence entries sequence structures consist infoheader sequence colors sequence xorbitmaps sequence andbitmaps constrast table shows single infoheader color xorbitmapandbitmap structure inspection source code confirmed png ico supports sequence infoheader color xorbitmapandbitmap structures ffe revealed bug png ico showed format produced png ico satisfy specification table table planes field entries shown eighth box size row fig png icoalways produces discrepency discovered ran flex-generated validator checks conformance png ico output format extracted ffe pre-existing ico files files windows installation created running freeware png ico utility validator rejected files accepted ico files generated png ico tracked problem line png ico source writeword outfile wplanes ping ping sends icmp echo request packets host host reachable network sendto output function ping discussed structure hfsm shown fig represents program output operations high level abstraction hfsm inferred main calls pinger catcher pinger calls sendto pinger sub-fsm fig constructed information recovered sendto asi format sizes successive elements 
bytes shown fig shown fig icmp packet struct includes -byte fields uint icmp type uint icmp code -byte field uint icmp checksum unions icmp hun icmp dun outcome ffe satisfies part specification -byte fields match uint icmp type uint icmp code call sendto size top size top size top size top size top pinger pinger pinger pinger entry pinger pinger size top top pinger exit pinger entry pinger exit catcher entry catcher exit pingermainentry mainexitpinger catcher pinger figure outcome ping hfsm hints program behavior ping packet -byte icmp header data typedefstructicmp uint icmp type type message uint icmp code type code uint icmp checksum complement cksumof struct define icmp cksumicmp checksum union uint pptr icmp paramprob structin addrih gwaddr icmp redirect structih idseq uint icd uint icd seq idseq intih void icmp unreach needfrag --path mtu discovery rfc structih pmtu uint ipm void uint ipm nextmtu pmtu structih rtradv uint irt num addrs uint irt wpa uint irt lifetime rtradv icmp hun define icmp pptricmp hun pptr union structid uint otime uint rtime uint ttime structid structipidi options bits data structicmp addrid radv uint mask char data icmp dun define icmp otimeicmp dun otime icmp figure icmp packet structure -byte field matches uint icmp cksum -byte fields match union icmp hun includes struct idseq consists uint icd uint icd seq union icmp dun discovered asi assignment union code asi partition memory locations union corresponds signal outcome ffe incomplete respect shown fig lines ping calls signal library function signal asynchronous event handling means statically generated control-flow graph cover flows control technique based cfg statically generated codesurfer output operations apvoid signal sitint finish void signal sigalrm catcher preload-pinger options flood catcher struct sockaddr register int size fromlen options flood floodok floodok pinger figure code fragment ping pear handler function signal call establishes resultant hfsm over-approximate outputs related work previous work reverse engineering file formats dynamic manual eilam describes strategy deciphering file formats symbol table sample output file approach requires manually stepping disassembled code inspecting memory contents debugger program produces file approaches ignore program rely heuristic generalization sample output files reverse-engineering case study searched zlib-compressed data file names length bytes typical structures approaches require considerable manual effort guarantee chosen sample files sufficiently general constrast static approach over-approximates file format relying sample files symbol tables extensive manual analysis human intervention needed identify output functions assign higher-level interpretations file selected fields identified analysis similar attempts statically recover information program data christensen presented technique discovering values string expressions java programs context-free grammar generated constructing dependence graphs class files grammar widened regular language strings dynamically generated method christensen applied low-level code christodorescu method string analysis executables approach similar sense executables targets tools recovered output data format analysis represented regular language denotes superset actual output language approach sense initial context-free structure recovered tool structure operations purely internal procedure call-return structure program tool approach related work host-based intrusion detection models expected program behavior constructed model over-approximates sequences system calls comparing actual sequence system calls allowed model detect malicious input hijacked program pushdown-system models employed purpose constructed source code low-level code sparc executables hfsms similar yield context-free languages projection portion program behavior previous work results dataflow analyses vsa asi elaborate models information sets values sizes conclusion future work paper focus output operations approach applied kinds operations treat input operations examining parsing input file approach paper case paths exit points represent successful runs program correspond successful well-formed input files addition apply approach network communication operations parse construct packets suggested referees characterization input language generate test inputs similarly knowledge output language component tool chain source test inputs component chain discussion ping signal calls factor hfsm overapproximate actual output language program description static-analysis tool handle features paper mops approach mops hfsms mentioned earlier assume output functions identified user create automatic tool extracting data formats desirable find automatically identify output functions wrapper functions loop hfsm transformed node-set node-set cases bound number iterations loop obtained vsa cases information loop iteration bounds provide users precise information output format basic file format ico files http daubnet formats ico html compress spec benchmark http itee emmerik specbench html cpio gnu project http gnu software cpio cpio html file format reversing everquest vpk http openrce articles full vew flex http gnu software flex gzip gnu project http gzip ping http packages debian stable net netkit-ping png ico http winterdrache freeware png ico tar gnu project http gnu software tar tar html freebsd linux kernel cross http fxr watson fxr source netinet icmp gzip file format specification version http gzip zlib rfc-gzip html alur benedikt etessami godefroid reps yannakakis analysis recursive state machines toplas alur yannakakis model checking hierarchical state machines fse pages balakrishnan reps analyzing memory accesses executables balakrishnan reps recovery variables heap structure executables tech rep trcomp sci dept univ wisconsin madison sept chen wagner mops infrastructure examining security properites software ccs christensen ller schwartzbach precise analysis string expressions sas christodorescu kidd goh string analysis binaries paste eilam reversing secrets reverse engineering wiley publishing giffin jha miller detecting manipulated remote call streams usenix security symposium giffin jha miller efficient contextsensitive intrusion detection ndss ramalingam field tip aggregate structure identification application program analysis popl pages reps balakrishnan lim next-generation platform analyzing executables aplas reps balakrishnan lim intermediaterepresentation recovery low-level code pepm wagner dean intrusion detection static analysis ieee symposium security privacy 
pennsylvania state scholars program department computer science transformation prolog programs perform update place prototype code synthesizer benjamin liblit april thesis submitted partial fulfillment requirements degree bachelor science honors computer science william winsborough barry pangrle thesis supervisor honors advisor honors chairman mary jane irwin head computer science abstract single assignment languages prolog standard endure considerable inefficiency support declarative semantics lacking destructive assignment programs written languages frequently duplicate large portions structures conventional programs simply modify place paper presents techniques automatically transforming prolog programs perform in-place updates destructive assignment reports evaluates experience prototyping code synthesis portion transformation applicable transformation produces code updates structures times faster implementations vastly memory contents introduction background compile time garbage collection update place positional arguments additional internal predicates implementation issues unravels minimized unravels unravel placement input aliasing destructive assignments upper connection placement destructive update method empirical evaluation benchmarks unravels minimized unravels unravel placement input aliasing destructive assignments upper connection placement destructive update method general results conclusions acknowledgments code synthesizer portability invoking synthesizer input file format predicate reuse clause reuse user options limitations benchmark source code append delete insert merge split tree iii list figures splicing delete memory layout list structure cells list tables minimized versus unsimplified unravels at-need versus early unravels input aliasing versus aliasing tail versus early versus late assignments increment assign versus assign versus setarg speed versus update place versus compile time garbage collection memory consumption versus update place introduction logic functional programming languages recent years restricted realms academia formal theory expressive simplicity high level abstraction make languages attractive tend make inefficient difficult prolog standard related languages compete conventional languages fortran major inefficiency extra work required support single assignment semantics incremental change made large structure multiple assignment language perform updates place modifying fields changed single assignment language hand forced copy structure replacing values overhead allocating memory duplicating data garbage collecting discarded copies hurts performance considerably detect original copy structure reused past point modification update place destructively modifying form structure generate refer structures dead memory cells occupied soon-to-be discarded structures intend reuse specifically static analysis detect arguments predicate function dead memory cells occupied arguments recycled construct predicate function output construct arguments body goals subcalls problem detecting deadness relates directly tracking liveness researchers developed static analysis techniques applied end languages including prolog explicitly identify output arguments cases define output predicate arguments passed free variables predicate called determined static analysis methods ideally programmer continue logic functional languages giving elegance ease expression single assignment affords compiler synthesize equivalent code performs multiple destructive assignment augmented primitives performing simple in-place assignments transformed source efficient memory potentially executing speeds competitive conventional languages earlier attempts applying multiple assignment efficiency single assignment languages demonstrated class optimizations lead significant improvements multiple assignment code produced prior approaches operate efficiently techniques essentially equivalent purposes paper focus review compile time garbage collection ctgc approach alternative technique paper centrally concerned update place uip transformation ctgc uip transformation produces code reuse dead memory cells uip transformed programs avoid difficulties hinder ctgc code performance yielding faster code complete uip transformation stage process stage performs dataflow analyses source program phase deadness detection performed input output arguments identified stage performs reuse analyses dead input cells matched output structures create forming mapping describes specifically memory cells reused problem produce good reuse mappings important open question debray proven related reuse problem complete efficient heuristics find good mappings unclear slightly reuse problem faced uip shares traits discussion relationship debray work uip final stage uip transformation code synthesis based dataflow patterns deduced stage reuse mappings selected stage code synthesizer transforms single assignment programs equivalent programs destructively reuse memory cells create structures prototype code synthesizer programs written prolog developed based formal specifications paper primarily address implementation issues involved creating synthesizer timing memory data provided directly compare performance code ctgc code variations uip code small collection benchmarks section reviews ctgc focusing contexts produces code work section develops intuitive basis type transformation apply contrasting ctgc section discusses implementation issues resolved produce transformed code correct highly efficient section presents empirical studies performance transformed collection benchmarks evaluates impact issues lastly section summarizes author findings discusses broader issues synthesizer incorporation working uip transformation system transformation present fairly general chosen prolog working language implement describe research discussion cross language issues background section introduces previously presented techniques rewriting prolog predicates clauses reuse memory cells dead input structures subsection reviews compile time garbage collection illustrates produce code extra work hampering efficiency subsection introduces present proposal update place uip uip avoids pitfalls earlier attempts resulting faster efficient transformed code compile time garbage collection prior proposal transforming prolog programs reuse dead memory cells compile time garbage collection ctgc destructively modifies cells reused free variables newly allocated heap memory cells ordinarily discarded made reuse reduces garbage collector work load leading faster memory efficient code fields reused cell reinstantiated reinitialized closer examination reveals ctgc transformed code perform needless work nonetheless implementation append concatenates arguments append head tail list head newtail append tail list newtail append list list assume static analysis determined arguments dead calls append argument free variable calls compile time garbage collection update place attempt reuse list cells arguments construct ctgc approach make potentially reassignable fields reused cells free variables essentially fields modify uninstantiated reinstantiated values code realizes ctgc transformation append worth noting ctgc originally proposed optimization warren abstract machine code purpose contrasting uip ctgc conveniently presented source level transformation append front rear front front tail makefree front newtail append tail rear newtail append rear rear ctgc primitive makefree rewrite fields free variables primitive called makefree argnum term -freevar destructively modifies argnum field term resembles uninstantiated free variable newly freed variable freevar ctgc code append field front made free variable referenced newtail works element list nil clause transformed predicate instantiates newtail list rear output argument completed list terminate transformed clause executes head unification unifies arguments tail newtail preceding level recursion newtail reinitialized list referenced tail referencing call makefree time spent destructively unbinding rebinding front field wasted append execution field immediately reinstantiated held transformed code perform faster spend time preparing change fields ultimately end staying update place compile time garbage collection extra 
work modifies reusable cells early update place transformation avoids pitfall performing destructive assignments lazily accomplished replacing output argument clause original predicate recent cell destructively modified assignment made genuinely required convention refer extra argument refer transformed code variable names intuitively cell recycled output structure level recursion understand argument program written conventional language append pair lists front rear pointer head lists composed singly linked nodes specially designated nil node marking termination list straightforward approach step links front reaching nil point previous node link pointer originally pointed nil destructively modified point head rear step front track node traversed successive node final node end list prolog code append transformed update place implements algorithm define means performing basic destructive assignment primitive setarg takes form setarg argnum compoundterm newargument call form replaces argnum argument compoundterm newargument interpretation arguments analogous arg setarg backtrackable trail test performed compoundterm argnum field recorded trail backtracking restore original note setarg provided primitive prolog implementations assignment primitive uip transformed code append append rear rear append front rear front front tail append tail rear front append rear setarg rear append front rear front tail append tail rear front notice immediately transformed code clauses half belonging append half append predicate clauses generated clauses original code call append entry predicate append internal predicate clause original code appears entry internal clause occasionally refer entry internal version clause general entry predicates original predicate called arguments internal predicates modified arguments track called entry versions internal predicates named original predicate additional suffix case suffixes encode additional information explained returning clause entry predicate handles specific case top level call append empty list argument case output simply argument clause identical clause original code clause entry predicate interesting argument front empty list reuse cell make cell output list head unification argument cell body unification grabs tail cell sequence finally clause calls internal predicate append call tail replaces argument rear passed unchanged original code place output argument pass front tail empty list front field destructively changed point rear initial cell internal predicate append handles work repeatedly stepping forward argument maintaining cell traversed clause append recursively walks list level recursion unification cell list current cell passed recursive subgoal clause executed argument empty list implies received caller modified matched head discarded ctgc put work preparing referenced cell assignment extra work recursive traversal ends clause append reached end list argument rear holds list concatenated cell terminating entry empty list argument referenced tail field call setarg destructively reassigns field point rear list pasted end execution complete original code copied cells entire length argument copied single destructive assignment redirects cell list point head positional arguments call setarg notice number field changed hard-coded works append modifying field case predicates code performing insertion binary tree tree insert info leaf tree info leaf leaf tree insert info tree node left tree node newleft info node tree insert info left newleft tree insert info tree node left tree node left newright info node tree insert info newright assume static analysis determined argument dead calls tree insert argument free variable time call update argument place construct intuitively expects transformed code clause perform destructive assignment parent leaf atom argument clause giving tree node info leaf left subtree parent destructive assignment made field track field receive assignment augment internal predicates clauses extra parameter passed body goal additional argument pos accompanies pos specifies field replaced event destructive assignment performed full field pos cell full transformed uip code tree insert tree insert info leaf tree info leaf leaf tree insert info tree tree tree tree node left info node tree insert info left tree tree insert info tree tree tree tree node info node tree insert info tree tree insert info leaf pos setarg pos tree info leaf leaf tree insert info tree tree tree node left info node tree insert info left tree tree insert info tree tree tree node info node tree insert info tree workings code similar transformed append argument traversed internal version clause original code anticipated call setarg assigning predetermined field assign field pos examining internal entry clauses pos passed depending info plugged left subtree node examination additional internal predicates reader noticed internal predicates tree insert suffix number chosen input argument child entry predicate information significant determine clause perform destructive assignment alter relationship clause input arguments append parent argument tree insert parent argument occasions children vary calls input argument traversed merge operation parent input argument possibility input arguments child happen splicing occurs cells input skipped incorporating output reflect situation suffix stray transforming code delete demonstrates suffixes vary depending parent child relationship input arguments predicate removes instances argument list argument placing cleaned list argument implementation delete junk junk oldtail delete junk oldtail delete junk oldtail newtail junk delete junk oldtail newtail delete delete operating modes skipping mode copying mode skipping mode cells match junk discarded output list composed remains unchanged copying mode cells match junk copied output list modes correspond clauses listed uip code delete destructive assignments splice cells dropped code skipping mode figure illustrates visually cell successor updated place skip unwanted junk cells possibility skipping cells recycling uip code delete track information figure splicing delete represents behavior uip transformed code deleting list solid arrows represent list cell changed represented dashed arrow destructively updated lightly dotted arrow detect transitions skipping copying modes copying stops skipping begins copying ended carried sequence skipped cells skipping stops copying begins carried skipped cells destructively modified point cell coming sequence copied cells return figure visiting cell transition copying skipping cells skipped continue pass field cell cell prompts transition back copying mode modify cell field point cell transition skipping copying points transformed delete make assignments arises skipping reach end list case cell final cell output list destructively assigning point nil terminates output list call complete level recursion critical factor distinguishing copying skipping modes rests location relative input arguments parent input arguments copying input arguments child call stray signals skipping cases match description earlier meaning suffixes internal predicates fact tracking input argument child sufficient information transformed code behave correctly pattern discarding reuse delete arguments considered input argument reused moment parent argument 
input argument internal predicates named delete delete stray uip-transformed code delete delete junk junk oldtail delete junk oldtail delete junk oldtail junk delete junk oldtail delete delete junk junk oldtail pos delete stray junk oldtail pos delete junk oldtail junk delete junk oldtail delete delete stray junk junk oldtail pos delete stray junk oldtail pos delete stray junk pos oldtail junk setarg pos delete junk oldtail delete stray pos setarg pos notice start top level call entry predicate skips initial junk cells dropping internal predicate main purpose internal predicates track relationships input arguments recall field recent input cell recycled output input list starts junk cells cells recycled output non-junk cell found point execution remains inside entry predicates internal predicates arity extra argument specifies field number actual delete theory optimize positional argument place constant directly calls setarg sake simplicity present automated techniques applying uip transformation attempt detect situation section examines assignment mechanism extra positional argument eliminated transformed predicates implementation issues gudjonsson formally defines code synthesis process mathematical terms section takes primary intent paper carry specification forward implementation important implementation issues omitted abstract specification actual synthesizer options details realized areas gudjonsson specification makes decisions sake descriptive simplicity lead ideal transformed code implementation questions left synthesizer discretion fall major categories related unravels special type unification related destructive assignments issues unravels section assignments covered section hypotheses inferences developed sections evaluated light empirical data section unravels unravels unifications synthesizer adds bodies transformed clauses serve important purposes obtain substructures parent structure points start list unravel tail tail tail list needed tail passed argument body goal recycled cell destructively assigned incorporate tail alternately destructive assignment scheduled field field current needed obtained destructive assignment performed addition obtaining extant portions structures unravels bind nonground terms static structures convention left hand side unravel unification variable unraveled hand side called template serves template outline structure unraveled formal specification uip transformation unravels liberally redundantly unravel templates unification examine structure deeper needed conditions unravels confound important optimizations potential hindrances optimization work subsections follow describe issues solutions greater detail section evaluates empirically minimized unravels unravels simply obtain substructures simplifications applied composing template unravel underscores substituted entire substructures needed suppose structure appears original program root structure children needed unravel simply substitute variables required subterms giving unravel form instantiated original static structure examine entire substructure child efficient unravel obvious optimization important distinguish contexts safely applied unravel purpose create structure templates simplified underscores substructure obtained subsequent unravels intended retrieve omitted code synthesizer track substructures located prior unravel avoids work optimization thought variant common subexpression elimination synthesizer processing unravels records location subterm obtained goal requires subterm unravel performed cases avoiding redundancy eliminate small handful unravel unifications transformed program final extremely basic unravel minimization template unravel free variable simple atom unified variable unraveled synthesis time causing expressed identically transformed clause trivial variable-to-variable variable-to-atom unification goal body transformed clause unravel placement minimization techniques outlined significantly reduce number unravels transformed programs remain code synthesizer choose transformed body unravel unifications option perform unravels start clause lead clause perform unnecessary work body goal fails obtained goals needed prolog clauses informally structured early goals express guard conditions failures early clause transformed code work failure backtracking strong possibility attractive alternative perform unravels unifications fetch substructures substructures needed earlier similarly unifications bind variables static structure immediately body goals variables unraveled hypothesize late placement unravels hurt performance failures rare improve performance failures occur frequently postponing unravels lend additional benefit reducing number live preserved stack subcalls directly address issue input aliasing unravel issue examination concerns effect uip transformation major optimization determinacy analysis examining static structure arguments clause heads aggressively optimizing aquarius prolog compiler determine clauses predicate mutually exclusive cases execution deterministic aquarius avoid creating choice points trail stack small reduces overhead maintaining append head nil argument list cell assuming calls argument ground clauses mutually exclusive arguments passed call match clause match backtracking occur point choice point created conflict arises code transformed perform uip aquarius analyses begin topmost memory cell input argument reused construct output generally formal specification synthesizer simply replace static structure clause head simple variable unify variable original static structure early clause body series unravels head transformation noting underscores substituted arguments central present discussion head tail lists assume argument list lists input argument needed root argument variable hold head transformed clause begin head tail lists moving unifications head body confounds aquarius determinacy analysis analysis strongest mutually exclusive unifications heads unifications bodies determinism present aquarius advantage anticipate blocking important optimization severely damage performance transformed code alternative input aliasing static structure clause heads obtain root cells input arguments input arguments transformed head original including full static structure input argument add additional argument called input alias appears simple variable transformed clause heads internal calls transformed predicate input argument alias passed identical values head unification input alias root input argument original static structure requiring additional unravels body static structure appears head aquarius determinacy analysis continues function properly input aliasing thusly head tail lists calls original modified original goal form lists heads tails replaced lists heads tails lists work disadvantage increasing arity transformed clauses slow calling process conjecture slowdown extremely small compared cost breaking aquarius determinacy analysis destructive assignments major cluster implementation issues involve destructive assignment directly gudjonsson formal specification adopts simple mechanism adding destructive assignments clause bodies implementing destructive assignment primitive sophisticated placement scheme lead efficient code similarly options exist implement destructive assignment primitive execute faster subsections follow describe destructive assignment issues detail section evaluates implications empirically upper connection placement case unravels exists amount flexibility clause body destructive assignments performed loosely speaking destructive assignments piece memory structures structures body goal assignments performed call earlier pieces structure composed fully processed earlier goals interactions unravels destructive assignments impose partial ordering obeyed preserve proper semantics goal receive incorrectly formed structures arguments destructive assignments assign greater leeway assignment choose perform assignments called upper connections body proper unravels performed case unravels wise postpone assignments long work backtracked event body goal fails postponing assignments long create problems specifically assignments pushed back goals transformed clause tail-recursion last-call optimization applicable original clause longer case input aliasing synthesizer confound important 
optimizations process applying hypothesis placing movable assignments subgoal clause body give performance placing assignments late result code drawn split benchmark split stray tail pos pos split stray tail tail setarg pos setarg pos notice setarg calls perform assignments assignments recursive subgoal giving split stray tail pos pos setarg pos setarg pos split stray tail tail clauses semantically equivalent amenable tailrecursion optimization needless anticipate empirical evaluation show clause execute rapidly destructive update method place destructive assignments exact method assignments performed interesting issue examples introduced earlier setarg simple straightforward approach makes source-to-source transformation portable setarg general tool perform required task efficiently setarg applied type memory cell work change depending actual run time arguments specifically call form setarg argnum compoundterm newargument compoundterm cell standard memory layout memory location modified offset start cell argnum words word offset holds compoundterm functor prolog implementations optimize storage list cells storing words reserving word functor compoundterm list cell memory location modified offset argnum words compile time analyses include aggressive type propagation level builtins setarg perform tag checks conditionally integer decrement call figure illustrates simplified manner figure upper rectangle represents memory layout list cell lower rectangle represents memory layout structure cell notice arguments located word back list cell structure cell list cells standard cells place fields offsets alternative propagate type information uip code synthesis invoke specialized destructive assignment primitives primitives forms assign general argnum compoundterm newargument assign struct argnum structure newargument assign list argnum listcell newargument assign general performs task setarg makes assumptions type compoundterm assign general decrements argnum compensate missing functor field list cell unlike setarg code synthesis time passed body goal represent list cell positional parameter pos decremented synthesizer appears transformed code primitive detailed type information unavailable list standard cell reach destructive assignment point memory cells structures standard memory layout destructively modified assign struct predicate performs tag checking modifies word offset argnum structure lastly assign list modify list cells performs tag checking modifies word offset argnum listcell case assign general assign list decrement positional parameter adjustment performed code synthesizer elimination run time tag checks run time decrements transformed code execute faster expense greater dependence underlying representation memory cells destructive assignment mechanisms presented require consisting memory cell positional parameter representing field number adjusted offset sufficient access underlying memory representation mechanisms condense single parameter information convey location field destructively updated passing cell base offset pass single direct pointer interior cell clause pass body goal obtains proper memory cell increments points directly proper field cell tag free variable passes pointer point destructive assignment offset assign primitive performs simple assignment memory transformed program contained code foo bar bar pos setarg pos increment-before-call scheme eliminate positional arguments transformed code foo increment pointer bar pointer bar assign increment primitive sets pointer point interior offset words increment scheme performing assignments falling trap ctgc performing additional work anticipation destructive assignment performed close scrutiny compiled truth increment primitive exists collection primitives form type type list struct varies reasonable maximum anticipated offset artifact manner primitives added aquarius berkeley abstract machine macros hard wiring constant significantly efficient bam code produced code approach reveals increment primitive executed single register-to-register add operation transfer type load positional argument argument register call add operation takes cycle increment result net slowdown calling end anticipate point destructive assignment extremely simple assign primitive execute rapidly setarg assign reducing arity transformed predicates reduce register pressure facilitating optimizations empirical data follow reveal significant speed differences conjecture setarg generality slowest destructive assigner assign faster fastest performance obtained increment assign empirical evaluation implementation issues difficult resolve confidence real demonstrable variations execution speed found section examines results timing collection benchmarks conditions proposed section cases code tested generated prototype uip code synthesizer directly source augmented special guiding directives detailed appendix subsections follow present choice implementation options comparative timings code variations uip transformed code primary goal determine choices perform synthesis result fastest code programs benchmarks transformed prototype code synthesizer transformed programs compiled release aquarius prolog compiler analyses optimizations enabled time trials conducted unloaded sparcstation ipc ram running environment benchmark executables standard provided aquarius exception trail increased size executable evoked repeatedly twenty executions complete page faults systemand user-mode execution times reported time summed single execution lowest total reported general times vary twenty trials section informally proposed choices synthesizer options expect produce sparcstation registered trademark sun microsystems code tests follow choice varied held constant expected values specifically unravels minimized unravels performed late input aliasing enabled assignments performed increment assign assignments upper connections late clause bodies subgoal benchmarks benchmark suite chosen illustrate performance transformed programs variety contexts programs benchmark suite fairly simplistic earlier reuse analysis stages uip transformation automated selected programs adequately span relevant issues programs uip optimization effectiveness evaluated append list length appended list length delete single integer located deleted list preceded differing integers insert integer inserted ordered list integers requiring members list skipped finding proper point insertion merge ordered list nonnegative integers merged list odd nonnegative integers resulting list ordered split list integers split member output lists list lists split list heads list tails members tree node added simple binary search tree requiring nodes traversed root leaf appendix full source code benchmarks including reuse directives guide code synthesizer unravels section important implementation issues handling unravels synthesizer attempted predict choices result efficient transformed programs subsections follow evaluate accuracy predictions light empirical data drawn benchmark suite outlined minimized unravels measure impact unravel minimization benchmarks executed timed unravels minimized safely allowed attention paid unravel simplification table presents net execution times time ratio transformed code minimized unsimplifiedbenchmark net time net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds unravels minimized versus simplified times tables adjusted reflect update time constant time required construct original input structures subtracted net times reported seconds ratios quotient net time implementation net time transformed program immediately sees minimizing number complexity unravels significant optimization unravels minimized uip code executes times faster code aggressive simplification fastest benchmark times faster code insert executed ten percent slowly examination synthesized code insert reveals unravel minimization explicit unifications unravels removed transformed program minimization sixteen unifications result appearing single clause extra run 
time work eliminated compile synthesis time average benchmarks executed times faster unravels minimized unravel placement current benchmark suite satisfactorily explore question placement unravels clause bodies affects performance noted earlier distinction at-need earlybenchmark net time net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds unravels clause bodies versus early significant backtracking occurs frequently benchmarks backtrack expects performing unravels significantly improve performance table presents timing data confirm expectation benchmarks executed identically positioning unravels fact benchmarks actual uip code produced identical insert early at-need placement meaningless distinction unravels synthesized code important area future exploration behavior complex benchmarks significant unravels backtrack frequently data presented establish important result code rarely backtracks placement unravels significant safe placement adversely affecting performance input aliasing input aliasing optimization means avoid blocking aquarius determinacy analysis unfortunate removing static structure clause heads aliasing aliasingbenchmark net time net time ratio net time ratio append delete insert merge split table empirical comparison benchmark speeds input arguments aliased versus aliasing confound analysis optimizations determinacy detection permits valuable ignore table timing results benchmarks save tree suffered reduced efficiency input aliasing unable execute inputs required test size benchmarks process test data endure considerable speed reductions benefit aquarius determinacy analysis hardest hit benchmarks tree excepted merge executes ten times slowly code input arguments aliased exceptions slowdown append executed slightly faster aliases aquarius detect determinism benchmarks confirmed fact append compile bam code choice points aliasing contrast benchmarks contained choice points compiled aliasing disabled aliasing enabled reason aquarius retains ability detect determinism append remains unclear destructive assignments heart uip transformation destructive assignment destructive assignment conceptually simple synthesizer options implement operation section discussed issues conjectured resolution affect efficiency transformed programs subsections follow evaluate conjectures performance benchmark suite outlined earlier upper connection placement evaluation impact unravel placement current benchmark suite fully explore issue ideal upper connection placement backtracking occurs expect placing unravels early body effect performance predicted section assignments upper connections absolutely body prevent tail-recursion last-call optimizations table time trial data confirms predictions cases placing upper connections guard goals transformed bodies subgoal affect execution encouraging placing assignments body lead speedups backtracking frequent results verify hinder forward-executing code preliminary investigation performance uip transformed code heavily backtracking environment synthesizer simple effective definition guard goals guards clause defined goals start body lead subcalls compiled code guard write tail early latebenchmark net time net time ratio net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds upper connection assignments clause bodies subgoal versus early versus late late placement rendered split non-viable times listed tests late placement highlight avoid confounding tail-recursion last-call optimization benchmarks append insert tree suffer slowdowns destructive assignments contexts recursive subgoals found benchmark delete potentially suffer clause tail recursion hidden late assignment code path crossed benchmark input data visible reduction speed remaining benchmarks merge split suffer great efficiency losses assignments late merge runs ten times slowly code split complete execution running stack space destructive update method options presented performing destructive assignments members benchmark suite timed results found table empirical data confirms hypothesis setarg generality hampers perna assign assign setargbenchmark net time net time ratio net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds assignments performed increment assign versus position passing assign versus position passing setarg formance early increments eliminating positional parameter results fastest code benchmarks interest merge split benchmarks assignment intensive performing destructive assignment level recursion merge benchmark setarg barely outpace code split ran considerably slower positional parameter assign allowed programs outstrip implementation respectable distances finally split faster albeit slightly increment assign eliminate positional parameter result extremely encouraging implications applicability uip ill-suited programs destructive assignments performed great frequency uip transformation yields significant improvements code require efficiently implemented set destructive assignment primitives assignment expensive performed setarg result net loss speed uip ctgcbenchmark time ratio standard ratio ratio append delete insert merge split tree table empirical comparison execution times implementation versus standard uip transformed programs versus ctgc transformed programs general results choices made synthesizer implementation issue profound effect speed resulting code table summaries speedups obtained synthesizer options proposed ideal speedup combination synthesizer options cases options conjectured preferable produce fastest transformed programs anomalies append suffer reductions speed input argument aliasing disabled table includes time ratios benchmarks transformed ctgc ctgc timing data reproduced found broadly speaking code synthesizer produce uip transformed programs update data structures times faster implementations peculiarities benchmark react differently choices made synthesizer set options conjectured generally desirable give excellent results predicted extra work performed ctgc transformed programs consistently limits speed benchmarks uip transformed code uipbenchmark net memory net memory ratio append delete insert merge split tree table comparison benchmark memory comsumption implementations versus uip transformed programs counts adjusted reflect memory consumed data structure update constant memory required construct original input structures subtracted net memory usages reported bytes ratios quotient net consumption implementation net time transformed program executes average thirty percent faster ctgc code paramount concern optimizations improve execution speed amount memory program requires run important issue aggressively reusing memory programs transformed uip technique consume memory counterparts table compares net memory consumed member benchmark suite reduction memory demonstrated programs transformed uip remarkable implementations consumed process data uip transformed benchmark required additional bytes storage append benchmark reduced memory consumption factor hundred complete execution requiring single additional byte storage conclusions update place transformation potential produce programs run significantly faster implementations uip avoid compile time garbage collection pitfall performing unnecessary extra work preparing destructive assignments performed augmenting prolog language primitives performing high speed backtrackable destructive assignment uip transformation offers promise considerably enhanced performance benchmarks tested execute times faster transformation require vastly memory tests destructive assignment performed great frequency uip transformed programs execute rapidly space implementations earlier explorations uip relied manual translation source programs prototype code synthesizer demonstrates automating transformation process feasible automatically synthesized code perform produced hand important implementation issues arise process prototyping synthesizer empirical evaluation confirmed intuitive notions issues resolved significantly uip transformation care introduces confound optimizations determinacy analysis tail-recursion optimization examination unravel simplification reiterates transformation time analyses minimize amount additional work synthesized code 
finally comparison mechanisms performing destructive assignment highlights tradeoffs speed portability entire uip optimization expressed high level source-to-source translation faster code results assignment primitives sacrifice portability order advantage low level representation details important questions uip transformation remain open investigation foremost challenge choosing reuse memory cells efficiently complex contexts simple benchmarks paper dataflow analysis stage developed immature stages deeply investigated prototype implementations developed automatically apply update place transformation general programs written prolog languages findings paper strong statement effort prove greatly rewarding acknowledgments research funded part national science foundation research experiences undergraduates supplement cise grant cda code synthesizer portability appendix intended informal user guide prototype update place code transformer code synthesizer written portable author knowledge conforms iso draft standard date document printing implementations synthesizer exist tested prolog environments sicstus prolog release compiled sicstus prolog release interpreted aquarius prolog release compiled aquarius prolog release interpreted output synthesizer portable extent additional primitives platforms setarg vehicle performing destructive assignment prolog implementation built execute uip transformed code primitives section implemented berkeley abstract machine macros aquarius compiler invoking synthesizer synthesizer front end interfaces synthesizer compiled free standing executable invoked command line assuming executable named siva siva filenames option settings file names option settings freely interspersed set option affects processing files follow command line overridden details options means set provided appendix filenames fully qualified suffix assumed filename user synthesizer read standard input stream physical file output standard output stream redirected storage physical file user option arguments set default option values simply printed synthesizer interpreted environment called directly prolog code predicates provide simple interface append suffix argument open file resulting transform contents file takes arguments simply reads current input stream transforming receives input file format input files code synthesizer consist standard prolog programs directives cells reused body goals transformed clauses rewritten directives provide needed information predicate reuse directives information entire predicates clause reuse directives describe individual clauses single predicate predicate reuse predicate reuse directive form pred reuse predname inputposns outputposns versions required arguments interpreted predname identifies predicate consists atomic predicate predicate arity separated slash inputposns list positive integers identifying argument positions predicate correspond input arguments list ordered duplicates out-of-range values list empty outputposns list positive integers identifying argument positions predicate correspond output arguments list ordered duplicates out-of-range values list empty outputposns inputposns disjoint include arguments predicate versions list transformed versions predicate synthesizer emit member list atom entry entry version consisting single clause calling conventions original predicate produced list descriptors member outputposns ordered correspond descriptor atom orphan indicating exists output argument pair form inpos type inpos input argument position inputposns child type atoms list term unknown depending type cell pair form stray type indicating input argument child type atoms list term unknown depending type cell predicate reuse directives clause predicate predicates transformed supply predicate reuse directive clause reuse clause reuse directive form clause reuse clausename required arguments interpreted clausename identifies clause consists atomic clause clause arity sequential order clause relation clauses arity subsequently refer clause identified clausename current clause clauses append named append append list pairs paths subterms clause pairs form one-to-one mapping preimages memory cells reused postimages structures composed reusing cells format paths list pairs describing body goals formed argument pair path output argument body goal transformed format paths subsequently refer body goal output argument current subgoal argument pair atom orphan indicating exists output argument term form parentlastnum indicating copied directly head clause transformed parentlastnum member outputposns current clause passed current subgoal term form oldstray parentpath childnum indicating consist childnum field subterm located parentpath stray parent input arguments current subgoal contained memory cell allocated entry current clause term form newstray parentpath childnum interpreted manner oldstray contained memory cell originally appeared static structure current clause term form parentpath childnum inpos indicating consist childnum field subterm located parentpath stray inpos member inputposns current subgoal constructed input argument current subgoal child contained memory cell allocated entry current clause term form parentpath childnum inpos interpreted manner contained memory cell originally appeared static structure current clause clause reuse directives point clause clauses predicates transformed supply clause reuse directive sake efficiency ease manipulation synthesizer expects stores paths lists positive integers stored reverse order term expand head tail path represents child child root head paths rooted principal functor clause clause structured term clauses bodies principal functor head located body consists paths form facts clauses bodies principal functor functor head located path user options code synthesizer supports user options determine implementation issues discussed section resolved code generated options set code synthesis time unravel depth set shallow deep set shallow unravels performed simply rarely trivial redundant unravels removed templates simplified underscores set deep simplifications occur unravels literally default setting shallow unravel placement set late early set late unravels performed goals require executed set early unravels needed performed start transformed clause body default setting early input aliasing set set arguments listed inputposns predicate aliased aid determinacy analysis set inputposns empty list aliasing performed default setting assign placement set tail early late set tail assignments upper connections immediately body goal transformed clause set early upper connections start transformed bodies simple opening goals serve guards set late upper connections body goal transformed clause default setting tail assign method set increment setarg assign set increment increment assign primitives set setarg setarg primitive set assign assign primitives default setting increment mechanisms exist modifying settings user options synthesizer invoked command line option names values simply listed file names invocation siva unravel depth deep foo note contrary unix conventions option names preceded dash conflicts sicstus option handling library options set directly input file synthesizer directive form siva option set named user option reunix registered trademark unix system laboratories quested lastly synthesizer interpreter environment evaluating goal siva option perform function set options affect synthesis files follow option set directives midst input file settings affect code synthesis file subsequent files time values single synthesis option applied individual clauses file limitations synthesizer intermediate representation requires augmenting clauses pseudo-goals goals present original clause synthesizer behavior ill determined synthesizer hold entire source code memory size program transformed limited amount memory allocated synthesizer predicate clause reuse directives checked verify reasonable errors present 
reuse directives synthesizer produce unexpected code fail option settings affect entire files time varied individual clauses predicates share single file benchmark source code complete source code members benchmark suite presented section fed code synthesizer additional directives follow format appendix generate code reuse directives simply stripped remaining clauses compile directly append insert element element insert element head tail element head tail element head insert element head tail head newtail element head insert element tail newtail pred reuse insert entry orphan list clause reuse insert clause reuse insert clause reuse insert delete delete delete oldtail newtail delete oldtail newtail delete oldtail newtail delete oldtail newtail pred reuse delete entry orphan list stray list clause reuse delete clause reuse delete clause reuse delete insert insert element element insert element head tail element head tail element head insert element head tail head newtail element head insert element tail newtail pred reuse insert entry orphan list clause reuse insert clause reuse insert clause reuse insert merge merge head tail head tail head newtail head head merge tail head tail newtail merge head tail head tail head newtail head head merge head tail tail newtail merge head tail head tail merge list list pred reuse merge entry orphan list list clause reuse merge clause reuse merge clause reuse merge clause reuse merge split split split head head split head head tail head tail head tail split tail tail tail pred reuse split entry orphan orphan stray list list clause reuse split clause reuse split clause reuse split oldstray head tail lists head heads tail tails lists heads tails pred reuse entry orphan orphan stray list list clause reuse clause reuse oldstray tree tree insert elem tree node left tree node newleft elem node tree insert elem left newleft tree insert elem tree node left tree node left newright elem node tree insert elem newright tree insert elem leaf tree elem leaf leaf pred reuse tree insert entry orphan term clause reuse tree insert clause reuse tree insert clause reuse tree insert burton gudjonsson winsborough algorithm computing alternating closure technical report cs- pennsylvania state department computer science june foster winsborough copy avoidance compile-time analysis local reuse proceedings international logic programming symposium mit press mulkers winsborough bruynooghe analysis shared data structures compile-time garbage collection logic programs proceedings seventh international conference logic programming mit press sundararajan sastry tick variable threadedness analysis concurrent logic programs proceedings joint international conference symposium logic programming mit press codish dams yardeni derivation safety abstract unification algorithm groundness aliasing analysis proceedings eighth international conference logic programming furukawa mit press debray copy avoidance single assignment languages tenth international conference logic programming mit press duvvuru sundararajan tick sastry hansen zhong compiletime memory-reuse scheme concurrent logic programs international workshop memory management lncs springer-verlag mari janssens mulkers bruynooghe impact abstract interpretation experiment code generation proceedings sixth international conference logic programming levi martelli eds mit press gudjonsson winsborough update place overview siva project submitted conference gudjonsson transforming prolog predicates perform update place unpublished technical notes carlsson widen sicstus prolog user manual swedish institute computer science kista sweden march haygood aquarius prolog user manual advanced computer architecture laboratory los angeles september schimpf setarg sepia eclipse personal communication april van roy logic programming execute fast imperative programming phd thesis california berkeley december sun microsystems programming utilities sun workstation groves transforming prolog predicates perform update place master thesis pennsylvania state department computer science programming language prolog committee draft standard iso work item jtc april 
operational semantics logtm ben liblit department computer sciences wisconsin madison liblit wisc version august abstract present formal operational semantics logtm hardware-based nested transactionalmemorysystem language includes memory accesses nested closed open transactions partial rollback commit abort handlers thread spawning escape actions working document intended reflect codify current understanding logtm operation common corner cases formal semantics serves companion published discussions logtm specifically corresponds system supporting nested transactional memory logtm moravan purpose status document document presents formal operational semantics logtm hardware transactional memory system define small assembly language memory accesses transaction operations state required behavior logtm implementation executing programs language implementation-specific behavior identified intentionally left unspecified additionally semantics models forward log current logtm implementations backward logs intentional deviation forces semantics dependent particulars implementation document dense mathematical notation minimum explanatory prose intended read treated companion published descriptions logtm architecture implementation specifically describe behavior nested logtm system moravan hope document documenting logtm behavior complex corner cases treatments hint codify detail andfurthermorehas mechanically tested verified revisions required correct errors reflect futurechangestologtm http wisc multifacet papers corrected updated semantics posted additionally citations document identify version number semantics version avoid confusion respect definitions fundamentals letvectors represent possibly empty vector ordered elements empty vector written right-associative single-element prepending operator vector concatenation operator convention numeric subscripts index vector elements prime sprime double prime sprimeprime marks identify successively updated versions initial execution proceeds forward time convention informal violated awkward cases set letvectors represent set vectors elements function domain domain function set restrict domain restriction restrict undefined pair functions represent cascading union defined braceleftbigg domain function values mapsto represent function maps identical represent fresh unnamed variable type context unconstrained instructions addresses set addressable memory locations program address space elements aprime values set values stored addressable memory locations elements vprime escapestates escaped unescaped set escape states elements eprime instructions set machine instructions logtm system elements xprime yprime zprime informally represent regular execution represent commit handlers represent abort handlers instructions recursive grammar instructions read write begin commitclosed commitopenvectoryvectorz escape unescapevectoryvectorz abort setstate evectort spawnvectorx addresses escapestates vectort transstates values andvectorx vectory vectorz instructions subsection definition transstates setstate instruction special operation manage environments abort handlers run actual program memory addresses values defined granularity logging implementation -bit values logged values represents -bit values addresses -bit-aligned locations hold values program single byte read complete -bit readsets addresses set read sets elements rprime valuemaps addresses values set maps elements wprime memorymaps addresses values set main memory maps elements mprime valuemaps memorymaps types convention construction elements memorymaps complete functions valuemaps includes partial functions address blocks logtm implementations log memory operations larger granularity individual addresses current implementations log -byte blocks memory accesses -byte aligned conditions defined apply coarser granularity logtm log model distinction addresses address blocks blocks fixed set address blocks addressblock addresses blocks complete function maps address address block mapping implementation-defined remain fixed duration program addressblocks addresses blocks element-wise extension addressblock sets set addresses addresses addressblocks uniontexta aaddressblock transaction state transstates readsets valuemaps instructions instructions set transaction states elements tprime informally transaction state records set addresses read transaction map addresses values written transaction current sequence commit handlers current sequence abort handlers thread states threadids set thread ids elements dprime threadstates escapestates transstates instructions represent set thread states thread consists escape bit stack transaction states ordered vector instructions execute threadids pii piprime program consists collection named threads system state memorymaps set system states elements prime system consists main memory running program initial subset initial system states defined set states conditions hold domain addresses mapsto unescaped note require complete address address hold initial arbitrary pool active threads initially consists single thread base non-transactional state arbitrary sequence pending instructions semantics judgments judgment read starting initial system state evaluation threads instructions terminates main memory system final state judgment prime read starting system state running steps leaves system sate prime judgment prime read starting system state running single step leaves system state prime judgment turnstileleft prime read starting system state running thread single step leaves system state prime judgment turnstileleft prime read starting system state evaluation instruction thread leaves system state prime sequential execution thread management termination system begins initial state runs threads reaped halt mem initial running multiple steps obvious transitive closure running single steps step multi step prime prime primeprime primeprime thread reaped instructions left execute base nontransactional state note multiple threads reaped order reaped arbitrary similarly single steps involving thread execution interleaved arbitrarily single steps thread reaping reap unescaped prime restrict threadids prime single step system consists selecting thread allowing thread single step note selection thread execute non-deterministic model thread scheduler semantics system step domain turnstileleftd prime prime single step thread consists removing evaluating pending instruction thread fetch vectort vectorx prime mapsto vectort vectorx prime turnstileleftd primeprime turnstileleftd primeprime thread spawned escape action newly spawned thread begins base non-transactional state spawn escaped dprime domain prime dprime mapsto unescaped vectorx turnstileleftd spawnvectorx prime conflicting memory operations conflict detection allread transstates addresses set addresses read transaction transaction stack defined allread allread vectort allread vectort allwritten transstates addresses set addresses written transaction transaction stack defined allwritten allwritten vectort domain allwritten vectort allaccessed transstates addresses set addresses read written transaction transaction stack defined allaccessed vectort allread vectort allwritten vectort conflict addresses addresses address conflict relation relation intentionally left unspecified address conflicts implementation-defined nondeterministic require conflict reflexive address conflicts writeconflict threadids addresses write conflict relation defined check write dprime negationslash dprime vectort aprime allwritten vectort conflict aprime writeconflict accessconflict threadids addresses access conflict relation defined check read dprime negationslash dprime vectort aprime allaccessed vectort conflict aprime accessconflict conflict resolution read conflicts thread uncommitted transactional write conflicting address conflicting reads abort read conf writeconflict unescaped turnstileleftd abort prime turnstileleftd read prime write conflicts thread uncommitted transactional write conflicting address uncommitted transactional read conflicting address conflicting writes abort write conf accessconflict unescaped turnstileleftd abort prime turnstileleftd write prime note provide semantic rules execution conflicting reads writes base non-transactional state implied requirement instructions stall time non-conflicting logtm strong atomicity defined blundell non-conflicting memory operations escape obeyx threadids addresses condition compliance relation potential read defined obeyx dprime negationslash dprime vectort 
addressblock addressblocks allwritten vectort intentionally state semantics escaped reads violate condition implementation choose extend semantics defining behavior reads -compliant escaped read fetches current thread nested transaction stack transactional state modified escaped read escaped vectort obeyx vectort turnstileleftd read addresses memorymaps transstates values transactional fetching function nested transaction stack requires finding innermost map mapping desired address top vectort vectort deep vectort vectortprime domain vectortprime vectort map found main memory provided resort mem obeyx transstates addresses condition compliance relation potential write defined obeyx obeyx vectort addressblock addressblocks allwritten vectort obeyx threadids addresses condition compliance relation potential write defined obeyx dprime negationslash dprime vectort addressblock addressblocks allaccessed vectort intentionally state semantics escaped writes violate conditions implementation choose extend semantics defining behavior writes -compliant escaped write directly updates main memory changing transactional state escaped write mem escaped vectort obeyx vectort obeyx prime amapsto turnstileleftd write prime non-transactional transaction active reads writes proceed conflict transactional activity threads noted earlier means logtm strongly atomic defined blundell non-conflicting read base non-transactional state yields main memory read base writeconflict unescaped turnstileleftd read non-conflicting write base non-transactional state updates main memory write base accessconflict unescaped prime amapsto turnstileleftd write prime transactional non-conflicting read transaction nested transaction stack current thread thread read set updated read trans writeconflict unescaped vectory vectorz vectort vectorx prime mapsto unescaped vectory vectorz vectorx vectort turnstileleftd read prime non-conflicting write transaction stores updates running transaction map write trans accessconflict unescaped vectory vectorz vectort vectorx prime mapsto unescaped amapsto vectory vectorz vectort vectorx turnstileleftd write prime handler registration unescapes open commits commit abort handlers run merged sibling operations addhandler instructions instructions instructions instructions instructions instructions handler combining function informally arguments addhandler represent existing instruction stream run handler handler prologue handler body handler epilogue existing instruction stream run handler result instruction stream argument instructions sequenced argument order handler body empty prologue epilogue arguments simply concatenated add handler empty addhandler vectorx vectorx vectorx vectorx add handler nonempty vectorx addhandler vectorx vectorx vectorx vectorx vectorx vectorx logtm commit handlers run fifo order addhandler withvectorx commit handlervectorx appended existing commit handlersvectorx conversely logtm abort handlers run lifo order addhandler withvectorx commit handlervectorx prepended existing abort handlersvectorx transactions special setstate instruction replaces current thread escaped state transaction stack instruction restore earlier configurations running abort handlers set state vectorx prime mapsto vectort vectorx turnstileleftd setstate evectort prime beginning transaction materializes empty read set map pushes current thread nested transaction stack commit handler empty abort handler restores thread state time begin restarts begin point initial values handlers change execution notice don care transaction closed open point matters commit begin unescaped vectort vectorx setstate unescapedvectort begin vectorx prime mapsto unescaped vectort vectorx turnstileleftd begin prime abort instructions normal execution sequence discarded aborting transaction popped discarded normal instruction stream running thread likewise discarded execution continues aborting transaction abort handler abort unescaped vectorz vectort prime mapsto unescaped vectort vectorz turnstileleftd abort prime substantial deviation logtm implementation rollback interleaved execution threads claim proved -compliant program distinguish atomic non-atomic rollback informally program difference thread observes aborting thread uncommitted writes rolled back condition forbids sort peeking escaped reads normal read write conflict detection forbids peeking unescaped reads closed commit enclosing transaction applies stored writes main memory committing transaction popped discarded execution continues committing transaction commit handler rest thread normal instruction stream notice means commit handlers execute dropping isolation commit handlers running threads observe stores performed committed transaction commit top closed unescaped vectory vectorx prime mapsto unescaped vectory vectorx turnstileleftd commitclosed prime open commit enclosing transaction similar instruction-provided commit handler run open transaction transaction accumulated commit handlers continuing rest thread normal instruction stream commit top open unescaped vectoryprime vectorx vectoryprimeprime addhandler begin vectory commitopen prime mapsto unescaped vectoryprime vectoryprimeprime vectorx turnstileleftd commitopenvectory prime nested closed commit innermost read set map commit handler abort handler merged parent transaction committing transaction popped discarded commit deep closed unescaped vectort vectorx vectort vectortprime vectory vectorz vectory vectorz tprime vectory vectory vectorz vectorz prime mapsto unescaped tprime vectortprime vectorx turnstileleftd commitclosed prime obeyo transstates addresses condition compliance relation potential write defined obeyo obeyo vectort addressblock addressblocks allwritten vectort note obeyo obeyx identical contexts nested open commit writes held innermost map applied directly main memory writes -compliant committing transaction popped discarded commit abort handlers commit instruction registered parent transaction subsequently needed handlers run open transactions abort handler commit handler restore state thread commit commit instruction execute accumulated commit handlers proceed normal instruction stream commit deep open unescaped vectort vectorx vectort vectortprime vectory vectory vectorz vectoryprime addhandler vectory begin vectory commitopen vectorzprime addhandler setstate unescapedvectort vectorz commitopen vectorz tprime vectoryprime vectorzprime domain obeyo vectort prime mapsto unescaped tprime vectortprime vectory vectorx turnstileleftd commitopenvectoryvectorz prime transactions marked open closed begun -compliance atransaction designated open closed commit time -compliance checking postponed open commit intentionally state semantics open writes violate condition implementation choose extend semantics defining behavior writes escape actions hardware responsible counting nested escape actions emphasize leave semantics double escape double unescape undefined escape unescaped vectort vectorx prime mapsto escaped vectort vectorx turnstileleftd escape prime unescaping require additional processing commit abort handlers unescaping inside transaction handlers queued depending outcome transaction unescape trans escaped vectort vectorx vectort vectortprime vectory vectorz tprime vectoryprime vectorzprime vectoryprime addhandler vectory escape vectory unescape vectorzprime addhandler setstate escapedvectort vectorz unescape vectorz prime mapsto escaped tprime vectortprime vectorx turnstileleftd unescapevectoryvectorz unescaping base non-transactional state abort handler discarded commit handler run immediately unescape base escaped vectorx vectoryprime addhandler escape vectory unescape prime mapsto escaped vectoryprime vectorx turnstileleftd unescapevectory acknowledgment document result intensive discussion jayaram bobba mark hill kevin moore michelle moravan cindy rubio gonzalez michael swift david wood luke yen wisconsin madison colin blundell christopher lewis milo martin deconstructing transactional semantics subtleties atomicity proceedings fourth workshop duplicating deconstructing debunking june keven moore jayaram bobba michelle moravan mark hill david wood logtm log-based transactional memory proceedings annual international symposium high performance computer architecture austin texas february institute electrical electronics engineers michelle moravan jayaram bobba kevin moore luke yen mark hill ben liblit michaelm swift anddavida wood proceedings international conference architectural support programming languages operating systems san jose california october 
association computing machinery index mapsto vector abort abort accessconflict add handler empty add handler nonempty addhandler addressblock addressblocks addresses allaccessed allread allwritten begin begin blocks check read check write commit deep closed commit deep open commit top closed commit top open commitclosed commitopen conflict domain escape escape escaped escaped read escaped write mem escapestates fetch deep mem top halt mem initial instructions memorymaps multi step step obeyo obeyx obeyx obeyx read read base read conf read trans readsets reap restrict set state setstate spawn spawn system step threadids threadstates transstates unescape unescape base unescape trans unescaped valuemaps values write write base write conf write trans writeconflict 
public deployment cooperative bug isolation ben liblit liblit berkeley mayur naik mhn stanford alice zheng alicez berkeley alex aiken aiken stanford michael jordan jordan berkeley department electrical engineering computer science department statistics california berkeley berkeley computer science department serra mall stanford stanford abstract part work cooperative bug isolation cbi undertaken instrument distribute binaries number large open source projects public deployment important step large experiment involving hope hundreds thousands users measure effectiveness cbi paper describes significant engineering issues arise instrumenting source code realistic applications introduction cooperative bug isolation cbi seeks leverage huge amount computation end users software gathering bit information run program performed user community make inferences automatically bugs experienced field approach cbi based compile-time instrumentation program source code insert instrumentation test large number predicates program values execution count times predicate observed true false termination program list predicate counters uploaded central server record program research supported part nasa grant nag nsf grant nos eiaccr- aciand iisdoe prime contract -engthrough memorandum agreement llnl darpa aro-muri acclimate daad- information presented necessarily reflect position policy government official endorsement inferred terminated successfully subsequent statistical analysis predicates correlated program failure engineers values parts program sources crashes cases exact line code fault identified cbi related research efforts great potential make software development responsive efficient giving developers accurate data software deployment testing idea requires significant experimentation real preferably large user communities real applications paper reports experience preparing experiment instrumented number large open source applications listed table total million lines code made instrumented programs public process collecting feedback reports result demonstrated complete cbi system feel comfortable claiming approach technically feasible aspects system improved point components good support deployment realistic instrumented applications collection feedback reports large user community design cbi system involves interesting challenges technical social paper focus solutions technical problems designers similar systems experiments dealing existing native compilers shared libraries plugins threads briefly discuss users interact system give static dynamic measures applications instrument application lines code shared libraries plugins threads evolution check check check gaim check gimp check check gnumeric check nautilus check check check rhythmbox check table instrumented applications native compiler integration system behaves gcc extra command line flags manual annotation source code required existing configuration scripts makefiles work transparently lets instrument million lines open source code releases short turnaround simply changing environment variable builds application instrumenting compiler standard meat instrumentation source source transformation preprocessor real compiler affect stages compilation preprocessing cpp pull extra headers declare define constructs instrumented code fixed content easier fixed headers synthesizing needed constructs programmatically instrumentor compilation inject sampled instrumentation source-to-source transformation emit additional static site information temporary files step assembly asm fuse extra static site information temporary files assembled object file linking pull extra libraries common runtime support code data instrumented programs gcc path flag alternate directory find compiler stages custom scripts directory named asm extra compilation assembly work invoke native compiler stages gcc -specs file flag augment replace standard option specs file option specs file simply specfile determines gcc parses command line arguments add flags request temporary file names specfile essentially tiny domain-specific language tweaking command lines compiler stages facility care preprocessing linking augmenting cpp command lines replacing stages custom scripts static site information main compilation task inject instrumentation code phase produces static information instrumentation site includes site source file line number host function control flow graph node information specific instrumentation scheme decoding feedback reports information tie predicate counts back source level features understood programmer experience maintaining information external object file brittle existing application build scripts move rename object files build process fuse static site information assembled object file storing custom elf sections linker combines object files pads unknown section fixed modulus concatenates same-named sections link order represent static site information remains valid null-byte injection concatenation instrumented executable shared library plugin describing complete static information instrumentation sites extra sections flagged debug information means stripped debugging information post-build packaging retain copy locally assist report decoding end users download store extra information machines libraries plugins post-run reporting easy application consisted single object file simply write predicate counters order file list constitute complete report table applications involve multiple object files form shared libraries plugins note table counts shared libraries plugins part source code application additionally generally shared libraries plugins resident end user machine running environment mix code instrumented cbi code shared libraries interesting applications instrumented instrumented applications cope uninstrumented code instrumented code cope finding uninstrumented application orthogonal set problems arises static linking dynamic loading system control linker assume object files order plugins loaded late unloaded time instrumented plugin unloaded capture part feedback report immediately unloaded global predicate counters vanish address space longer accessed solution problems make object file self-managing initialization code runs loaded finalization code runs unloaded objects part main application binary initialization code runs early program execution main finalization code runs main returns afterexit called shared libraries similar plugins initialization code runs dlopen plugin mapped memory plugin finalization code runs dlclose plugin removed memory object file maintains instrumentation state object file maintains predicate counters situation global knowledge loaded object files finalization code run crash program receives fatal signal immediately gather predicate counters loaded object file feedback report maintain doubly-linked list loaded object files initialization finalization code object file adds removes file list moment time application central registry instrumented loaded object files attention fact global registry corrupted buggy program maintain global count expected size global registry walking list signal handler counter decide stop reached end list data structure prevents infinite loop memory error application introduces cycle doubly-linked list global registry damaged ways misbehaving program avoiding cycles important case handle complications checking corrupted global registry general problem completely isolate program instrumentation program unsafe languages result sanity check feedback reports central server discard ill-formed practice receive ill-formed reports number tiny fraction reports threads cbi system maintains kinds global data special attention multi-threaded applications case thread-safety hurt performance extra care fact application multithreaded compiler command line gcc -pthread flag key feature cbi system performance improved sampling instrumentation code implemented frequently skipping instrumentation executing fast path instrumentation global countdown determine instrumentation sites skip testing predicate recording result countdown chosen 
randomly geometric distribution desired sampling rate equivalent efficient tossing coin instrumentation site decide sample multi-threaded system global variable holding next-sample countdown source high contention threads simple solution problem give thread independent countdown variable equivalent giving thread coin toss behavior system per-thread countdowns indistinguishable single global countdown addition avoid locking enacting plan requires compiler support thread storage qualifier declare thread-specific storage gcc extension requires support posix threading runtime library runtime loader alter thread creation initialize thread global state --wrap flag provided gnu linker replace pthread create augmented version class data requires special handling multi-threaded applications predicate counters recall predicate counters track predicate line code observed true false efficiency low sampling rates hundred times average randomized line code predicate executed predicates tested rarely individual counter accessed rarely single thread maintain copy predicate counter shared threads critical operation counters increment basic cpu architecture atomically resorting heavyweight locking finally class data protected concurrent access includes global registry compilation units report file structures accessed rarely guarantee exclusive access guarding mutual exclusion lock user interaction user launches instrumented application run instrumented binary directly install wrapper script expected location usr bin put instrumented binary wrapper script responsibilities performs user interaction underlying application collects raw feedback report instrumented application packages transit sends report collection server information program outcome avoid adding gui infrastructure encrypted networking support applications script language python excellent library support networking desktop interaction wrapper script starts checks user run instrumented version application presents first-time opt-in dialog box shown figure dialog box briefly describes goals project consequences participating lets user decide logo icon highlighting explanatory text change reflect user current choice hyperlink button links project web site information dialog box initially presented background real application launched waiting reply run application reports data user selected preference remembered first-time opt-in dialog box shown subsequent runs change preference distinct sampler control panel background wrapper posts small status icon desktop status bar notification area icon visual reminder instrumented application running simple pop-up menu toggle globally disable enable sampling status figure first-time opt-in dialog box application min max evolution gaim gimp gnumeric nautilus rhythmbox table feedback report sizes bytes icon depending sampling enabled disabled globally remains present long instrumented application running menu item launches sampler control panel detailed customization data collection preferences opt-in dialog box status icon control panel work user fully informed fully control additional configuration management hooks system administrators change defaults mandatory locked-down settings settings include sampling density address report collection server reporting enabled selected applications tracking user behavior delicate matter users system administrators adapt system local concerns wrapper script launches instrumented binary subprocess check subprocess exit status result code fatal signal included report uploaded feedback collection server wrapper script compresses raw feedback report transit gzip-compatible compression huge benefit reports zeros compress average compression reports received table shows range report sizes received application largest reports bytes uploaded slow modem connection seconds submitting report wrapper checks sampling enabled globally application user changed mind program launch chance quash unwanted feedback report reaches collection server report submitted http post request encrypted ssl connection http request response server ordinarily collection server give response success code server give response wrapper script receives presents user html page feature critical security issue found requiring upgrades http reply include special reply headers update local sampling configuration client ability promote destination url future reports relocate collection server change sampling density default performance problems arise issue poison pill turns sampling future runs application intended shutoff cooperative bug isolation project discontinued future date feature learned prior experience elbaum hardojo suppress future reports individual misbehaving users needed facilities status public deployment conclude discussion experience public deployment applications listed earlier concern approach adds great deal code application fact binaries large original uninstrumented program growth disk footprint considerably smaller considers entire package typical large application fact executable code small percentage total distribution applications instrumented downloaded packages larger installed footprint disk grows actual application binaries larger original distribution application total good error crash evolution gaim gimp gnumeric nautilus rhythmbox table number reports received date received complaints package sizes downloaded expanded disk potential issue application performance received complaints performance instrumented applications sampling apparently sparse sampled densely interactive applications spend time waiting user note applications cpu-intensive phases rhythmbox loading library thousands music files gnumeric recalculating large spreadsheet table summarizes current state data instrumented applications total number valid feedback reports received broken good runs runs exited non-zero error status runs ended crash due fatal signal note large variation crash rates gimp rhythmbox good news bad news figures bad news received reports carry statistically significant analysis results based previous experience studies lab running applications synthetic data simulate large user community sampling ten twenty thousand runs current methods achieve accurate analysis results ten times number reports received date applications situation reflects inherent aspect cbi similar approaches methods work minimum scale good news applications crash indicating potential improve state software users participating cbi addition data demonstrate complete system works instrumenting code gathering reports continue receive feedback reports daily beginning experiment invested effort attracting users step experiment find ways recruit began collecting data public october users test advantages cbi large user communities complex applications elbaum hardojo deploying instrumented software assist testing activity ramss international workshop remote analysis measurement software systems pages liblit cooperative bug isolation project http berkeley liblit sampler liblit aiken zheng jordan bug isolation remote program sampling james fenwick norris editors proceedings acm sigplan conference programming language design implementation pldivolume acm sigplan notices pages acm press liblit aiken zheng jordan sampling user executions bug isolation proceedings workshop remote analysis measurement software systems pages portland oregon zheng jordan liblit aiken statistical debugging sampled programs advances neural information processing systems vancouver whistler british colombia canada dec 
cognitive perspectives role naming computer programs ben liblit andrew begel eve sweetser wisconsin madison usa liblit wisc microsoft research redmond usa andrew begel microsoft california berkeley usa sweetser berkeley abstract programming computer complex cognitively rich process paper examines ways human cognition reflected text computer programs concentrate naming assignment identifying labels programmatic constructs naming arbitrary programmers select names arbitrarily programmers choose names regular systematic ways reflect deep cognitive linguistic influences turn names carry semantic cues aid program understanding support larger software development process introduction programming languages designed precise mathematical unambiguous interpretable machines natural languages hand evolved long periods time interpreted humans rich suite cognitive processes wrong dismiss programming languages wholly unnatural programs written humans proceed directly keyboard compiler development humans read modify code produced code understood human human programmers aware code artifacts produce readable runnable human cognition reflected text computer programs cially strongly purpose paper examine impact human cognition human language text forms computer software facets software construction paper closely examines naming act assigning identifying labels programmatic constructs intensive invented words major deviation natural language dialog participants share large mutually understood fixed lexicon compiler natural language blue sgu asd equally opaque arbitrary sequences letters provided programmer consistent spelling capitalization good precisely names arbitrary programmers great freedom select names promote code understanding examine ways relating standard programming practice modern theories human language cognition in-depth treatise identifiers standard scope narrow focus primarily languages java justified fact languages dominant tools large-scale industrial software development insight gain broad potential applicability variety methodologies morphological analysis discourse analysis grammar-based deconstruction names metaphorbased deconstruction names discover rationale programmers choices identifiers remainder paper organized section describes factors influencing selection individual names encodes insection weshowthatnamesexhibit regularities derived grammars natural languages allowing combine form larger pseudo-grammatical phrases convey additional meaning code section explores fundamental programming metaphors aid understanding code direct linguistic interpretation section review phenomenon overloading controversial programming feature relates polysemy metaphorical extension word meaning lastly section reviews findings suggests directions future study meaningful names basic guidelines writing good code meaningful names humans create code humans read code names programmers select reflect human cognitive structure naming engenders strong reaction software practitioners advocate naming scheme ensure programs understandable documentation jones asserts memorability confusability names program section examine ways programmers select names embed cognitively salient information practice human beings rich source hints behavior intent code morphological metaphorical regularities programmatic representation manipulation information abstract routinely speaks virtual world exists inside computer distinguished form real world humans make pervasive metaphor structure understanding world exclusively facets world removed bodily experience metaphors presenting domain tasks reifying abstractions concrete terms making accessible people comprehend programs central naming program entities piece software studies program comprehension verified names classified groups called concept keywords programming metaphors design data abstractions illustrative collection functions listed figure functions part gnome project collection software tools building desktop applications unix environment functions written brevity show names functions elide parameters result types implementations short list function names reveals regularities morphological structure metaphors gnome druid type gnome druid set buttons sensitive gnome druid gnome druid set show finish gnome druid append page gnome druid set page gnome druid prepend page gnome druid set show gnome druid insert page fig gnome druid functions obvious patterns morphological words morphemes separated underscores programmers great freedom choose names technical considerations make disallow spaces punctuation marks underscores allowed programmers delimit multiple morphemes single lexical convention popular functions fields variables lower case letters distinct lexical conventions govern kinds names morphemes concatenated delimiting underscores commonly java names capitalizing morpheme called camel case java type names gnomedruidpage gtkcontainerclass additionally method names concatenating morphemes underscores fully capitalizing word commonly found macro names gnome druid class gnome druid aware java lexical conventions differ slightly java embedded capital letters field method names indexof underscores expect index type names remain distinctive initial capital letter vector lexically transitional programmers prefer underscores favor embedded capitals leading trailing underscores mark internal names intended general combined lexical conventions gnomedruid internal type gnome druid internal macro distinctions drawn conventions coincide profound differences names code observe names begin gnome druid lexical convention deeper metaphorical basis distinct pieces code combined problems arise programmers names unrelated things modern language facilities packages modules namespaces encapsulate code avoid problematic collisions language faciligtk software system gnome layered gtk acts single word ties programmers creating encapsulated namespaces naming conventions preponderance names defined gnome software begin gnome gnome types gnome macros effect creating metaphorical container functions figure apply specific gnome facility druids names begin gnome druid gnomedruid gnome druid creating namespace namespace box box nested containers pervasive programming metaphor revisit section page gnome druid set dialog boxes guide user linear sequence steps druid humorous play wizard microsoft similar sequence-of-steps interaction popularized microsoft windows page corresponds single step sequence druid ordered linear collection pages provisions adding page start sequence prepend end append middle insert selecting page visible set metaphorical model sheaf paper folded open reveal page programmer adds removes druid pages target domain add remove real pages source domain instructive programmer chose call pages steps druid encapsulate sequence steps encapsulates presentation sequence steps user visual display critical page metaphor captures acutely fact druid pages rectangular black text white background enforces mapping gnome druid small programmatic abstraction metaphorical correspondences means unique douce presents long list metaphors found computer programs conflicting pressures impacting length names informative longer names embedded subwords informative practical limits lengths names practical limits lengths words natural languages compilers early programming languages fortran limited names characters starting long tradition abbreviation naming longer names informative cumbersome type read long names quickly run finite display width distance abscissae abscissa abscissa distance ordinates ordinate ordinate cartesian distance square root distance abscissae distance abscissae distance ordinates distance ordinates terse abbreviated names complete words enhance readability expense role expressiveness require domain knowledge decipher dist sqrt linguists long observed character length english words varies inverse proportion frequency written text good reasons tendency magnified source code names concatenations words grow longer rapidly isolated words typographic limitations make long names unwieldy larger expressions programmers leverage existing mathematical conventions attach significant meaning small names spatial coordinates indices counted number items fourth overuse 
abbreviations lead preponderance unique symbols programmers decipher lead inhibited understanding lastly programmatic names vary semantic roles visibility code informative lessened names narrow scope restricted ways identifier names wild collected statistical data andc code ourjavacode represents complete source standard java class libraries lines java code defined names half declare local variables formal parameters local names narrowest scope exists body single method names average characters embedded subwords measured number capitalized subwords suggesting combination heavy narrow scope incline programmers terse largest semantic category consists public methods names average characters embedded subwords public methods fewer number sparser visible entire program justify longer informative names similar trends code measured lengths source code gnumeric open source spreadsheet application corpus lines long declared names common names local variables formal parameters average length characters embedded subwords measured number underscore delimiters identifier find noteworthy metrics closely match java corpus bodies code authors purposes written languages names broader scope longer lesscommon functionswithfilescope average charactersand words andthe charactersand words earlier observed programmers common prefixes create artificial namespaces account greater average length function names compared java methods lastly analyzed source code windows server written corpus million lines code names names evenly divided global local localnamesaverage charactersand embeddedsubwords measuredbythenumber underscores inter-capitalized subwords global names average characters subwords significant increase public functions opposed types slightly smaller characters subwords average fewer type symbols shows average types windows server subword functions statistics interesting read standard deviations high refrain reporting remaining semantic categories drawing detailed conclusions pending nuanced statistical analysis treatment correlating lengths frequencies visibilities semantic roles scope present study crude preliminary analysis suggest strong underlying principles warrant closer examination grammatical sensibility programmer-defined names exist isolation interact language specific punctuation keywords build expressions statements composite constructs examine larger code fragments find evidence natural language grammar program text caprile tonella analyze function identifiers breaking individually meaningful words classifying lexical categories describing sixteen-production grammar section ways names create larger pseudo-grammatical utterances leverage natural language understanding aid code comprehension names phrase fragments purposes paper accept metaphorical assumption data things mapping reflected figure lists constituent fields make gnome dock fields nouns noun phrases programmer made english plurals precisely fields data lists single items unusual field floating items allowed indicative phrase omitted verb field holds single true false human reading code immediately conclude field true floating items allowed truthful statement dock specialized true false data factual assertions mapping override generic data things practical matter interested present state object phrases present tense occasionally encounter past future tense reason inquire past future states turn attention java class java util vector class fields capacityincrement elementcount elementdata true false data things correctly predicts noun phrase text small caps read metaphors container bottom bands floating children client area bands client rect top bands left bands floating items allowed fig constituent fields gnome dock names methods vector complex names suite schemes reflect differing frames understanding behavior purpose methods methods actions actively change state program methods obeying model return return incidental information effect actions names methods verb phrases imperative mood add addall addelement clear copyinto ensurecapacity insertelementat remove removeall removeallelements removeelement removeelementat removerange retainall set setelementat setsize trimtosize methods mathematical functions passively compute result alter state program methods obeying model return piece data interest caller method identified produces obeys data naming principles earlier true false data factual assertions true false returning methods verb phrase names indicative mood containsall equals isempty data things methods returning values true false singular plural noun phrase names capacity clone elementat elements firstelement hashcode indexof lastelement lastindexof size sublist conventions correctly describe thirty forty methods vector exceptions toarray tostring actual behaviors properly place category non-true false mathematical functions toarray tostring return object equivalent original vector converted form names consistent specialized java naming scheme exclusively conversion methods method strongest anomaly behavior return tat expected noun phrase naming convention play common offer matched pairs set methods manipulate object attributes object attributes method names extended identify attribute manipulate setcolor getcolor setname getname symmetric naming informative reveals attribute exists paired methods relate attribute specific italsoviolatesthe data things providing methods programmers resolve conflict inconsistently vector set setsize size setsize getsize valence cues characterize copyinto verb phrase bit generous ends dangling preposition natural language terms fragment open valence slot additional item specifically noun provided complete phrase java natural language valence cue valid nonetheless copyinto method called additional argument array vector components copied methods indexof elementat similar preposition-based hints open valence slots stem parts speech adjective requires noun modify removeall expects argument transitive verb method expects single parameter corresponds direct object english speech valence cues universal exact one-to-one correspondence method arity add method requires parameters requires share sublist method called sublistfromto open prepositions emphasize required arguments room variation programmer balance benefit valence cues concerns length readability design underlying programming language significant majority programming languages treat method names atomic object-oriented language smalltalk noteworthy exception smalltalk method names multiple words delimited colons argument segment smalltalk version insertelement named insert roster insert newhire position contrast java syntax roster insertelement newhire position smalltalk method woven arguments suggested required smalltalk programmer produce fragment argument english words open valence slots obvious choice finds smalltalk method names inject movetower highly descriptive schedulearrivalof accordingto startingat object oriented languages data personified active agents internal state fields set exported behaviors methods invoke method direct agent perform action perform calculation respect methods verb names open valence slot subject slot filled object method called roster insertelement insertelement reads imperative command issued roster subject appears immediately verb helps create extended pseudo-grammatical utterances english speaking programmers factual assertion roster record roster record factual assertion roster empty roster isempty imperative command roster remove junk roster removeall junk imperative command roster set size roster setsize noun-named methods reading possessive case equally easily provided reader access english construction computed attribute roster element roster firstelement computed attribute roster capacity roster capacity possessive reading natural complex expressions revisit issue greater depth section containers paths broaden scope issues cognition language comprehension intent undertake general review cognition computing pair models directly impact require closer inspection objects containers pointers paths describing objects predominantly container metaphor speak objects constituent fields internal state versus exported behaviors 
model consistent real-world metaphors treat composite entities containers enclose attributes metaphor carries visual depictions data structures typically show objects rectangles partitioned smaller boxes member field objects objects depicted boxes boxes objects enclose strict containment hierarchy object indirectly calls pointer java call pointer uniquely identifies single piece data holding data pointer simply records data found pictorial representations pointers presented arrows referrer referent programmer explicitly decide part complex data structure embeds directly indirect pointer java programmers deal directly java indirect embedding provided compound data types dot marks access embedded field object dock gnome dock dock container accesses embedded container field fields composite field access expressions extended long offers pointers roughly combine pointer semantics java syntax transitional form access deeply embedded subfields dock container widget requisition width section suggested english possessive construction capture member access satisfactory simple expressions roster firstelement difficult claim dock container widget requisition width effective comprehend extended field access chains programmers expressions explicitly linguistic terms operative model drilling outer containers start dock container continue widget widget hypothesis gains credence pointer fields dot represent pointer accesses textual approximation arrow client area field gnome dock pointer dock client areaparent cross pointer retrieve parent subfield field access expressions driving directions describe path starting point final destination individual steps listed order traversed programmers casually refer crossing pointer reinforcing spatial metaphor pointers paths bridges islands data refer falling end data structure traversing pointer object orientation anaphora role deixis lastelement method java vector named roster write roster lastelement code implements lastelement longer refer roster body lastelement call size read elementdata access member fields methods explicitly naming object object implicitly assumed object lastelement method called methods single object tend tightly interdependent convention convenient greatly improves code readability creates interesting deictic shift place metaphorical data space sense inside object location benefits privileges access internal attributes object visible outsiders abbreviated names size roster size missing information implicit surrounding context refer object inside java supply keyword purpose smalltalk author gnumeric gnumeric written strongly object oriented style java referencing object superclass keyword super current class hidden access superclass fields methods object meaning constant altered execution program statement introduce object contrast natural languages subject sentence introduced subsequent sentences anaphorically refer subject pronoun nancy brought chips party brought bottle soda detienne notes anaphora rare programming languages anaphoricreferences temporal conditions execution thismethod found aspect-oriented programming incorrectly applied anaphora lead ambiguity unacceptable programming languages polysemy homonymy overloading phenomenon address overloading policy sharing functions permit overloading java java vector class overloading add methods addall methods indexof methods lastindexof methods remove methods toarray methods cases same-named methods accept numbers arguments overloaded methods identical arity differ expected types arguments distinctions compiler select method overloading disambiguated manner detected disallowed aggressive overloading turn kword open source word processor written programmer defined kwstring type represent text sequences document type overloaded methods including named insert insert method expects arguments argument position kwstring insertion place argument sequence characters represented underlying graphical toolkit sequence characters represented kword single character picture tab placeholder automatically generated text current date page number footnote anchor floating figure programmer method distinct insertpicture inserttab insertfootnote single creates conceptual grouping methods sense equivalent inserts document fragment position differ inserted methods english verb insert picture insert anchor english argue single insert verb picture anchor grammatically interchangeable kword program pictures anchors distinct insertion requires slightly code general effect caller cases making convenient simply call insert compiler determine method intended effect insert polysemic exceptions found command-line shells refer result evaluated expression csh operator overloading debate operator overloading takes view mathematical operators simply functions special names syntax sum operators addition integers built language forms addition anticipated language designers programmers define arithmetic data type representation hamilton quaternion algebra intended behavior obvious metaphorical extension addition realm languages support operator overloading programmer extend basic operators support data types defining addition quaternions similar defining function improve readability easier scan sum product object-centered times authors numerical scientific code find operator overloading skeptics counter overloaded operator perform arbitrary computation relationship basic form presence operator overloading simplest code fragments assumed consistent meaning entire word processor overloading offer overloading names operators overloadable operators include obvious arithmetic obscure define operators create objects act arrays overloading lets create so-called smart pointers function invocation operator overloaded javaallowsmethod overloading operator overloading cognitive terms deconstruct debate distinct concerns issue arbitrariness overloaded operators behavior worry overloaded operators diverge homonyms rational polysemic connection primitive counterparts true hiding entire word processor equally true insert remove data vector represent color blue skilled programmers names cognitively rational ways reason operators concern overloaded operators make harder infer behavior code difficult matter programmers read code ways goals important understand precise literal behavior code create run overloaded operators obfuscating intent understand code higher level abstraction operators extended metaphorically principled manner boon homonymic extension shift operators surprisingly widespread operator overloading homonymic defines standard operators manipulate bit-level representation numbers left shift shift motivation built-in operators based visual iconicity resemble arrows pointing left binary operators shifts bits representing left positions standard library overloads shift operators completely unrelated purpose file input output writes file data store data file file data load data file programmers add operators extend file data types technically clever trick justifies output polysemic extension shifting left input polysemic extension shifting file data simply data flowing arrow file visual metaphor compelling justify derided arbitrary overloading conclusions future work modern software incredibly complex source microsoft windows million lines code linux kernel weighs million lines managing kind complexity requires programmers draw deeply cognitive abilities discussed ways programmers select names cognitively motivated ways lexical morphological conventions convey basic information role metaphors encourage productive inferences drawn domains experience grammars natural languages shape intricate ways polysemy appears overloading attendant debates literal versus metaphorically extended meaning find programmers leverage fundamental aspects cognition natural language comprehension make code easier read understand practical considerations motivated narrowly study role naming imperative languages expand scope increasingly linguistically sophisticated programming languages changed cognitive burden programmers conversely language designers support programming cognitive communicative task programming languages provide linguistic support anthropomorphism herbsleb study metaphors describe software behavior programming sophisticated intellectual process combines aspects natural language regular structure formal mathematical thought study 
programming potential contribute valuable perspectives current research linguistics cognition anand clarify function sigplan ben-ari sajaniemi roles variables educators proceedings iticse pages york blackwell metaphor analogy programming abstractions vanneste bertels decker jaques editors annual workshop ppig pages ghent belgium april cannon elliott kirchhoff miller milner mitze schan whittington spencer keppel brader recommended style coding standards http psgd paul docs cstyle cstyle htm caprile tonella nomen est omen analyzing language function identifiers proceedings wcre page washington carter choosing identifiers sigplan detienne software design cognitive aspects springer douce metaphors program annual workshop pyschology programming interest group carlowe ireland april gnome project gnome libraries release http gnome gnome project gnumeric release http gnome projects gnumeric goldberg robson smalltalkthe language implementation addisonwesley publishing reading green cognitive dimensions notations proceedings hci cognitive ergonomics pages herbsleb metaphorical representation collaborative software engineering proceedings wacc york usa acm press jones standard economic cultural commentary derek jones kaehler patterson taste smalltalk norton company york koffice project kword release http koffice kword laitinen estimating understandability software documents sigsoft softw eng notes lakoff johnson metaphors live chicago press chicago lewis art science smalltalk hewlett-packard professional books prentice hall international hertfordshire lopes dourish lorenz lieberherr aop naturalistic programming companion proceedings oopsla pages york maraia build master microsoft software configuration management practices addison-wesley professional september marca pascal style guidelines sigplan miller newman tests statistical explanation rank-frequency relation words written english american journal psychology ohba gondow mining concept keywords identifiers large software projects proceedings msr york sajaniemi proceedings hcc page washington sheppard curtis milliman love modern coding practices programmer performance ieee computer dec shneiderman software psychology winthrop publishers soloway empirical investigation tacit plan knowledge programming thomas schneider editors human factors computer systems pages ablex norwood stroustrup programming language addison-wesley series computer science addison-wesley publishing reading edition sun microsystems java sdk standard edition release http java sun takang grubb macredie effects comments identifier names program comprehensibility experimental investigation prog lang torvalds linux release http kernel yelick semenzato pike miyamoto liblit krishnamurthy hilfinger graham gay colella aiken titanium high-performance java dialect concurrency practice experience sept special issue java high-performance network computing zipf selected studies principle relative frequency language harvard press cambridge 
estimating impact scalable pointer analysis optimization manuvir das ben liblit manuel ahndrich jakob rehof microsoft research eecs department berkeley fmanuvir maf rehofg microsoft liblit eecs berkeley abstract paper addresses question scalable controlow-insensitive pointer analyses provide level precision required make compiler optimizations rst describe alias frequency metric measures ability pointer analysis determine pairs memory accesses programs aliases kind information variety optimizations remaining independent optimization show controlow context insensitive analyses provide answer pointer analysis statically generated alias queries order understand potential run-time impact remaining queries weight alias queries dynamic execution counts obtained pro data flow-insensitive pointer analyses accurate weighted alias queries examine scalable pointer analyses inaccurate remaining alias queries context-insensitive end developed context-sensitive pointer analysis serves general engine tracing values programs knowledge rst technique performing context-sensitive analysis subtyping scales millions lines code algorithm identify fewer aliases contextinsensitive analysis introduction programs written typically make widespread pointer variables order analyze program pointers perform pointer analysis computes dereference point program superset set memory locations accessed dereference points-to sets perform alias analysis optimizing compiler memory accesses points-to sets intersect aliases alias information utilized variety optimizations including limited code scheduling register allocation loop unrolling constant propagation years wide variety algorithms pointer analysis proposed including egh ste algorithms scale large programs believed produce poor alias information reason optimizing compilers perform global pointer analysis forced make conservative assumptions potential aliases paper argue scalable pointer analyses produce precise alias information interested determining scalable pointer analyses impact variety optimizations avoid evaluating pointer analyses context speci optimization speci compiler develop metric alias frequency measures frequency pointer analysis forced assert pair statically generated memory accesses program aliases experiments show alias frequency scalable pointer analyses das algorithm das alias frequency pointer analysis result extremely encouraging alias queries scalable pointer analyses imprecise queries greatest impact optimization code queries dominate run-time programs weight responses alias queries dynamic execution counts pro data expect large gap alias frequency das algorithm pointer analysis experiments show das algorithm pointer analysis terms weighted alias frequency source remaining inaccuracy das algorithm lack context-sensitivity understand impact limitation developed algorithm context-sensitive version das algorithm generalized level golf algorithm level idea das achieve limited form context-sensitivity addition subtyping results show appreciable decrease alias frequency context-sensitivity golf general engine tracing values programs pointers indirect function calls context-sensitive manner applications program slicing tip escape analysis ruf golf rst context-sensitive analysis subtyping scales millions lines code golf improve alias frequency provide precise results context-insensitive algorithm client analysis context-sensitive section summary make contributions present alias frequency metric measuring impact pointer analysis optimization demonstrate scalable pointer analyses produce precise responses alias queries test programs show addition context-sensitivity improve alias frequency scalable pointer analyses present golf ow-insensitive pointer analysis utilizes limited amount context-sensitivity subtyping produces pointsto graph linear size program linear time points-to sets program extracted graph cfl-reachability worst-case cubic time show test programs golf linear time space requirements show limited forms context-sensitivity subtyping golf provide precision algorithms full polymorphism subtyping claim golf provide precision algorithm full polymorphic subtyping rest paper organized section motivate golf describe golf section section present alias frequency section present empirical results discuss related work section conclude section fragment program function calls shown return idi idj goal context-sensitive pointer analysis avoid confusing addresses returned function variables calls pqi points-to information computed das algorithm shown points-to graph shown nodes representing memory locations edges representing pointer relationships node single pointer edge target node represents location points-to graph includes special edges labeled nodes flow edges introduced assignments level points-to graph expressions involved assignment program implicit assignment parameter induced function call introduces edge node pointer target node indicating set symbols represented include return statement induces implicit assignments result set symbols represented includes execution program address ows pointed authors previous work rhs problem arises owing call site allowed erent call site points-to graph produced golf shown label edges arising function calls identi ers edges call site identi edges polarity indicating owing called function graph included set symbols path edge labeled edge labeled valid path calls returns matched edge labeled matched edge labeled valid path golf graph sequence labels forms string context-free language matched labels presence valid paths pair nodes determined worst-case cubic time cfl-reachability queries rhs das algorithm golf achieve scaling partly limiting edges level points-to graph uni cation type equality rules merge nodes lower levels experiments show restriction context-sensitivity level lead loss precision compared full context-sensitivity golf generalized level flow pointer analysis thought abstract computation models memory locations location set symbols holds contents abstract pointer figure location points-to contents pointer information locations encoded points-to graph nodes represent locations edges represent points-to relationships steensgaard uni cation-based algorithm ste ect assignment equate contents locations achieved unifying equating ids contents locations pointed-to representative location das algorithm extends steensgaard algorithm pushing ect assignment processing level chains points-to graph figure ect assignment introduce special edge pointed-to location pointed-to location equate contents pointed-to locations figure flow edges relate ids locations symbols source edge included target edge assignment processing represented declaratively figure type rule program correctly typed pointed-to locations contents pointed-to location subset pointed-to location golf extends das algorithm treating implicit assignments induced function calls special manner obtain context-sensitive information fxg fyg symbols locations ids sng values ptr ptr ptr welltyped fig assignment processing das algorithm figure shows points-to graph processing domains type rule gure provide declarative speci cation assignment processing fpg fyg fxg frg path optimization programs application debugging star akash lal junghee lim marina polishchuk ben liblit computer sciences department wisconsin-madison akash junghee mpoli liblit wisc abstract present solve path optimization problem programs set program nodes called critical nodes find shortest path program control flow graph touches maximum number nodes control flow graphs over-approximate real program behavior adding dataflow analysis control flow graph narrow program actual behavior discard paths deemed infeasible dataflow analysis derive efficient algorithm path optimization based weighted pushdown systems present application path optimization integrating cooperative bug isolation project cbi dynamic debugging system cbi mines instrumentation feedback data find suspect program behaviors called bug predictors strongly program failure instantiating critical nodes nodes bug predictors solve shortest program path touches predictors path programmer debug software present early experience hybrid static dynamic system debugging introduction static analysis programs variety purposes including compiler optimizations verification safety properties improving program understanding static analysis advantage executions program giving strong guarantees program behavior paper present static analysis technique finding program execution sequence optimal respect criteria set program locations call critical nodes find trace program execution traces touches maximum number critical nodes shortest length traces reachability programs undecidable general over-approximate set traces program paths control flow graph solve optimization problem collection paths closely approximate actual program behavior discarding paths control flow graph deemed infeasible dataflow analysis show powerful framework weighted pushdown systems represent solve variations path optimization problem star supported part onr contracts nsf grant ccrand gift microsoft research important find paths conint void main init process void clear int null void process int switch getchar case clear break case fig buggy program fragment sider program fragment shown figure suppose crashes input line debugging program find analysis statement null clear caused null-pointer deference crash site line isolation indication actual bug construct path program entry point main crash site visits suspect line clear path touches statements shown bold figure shows program call clear process continue execution crash site closer examination path suggest break statement clear return statement paths richer understanding program behavior examining isolated statements procedures implemented path optimization algorithm integrated cooperative bug isolation project cbi create btrace debugging support tool cbi adds lightweight dynamic instrumentation software gather information runtime behavior data identifies suspect program behaviors called bug predictors strongly program failure bug predictors expose circumstances failure successfully find previously unknown bugs cbi primarily dynamic system based mining feedback data observed runs work btrace represents major effort combine cbi dynamic approach static program analysis btrace enhances cbi output giving context interpreting bug predictors cbi bug predictors set critical nodes construct path entry point program failure site touches maximum number predictors cbi associates numerical score bug predictor higher scores denoting stronger association failure extend btrace find shortest path maximizes sum scores predictors touches btrace finds path sum predictor scores predictors path maximal shorter path score user restrict attention paths unfinished calls order stack trace left failed program impose constraints order predictors touched constraints enhance utility btrace debugging purposes producing path close actual failing execution program give user substantial insight root failure present experimental results section support claim extra constraints path optimization problem solved btrace stated btrace problem control flow graph program nodes edges single node representing crash site program set critical nodes representing bug predictors function representing predictor scores find path control flow graph maximizes set critical nodes path touches minimizes length restrict search optimal path paths satisfy constraints stack trace stack trace paths reach unfinished calls order stack trace ordering list node pairs paths touch node node dataflow dataflow analysis framework ptr paths ptr ruled infeasible dataflow analysis requirements dataflow welltyped analysis framework welltyped fun section finding feasible path program exists general undecidable welltyped powerful fig dataflow function analysis call btrace processing golf return graph path fragments represent real points-to execution information processing program call acceptable function judge argument usefulness call path site ease helps exposition programmer debug assume program functions normalized feasibility statement key fun contributions paper nes function present single algorithm formal parameter optimizes path selection parameter program holds return criteria statement body weighted pushdown labeled systems constraints provide common setting generated function calls similar mentioned optimization instantiation constraints constraints polymorphic satisfied type describe inference hybrid hen static dynamic system direction combines constraints optimal path selection negative polarity cbi bug reversed predictors match support direction debugging remainder values paper organized ect function calls section golf presents shown formal theory figure parameter representing passing paths induces program edges section derives labeled algorithm call site finding identi optimal path polarity section figure considers path polarity optimization direction conjunction values cbi debugging programs called function presents experimental formal results parameter demonstrating approach function feasible return section discusses statement function call related processing work represented area declaratively section type concludes rules function final nitions remarks describing function paths calls program figure section introduces basic theory called function approach generates special section labeled constraints formalize set ids paths pointed-to locations program pushdown contents system pointed-to section locations introduces weighted equated pushdown labeled systems constraints similar added ability associate path emain call ret exitmain exitp call ret emain arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft exitmain exitmain arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft exitp arrowhookleft exitp exitp arrowhookleft fig control flow graph exit nodes represent entry exit points procedures dashed edges represent interprocedural control flow pushdown system models control flow graph shown single state rule cfg edge rules correspond procedure calls save return site stack rules subset constraints labels restrict ways constraints composed transitively explained section 
rule invalid values arises edge labeled representing values function call site edge labeled representing values back erent call site valid paths set valid paths characterized precisely grammar shown sequence labels encountered path edges forms string path valid path sequence labels forms string context-free language recognized non-terminal declarative speci cation golf algorithm viewed set non-standard type inference rules simple language pointer related assignments set rules includes rules figure rules das algorithm handling kinds explicit assignment statements shown welltyped ptr welltyped ptr welltyped ptr welltyped correctness claim type rules figure provide speci cation correct ow-insensitive context-sensitive pointer analysis observation type rules viewed restriction type system presented rehof ahndrich type system shown correct nes algorithm full subtyping polymorphism golf type rules algorithm level subtyping level polymorphism formal connection constraint satisfaction type inference rules valid paths golf points-to graph connection provided global storage goal golf identify valid induced function calls programs include global variables functions occur global variable labeled edge produced pointsto graph reps suggested treating globals extra parameters lead large increase size points-to graph identify nodes globals call global storage nodes add loops nodes labeled call site polarity conservative approximation ensures omit values global variables similar problem occurs indirect accesses pointer valued parameters solution modify function call rule add loops call site label nodes nodes related labeled edges conservative approximation treating nodes global storage nodes operational algorithm symbol referenced program unique location demand program processed assignment time including implicit assignments generated function calls assignment locations uni satisfy type equality requirements imposed non-standard type inference rules figure section processing simple subset constraints labeled constraints delayed introducing edges locations shown figures locations uni edges locations turn loops unlabeled loops discarded labeled loops retained order capture valid golf graph edges das points-to graph practice increase edge count low processing entire program complete points-to sets produced points-to graph symbol included points-to set dereference valid path node node reps observed presence path determined cfl-reachability queries rhs single-source queries symbol program populate points-to sets global storage identify mark global storage nodes linear scan points-to graph adding linear number edges global storage node account ect edges implicitly valid path node node global storage node valid path node node valid path node node unmatched labeled edges path matched set edges words ect global storage node introduce transitivity cfl-reachability queries leads modi reachability procedure node reachable node reach stepping global storage nodes valid paths hop global storage node complexity algorithm steps assignment processing step produces points-to graph edges propagation step rst step complexity steensgaard algorithm linear space linear running-time size program implicit assignment addition single labeled edge number implicit assignments linear presence indirect calls single signature target functions call site ste step involves cfl-reachability query graph symbol program worst-case cost all-pairs cfl-reachability query graph cubic number graph nodes rhs complexity golf cubic size program cient cfl-reachability subsection explain insights ciently compute points-to sets large programs memoization rst insight simple memoization borrowed das amortize cost multiple queries avoiding repeated work experiments show points-to graph single node blob large number outgoing edges graph blob order magnitude outgoing edges node set symbols valid paths blob symbol repeat scan subgraph originating blob perform scan blob cache result share symbols reach blob pre-compute set nodes reachable blob frontier nodes set symbols reach blob symbol reach blob perform forward scan dereference nodes usual symbol reaches blob perform forward scan stop frontier nodes processed symbols append symbols reach blob points-to set frontier node symbol compose scan blob scan symbol cfl-reachability transitive treating nodes reachable symbol blob global storage node compose loss precision programs blob global storage node extremely small require memoization hand frontier nodes scan symbol arrives matching requirements valid path scan blob stop scan nodes compose scan blob fail visit nodes identify cases scan symbol continue scan frontier node simple memoization results dramatic speedup empirical evidence shows scans involve blob amortize scan cost remaining scans cover small regions graph existence blob coincidence ects presence global variables referenced program blob node accumulator large points-to sets sets poor targets improvement precise pointer analysis shrink small sets precise analysis spend considerable resources tracking global variables points-to sets reach blob targets precise analysis global storage insight transitive behaviour global storage nodes make single scan cient global storage nodes serve points divide conquer strategy form longer valid paths shorter valid paths enforcing matching requirements summary edges algorithm single cfl-reachability query based demand algorithm outlined horwitz hrs improves ciency queries adding special summary edges graph adapted algorithm handle nodes shared functions uni cation handle global storage alias frequency interested estimating impact pointer analysis compiler optimizations manner independent optimizing compiler optimization previously ned measures precision pointer analysis independent optimization average points-to set size number singleton points-to sets provide indication ability pointer analysis enable optimizations identifying memory accesses aliased propose alias frequency metric estimates precision alias information produced pointer analysis simple alias frequency program queries set alias queries query involves pair memory access expressions occuring statically program alias frequency pointer analysis percentage queries analysis refer memory location execution program simple alias frequency queries queries aliases alias queries extreme approach generating alias queries pairs memory accesses encountered program result large number pairs accesses erent functions pairs uninteresting typical optimizer optimize code function boundaries alias queries memory access expressions occur body function duplicate pairs queries represent intra-procedural optimizations performed commonly compilers expressions multiple dereference operators order limit number queries top-level memory accesses assignment expressions conditional expressions function arguments experimented erent criteria selecting queries including subexpressions nested dereferences ignoring function arguments found results remain consistent categorizing queries categorize memory accesses based require pointer information resolve symbol-access recursively symbol-access variable eld access operation symbol-access array index operation symbol-access array type remaining memory access including dereference arrow operation array index operation object pointer type pointer-access alias query relating symbol-accesses answered pointer analysis symbol-accesses refer variable aliases var var measuring pointer analysis pointer analysis produces points-to set pts expression set pts fvar gfor symbol-access answer queries involving pointer-accesses accesses aliases points-to sets overlap pts pts notice queries include aliases globals locals referenced body function measuring worst pointer analysis interested understanding gap alias 
precision scalable pointer analyses precise algorithms create arti cial lower bound analysis under-estimates alias frequency safe pointer analysis treating query involving pointer-access aliased exception golf determines pair accesses refer single stack global symbol lower bound analysis treats pairs aliases pts pts fvg lower bound analysis property precise pointer analysis alias query pointer analysis close alias frequency lower bound analysis close precise safe pointer analysis create arti cial upper bound analysis treating query involving pointer-access aliases upper bound analysis form pointer analysis program metric over-estimates alias frequency lower bound analysis pair accesses variable aliases accesses refer erent structure elds concerned erence analysis lower bound pairs accesses access pointer-access lower bound analysis treats pairs aliased pointer analyses potentially improve response queries eld distinction pairs symbol-accesses analyses including lower bound analysis equally lack eld distinction leads conservatively over-estimate precision gap pointer analysis lower bound analysis weighted alias frequency mentioned introduction estimate potential impact run-time alias queries pointer analysis produces possibly inaccurate response weight response analysis query sum dynamic execution counts num num gathered pro data accesses query weighted alias frequency queries num num queries num num small erence weighted alias frequency pointer analysis lower bound analysis means precise pointer analysis enable additional optimizations improve run-time signi cantly create dummy symbols dynamic allocation site represent heap storage lower bound analysis treat accesses heap symbol aliases pointer analyses argument applies accesses static arrays program loc ast nodes time compress ksim ijpeg perl vortex gcc word table benchmark data program table shows lines code ast node count running-time seconds golf experiments produced modular implementation golf ast toolkit extension microsoft visual compiler implementation handles simply pop-off top stack reveal recent return site paths program control flow graph cfg program graph nodes program statements edges represent flow control statements figure shows cfg program procedures adopt convention procedure call program represented nodes source interprocedural call edge callee entry node target interprocedural return edge callee exit node back caller figure nodes represent call main nodes represent call paths sequences nodes connected edges cfg valid path emain exitp invalid call features details found das implemented golf modifying rules parameter passing return statements implementation das algorithm adding cflreachability engine implementation das algorithm tested extensively usual testing veri correctness implementation golf ways performed reachability queries forward backward memoization veri results case tested implementation cflreachability treating labeled edges unlabeled verifying obtain points-to sets das algorithm benchmark programs table shows benchmark programs consisting integer benchmarks spec version microsoft word benchmark list total lines source code including comments blank lines number ast nodes accurate measure program size analysis time seconds golf averaged runs analysis time includes time analyze compilation unit excluding parse time time write object les time read object les perform uni cations compute points-to sets exhaustively static dereference points program cfl-reachability experiments conducted dell desktop running windows ram single mhz intel pentium iii processor alias precision pointer analysis table shows simple weighted alias frequencies pointer analyses obtained execution counts computation weighted alias frequency instrumenting benchmarks running spec program simple alias frequency weighted alias frequency lower golf das ste upper lower golf das ste upper compress ksim ijpeg perl vortex gcc word average table precision pointer analyses benchmark program table shows simple alias frequency lower bound analysis lower golf das algorithm das steensgaard algorithm ste upper bound analysis node return node node general valid paths cfg context-free language matching call return pairs call matching return edge exit node reason natural pushdown systems describe valid paths program definition pushdown system pds triple finite sets set states set stack symbols set pushdown rules rule written arrowhookleft pds finite automaton stack input interested transition system describes language generates definition configuration pushdown system pair rules pushdown system describe transition relation configurations arrowhookleft rule uprime uuprime uprime construction pds represent paths cfg fairly straightforward shown figure transition system constructed pds mimics control flow program sequence transitions transition system ending configuration stack trace describes path cfg unfinished calls return sites sense configuration stores abstract run-time stack program transition system describes valid program make weighted pushdown systems weighted pushdown system wpds obtained associating weight pushdown rule weights set satisfies bounded idempotent semiring properties definition bounded idempotent semiring quintuple set elements called weights elements combine 
operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule operation compute weight concatenating paths operation compute weight merging parallel paths sequence rules define val definition item required wpdss efficiently explore paths item required termination wpds algorithms sets pushdown configurations sprime path sprime set rule sequences transform configuration configuration sprime denote set stacks start existing work wpdss solve problems definition letw weighted pushdown system withp configuration generalized pushdown predecessor gppc problem find regular set configurations circleplustext val path witness set paths path circleplustext val generalized pushdown successor gpsc problem find regular set configurations circleplustext val path witness set paths path circleplustext val definition avoid defining regular set configurations restricting single configuration cprime problems considered backward forward reachability problems aims find combine values paths pairs configurations find witness set paths justify reported set paths finite item definition note reachability problems require finding smallest witness set wpds algorithms find finite set finding optimal path section solve specific btrace problem defined section begin developing solution basic path optimization problem dataflow ordering constraints add back creating wpds cfg pushdown system representing paths constructed section set critical nodes notation section construct wpds solved find path path track length set critical nodes touches set elements consist subset critical nodes touched natural number length path associate path element accomplished defining weight summarize set paths set elements combine operation simply takes union weights eliminates element elements shorter path length chosen drives wpds paths shortest length extend operation takes union critical nodes sums path lengths pair elements weights reflects fact path length touches critical nodes extended path length touches critical nodes path length touches critical nodes semiring constant denotes infeasible path constant denotes empty path touches critical nodes crosses graph edges formalized definition definition bounded idempotent semiring component defined set weights power set define reduce reduce notexistential vprime vprime define reduce semiring constants complete description wpds associate pushdown rule weight arrowhookleft associate weight rule length path increased set critical nodes grows include critical node easy sequence rules describes path cfg val set critical nodes touched path length solving wpds optimal path found solving generalized pushdown reachability problems wpds scenarios crash site stack trace crash crash site stack trace start crash site entry point program crash site theorem solving gps path touches critical nodes shortest path length set paths path touches critical nodes length theorem holds paths set paths unfinished calls taking combine values paths selects subsets shortest path touches critical nodes discards longer witness set record paths justify reported path singleton-set weight path member stack trace topmost element gps gpp theorem inw solving gps gpp values valid path stack trace touches critical nodes shortest path length set paths stack trace path touches critical nodes length theorem find required values gps gpp forward reachability starting forward program backward reachability starting stack trace backwards appendix presents detailed discussion complexity solving problems wpds worst-case complexity exponential number critical nodes practically linear size program exponential complexity critical nodes unavoidable reason path optimization problem solve strict generalization traveling salesman problem objective find shortest path points touches set nodes find complexity limitation experiments obtained values find optimal path easily user-defined measure associates score critical node compute score summing scores critical nodes choose pair highest score extracting path pair optimal path upper erence simple alias frequency das lower data shown weighted alias frequency obtain dynamic execution counts word inputs data shows scalable pointer analyses surprisingly close lower bound analysis das algorithm lower bound analysis alias queries benchmark programs understand loss precision scalable pointer analysis manually examined fraction queries das algorithm ers lower bound analysis found case lower bound analysis unsound straightforward eld distinction resolve query aliased gap alias frequency scalable pointer analyses pointer analysis fact data table shows erence weighted alias frequency das algorithm lower bound analysis similar erence simple alias frequency benchmark claim queries das algorithm inaccurate provide signi additional opportunity optimization benchmarks erences weighted alias frequencies analyses similar erences simple alias frequency analyses argue simple alias frequency indicator precision implementors pointer analysis access pro data optimizing compilers consume alias information produced analyses input gcc consists source les ran gcc largest source les averaged execution counts das golf table shows alias frequency das algorithm improved addition context-sensitivity benchmark word data shows practice scalable pointer analyses sacri optimization opportunity lack context-sensitivity ste data shows steensgaard algorithm surprisingly close lower bound analysis poor precision algorithm terms points-to set size table largely pollution points-to sets occurs steensgaard algorithm leads accumulation variables functions pollution result conservative alias relationships pointer variables function smaller points-to sets imply lower alias frequency smaller sets subset common symbols finally points-to set sizes arti cially ated inclusion symbols scope table table show traditional measures precision pointer analysis ect ability analysis produce good alias information das andersen previous work das shown das algorithm andersen algorithm produce identical points-to sets alias frequencies expected identical limitations measure alias frequency evaluating pointer analysis signi cantly improve alias frequency analysis including lower bound analysis adding structure eld analysis array index analysis results apply programs apply programs written java open question aggressive inter-procedural optimizers utilize alias information inter-procedurally ruf opportunities ected selection alias queries potential concern results scalable pointer analyses close lower bound analysis swamped query set pairs symbol accesses average queries require form pointer information large percentage form pointer analysis compilers expected generate large number alias queries million queries word query require reachability points-to graph amortization technique section answer alias queries extremely ciently answer queries word minutes regions program accurate analysis eliminate aliases instance linked list traversal previous current pointers results show approach rst run scalable pointer analysis apply precise shape analysis locally functions functions identi alias frequency performance precision golf performance gure chart advantages userdefined measure user bug predictor scores cbi make scores user give negative score critical nodes avoided path critical nodes score added ordering constraints section lets tool work interactively user find suitable path generally user give measure directly associates score path measure user decide choose shorter paths paths touch critical nodes adding ordering constraints add ordering constraints path optimization problem suppose constraint node visited node paths visit visiting easy add constraints wpds extend operation compute path simply change yield paths satisfy ordering constraint redefine reduce ordering constraint simply add clauses constraint definition extend constraints change worst case asymptotic complexity solving reachability problems wpds prune paths explored constraint cuts size weights produced extend operation adding dataflow analysis considered interpreting semantics program control flow implies wpds find infeasible paths occur execution program path assigns true branch conditional general undecidable restrict attention paths occur program execution rule infeasible paths increase chances presenting feasible near-feasible path user dataflow analysis dataflow analysis carried approximate program variable set values variable point program dataflow analysis satisfies conditions integrated wpds designing weight domain examples dataflow analyses include linear constant propagation affine relation analysis bounded idempotent semiring weight domain provided function associates pds rule cfg running times golf table ratio running-time program size edge weight satisfies property possibly infinite set paths pair program nodes circleplustext vald paths infeasible vald means vald infeasible path imposes soundness guarantee dataflow analysis rule infeasible paths details classical dataflow analysis frameworks encoded weight domains found reps basic idea encode dataflow transformers capture effect executing program statement sequence statements weights extend operation composes transformers combine operation takes meet dataflow lattice translation dataflow transformers weight domain talk meet-over-all-paths configurations pushdown system solving gps weight domain combine meet values paths stack trace unique advantage gain conventional dataflow analysis wpdss change weight domain wpds definition bounded idempotent semiring component defined set weights power set set define reduced reduced defined min define reduced setbraceleftbigg vextendsingle negationslash satisfy ordering constraints bracerightbigg semiring constants satisfy ordering constraints iff constraint visit case weight rule arrowhookleft path set predictors touches length dataflow infeasible paths removed extend operation weights dataflow discarded formally path cfg val vald negationslash dataflow path length path set critical nodes touched path path satisfies ordering constraints satisfy ordering constraint vald val analysis weight domain similar property simulation esp distinct dataflow maintained property-state maintain distinct dataflow weight subset critical nodes repeating theorems present case gps stack trace results cases obtained similarly theorem wpds obtained weight domain defined definition solving gps values path stack trace visits critical nodes satisfies ordering constraints infeasible weight domain shortest path length path stack trace visits predictors satisfies ordering constraints length generally paths constant val min worst case time complexity 
presence dataflow analysis increases factor height time required applying time required applying theorem completely solves btrace problem mentioned section section presents dataflow weight domain experiments extensions dataflow analysis copy constant propagation give weight domain dataflow analysis encode copy-constant propagation weight domain similar encoding sagiv reps horwitz copy-constant propagation aims determine variable fixed constant point program interprets constant-to-variable assignments variable-tovariable assignments abstracts assignments constant ignore conditions branches var set global integer variables program zlatticetop latticetop zlatticetop intersectionsq standard constant propagation meet semilattice obtained partial order subsetsqequalcp csubsetsqequalcp latticetop set weights weight domain var var zlatticetop represents dataflow transformer summarizes effect executing sequence program statements env var state program statements executed zlatticetop variable statements executed env intersectionsqenv intersectionsqenv intersectionsqc component component define semiring operations combine operation concatenation expressions extend operation substitution formally intersectionsq uniondisplay intersectionsq semiring constants latticetop latticetop handling conditionals handling branch conditions problematic dataflow analysis presence conditions hard finding branch condition evaluate true copy-constant propagation pspace-complete resort approximate dataflow analysis give computing meet-over-all-paths translates relaxing distributivity requirement weight domain fortunately wpdss handle non-distributive weight domains relaxing definition item set weights subsetsqequal subsetsqequal subsetsqequal partial order defined subsetsqequal iff weaker property generalized reachability problems solved approximately obtaining configuration obtain weight subsetsqequal path optimization problem inaccuracy limited dataflow analysis eliminate paths dataflow analysis find infeasible find path vald acceptable rule infeasible paths flexibility putting simple treatment conditions dataflow analyses disadvantage lose strong characterization type paths eliminated copy-constant propagation extend set weights arithmetic condition associate weight rule arrowhookleft cfg edge evaluates true program state associate weight true branch conditional weight xnegationslash false branch extend operation modified evaluates condition information provided results evaluates false extend simply details found companion technical report handling local variables recent extension wpdss shows local variables handled merge functions local variables saved call merged information returned callee compute effect call treatment local variables restrict weight manage local variables procedure details construction merge functions companion technical report integrating btrace cbi formalisms section solving variety optimization problems concerned touching key program points path btrace represents application ideas enhancement statistical debugging analysis performed cooperative bug isolation project cbi failure paths cbi runtime instrumentation statistical modeling techniques diagnose bugs widely deployed software cbi identifies suspect program behaviors called bug predictors strongly program failure candidate behaviors include branch directions function call results values variables dynamic properties bug predictor assigned numerical score balances key factors predictor increases probability failure failed runs predictor accounts high-value predictors warrant close examination highly correlated failure account large portion failure rate end users key strength cbi samples behavior entire dynamic lifetime run interpreting resulting predictors located program prior failure point challenging work isolated bug predictors programmer navigate forward backward path led failure btrace constructs path hits high-ranked chart predictors shows ratio programmer fairly draw steady connections program size sections grows code indicating seemingly analysis scales unrelated act linearly concert bring program btrace implementation implemented btrace wpds library manage exponential complexity number bug predictors efficiently encode weights abstract decision diagrams adds provided cudd library additional details semiring operations implemented adds found companion technical report btrace debugging session starts list related bug predictors believed cbi represent single bug designate list high-ranked prefix thereof critical nodes insert locations cfg branch predictors treated special case predictors associate direction conditional failure repositioned branch exploiting location semantic meaning bug predictor branch predicates make easy semantic meaning directly corresponds control flow dataflow analysis track integerand pointer-valued variables structure fields track contents memory write memory pointer replaced assignments variables address direct structure assignments expanded component-wise assignments fields structure case studies siemens suite applied btrace buggy programs siemens test suite tcas replace print tokens programs crash produce incorrect output analysis performed stack trace treating exit main failure point find btrace non-fatal bugs tcas array index error one-line function cbi instrumentation easily overlooked bug predictors btrace produces shortest path exits main revealing bug adding top-ranked predictor btrace isolates lines calls buggy function replace incorrect function return btrace top predictors yields path faulty statement predictor located disjoint chains function calls invoked main falls function bug isolated predictors directly reveal bug btrace failure path predictors print tokens off-by-one error predictors suffice steer btrace faulty line repositioning branch predictors critical nineteen cbi-suggested predictors dataflow analysis enabled correct failure path results branch predictors repositioned steer path proper direction case studies ccrypt run btrace small open source utilities ccrypt ccrypt encryption decryption tool arbitrary precision calculator written fatal bugs characterized prior work liblit detailed discussion experimental results found companion technical report ccrypt input validation bug reading end-of-file yields null string char subsequently dereferenced checked stack trace btrace builds infeasible path takes impossible shortcuts initialization code shortcuts yield null values places properly checked real bug path remains add dataflow analysis bug predictors add fourteen bug predictors dataflow analysis btrace dataflow analysis eleven bug predictors failure path feasible path correctly describes bug non-null values well-checked initialization code fatal unchecked null feasible path arises stack trace manually inserts ordering constraints require bug predictors initialization code initialization code assumed bug-free combination dataflow analysis bug predictors make manual priori assumptions unnecessary buffer overrun bad loop index arrays silently trashes memory program running eventually crash subsequent call malloc stack trace point failure suggests heap corruption real clues corruption occurred piece code cbi-identified bug predictors scattered files relationship clear examination bug predictor btrace builds path calls arrays early execution path feasible misleading arrays called early execution subsequent call arrays failure bug predictors forces path include fatal call arrays correctly reflecting true bug reading in-progress calls failure trace easily reconstruct entire stack call arrays point interest give deeper context frontier bad code cbi produces ranked lists related bug predictors suggesting distinct bugs btrace produces path list suggesting correspond single bug btrace correct lists correspond single bug cbi confused sampling noise statistical approximation incompleteness dynamic data factors btrace check letting unify equivalent bug lists cbi incorrectly held section mentioned solving wpds require time exponential number bug predictors find actual slowdown gradual absolute performance btrace good expected gps phase dominates creating initial wpds extracting witness path solved system negligible time small ccrypt application cfg nodes typical failure path btrace requires seconds find path ccrypt predictors increasing gradually seconds 
fifteen predictors adding predictors slows analysis gradually amplified adding predictor forces btrace build longer failure path larger cfg nodes typical failure path produced btrace nodes long complete analysis takes seconds predictors adding dataflow analysis slows analysis factor twelve depending configuration details analysis dataflow realistic numbers bug predictors takes thirteen seconds seconds ccrypt related work codesurfer path program inspector size tool golf requires weighted roughly pushdown systems time verification memory program das drive algorithm automaton present summarizing detailed program data property space consumption bad state low golf requires witnesses produce faulty word program compress path ksim ijpeg perl dataflow vortex analyses gccword encoding average benchmark weights analysistime rule msper nodes infeasible precision paths scalable wpdss pointer analyses optimizing table property shows precision verifying golf measured traditional previously metrics explored liblit table shows aiken directly average size problem points-to sets finding dereference failure points paths number program singleton points-to present sets family analysis benchmark techniques previous exploit work dynamic size information points-to set failure sites dereference stack point number program symbols including dummy symbols produced dynamic allocation sites points-to set dereference expression analyses run settings implementation omit data points-to sets indirect call sites golf improve points-to sets function pointers points-to sets single elements represent opportunites replacing conditional updates strong updates smaller points-to sets lead greater ciency subsequent analyses 
run-time overhead systems instrument code mce data shows golf produces singleton sets das algorithm benchmarks results consistent results foster ffa found traces improvement precision addition polymorphism pointer event analysis logs subtyping construct set benchmark programs paths larger program ffa greater improvement larger optimize path length number programs precision full polymorphic subtyping golf approximates full polymorphic subtyping algorithm restricting subtyping polymorphism level type structure das events touched shown level restriction unreachable subtyping single path loss approach precision das general data btrace frd incorporates onelev techniques columns table dataflow shows analysis level unifying framework restriction weighted polymorphism pushdown systems precision difference loss event logs golf extracts output precision cbi guide analysis path-finding full analysis polymorphism theory subtyping presented section extended incorporate combination event logs full polymorphism adding ordering full constraints subtyping appropriately eliminate restrict spurious order values events combination visited limited path polymorphism pse limited tool subprogram finding average failing thru-deref size paths singleton requires sets ste user-provided das golf description frd onelev error ste das golf frd occurred onelev pointer assigned compress null dereferenced description form finite state automaton problem ksim finding failing run reduced finding backward path ijpeg drives automaton error state initial state pse solves presence perl pointer-based data structures aliasing work require vortex user description bug caused gcc crash handle word pointer-based structures pse table precision pointer analysis pointer preprocessing analyses step produce benchmark program accurate dataflow table weights shows definitions average size define points-to sets semirings static dereference power points set ste values das golf associate polymorphic version path steensgaard approach algorithm presented frd general level setting restriction lengauer frd onelev theune table power set shows operation number add dereference points distributivity singleton semiring points-to sets found reduction function algorithms reduce frd ensures onelev form sets compared directly elements analyses lists bug predictors based rehof derived implementation iterative ranking polymorphic version elimination steensgaard algorithm liblit algorithm frd statistical debugging algorithms implementation analyze cbistyle word data typing proposed golf including unable based perform regularized curve direct comparison fitting sparse disjunction learning scale probability polymorphic density subtyping function large estimation programs support vector context-sensitive clients machines order random populate forests points-to btrace sets path accumulate reconstruction predictors pointer arising values function techniques callers require list predictors points-to set numerical scores reflecting das importance study reveal statistical debugging algorithms yield btrace paths conclusions presented static analysis technique build btrace tool find optimal path program constraints imposed user bug predictors produced cbi btrace perform postmortem analysis program reconstruct program path reveals circumstances failure paths produced btrace feasible intend programmers understand bug predictors produced cbi locate bugs quickly btrace user options supply additional constraints form stack traces ordering constraints user guide tool interactively locating bug case studies show btrace path isolate chain events leading failure predictors ability lead programmer directly faulty code experiments required prove utility btrace debugging larger software systems initial results promising acknowledgments susan horwitz insightful comments earlier draft paper aho sethi ullman compilers principles techniques tools addison-wesley reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog volume liblit cooperative bug isolation phd thesis california berkeley liblit naik zheng aiken jordan scalable statistical bug isolation sigplan conf prog lang design impl lal reps balakrishnan extended weighted pushdown systems computer aided verification bouajjani esparza touili generic approach static analysis concurrent programs procedures symp princ prog lang sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci ller-olm seidl precise interprocedural analysis linear algebra symp princ prog lang ller-olm seidl analysis modular arithmetic european symp programming das lerner seigle esp path-sensitive program verification polynomial time sigplan conf prog lang design impl wegman zadeck constant propagation conditional branches symp princ prog lang ller-olm thing complexity constant propagation european symp programming lal lim polishchuk liblit btrace path optimization debugging technical report wisconsin-madison liblit aiken zheng jordan bug isolation remote program sampling sigplan conf prog lang design impl kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds somenzi colorado decision diagram package technical report colorado boulder hutchins foster goradia ostrand experiments effectiveness dataflowand control-flow-based test adequacy criteria proc int conf softw eng ieee computer society press grammatech codesurfer path inspector http grammatech products codesurfer overview html balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds computer aided verfication liblit aiken building backtrace techniques postmortem program analysis technical report csd- california berkeley manevich sridharan adams das yang pse explaining program failures postmortem static analysis found softw eng lengauer theune unstructured path problems making semirings preliminary version wads volume lecture notes computer science springer zheng jordan liblit aiken statistical debugging sampled programs thrun saul sch lkopf eds advances neural information processing systems mit press cambridge zheng statistical software debugging phd thesis univ california berkeley liu yan fei han midkiff sober statistical mmodel-based bug localization found softw eng york usa acm press jiang automatic isolation cause-effect chains machine learning technical report cse- california davis complexity solving wpds section discuss worst-case running time complexity solving wpds constructed weight domain defined definition methods outlined theorems require solving gps gpp reading configuration time required reading witness factored steps number pushdown rules size cfg proc number procedures program entry point program number critical nodes length shortest path distant cfg node height length longest descending chain semiring time required perform semiring operation avoid requiring wpds terminology specialize complexity results solving reachability problems wpds gps solved proc time gpp requires time reading constant time requires time put results stack trace option theorem obtaining optimal path case requires time proc stack trace theorem options suppose stack traces multiple failures caused bug option solve gps stack trace worst-case time complexity proc average length stack traces option requires stack trace solves gpp asks worst-case time complexity evident complexities option faster complexity grows faster increase note worst-case complexities comparisons based hold average case fact wpds wpds implementation solving gps faster solving gpp present intuition comn fig simple control flow graph plexity results stated cfg shown figure node critical node path takes left branch length path takes branch length touches critical nodes path path discarded remember path branching program algorithm golf void read obj obj flockwrap lock lockwrap lock void lockwrap lock facquirelock labeled edges golf produce distinct summaries function behaviour erent call sites summaries leveraged client golf long client context-sensitive instance context-sensitive analysis tracks lockable objects summaries lockwrap produced golf conclude locked rst call lockwrap das algorithm locked call real golf related work golf mentioned introduction work golf long line research context-sensitive pointer analysis precise algorithms controlow-sensitive context-sensitive egh crl clear algorithms scale lines code previous algorithms controlow-insensitive context-sensitive pointer analysis include frd rst algorithms follow edge call graph call graph pre-computed constructed limit applicability large programs large quadratic sized call graphs due indirect calls hand frd appears scale provide degree subtyping important larger programs golf context-sensitive algorithm subtyping scales large programs extension das algorithm das apply level idea restrict polymorphism losing precision borrow caching technique speed computation golf viewed restriction rehof ahndrich general polymorphic subtyping framework modi cations account uni cation globals pointers golf viewed variant reps horwitz sagiv framework rhs golf scalable instantiation frameworks liang harrold mechanism extracting contextsensitivity context-insensitive pointer analyses approach add context-sensitivity das algorithm clear golf compare resulting analysis ruf ruf foster ffa reported empirical investigations added precision provided context-sensitive pointer analysis argue gain precision context-sensitivity results consistent extend conclusions larger programs real golf context-sensitive analysis produces polymorphic summaries function behaviour impact ow-insensitive pointer analysis issue addressed paper usefulness controlow-insensitive pointer analyses compiler optimizations conventional wisdom lack ow-sensitivity structureeld distinction severely limit usefulness scalable pointer analyses empirical evidence support belief fact studies produced results contradict idea dmm cheng hwu shown context-sensitive pointer analysis subtyping enable optimizations compiler result inspired develop scalable context-sensitive pointer analysis subtyping hind pioli shown ow-sensitivity impact precision pointer analysis diwan shown java optimization ow-insensitive pointer analysis precision exploited optimizer dmm results consistent studies previous work alias frequency estimate impact pointer analysis compiler optimizations diwan studied ect pointer analysis java optimization levels including static points-to information optimization opportunities enabled run-time improvement dmm ideally repeat study conceivable optimization pointer analysis propose weighted alias frequency practical replacement large set experimental studies avenue improvement precision suggested results run increases scalable analysis total globally number apply paths precise analysis program locally increases rountev complexity proposed linearly idea node rrl results provide critical evidence node supports approach remember steensgaard paths algorithm touches scalable critical global nodes analysis shorter golf length global path analysis lead greater precision touched alias frequency measure shorter framework branch identify target general functions precise remember path analysis conclusions subset paper set provided critical experimental nodes evidence support reflected claim design scalable weight pointer domain analyses provide precise contributes alias information exponential complexity programs respect number strong argument critical nodes routine implementation scalable pointer analysis advantage optimizing fact compilers pds developed obtained framework cfg measuring backward impact reachability pointer easier analysis cfgs compiler optimizations manner predecessor independent return-site node 
optimization optimizing compiler finally presented golf rst algorithm trace values large programs providing degree subtyping context-sensitivity method analysis large programs scalable global analysis conjunction expensive local analysis acknowledgements tom reps rakesh ghiya helpful discussions jim larus anonymous referees suggestions paper andersen program analysis specialization programming language phd thesis diku copenhagen diku report cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation proceedings acm sigplan conference programming language design implementation crl chatterjee ryder landi relevant context inference acm sigplan symposium principles programming languages das das uni cation-based pointer analysis directional assignments proceedings sigplan conference programming language design implementation dmm diwan mckinley eliot moss type-based alias analysis proceedings acm sigplan conference programming language design implementation egh emami ghiya hendren context-sensitive interprocedural points-to analysis presence function pointers proceedings acm sigplan conference programming language design implementation ffa foster ahndrich aiken polymorphic versus monomorphic ow-insensitive points-to analysis proceedings international static analysis symposium frd ahndrich rehof das scalable context-sensitive analysis instantiation constraints proceedings acm conference programming language design implementation hen henglein type inference polymorphic recursion acm trans program lang syst hind pioli assessing ects ow-sensitivity pointer alias analyses international static analysis symposium pisa italy number lncs pages springer-verlag hrs horwitz reps sagiv demand interprocedural data analysis acm sigsoft symposium foundations software engineering sigsoft software engineering notes liang harrold cient points-to analysis program analysis proceedings acm sigsoft symposium foundations software engineering liang harrold light-weight context recovery cient accurate program analyses proceedings international conference software engineering june landi ryder safe approximate algorithm interprocedural pointer aliasing proceedings acm sigplan conference programming language design implementation mce mock chambers eggers calpa tool automating selective dynamic compilation annual international symposium microarchitecture december micromonterrey california december rehof ahndrich type-based analysis polymorphic subtyping cfl-reachability proceedings annual acm symposium principles programming languages january rhs reps horwitz sagiv precise interprocedural data analysis graph reachability symposium principles programming languages popl san francisco california rrl rountev ryder landi dataow analysis program fragments proceedings european software engineering conference acm sigsoft symposium foundations software engineering ruf ruf context-sensitive alias analysis reconsidered proceedings acm sigplan conference programming language design implementation ruf ruf ective synchronization removal java proceedings sigplan conference programming language design implementation shapiro horwitz ects precision pointer analysis lncs international symposium static analysis springerverlag ste steensgaard points-to analysis linear time conference record acm symposium principles programming languages tip tip survey program slicing techniques journal programming languages wilson lam cient context-sensitive pointer analysis programs 
proceedings sigplan conference programming language design implementation 
type systems distributed data sharing star ben liblit alex aiken katherine yelick california berkeley berkeley abstract parallel programming languages multiple processors access shared data provide variety sharing mechanisms memory models understanding language support data sharing behavior critical understanding language component numerous program analysis optimization runtime clients languages provide illusion global address space intended work machines physically distributed memory distinguish kinds pointers shared data result subtle rules kinds accesses allowed application programs implicit constraints language implemented paper develops basis understanding design space sharing formalisms codifies understanding suite type checking inference systems illustrate trade-offs models introduction parallel distributed multithreaded computing environments increasingly important systems remain difficult reason data sharing ability multiple threads hold object source difficulty programming languages java titanium upc offer facilities sharing data vary subtle implicit semantically significant ways type-based approach characterizing data sharing distributed programming environments paper makes principal contributions show essential difference distributed pointers local address space global address spaces patterns access data private processor shared processors section earlier efforts distinguished concepts section show notion data sharing sharing models captured suite type systems sections show type qualifier inference automatically add detailed sharing information unannotated program approach realistic distributed programming languages section star research supported part nasa nag appears proceedings twelfth international conference architectural support programming languages operating systems asplos san jose october supporting nested transactional memory logtm michelle moravan jayaram bobba mark hill ben liblit michael swift department computer sciences uni moravan bobba kmoore lyen markhill liblit swift work supported part national science foundation nsf grants ccfccr- eia cnsccr- donations intel sun microsystems bobba intel foundation fellowship yen nsf graduate research fellowship hill wood significant financial interest sun microsystems views expressed necessarily nsf intel sun microsystems permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee asplos october san jose california usa copyright acm aborts transparently explicitly retry programmers invoke transactions directly calling transaction begin indirectly statically scoped atomic blocks eliminate problems posed modular software closed transaction semantics limit concurrency maintaining isolation top-level transaction commits long-running low-contention top-level transaction frequently invokes short-running nested transaction shared resource allocator closed nesting maintain isolation resource allocator updates free list pointer commits severely restricting parallelism ideally release free list pointer transactions access allocator conflicting transaction open nested transactions address concerns relaxing atomicity guarantee managing isolation higher http wisc multif abstract nested transactional memory facilitates software composition letting module invoke knowing transactions closed nested transactions extend isolation transaction toplevel transaction commits implementations flatten nested transactions top-level resulting complete abort conflict partial abort transactions open nested transactions committing transaction immediately release isolation increases parallelism expressiveness cost software hardware complexity paper extends recently-proposed flat log-based transactional memory logtm nested transactions flat logtm saves pre-transaction values log detects conflicts read write bits cache block abort invokes software handler unroll log nested logtm supports nesting segmenting log stack activation records modestly replicating bits facilitate composition nontransactional code language runtime operating system services propose escape actions trusted code run confines transactional memory system categories subject descriptors processor architectures parallel architectures general terms design languages keywords transactional memory nesting logtm introduction emerging chip multiprocessors multi-core chips energizing interest making multithreaded programming painful promising approach transactional memory system lets programmer invoke transaction transaction begin work transaction end rely system make execution atomic intermediate data isolated successful transaction commits unsuccessful conflicts concurrent transaction evin moore luke yen vid wood versity wisconsin madison vid wisc acet java synchronized methods paper focuses systems implemented hardware support htms examine software-only stm systems challenges major challenges composing software modules transactional memory system supporting software composition transactions providing high concurrency long-running transactions require contended resources invoking nontransactional language operating system services challenge facilitating software composition ideal software composition module invoke module nsf eiaccr- acidoe de-fc ndseg fellowship information presented necessarily reflect position policy government official endorsement inferred integer literal shared private program variable function widen transmit fig common grammar expressions report results adding sharing inference real compiler parallel language highlights strengths approach present unexpected results effect underlying memory consistency model program performance experience area independent interest section background parallel applications distributed address invoke space distinct module notions interfaces data deep pointer knowledge local module global internals object prevalent private method shared locking previous fails work provide brought composition distinction ensure safety avoid deadlock ideas programmers section primary thesis locks separate held concepts caller section callee explains implementations open solaris ideas warns sophisticated distinct operating figure system introduces programmers small data blocking manipulation language mutex pointers surprisingly pairs delicate language dance extends aid software liblit composition systems aiken support features transaction capture nesting data sharing transaction behavior begin sake end brevity surrounding omit transactions detailed formal straightforward semantics nesting called soundness closed proof nesting ensures semantics atomicity unchanged isolation prior work top-level extensions outermost serve transaction restrict commits programs htms implement admitted closed nesting type system flattening nested changing accepted programs behave run transactions time top-level transaction transaction begin soundness addressed briefly close section straightforward adaptation complete proof previously published related system base expression integer literal named variable predefined environment function calls similarly assume function predefined sequencing operator ordered evaluation language facilities defining functions types recursion features unnecessary exposition techniques readily extend realistic languages purposes essential aspects language data structures modeled pairs pointers data combined pairs unboxed held directly flat-structured intervening levels indirection unboxed pairs integers stored memory allocation operators return boxed values stored local processor memory allocation local processor subscript states boxed shared private informally private accessed processor allocated private produces pointer private memory cell holding pair contrast shared values examined manipulated multiple processors entire system holds private unboxed pair pair selection operator accepts pointer boxed pair produces offset pointer component pair holds private yields pointer component boxed pair yields unboxed left operand assignment pointer memory location named pointer left explicit treatment boxing offset pointers model update components data structures expression private modifies allocated pair remaining constructs model distributed memory systems allocation local produces local pointer local pointer names memory local single processor corresponds practice simple memory address make sense transfer local pointers processors global pointer names location entire distributed system akin processor address pair processor uniquely identifies processor complete distributed system address memory address processor local address space local pointers preferred data local global pointers larger slower widen operator widen coercions local global pointers clarity make coercions explicit practice coercions inserted automatically compiler transmission operator transmit models sending machine transmission implicitly dereference pointers serialize interlinked data structures evaluates unboxed tuple components tuple evaluates pointer single simply pointer increments counter pointed-to data transaction end decrements intentionally leave commit communication occurs semantics unspecified count transmit returns correspond network functionally broadcast correct flat remote closed procedure nesting invocation degrade performance cross-machine data exchange conflict important invariant transaction transmit complete abort produce beginning representation top-level safely transaction remote processors reason partial abort typical improve transmit widened performance values aborting transmitting local pointer transaction avoiding widening abort forbidden possibly local pointer longer top-level meaningless transaction challenge originating enhancing processor concurrency closed representation nesting versus sharing level expression abstraction private open nested referent transaction supposed commits private enclosing transaction processor system access releases data read written pointers including transactions access cheaper local generating pointer conflicts representation single-threaded register commit program data compensating actions local run private transaction commits transmit widen aborts shared actions declared programmers raise shared level global pointer abstraction providing higherlevel transmitted isolation remote undo processor semantics processors stored compensate variable malloc executing transmit free broadcasts simply computed relying garbage processor collection simply running restoring processor receives values pointer memory locations processor modified stores free list pointer instance insufficient variable subsequent open remote transactions processor global modified pointer challenge piece escaping shared data non-transactional finally systems systems minor run variation top non-transactional base shared systems transmit include widen run-time libraries language virtual global machines pointer points jvms shared operating data systems windows linux points solaris shared data system virtual machines vmware processor applications escape local pointer systems shared explicitly data system calls case implicitly distinguisheslocal tlb globalfromshared traps private interrupts distinction asm local statements global determines escapes representation access pointers lower-level capabilities shared private determines data directly illustrated application programmers examples stms handle local escapes pointer easily point virtualize shared private mechanisms data user-level software local htms pointer hand concurrent hardware access conflict detection processors bits speculative whilelocal globalis buffers distinct escape fromshared private non-transactional system concepts disable orthogonal mechanisms global software pointers private operate data correctly problematic presence transaction isolation processor hold aborts pointer nested data logtm paper supposed explores private challenges processor context show section recently-proposed multiple log-based transactional answers memory system question call sharing flat information logtm flat logtm sections show hardware statically mechanisms determine version data private management single conflict processor versus detection compilers run-time library software implement language-specific transactional memory policies flat logtm performs version management storing values commit place cacheable virtual memory values abort per-thread log cacheable virtual memory hardware support makes commits fast data moved library software handler unrolls log aborts htms flat logtm performs conflict detection read write bits caches adds mechanisms cache evictions transactional data flat logtm counter flatten closed nested transactions top-level transaction nested logtm makes contributions extending flat logtm mechanisms support nesting escape actions contribution closed nesting partial aborts nested logtm transactions abort separately toplevel transaction segmenting undo log replicating bits segment records values single nesting level makes log resemble standard stack activation records frame holds records level nesting nested logtm narrows conflict detection specific nesting level extending cache bits copies flattening transactions nested deeper nested logtm partial abort unrolling subset log frames clearing subset bits contribution open nesting nested logtm supports access highly contended resources transaction open nested transactions commit release isolation prior top-level transaction commit open nested transaction commits log segment removed commit compensating action records added parent log segment addition transaction bits cleared cache contribution escape actions nested logtm supports calls lower-level non-transactional system including transaction escape actions bypass transaction version management conflict detection escape actions invoked explicitly instructions implicitly part trap escape action register commit compensating actions open nested transaction nested logtm implements escape actions per-thread flag disables logging conflict detection set view escape actions enabling mechanism supporting non-transactional system activity htms trap handlers system calls execute escape actions increases variety code execute transactions reduces abort transaction due activity addition escape actions key building block implementing transactions supporting debuggers garbage collectors recent htm proposals explored support closed nesting partial aborts open nesting extend work ways including proposing escape actions implementing nesting logtm shared defining condition multiple processors information support number clients autonomous garbage collection reclaim private data strictly local operation coordinating processors data location management important hardware constraints make shared memory limited resource cache coherence overhead avoided private data processor sees race condition detection races private data program algorithm documentation augmented compiler validation programmers claims consistency model relaxation aggressive optimizations data processors synchronization elimination boosts performance private monitors contention security mandates careful treatment private data distributed systems mutual trust clients depends identifying data accessed processor typically processor local memory data lives data accessed local pointers local pointers suffice possibility global pointer alias location data referenced local pointers transitive reachability concern global pointer local pointer local pointer memory cell accessed remote processor sequence dereference operations widen local pointers global dereference int boxed local global shared mixed private grammar types shared mixed private mixed boxed boxed prime prime prime prime prime prime subtyping relations fig common properties type systems pointer representations data sharing patterns trivially deduced section show clients autonomous security require stronger privacy guarantees suggests solution based single definition privacy family alternatives client select type systems figure presents types subtyping relation subsections basic types unboxed integers int unboxed pairs pointers boxed values type carry qualifiers range local global shared mixed private local pointer widened equivalent global pointer local global pointers distinct physical representations manipulated machine-level operations widening coercion subtyping relation widen included explicit operator language figure hand sharing qualifiers dictate remote operations permissible forbidden general shared 
private pointers identical physical representation manipulated allowed identical machine-level operations coercion simplistic subtyping shared private pointers shared pointers functionality private pointers widened global distance private pointers unique functionality admit aggressive optimization violate language invariants observed remote processors sound type system ensure sharing qualifiers consistent aliasing local global pointers address location simultaneously location considered shared private good reasons code operates shared private data type object constructor java-like language observed earlier coercion private shared shared private shared constructor called construct private object private shared object built constructor class ultimately calls object restrictions introduced affect entire system reuse constructor code requires polymorphism find section basic utility code reused contexts imposes similar requirements mitigating type subtle system open nesting paper semantic issues subtyping polymorphism systems evaluate mixed nested sharing logtm versus qualifier flat mixed logtm datum running 
microbenchmarks solaris -way multiprocessor simulated extension wisconsin gems sorted list b-tree microbenchmarks show benefit closed nesting partial abort show significant improvement increased concurrency provided open nesting performance benefit nesting running subset splashbenchmarks part due lack conflicts transactions workloads strided array microbenchmark demonstrates escape actions improve performance presence tlb miss traps allowing transactions continue trap transactional memory model section informally describes model closed nested transactional memory implemented flattening remainder paper evolves model support partial aborts open nesting escape actions describes model maps flat nested logtm implementations system represented memory maps addresses values set threads thread transaction level level read set write set map maps addresses updated values block function maps address possibly-larger aligned granularity memory block initially maps initial values level null thread begins transaction incrementing level subsequent reads address add block writing address adds block mapping tov replacing previous mapping inv read address generates conflict block thread write address generates conflict block thread transaction commit decrements level level updates mappings makes null transaction abort discards sets level reverts execution top-level transaction begin flat logtm background log-based transactional memory system referred flat logtm depicted figure serves framework nested transaction implementations flat logtm performs version management storing values commit place cacheable virtual memory values abort per-thread log cacheable virtual memory log consists fixed-size header thread state registers variable sized body comprising undo records figure shows in-depth transaction execution step log header thread register state including program counter step log body undo record old-block-value block old-block-value block prior transaction begin step including block block aligned virtual address processor maintains pointers log header log end write block bit set flat logtm writes undo record end log commit flat logtm discards log resetting log end pointer abort flat logtm invokes runtime software handler unroll log processing undo records last-in-first-out order starting log end pointer restoring thread state header flat logtm implements closed transactional nesting counter flatten nested transactions toplevel transaction htms flat logtm performs conflict detection read write bits caches commit abort flash clear bits flat logtm handles cache evictions transactional data extended directory protocol sticky-s sticky-m states flat logtm implements section transactional memory model forward-value map backward-value map replaces memory update-to-date memory forward map backward map mappings flat logtm updates memory place equals union means mappings replaced mappings conflict detection ensures disjoint sets flat logtm revert memory back memory union abort thread transaction flat logtm backward map undo thread omit proof equivalence backward forward logs understood database literature finally flat logtm bits directly maintain model read write sets blocks cache sticky-s sticky-m states conservatively overestimate set membership replaced blocks closed nesting partial abort section presents requirements closed nesting implemented partial abort requirements extend model partial aborts thread maintains separate read shared private code manipulates mixed data ways sound subtyping relation defined figure note subtyping cross pointers restriction avoid well-known unsoundness problems result subtyping updatable late enforcement define private read written remote processor global pointers private data freely created dereferenced section presents late enforcement system typing judgments turnstileleft read environment provable expression type auxiliary expand pop functions defined figure describe types transformed constrained widening cross-processor communication observe type expansion recursively descends pairs crosses pointers expand directly communicated processor boundaries integers global pointers local pointers expand global topmost level type expand banned appearing expanding pairs pop global pointers general larger local pointers expanding local pointers global pointers inside pair change size layout pair undesirable practice languages named structure type class single consistent layout alternative deep local pointers remain size mark invalid remote processor possibility explored greater detail omitted simplicity types integers variables function applications completely standard sequencing pair construction subtyping typical manner turnstileleft int turnstileleft prime turnstileleft turnstileleft prime turnstileleft turnstileleft eprime prime turnstileleft eprime prime turnstileleft turnstileleft turnstileleft turnstileleft prime turnstileleft prime shared private allocation creates appropriately qualified local pointer alternative parametric polymorphism expressive subtype polymorphism simpler explain expand boxed boxedglobal expand pop pop expand int int pop boxedglobal boxedglobal pop pop pop pop int int fig supporting functions late enforcement notice pop defined local pointers turnstileleft shared private turnstileleft boxedlocal notice late set enforcement places write restrictions set type map data nesting boxed level nesting level create thread pointer maintains shared read data set embedded write pointers set private data dereferencing map local pointers standard transaction begins allowed reads writes sharing similar qualifier base global model pointers section thread dereferencing begins transaction pointed-to data incrementing level shared reading address apply adds pointer block widening result level turnstileleft writing boxedlocal address turnstileleft adds block turnstileleft level boxedglobalshared turnstileleft mapping expand tov level instance reading address late generates enforcement restricts conflict program block behavior private data thread read global level pointer private writing data address generates visible conflict owning block processor local orw pointers assignment thread similar represents level instance transaction commit late enforcement significantly restricts program addition behavior partial local aborts pointer top-level commit modify level shared remains private data decrement level global pointer update touch shared data mappings enforce assigned clear embed local pointers global assignment closed carries nested additional commit requirement commit type level assigned preserved promotes type committed expansion transaction turnstileleft state boxedlocal parent transaction turnstileleft nesting eprime level specifically turnstileleft closed eprime nested commit turnstileleft level maintains boxedglobalshared isolation turnstileleft level eprime taking expand union turnstileleft read eprime write widening sets directly applies level type expansion level function coerce local level pointers global level equivalents transmission means processor boundaries set requires assigned type set expansion union identity similarly global commit assignment merges typically maps level level level level model assumes granularity read write conflicts generalized systems granularities tcc figure logtm node circles denote architectural state additions flat logtm required support nested logtm tag state data cpu directory cache controller timestamp cycle overflow nested logtm-specific state tag state sharer list tag state data log frame log end tmcount begin handler registers user escape escape actions exceptionmask mapping replaces mapping finally commit clears level level level decrements level top-level commit top-level abort closed nesting remains unchanged set level clear levels revert execution transaction begins aborting closed nested transaction level results partial abort leaves enclosing transactions states unchanged specifically abort level clears sets level reverts execution begin transaction level figure presents extended closed nesting including top-level nested transactions reads writes partial abort eventual commit closed nesting logtm adapt flat logtm support closed nesting partial aborts extending version management conflict detection figure depicts architectural state added nested logtm node buffers hide latency log writes shown version management closed nesting extends flat logtm perthread log header series old-block-value blockaddress undo records stack log frames resembling stack activation records similar harris log frame consists fixed-size header variable-size body undo records garbage headers specifically nested logtm operates transaction begin allocates log frame initializes figure nested logtm operation figure shows snapshots log conflict detection bits lower half shows cache state var columns correspond variable names figure val columns show current values processor local cache upper half shows logical view log frames separated solid black line instance part frames parts dotted line separates header undo records frame previous frame pointer part header records shown undo record abbreviated variable logs pictured assume block block block part shows snapshot log conflict detection bits figure step key points multiple logging logged values level frame level frame level header includes pointer beginning level frame restoration commit abort header data including register checkpoint shown finally redundant conflict detection levels marked part read set conflict occurs thread write conflict thread read important difference bits affect abort instance suppose transaction makes read request redundant conflict detection shows sufficient abort roll back level transaction successfully resolve conflict conversely write conflict abort transaction levels part shows state level completes execution commits step figure key take-away merge operations work log data merge difference level frame encompassed level frame note sources waste level header level previous useless subsequent abort back level level header restored log traversed lifo order level final restored restart conflict detection bits show result merge operation level bit set set level commit additionally set level bit set level bits flash cleared write transmit widened turnstileleft turnstileleft widen expand turnstileleft expand turnstileleft transmit expand selection propagates sharing qualifier pointer displacement obvious manner turnstileleft boxed turnstileleft boxed design implications rules point actual dereference assignment add restrictions implement late enforcement program read write private mixed data global pointer fails type check conjunction expand function rules implicitly cover case global pointers local pointers suppose local pointer private data global pointer shared location boxedlocalprivate boxedglobalprivate dereferencing yield local pointer equivalent pointer widened global points private data widened pointer points private data dereferenced assigned general late enforcement system forbids undesirable behavior private remote processor global pointer private data created copied processors data structures compared pointers memory location named pointer examined modified situations type boxedglobalprivate desirable pointer embedded tuple shared private components shared portions data structure accessed remotely private portions type checking program requires global pointers private data formed manipulated provided global pointer conservatively assumed address remote memory global pointer address local memory real distributed languages typically dynamically checked conversion global pointers back local global pointer private data converted back local pointer private data freely applicability limitations intend sharing qualifiers make data location management decisions weak guarantees offered late enforcement sufficient memory reserved private shared subscripted qualifier choose suitable region memory global pointers escape distant processors memory occupied private data examined modified remotely private data reside memory network-addressable sharable memory slower scarce reserved shared data clients make late enforcement guarantees distributed cache coherence maintained data examined remotely race condition detection systems concern global pointers private data create races similarly sequence operations private data reordered optimized freely strictest consistency models intermediate states observable processors treating lock acquisition dereference private locks eliminated compile time late enforcement late applications languages unable autonomously garbage collect late enforcement security concerns unsatisfied exposed pointers private data remaining type systems incrementally impose stricter enforcement policies accommodate concerns export enforcement languages late enforcement weak support autonomous garbage collection suggested earlier distributed programming environments support checked conversion global pointers back local system sequence actions place processor creates private data sends address remote processor processor holds global pointer private data processor destroys private data global pointer held processor live private data time processor sends global private pointer back processor processor checked conversion recover local pointer private data subsequently dereferences pointer autonomous garbage collection requires live data live local processor autonomously garbage collect steps private data unreachable memory occupies reclaimed language narrowing casts global local late enforcement support autonomous garbage collection modify late enforcement system source global pointers private data initial environment impose well-formedness requirement initial environment stipulating boxedglobalprivate part type variable function compound expressions chief source global pointers widen operator relies expand expand local pointers global figure revised expand function produces global pointers shared data notice version defined pointers private mixed data transmit longer send pointers private data processor boundaries thewidencoercion similarly restricted global assignment global dereferencing well-formed starting environment revised expand function ensures expression type boxedglobal private expand function guarantees pointers exported shared data observe pointer type boxed shared expanded restrictions type pointed-to data expand boxed shared boxedglobalshared expand pop pop expand int int fig revised type expansion function supporting export enforcement subordinate pop function unchanged figure freely transmit pointer shared memory cell turn points private data boxed shared boxed prime private 
prime identity expand export enforcement type system restricts actual values exported extend transitively level pointers sufficient support autonomous garbage collection guarantees remote processor hold live piece private data approach eliminate manage memory objects genuinely shared complements distributed garbage collection techniques stubs scions identifying private subset data collected aggressively simpler traditional purely local collection algorithms early enforcement untrusted environment address private data stored sensitive information security concerns mandate private address escape owning processor late export enforcement provide kind protection vulnerability type checking rule global dereference requires pointed-to data shared untrusted environment remote processor willfully disregards restriction transitively walk pointers ultimately reach private data global assignment similarly vulnerable runtime checks detect misbehavior static compile-time assurances attractive option complete control private addresses refine export enforcement additionally require private data transitively reachable shared memory variables functions extend well-formedness requirements initial environments obvious manner compound expressions change required type checking rules allocation late export enforcement allowed shared private boxing type early enforcement impose additional restriction shared allocation turnstileleft turnstileleft private boxedlocalprivate turnstileleft allshared turnstileleft shared boxedlocalshared allshared predicate holds pointers directly embedded type shared allshared boxed shared allshared allshared allshared allshared int true pointer private data shared memory require initial environment obey similar restrictions general private storage transitively reachable shared global memory universe shared data transitively closed consequence sharing constraint global dereference assignment rules trivially satisfied data transitively reachable global pointer shared impossible malicious remote processor disregard sharing constraint transitively reach private data applicability trade-offs export enforcement restrictive late enforcement early enforcement restrictive accepting fewer programs export early enforcement make progressively stronger guarantees meaning private programs type check early enforcement support late enforcement clients race detectors reordering optimizers autonomous garbage collection effectiveness clients reduced early enforcement treats data shared late export enforcement private set programs accepted system strict subset accepted adapted earlier proof local global soundness show late enforcement system sound soundness systems additional requirements imposed system access private data global pointer enforced directly type checking rules correctness restrictions verifiable direct inspection type checking rules operations type inference type systems easily converted type checking type inference illustrate late enforcement inference inference export early enforcement similar omitted sake brevity assume program type check disregarding sharing qualifiers local global qualifiers inferred infer qualifiers simultaneously simplicity assume local global inference place separately type inference rules produce system constraints solved rules figure additional sharing constraints arise expand function defined figure clarity presentation rules abbreviations constraint sets explicitly propagated subexpressions complete constraint set union sets constraints induced subexpressions turnstileleft int turnstileleft prime turnstileleft primeprime primeprime turnstileleft prime turnstileleft turnstileleft boxedlocal turnstileleft boxedlocal turnstileleft turnstileleft boxedglobalshared expand prime turnstileleft prime turnstileleft turnstileleft eprime prime turnstileleft eprime prime turnstileleft boxedlocal turnstileleft eprime prime prime turnstileleft eprime turnstileleft boxedglobalshared turnstileleft eprime prime prime expand turnstileleft eprime turnstileleft turnstileleft turnstileleft turnstileleft boxed turnstileleft boxed turnstileleft expand prime turnstileleft widen prime turnstileleft conflict expand turnstileleft transmit attributed fig level type sole inference rules writer part late shows enforcement nontrivial post-commit rule state hypothesis level open boxedglobalshared closed read section equality unlike constraint part level boxedglobalshared versions constraint discarded variables replaced fresh solution compensation record constraints abbreviated induced open 
figure conflict bits show level bits flash cleared level bits remain transaction point transaction read read write traversing log abort handler executes compensating action left level restores distinguishes record types examining tags shown var val step log cache var val step cache var val step cache closed level open level log log open thread current registers program counter saves parent transaction information base parent frame sets log frame pointer frame flat logtm nested logtm reuses bits detect write unique block causing add undo record end log current frame body nested logtm adds two-bit tag log record indicating undo record frame header block addresses aligned -byte blocks common undo record tag encoded free address least-significant address bits closed nested commit merges current log frame parent frame specifically nested logtm sets log frame pointer back parent frame saved transaction begin committing transaction frame committed transaction frame header remains body parent garbage header garbage headers occupy space parent frame semantic abort current transaction level traps library software handler walks body log frame backwards process undo records skip garbage headers finally restoring register state saved header transaction abort handler undo j-m log frames easily implemented software handler advantage logtm approach conflict detection closed nesting cache line bits array bits small chung find levels explicit support sufficient reads writes transaction level set ifj flattened level flattening correct behavior deeper nests removes performance benefit partial abort incoming read block generates conflict level minimum set outermost conflicting transaction similarly incoming write examines find minimum conflict cycle indicating potential deadlock nested logtm bit transaction level inform software handler rollback top-level transaction commit clears flash clear nested transaction commit level merges flash clears implementation merge flash-or circuit calculates cache line parallel assigns logical-or flash-or circuit adds transistors bit line transistors word bit lines sram cell flash clear transaction abort level back level undoes log frames flash clears figure figure illustrate version management conflict detection closed nested transactions figure shows nested logtm state nested transaction ready commit top-level transaction step figure note levelframe records write step levelframe records writes steps figure shows nested logtm state transaction performs closed commit leaving top-level transaction active correctness argument nested logtm closed nesting implements section closed nesting model steps stack log frames backward maps complement forward maps manner similar flat logtm complemented partial abort thread level back level undo made thread transaction levels cache bits directly implement multi-level readand write-sets due flattening represent union open nested transactions nested logtm supports open nested transactions provide greater concurrency richer semantics section generational terminology helpful transaction invoked thread level sparent thread level transaction began ancestors parent parent ancestors siblings level transactions thread begun parent including requirements open nested transaction releases isolation commit optionally registers commit compensating action handlers figure closed nesting thread begins execution non-transactional level initializes variables begins top-level level transaction step step read variable adds block conflict detection write variable adds block conflict detection version management thread begins nested level transaction step step read adds block write adds block step step write variable encounters read conflict block system resolves partial abort clears restarts execution step assume retry step succeeds adding block block step adds block block note address exist structures transaction level step block block step nested level transaction commits merging note merge mapping replace mapping finally step toplevel transaction commits updating memory mappings clearing thread level non-transactional initialize transaction begin top-level level transaction begin level partial abort write transaction commit level transaction commit level level ancestor current transaction level software ensure consistency open nested transactions raise level abstraction isolation rollback figure illustrates outer insert set transaction calls insert add multiple entries b-tree data structure making insert open nested transaction increases concurrency releasing memory-level isolation rules valid typing program note setting variables shared produces legitimate solution languages assume data shared safe albeit expand boxed boxed prime prime prime prime prime expand prime prime expand prime expand prime expand int int fig additional constraints induced supporting functions assume local global qualifiers assigned functions cover additional sharing constraints private shared fig constraint graph requiring choice shared private arrow encodes constraint overly conservative sharing qualifier lattice solution interested solution defined largest number private qualifiers maximally-private solution computed efficiently assume initially static typing showing pointer pair integer pointers local global equivalences figure expand type constraints prime prime obtain complete set sharing constraints identify set qualifier constants transitive lower bounds qualifier variable collect set constraint variables shared mixed transitive lower bound variables private sharing qualifier variable set private private transitive lower bound variable present earlier sharing qualifier upper bound constant transitive lower bounds final solution meat algorithm devolves graph reachability flowing forward constraint edges nodes representing type qualifiers solution computable time linear respect number sharing qualifiers fully typed program local global inference linear language designers great flexibility expose type choices source language present simpler source-level model augmented fast compiler-driven type inference fill details critical feature algorithm identifies qualifiers possibly private binds variables private lastly chooses shared mixed variables made private strategy maximizes number private qualifiers exchange driving qualifiers mixed shared figure algorithm binds private means private mixed alternative set shared drive mixed shared case mixed algorithm resolves choices favor maximizing number variables bound private clients interest related work static type systems previous proposals dealt local global shared private general result general unsafe lack generality prevents programmers enforcing data private makes difficult reason program correctness results missed opportunities optimization lack safety exhibits unsafe implicit casts pointer types impede optimization under-specified internal semantics data optimization structures change preserve program behavior consistency unexpected data ways structure group maintain isolation languages guarantees safety inserted entries facility lock declaring flag private heap data figure languages outer transaction stack commits private note entire outer heap transaction treated release isolation potentially shared inserted java entries olden performing titanium prior commit actions work calling unlock category key similarly languages compensating actions techniques provide undo basis forward action automatically inferring higher private level heap data abstraction calling important delete key programmers b-tree entry declare open private nested data transaction explicitly open commits knowledge propagating data private map critical understanding nearest parallel enclosing distributed map programs memory jade clearing safe language distinguishes local global optionally pointers registering commit action open heap data compensating private abort action private data open decrementing transitively level reachable mapping shared heap corresponds exists early mapping enforcement system section max results show propagates security primary concern significantly flexible propagates sharing memory data allowing data statically identified private making privacy-dependent analyses effective earth-c explicitly offers local global shared private type qualifiers local global inferred shared private explicitly approach shows shared private amenable inference operating fully automatically augment programmer directives broader earth-c project demonstrated identifying local private data drive analyses redundant read write removal communication optimization unsafe c-derived languages pcp upc offer shared private data type systems distinguish addresses private data narrowed global pointers shared data effect languages offer global shared local mixed private data exists run time static type system identify manner clients listed section deployed family split-c directly address notion private data data presumed shared difficult semantics required regard code reordering aggressive optimizations cilk explicitly treats memory shared states programmer responsible understanding underlying memory model provided host hardware sharing inference support aggressive optimization added burden under-specified semantics type systems similar 
escape analysis previous research focused identifying data escape stack frame thread execution early enforcement system thought identifying data escape local address space considered light late enforcement system unusual escape addresses permitted provided data referenced escaped address examined modified distance permissive escape analysis strong support traditional escape analysis clients synchronization removal knowledge earlier study takes approach similar late enforcement thread-local analysis presented aldrich defines multithreaded objects objects escape thread written conservatively defined distinct thread escaped object written considered multithreaded similar spirit late enforcement globally reachable piece data accessed remotely considered shared question akin late enforcement applied directly stack thread escape analyses warrants study experimental findings added sharing qualifiers titanium experimental java dialect high performance parallel computing unqualified assumed shared programmers declare private mixed subject validation type checker stronger private qualifiers added automatically type inference highlight bounds design space late early enforcement export enforcement yield performance results inference engine based cqual qualifier inference engine benchmarks single-program multiple-data spmd thread invokes open nested transaction open top-level ancestor commits performs commit action open open nested transaction level greater open committed open ancestors aborts system executes open open nested transaction moss argues compensating action execute state held forward action committed open executes open committed top-level ancestor transaction releases isolation processing commit compensating actions note programmers responsible ensuring actions generate additional conflicts original transaction failure result deadlock thread executes open nested transaction top-level transaction commits handlers interact clarity explain semantics case thread executes open nested transactions sibling open transactions opent open-n commit register commit compensating actions openc open-n opena open-n parent transaction open-parent ift open-parent commits commit actions executed first-in-first-out fifo order openc open-n compensating actions opena open-n discarded open-parent registers higher-level commit compensating actions open-parent open-parent conversely open-parent aborts compensating actions executed lastin-first-out lifo order open-n openthe action open-k executes moss simple semantics codes explicit sharing qualifiers maps open-k committed long open nested transactions compensating actions written address ancestor section addresses potential problems arise case generally thread executes closed open nested transactions actions closest open ancestor transaction commits illustrate compensating actions multiple open transactions suppose open-parent insert set routine calls insert add multiple key pairs b-tree open-parent aborts compensating actions open-i call delete remove inserted keys open-parent benchmarks designed execution distributed memory multiprocessors reflect scientific focus spmd programming applications include monte carlo integration sorting sample-sort dense linear algebra lu-fact cannon fourier transform d-fft particle methods n-body particle-mesh solvers computational fluid dynamics gsrb pps amr gas whole-program sharing inference including java class library roughly additional lines takes ghz pentium linux workstation inference algorithm linear scale larger code bases studied sharing based analyses optimizations section detailed results companion report additional details incorporating sharing analysis complete programming language focus areas static prevalence inferred types dynamic tallies shared versus private allocation support data location management performance impact sharing inference consistency model relaxation static metrics table shows number static declaration sites benchmark places sharing qualifier syntactically titanium stack trivially table benchmark sizes relative counts inferred qualifiers benchmark lines sites late earlyshared mixed private shared mixed private sample-sort lu-fact cannon d-fft n-body gsrb particle-grid pps amr gas private exclude local variables tabulate heap data program inference include sites appearing benchmark application code libraries style enforcement show fraction static inferred shared mixed private review related work distributed languages private stack notion private data important omission system consistently identify large amounts private heap data benchmarks sizes largest benchmark gas private data half declaration sites benchmarks range sites benchmarks inferred private encouraging news analysis clients exploit information reinforces inference human programmer correctly place qualifiers hand maintain qualifiers time small number mixed qualifiers benchmark cases mixed found utility code shared distinct parts application parametric polymorphism subtyping find code isolated methods performs complex operations shared private data based complex run time control decisions mixed qualifier works method-based parametric polymorphism difficult apply nontrivial code factoring cases code polymorphic respect sharing polymorphic type system significantly data forced shared polymorphism important system small mixed counts suggest heap data shared processors obvious choice address global pointers clear local pointers shared data needed programs show heavy local pointers shared data shared heap data addressed local pointers numbers remain high amr gas largest benchmarks local shared pointer represents locally allocated portion larger distributed table kilobytes allocated shared private memory omitgsrbandibdue unrelated titanium bugs prevent running completion benchmark late earlyshared private shared private sample-sort cannon d-fft n-body particle-grid pps amr gas data structure processor retains local pointer data created pointer efficient access data owns earlier work demonstrated local pointers critical performance quarter half statically shared data forced global performance suffer data location management shared memory scarce costly resource instrumented benchmark tally number shared private allocations entire run table totals bytes late early enforcement observe slight differences enforcement schemes small benchmarks reported identical results table earlier table examined application code excluded libraries allocation counts apply entire program slight differences inference results library code visible slight differences allocation counts late versus early enforcement wide variation benchmarks ranging allocations shared particle-grid allocations private n-body examples extremes large small benchmarks largest benchmark gas memory intensive find allocated bytes private memory byte counts vary appreciably late early enforcement amr sees shift dramatic shift found pps late enforcement private allocation early enforcement drops table observe pps shows large difference static private declaration counts differences encompass data structures account preponderance pps runtime memory consumption running machines costly shared memory pps stands benefit greatly data location management guided sharing inference fig performance cost sequential consistency omit lu-fact gsrb due unrelated titanium bugs prevent running completion consistency model relaxation titanium fairly weak consistency model compiler hardware reorder memory operations stronger model attractive programming target unacceptably commits registers higher-level delete set routine open-parent replacing individual calls delete interactions undo compensating actions open nested transactions lead strange behavior transaction open ancestors write memory location figure problems arise non-obvious interactions memorylevel undo operations parent semantic undo child problem exacerbated implementations handle interactions differently avoid making programmers reason subtle non-portable implementation details advocate programmers observe restriction open nested transactions condition writes data written ancestors open transaction open commit compensating actions open open writes data written open ancestors open executed thread level advantages obeying condition obeying condition effective open nested transactions b-tree open nested transactions section obey condition obeying condition frees programmers reasoning subtle issues surrounding leakage uncommitted transactional state open ancestors write datum 
isolation end open commits ancestors active obeying condition avoids subtle interactions recovery parent values semantic undo child actions open nesting logtm open nesting nested logtm requires version management conflict detection version management open nested transaction open level commits nested logtm discards open frame log making open parent level current optionally appends commit compensating action records open open harm performance suggested section sharing inference private data accesses reordered ensuring stronger semantics language level implemented optimization sequentially consistent variant titanium figure presents benchmark running times configurations inference data assumed shared sequential consistency enforced early late enforce sequential consistency private data inferred type system weak weak consistency model titanium upper bound speedup allowing reordering benchmarks raw performance present running times normalized running time implementation sequential consistency measurements smp linux workstation pentium iii mhz cpu dram large speedup weak confirms sequential consistency costly bluntly applied sharing inference identify private data erase penalty late early variants hand inspection shows sharing inference forpiis perfect data main computational loop inferredprivate restrictions needed optimizations enforce sequential consistency early late weak versions yield identical machine code apparent performance measurement noise benchmarks modest improvement implementation weak consistency model potential speedup sharing inference limited defies conventional wisdom sequential consistency expensive potential sources inefficiency sequentially consistent versions lost optimization opportunities loop transformations additional memory fences load store instructions significant benchmarks highlights limitation experimental environment titanium compiler pentium hardware taking advantage weak consistency looser requirements significantly boost performance sequential consistency larger benchmarks cannon d-fft amr show largest performance gap weak models stand benefit sharing inference d-fft inference late early match weak model modest benefits cannon larger slowdown partly offset inference late early enforcement yield identical results cannon difference late early slowdown factors measurement noise results amr interesting key performance-critical data structures inferred private current system spmd programs amr alternating-phase structure processors exchange boundary information processor updates local portion shared grid processors communicate data shared widely amr communication phase treat data private local computation phases phases delimited global barrier operations processor processors data local computations taking place sharing inference effective 
limited form flow sensitivity keyed phases structure barriers regular practice extension techniques feasible observe benchmarks unexpected speedups sequential consistency direct penalty sequential consistency small measurement noise due secondary effects cache alignment code layout noticeable conclusions presented general approach describing data sharing behavior distributed programming languages codified approach suite type systems early enforcement resembles earlier work escape analysis export late enforcement unusual enforcing privacy closer point point escape allowing identify private data exchange weaker guarantees private means considered type systems light optimizations permit present experimental data optimizations data layout management consistency model relaxation approach conducive efficient type qualifier inference adapted suit realistic languages survey related languages suggests fall categories under-specify behavior shared data equate shared global private local approach points combinations mixed pointers local shared pointers role play agarwal bianchini chaiken johnson kranz kubiatowicz lim mackenzie yeung mit alewife machine architecture performance proc annual int symp computer architecture isca pages june aiken gay barrier inference conference record popl acm sigplan-sigact symposium principles programming languages pages san diego california january aldrich sirer chambers eggers comprehensive synchronization elimination java science computer programming published washington technical report uw-cse- october balls finite difference domain decomposition method local corrections solution poisson equation phd thesis department mechanical engineering california berkeley berger colella local adaptive mesh refinement shock hydrodynamics journal computational physics lawrence livermore laboratory report ucrlb blanchet escape analysis object oriented languages application java oopsla pages bogda olzle removing unnecessary synchronization java oopsla pages brooks iii pcp parallel extension fat free technical report ucrllawrence livermore national laboratory sept carlisle olden parallelizing programs dynamic data structures distributedmemory machines phd thesis department computer science princeton june carlson draper distributed data access proc acm sigplan symposium principles practice parallel programming ppopp pages santa barbara california july ida supercomputing research center carlson draper culler yelick brooks warren introduction upc language specification technical report ccs-tr- ida center computing sciences chandy kesselman compositional compositional parallel programming lecture notes computer science choi gupta serrano sreedhar midkiff escape analysis java oopsla pages culler dusseau goldstein krishnamurthy lumetta von eicken yelick parallel programming split-c ieee editor proceedings supercomputing portland oregon november pages spring street suite silver spring usa ieee computer society press foster cqual http bane berkeley cqual nov foster ahndrich aiken theory type newly exposed end open parent frame handler records function address variable-length argument list length insert int key int open begin leaf find leaf key entry insert leaf key lock entry isolate node entrylock open commit abort action delete key commit action unlock key insert set set open begin key insert key open commit abort action delete set figure open nested b-tree transaction abort software abort handler log restore values perform compensating actions processing log lifo order naturally produces correct interleaving restored values compensating actions moss semantics handler undoes transactional updates point open commit performing compensating action nested logtm logs store cache block transaction level open nested transaction commits semantics require log undo records needed roll back state memory transaction committed run-time system ensures presence log records immediately beginning implicit closed transaction nesting level committed open transaction level runtime system commits implicit transaction immediately begin commit operation promoting conflict information nesting level commit compensating actions execute open nested transactions lower level open committed actions conflict abort retry open transaction conflict detection beginning open nested transaction open closed nested transaction open commits nested logtm simply flash clears bits employing flash-or closed nested commit nested logtm supports maskable exceptions openlevel exception raised open begins level exceed nested logtm levels bits masking exception supports unbounded nesting converting deeply nested open transactions flattened closed transactions ignoring handlers registered commit masking exception open nested transactions enhance concurrency two-way communication enabling open-level exception software error handling full open nested semantics required communication transactions logtm raises maskable condition-o exception open writes data written ancestor violating condition exception raised execution obey simpler semantics condition programmers choose richer semantics handling masking exception case memory locations modified parent open child remain isolated part parent condition trigger false violations stack locations parent transaction reused open child true violations parent implicitly deallocated stack addresses changing stack pointer prevent unnecessary exceptions nested logtm provide mechanism identify bottom stack transaction begins mask violations addresses stack page address common case transaction begins ends language scoping level stack frame transaction begin address stack variable written child transaction figure parts illustrates version management conflict detection open nested transactions recall figure shows nested logtm state nested transaction ready commit top-level transaction step figure note level frame records write step level frame records writes steps figure shows nested logtm state open transaction commits leaving top-level transaction active correctness argument sketch support open nesting nested logtm correct open transaction commit thread level performs fifo order commit actions registered committed descendent transactions discards open frame effectively promoting open nearest enclosing map memory clears release isolation data accessed parent transaction abort handler processes log lifo order performing memory undos compensation actions inverse order transaction violates condition compensating action sees ancestral memory state equivalent existed forward action committed escape actions open nested transactions promise greater concurrency semantics ill-suited invoking conventional operating system tolerate stalls aborts due data conflicts end propose escape actions transactional atomicity isolation invoke counter initializes transaction begin top-level counter counter open begin level counter counter commit compensating action open commit abort action decr counter abort run compensating action expect counter restored transaction commit executed figure violating thread initializes counter begins transaction increments counter begins open nested transaction increments counter commits open nested transaction compensating action decrement counter step aborts top-level transaction step thread updated counter expect counter restored nested logtm section raise exception step signal dangerous programming practice condition-o exception masked nested logtm implementation expected occurs processes log back commit point open nested transaction step running compensating action processes rest log restoring initial counter conversely mcdonald tcc implementation set counter kozyrakis olukotun personal communication occurs open transaction commit step writes memory input compensating action decrement complex examples strange behavior implementations programmers obey condition level performing reads writes behaves transaction register commit compensating actions effect enclosing transactions escape actions low-level escapes software nontransactional rest allowing debuggers libraries access modify uncommitted transactional data aborting transactions provide interface deal non-transactional code foreseeable future includes operating systems device drivers transactional operating systems escape actions interact non-transactional devices support non-transactional system calls escape actions implicitly begin end entering exiting kernel mode gracefully handling simple exceptions software tlb fills escape begin escape end calls provide explicit escape actions similar processor management instructions assembly code envision escape actions implement low-level functions exception handlers debuggers run-time support hidden highlevel language programmers complexity writing escape actions one-time expense library developers application developers general case study open solaris systems calls reasons applications access conventional operating system services transaction memory allocator introduction transaction invoke sbrk grow heap logtm htm continue transactional operation non-transactional kernel open solaris cede isolation control kernel memory user-level code escape actions provide bridge transactional nontransactional software summarized table escape actions suffice handle hundred open solaris system calls core services processor thread management file synchronization escape actions trivially correct read-only system calls getpid concurrent callers errors isolation compensation aborts category shown table traps tlb misses read kernel state causing user-visible transparent escape actions made correct system calls sbrk incr affect threads current process key steps invoking system calls isolating registering compensating action roll-back effects call transaction abort releasing isolation enclosing transaction commits sentinel location process virtual memory acts transactional lock kernel state writing sentinel location invoking system call effect locks sentinel prevents transactions invoking call outer transaction commits figure illustrates transactional wrapper sbrk system call process data segment size wrapper writes sentinel prevents threads calling sbrk incr enclosing transaction commits aborts invoking sbrk successfully wrapper registers compensating action undoes effect system call case resetting data segment back original size call sbrk -incr wrapper begins ends escape action explicitly ensure system call compensating action registration atomic enclosing transaction abort immediately escape action ends sentinels sufficient simple system calls general locking mechanisms complex calls 
open transactions escape actions commit actions system calls release isolation enclosing transaction commits escape actions make system calls safe calls manipulate data file system undoable effects observed processes similarly calls kill unlink undone data process file destroyed executing calls safely inside transaction require serialization-based technique unrestricted transactions escape actions common exceptions tlb miss handlers protection fault handlers system calls execute correctly disrupting running transactions greatly simplifies transactional programming increasing amount code run transaction requirements escape actions open transactions potential complex interactions compensation undo addition escape actions bypassing transaction conflict detection version management weak atomicity lead programming challenges result recommend escape action executed thread transaction level obey conditions condition writes data written ancestors write data written ancestors table escape actions open solaris system calls category examples read-only calls getpid times stat qualifiers proceedings acm sigplan conference programming language design implementation pages atlanta georgia sigplan notices helmbold mcdowell computing reachable states parallel programs acm sigplan notices dec hendren tang zhu ghobrial gao xue cai ouellet compiling earth multithreaded architecture international journal parallel programming aug henglein rehof complexity subtype entailment simple types proceedings twelth annual ieee symposium logic computer science pages warsaw poland june july ieee computer society press hilfinger bonachea gay graham liblit yelick titanium language manual technical report csd- california berkeley nov liblit aiken type systems distributed data structures conference record popl acm sigplan-sigact symposium principles programming languages pages boston massachusetts january liblit aiken type systems distributed data structures technical report csd- california berkeley jan http sunsite berkeley techreppages csd- liblit aiken yelick data sharing analysis titanium technical report csd- california berkeley nov http sunsite berkeley techreppages csd- mellor-crummey compile-time support efficient data race detection sharedmemory parallel programs acm sigplan notices dec midkiff padua issues optimization parallel programs proceedings international conference parallel processing volume software pages park penn aug penn state press csrd ill myricom message passing system july version oopsla acm conference object-oriented systems languages applications volume acm sigplan notices denver oct acm press peskin mcqueen three-dimensional computational method blood flow heart immersed elastic fibers viscous incompressible fluid journal computational physics apr pike semenzato colella hilfinger parallel adaptive mesh refinement titanium proceedings ninth siam conference parallel processing scientific computing san antonio texas mar plainfoss shapiro survey distributed garbage collection techniques baker editor proceedings international workshop memory management volume lecture notes computer science ilog gentilly france inria chesnay france sept springer-verlag rinard lam design implementation evaluation jade acm transactions programming languages systems savage burrows nelson sobalvarro anderson eraser dynamic data race detector multithreaded programs acm transactions computer systems nov steensgaard thread-specific heaps multi-threaded programs hosking editor ismm proceedings international symposium memory management volume acm sigplan notices minneapolis oct acm press supercomputing technologies group mit laboratory computer science cilk manual june whaley rinard compositional pointer escape analysis java programs oopsla pages zhu hendren locality analysis parallel programs ieee transactions parallel distributed systems feb zhu hendren communication optimizations parallel programs acm sigplan notices 
access mincore sync pread gettimeofday undoable calls per-process side effects chdir dup umask seteuid nice seek mprotect undoable calls global side effects handled chmod mkdir link mknod stime calls handled escape actions write kill fork exec umount void logtm sbrk int incr sbrk sentinel escape begin tmp sbrk incr tmp null escape end abort action sbrk -incr escape end null return tmp figure wrapper sbrk transactions effect call lock sentinel condition writes data accessed write data read written active transactions threads condition reads data written read data written active transactions threads conditions restrict escape action modifying uncommitted updates ancestor transactions threads transactions condition restricts escape action reading threads uncommitted updates conditions hold escape action operates non-transactional level begin transaction ending resumes execution thread level transaction escape action register commit compensating actions escape escape handlers differ open transaction counterparts execute escape actions escape actions violate conditions important debuggers exception handlers updates erroneous values resuming transaction reason section describes logtm escape action behavior including violations behavior cases htms differ subtle implementationdependent ways conditions hold escape actions resemble zilles bauch pause unpause escape mechanism non-isolated accesses memory support nontransactional operations escape actions maintain pause strong atomicity user-mode code zilles concurs weak atomicity prevent deadlock paused regions access transactionally isolated data zilles personal communication escape actions resemble external actions harris stm system java harris external actions special potentially costly steps maintain java memory safety pre-registration future external actions escape actions lightweight low-level mechanism language design system interactions escape actions logtm implementing escape actions nested logtm straightforward escape action requires escape flag thread figure transaction escaped escape set nested logtm behaves escape action begin sets escape escape action end clears nesting escape actions implemented software hardware action required nested escape action ends ancestor transaction aborts escape action running abort delayed escape flag cleared version management executing escape actions thread makes log reads writes access coherent memory return latest possibly uncommitted write conflict detection executing escape actions thread makes bits ignores conflicting accesses threads forced writeback correctness argument sketch nested hold executing escape actions behavior affected executing escape action thread invoked transaction level reads values written transaction memory writes data memory thread including transactionally-modified data accessed logtm violations logtm reads escape actions return recent uncommitted write thread reads data modified transaction thread violation return uncommitted data uncacheable block similarly writes blocks read modified transaction thread violation update values immediately writes invalidate remote caches forcing modified blocks back memory leave blocks sticky-s sticky-m state writes memory locations modified ancestors violation update values affect ancestors bits log methods section describes target system assumptions simulation techniques evaluating nested logtm versus flat logtm table summarizes parameters system model system processors levels private cache moesi directory protocol maintains coherence highbandwidth switched interconnect single-issue in-order processor model assumes aggressive single-cycle non-memory ipc detailed memory system model includes timing intricacies transactional memory extensions simulation framework virtutech simics conjunction customized memory models built wisconsin gems simics full-system functional simulator accurately models sparc architecture support transactional memory support logtm added simics magic instructions special no-ops simics catches passes memory model experiments section presents experiments isolate performance differences nesting alternatives earlier studies examined benefits transactions locks exercising nesting sorted list versions sorted list microbenchmark table system model parameters system model settings processors ghz single-issue in-order non-memory ipc cache -way split -cycle latency cache -way unified -cycle latency memory -cycle latency directory full-bit vector sharer list migratory sharing optimization directory cache -cycle latency interconnection network hierarchical switch topology -cycle link latency logtm support escape actions correct conditions verify nested logtm performs expected illustrate conditions closed nesting partial aborts closed open nesting open outperform flattening flat sorted list microbenchmark searches shared sorted linkedlist complex elements thread repeatedly begins top-level transaction examines list elements find matching field chosen random microbenchmark versions update global shared counter level-two nested transaction points execution slist-early performs update search slist-late performs searches read-only contention occurs counter update counter updates require compensating action counter unique continuous slist-late left side figure nested logtm closed open improves performance relative flat logtm performance improves avoid complete aborts nested transactions conflict versions perform similarly top-level transaction commits level-two transaction commits limiting long closed flat extend isolation counter slist-early side figure closed nesting partial aborts offers performance improvement open nesting dramatic improvement closed abort occurs level-two transaction difference partial abort complete abort nested transaction occurs early outer transaction abort occurs level-two transaction commits forcing complete abort outer transaction subsumes open achieves performance releases isolation counter level-two transaction commits greatly increasing concurrency results illustrate closed nesting partial aborts improve performance conflicts arise nested transactions occur late top-level transaction conversely open nesting releases isolation improves performance nested transactions occur early top-level transaction b-tree microbenchmark b-tree microbenchmark represents common class concurrent data structures found applications results show closed benefit flat open represents attractive alternative restructuring workload b-tree thread makes repeated accesses shared tree randomly performing lookup probability insert tree -ary b-tree initially levels deep high level operation insert lookup executed top-level transaction inserts encounter full nodes split tree preventing back propagation splits occur level-two closed nested transaction nodes allocated shared free list open closed level-three nested transactions assume presence garbage collector compensating action open nested transactions figure illustrates speedup alternative versions b-tree relative sequential performance speedups exceed threads threads solaris threads bound processors 
speedups cost-effective multiprocessors cost times uniprocessor case chip multiprocessors bottom lines figure labeled flatand closedshow poor speedup flat closed investigation revealed insert transactions frequently contended shared free list entire insert executes single parent transaction flat closed subsume free list parent transaction write set preventing access subsequent inserts parent transaction commits partitioning free list separate lists approximating thread-private allocators eliminates bottleneck expense restructuring benchmark lines labelled flatand closedin figure show good speedup improved allocator difference flat closed discussed earlier open nesting presents appealing alternative allocators openuses open nested transaction access simple non-partitioned free list figure shows opensimple allocator performs closedsimple allocator closedpartitioned allocator results demonstrate programmer library writer choose open nested transaction complexity parallelizing allocator considerable merit approach complex allocators speedup closed open slist-late closed open slate-early figure slist speedup closed nesting partial aborts open nesting flat implementation threads speedup closedflat- closedflat- figure scalability b-tree flat closed nesting closed nesting partial aborts flatand closedor flatand closedfree lists increase concurrency data structures splashs radiosity raytrace cholesky original logtm paper converted selected splashbenchmarks replacing locks transactions leaving barriers synchronization mechanisms unchanged study found flat logtm offered good performance comparable locks modified flat transaction versions radiosity raytrace cholesky adding closed nested transactions open nesting applied data modifications undone isolation released benchmarks lend easily nested transactions radiosity nested locking replaced closed nested transactions raytrace cholesky memory allocation routines walk list elements programs nesting split large transactions smaller transactions partial abort entire list access transaction additionally code modifies list put inside nested transaction optimized raytrace prevent interactions transactions due false sharing ran benchmarks closed nesting partial aborts confirmed chung finding closed nesting programs result due part rarity aborts splashon flat nested logtm escaping open solaris escape action control transfer transactional nest non-transactional system back figure table illustrates escape actions suffice handle hundred open solaris system calls section illustrates nested logtm escaping solaris tlb traps loading tlb non-transactional kernel resuming user-level activity escape actions logtm abort active transaction preserve user kernel isolation handle tlb trap nontransactional mode restart transaction exercise implementations tlb traps singlethreaded microbenchmark walks character array stride figure displays data read rate varying array sizes nested logtm escape actions escape achieves roughly constant performance array size line abort shows escape actions performance degrades rapidly array size increases abort fails make forward progress arrays larger pages -entry tlb tlb map entire array results discussion nested logtm greatest performance improvement flag logtm open nested transactions release isolation early increasing concurrency escape actions improve performance allowing non-transactional trap code execute aborting current transaction improvement closed nested transactions performance benefit transactions abort splashresults concur chung finding closed nesting programs fact benefit splashas flat logtm rarely aborts programs part stalls recently tcc group adapted workloads aborts common partial aborts valuable specjbb processors figure violations dominated execution time flattening time closed nested reduced execution time substantially closed nesting similarly nested logtm workloads stalling mitigate benefit partial aborts conclusions transactional memory systems support closed nested transactions complete aborts flattening selective partial aborts nested transactions open nested transactions newly-proposed escape actions paper expresses behavior alternatives common model implement nesting alternatives recentlyproposed flat log-based transactional memory logtm nested logtm supports closed nesting partial aborts data rate low fetches byte misses figure scalability b-tree multiple allocators open nesting threads speedup openclosed- closedbenchmark footprint data read sec escape abort figure strided array accesses causing tlb traps handled escape actions escape aborts segmenting log stack activation records modestly cache tlb miss second-level tsb miss replicating bits open nesting allowing committing open transaction release isolation optionally save commit compensating actions log non-transactional escape actions commit compensating actions evaluate microbenchmarks demonstrate closed open nesting performance differences sorted list concurrency exposed open nesting b-tree performance improvement closed nesting splashsubset correct operation tlb traps exposed actions strided array future work includes evaluating closed nesting partial aborts open nesting benchmarks representative future workloads plan explore richer semantics open nested transactions escape actions provide complete runtime operating system support acknowledgements virtutech wisconsin condor group wisconsin computer systems lab support daniel gibson flash-or circuit kan zeffer computer architecture affiliates members wisconsin multifacet project helpful feedback work ananian asanovic kuszmaul leiserson lie unbounded transactional memory proceedings eleventh ieee symposium high-performance computer architecture feb blundell lewis martin deconstructing transactional semantics subtleties atomicity workshop duplicating deconstructing debunking wddd june blundell lewis martin unrestricted transactional memory supporting system calls transactions technical report tr-cis- pennsylvania june carlstrom chung chafi mcdonald minh hammond kozyrakis olukotun transactional execution java programs scool workshop oct chung chafi minh mcdonald carlstrom kozyrakis olukotun common case transactional behavior multithreaded programs proceedings twelfth ieee symposium high-performance computer architecture feb chung minh carlstrom kozyrakis parallelizing specjbb transactional memory podc workshop concurrency synchronization java programs june hammond wong chen carlstrom davis hertzberg prabhu wijaya kozyrakis olukotun transactional memory coherence consistency proceedings annual international symposium computer architecture june harris design choices language-based transactions technical report ucam-cl-truniversity cambridge aug harris exceptions side-effects atomic blocks podc workshop concurrency synchronization java programs jul harris fraser language support lightweight transactions proceedings sigplan conference object-oriented programming systems languages application oopsla oct harris marlow jones herlihy composable memory transactions proceedings acm sigplan symposium principles practice parallel programming ppopp june herlihy luchangco moir scherer iii software transactional memory dynamic-sized data structures twenty-second acm symposium principles distributed computing boston massachusetts july herlihy moss transactional memory architectural support lock-free data structures proceedings annual international symposium computer architecture pages korth levy silberschatz formal approach recovery compensating transactions proceedings sixteenth international conference large databases pages san francisco usa morgan kaufmann publishers lebeck wood dynamic self-invalidation reducing coherence overhead shared-memory multiprocessors proceedings annual international symposium computer architecture pages june magnusson simics full system simulation platform ieee computer feb martin sorin beckmann marty alameldeen moore hill wood multifacet general execution-driven multiprocessor simulator gems toolset computer architecture news pages sept mcdonald chung carlstrom minh chafi kozyrakis olukotun architectural semantics practical transactional memory proceedings annual international symposium computer architecture june microsystems opensolaris mutex http cvs opensolaris source xref usr src uts common mutex mohan haderle lindsay pirahesh schwarz aries transaction recovery method supporting finegranularity locking partial rollbacks write-ahead logging readings database systems pages morgan 
kaufmann publishers moore bobba moravan hill wood logtm log-based transactional memory proceedings twelfth ieee symposium high-performance computer architecture feb moss nested transactions approach reliable distributed computing phd thesis massachusetts institute technology moss nesting transactions transact keynote address june moss open nested transactions semantics support workshop memory performance issues feb moss griffeth graham abstraction recovery management sigmod proceedings acm sigmod international conference management data pages york usa acm press moss hosking nested transactional memory model preliminary architecture sketches scool workshop oct parnas criteria decomposing systems modules communications acm dec rajwar herlihy lai virtualizing transactional memory proceedings annual international symposium computer architecture june shavit touitou software transactional memory fourteenth acm symposium principles distributed computing ottawa ontario canada pages aug sun microsystems solaris manual collection man pages section system calls http docs sun app docs doc weikum theoretical foundation multi-level concurrency control proceedings acm sigact-sigmod symposium principles database systems pods pages mar weikum schek concepts applications multilevel transactions open nested transactions morgan kaufmann wisconsin multifacet gems simulator http wisc gems woo ohara torrie singh gupta splashprograms characterization methodological considerations proceedings annual international symposium computer architecture pages june wood hill cost-effective parallel computing ieee computer pages feb zilles baugh extending hardware transactional memory support non-busy waiting non-transactional actions acm sigplan workshop languages compilers hardware support transactional computing june 
extracting output formats executables junghee lim junghee wisc thomas reps reps wisc ben liblit liblit wisc computer sciences department wisconsin-madison abstract describe design implementation ffe file-format extractor analysis tool works stripped executables source code debugging information extracts output data formats file formats network packet formats construct hierarchical finite state machine hfsm over-approximates output data format hfsm defines language operations generate output data value-set analysis vsa aggregate structure identification asi annotate hfsms information partially characterizes output data values vsa determines over-approximation set addresses integer values data object hold program point asi analyzes memory accesses program recover information structure aggregates series filtering operations performed over-approximate hfsm finite-state machine result final answer easier understand experiments ffe uncovered bug image-conversion utility png ico introduction reverse engineering helps gain insight program internal workings performed retrieve source code program source code lost analyze program malicious virus fix bug improve performance program paper describes reverseengineering tool human understand program produces output cots commercial off-the-shelf software increasingly deployed source code documentation proprietary intermediate formats reverse engineering increasingly needed work supported part nsf grants ccfand ccrand onr contracts dayton madison usa interoperability cots tool proprietary file format interoperability inhibited tool tool chain consumer producer files format technique presented paper promotes reuse components tool chain software engineer build program process files cots software product generates tool obtain information format specification creating program act substitute consumer producer technique presented malware detection instance identify live versions malware figure format network traffic technique provide problem technique provide summary program behavior produces structure consists reduced number entities compared call graph instance make easier understand program contributions work technique extracting overapproximation program output data format including extract preliminary structure output data format elaborate structure annotating information output values sizes simplify structure provide greater understanding output data format information lead greater understanding program behavior report experimental results applying ffe applications experiments uncovered bug png ico concentrated problem extracting output file formats executables approach applied source code advantage information program variables declared types extracting input file formats remainder paper organized discusses key observations inspired work assumptions approach explains process constructing structure output data format overview infrastructure implementation based discusses elaborate structure generated step static analyses presents series filtering operations making hfsms understandable describes validated ffe presents experimental results describes related work describes future directions observations assumptions programming styles section makes observations programming styles typical application programs produce output data programming styles relevant writing output data categorized individual writes bulk writes present approaches tailored handle sections programs styles tool capable handling programs void put byte char void put long long void writes char void type switch case put byte break case put byte break void chksum put long void fill data put byte void main put long magic put long magic writes filename type put long size chksum return figure individual writes individual writes programming style write individual data items separately file network standard functions fputs fputc programs practice wrapper functions tend frequently fig shows programming style wrapper functions put byte put long writes fields output including magic numbers types sizes checksum written calling wrapper functions functions provide api append output items internal buffer buffer filled contents buffer flushed buffer written bulk individual calls wrapper functions represent individual writes referred style refer standard functions user-defined wrapper functions output functions output operation operation relevant generating output data object specifically term output operation defined call site calls output function standard library function wrapper function lines fig experience application programs coded programming style instance gzip compress png ico follow programming style typedef struct header byte magic char char type long size long chksum header void write file header header malloc magic strcpy type size chksum fwrite sizeof header write data figure bulk write bulk writes programming style structs classes manipulate headers fig shows header structure write output data header struct object created line field struct set lines finally lines object written file entirety programming style calls fwrite output operations practice observed tar cpio aggregate structures storage preparation bulk write suspect style headers applications output files consist sequence records user-supplied information current implementation user identify output functions supply additional information information outputrelevant parameter numeric written gzip source macros functions output operations call sites gzip executable compatible approach user identify output operations supplying names output functions convert gzip output operations visible procedure calls proof concept experimental study modified gzipsource code change output macro definitions explicit functions automatically identifying low-level code fragments represent output operations remains challenging problem future work address pointing memory data written bytes written details case standard functions information step approach hierarchical finite state machine hfsm represent output data format hfsm structure nesting finite automata states allowed hfsm captures commonalities organizing states hierarchy note points hfsms languages paths recursive hfsms context-free languages languages paths non-recursive hfsms regular languages call bar foo bar baz call bar call baz call baz figure fsm hierarchical fsm non-recursive hierarchical fsms exponentially succinct conventional fsms due sharing illustrated fig construction hfsm code fragment shown fig explain approach code emulates archive utility writes magic numbers file layout type size check-sum wrapper functions fig shows disassembled code generated idapro procedure involved output operation rise fsm program wrapper functions include put byte disassembled code put long writes calls functions represent output operations ffe finds output operations constructs hfsm based cfgs provided codesurfer analyzer creates reduced interprocedural control-flow graph hfsm projection interprocedural control-flow graph enter nodes exit nodes call nodes output operations fig shows outcome running ffe node hfsm output operation call put long call put long call write bytes call fill data call put long call type call chksum call put byte call put long call put long call put long figure hfsm fig shaded boxes signify calls fsms dotted lines implicit connections fsms proc type push ebp mov ebp esp esp mov eax ebpmov ebpeax cmp ebpjz short loc cmp ebpjz short loc jmp short loc loc mov eax ebpd mov esp eax call jmp short loc loc mov eax ebpa mov esp eax call loc leave retn proc chksum push ebp mov ebp esp esp mov eax 
ebpd mov esp eax call leave retn proc fill data push ebp mov ebp esp esp loc cmp ebpjz short loc movsx eax ebpmov esp eax call jmp short loc loc leave retn proc main push ebp mov ebp esp esp esp fffffff mov eax add eax add eax shr eax shl eax mov ebph eax mov eax ebph call call main mov eax ebph mov esp eax call mov eax ebpch mov esp eax call mov esp mov eax ebpce mov esp eax call call call mov eax ebpe mov esp eax call call mov eax leave retn figure disassembled code fig transparent boxes output operations shaded boxes calls sub-fsms call-site sub-fsm type call-site node represents call sub-fsm implicitly connects fsms hfsm hfsm generated tool gzip shown fig thesis hfsms including elaborations refinements hfsms explained provide basis gaining understanding program behavior regard instructive compare hfsm program call graph call graph structure programmer gain high-level understanding program fig shows part call graph gzip gzip composed control-flow graphs cfgs cfg nodes call sites hfsm produced tool appears complicated substantially complicated program call graph interprocedural control-flow graph hfsm gzip fsms nodes call sites entry call call call call call call call call entry entry call call call call entry call call entry dfd call entry call call call call call call entry call entry entry entry entry call call call call call call call call entrycall call call call call call figure hfsm gzip fragment call graph gzip existing infrastructure ffe intermediate representations irs provided codesurfer framework fig analyst powerful flexible platform investigating properties behaviors executables codesurfer includes static analyses including set analysis vsa aggregate structure identification asi executable disassembleexecutable build cfgs ida pro vsa asi connector codesurfer back-end file format extractor codesurfer figure organization codersurfer ffe interacts components vsa combined numeric-analysis pointeranalysis algorithm determines over-approximation set numeric values addresses memory location holds program point asi recovers information variables types aggregates including arrays structs variables recovered asi vsa obtain information variables values values recovered vsa asi identify refined set variables codesurfer runs vsa asi repeatedly quiescence user-supplied bound reached vsa asi quiesced bound reached codesurfer initial estimate program variables call graph control-flow graphs cfgs program procedures provided idapro idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete contrast codesurfer values vsa discovers resolve indirect jumps indirect calls supply sound over-approximation call graph discusses ways vsa asi exploited purposes augmenting hfsm static-analyses information section explain exploit static analyses mentioned elaborating hfsms set analysis hfsm generated method information understanding output format hfsm made precise annotating additional information label node information size bytes data node represents over-approximation written values interest actual parameters formal parameters output functions suppose put byteis output functions fig suppose call sites safe results final round vsa round vsa over-approximation set numeric values addresses memory location modulo treatment memory-safety violations due loss precision vsa details void put byte char outbuf outcnt uch outcnt outbufsize flush outbuf mov byte ptr esp call put byte figure code fragment put byte output function call sites call output operations calls put byte output operations actual parameter fig information obtained information collected vsa note call put byte relevant stored stack byte pointed byesp abstract memory configuration amc vsa call site instance fig illustrates values amc tool obtain overapproximation set values actual hold evaluating operand expression esp amc amounts amc contents cell cells esp point result singleton set buf ptr size count esp esp size fhvalue size size count number bytes written size size esp figure obtain information vsa kinds parameters passed output function numeric values addresses numeric values case actual parameter holds numeric explained fig size obtained asi infers size usage pattern formal parameter called function case output operation calls standard function information signature function put bytewould -byte argument put short -byte argument addresses type formal parameter pointer set addresses memory location actual parameter amc values cells actual parameter point fig case fwrite lines fig falls category address heap-allocated memory location data passed argument size tfwrite constvoid buf ptr size size size count file product parameters fwrite number bytes written fig roles kind abstract recovered vsa suggests role singleton vsa recovers singleton actual parameter output operation parameter correspond magic number reserved field set numeric valuesif vsa recovers non-singleton set numeric values parameter correspond optional field topif vsa top means actual parameter output operation parameter correspond variant data aggregate structure identification mentioned programmers frequently struct class collect data written char outpack maxpacket static void pinger void register struct icmphdr icp register int int icp struct icmphdr outpack icpicmp type icmp echo icpicmp code icpicmp cksum icpicmp seq ntransmitted icpicmp ident sendto char outpack whereto sizeof struct sockaddr figure code fragment illustrate asi information fig shows fragment ping network packet constructed writing individual data items time output operations struct object store output data multiple fields prepared shown lines fig aggregate object written lines aggregate structure identification asi unification-based flow-insensitive algorithm identify structure aggregates program read write part memory object encountered asi records memory object subdivided smaller objects consistent memory access assume user sendto gnu library function mov eax dword ptr ebp mov byte ptr eax mov edx dword ptr ebp mov byte ptr edx mov eax dword ptr ebp mov word ptr eax mov eax dword ptr ntransmitted mov edx dword ptr ebp mov word ptr edx dword ptr ntransmitted mov eax dword ptr ident mov edx dword ptr ebp mov word ptr edx global struct byte outpack byte outpack byte outpack byte outpack byte outpack figure disassembled code fragment fig outcome asi output function argument sendto pointer struct object unknown substructure asi information substructure instructions correspond assignment statements lines fig shown fig lines vsa information extent memory accessed instructions asi information subdivide portion memory accessed producing structure shown fig structure packet header consist -byte fields -byte fields asi capable recovering information structure aggregates allocated heap illustrates case output function emits completely-constructed chunk output data hfsm represents program output operations high level abstraction bulk writes structure information recovered asi identifying structure output data format fig 
pinger call sendto elaborated sequence -byte header-field writes larger packet payload filtering hfsm hard understand experimented applying series filtering operations including simplification conversion fsm regular expression inline expansion generate simpler representation output format regular expression experiments manually process easy automate simplification nodes hfsm helpful understanding output format unnecessarily complicated hfsm prevent users understanding key aspects output format portions hfsm shown fig turn top-value top-size unbounded loop includes top-valuemeans node top-size means node size cases node node set provide meaningful information node top-size top-value node set unbounded loop top-size top-value considered meaningful node node node non-top-size algorithm simplification algorithm input hfsm output trimed hfsm set status fsms meaningful exists meaningful fsm non-meaningful nodes calls non-meaningful fsms set non-meaningful fsm transform fsm self-loop node labeled top-size top-value end alg describes algorithm simplifying hfsms generated ffe idea algorithm cases mentioned fsm consists nodes top-value top-size unbounded loop includes items simplify top original fsm provide meaningful information output format size top top size top top call size top top size top top size top top call size top top figure simplification fig shows simplification shaded fsm non-meaningful fsms non-meaningful nodes simplified unbounded selfloop consisting node top-size top-value conversion regular expression convert fsm hfsm regular expression kleene construction expansion final step apply inline expansion recursion encountered applications experiments inline expansion applied worrying nontermination recursion encountered summarized strongly connected components call graph fig represents final outcome techniques size size size top top size top size size size top size top figure final result simplification conversion inline expansion validation dynamic output validate approach testing outcome algorithm regular expression matches output data produced actual runs application flex tool generating scanners compilers input specification form list pattern-action pairs pattern regular expression flex generates program repeatedly finds longest prefix remaining input matches patterns create tool testing regular expression generated algorithm describes output application give flex -pattern specification consisting action report success default pattern action report failure discussed earlier box shown fig regular expression generated technique labeled kinds information size size top singleton set numeric values singleton set numeric values top feed flex regular expression transformed basic unit -byte character table shows transformation rules applied boxes table transformation boxes size conversion singleton singleton split multiple boxes -byte box fig transformed boxes fig singleton top top transformed matches character transformed sequence boxes box fig transformed boxes fig top top transformed box self-loop box fig transformed box loop fig table describes cases size singleton top note case size top non-top outcome vsa case size set numeric values split shorthand character flex pattern size size top top size size top size top figure transformation means character box multiple boxes singleton singleton size box fig values transformed boxes fig values case size singleton shaded boxes fig show converted note process validation original values sets values understandable human subdivided values experimental results evaluated ffe applications gzip png ico ping gzip gzip gnu data-compression program fig represents outcome filtering hfsm fig size size size size top size top top size top top size top size top size top size top size top figure final result gzip table part specification gzip format xflmtimeflgcmid flg fhcrc set isizecrc compressed blocks fixed values xlf identifies compression method reserved demotes deflate compression method flg divided individual bits bit ftext bit fhcrc mtime recent modification time original file compressed xfl specific compression methods identifies type file system compression place fat filesystem amiga crc cyclic redundancy check uncompressed data isize size original input data modulo format files generated gzip rfc table outcome shown fig correctly over-approximates specification words language outcome superset output language gzip outcome magic numbers constant positions shown table -byte element mtime -byte elements toxflandos end -byte elements correspond tocrc isize applied validation process outcome flex-generated validator accepted files chosen arbitrarily internet png ico size size top size size top size top size size top size size top size size size size top top size size top top size size size top size top size top size top size size size top size top size top figure outcome png ico table unofficial specification ico format size description reserved byte type byte count byte number icons file entries count list icons width byte cursor width height byte cursor height commonly width colorcount byte number colors reserved byte planes byte bitcount byte bits pixel sizeinbytes byte size infoheader andbitmap xorbitmap fileoffset byte filepos infoheader starts repeated count times infoheader bytes variant bmp infoheader size bytes size infoheader structure width bytes icon width height bytes icon height added height xorbitmap and-bitmap planes bytes number planes bitcount bytes bits pixel compression bytes type compression imagesize bytes size image bytes uncompressed xpixelsperm bytes unused ypixelsperm bytes unused colorsused bytes unused colorsimportant bytes unused colors number-of-colors bytes color map xor-bitmap red byte red component green byte green component blue byte blue component reserved byte repeated numberofcolors times xorbitmap bitmap andbitmap monochrome bitmap png icoconverts png files windows icon-resource files fig shows final outcome compared unofficial specification ico image format table constant data items format recovered ffe fields ico format including reserved type constant values recovered technique structure fig similar table difference format recovered ffe shows loops top level sequence entries sequence structures consist infoheader sequence colors sequence xorbitmaps sequence andbitmaps constrast table shows single infoheader color xorbitmapandbitmap structure inspection source code confirmed png ico supports sequence infoheader color xorbitmapandbitmap structures ffe revealed bug png ico showed format produced png ico satisfy specification table table planes field entries shown eighth box size row fig png icoalways produces discrepency discovered ran flex-generated validator checks conformance png ico output format extracted ffe pre-existing ico files files windows installation created running freeware png ico utility validator rejected files accepted ico files generated png ico tracked problem line png ico source writeword outfile wplanes ping ping sends icmp echo request packets host host reachable network sendto output function ping discussed structure hfsm shown fig represents program output operations high level abstraction hfsm inferred main calls pinger catcher pinger calls sendto pinger sub-fsm fig constructed information recovered sendto asi format sizes successive elements 
bytes shown fig shown fig icmp packet struct includes -byte fields uint icmp type uint icmp code -byte field uint icmp checksum unions icmp hun icmp dun outcome ffe satisfies part specification -byte fields match uint icmp type uint icmp code call sendto size top size top size top size top size top pinger pinger pinger pinger entry pinger pinger size top top pinger exit pinger entry pinger exit catcher entry catcher exit pingermainentry mainexitpinger catcher pinger figure outcome ping hfsm hints program behavior ping packet -byte icmp header data typedefstructicmp uint icmp type type message uint icmp code type code uint icmp checksum complement cksumof struct define icmp cksumicmp checksum union uint pptr icmp paramprob structin addrih gwaddr icmp redirect structih idseq uint icd uint icd seq idseq intih void icmp unreach needfrag --path mtu discovery rfc structih pmtu uint ipm void uint ipm nextmtu pmtu structih rtradv uint irt num addrs uint irt wpa uint irt lifetime rtradv icmp hun define icmp pptricmp hun pptr union structid uint otime uint rtime uint ttime structid structipidi options bits data structicmp addrid radv uint mask char data icmp dun define icmp otimeicmp dun otime icmp figure icmp packet structure -byte field matches uint icmp cksum -byte fields match union icmp hun includes struct idseq consists uint icd uint icd seq union icmp dun discovered asi assignment union code asi partition memory locations union corresponds signal outcome ffe incomplete respect shown fig lines ping calls signal library function signal asynchronous event handling means statically generated control-flow graph cover flows control technique based cfg statically generated codesurfer output operations apvoid signal sitint finish void signal sigalrm catcher preload-pinger options flood catcher struct sockaddr register int size fromlen options flood floodok floodok pinger figure code fragment ping pear handler function signal call establishes resultant hfsm over-approximate outputs related work previous work reverse engineering file formats dynamic manual eilam describes strategy deciphering file formats symbol table sample output file approach requires manually stepping disassembled code inspecting memory contents debugger program produces file approaches ignore program rely heuristic generalization sample output files reverse-engineering case study searched zlib-compressed data file names length bytes typical structures approaches require considerable manual effort guarantee chosen sample files sufficiently general constrast static approach over-approximates file format relying sample files symbol tables extensive manual analysis human intervention needed identify output functions assign higher-level interpretations file selected fields identified analysis similar attempts statically recover information program data christensen presented technique discovering values string expressions java programs context-free grammar generated constructing dependence graphs class files grammar widened regular language strings dynamically generated method christensen applied low-level code christodorescu method string analysis executables approach similar sense executables targets tools recovered output data format analysis represented regular language denotes superset actual output language approach sense initial context-free structure recovered tool structure operations purely internal procedure call-return structure program tool approach related work host-based intrusion detection models expected program behavior constructed model over-approximates sequences system calls comparing actual sequence system calls allowed model detect malicious input hijacked program pushdown-system models employed purpose constructed source code low-level code sparc executables hfsms similar yield context-free languages projection portion program behavior previous work results dataflow analyses vsa asi elaborate models information sets values sizes conclusion future work paper focus output operations approach applied kinds operations treat input operations examining parsing input file approach paper case paths exit points represent successful runs program correspond successful well-formed input files addition apply approach network communication operations parse construct packets suggested referees characterization input language generate test inputs similarly knowledge output language component tool chain source test inputs component chain discussion ping signal calls factor hfsm overapproximate actual output language program description static-analysis tool handle features paper mops approach mops hfsms mentioned earlier assume output functions identified user create automatic tool extracting data formats desirable find automatically identify output functions wrapper functions loop hfsm transformed node-set node-set cases bound number iterations loop obtained vsa cases information loop iteration bounds provide users precise information output format basic file format ico files http daubnet formats ico html compress spec benchmark http itee emmerik specbench html cpio gnu project http gnu software cpio cpio html file format reversing everquest vpk http openrce articles full vew flex http gnu software flex gzip gnu project http gzip ping http packages debian stable net netkit-ping png ico http winterdrache freeware png ico tar gnu project http gnu software tar tar html freebsd linux kernel cross http fxr watson fxr source netinet icmp gzip file format specification version http gzip zlib rfc-gzip html alur benedikt etessami godefroid reps yannakakis analysis recursive state machines toplas alur yannakakis model checking hierarchical state machines fse pages balakrishnan reps analyzing memory accesses executables balakrishnan reps recovery variables heap structure executables tech rep trcomp sci dept univ wisconsin madison sept chen wagner mops infrastructure examining security properites software ccs christensen ller schwartzbach precise analysis string expressions sas christodorescu kidd goh string analysis binaries paste eilam reversing secrets reverse engineering wiley publishing giffin jha miller detecting manipulated remote call streams usenix security symposium giffin jha miller efficient contextsensitive intrusion detection ndss ramalingam field tip aggregate structure identification application program analysis popl pages reps balakrishnan lim next-generation platform analyzing executables aplas reps balakrishnan lim intermediaterepresentation recovery low-level code pepm wagner dean intrusion detection static analysis ieee symposium security privacy 
pennsylvania state scholars program department computer science transformation prolog programs perform update place prototype code synthesizer benjamin liblit april thesis submitted partial fulfillment requirements degree bachelor science honors computer science william winsborough barry pangrle thesis supervisor honors advisor honors chairman mary jane irwin head computer science abstract single assignment languages prolog standard endure considerable inefficiency support declarative semantics lacking destructive assignment programs written languages frequently duplicate large portions structures conventional programs simply modify place paper presents techniques automatically transforming prolog programs perform in-place updates destructive assignment reports evaluates experience prototyping code synthesis portion transformation applicable transformation produces code updates structures times faster implementations vastly memory contents introduction background compile time garbage collection update place positional arguments additional internal predicates implementation issues unravels minimized unravels unravel placement input aliasing destructive assignments upper connection placement destructive update method empirical evaluation benchmarks unravels minimized unravels unravel placement input aliasing destructive assignments upper connection placement destructive update method general results conclusions acknowledgments code synthesizer portability invoking synthesizer input file format predicate reuse clause reuse user options limitations benchmark source code append delete insert merge split tree iii list figures splicing delete memory layout list structure cells list tables minimized versus unsimplified unravels at-need versus early unravels input aliasing versus aliasing tail versus early versus late assignments increment assign versus assign versus setarg speed versus update place versus compile time garbage collection memory consumption versus update place introduction logic functional programming languages recent years restricted realms academia formal theory expressive simplicity high level abstraction make languages attractive tend make inefficient difficult prolog standard related languages compete conventional languages fortran major inefficiency extra work required support single assignment semantics incremental change made large structure multiple assignment language perform updates place modifying fields changed single assignment language hand forced copy structure replacing values overhead allocating memory duplicating data garbage collecting discarded copies hurts performance considerably detect original copy structure reused past point modification update place destructively modifying form structure generate refer structures dead memory cells occupied soon-to-be discarded structures intend reuse specifically static analysis detect arguments predicate function dead memory cells occupied arguments recycled construct predicate function output construct arguments body goals subcalls problem detecting deadness relates directly tracking liveness researchers developed static analysis techniques applied end languages including prolog explicitly identify output arguments cases define output predicate arguments passed free variables predicate called determined static analysis methods ideally programmer continue logic functional languages giving elegance ease expression single assignment affords compiler synthesize equivalent code performs multiple destructive assignment augmented primitives performing simple in-place assignments transformed source efficient memory potentially executing speeds competitive conventional languages earlier attempts applying multiple assignment efficiency single assignment languages demonstrated class optimizations lead significant improvements multiple assignment code produced prior approaches operate efficiently techniques essentially equivalent purposes paper focus review compile time garbage collection ctgc approach alternative technique paper centrally concerned update place uip transformation ctgc uip transformation produces code reuse dead memory cells uip transformed programs avoid difficulties hinder ctgc code performance yielding faster code complete uip transformation stage process stage performs dataflow analyses source program phase deadness detection performed input output arguments identified stage performs reuse analyses dead input cells matched output structures create forming mapping describes specifically memory cells reused problem produce good reuse mappings important open question debray proven related reuse problem complete efficient heuristics find good mappings unclear slightly reuse problem faced uip shares traits discussion relationship debray work uip final stage uip transformation code synthesis based dataflow patterns deduced stage reuse mappings selected stage code synthesizer transforms single assignment programs equivalent programs destructively reuse memory cells create structures prototype code synthesizer programs written prolog developed based formal specifications paper primarily address implementation issues involved creating synthesizer timing memory data provided directly compare performance code ctgc code variations uip code small collection benchmarks section reviews ctgc focusing contexts produces code work section develops intuitive basis type transformation apply contrasting ctgc section discusses implementation issues resolved produce transformed code correct highly efficient section presents empirical studies performance transformed collection benchmarks evaluates impact issues lastly section summarizes author findings discusses broader issues synthesizer incorporation working uip transformation system transformation present fairly general chosen prolog working language implement describe research discussion cross language issues background section introduces previously presented techniques rewriting prolog predicates clauses reuse memory cells dead input structures subsection reviews compile time garbage collection illustrates produce code extra work hampering efficiency subsection introduces present proposal update place uip uip avoids pitfalls earlier attempts resulting faster efficient transformed code compile time garbage collection prior proposal transforming prolog programs reuse dead memory cells compile time garbage collection ctgc destructively modifies cells reused free variables newly allocated heap memory cells ordinarily discarded made reuse reduces garbage collector work load leading faster memory efficient code fields reused cell reinstantiated reinitialized closer examination reveals ctgc transformed code perform needless work nonetheless implementation append concatenates arguments append head tail list head newtail append tail list newtail append list list assume static analysis determined arguments dead calls append argument free variable calls compile time garbage collection update place attempt reuse list cells arguments construct ctgc approach make potentially reassignable fields reused cells free variables essentially fields modify uninstantiated reinstantiated values code realizes ctgc transformation append worth noting ctgc originally proposed optimization warren abstract machine code purpose contrasting uip ctgc conveniently presented source level transformation append front rear front front tail makefree front newtail append tail rear newtail append rear rear ctgc primitive makefree rewrite fields free variables primitive called makefree argnum term -freevar destructively modifies argnum field term resembles uninstantiated free variable newly freed variable freevar ctgc code append field front made free variable referenced newtail works element list nil clause transformed predicate instantiates newtail list rear output argument completed list terminate transformed clause executes head unification unifies arguments tail newtail preceding level recursion newtail reinitialized list referenced tail referencing call makefree time spent destructively unbinding rebinding front field wasted append execution field immediately reinstantiated held transformed code perform faster spend time preparing change fields ultimately end staying update place compile time garbage collection extra 
work modifies reusable cells early update place transformation avoids pitfall performing destructive assignments lazily accomplished replacing output argument clause original predicate recent cell destructively modified assignment made genuinely required convention refer extra argument refer transformed code variable names intuitively cell recycled output structure level recursion understand argument program written conventional language append pair lists front rear pointer head lists composed singly linked nodes specially designated nil node marking termination list straightforward approach step links front reaching nil point previous node link pointer originally pointed nil destructively modified point head rear step front track node traversed successive node final node end list prolog code append transformed update place implements algorithm define means performing basic destructive assignment primitive setarg takes form setarg argnum compoundterm newargument call form replaces argnum argument compoundterm newargument interpretation arguments analogous arg setarg backtrackable trail test performed compoundterm argnum field recorded trail backtracking restore original note setarg provided primitive prolog implementations assignment primitive uip transformed code append append rear rear append front rear front front tail append tail rear front append rear setarg rear append front rear front tail append tail rear front notice immediately transformed code clauses half belonging append half append predicate clauses generated clauses original code call append entry predicate append internal predicate clause original code appears entry internal clause occasionally refer entry internal version clause general entry predicates original predicate called arguments internal predicates modified arguments track called entry versions internal predicates named original predicate additional suffix case suffixes encode additional information explained returning clause entry predicate handles specific case top level call append empty list argument case output simply argument clause identical clause original code clause entry predicate interesting argument front empty list reuse cell make cell output list head unification argument cell body unification grabs tail cell sequence finally clause calls internal predicate append call tail replaces argument rear passed unchanged original code place output argument pass front tail empty list front field destructively changed point rear initial cell internal predicate append handles work repeatedly stepping forward argument maintaining cell traversed clause append recursively walks list level recursion unification cell list current cell passed recursive subgoal clause executed argument empty list implies received caller modified matched head discarded ctgc put work preparing referenced cell assignment extra work recursive traversal ends clause append reached end list argument rear holds list concatenated cell terminating entry empty list argument referenced tail field call setarg destructively reassigns field point rear list pasted end execution complete original code copied cells entire length argument copied single destructive assignment redirects cell list point head positional arguments call setarg notice number field changed hard-coded works append modifying field case predicates code performing insertion binary tree tree insert info leaf tree info leaf leaf tree insert info tree node left tree node newleft info node tree insert info left newleft tree insert info tree node left tree node left newright info node tree insert info newright assume static analysis determined argument dead calls tree insert argument free variable time call update argument place construct intuitively expects transformed code clause perform destructive assignment parent leaf atom argument clause giving tree node info leaf left subtree parent destructive assignment made field track field receive assignment augment internal predicates clauses extra parameter passed body goal additional argument pos accompanies pos specifies field replaced event destructive assignment performed full field pos cell full transformed uip code tree insert tree insert info leaf tree info leaf leaf tree insert info tree tree tree tree node left info node tree insert info left tree tree insert info tree tree tree tree node info node tree insert info tree tree insert info leaf pos setarg pos tree info leaf leaf tree insert info tree tree tree node left info node tree insert info left tree tree insert info tree tree tree node info node tree insert info tree workings code similar transformed append argument traversed internal version clause original code anticipated call setarg assigning predetermined field assign field pos examining internal entry clauses pos passed depending info plugged left subtree node examination additional internal predicates reader noticed internal predicates tree insert suffix number chosen input argument child entry predicate information significant determine clause perform destructive assignment alter relationship clause input arguments append parent argument tree insert parent argument occasions children vary calls input argument traversed merge operation parent input argument possibility input arguments child happen splicing occurs cells input skipped incorporating output reflect situation suffix stray transforming code delete demonstrates suffixes vary depending parent child relationship input arguments predicate removes instances argument list argument placing cleaned list argument implementation delete junk junk oldtail delete junk oldtail delete junk oldtail newtail junk delete junk oldtail newtail delete delete operating modes skipping mode copying mode skipping mode cells match junk discarded output list composed remains unchanged copying mode cells match junk copied output list modes correspond clauses listed uip code delete destructive assignments splice cells dropped code skipping mode figure illustrates visually cell successor updated place skip unwanted junk cells possibility skipping cells recycling uip code delete track information figure splicing delete represents behavior uip transformed code deleting list solid arrows represent list cell changed represented dashed arrow destructively updated lightly dotted arrow detect transitions skipping copying modes copying stops skipping begins copying ended carried sequence skipped cells skipping stops copying begins carried skipped cells destructively modified point cell coming sequence copied cells return figure visiting cell transition copying skipping cells skipped continue pass field cell cell prompts transition back copying mode modify cell field point cell transition skipping copying points transformed delete make assignments arises skipping reach end list case cell final cell output list destructively assigning point nil terminates output list call complete level recursion critical factor distinguishing copying skipping modes rests location relative input arguments parent input arguments copying input arguments child call stray signals skipping cases match description earlier meaning suffixes internal predicates fact tracking input argument child sufficient information transformed code behave correctly pattern discarding reuse delete arguments considered input argument reused moment parent argument 
input argument internal predicates named delete delete stray uip-transformed code delete delete junk junk oldtail delete junk oldtail delete junk oldtail junk delete junk oldtail delete delete junk junk oldtail pos delete stray junk oldtail pos delete junk oldtail junk delete junk oldtail delete delete stray junk junk oldtail pos delete stray junk oldtail pos delete stray junk pos oldtail junk setarg pos delete junk oldtail delete stray pos setarg pos notice start top level call entry predicate skips initial junk cells dropping internal predicate main purpose internal predicates track relationships input arguments recall field recent input cell recycled output input list starts junk cells cells recycled output non-junk cell found point execution remains inside entry predicates internal predicates arity extra argument specifies field number actual delete theory optimize positional argument place constant directly calls setarg sake simplicity present automated techniques applying uip transformation attempt detect situation section examines assignment mechanism extra positional argument eliminated transformed predicates implementation issues gudjonsson formally defines code synthesis process mathematical terms section takes primary intent paper carry specification forward implementation important implementation issues omitted abstract specification actual synthesizer options details realized areas gudjonsson specification makes decisions sake descriptive simplicity lead ideal transformed code implementation questions left synthesizer discretion fall major categories related unravels special type unification related destructive assignments issues unravels section assignments covered section hypotheses inferences developed sections evaluated light empirical data section unravels unravels unifications synthesizer adds bodies transformed clauses serve important purposes obtain substructures parent structure points start list unravel tail tail tail list needed tail passed argument body goal recycled cell destructively assigned incorporate tail alternately destructive assignment scheduled field field current needed obtained destructive assignment performed addition obtaining extant portions structures unravels bind nonground terms static structures convention left hand side unravel unification variable unraveled hand side called template serves template outline structure unraveled formal specification uip transformation unravels liberally redundantly unravel templates unification examine structure deeper needed conditions unravels confound important optimizations potential hindrances optimization work subsections follow describe issues solutions greater detail section evaluates empirically minimized unravels unravels simply obtain substructures simplifications applied composing template unravel underscores substituted entire substructures needed suppose structure appears original program root structure children needed unravel simply substitute variables required subterms giving unravel form instantiated original static structure examine entire substructure child efficient unravel obvious optimization important distinguish contexts safely applied unravel purpose create structure templates simplified underscores substructure obtained subsequent unravels intended retrieve omitted code synthesizer track substructures located prior unravel avoids work optimization thought variant common subexpression elimination synthesizer processing unravels records location subterm obtained goal requires subterm unravel performed cases avoiding redundancy eliminate small handful unravel unifications transformed program final extremely basic unravel minimization template unravel free variable simple atom unified variable unraveled synthesis time causing expressed identically transformed clause trivial variable-to-variable variable-to-atom unification goal body transformed clause unravel placement minimization techniques outlined significantly reduce number unravels transformed programs remain code synthesizer choose transformed body unravel unifications option perform unravels start clause lead clause perform unnecessary work body goal fails obtained goals needed prolog clauses informally structured early goals express guard conditions failures early clause transformed code work failure backtracking strong possibility attractive alternative perform unravels unifications fetch substructures substructures needed earlier similarly unifications bind variables static structure immediately body goals variables unraveled hypothesize late placement unravels hurt performance failures rare improve performance failures occur frequently postponing unravels lend additional benefit reducing number live preserved stack subcalls directly address issue input aliasing unravel issue examination concerns effect uip transformation major optimization determinacy analysis examining static structure arguments clause heads aggressively optimizing aquarius prolog compiler determine clauses predicate mutually exclusive cases execution deterministic aquarius avoid creating choice points trail stack small reduces overhead maintaining append head nil argument list cell assuming calls argument ground clauses mutually exclusive arguments passed call match clause match backtracking occur point choice point created conflict arises code transformed perform uip aquarius analyses begin topmost memory cell input argument reused construct output generally formal specification synthesizer simply replace static structure clause head simple variable unify variable original static structure early clause body series unravels head transformation noting underscores substituted arguments central present discussion head tail lists assume argument list lists input argument needed root argument variable hold head transformed clause begin head tail lists moving unifications head body confounds aquarius determinacy analysis analysis strongest mutually exclusive unifications heads unifications bodies determinism present aquarius advantage anticipate blocking important optimization severely damage performance transformed code alternative input aliasing static structure clause heads obtain root cells input arguments input arguments transformed head original including full static structure input argument add additional argument called input alias appears simple variable transformed clause heads internal calls transformed predicate input argument alias passed identical values head unification input alias root input argument original static structure requiring additional unravels body static structure appears head aquarius determinacy analysis continues function properly input aliasing thusly head tail lists calls original modified original goal form lists heads tails replaced lists heads tails lists work disadvantage increasing arity transformed clauses slow calling process conjecture slowdown extremely small compared cost breaking aquarius determinacy analysis destructive assignments major cluster implementation issues involve destructive assignment directly gudjonsson formal specification adopts simple mechanism adding destructive assignments clause bodies implementing destructive assignment primitive sophisticated placement scheme lead efficient code similarly options exist implement destructive assignment primitive execute faster subsections follow describe destructive assignment issues detail section evaluates implications empirically upper connection placement case unravels exists amount flexibility clause body destructive assignments performed loosely speaking destructive assignments piece memory structures structures body goal assignments performed call earlier pieces structure composed fully processed earlier goals interactions unravels destructive assignments impose partial ordering obeyed preserve proper semantics goal receive incorrectly formed structures arguments destructive assignments assign greater leeway assignment choose perform assignments called upper connections body proper unravels performed case unravels wise postpone assignments long work backtracked event body goal fails postponing assignments long create problems specifically assignments pushed back goals transformed clause tail-recursion last-call optimization applicable original clause longer case input aliasing synthesizer confound important 
optimizations process applying hypothesis placing movable assignments subgoal clause body give performance placing assignments late result code drawn split benchmark split stray tail pos pos split stray tail tail setarg pos setarg pos notice setarg calls perform assignments assignments recursive subgoal giving split stray tail pos pos setarg pos setarg pos split stray tail tail clauses semantically equivalent amenable tailrecursion optimization needless anticipate empirical evaluation show clause execute rapidly destructive update method place destructive assignments exact method assignments performed interesting issue examples introduced earlier setarg simple straightforward approach makes source-to-source transformation portable setarg general tool perform required task efficiently setarg applied type memory cell work change depending actual run time arguments specifically call form setarg argnum compoundterm newargument compoundterm cell standard memory layout memory location modified offset start cell argnum words word offset holds compoundterm functor prolog implementations optimize storage list cells storing words reserving word functor compoundterm list cell memory location modified offset argnum words compile time analyses include aggressive type propagation level builtins setarg perform tag checks conditionally integer decrement call figure illustrates simplified manner figure upper rectangle represents memory layout list cell lower rectangle represents memory layout structure cell notice arguments located word back list cell structure cell list cells standard cells place fields offsets alternative propagate type information uip code synthesis invoke specialized destructive assignment primitives primitives forms assign general argnum compoundterm newargument assign struct argnum structure newargument assign list argnum listcell newargument assign general performs task setarg makes assumptions type compoundterm assign general decrements argnum compensate missing functor field list cell unlike setarg code synthesis time passed body goal represent list cell positional parameter pos decremented synthesizer appears transformed code primitive detailed type information unavailable list standard cell reach destructive assignment point memory cells structures standard memory layout destructively modified assign struct predicate performs tag checking modifies word offset argnum structure lastly assign list modify list cells performs tag checking modifies word offset argnum listcell case assign general assign list decrement positional parameter adjustment performed code synthesizer elimination run time tag checks run time decrements transformed code execute faster expense greater dependence underlying representation memory cells destructive assignment mechanisms presented require consisting memory cell positional parameter representing field number adjusted offset sufficient access underlying memory representation mechanisms condense single parameter information convey location field destructively updated passing cell base offset pass single direct pointer interior cell clause pass body goal obtains proper memory cell increments points directly proper field cell tag free variable passes pointer point destructive assignment offset assign primitive performs simple assignment memory transformed program contained code foo bar bar pos setarg pos increment-before-call scheme eliminate positional arguments transformed code foo increment pointer bar pointer bar assign increment primitive sets pointer point interior offset words increment scheme performing assignments falling trap ctgc performing additional work anticipation destructive assignment performed close scrutiny compiled truth increment primitive exists collection primitives form type type list struct varies reasonable maximum anticipated offset artifact manner primitives added aquarius berkeley abstract machine macros hard wiring constant significantly efficient bam code produced code approach reveals increment primitive executed single register-to-register add operation transfer type load positional argument argument register call add operation takes cycle increment result net slowdown calling end anticipate point destructive assignment extremely simple assign primitive execute rapidly setarg assign reducing arity transformed predicates reduce register pressure facilitating optimizations empirical data follow reveal significant speed differences conjecture setarg generality slowest destructive assigner assign faster fastest performance obtained increment assign empirical evaluation implementation issues difficult resolve confidence real demonstrable variations execution speed found section examines results timing collection benchmarks conditions proposed section cases code tested generated prototype uip code synthesizer directly source augmented special guiding directives detailed appendix subsections follow present choice implementation options comparative timings code variations uip transformed code primary goal determine choices perform synthesis result fastest code programs benchmarks transformed prototype code synthesizer transformed programs compiled release aquarius prolog compiler analyses optimizations enabled time trials conducted unloaded sparcstation ipc ram running environment benchmark executables standard provided aquarius exception trail increased size executable evoked repeatedly twenty executions complete page faults systemand user-mode execution times reported time summed single execution lowest total reported general times vary twenty trials section informally proposed choices synthesizer options expect produce sparcstation registered trademark sun microsystems code tests follow choice varied held constant expected values specifically unravels minimized unravels performed late input aliasing enabled assignments performed increment assign assignments upper connections late clause bodies subgoal benchmarks benchmark suite chosen illustrate performance transformed programs variety contexts programs benchmark suite fairly simplistic earlier reuse analysis stages uip transformation automated selected programs adequately span relevant issues programs uip optimization effectiveness evaluated append list length appended list length delete single integer located deleted list preceded differing integers insert integer inserted ordered list integers requiring members list skipped finding proper point insertion merge ordered list nonnegative integers merged list odd nonnegative integers resulting list ordered split list integers split member output lists list lists split list heads list tails members tree node added simple binary search tree requiring nodes traversed root leaf appendix full source code benchmarks including reuse directives guide code synthesizer unravels section important implementation issues handling unravels synthesizer attempted predict choices result efficient transformed programs subsections follow evaluate accuracy predictions light empirical data drawn benchmark suite outlined minimized unravels measure impact unravel minimization benchmarks executed timed unravels minimized safely allowed attention paid unravel simplification table presents net execution times time ratio transformed code minimized unsimplifiedbenchmark net time net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds unravels minimized versus simplified times tables adjusted reflect update time constant time required construct original input structures subtracted net times reported seconds ratios quotient net time implementation net time transformed program immediately sees minimizing number complexity unravels significant optimization unravels minimized uip code executes times faster code aggressive simplification fastest benchmark times faster code insert executed ten percent slowly examination synthesized code insert reveals unravel minimization explicit unifications unravels removed transformed program minimization sixteen unifications result appearing single clause extra run 
time work eliminated compile synthesis time average benchmarks executed times faster unravels minimized unravel placement current benchmark suite satisfactorily explore question placement unravels clause bodies affects performance noted earlier distinction at-need earlybenchmark net time net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds unravels clause bodies versus early significant backtracking occurs frequently benchmarks backtrack expects performing unravels significantly improve performance table presents timing data confirm expectation benchmarks executed identically positioning unravels fact benchmarks actual uip code produced identical insert early at-need placement meaningless distinction unravels synthesized code important area future exploration behavior complex benchmarks significant unravels backtrack frequently data presented establish important result code rarely backtracks placement unravels significant safe placement adversely affecting performance input aliasing input aliasing optimization means avoid blocking aquarius determinacy analysis unfortunate removing static structure clause heads aliasing aliasingbenchmark net time net time ratio net time ratio append delete insert merge split table empirical comparison benchmark speeds input arguments aliased versus aliasing confound analysis optimizations determinacy detection permits valuable ignore table timing results benchmarks save tree suffered reduced efficiency input aliasing unable execute inputs required test size benchmarks process test data endure considerable speed reductions benefit aquarius determinacy analysis hardest hit benchmarks tree excepted merge executes ten times slowly code input arguments aliased exceptions slowdown append executed slightly faster aliases aquarius detect determinism benchmarks confirmed fact append compile bam code choice points aliasing contrast benchmarks contained choice points compiled aliasing disabled aliasing enabled reason aquarius retains ability detect determinism append remains unclear destructive assignments heart uip transformation destructive assignment destructive assignment conceptually simple synthesizer options implement operation section discussed issues conjectured resolution affect efficiency transformed programs subsections follow evaluate conjectures performance benchmark suite outlined earlier upper connection placement evaluation impact unravel placement current benchmark suite fully explore issue ideal upper connection placement backtracking occurs expect placing unravels early body effect performance predicted section assignments upper connections absolutely body prevent tail-recursion last-call optimizations table time trial data confirms predictions cases placing upper connections guard goals transformed bodies subgoal affect execution encouraging placing assignments body lead speedups backtracking frequent results verify hinder forward-executing code preliminary investigation performance uip transformed code heavily backtracking environment synthesizer simple effective definition guard goals guards clause defined goals start body lead subcalls compiled code guard write tail early latebenchmark net time net time ratio net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds upper connection assignments clause bodies subgoal versus early versus late late placement rendered split non-viable times listed tests late placement highlight avoid confounding tail-recursion last-call optimization benchmarks append insert tree suffer slowdowns destructive assignments contexts recursive subgoals found benchmark delete potentially suffer clause tail recursion hidden late assignment code path crossed benchmark input data visible reduction speed remaining benchmarks merge split suffer great efficiency losses assignments late merge runs ten times slowly code split complete execution running stack space destructive update method options presented performing destructive assignments members benchmark suite timed results found table empirical data confirms hypothesis setarg generality hampers perna assign assign setargbenchmark net time net time ratio net time ratio net time ratio append delete insert merge split tree table empirical comparison benchmark speeds assignments performed increment assign versus position passing assign versus position passing setarg formance early increments eliminating positional parameter results fastest code benchmarks interest merge split benchmarks assignment intensive performing destructive assignment level recursion merge benchmark setarg barely outpace code split ran considerably slower positional parameter assign allowed programs outstrip implementation respectable distances finally split faster albeit slightly increment assign eliminate positional parameter result extremely encouraging implications applicability uip ill-suited programs destructive assignments performed great frequency uip transformation yields significant improvements code require efficiently implemented set destructive assignment primitives assignment expensive performed setarg result net loss speed uip ctgcbenchmark time ratio standard ratio ratio append delete insert merge split tree table empirical comparison execution times implementation versus standard uip transformed programs versus ctgc transformed programs general results choices made synthesizer implementation issue profound effect speed resulting code table summaries speedups obtained synthesizer options proposed ideal speedup combination synthesizer options cases options conjectured preferable produce fastest transformed programs anomalies append suffer reductions speed input argument aliasing disabled table includes time ratios benchmarks transformed ctgc ctgc timing data reproduced found broadly speaking code synthesizer produce uip transformed programs update data structures times faster implementations peculiarities benchmark react differently choices made synthesizer set options conjectured generally desirable give excellent results predicted extra work performed ctgc transformed programs consistently limits speed benchmarks uip transformed code uipbenchmark net memory net memory ratio append delete insert merge split tree table comparison benchmark memory comsumption implementations versus uip transformed programs counts adjusted reflect memory consumed data structure update constant memory required construct original input structures subtracted net memory usages reported bytes ratios quotient net consumption implementation net time transformed program executes average thirty percent faster ctgc code paramount concern optimizations improve execution speed amount memory program requires run important issue aggressively reusing memory programs transformed uip technique consume memory counterparts table compares net memory consumed member benchmark suite reduction memory demonstrated programs transformed uip remarkable implementations consumed process data uip transformed benchmark required additional bytes storage append benchmark reduced memory consumption factor hundred complete execution requiring single additional byte storage conclusions update place transformation potential produce programs run significantly faster implementations uip avoid compile time garbage collection pitfall performing unnecessary extra work preparing destructive assignments performed augmenting prolog language primitives performing high speed backtrackable destructive assignment uip transformation offers promise considerably enhanced performance benchmarks tested execute times faster transformation require vastly memory tests destructive assignment performed great frequency uip transformed programs execute rapidly space implementations earlier explorations uip relied manual translation source programs prototype code synthesizer demonstrates automating transformation process feasible automatically synthesized code perform produced hand important implementation issues arise process prototyping synthesizer empirical evaluation confirmed intuitive notions issues resolved significantly uip transformation care introduces confound optimizations determinacy analysis tail-recursion optimization examination unravel simplification reiterates transformation time analyses minimize amount additional work synthesized code 
finally comparison mechanisms performing destructive assignment highlights tradeoffs speed portability entire uip optimization expressed high level source-to-source translation faster code results assignment primitives sacrifice portability order advantage low level representation details important questions uip transformation remain open investigation foremost challenge choosing reuse memory cells efficiently complex contexts simple benchmarks paper dataflow analysis stage developed immature stages deeply investigated prototype implementations developed automatically apply update place transformation general programs written prolog languages findings paper strong statement effort prove greatly rewarding acknowledgments research funded part national science foundation research experiences undergraduates supplement cise grant cda code synthesizer portability appendix intended informal user guide prototype update place code transformer code synthesizer written portable author knowledge conforms iso draft standard date document printing implementations synthesizer exist tested prolog environments sicstus prolog release compiled sicstus prolog release interpreted aquarius prolog release compiled aquarius prolog release interpreted output synthesizer portable extent additional primitives platforms setarg vehicle performing destructive assignment prolog implementation built execute uip transformed code primitives section implemented berkeley abstract machine macros aquarius compiler invoking synthesizer synthesizer front end interfaces synthesizer compiled free standing executable invoked command line assuming executable named siva siva filenames option settings file names option settings freely interspersed set option affects processing files follow command line overridden details options means set provided appendix filenames fully qualified suffix assumed filename user synthesizer read standard input stream physical file output standard output stream redirected storage physical file user option arguments set default option values simply printed synthesizer interpreted environment called directly prolog code predicates provide simple interface append suffix argument open file resulting transform contents file takes arguments simply reads current input stream transforming receives input file format input files code synthesizer consist standard prolog programs directives cells reused body goals transformed clauses rewritten directives provide needed information predicate reuse directives information entire predicates clause reuse directives describe individual clauses single predicate predicate reuse predicate reuse directive form pred reuse predname inputposns outputposns versions required arguments interpreted predname identifies predicate consists atomic predicate predicate arity separated slash inputposns list positive integers identifying argument positions predicate correspond input arguments list ordered duplicates out-of-range values list empty outputposns list positive integers identifying argument positions predicate correspond output arguments list ordered duplicates out-of-range values list empty outputposns inputposns disjoint include arguments predicate versions list transformed versions predicate synthesizer emit member list atom entry entry version consisting single clause calling conventions original predicate produced list descriptors member outputposns ordered correspond descriptor atom orphan indicating exists output argument pair form inpos type inpos input argument position inputposns child type atoms list term unknown depending type cell pair form stray type indicating input argument child type atoms list term unknown depending type cell predicate reuse directives clause predicate predicates transformed supply predicate reuse directive clause reuse clause reuse directive form clause reuse clausename required arguments interpreted clausename identifies clause consists atomic clause clause arity sequential order clause relation clauses arity subsequently refer clause identified clausename current clause clauses append named append append list pairs paths subterms clause pairs form one-to-one mapping preimages memory cells reused postimages structures composed reusing cells format paths list pairs describing body goals formed argument pair path output argument body goal transformed format paths subsequently refer body goal output argument current subgoal argument pair atom orphan indicating exists output argument term form parentlastnum indicating copied directly head clause transformed parentlastnum member outputposns current clause passed current subgoal term form oldstray parentpath childnum indicating consist childnum field subterm located parentpath stray parent input arguments current subgoal contained memory cell allocated entry current clause term form newstray parentpath childnum interpreted manner oldstray contained memory cell originally appeared static structure current clause term form parentpath childnum inpos indicating consist childnum field subterm located parentpath stray inpos member inputposns current subgoal constructed input argument current subgoal child contained memory cell allocated entry current clause term form parentpath childnum inpos interpreted manner contained memory cell originally appeared static structure current clause clause reuse directives point clause clauses predicates transformed supply clause reuse directive sake efficiency ease manipulation synthesizer expects stores paths lists positive integers stored reverse order term expand head tail path represents child child root head paths rooted principal functor clause clause structured term clauses bodies principal functor head located body consists paths form facts clauses bodies principal functor functor head located path user options code synthesizer supports user options determine implementation issues discussed section resolved code generated options set code synthesis time unravel depth set shallow deep set shallow unravels performed simply rarely trivial redundant unravels removed templates simplified underscores set deep simplifications occur unravels literally default setting shallow unravel placement set late early set late unravels performed goals require executed set early unravels needed performed start transformed clause body default setting early input aliasing set set arguments listed inputposns predicate aliased aid determinacy analysis set inputposns empty list aliasing performed default setting assign placement set tail early late set tail assignments upper connections immediately body goal transformed clause set early upper connections start transformed bodies simple opening goals serve guards set late upper connections body goal transformed clause default setting tail assign method set increment setarg assign set increment increment assign primitives set setarg setarg primitive set assign assign primitives default setting increment mechanisms exist modifying settings user options synthesizer invoked command line option names values simply listed file names invocation siva unravel depth deep foo note contrary unix conventions option names preceded dash conflicts sicstus option handling library options set directly input file synthesizer directive form siva option set named user option reunix registered trademark unix system laboratories quested lastly synthesizer interpreter environment evaluating goal siva option perform function set options affect synthesis files follow option set directives midst input file settings affect code synthesis file subsequent files time values single synthesis option applied individual clauses file limitations synthesizer intermediate representation requires augmenting clauses pseudo-goals goals present original clause synthesizer behavior ill determined synthesizer hold entire source code memory size program transformed limited amount memory allocated synthesizer predicate clause reuse directives checked verify reasonable errors present 
reuse directives synthesizer produce unexpected code fail option settings affect entire files time varied individual clauses predicates share single file benchmark source code complete source code members benchmark suite presented section fed code synthesizer additional directives follow format appendix generate code reuse directives simply stripped remaining clauses compile directly append insert element element insert element head tail element head tail element head insert element head tail head newtail element head insert element tail newtail pred reuse insert entry orphan list clause reuse insert clause reuse insert clause reuse insert delete delete delete oldtail newtail delete oldtail newtail delete oldtail newtail delete oldtail newtail pred reuse delete entry orphan list stray list clause reuse delete clause reuse delete clause reuse delete insert insert element element insert element head tail element head tail element head insert element head tail head newtail element head insert element tail newtail pred reuse insert entry orphan list clause reuse insert clause reuse insert clause reuse insert merge merge head tail head tail head newtail head head merge tail head tail newtail merge head tail head tail head newtail head head merge head tail tail newtail merge head tail head tail merge list list pred reuse merge entry orphan list list clause reuse merge clause reuse merge clause reuse merge clause reuse merge split split split head head split head head tail head tail head tail split tail tail tail pred reuse split entry orphan orphan stray list list clause reuse split clause reuse split clause reuse split oldstray head tail lists head heads tail tails lists heads tails pred reuse entry orphan orphan stray list list clause reuse clause reuse oldstray tree tree insert elem tree node left tree node newleft elem node tree insert elem left newleft tree insert elem tree node left tree node left newright elem node tree insert elem newright tree insert elem leaf tree elem leaf leaf pred reuse tree insert entry orphan term clause reuse tree insert clause reuse tree insert clause reuse tree insert burton gudjonsson winsborough algorithm computing alternating closure technical report cs- pennsylvania state department computer science june foster winsborough copy avoidance compile-time analysis local reuse proceedings international logic programming symposium mit press mulkers winsborough bruynooghe analysis shared data structures compile-time garbage collection logic programs proceedings seventh international conference logic programming mit press sundararajan sastry tick variable threadedness analysis concurrent logic programs proceedings joint international conference symposium logic programming mit press codish dams yardeni derivation safety abstract unification algorithm groundness aliasing analysis proceedings eighth international conference logic programming furukawa mit press debray copy avoidance single assignment languages tenth international conference logic programming mit press duvvuru sundararajan tick sastry hansen zhong compiletime memory-reuse scheme concurrent logic programs international workshop memory management lncs springer-verlag mari janssens mulkers bruynooghe impact abstract interpretation experiment code generation proceedings sixth international conference logic programming levi martelli eds mit press gudjonsson winsborough update place overview siva project submitted conference gudjonsson transforming prolog predicates perform update place unpublished technical notes carlsson widen sicstus prolog user manual swedish institute computer science kista sweden march haygood aquarius prolog user manual advanced computer architecture laboratory los angeles september schimpf setarg sepia eclipse personal communication april van roy logic programming execute fast imperative programming phd thesis california berkeley december sun microsystems programming utilities sun workstation groves transforming prolog predicates perform update place master thesis pennsylvania state department computer science programming language prolog committee draft standard iso work item jtc april 
