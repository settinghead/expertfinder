complexity join predicates jin-yi cai venkatesan chakaravarthy raghav kaushik jeffrey naughton dept computer sciences wisconsin madison fjyc venkat raghav naughtong wisc abstract complexity join problems focusing equijoins spatial-overlap joins set-containment joins graph pebbling model characterize joins combinatorially length optimal pebbling strategies computationally complexity discovering strategies results show equijoins easiest joins optimal pebbling strategies meet lower bound join problems found linear time contrast spatial-overlap set-containment joins hardest joins instances optimal pebbling strategies reach upper bound join problems problem discovering optimal pebbling strategies np-complete set-containment joins show discovering optimal pebbling max-snp-complete consequence show constant problem approximated factor polynomial time results shed light culty applied community nding good algorithms spatial-overlap set-containment joins introduction join operation received great deal attention database researchers database system implementers recall relational algebra join operation expressed join selection predicate cross product relations studied common join equijoin join predicate equality recently advent dbmss extensible type systems research turned joins supported part nsf grant ccr guggenheim fellowship ysupported nsf grant ccr classes join predicates including spatial overlap joins set containment joins paper intrinsically harder joins classes join predicates motivation work growing intuition spatial overlap set containment joins harder equijoins equijoins number recognized good algorithms including index nested loops sort-merge join hash-join algorithms rst proposed subsequent research focussed optimizations algorithms algorithms turn spatial overlap joins set containment joins situation erent number algorithms joins level satisfying equijoin algorithms requiring replication data repeated processing data spatial join set-containment joins considered solved problems super cial perspective joins harder complicated goal make statement precise formally provable turns simple problem joins erent classes join predicates surprisingly rich structure goal devise algorithms problems results shed light problems community devising good algorithms spatial overlap set-containment joins compare culty erent join predicates model fundamental operations join computation pebbling game analyze pebbling game results show equijoins easiest joins combinatorially computationally optimal pebbling strategies meet lower bound join problems found linear time contrast show spatial-overlap set-containment joins hardest joins instances optimal pebbling strategies reach upper bound join problems problem discovering optimal pebbling strategies np-complete set-containment joins show discovering optimal pebbling max-snp-complete consequence show constant problem approximated factor polynomial time pebble game model paper simplicity assume relations single column joins column relations allowed multi-sets join problems ned relations join predicate generate pairs tuples holds simplest join equijoin equijoins relational systems extremely well-studied problem good overview equijoins domain supports equality traditional relational systems domains character strings avor numeric type recently advent object-relational dbms researchers begun developers begun implementing domains types types include spatial types elements domain typically polygons coordinate system set-valued types elements domain sets domains researchers begun investigating algorithms support join predicates spatial domains common join considered polygon overlap polygon overlaps polygon set-valued domains common predicate considered set-containment goal study join problems speci algorithms evaluation abstract model join computation independent algorithm work model instance join problem bipartite graph vertex tuple vertex tuple vertices connected edge tuples join join predicate call join graph instance pair tuples joins join algorithm pair tuples point time execution produce result tuple model stating join algorithm places pebble vertex corresponds join graph removes edge performing join modeled sequence moves pebbles join graph purpose delete edges simple abstract model model costs join algorithm merge phase sort-merge join sense resemble pebbling game intentional recall goal explore erences intrinsic culty join problems explore performance speci algorithms pebbling game bipartite graph partitions pebbles nodes graph nition applies general graphs start pebbles graph pebbles incident vertices edge edge deleted single move pebbles moved node pebbling scheme sequence moves deletes edges denote pebbling scheme sequence pebbling con gurations pair nodes pebbling game deals edge set remove priori isolated vertices assume henceforth paper singletons input size problem number edges number tuples produced join results expressed terms output size related work similar pebbling game considered nodes graph disk pages tuples pebbling cost capture cost scheduling page fetches speci layout disk pages main result paper problem nding optimal pebbling scheme np-complete shown nding optimal pebbling scheme spatial joins np-complete context scheduling page-fetches speci layout disk pages results imply theorem work ers approach notion inherent complexity join predicate focus problem scheduling pagefetches upper lower bounds length optimal pebbling sequences model investigate complexity erent classes join predicates cost models section describe cost model properties definition bipartite graph pebbling scheme cost number pebble moves added account initial placement pebble optimal pebbling cost denoted formulation problem pebbling game essential input problem edge set graph vertex set secondary isolated vertices removed disconnected pebbling scheme pay cost placing pebble component represents start cost ect intrinsically cost good pebbling scheme definition ective cost pebbling scheme number connected components betti number move edge deleted optimal scheme moves required delete edge lemma graph edges corollary connected graph edges disconnected graph connected components represents essentially separate join problems additivity lemma states gained model lumping problems lemma disjoint union bipartite graphs satis proof easy show optimal pebbling scheme loss generality assume rst edge deleted edge claim pebbling scheme deletes edges deleting edge key observation pair pebbling con gurations distinct takes moves change con guration rst h-edge deleted g-edges deleted rst g-edge deleted h-edges deleted run edges edges modify run disconnected moving edge component takes moves costs cost changing pebbling con guration previous con guration scheme cost g-edges removed h-edge removed proceeding optimal pebbling scheme deletes g-edges moving h-edges additivity lemma lemma rest paper focus connected graphs additivity lemma corollary lemma graph edges definition perfect pebbling scheme number edges lemma matching edges relationship pebble game tsp pebbling scheme moves edge view edges abstract nodes sense traveling salesman path capture intuition notion line graphs line graph graph graph edge represented node nodes adjacent edges share end point proposition connected bipartite graph edges hamiltonian path proof recall perfect pebbling scheme perfect pebbling scheme move deletes edge sequence edges constitutes hamiltonian path conversely hamiltonian path view sequence edges path sequence pebbling con gurations perfect pebbling scheme order generalize proposition imperfect pebbling schemes view weighted complete graph weight nodes set edge completed traveling salesman tour visit node rest paper term tsp tour sequence visits node proposition optimal tsp tour cost omit proof call edges 
weight good edges weight bad tsp tour moves bad edge jump cost tsp tour number nodes number jumps extra cost tour combinatorial bounds pebbling cost examine structure join graphs predicates equijoins spatial overlap joins set containment joins establish combinatorial bounds optimal pebbling cost moving details join graphs erent predicates observe result arbitrary bipartite graph fact proof valid general connected graph bipartite theorem connected bipartite graph number edges proof show tsp tour cost give partition hamiltonian path jeij set nodes loss generality jej connected graphs order hamiltonian path connected connected induced subgraph erence due length tsp tour typically measured rst vertex tour counts rooted depth search dfs tree node children call pair nodes twins leaves share parent twins parent grandparent -free jej exists adjacent loss generality remove edge add dfs tree note repeating procedure obtain tree twins node children nodes descendants including nodes pick lowest level call veri subtree rooted path hamiltonian remove nodes subtree resulting graph connected repeating procedure obtain desired partitioning nodes construction yields algorithm linear size line graph alternative proof theorem linear time algorithm achieve bound lemma connected bipartite graph edges nding pebbling scheme cost linear time equijoins rst equijoins connected component join graph equijoins complete bipartite graph lemma complete bipartite graph edges proof complete bipartite graph vertices side side sequence pebbling con gurations pebbles cost number edges examine optimal pebbling cost join graph equijoin theorem join graph equijoin edges join graph equijoins pebbled perfectly proof pebble moves needed isolated nodes lemma connected component join graph pebbled perfectly theorem lemma set containment joins turn set containment joins joins universal sense lemma bipartite graph instance set containment join problem join graph proof rkg slg instance set containment joins denotes tuple fig denotes tuple join graph instance set containment joins lower upper bounds pebbling cost set containment joins bounds general bipartite graphs shown theorem connected bipartite graph pebbled times number edges hand bipartite graphs require bound show theorem family bipartite graphs graph proof family bipartite graphs shown fig general built similarly graph family theorem show proving line graph viewed complete weighted graph tsp tour cost line graph shown figure general extra nodes degree connected nodes fashion tsp tour fnodes entered bad edgeg fnodes left bad edgeg tsp tour cost vertices degree tsp tour enter exit leaves bad edge rst node tour total cost tour noted worst case bipartite graph realized set containment join note graph join graph equijoin complete bipartite graph unlike equijoins perfect pebbling scheme instances set-containment joins optimal algorithm produce pebbling scheme irrespective computational complexity yields pebbling cost times number edges spatial overlap joins turn spatial overlap joins upper bound result general join graphs spatial join graph pebbled times number edges turns instance spatial join join graph worst case behavior spatial overlap joins inherently cult equijoins purely combinatorial metric lemma family instances spatial overlap join problem join graphs shown fig family graphs line graph figure lower bound finding optimal pebbling scheme proceed classify join predicates consideration computational complexity nding optimal pebbling scheme definition pebble problem bipartite graph optimal pebbling scheme -approximation problem approximation factor decision version pebble integer decide theorem pebble solved linear time equijoin graphs observe construction theorem similar merge phase sort-merge join general join graph pebble turns hard easier input graph join graph spatial overlap join theorem pebble np-complete pebble remains np-complete input graph spatial overlap join graph rst part theorem directly motivation erent investigating scheduling page reads joins computing joins individual tuples erent classes join predicates authors considered scheduling page reads case assumed pages rectangles partitioning coordinate system special case spatial overlap join result implies part preceding theorem question arises approximation algorithms pebble constant factor polynomial time lemma linear time approximation algorithm nds pebbling scheme factor optimal work approximate note algorithm papadimitriou yannakakis approximate pebble factor approximation problem polynomial time approximation scheme ptas polynomial time algorithm constant polynomial problem instance nds approximate solution problem minimization problems optimal solution time jxj note np-hardness imply existence non-existence ptas assuming complexity class max-snp ned papadimitriou yannakakis technically involved problem max-snp max-snpcomplete problem max-snp reducible l-reduction problem l-reducible problem ptas ptas possess ptas pcp theory proves max-snp-complete problem ptas assuming show pebble max-snp-complete membership max-snp pebble shown directly noticing pebble constant factor approximation algorithm problems imply membership max-snp l-reduction basically reduction preserves approximability definition optimization problems l-reduction pair functions computable polynomial time exist constants instance problem instance opt opt opt denotes optimal cost feasible solution feasible solution jopt cost jopt cost proof max-snp-completeness pebble reduction max-snp-complete problem tspbe problem nding optimal traveling salesman tour complete graph edge weights tsp-k problem node graph incident edges weight ham-path-k hamiltonian path problem graphs bounded degree tspis max-snp-complete rst give l-reduction tspto tspthen give l-reduction tspto pebble line graphs theorem tspis max-snp-complete proof tspwas shown max-snpcomplete l-reduce problem tspham- pathis shown np-complete giving reduction ham-pathin gadget shown fig gadget l-reduction call gadget diamond call nodes corner nodes central nodes notice diamond hamiltonian path exists corner nodes hamiltonian path diamond start end corner nodes figure gadget show tspis maxsnp-complete input graph degree bounded obtain graph replacing node degree diamond connecting edges corner call diamond rst show opt opt optimal tsp tour prove bound exhibiting tour bound replace node degree suitable hamiltonian path corner corner diamond distinct corners chosen node good edge corner choose corners chosen similarly easy extra cost number jumps number nodes number nodes opt opt exhibit reduction tsp tour produces tsp tour preserving approximability call nice respect node tour visits nodes diamond consecutively tour called nice nice respect node show converted nice tour increasing cost arbitrary node degree convert tour nice respect procedure denote segment nodes segment du-segment nodes segment called perfect edge good entered left good edges procedure considers du-segments chooses segment perfect du-segment chosen chosen chosen arbitrarily entry exit points node appearing appearing distinct corner points chosen replaced hamiltonian path procedure sets corner point corner point chosen arbitrarily du-segments removed modi tour nice respect chosen segment perfect case extra cost segment extra cost extra cost incurred bypassing deleted du-segments perfect du-segments perfect bypassing increase extra cost case perfect perfect du-segment 
assume exists bypassing add additional jump examining gadget perfect segments cover nodes gadget du-segment perfect perfect corner points entered exited jumps bypassing saves jumps compensates potentially additional jump incurred bypassing du-segments imperfect removing add additional jump case left considered perfect perfect du-segment bypassing imperfect segments add extra jumps nice tour respect node repeating process nodes nice tour obtain tour visiting nodes order diamonds easy extra cost l-reduction result independent interest theory ham-pathis np-complete theorem shows tsp version problem maxsnp-complete improving result tspis maxsnp-complete theorem pebble max-snp-complete proof problem max-snp constant factor approximation algorithm theorem approximation algorithm l-reduce tspto pebble reduction concepts tspgraph outputs incidence graph bipartite graph node joined node edge end points claim satis rst property l-reductions line graph observe obtained directly replacing vertex degree clique vertices edges connected vertices clique note optimal tour length obtain tour length tour translated equally good pebbling strategy proposition satis property pebbling strategy rst translated equally good tsp tour tour converted tour process similar theorem corollary tspfor line graphs maxsnp complete consequence max-snp-completeness pebble pcp theory assuming absolute constant polynomial time approximation algorithm pebble stronger statement non-existence ptas conclusion development join algorithms studied problems database systems research date published intrinsic culty join problems joins easy join computed polynomial time compute cross product iterate result applying join predicate tuple cross product true coarse-grained analysis belies experience researchers good algorithms join problems shown paper digs combinatorial complexity joins resulting optimization problems nds surprisingly rich structure structure con rms experience community developing implementing join algorithms equijoins easier spatial overlap joins set-containment joins number interesting problems remain intriguing join algorithms practice work rst mapping input relations join investigating subset joins explore parallelism make main memory today memory sizes reason important natural hard optimal mapping tuples classes joins paper equijoins spatial overlap set containment problem np-complete conjecture problem equijoins good approximation algorithms arora lund motwani sudan szegedy proof veri cation hardness approximation problems annual symposium foundations computer science pages graefe query evaluation techniques large databases acm computing surveys unther cient computation spatial joins proceedings ninth international conference data engineering pages harary graph theory addison-wesley helmer moerkotte evaluation main memory join algorithms joins set comparison join predicates vldb proceedings international conference large data bases pages merrett kambayashi yasuura scheduling page-fetches join operations large data bases international conference proceedings pages neyer widmayer singularities make spatial join scheduling hard international symposium algorithms computation isaac international symposium proceedings pages orenstein spatial query processing object-oriented database system proceedings acm sigmod international conference management data pages papadimitriou computational complexity addison-wesley papadimitriou steiglitz combinatorial optimization algorithms complexity prentice hall papadimitriou yannakakis optimization approximation complexity classes extended abstract proceedings twentieth annual acm symposium theory computing pages papadimitriou yannakakis travelling salesman problem distances mathematics operations research pages patel dewitt partition based spatial-merge join proceedings acm sigmod international conference management data pages ramasamy patel naughton kaushik set containment joins good bad ugly vldb proceedings international conference large data bases pages stonebraker object relational dbms great wave morgan kaufmann 
