home page prof thomas reps nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page reps contact nbsp information biography teaching research projects research summary past research recent items note updated categorized index disclaimer list books journal invited papers book chapters reprinted collections edited books magazine articles conference patents pending submissions reports software visitors post-doctoral associates students professional activities dept nbsp home page nbsp thomas reps professor computer sciences department wisconsin-madison west dayton street madison usa contact information e-mail reps wisc telephone secretary department finger information maps campus map campus-to-capitol map city map cornell biography research summary past research research interests program slicing differencing merging interprocedural dataflow analysis alias analysis pointer analysis shape analysis program-analysis problems path problems model checking computer security code instrumentation computational differentiation computational divided differencing language-based program-development environments incremental computing attribute grammars miscellaneous citeseer google scholar projects wisconsin program-slicing project wisconsin safety analyzer project cmu-uw software model checking project table contents research summary recent items note updated aug categorized index disclaimer list books journal invited papers book chapters reprinted collections edited books magazine articles conference patents pending submissions reports software visitors post-doctoral associates students recent items note recent papers divine discovering variables executables shape analysis uniform change refinement-based program verification three-valued-logic analysis extracting output formats executables wysinwyx execute automatic verification strongly dynamic software systems reducing dependence spki sdsi pki automated verification deutsch-schorr-waite tree-traversal algorithm recency-abstraction heap-allocated storage lookahead widening improving pushdown system model checking weighted pushdown systems trust-management systems verifying concurrent message-passing programs recursive calls recovery low-level code next-generation platform analyzing executables relational abstraction functions simulating reachability first-order logic applications verification linked data structures model checking executables codesurfer wpds extended weighted pushdown systems abstraction refinement inductive learning utility canonical abstraction weighted pushdown systems application interprocedural dataflow analysis codesurfer platform analyzing executables automatic discovery api-level exploits numeric analysis array operations semantics procedure local heaps abstractions back top miscellaneous paper horwitz reps binkley interprocedural slicing dependence graphs proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july abstract selected inclusion special sigplan collection influential papers sigplan conference programming language design implementation horwitz reps binkley interprocedural slicing dependence graphs years acm sigplan conference programming language design implementation selection mckinley acm sigplan notices april retrospective paper published horwitz reps binkley retrospective interprocedural slicing dependence graphs years acm sigplan conference programming language design implementation selection mckinley acm sigplan notices april retrospective retrospective pdf extended version pldi paper appeared journal paper horwitz reps binkley interprocedural slicing dependence graphs acm transactions programming languages systems january abstract paper back top availability program-slicing tools wisconsin program-slicing tool wisconsin program-slicing tool software system supports operations programs including backward slicing forward slicing chopping toplas fse fse user gain understanding program works wisconsin program-slicing tool consists package building manipulating control-flow graphs program dependence graphs front-end parses programs translates internal representations slicing wisconsin program-slicing tool wisconsin program-slicing tool manual man page batch version wisconsin program-slicing tool wisconsin program-slicing tool distributed not-for-profit research purposes license wisconsin longer distributed commercial tool named codesurfer derived wisconsin implementation grammatech grammatech improved wisconsin implementation considerably terms speed space efficiency grammatech codesurfer academic researchers favorable terms codesurfer wisconsin program-slicing technology commercial product codesurfer tool grammatech codesurfer builds dependence-graph program representation gui exploring web dependence graph includes forward backward links assignment statement values stored assignment pointer analysis indirect loads stores pointers account indirect function calls dataflow analysis links unrelated assignments excluded operations highlight forward backward slices show impact statement rest program forward slicing impact rest program statement backward slicing toplas fse operations highlight paths nodes dependence graph chops show ways program points interdependent independent fse codesurfer scripting language access dependence-graph program representation widget set extensibility batch applications full information codesurfer find full documentation whitepapers pricing information information academic researchers aware important current limitations codesurfer language full support alpha support program length sloc codesurfer windows windows windows linux solaris back top categorized index program slicing differencing merging overview program analysis graph reachability ist program analysis graph reachability trand program analysis graph reachability ilps program dependence graphs software engineering wisconsin program-slicing tool wisconsin program-slicing tool license wisconsin program-slicing tool wisconsin program-slicing tool manual man page batch version wisconsin program-slicing tool codesurfer system short description codesurfer system codesurfer web page slicing program specialization program slicing speeding slicing interprocedural slicing computer programs dependence graphs multi-procedure program integration efficient comparison program slices interprocedural slicing dependence graphs toplas interprocedural slicing dependence graphs pldi chopping precise interprocedural chopping differencing identifying semantic differences programs procedures algorithm semantics-based program integration merging program integration languages procedure calls program integration algorithm accommodates semantics-preserving transformations tosem program integration algorithm accommodates semantics-preserving transformations sigsoft multi-procedure program integration algorithm semantics-based program integration illustrating interference interfering versions programs integrating non-interfering versions programs toplas integrating non-interfering versions programs popl semantics-based program integration support integrating program variants environment programming large algebra slices applications program merging programs algebraic properties program integration scp algebraic properties program integration esop theory program modifications modification algebras semantics slicing semantics program representation graphs semantics program slicing program integration multi-procedure equivalence theorem adequacy program dependence graphs representing programs applications slicing program slicing hardware description languages program slicing design automation partial evaluation dependence graphs program specialization program slicing semantic foundations binding-time analysis imperative programs implemented integration system small pascal subset wisconsin program-integration system wisconsin program-integration system manual release demonstration prototype tool program integration miscellaneous undecidability context-sensitive data-dependence analysis correctness algorithm reconstituting program dependence graph dissertations partial evaluation dependence graphs multi-procedure program integration algorithm semantics-based program integration dependence-based representations programs variables back top interprocedural dataflow analysis demand idfa bottom-up logic programming magic-sets transformation demand interprocedural program analysis logic databases solving demand versions interprocedural analysis problems exhaustive demand idfa graph reachability program analysis graph reachability ist program analysis 
graph reachability trand program analysis graph reachability ilps demand interprocedural dataflow analysis tralso demand interprocedural dataflow analysis fse precise interprocedural dataflow analysis graph reachability interprocedural dataflow analysis graph reachability idfa graph reachability improving pushdown system model checking extended weighted pushdown systems weighted pushdown systems application interprocedural dataflow analysis scp weighted pushdown systems application interprocedural dataflow analysis sas precise interprocedural 
dataflow analysis applications constant propagation tcs precise interprocedural dataflow analysis applications constant propagation fase ptime completeness idfa sequential nature interprocedural program-analysis problems back top alias analysis pointer analysis shape analysis refinement-based program verification three-valued-logic analysis automated verification deutsch-schorr-waite tree-traversal algorithm recency-abstraction heap-allocated storage automatic verification strongly dynamic software systems relational abstraction functions simulating reachability first-order logic applications verification linked data structures abstraction refinement inductive learning utility canonical abstraction numeric analysis array operations semantics procedure local heaps abstractions relational approach interprocedural shape analysis static program analysis -valued logic verification structure simulation symbolically computing most-precise abstract operations shape analysis verifying temporal heap properties evolution logic finite differencing logical formulas static analysis parametric shape analysis -valued logic putting static analysis work verification case study shape analysis pointer analysis programs structures casting decidable logic describing linked data structures program analysis graph reachability ist program analysis graph reachability trand program analysis graph reachability ilps program specialization program slicing solving shape-analysis problems languages destructive updating toplas solving shape-analysis problems languages destructive updating popl solving shape-analysis problems languages destructive updating trshape analysis generalized path problem dependence-based representations programs variables dependence analysis pointer variables dissertations refinement-based program verification three-valued-logic analysis dependence-based representations programs variables back top program-analysis problems extracting output formats executables lookahead widening numeric domains summarized dimensions symbolic implementation transformer interprocedural express-lane transformation interprocedural path profiling interprocedural express-lane transformation melski thesis typestate checking machine code safety-checking machine code thesis safety checking machine code pldi putting static analysis work verification case study physical type checking paste physical type checking coping type casts fse coping type casts interprocedural path profiling interprocedural path profiling trtechniques software renovation program analysis graph reachability ist program analysis graph reachability trand program analysis graph reachability ilps interconvertibility class set constraints context-free language reachability tcs interconvertibility set constraints context-free language reachability pepm identifying modules concept analysis tse identifying modules concept analysis icsm program profiling software maintenance applications year problem program profiling software testing method troubleshooting data-dependent anomalies computer programs bta termination cfl-reachability program generalization software reuse semantic foundations binding-time analysis imperative programs dissertations safety-checking machine code techniques software renovation partial evaluation dependence graphs back top path problems context-free-language reachability model checking unrestricted hierarchical state machines program analysis graph reachability ist program analysis graph reachability trand program analysis graph reachability ilps interconvertibility class set constraints context-free language reachability tcs interconvertibility set constraints context-free language reachability pepm undecidability context-sensitive data-dependence analysis speeding slicing interprocedural slicing computer programs dependence graphs interprocedural slicing dependence graphs toplas interprocedural slicing dependence graphs pldi demand interprocedural dataflow analysis tralso demand interprocedural dataflow analysis fse precise interprocedural dataflow analysis graph reachability interprocedural dataflow analysis graph reachability sequential nature interprocedural program-analysis problems shape analysis generalized path problem path problems reducing dependence spki sdsi pki improving pushdown system model checking weighted pushdown systems trust-management systems verifying concurrent message-passing programs recursive calls extended weighted pushdown systems weighted pushdown systems application interprocedural dataflow analysis scp weighted pushdown systems application interprocedural dataflow analysis sas interprocedural express-lane transformation generalized authorization problems incremental algorithm generalization shortest-path problem computational complexity dynamic graph problems incremental algorithm maintaining dominator tree reducible flowgraph precise interprocedural dataflow analysis applications constant propagation tcs precise interprocedural dataflow analysis applications constant propagation fase interprocedural path profiling interprocedural path profiling trph dissertations interprocedural path profiling interprocedural express-lane transformation bounded incremental computation multi-procedure program integration back top model checking improving pushdown system model checking weighted pushdown systems trust-management systems verifying concurrent message-passing programs recursive calls model checking executables codesurfer wpds extended weighted pushdown systems weighted pushdown systems application interprocedural dataflow analysis automatic discovery api-level exploits model checking spki sdsi verifying temporal heap properties evolution logic generalized authorization problems analysis spki sdsi certificates model checking model checking unrestricted hierarchical state machines ltl model checking systems unbounded number dynamically created threads objects back top computer security divine discovering variables executables reducing dependence spki sdsi pki weighted pushdown systems trust-management systems recovery low-level code next-generation platform analyzing executables wysinwyx execute model checking executables codesurfer wpds codesurfer platform analyzing executables automatic discovery api-level exploits analyzing memory accesses executables generalized authorization problems model checking spki sdsi typestate checking machine code safety checking machine code pldi dissertations safety-checking machine code thesis back top code instrumentation interprocedural express-lane transformation debugging run-time type checking interprocedural path profiling interprocedural path profiling trnew technology year problem tools program profiling software maintenance applications year problem program profiling software testing dissertations interprocedural path profiling interprocedural express-lane transformation melski thesis back top computational differentiation computational divided differencing algorithmic differencing computational divided differencing divided-difference arithmetics back top language-based program-development environments programming environments synthesizer generator system constructing language-based editors synthesizer generator manual edition language processing program editors remote attribute updating language-based editors synthesizer generator system synthesizer generator psde incremental context-dependent analysis language-based editors optimal-time incremental semantic analysis syntax-directed editors incremental evaluation attribute grammars application syntax-directed editors static-semantic analysis language-based editors cornell program synthesizer syntax-directed programming environment wherefore cornell program synthesizer cornell program synthesizer dissertations techniques software renovation generating language-based environments back top incremental computing finite differencing logical formulas static analysis incremental algorithm generalization shortest-path problem computational complexity dynamic graph problems competitive on-line algorithms dynamic priority-ordering problem incremental computation dynamic algorithms incremental algorithm maintaining dominator tree reducible flowgraph categorized bibliography incremental computation incremental computation synthesizer generator system constructing language-based editors incremental evaluation attribute grammars unrestricted movement tree modifications language processing program editors remote attribute updating language-based editors synthesizer generator system incremental context-dependent analysis language-based editors optimal-time incremental semantic analysis syntax-directed editors incremental evaluation attribute grammars application syntax-directed editors dissertations bounded incremental computation generating language-based environments back top attribute grammars scan grammars parallel attribute evaluation data-parallelism synthesizer generator system constructing language-based editors synthesizer generator manual edition incremental evaluation attribute grammars unrestricted movement tree modifications sublinear-space evaluation algorithms attribute grammars remote attribute updating language-based editors synthesizer generator system synthesizer generator psde interactive proof checking incremental context-dependent analysis language-based editors optimal-time incremental semantic analysis syntax-directed editors incremental evaluation attribute grammars application syntax-directed editors static-semantic analysis language-based editors dissertations generating language-based environments back top miscellaneous maximal-munch tokenization linear time back top disclaimer web page links postscript pdf files articles covered 
copyright browse articles convenience spirit read journal article article conference proceedings public library retrieving copying distributing files violate copyright law note definitive versions papers published versions postscript versions provided courtesy cases differences postscript provided published version differences formatting differences copy-editing cite papers cite published version giving url back top list citeseer google scholar books reps teitelbaum synthesizer generator system constructing language-based editors springer-verlag york abstract reps teitelbaum synthesizer generator manual edition springer-verlag york chinese reprint published world publishing corporation beijing china reps generating language-based environments press cambridge awarded acm doctoral dissertation award abstract back top journal yorsh reps sagiv wilhelm logical characterizations heap abstractions acm thomas transactions reps computational logic jan abstract biography postscript nbsp nbsp pdf yahav reps nbsp sagiv wilhelm verifying temporal search heap nbsp properties nbsp evolution nbsp logic logic journal nbsp computer igpl science home oct page abstract pdf reps schwoon reps jha contact nbsp melski weighted pushdown systems information application biography interprocedural dataflow teaching analysis science computer research programming projects oct research abstract summary past postscript research recent pdf items alur note benedikt etessami godefroid updated reps categorized index yannakakis analysis recursive state machines acm disclaimer trans list program lang syst books journal jha reps model invited checking spki sdsi papers book journal computer chapters security reprinted abstract collections edited pdf anderson books reps magazine teitelbaum articles design conference implementation fine-grained software inspection tool patents pending ieee trans software submissions engineering aug abstract paper reports ieee explore software reps visitors post-doctoral rall associates computational divided differencing students divided-difference professional arithmetics activities higher-order symbolic computation dept nbsp home abstract tech report version postscript pdf page talk powerpoint clarke fujita nbsp rajan thomas reps reps shankar professor computer teitelbaum sciences program department slicing vhdl software wisconsin-madison tools west dayton technology street transfer madison oct abstract paper sagiv usa reps thomas reps wilhelm professor parametric shape computer analysis science -valued computer logic sciences acm department transactions programming languages wisconsin joined systems reps abstract author postscript co-author pdf talk books powerpoint reps hundred papers undecidability describing research http wisc reps context-sensitive data-dependence work analysis concerned acm wide transactions variety programming topics languages including program slicing systems dataflow jan analysis pointer analysis model checking computer security code instrumentation abstract language-based postscript program-development pdf environments melski program reps profiling software interconvertibility testing class software set renovation constraints incremental algorithms context-free language attribute reachability grammars theoretical click computer summary science recent nov research activities abstract postscript summary pdf siff past research reps activities identifying modules concept analysis collaboration ieee transactions professor tim software teitelbaum engineering cornell nov dec led abstract creation paper ieee systems explore cornell reps program synthesizer program analysis synthesizer graph generator reachability information explored software build technology interactive programming november tools december incorporate knowledge abstract programming tech language report version supported reps paper postscript president pdf grammatech talk powerpoint reps teitelbaum founded maximal-munch tokenization commercialize linear time work acm transactions professor reps programming languages co-leader systems professor susan march horwitz research abstract group postscript pdf sagiv wisconsin reps carried wilhelm investigations solving program shape-analysis slicing problems languages applications destructive software updating engineering acm transactions recent work programming concerns languages program analysis systems computer security january software model abstract checking postscript reps pdf served sagiv reps consultant darpa horwitz precise plan interprocedural project aimed dataflow analysis reducing applications impact constant year propagation problem theoretical computer department science defense abstract served paper reps avionics advisory sequential team nature provided interprocedural advice program-analysis problems department acta informatica abstract paper ramalingam reps incremental algorithm generalization shortest-path problem journal algorithms abstract paper ramalingam reps defense computational complexity problems dynamic uncovered graph integration problems testing theoretical computer plane science avionics software professor reps abstract received paper binkley computer science horwitz cornell reps program integration dissertation languages won procedure acm calls doctoral acm dissertation transactions award reps software engineering paper interprocedural methodology slicing january susan horwitz then-student david binkley abstract selected paper ramalingam influential papers reps acm competitive sigplan on-line conference algorithms programming dynamic language priority-ordering design problem implementation information processing pldi letters paper analysis abstract paper yang horwitz reps program integration algorithm accommodates semantics-preserving transformations acm transactions software engineering methodology july abstract reps algebraic properties program integration science computer programming abstract paper horwitz assembly reps code efficient student comparison gogul balakrishnan program received slices eapls acta best-paper award etaps informatica reps abstract horwitz recognized reps highly binkley cited interprocedural slicing dependence researcher graphs acm transactions field computer programming science languages worldwide received systems recognition january institute scientific information reps recipient nsf presidential abstract young investigator paper award horwitz packard fellowship prins humboldt research reps award guggenheim integrating fellowship non-interfering reps versions acm fellow programs reps acm transactions held visiting programming positions languages institut systems national recherche july informatique abstract automatique paper inria reps rocquencourt incremental evaluation france attribute grammars copenhagen unrestricted movement denmark tree modifications consiglio acta nazionale delle ricerche informatica pisa italy abstract reps demers sublinear-space evaluation algorithms nbsp attribute computer grammars acm sciences transactions programming languages systems home july feedback abstract content paper questions acm send digital reps library reps wisc teitelbaum server demers technical incremental accessibility context-dependent issues analysis lab wisc language-based editors acm transactions copyright programming languages copy board systems regents july abstract wisconsin paper acm system digital 
library teitelbaum reps cornell program synthesizer syntax-directed programming environment communications acm september abstract paper acm digital library back top invited papers balakrishnan reps divine discovering variables executables proc vmcai nice france jan abstract pdf springer-verlag jha schwoon wang reps weighted pushdown systems trust-management systems proc tacas vienna austria mar apr springer-verlag york abstract pdf springer-verlag reps balakrishnan lim recovery low-level code proc workshop partial evaluation program manipulation pepm charleston jan abstract postscript pdf reps balakrishnan lim teitelbaum next-generation platform analyzing executables proc asian symposium programming languages systems tsukuba japan nov springer-verlag york abstract postscript pdf springer-verlag reps sagiv wilhelm static program analysis -valued logic proc int conf computer-aided verification springer-verlag york abstract postscript pdf springer-verlag talk powerpoint rall reps algorithmic differencing perspectives enclosure methods kulisch lohner faciush eds springer-verlag vienna invited paper presented scan gamm-imacs int symp sci comput comp arith validated numerics karlsruhe ger sept abstract wilhelm sagiv reps shape analysis proc int conf compiler construction berlin ger mar apr abstract postscript pdf springer-verlag reps program analysis graph reachability proc ilps international logic programming symposium port jefferson oct maluszynski press cambridge abstract paper springer-verlag reps program profiling software testing proc informatik aachen germany sept jarke pasedach pohl eds springer-verlag berlin ger abstract paper springer-verlag horwitz reps program dependence graphs software engineering proceedings fourteenth international conference software engineering melbourne australia acm york abstract paper reps horwitz semantics-based program integration proceedings european symposium programming nancy france march lecture notes computer science vol ganzinger springer-verlag york back top book chapters sagiv reps wilhelm yahav utility canonical abstraction engineering theories software intensive systems broy gruenbauer hoare harel eds kluwer academic publishers dordrecht netherlands reps sagiv wilhelm shape analysis applications compiler design handbook optimizations machine code generation crc press reps demand interprocedural program analysis logic databases applications logic databases ramakrishnan kluwer academic publishers boston abstract paper back top reprinted collections reps balakrishnan lim teitelbaum next-generation platform analyzing executables malware detection advances information security series springer-verlag reprinted proc asian symposium programming languages systems tsukuba japan nov horwitz reps binkley interprocedural slicing dependence graphs years acm sigplan conference programming language design implementation selection mckinley acm sigplan notices april abstract reprinted proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july retrospective paper published horwitz reps binkley retrospective interprocedural slicing dependence graphs years acm sigplan conference programming language design implementation selection mckinley acm sigplan notices april retrospective retrospective pdf horwitz reps binkley interprocedural slicing dependence graphs software change impact analysis bohner arnold eds ieee computer society los alamitos reprinted acm transactions programming languages systems january abstract paper horwitz reps binkley interprocedural slicing dependence graphs software merging slicing berzins ieee computer society los alamitos reprinted acm transactions programming languages systems january abstract paper horwitz prins reps integrating non-interfering versions programs software merging slicing berzins ieee computer society los alamitos reprinted acm transactions programming languages systems 
july abstract paper ramalingam reps theory program modifications software merging slicing berzins ieee computer society los alamitos reprinted proceedings colloquium combining paradigms software development brighton april lecture notes computer science vol abramsky maibaum eds springer-verlag york reps teitelbaum language processing program editors language architectures programming environments ichikawa tsubotani eds world scientific publishing company singapore reprinted ieee computer november teitelbaum reps cornell program synthesizer syntax-directed programming environment interactive programming environments barstow sandewall shrobe eds mcgraw-hill reprinted communications acm september abstract paper acm digital library teitelbaum reps horwitz wherefore cornell program synthesizer software development environments wasserman ieee computer society washington reprinted proceedings acm sigplan sigoa symposium text manipulation portland june acm sigplan notices june back top edited books program analysis compilation theory practice essays dedicated reinhard wilhelm reps sagiv bauer eds lecture notes computer science vol springer-verlag back table contents magazine articles anderson reps teitelbaum zarins tool support fine-grained software inspection ieee software abstract paper ieee explore reps teitelbaum language processing program editors ieee computer november back top conference lal kidd reps touili abstract error projection proc static analysis symposium gopan reps guided static analysis proc static analysis symposium lev-ami weidenbach reps sagiv labelled clauses proc conference automated deduction gopan reps low-level library analysis summarization proc computer-aided verification amit rinetzky reps sagiv yahav comparison abstraction verifying linearizability proc computer-aided verification bogudlov lev-ami reps sagiv revamping tvla making parametric shape analysis competitive tool paper proc computer-aided verification loginov reps sagiv refinement-based verification possibly-cyclic lists program analysis compilation theory practice essays dedicated reinhard wilhelm springer-verlag balakrishnan reps melski teitelbaum wysinwyx execute verified software theories tools experiments springer-verlag abstract postscript pdf dor field gopan lev-ami loginov manevich ramalingam reps rinetzky sagiv wilhelm yahav yorsh automatic verification strongly dynamic software systems verified software theories tools experiments springer-verlag abstract postscript pdf lev-ami sagiv immerman reps shape analysis uniform change proc vmcai nice france jan abstract pdf springer-verlag lim reps liblit extracting output formats executables proc ieee working conference reverse engineering benevento italy oct abstract pdf talk powerpoint wang jha reps schwoon stubblebine reducing dependence spki sdsi pki european symposium research computer security esorics abstract pdf springer-verlag loginov reps sagiv automated verification deutsch-schorr-waite tree-traversal algorithm static analysis symposium abstract pdf springer-verlag balakrishnan reps recency-abstraction heap-allocated storage static analysis symposium abstract pdf springer-verlag lal reps improving pushdown system model checking computer-aided verification abstract pdf springer-verlag gopan reps lookahead widening computer-aided verification abstract pdf springer-verlag chaki clarke kidd reps touili verifying concurrent message-passing programs recursive calls proc tacas springer-verlag york abstract postscript pdf springer-verlag talk powerpoint jeannet gopan reps relational abstraction functions proc int static analysis symp abstract postscript pdf springer-verlag lev-ami immerman reps sagiv srivastava yorsh simulating reachability first-order logic applications verification linked data structures proc conf automated deduction abstract postscript pdf springer-verlag talk powerpoint balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds tool-demonstration paper proc computer-aided verification abstract postscript pdf springer-verlag lal balakrishnan reps extended weighted pushdown systems proc computer-aided verification abstract postscript pdf springer-verlag loginov reps sagiv abstraction refinement inductive learning proc computer-aided verification abstract postscript pdf springer-verlag ganapathy seshia jha reps bryant automatic discovery api-level exploits proc int conf software engineering louis missouri abstract postscript pdf balakrishnan gruian reps teitelbaum codesurfer platform analyzing executables tool demonstration paper proc int conf compiler construction april abstract postscript pdf springer-verlag jeannet gopan reps relational abstraction functions int workshop numerical symbolic abstract domains jan abstract postscript pdf yorsh skidanov reps sagiv assume guarantee reasoning heap-manipulating programs proc int workshop abstract interpretation object-oriented languages electronic notes theoretical computer science abstract postscript pdf gopan reps sagiv numeric analysis array operations conference record thirty-second acm symposium principles programming languages long beach jan abstract postscript pdf rinetzky bauer reps sagiv wilhelm semantics procedure local heaps abstractions conference record thirty-second acm symposium principles programming languages long beach jan abstract pdf immerman rabinovich reps sagiv yorsh boundary decidability undecidability transitive closure logics proc computer science logic lecture notes computer science springer-verlag york abstract jeannet loginov reps sagiv relational approach interprocedural shape analysis proc int static analysis symp lecture notes computer science springer-verlag york abstract postscript pdf springer-verlag immerman rabinovich reps sagiv yorsh verification structure simulation proc int conf computer-aided verification abstract postscript pdf springer-verlag balakrishnan reps analyzing memory accesses executables proc int conf compiler construction springer-verlag york awarded eapls paper award etaps abstract postscript pdf springer-verlag talk powerpoint yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis proc tacas springer-verlag york abstract postscript pdf springer-verlag gopan dimaio dor reps sagiv numeric domains summarized dimensions proc tacas springer-verlag york abstract postscript pdf springer-verlag reps sagiv yorsh symbolic implementation transformer proc vmcai abstract postscript pdf springer-verlag reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis proc int static analysis symp june san diego lecture notes computer science vol springer-verlag york abstract postscript pdf springer-verlag talk powerpoint schwoon jha reps stubblebine generalized authorization problems proc ieee computer security foundations workshop june july asilomar pacific grove abstract postscript pdf talk powerpoint reps sagiv loginov finite differencing logical formulas static analysis proc european symp programming lecture notes computer science vol springer-verlag york abstract postscript pdf springer-verlag yahav reps sagiv wilhelm verifying temporal heap properties evolution logic proc european symp programming lecture notes computer science vol springer-verlag york abstract postscript pdf springer-verlag melski reps interprocedural express-lane transformation proc int conf compiler construction lecture notes computer science vol springer-verlag york abstract postscript pdf springer-verlag reps loginov sagiv semantic minimization -valued propositional formulae proc ieee symp logic computer science copenhagen denmark july abstract postscript pdf talk powerpoint jha reps analysis spki sdsi certificates model checking proc ieee computer security foundations workshop cape breton nova scotia june abstract postscript pdf benedikt godefroid reps model checking unrestricted hierarchical state machines proc icalp twenty-eighth int colloq automata languages programming crete greece july lecture notes computer science vol springer-verlag york abstract postscript pdf springer-verlag loginov yong horwitz reps debugging run-time type checking proc fase fundamental approaches softw eng genoa italy april abstract postscript pdf springer-verlag reps miller typestate checking machine code proc esop european symp programming genoa italy april 
abstract postscript pdf springer-verlag lev-ami reps sagiv wilhelm putting static analysis work verification case study issta proc int symp software testing analysis portland aug abstract postscript pdf miller reps safety checking machine code sigplan proceedings acm conference programming language design implementation vancouver canada june abstract paper chandra reps physical type checking proc paste sigplan-sigsoft workshop program analysis software tools engineering toulouse france sept acm sigsoft software engineering notes sept abstract postscript pdf siff chandra ball kunchithapadam reps coping type casts proceedings esec fse seventh european software engineering conference seventh acm sigsoft symposium foundations software engineering toulouse france sept abstract postscript pdf clarke fujita rajan reps shankar teitelbaum program slicing hardware description languages proc charme bad herrenalb ger sept abstract postscript pdf yong horwitz reps pointer analysis programs structures casting sigplan proceedings acm conference programming language design implementation atlanta acm sigplan notices abstract postscript pdf melski reps interprocedural path profiling proc int conf compiler construction amsterdam netherlands mar lecture notes computer science vol jaehnichen springer-verlag york abstract postscript pdf springer-verlag benedikt reps sagiv decidable logic describing linked data structures proc esop european symposium programming amsterdam netherlands mar lecture notes computer science vol swierstra springer-verlag york abstract postscript pdf springer-verlag sagiv reps wilhelm parametric shape analysis -valued logic conference record twenty-sixth acm symposium principles programming languages san antonio jan acm york abstract postscript pdf siff reps identifying modules concept analysis icsm ieee international conference software maintenance oct bari italy harrold visaggio eds ieee computer society washington abstract postscript pdf reps ball das larus program profiling software maintenance applications year problem proceedings esec fse sixth european software engineering conference acm sigsoft symposium foundations software engineering zurich switzerland sept lecture notes computer science vol jazayeri schauer eds springer-verlag york abstract paper springer-verlag melski reps interconvertibility set constraints context-free language reachability pepm proceedings acm sigplan symposium partial evaluation semantics-based program manipulation amsterdam netherlands june acm york abstract paper siff reps program generalization software reuse sigsoft proceedings fourth acm sigsoft symposium foundations software engineering san francisco october acm york abstract paper reps turnidge program specialization program slicing proceedings dagstuhl seminar partial evaluation schloss dagstuhl wadern germany feb lecture notes computer science vol danvy glueck thiemann eds springer-verlag york abstract paper springer-verlag sagiv reps wilhelm solving shape-analysis problems languages destructive updating conference record twenty-third acm symposium principles programming languages petersburg jan acm york abstract paper horwitz reps sagiv demand interprocedural dataflow analysis sigsoft proceedings acm sigsoft symposium foundations software engineering washington october acm sigsoft software engineering notes abstract paper reps rosay precise interprocedural chopping sigsoft proceedings acm sigsoft symposium foundations software engineering washington october acm sigsoft software engineering notes abstract paper das reps van hentenryck semantic foundations binding-time analysis imperative programs pepm proceedings acm sigplan symposium partial evaluation semantics-based program manipulation jolla california june acm york abstract paper reps shape analysis generalized path problem pepm proceedings acm sigplan symposium partial evaluation semantics-based program manipulation jolla california june acm york abstract postscript pdf sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation proceedings fase colloquium formal approaches software engineering aarhus denmark lecture notes computer science vol mosses nielsen schwartzbach eds springer-verlag york abstract paper springer-verlag reps horwitz sagiv precise interprocedural dataflow analysis graph reachability conference record twenty-second acm symposium principles programming languages san francisco jan abstract postscript pdf reps horwitz sagiv rosay speeding slicing sigsoft proceedings acm sigsoft symposium foundations software engineering orleans december acm sigsoft software engineering notes december abstract postscript pdf reps solving demand versions interprocedural analysis problems proceedings international conference compiler construction edinburgh scotland april lecture notes computer science vol fritzson springer-verlag york abstract paper springer-verlag ramalingam reps incremental algorithm maintaining dominator tree reducible flowgraph conference record twenty-first acm symposium principles programming languages portland jan abstract postscript pdf reps scan grammars parallel attribute evaluation data-parallelism proceedings acm symposium parallel algorithms architectures velen germany june july abstract postscript pdf ramalingam reps modification algebras proceedings international conference algebraic methodology software technology amast iowa city iowa ramalingam reps theory program modifications proceedings colloquium combining paradigms software development brighton april lecture notes computer science vol abramsky maibaum eds springer-verlag york yang horwitz reps program integration algorithm accommodates semantics-preserving transformations sigsoft proceedings fourth acm sigsoft symposium software development environments irvine december acm software engineering notes december reps algebraic properties program integration proceedings european symposium programming copenhagen denmark lecture notes computer science vol jones springer-verlag york reps bricker illustrating interference interfering versions programs proceedings international workshop software configuration management princeton october acm software engineering notes november horwitz pfeiffer reps dependence analysis pointer variables proceedings acm sigplan conference programming language design implementation portland june acm sigplan notices july reps yang semantics program slicing program integration proceedings colloquium current issues programming languages barcelona spain march lecture notes computer science vol diaz orejas eds springer-verlag york horwitz reps binkley interprocedural slicing dependence graphs proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july abstract retrospective retrospective pdf reps horwitz prins support integrating program variants environment programming large proceedings international workshop software version configuration control grassau germany jan berichte des german chapter acm vol winkler teubner stuttgart germany horwitz prins reps integrating non-interfering versions programs conference record fifteenth acm symposium principles programming languages san diego january acm york horwitz prins reps adequacy program dependence graphs representing programs conference record fifteenth acm symposium principles programming languages san diego january acm york abstract paper reps marceau teitelbaum remote attribute updating language-based editors conference record thirteenth acm symposium principles programming languages petersburg january acm york reps teitelbaum synthesizer generator proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh april acm sigplan notices abstract reps alpern interactive proof checking conference record eleventh acm symposium principles programming languages salt lake city utah january acm york abstract reps static-semantic analysis language-based editors digest papers ieee spring compcon san francisco march ieee computer society washington reps optimal-time incremental semantic analysis syntax-directed editors conference record ninth acm symposium principles programming languages albuquerque january acm york abstract teitelbaum reps horwitz wherefore cornell program synthesizer proceedings acm sigplan sigoa symposium text manipulation portland june acm sigplan notices 
june demers reps teitelbaum incremental evaluation attribute grammars application syntax-directed editors conference record eighth acm symposium principles programming languages williamsburg january acm york abstract back top patents reps horwitz binkley interprocedural slicing computer programs dependence graphs patent number issued november back top pending submissions lev-ami immerman reps sagiv srivastava yorsh simulating reachability first-order logic applications verification linked data structures submitted journal touili lal kidd reps saturation procedure computing reachability transducer pushdown systems submitted conference kidd reps dolby vaziri empire static detection atomic-set serializability violations submitted conference lal reps solving multiple reachability queries wpdss submitted conference lal touili kidd reps weighted transducers weighted pushdown systems submitted conference lal touili kidd reps summarizing reachability pushdown systems submitted conference back top reports reps sagiv bauer appreciation work reinhard wilhelm program analysis compilation theory practice essays dedicated reinhard wilhelm springer-verlag lal touili kidd reps weighted pushdown systems weighted transducers trcomputer sciences department wisconsin madison oct abstract pdf lal kidd reps touili abstract error projection trcomputer sciences department wisconsin madison sept abstract pdf lal reps improving pushdown system model checking trcomputer sciences department wisconsin madison feb abstract pdf balakrishnan reps recency-abstraction heap-allocated storage trcomputer sciences department wisconsin madison dec abstract postscript pdf balakrishnan reps recovery variables heap structure executables trcomputer sciences department wisconsin madison sept abstract postscript pdf chaki clarke kidd reps touili verifying concurrent message-passing programs recursive calls trcomputer sciences department wisconsin madison sept abstract postscript pdf wang jha reps schwoon stubblebine reducing dependence trust-management systems pki trcomputer sciences department wisconsin madison aug abstract postscript pdf schwoon wang jha reps distributed certificate-chain discovery spki sdsi trcomputer sciences department wisconsin madison aug abstract postscript pdf balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds proc workshop evaluation software defect detection tools june loginov reps sagiv learning abstractions verifying data-structure properties trcomputer sciences department wisconsin madison jan abstract postscript pdf ganapathy seshia jha reps bryant automatic discovery api-level vulnerabilities trcomputer sciences department wisconsin madison july pdf loginov reps sagiv abstraction refinement -valued-logic analysis trcomputer sciences department wisconsin madison april abstract postscript pdf yahav pnueli reps sagiv automatic verification temporal heap properties april yahav reps sagiv ltl model checking systems unbounded number dynamically created threads objects trcomputer sciences department wisconsin madison march abstract postscript pdf chandra reps physical type checking bell labs tech rep lucent technologies naperville mar abstract postscript pdf siff chandra ball kunchithapadam reps coping type casts bell labs tech rep lucent technologies naperville feb abstract postscript pdf clarke fujita rajan reps shankar teitelbaum program slicing design automation automatic technique speeding-up hardware design simulation testing verification unpublished report october abstract paper melski reps interprocedural path profiling trcomputer sciences department wisconsin madison september abstract postscript pdf reps program analysis graph reachability trcomputer sciences department wisconsin madison august abstract postscript pdf talk powerpoint mueller reps snelting eds program comprehension software reengineering dagstuhl seminar report international conference research center computer science ibfi schloss dagstuhl wadern germany dag wisconsin program-slicing tool manual computer sciences department wisconsin-madison august slicing-manual das reps bta termination cfl-reachability trcomputer sciences department wisconsin madison november horwitz reps sagiv demand interprocedural dataflow analysis trcomputer sciences department wisconsin madison august reps sagiv wilhelm solving shape-analysis problems languages destructive updating trcomputer sciences department wisconsin madison july van leeuwen mehlhorn reps eds incremental computation dynamic algorithms dagstuhl seminar report international conference research center computer science ibfi schloss dagstuhl wadern germany dagstuhl reps sagiv horwitz interprocedural dataflow analysis graph reachability datalogisk institut copenhagen copenhagen denmark april diku-tr reps wisconsin program-integration system manual release computer sciences department wisconsin-madison july manual ramalingam reps categorized bibliography incremental computation conference record twentieth acm symposium principles programming languages charleston jan acm york tutorial paper reps incremental computation unpublished tutorial notes presented twentieth acm symposium principles programming languages charleston jan klint reps snelting eds programming environments dagstuhl seminar report international conference research center computer science ibfi schloss dagstuhl wadern germany binkley horwitz reps identifying semantic differences programs procedures extended abstract computer sciences department wisconsin-madison september ramalingam reps programs trcomputer sciences department wisconsin-madison november paper latest version ball horwitz reps correctness algorithm reconstituting program dependence graph trcomputer sciences department wisconsin-madison july ramalingam reps semantics program representation graphs trcomputer sciences department wisconsin-madison december paper binkley horwitz reps multi-procedure equivalence theorem trcomputer sciences department wisconsin-madison november paper reps demonstration prototype tool program integration trcomputer sciences department wisconsin-madison january paper back top software teitelbaum reps cornell program synthesizer version june version september version september licensed approximately sites reps teitelbaum synthesizer generator release december release july release april licensed approximately sites reps bricker rosay wisconsin program-integration system release april release april release july licensed sites reps rosay horwitz wisconsin program-slicing tool release august kidd reps melski lal wpds library weighted pushdown systems download software back top visitors post-docs students visitors post-doctoral associates neil immerman mass bertrand jeannet irisa mar june stefan schwoon univ stuttgart feb mar david melski grammatech ithaca mooly sagiv associate professor school computer science tel-aviv israel robert paige nyu jiazhen cai nyu wuu yang professor department computer information science national chiao-tung taiwan jan prins professor department computer science north carolina chapel hill students alexey loginov refinement-based program verification three-valued-logic analysis dissertation tech rep trcomputer sciences department wisconsin madison august abstract pdf citeseer google scholar david melski interprocedural path profiling interprocedural express-lane transformation dissertation tech rep trcomputer sciences department wisconsin madison february abstract postscript pdf citeseer google scholar zhichen safety-checking machine code dissertation computer sciences department wisconsin madison december supervised jointly miller abstract postscript pdf citeseer michael siff techniques software renovation dissertation tech rep trcomputer sciences department wisconsin madison august abstract dissertation citeseer google scholar manuvir das partial evaluation dependence graphs dissertation tech rep trcomputer sciences department wisconsin madison february abstract dissertation citeseer ramalingam bounded incremental computation dissertation tech rep trcomputer sciences department wisconsin madison august citeseer google scholar dissertation published ramalingam bounded incremental computation lecture notes computer science vol springer-verlag york david binkley multi-procedure program integration dissertation tech rep trcomputer sciences department wisconsin madison august dissertation citeseer google scholar phil pfeiffer dependence-based representations programs variables dissertation tech rep trcomputer sciences department wisconsin 
madison august dissertation citeseer wuu yang algorithm semantics-based program integration dissertation tech rep trcomputer sciences department wisconsin madison august supervised jointly horwitz dissertation citeseer current students gogul balakrishnan citeseer evan driscoll denis gopan citeseer google scholar nick kidd akash lal junghee lim back top nbsp computer sciences home feedback content questions send reps wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
thomas reps research summary nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page reps contact nbsp information biography teaching research projects research summary past research recent items note updated categorized index disclaimer list books journal invited papers book chapters reprinted collections edited books magazine articles conference patents pending submissions reports software visitors post-doctoral associates students professional activities dept nbsp home page nbsp thomas reps professor computer sciences department wisconsin-madison west dayton street madison usa research summary research focuses methods programmers develop correct reliable secure software goal create tools manipulating programs analyzing execution properties tools developing based static analysis obtain information states program reaches execution running program specific inputs static-analysis techniques explore program behavior inputs states program reach make feasible program run aggregate descriptors represent collections states effort focused topics static program analysis -valued logic static analysis executables weighted pushdown systems summary past research work found work static analysis -valued logic addresses problem analyzing programs dynamic allocation freeing storage cells destructive updating structure fields features found modern programming languages including java programs data structures grow shrink dynamically fixed upper bound size number case thread-based languages java number threads grow shrink dynamically techniques provide create finite-sized descriptors memory configurations abstract details retain key information analysis identify interesting properties hold work analyzing stripped executables devised methods debugging information identify variables data objects types track manipulated executable information answers questions dereference operation access function called indirect call site human security analysts understand workings cots components plugins mobile code dlls memory snapshots worms virus-infected code work weighted pushdown systems wpdss developed static-analysis framework strictly richer previous approaches years worth shown wpdss formalism completely separate application domain access control shared computing resources distributed systems static program analysis -valued logic aim work srw rsw create parametric framework program analysis capable expressing rich properties memory configurations confirming behavioral properties input list-insert program acyclic list output acyclic list input list-reversal program destructive-update operations acyclic list output acyclic list parametric analysis framework instantiated ways create program-analysis algorithms provide answers questions varying degrees efficiency precision work originally motivated problem shape analysis programs written languages permit destructive updating dynamically allocated storage aim shape analysis discover information conservative shapes dynamically allocated data structures program pointer variables point investigated problem deeply discovered methods allowed deal properties memory configurations pure shape properties instance recent work concerned numeric properties gddrs key aspect approach makes -valued -valued logic -valued -valued logical structures ---i collections relations---are represent concrete abstract stores individuals represent entities memory cells threads locks unary binary relations encode contents variables pointer-valued structure fields aspects memory states first-order formulas transitive closure properties sharing cyclicity reachability formulas store affected execution kinds statements programming language analysis framework instantiated ways varying relation symbols logic varying unary relations control nodes folded set relations determines set properties tracked properties stores discovered hold points program instance analysis methodology verifying properties programs advantages -valued-logic approach loop invariants required theorem provers involved abstract execution step terminate method based abstract interpretation satisfies conditions guarantee entire process terminates method applies programs manipulate pointers heap-allocated data structures method eliminates user write usual proofs required abstract interpretation---i demonstrate abstract descriptors analyzer manipulates correctly model actual heap-allocated data structures program manipulates powerpoint presentation material found prototype implementation implements approach created called tvla hreev aluedl ogic nalyzer bibliography parametric shape analysis -valued logic static program analysis -valued logic putting static analysis work verification case study shape analysis finite differencing logical formulas static analysis verifying temporal heap properties evolution logic symbolically computing most-precise abstract operations shape analysis verification structure simulation relational approach interprocedural shape analysis semantics procedure local heaps abstractions numeric analysis array operations utility canonical abstraction abstraction refinement inductive learning simulating reachability first-order logic applications verification linked data structures relational abstraction functions automatic verification strongly dynamic software systems automated verification deutsch-schorr-waite tree-traversal algorithm refinement-based program verification three-valued-logic analysis back top static analysis executables aim research recover intermediate representations similar created program written high-level language initial work concerned executables goal provide platform analyst understand workings cots components plugins mobile code dlls memory snapshots worms virus-infected code static analysis techniques task obstacles overcome understand memory-access operations determine set addresses accessed operation difficult memory operations explicit memory addresses instruction easy indirect addressing address expressions difficult arithmetic addresses pervasive instance local variable loaded slot activation record address arithmetic performed notion type hardware level address values distinguished integer values memory accesses aligned word-sized address values potentially cobbled misaligned reads writes additional challenge programs symbol-table debugging information absent present executable untrustworthy case symbol-table debugging information relied analysis developed---called value-set analysis vsa ---is carried recover information contents memory locations manipulated executable rbl key feature vsa tracks address-valued integer-valued quantities simultaneously vsa related pointer-analysis algorithms developed programs written high-level languages determine over-approximation set variables addresses pointer variable hold vsa determines over-approximation set addresses data object hold program point time vsa similar range analysis numeric static-analysis algorithms over-approximate integer values variable hold vsa determines over-approximation set integer values data object hold program point value-set analysis incorporated tool called codesurfer facilities codesurfer provide analyst powerful flexible platform investigating properties behaviors executable codesurfer gui codesurfer scripting language access intermediate representations codesurfer builds executable iii grammatech path inspector tool sophisticated pattern-matching engine answer questions flow execution program codesurfer outcome joint project univ wisconsin grammatech codesurfer makes idapro disassembly toolkit grammatech codesurfer system toolkit building program-analysis inspection tools codesurfer tool code understanding code inspection supports graphical user interface gui scripting language accessing program system dependence graph sdg hrb information stored codesurfer intermediate representations irs gui supports browsing surfing sdg variety operations making queries sdg---such slicing hrb chopping gui user navigate program source code dependences manner analogous navigating world wide web codesurfer scripting language programmatic interface operations lower-level information individual nodes edges program sdg call graph control-flow graph node sets killed possibly-killed variables writing programs traverse codesurfer irs implement additional program analyses scripting language extend codesurfer capabilities bibliography analyzing memory accesses executables codesurfer platform analyzing executables model checking executables codesurfer wpds wysinwyx execute next-generation platform analyzing executables recovery low-level code recency-abstraction heap-allocated storage divine discovering variables executables back top weighted pushdown 
systems application interprocedural dataflow analysis work established connections interprocedural dataflow analysis model checking pushdown systems pdss connections dataflow analysis model checking established past work exception past work shed light relationship model checking bit-vector dataflow-analysis problems live-variable analysis partial-redundancy elimination contrast results obtained work rsj rsjm apply bit-vector problems non-bit-vector problem addressed iii dataflow-analysis problems expressed bit-vector problems linear constant propagation srh affine-relation analysis mos general approach applied distributive dataflow-analysis problem domain transfer functions infinite descending chains safe solutions obtained problems monotonic distributive contributions work summarized conventional dataflow-analysis algorithms merge values states program point states calling context dataflow-analysis algorithm obtained weighted pdss dataflow queries posed respect regular language stack configurations conventional merged dataflow information obtained issuing queries approach strictly richer framework interprocedural dataflow analysis provided conventional interprocedural dataflow-analysis algorithms algorithm solving path problems weighted pdss provide witness set paths provide explanation answer dataflow query reported algorithms rsj rsjm implemented libraries implemented implemented solve reachability problems weighted pdss downloaded wpds wpds libraries create prototype implementations context-sensitive interprocedural dataflow analyses uninitialized variables live variables linear constant propagation detection affine relationships weighted pushdown systems formalism completely separate application domain access control shared computing resources distributed systems sjrs jswr wjrss bibliography wpdss program analysis weighted pushdown systems application interprocedural dataflow analysis scp weighted pushdown systems application interprocedural dataflow analysis sas extended weighted pushdown systems verifying concurrent message-passing programs recursive calls improving pushdown system model checking wpdss access control distributed systems analysis spki sdsi certificates model checking generalized authorization problems model checking spki sdsi weighted pushdown systems trust-management systems reducing dependence spki sdsi pki back top nbsp computer sciences home feedback content questions send reps wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 
thomas reps past research accomplishments nbsp nbsp nbsp search nbsp nbsp nbsp nbsp computer science home page reps contact nbsp information biography teaching research projects research summary past research recent items note updated categorized index disclaimer list books journal invited papers book chapters reprinted collections edited books magazine articles conference patents pending submissions reports software visitors post-doctoral associates students professional activities dept nbsp home page nbsp thomas reps professor computer sciences department wisconsin-madison west dayton street madison usa past research accomplishments cornell program synthesizer technology transfer synthesizer generator technology transfer incremental computing technology transfer program slicing technology transfer interprocedural dataflow analysis context-free-language reachability technology transfer techniques software renovation program profiling software maintenance computational differentiation computational divided differencing cornell program synthesizer cornell program synthesizer tim teitelbaum started working interactive wysisyg programming environment strongly-typed block-structured imperative programming language tightly integrated combination facilities programmers create edit execute debug programs words created version interactive programming environment similar modern tools visual studio eclipse time created cornell program synthesizer radically kind programming tool mentor system donzeau-gouge kahn huet lang showed kind direct-manipulation programming tools pioneered smalltalk interlisp systems created mainstream programming language strongly-typed block-structured imperative programming constructs cornell program synthesizer successfully introductory programming classes students five-year period cornell rutgers princeton ucla universities technology transfer cornell program synthesizer distributed researchers universities research institutes industry laboratories lectures system copies distributed trace direct influence commercial products including dec language sensitive editor rational ada programming environment symantec lightspeedc lightspeedpascal programming environments difficult connect dots similar products hundreds thousands millions people daily basis today initial paper system cornell program synthesizer influential model programming tools future helped spark widespread interest question create tools developing analyzing testing debugging programs back top synthesizer generator dissertation investigated problem automating creation programming tools similar cornell program synthesizer languages goal research create editor-generator program enable editors languages created automatically language description solution proposed language descriptions giving grammar language sets attributes annotations attached nodes grammar derivation trees rules describe information node attributes affects attributes nodes essence editor thought specialized spreadsheet documents written language editing operation document underlying tree tree attributes longer consistent attributes updated reestablish consistency similar values updated spreadsheet program major result research optimal algorithm devised solve attribute-updating problem rtd part research developed prototype implementation editor-generating system made ideas spent post-doc cornell residence inria national institute computer science france collaborating advisor tim teitelbaum design implementation synthesizer generator full-scale version system synthesizer generator creates language-specific editor input specification defines language syntax display format transformation rules restructuring documents written language attribution rules codify context-sensitive relationships document elements specification synthesizer generator creates specialized editor manipulating documents rules synthesizer generator proven great utility wide range applications including program editors text-preparation systems tools verify correctness proofs kinds mathematical programming logics technology transfer beginning august synthesizer generator made universities industrial research organizations distribution began licensed sites countries books describing system teitelbaum co-authored published springer-verlag teitelbaum founded company grammatech commercialize synthesizer generator technology grammatech subsequently created products ada programming language based synthesizer generator ada-assured ada-utilities mids development major department defense system written ada back top incremental computing attribute-updating algorithm developed part research incremental updating algorithm ---an algorithm makes solution problem instance find solution nearby problem instance kind problem remained interests returned occasionally years variety contexts including interactive program-development environments rtd rmt graph algorithms construction abstract transformers program-analysis problems rsl incremental computing subject ramalingam research carried supervision technology transfer incremental shortest-hyperpath algorithm improve performance open shortest path ospf commonly intra-domain internet routing protocol incremental shortest-hyperpath algorithm subroutine heuristic search algorithm optimizing ospf weights set projected demands reduce congestion fortz thorup speed-up obtained incremental algorithm reported factor mikkel thorup told results adjust capacities network schedule link downtimes maintenance apparently frequently order dozen links serviced day back top program slicing starting carried great deal work exploring program slicing operation originally proposed late mark weiser serve basis semantics-based program-manipulation operations slice program respect set program elements projection program includes program elements affect directly transitively values variables members slicing find semantically meaningful decompositions programs decompositions consist elements textually contiguous program slicing fundamental operation aid solving software-engineering problems instance applications program understanding maintenance debugging testing differencing specialization reuse merging program variants hpr projects carried students co-workers aimed improving underlying technology program slicing related operations hrb rhsr implementing program slicers wisconsin program-slicing tool codesurfer developing methods slicing software-engineering tools hpr building slicing-based program-manipulation tools hpr click home page wisconsin program-slicing project conference paper interprocedural slicing susan horwitz david binkley wrote hrb selected inclusion special sigplan collection influential papers sigplan conference programming language design implementation horwitz reps binkley interprocedural slicing dependence graphs years acm sigplan conference programming language design implementation selection mckinley acm sigplan notices april journal version hrb appeared hrb papers highly-cited google scholar citeseer retrospective hrb published horwitz reps binkley retrospective interprocedural slicing dependence graphs years acm sigplan conference programming language design implementation selection mckinley acm sigplan notices april retrospective retrospective pdf recent work students colleagues developed methods program analysis slicing based formalism called weighted pushdown systems technology transfer collaboration genevieve rosay susan horwitz built system called wisconsin program-slicing tool implemented slicing ansi programs wisconsin program-slicing tool distributed not-for-profit research purposes license wisconsin longer distributed commercial tool named codesurfer derived wisconsin implementation grammatech licensed technology wisconsin alumni research foundation not-for-profit foundation royalty income technologies licenses support research wisconsin grammatech improved wisconsin implementation considerably terms speed space efficiency extended support grammatech offers codesurfer academic researchers favorable terms tavis ormandy gentoo linux codesurfer team responsible investigating verifying security problems open source programs distribute codesurfer made dramatic impact time takes isolate understand security flaws allowing traverse complex unfamiliar codebases easily trace problems source group saic nasa codesurfer group analyzes mission-critical software projects reduce defects ensure software meets requirements conducted formal study codesufer improve software inspections found codesurfer reduced inspection time average addition codesurfer number defects found doubled slicing commercial tools designed address year problem including ibm visual age cobol slicing support application understanding program conversion program structuring year code-renovation issues slicing continued live tools software renovation modify financial software account conversion euro list tools found list slicing tools back top interprocedural dataflow analysis 
context-free-language reachability work carried susan horwitz mooly sagiv david melski established interesting connections work interprocedural program slicing number program-analysis problems classical interprocedural dataflow analysis showed large class program-analysis problems solved transforming instances special kind graph-reachability problem called context-free-language reachability cfl-reachability rhs hrs notion cfl-reachability originated mihalis yannakakis developed context graph-theoretic methods database theory context-free-language reachability problems solved polynomial time algorithms similar originally developed interprocedural slicing hrb rhsr david melski studied relationship cfl-reachability program-analysis formalism set constraints introduced john reynolds subsequently studied alex aiken nevin heintze powerpoint presentation prepared tutorial gave material pldi found technology transfer addition cfl-reachability-based slicing algorithms codesurfer work program analysis cfl-reachability direct impact well-known slam tool microsoft key algorithms slam based interprocedural dataflow-analysis algorithm rhs slam work bill gates radar screen instance keynote address windows hardware engineering conference gates touted work slam software verification holy grail computer science decades key areas driver verification building tools actual proof software works order guarantee reliability recent work students colleagues developed methods interprocedural dataflow analysis based formalism called weighted pushdown systems back top techniques software renovation mike siff investigated techniques converting programs programs advantage improved features templates classes instance considered problem software generalization program component create parameterized program component usable wider variety syntactic contexts semantically meaningful generalization exist instantiation equivalent functionality gave algorithm generalizes functions type inference original functions operate specific data types result generalization collection function templates operate parameterized types version generalization problem context converting existing programs general technique identifying modules legacy code method based concept analysis---a branch lattice theory identify similarities set objects based attributes showed concept analysis identify potential modules positive negative information presented algorithmic framework construct lattice concepts program concept represents potential module back top program profiling software maintenance asked defense advanced research projects agency darpa plan project aimed reducing impact year problem department defense darpa interested techniques research community applied problem impact present commercial products services spent semester kind talent scout darpa ideas worth pursuing exciting ideas turned concerned method path profiling heuristic locate sites program problematic date manipulations rbdl generally aid testing debugging path profiler instruments program number times loop-free path executes accumulated execution run instrumented program run program generates path spectrum execution---a distribution paths executed run path spectrum finite easily obtainable characterization program execution dataset behavior signature run program techniques based idea comparing path spectra runs program runs produce spectra spectral differences identify paths program control diverges runs choosing input datasets hold factors constant divergence attributed factor point divergence underlying problem starting place programmer begin exploration application technique year problem problem fixing computer systems -digit year fields date-valued data context path-spectrum comparison heuristic identifying paths program good candidates date-dependent computations technology year problem tools program profiling software maintenance applications year problem program profiling software testing interprocedural path profiling interprocedural path profiling tra years found essentially idea discovered earlier collofello cousin wilde extensive research subject term software reconnaissance back top computational differentiation computational divided differencing tools computational differentiation transform program computes numerical function related program computes derivative louis rall mathematics department techniques similar tools implement program transformations---in variety transformations computational divided differencing back top nbsp computer sciences home feedback content questions send reps wisc server technical accessibility issues lab wisc copyright copy board regents wisconsin system 

curriculum vitae thomas reps professor computer sciences department wisconsin west dayton street madison wisconsin usa office secretary department reps wisc http wisc reps birth ithaca usa citizenship united states education cornell computer science cornell computer science cum laude harvard applied mathematics positions visiting researcher istituto elaborazione della informazione del cnr pisa italy vilas associate wisconsin professor computer sciences department wisconsin guest professor datalogisk institut copenhagen copenhagen denmark associate chairman computer sciences department wisconsin associate professor computer sciences department wisconsin president co-founder grammatech assistant professor computer sciences department wisconsin research associate department computer science cornell visiting researcher institut national recherche informatique automatique inria rocquencourt france post-doctoral associate department computer science cornell rds acm fellow eapls paper award etaps balakrishnan recognized highly cited researcher field computer science institute scientific information horwitz reps binkley interprocedural slicing dependence graphs selected influential papers acm sigplan conference programming language design implementation pldi guggenheim fellowship john simon guggenheim memorial foundation humboldt research award alexander von humboldt foundation vilas associate award wisconsin david lucile packard fellowship science engineering ibm faculty development award nsf presidential young investigator award acm doctoral dissertation award grants principal investigator advanced static-analysis techniques ensuring reliable software nsf principal investigator reverse engineering kernel-mode rootkits grammatech principal investigator deobfuscating tools validation verification tamper-proofed software grammatech principal investigator subcontract grammatech deep static analysis binaries arda principal investigator subcontract grammatech model checking software binaries hsarpa principal investigator advanced methods checking information-security properties nsf cybertrust co-principal investigator static analysis enhance power model checking concurrent software onr research initiative co-principal investigator vulnerability information flowanalysis cots onr research initiative principal investigator investigation newcompressed representation boolean functions nsf principal investigator investigation newcompressed representation boolean functions onr co-investigator run-time type checking programs ibm partnership award ibm research co-investigator run-time type checking programs ibm partnership award ibm research principal investigator softwarediagnostics path-spectrum information ibm partnership award ibm research principal investigator shape-analysis languageswith destructive updating nsf co-investigator slicing programs recursive data structures united states-israel binational science foundation principal investigator improved techniques programanalysis programspecialization rockwell foundation principal investigator softwarediagnostics path-spectrum information ibm partnership award ibm research principal investigator apreprocessor activity analysis ansi-c programs argonne national laboratories principal investigator semantics-based programmanipulation nsf principal investigator technical opportunities year problem advanced research projects agency principal investigator improved techniques programanalysis programslicing advanced research projects agency principal investigator softwaresupport programming large advanced research projects agency principal investigator avel support participants international workshop national science foundation principal investigator semantics-based programintegration national science foundation david lucile packardfellowship science engineering david lucile packard foundation principal investigator softwaresupport programming large defense advanced research projects agency principal investigator softwaresupport programming large digital equipment corporation presidential young investigator award nsf principal investigator language-based programdevelopment environments xerox corporation faculty development award ibm corporation principal investigator language-based programdevelopment environments digital equipment corporation principal investigator language-based programdevelopment environments siemens corporate research participating faculty member prism laboratory research infuturehigh-performance parallel computing nsf vernon carey dyer hill meyer miller principal investigators participating faculty member topaz laboratory research indistributed computing nsf dewitt finkel fischer landweber mangasarian solomon principal investigators books reps teitelbaum synthesizer generator system constructing language-based editors springer-verlag newyork reps teitelbaum synthesizer generator manual thirdedition springer-verlag newyork chinese reprint published world publishing corporation beijing china reps generating language-based environments press cambridge edited books programanalysis compilation theory practice essays dedicated reinhardwilhelm reps sagiv bauer eds lecture notes computer science vol springer-verlag journal yorsh reps sagiv wilhelm logical characterizations heap abstractions acmtransactions computational logic jan yahav reps sagiv wilhelm verifying temporal heap properties evolution logic logic journal igpl oct reps schwoon jha melski weighted pushdown systems application interprocedural dataflowanalysis science computer programming oct alur benedikt etessami godefroid reps yannakakis analysis recursive state machines acmtrans prog lang syst jha reps model checking spki sdsi journal computer security anderson reps teitelbaum design implementation fine-grained software inspection tool ieee trans softwareengineering aug reps rall computational divided differencing divided-difference arithmetics higher-order symbolic computation clarke fujita rajan reps shankar teitelbaum program slicing vhdl softwaretools technology transfer oct sagiv reps wilhelm parametric shape analysis -valued logic acmtrans program lang syst reps undecidability context-sensitive data-dependence analysis acmtransactions programming languagesand systems jan melski reps interconvertibility class set constraints context-free language reachability theoretical computer science nov siff reps identifying modules concept analysis ieee transactions softwareengineering nov dec reps program analysis graph reachability information softwaretechnology november december reps maximal-munch tokenization linear time acmtransactions programming languages systems march sagiv reps wilhelm solving shape-analysis problems languages destructive updating acmtransactions programming languagesand systems january sagiv reps horwitz precise interprocedural dataflowanalysis applications constant propagation theoretical computer science reps sequential nature interprocedural program-analysis problems acta informatica ramalingam reps incremental algorithm generalization shortest-path problem journal algorithms ramalingam reps computational complexity dynamic graph problems theoretical computer science binkley horwitz reps program integration languages procedure calls acm ansactions softwareengineering methodology january ramalingam reps competitive on-line algorithms dynamic priority-ordering problem information processing letters yang horwitz reps program integration algorithm accommodates semantics-preserving transformations acmtransactions softwareengineering methodology july reps algebraic properties program integration science computer programming horwitz reps efficient comparison program slices acta informatica horwitz reps binkley interprocedural slicing dependence graphs acmtransactions programming languagesand systems january horwitz prins reps integrating non-interfering versions programs acmtransactions programming languagesand systems july reps incremental evaluation attribute grammars unrestricted movement tree modifications acta informatica reps demers sublinear-space evaluation algorithms attribute grammars acmtransactions programming languagesand systems july reps teitelbaum demers incremental context-dependent analysis language-based editors acmtransactions programming languagesand systems july teitelbaum reps cornell program synthesizer syntax-directed programming environment communications acm september invited papers balakrishnan reps divine discovering variables executables proc int conf onverification model checking abstract interpretation nice france jan jha schwoon wang reps weighted pushdown systems trust-management systems proc tacas vienna austria mar apr reps balakrishnan lim recovery low-levelcode proc workshop partial evaluation programmanipulation pepm charleston jan reps balakrishnan lim teitelbaum next-generation platform analyzing executables proc rdasian symposium programming languagesand systems tsukuba japan nov reps sagiv wilhelm static program analysis -valued logic proc int conf computer-aided verification rall reps algorithmic differencing perspectives enclosuremethods kulisch lohner facius eds springer-verlag vienna invited paper presented scan gamm-imacs int symp sci comput comp arith validated numerics karlsruhe ger sept wilhelm sagiv reps shape analysis 
proc int conf oncompiler construction berlin ger mar apr reps program analysis graph reachability proc ilps international logic programming symposium port jefferson oct maluszynski press cambridge reps program profiling software testing proc informatik aachen germany sept jarke pasedach pohl eds springer-verlag berlin ger horwitz reps program dependence graphs software engineering proceedings fourteenth international conference softwareengineering melbourne australia acm newyork reps horwitz semantics-based program integration proceedings european symposium programming nancy france march lecturenotes computer science vol ganzinger springer-verlag newyork book chapters sagiv reps wilhelm yahav utility canonical abstraction engineering theories softwareintensive systems broy gruenbauer hoare harel eds kluwer academic publishers dordrecht netherlands reps sagiv wilhelm shape analysis applications compiler design handbook optimizations machine code generation crc press reps demand interprocedural program analysis logic databases applications logic databases ramakrishnan kluwer academic publishers boston reprinted collections reps balakrishnan lim teitelbaum next-generation platform analyzing executables malwaredetection advances information security series springer-verlag reprinted proc rdasian symposium programming languagesand systems tsukuba japan nov horwitz reps binkley interprocedural slicing dependence graphs yearsofthe acmsigplan conference programming language design implementation selection mckinley acmsigplan notices april reprinted sigplan proceedings acm conference programming language design implementation atlanta june acmsigplan notices july aretrospective onthe paper appeared horwitz reps binkley retrospective interprocedural slicing dependence graphs yearsofthe acm sigplan conference programming language design implementation selection mckinley acmsigplan notices april horwitz reps binkley interprocedural slicing dependence graphs software changeimpact analysis bohner arnold eds ieee computer society los alamitos reprinted acmtransactions programming languagesand systems january horwitz reps binkley interprocedural slicing dependence graphs softwaremerging slicing berzins ieee computer society los alamitos reprinted acmtransactions programming languagesand systems january horwitz prins reps integrating non-interfering versions programs softwaremerging slicing berzins ieee computer society los alamitos reprinted acmtransactions programming languagesand systems july ramalingam reps theory program modifications softwaremerging slicing berzins ieee computer society los alamitos reprinted proceedings colloquium combining paradigms softwaredevelopment brighton april lecturenotes computer science vol abramskyand maibaum eds springer-verlag newyork reps teitelbaum language processing program editors language arc hitectures programming environments ichikawa tsubotani eds world scientific publishing company singapore reprinted ieee computer november teitelbaum reps cornell program synthesizer syntax-directed programming environment interactive programming environments barstow sandewall shrobe eds mcgraw-hill reprinted communications acm september teitelbaum reps horwitz whyand wherefore cornell program synthesizer softwaredevelopment environments wasserman ieee computer society washington reprinted proceedings acm sigplan sigoasymposium textmanipulation portland june acmsigplan notices june magazine articles anderson reps teitelbaum zarins tool support fine-grained software inspection ieee software reps teitelbaum language processing program editors ieee computer november refereed conference gopan reps guided static analysis proc static analysis symposium lal kidd reps touili abstract error projection proc static analysis symposium lev-ami weidenbach reps sagiv labelled clauses proc conference automated deduction gopan reps low-levellibrary analysis summarization proc computeraided verification amit rinetzky reps sagiv yahav comparison abstraction verifying linearizability toappear proc computer-aided verification bogudlov lev-ami reps sagiv revamping tvla making parametric shape analysis competitive tool paper proc computer-aided verification loginov reps sagiv refinement-based verification possibly-cyclic lists program analysis compilation theory practice essays dedicated reinhardwilhelm springerverlag balakrishnan reps melski teitelbaum wysinwyx execute toappear verified software theories tools experiments springer-verlag dor field gopan lev-ami loginov manevich ramalingam reps rinetzky sagiv wilhelm yahav yorsh automatic verification strongly dynamic software systems verified software theories tools experiments springer-verlag lev-ami sagiv immerman reps shape analysis uniform change proc int conf onverification model checking abstract interpretation nice france jan lim reps liblit extracting output formats executables proc ieee working conference reverse engineering benevento italy oct wang jha reps schwoon stubblebine reducing dependence spki sdsi pki proc european symp research incomputer security balakrishnan reps recency-abstraction heap-allocated storage proc static analysis symposium springer-verlag newyork loginov reps sagiv automated verification deutsch-schorr-waite tree-traversal algorithm proc static analysis symposium springer-verlag newyork lal reps improving pushdown system model checking proc computer-aided verification springer-verlag newyork gopan reps lookahead widening proc computer-aided verification springer-verlag newyork chaki clarke kidd reps touili verifying concurrent message-passing programs recursive calls proc tacas springer-verlag newyork jeannet gopan reps relational abstraction functions proc int static analysis symp lev-ami immerman reps sagiv srivastava yorsh simulating reachability first-order logic applications verification linked data structures proc conf automated deduction balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds tool-demonstration paper proc computer-aided verification lal balakrishnan reps extended weighted pushdown systems proc computer-aided verification loginov reps sagiv abstraction refinement inductive learning proc computeraided verification ganapathy seshia jha reps bryant automatic discovery api-level exploits proc int conf onsoftwareengineering louis missouri balakrishnan gruian reps teitelbaum codesurfer aplatform analyzing executables tool demonstration paper int conf oncompiler construction april jeannet gopan reps relational abstraction functions int workshop numerical symbolic abstract domains jan yorsh skidanov reps sagiv assume guarantee reasoning heap-manipulating programs proc int workshop abstract interpretation object-oriented languages electronic notes theoretical computer science gopan reps sagiv numeric analysis array operations conference recordofthe thirty-second acm symposium principles programming languages long beach jan rinetzky bauer reps sagiv wilhelm semantics procedure local heaps abstractions conference recordofthe thirty-second acm symposium principles programming languages long beach jan immerman rabinovich reps sagiv yorsh boundary decidability undecidability transitive closure logics proc computer science logic springer-verlag newyork jeannet loginov reps sagiv relational approach interprocedural shape analysis proc int static analysis symp springer-verlag newyork immerman rabinovich reps sagiv yorsh verification structure simulation proc int conf oncomputer-aided verification balakrishnan reps analyzing memory accesses executables proc int conf compiler construction springer-verlag newyork arded eapls paper award etaps yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis proc tacas springer-verlag newyork gopan dimaio dor reps sagiv numeric domains summarized dimensions proc tacas springer-verlag newyork reps sagiv yorsh symbolic implementation transformer proc verification model checking abstract interpretation reps schwoon jha weighted pushdown systems application interprocedural dataflowanalysis proc int static analysis symp june san diego lecturenotes computer science vol springer-verlag newyork invited special submission science computer programming schwoon jha reps stubblebine generalized authorization problems proc ieee computer security foundations workshop june july asilomar pacific grove reps sagiv loginov finite differencing logical formulas static analysis proc european symp programming lecturenotes computer science vol springer-verlag newyork yahav reps sagiv wilhelm verifying temporal heap properties evolution logic proc european symp programming lecturenotes computer science vol springer-verlag newyork 
melski reps interprocedural express-lane transformation proc int conf oncompiler construction lecturenotes computer science vol springer-verlag newyork reps loginov sagiv semantic minimization -valued propositional formulae proc ieee symp logic computer science copenhagen denmark july jha reps analysis spki sdsi certificates model checking proc ieee computer security foundations workshop cape breton nova scotia june invited special submission journal computer security benedikt godefroid reps model checking unrestricted hierarchical state machines proc icalp twenty-eighth int colloq automata languages programming crete greece july lecturenotes computer science vol springer-verlag newyork loginov yong horwitz reps debugging run-time type checking proc fase fundamental approaches softw eng genoa italy april reps miller typestate checking machine code proc esop european symp programming genoa italy april lev-ami reps sagiv wilhelm putting static analysis work verification case study issta proc int symp softwaretesting analysis portland aug miller reps safety checking machine code sigplan proceedings acmconference programming language design implementation vancouver canada june chandra reps physical type checking proc paste sigplan-sigsoft workshop programanalysis softwaretools engineering toulouse france sept acmsigsoft softwareengineering notes sept siff chandra ball kunchithapadam reps coping type casts proceedings esec fse seventh european softwareengineering conference seventh acm sigsoft symposium foundations softwareengineering toulouse france sept clarke fujita rajan reps shankar teitelbaum program slicing hardware description languages proc charme bad herrenalb ger sept invited special submission int journal softwaretools technology transfer yong horwitz reps pointer analysis programs structures casting sigplan proceedings acm conference programming language design implementation atlanta acmsigplan notices melski reps interprocedural path profiling proc int conf oncompiler construction amsterdam netherlands mar lecturenotes computer science jaehnichen springer-verlag newyork benedikt reps sagiv decidable logic describing linked data structures proc esop european symposium programming amsterdam netherlands mar lecturenotes computer science vol swierstra springer-verlag newyork sagiv reps wilhelm parametric shape analysis -valued logic conference record twenty-sixth acm symposium principles programming languages san antonio jan acm newyork siff reps identifying modules concept analysis icsm ieee international conference softwaremaintenance bari italy oct harrold visaggio eds ieee computer society washington invited special submission ieee trans softwareengineering reps ball das larus program profiling software maintenance applications year problem proceedings esec fse sixth european softwareengineering conference acm sigsoft symposium foundations softwareengineering zurich switzerland sept lecturenotes computer science vol jazayeri schauer eds springer-verlag newyork melski reps interconvertibility set constraints context-free language reachability pepm proceedings acm sigplan symposium partial evaluation semanticsbased programmanipulation amsterdam netherlands june acm newyork invited special submission theoretical computer science siff reps program generalization software reuse sigsoft proceedings fourth acm sigsoft symposium foundations softwareengineering san francisco october acm newyork reps turnidge program specialization program slicing proceedings dagstuhl seminar partial evaluation schloss dagstuhl wadern germany feb lecture notes computer science vol danvy glueck thiemann eds springer-verlag newyork sagiv reps wilhelm solving shape-analysis problems languages destructive updating conference recordofthe twenty-thirdacm symposium principles programming languages petersburg jan acm newyork horwitz reps sagiv demand interprocedural dataflowanalysis sigsoft proceedings thirdacm sigsoft symposium foundations softwareengineering washington october acmsigsoft softwareengineering notes invited special submission acmtrans softwareengineering methodology reps rosay precise interprocedural chopping sigsoft proceedings thirdacm sigsoft symposium foundations softwareengineering washington october acmsigsoft softwareengineering notes reps shape analysis generalized path problem pepm proceedings acm sigplan symposium partial evaluation semantics-based programmanipulation jolla california june acm newyork das reps van hentenryck semantic foundations binding-time analysis imperative programs pepm proceedings acm sigplan symposium partial evaluation semantics-based programmanipulation jolla california june acm newyork sagiv reps horwitz precise interprocedural dataflowanalysis applications constant propagation proceedings fase colloquium formal approaches softwareengineering aarhus denmark lecturenotes computer science vol mosses nielsen schwartzbach eds springer-verlag newyork invited special submission theoretical computer science reps horwitz sagiv precise interprocedural dataflowanalysis graph reachability conference recordofthe twenty-second acm symposium principles programming languages san francisco jan acm newyork reps horwitz sagiv rosay speeding slicing sigsoft proceedings acm sigsoft symposium foundations softwareengineering neworleans december acmsigsoft softwareengineering notes december reps solving demand versions interprocedural analysis problems proceedings international conference compiler construction edinburgh scotland april lecturenotes computer science vol fritzson springer-verlag newyork ramalingam reps incremental algorithm maintaining dominator tree reducible flowgraph conference recordofthe twenty-first acm symposium principles programming languages portland jan reps scan grammars parallel attribute evaluation data-parallelism proceedings acmsymposium parallel algorithms architectures velen germany june july ramalingam reps modification algebras proceedings international conference algebraic methodology softwaretechnology amast iowa city iow ramalingam reps theory program modifications proceedings colloquium combining paradigms softwaredevelopment brighton april lecturenotes computer science vol abramskyand maibaum eds springer-verlag newyork yang horwitz reps program integration algorithm accommodates semantics-preserving transformations sigsoft proceedings fourth acm sigsoft symposium softwaredevelopment environments irvine december acmsoftwareengineering notes december invited special submission acmtrans softwareengineering methodology reps algebraic properties program integration proceedings thirdeuropean symposium programming copenhagen denmark lecturenotes computer science vol jones springer-verlag newyork invited special submission science computer programming reps bricker illustrating interference interfering versions programs proceedings international workshop softwareconfiguration management princeton october acmsoftwareengineering notes november horwitz pfeiffer reps dependence analysis pointer variables sigplan proceedings acm conference programming language design implementation portland june acmsigplan notices july reps yang semantics program slicing program integration proceedings colloquium current issues programming languages barcelona spain march lecturenotes computer science vol diaz orejas eds springer-verlag newyork horwitz reps binkley interprocedural slicing dependence graphs sigplan proceedings acm conference programming language design implementation atlanta june acmsigplan notices july selected inclusion special sigplan collection influential papers sigplan conference programming language design implementation reps horwitz prins support integrating program variants environment programming large proceedings international workshop softwareversion configuration control grassau germany jan berichte des german chapter acm winkler teubner stuttgart germany horwitz prins reps integrating non-interfering versions programs conference record fifteenth acm symposium principles programming languages san diego january acm newyork horwitz prins reps adequacyofprogram dependence graphs representing programs conference recordofthe fifteenth acm symposium principles programming languages san diego january acm newyork reps marceau teitelbaum remote attribute updating language-based editors conference recordofthe thirteenth acm symposium principles programming languages petersburg january acm newyork reps teitelbaum synthesizer generator proceedings acm sigsoft sigplan softwareengineering symposium practical softwaredevelopment environments pittsburgh april acmsigplan notices reps alpern interactive proof checking conference recordofthe eleventh acm symposium principles programming languages salt lakecity utah january acm newyork reps optimal-time incremental semantic analysis syntax-directed editors conference recordof ninth acm symposium principles programming languages albuquerque january acm newyork invited special 
submission acmtrans programming languagesand systems teitelbaum reps horwitz whyand wherefore cornell program synthesizer proceedings acm sigplan sigoasymposium textmanipulation portland june acmsigplan notices june demers reps teitelbaum incremental evaluation attribute grammars application syntax-directed editors conference recordofthe eighth acm symposium principles programming languages williamsburg january acm newyork conference horwitz reps language-based tools software engineering proceedings darpa istosoftwaretechnology conference santa monica april defense advanced research projects agency arlington ramalingam reps modification algebras extended abstract preliminary proceedings international conference algebraic methodology softwaretechnology amast iowa city iow department computer science iowa iow city reps demonstration prototype tool program integration proceedings darpa isto softwareprincipal investigators meeting warwick feb march defense advanced research projects agency arlington reps static-semantic analysis language-based editors digest papersofthe ieee spring compcon san francisco march ieee computer society washington pending submissions lev-ami immerman reps sagiv srivastava yorsh simulating reachability first-order logic applications verification linked data structures submitted journal kidd reps dolby vaziri empire static detection atomic-set serializability violations submitted conference reports reps sagiv bauer appreciation work reinhard wilhelm programanalysis compilation theory practice essays dedicated reinhardwilhelm springer-verlag lal touili kidd reps weighted pushdown systems weighted transducers trcomputer sciences department wisconsin madison oct lal kidd reps touili abstract error projection trcomputer sciences department wisconsin madison sept reps teitelbaum anderson melski static analysis binary executable code proceedings defining state art softwaresecurity tools workshop gaithersburg aug nist special nat inst standards technology gaithersburg sept balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds proc workshop evaluation softwaredefect detection tools june yahav reps sagiv ltl model checking systems unbounded number dynamically created threads objects trcomputer sciences department wisconsin madison march chandra reps physical type checking bell labs tech rep lucent technologies naperville mar siff chandra ball kunchithapadam reps coping type casts bell labs tech rep lucent technologies naperville feb clarke fujita rajan reps shankar teitelbaum program slicing design automation automatic technique speeding-up hardware design simulation testing verification unpublished report october mueller reps snelting program comprehension software reengineering dagstuhl seminar report international conference research center computer science ibfi schloss dagstuhl wadern germany wisconsin program-slicing tool manual computer sciences department wisconsin-madison august das reps bta termination cfl-reachability trcomputer sciences department wisconsin madison november horwitz reps sagiv demand interprocedural dataflowanalysis trcomputer sciences department wisconsin madison august vanleeuwen mehlhorn reps eds incremental computation dynamic algorithms dagstuhl seminar report international conference research center computer science ibfi schloss dagstuhl wadern germany reps sagiv horwitz interprocedural dataflowanalysis graph reachability datalogisk institut copenhagen copenhagen denmark april reps wisconsin program-integration system manual release computer sciences department wisconsin madison july ramalingam reps categorized computation conference recordofthe twentieth acm symposium principles programming languages charleston jan acm newyork reps incremental computation unpublished tutorial notes presented twentieth acm symposium principles programming languages charleston jan klint reps snelting eds programming environments dagstuhl seminar report international conference research center computer science ibfi schloss dagstuhl wadern germany ramalingam reps newprograms trcomputer sciences department wisconsin madison november binkley horwitz reps identifying semantic differences programs procedures extended abstract computer sciences department wisconsin madison september ball horwitz reps correctness algorithm reconstituting program dependence graph trcomputer sciences department wisconsin madison july ramalingam reps semantics program representation graphs trcomputer sciences department wisconsin madison december binkley horwitz reps multi-procedure equivalence theorem trcomputer sciences department wisconsin madison november yang horwitz reps detecting program components equivalent behaviors trcomputer sciences department wisconsin madison april horwitz prins reps suitability dependence graphs representing programs computer sciences department wisconsin madison august reps guest editor sintroduction acmtransactions programming languagesand systems october teitelbaum reps release synthesizer generator acmsoftwareengineering notes january teitelbaum reps computation engineering cornell quarterly college engineering cornell ithaca november teitelbaum reps correspondence syntax-directed editors communications acm software kidd reps melski lal wpds library weighted pushdown systems download http wisc wpis wpds reps rosay horwitz wisconsin program-slicing tool release august release january reps bricker rosay wisconsin program-integration system release april release april release july licensed sites reps teitelbaum synthesizer generator release december release july release april licensed approximately sites teitelbaum reps cornell programsynthesizer version june version september version september licensed approximately sites patents reps horwitz binkley interprocedural slicing computer programs dependence graphs patent number issued november lectures invited addresses semantics-based program integration european symposium programming esop nancy france march program dependence graphs software engineering fourteenth international conference software engineering melbourne australia program profiling software testing informatik aachen germany sept program analysis graph reachability fourteenth international logic programming symposium port jefferson oct program analysis graph reachability distinguished lecture series department computer information science ohio state columbus april static analysis software-engineering tools issues opportunities washington microsoft research workshop technologies improve software development seattle august static analysis linked data structures distinguished lecture series louisiana lafayette lafayette april static program analysis -valued logic static analysis symposium madrid spain sept finite differencing logical formulas static analysis workshop dynamic algorithms applications neworleans jan weighted pushdown systems applications int workshop automated verification infinite-state systems barcelona spain april codesurfer aplatform analyzing executables infosec research council arlington july static program analysis three-valued logic int conf computer-aided verification boston july static analysis executables distinguished lecture series minn nov abstraction analysis dynamically changing resources ifip working conference verified software theories tools experiments zurich switzerland oct next-generation platform analyzing executables asian symposium programming languages systems tsukuba japan nov ----------acmsigplan workshop partial evaluation program manipulation pepm charleston jan wysinwyx execute infosec research council washington march divine discovering variables executables eighth int conf verification model checking abstract interpretation vmcai nice france jan tutorials incremental computation twentieth acm symposium principles programming languages charleston january program analysis graph reachability pldi acm conference programming language design implementation vancouver canada june presentations symposia workshops whyand wherefore cornell program synthesizer acm sigplan sigoasymposium xtmanipulation portland june optimal-time incremental semantic analysis syntax-directed editors ninth acm symposium principles programming languages albuquerque january static-semantic analysis language-based editors ieee spring compcon san francisco march ----------international syntax-directed editing aussois france april optimal-time incremental semantic analysis syntax-directed editors international syntax-directed editing aussois france april interactive proof checking eleventh acm symposium principles programming languages salt lakecity utah january synthesizer generator acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh april ----------workshop programs data objects copenhagen 
denmark october remote attribute updating language-based editors thirteenth acm symposium principles programming languages petersburg january synthesizer generator ibm academic information systems study conference lauderdale november integrating non-interfering versions programs ifip working group niagara-on-the-lake ontario ----------first meeting midwest society programming languages systems chicago october semantics-based program integration nsf industry symposium ibm watson research center yorktown heights april ----------first annual meeting david lucile packard fellowships program monterey september algebraic properties program integration meeting midwest society programming languages systems chicago october illustrating interference interfering versions programs international workshop software configuration management princeton october algebraic properties program integration european symposium programming esop copenhagen denmark semantics-based program integration darpa istosoftware principal investigators meeting warwick february computational complexity incremental algorithms seminar programming environments international conference research center computer science ibfi dagstuhl castle wadern germany march semantics-based program integration international workshop feature interactions telecommunications software systems petersburg december scan grammars parallel attribute evaluation data-parallelism twelfth meeting midwest society programming languages systems iowa city april ----------fifth acm symposium parallel algorithms architectures velen germany july bounded incremental computation annual meeting david lucile packard fellowships program monterey september solving demand versions interprocedural analysis problems international conference compiler construction edinburgh scotland april incremental attribute evaluation bounded incremental computation seminar incremental computation dynamic algorithms international conference research center computer science ibfi dagstuhl castle wadern germany incremental interprocedural dataflowanalysis seminar incremental computation dynamic algorithms international conference research center computer science ibfi dagstuhl castle wadern germany speeding slicing sigsoft acm sigsoft symposium foundations software engineering neworleans december precise interprocedural dataflowanalysis graph reachability twenty-second acm symposium principles programming languages san francisco january shape analysis generalized path problem pepm acm sigplan symposium partial evaluation semantics-based program manipulation jolla california june precise interprocedural chopping acm sigsoft symposium foundations software engineering washington october program specialization program slicing seminar partial evaluation international conference research center computer science ibfi dagstuhl castle wadern germany february program profiling debugging testing quest annual technology awareness symposium motorola museum schaumburg april program profiling software maintenance applications year problem fourteenth int conf testing computer software tysons corner june ----------sixth european software engineering conference acm sigsoft symposium foundations software engineering zurich switzerland sept program analysis graph reachability seminar program comprehension software reengineering international conference research center computer science ibfi dagstuhl castle wadern germany march parametric shape analysis -valued logic seminar programs recursively defined data structures international conference research center computer science ibfi dagstuhl castle wadern germany april program analysis graph reachability seminar programs recursively defined data structures international conference research center computer science ibfi dagstuhl castle wadern germany april parametric shape analysis -valued logic seminar program analysis international conference research center computer science ibfi dagstuhl castle wadern germany april program analysis graph reachability seminar model checking program analysis schloss ringberg tegernsee germany feb semantic minimization -valued propositional formulae ieee symp logic computer science copenhagen denmark july static program analysis -valued logic seminar reasoning shape international conference research center computer science ibfi dagstuhl castle wadern germany march symbolic implementation transformer seminar reasoning shape international conference research center computer science ibfi dagstuhl castle wadern germany march weighted pushdown systems application interprocedural dataflowanalysis int static analysis symp san diego june generalized authorization problems ieee computer security foundations workshop pacific grove july weighted pushdown systems seminar language-based security international conference research center computer science ibfi dagstuhl castle wadern germany oct numeric analysis array operations thirty-second acm symposium principles programming languages long beach jan codesurfer next-generation platform analyzing executables national security agency conference high confidence software systems linthicum heights march next-generation platform analyzing executables software assurance forum alexandria april model checking executables codesurfer wpds workshop evaluation software defect detection tools june next-generation platform analyzing executables aro-dhs workshop malware detection aug wysinwyx execute ifip working conference verified software theories tools experiments zurich switzerland oct ----------dagstuhl seminar software verification infinite-state model checking static program analysis feb demonstrations softwareatsymposia workshops synthesizer generator acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh april wisconsin program-integration system european symposium programming esop copenhagen denmark ----------acmsigsoft fourth symposium software development environments irvine december ----------second international conference algebraic methodology software technology amast iowa city iow ----------third annual meeting david lucile packard fellowships program monterey september ----------seminar programming environments international conference research center computer science ibfi dagstuhl castle wadern germany march synthesizer generator fifteenth international conference software engineering baltimore wisconsin program-integration system fifteenth international conference software engineering baltimore ----------seminar partial evaluation international conference research center computer science ibfi dagstuhl castle wadern germany february lectures universities research institutes approximately seminar talks universities research institutes north america europe asia australia supervisoryactivities students supervised major dissertation advisor wuu yang supervised jointly horwitz dissertation anew algorithm semanticsbased program integration tech rep trcomputer sciences department wisconsin madison august phillip pfeiffer dissertation dependence-based representations programs variables tech rep trcomputer sciences department wisconsin madison august david binkley dissertation multi-procedure program integration tech rep trcom- puter sciences department wisconsin madison august ramalingam dissertation bounded incremental computation tech rep trcom- puter sciences department wisconsin madison august dissertation published ramalingam bounded incremental computation lecture notes computer science vol springer-verlag newyork manuvir das dissertation partial evaluation dependence graphs tech rep trcomputer sciences department wisconsin madison february michael siff dissertation techniques software renovation tech rep trcom- puter sciences department wisconsin madison august zhichen supervised jointly miller dissertation safety checking machine code david melski dissertation interprocedural path profiling interprocedural express-lane transformation trcomputer sciences department wisconsin madison feb alexey loginov dissertation refinement-based program verification three-valued-logic analysis dissertation tech rep trcomputer sciences department wisconsin madison august post-doctoral associates visitors jan prins cornell univ professor department computer science north carolina chapel hill wuu yang univ ofwisconsin professor department computer information science national chiao-tung taiwan robert paige nyu jiazhen cai nyu mooly sagiv technion associate professor computer science department tel-avivuniversity israel david melski univ ofwisconsin stefan schwoon univ ofstuttgart feb mar bertrand jeannet irisa mar june neil immerman mass external examiner emma vander meulen centrum voor wiskunde informatica mathematical center amsterdam netherlands january frank tip centrum voor wiskunde informatica mathematical center amsterdam netherlands march professional activities government member avionics advisory team office deputy secretary defense science technology consultant defense advanced research projects agency darpa plan 
project aimed reducing impact year problem department defense editorial activities co-editor programanalysis compilation theory practice essays dedicated reinhardwilhelm festschrift prof reinhard wilhelm univ des saarlandes springer-verlag editor software practice experience present associate editor ieee transactions softwareengineering guest editor acmtransactions programming languagesand systems october special issue consisting papers acm sigplan symposium languages issues programming environments seattle june organizer co-organizer member steering committee international workshop verification model checking abstract interpretation vmcai seminar program comprehension software reengineering international conference research center computer science ibfi dagstuhl castle wadern germany march snelting mueller nsf darpa aroworkshop software engineering programming languages cambridge june gill gunter lee lee mitchell notkin tannen seminar incremental computation dynamic algorithms international conference research center computer science ibfi dagstuhl castle wadern germany vanleeuwen mehlhorn seminar programming environments international conference research center computer science ibfi dagstuhl castle wadern germany march klint snelting chairman program committee twenty-seventh acm symposium principles programming languages january member program committee conference computer-aided verification international workshop verification model checking abstract interpretation european symposium programming esop acmsigplan conference programming language design implementation acmworkship partial evaluation semantics-based progrm manipulation international workshop verification model checking abstract interpretation eleventh international conference compiler construction international workshop automated program analysis testing verification static analysis symposium ieee international conference computer languages acmpepm sigplan symposium partial evaluation semantics-based program manipulation acmsigplan conference programming language design implementation sixth international conference compiler construction acm sigsoft symposium foundations software engineering acmsigsoft fourth symposium software development environments irvine sixteenth acm symposium principles programming languages austin european symposium programming esop nancy france fourteenth acm symposium principles programming languages munich west germany acmsigplan symposium languages issues programming environments seattle member selection committee ninth acm george forsythe student paper competition review committees member reviewcommittee army research office computing information sciences division proposal-review panels member national science foundation proposal-reviewpanels instructor international syntax-directed editing aussois france april panelist panel software development quality metrics cip uri workshop annapolis aug formal methods software verification cav int conf computer aided verification july programming environments tools ifip world computer congress madrid spain september programming environments tools ibm academic information systems study conference lauderdale november participant darpa itoworkshop software-enabled control systems atlanta december models programming languages working group acm workshop strategic directions computing research cambridge june workshop foundational studies software engineering nsf arpa palo alto september workshop future research programming languages compilers nsf charleston january workshop critical research directions programming languages office navalresearch miami beach october referee reviewer acmcomputing surveys acmtransactions programming languagesand systems acmtransactions softwareengineering methodology acta informatica ieee transactions computers ieee transactions softwareengineering information processing letters lecturenotes computer science mathematical systems theory science computer programming software practice experience press national research council national academy sciences national science foundation netherlands computer science research foundation swedish research council engineering sciences professional societies association computing machinery acm acmspecial interest group programming languages sigplan acmspecial interest group software engineering sigsoft 
retrospective interprocedural slicing dependence graphs susan horwitz comp sci department wisconsin west dayton street madison horwitz wisc thomas reps comp sci department wisconsin west dayton street madison reps wisc david binkley comp sci department loyola college north charles street baltimore binkley loyola paper made main contributions defined system dependence graphs sdgs extended program dependence graphs pdgs incorporate collections procedures procedure calls monolithic programs defined interprocedural slicing algorithm identifies components sdg affect values variables defined program point executes novelty algorithm correctly accounts calling context called procedure improving technique interprocedural slicing algorithm presented mark weiser seminal papers program slicing paper results form part david binkley thesis journal version paper published toplas sdgs covered patent algorithms forward backward slicing part original patent application submitted wisconsin alumni research foundation decided money spent time patent office convinced claim sdgs patentable data structures slicing algorithms paper commercial product codesurfer tool code understanding inspection supports browsing slicing dependence graphs codesurfer grammatech http grammatech products codesurfer slicing algorithm codesurfer based improved method pldi paper careful state slicing problem solve producing slice executable projection original program reason multiple calls procedure general slice include call subset procedure parameters slice extended slicing algorithm addresses parameter-mismatch problem binkley pldi paper couched terms simple programming language sdgs class program representations represent programs programming languages variants pdgs nodes edges capture features constructs language issue create pdgs sdgs orthogonal issue slice considerable work build dependence graphs features constructs found real-world programming languages years acm sigplan conference programming language design implementation selection copyright acm including arrays parameters pointers non-structured control flow threads context-sensitive program analysis nowadays interprocedural-slicing method pldi paper termed context-sensitive interprocedural-slicing method general context-sensitive analysis analysis called procedure sensitive context called context-sensitive analysis captures fact calls procedure call sites effects program execution state general frameworks context-sensitive program analysis existed aware time work influenced kastens algorithm building collection cooperating finite-state machines evaluating derivation trees attribute grammars papers session pldi paper presented foreshadowed major direction work subsequently callahan presented context-sensitive algorithm kind dataflow-analysis problem cooper kennedy presented graph-reachability algorithm finding procedures maymod mayuse sets summarize side-effects procedure calls global variables work horwitz reps collaborators showed dataflow-analysis problems similar callahan addressed turned graphreachability problems fashion similar technique cooper-kennedy paper solved algorithms similar horwitz-reps-binkley interprocedural-slicing algorithm papers presented hour half session pldi act combining techniques occur years context-free-language reachability pldi paper pointed correspondence call structure program context-free grammar intraprocedural transitive dependences pdg parameter nodes dependences attributes attribute grammar paper exploited correspondence compute summary edges added sdg call sites capture transitive dependences transitive dependences interest transitive dependences captured characteristic graphs attribute grammar nonterminals algorithm identifying summary edges inspired passes algorithm creating tds graphs define class ordered attribute grammars yields slicing algorithm quartic size parameter problem learned fifteen years write paper today describe work differently addition describing problem context-sensitive analysis algorithm identifying summary edges tabulation algorithm dynamic-programming algorithm explain interprocedural slicing formulated terms simple logic program lines explain interprocedural-slicing problem kind generalized graph-reachability problem labels edges graph filter paths interest path vertex vertex counts valid connection word spelled concatenation order labels edges language filter language context-free language called cfl-reachability concept originated yannakakis cfl-reachability problems solved time cubic number nodes graph general algorithm running time survey ways cflreachability applies program-analysis problems slight clash terminology exists formal-language theory context-sensitive languages strictly powerful formalism context-free languages principle context-free-language reachability captures essential aspect context-sensitive analysis fully articulated term context-sensitive analysis adopted programming-languages community case interprocedural slicing contextsensitive program-analysis problems filter language language matched parentheses called dyck language essence pldi paper language partially balanced parentheses exclude consideration paths calls returns mismatched parentheses defined call-site node sdg unique index totalcallsites totalcallsites total number call sites program call site label outgoing parameter-in edges incoming parameter-out edges symbols label outgoing call edge label edges symbol dyck languages earlier work interprocedural dataflow analysis sharir pnueli contributions kinds infeasible execution paths filtered dataflow-analysis algorithms sharir pnueli based graph reachability mentioned algorithm pldi paper quartic time complexity dyck languages contextfree means yannakakis result applies yannakakis work means cfl-reachability problems solved time cubic number graph nodes asymptotically taking advantage structure graph arises subclass problems instance improved algorithm interprocedural slicing algorithm cubic size parameter parameter smaller size sdg node set dyck-language reachability shown reps sagiv horwitz provide algorithms wide variety interprocedural program-analysis problems including addressed callahan pldi paper ideas elaborated sequence papers showed utility approach exhaustive demand program-analysis problems algorithms cubic worst-case running time quadratic space interesting special cases gen-kill dataflow-analysis problems run linear time linear space authors aware connection general concept cfl-reachability fall papers period mentions cflreachability explicitly yannakakis paper sagiv reps horwitz similar ideas cfl-reachability give powerful cubic-time interprocedural dataflow-analysis algorithms benefits work showed obtain precise jump functions classes interprocedural constant-propagation problems improving developed callahan paper cfl-reachability viewpoint yielded results inherent computational limitations related slicing program-analysis problems work adopted cfl-reachability model addressed topics program chopping type checking model checking bug detection agrawal slicing programs jump statements conf prog lang design impl pages ball horwitz slicing programs arbitrary control-flow int workshop automated algorithmic debugging pages ball rajamani bebop path-sensitive interprocedural dataflow engine workshop prog analysis softw tools eng york june acm press bannerjee speedup ordinary programs phd thesis dept comp sci univ illinois urbana october benedikt godefroid reps model checking unrestricted hierarchical state machines icalp binkley multi-procedure program integration phd thesis comp sci dept univ wisconsin madison august tech rep trd binkley precise executable interprocedural slices prog lang syst callahan program summary graph flow-sensitive interprocedural data flow analysis conf prog lang design impl pages york acm press callahan cooper kennedy torczon interprocedural constant propagation symp comp construct pages chase wegman zadeck analysis pointers structures conf prog lang design impl pages york acm press choi ferrante static slicing presence goto statements trans prog lang syst cooper kennedy interprocedural side-effect analysis linear time conf prog lang design impl pages york acm press cousot cousot static determination dynamic properties recursive procedures neuhold editor formal descriptions programming concepts ifip andrews canada august pages north-holland das lerner seigle esp path-sensitive program verification polynomial time conf prog lang design impl pages york acm press dwyer corbett hatcliff sokolowski 
zheng slicing multi-threaded java programs case study tech rep dept comp inf sci kansas state univ manhattan february emami ghiya hendren context-sensitive interprocedural points-to analysis presence function pointers conf prog lang design impl york acm press ferrante ottenstein warren program dependence graph optimization trans prog lang syst goff kennedy tseng practical dependence testing conf prog lang design impl pages york acm press horwitz pfeiffer reps dependence analysis pointer variables conf prog lang design impl pages york acm press horwitz reps binkley interprocedural slicing dependence graphs trans prog lang syst january horwitz reps sagiv demand interprocedural dataflow analysis symp found softw eng pages york october acm press horwitz reps sagiv demand interprocedural dataflow analysis report trcomp sci dept univ wisconsin august http wisc wpis papers horwitz reps sagiv rosay speeding slicing symp found softw eng pages york december acm press kastens ordered attribute grammars acta inf knuth semantics context-free languages math syst theory krinke static slicing threaded programs workshop prog analysis softw tools eng june kumar horwitz slicing programs jumps switches colloq formal approaches softw eng pages larus hilfinger detecting conflicts structure accesses conf prog lang design impl pages york acm press maydan hennessy lam efficient exact data dependence analysis conf prog lang design impl pages york acm press nanda ramesh slicing concurrent programs symp softw testing analysis august ottenstein ottenstein program dependence graph software development environment softw eng symp practical softw dev environments pages york acm press pugh wonnacott eliminating false data dependences omega test conf prog lang design impl pages york acm press ramalingam context-sensitive analysis undecidable trans prog lang syst rehof ahndrich type-base flow analysis polymorphic subtyping cfl-reachability symp princ prog lang pages york acm press reps demand interprocedural program analysis logic databases ramakrishnan editor applications logic databases kluwer academic publishers reps shape analysis generalized path problem symp part eval semantics-based prog manip pages york june acm press reps sequential nature interprocedural program-analysis problems acta inf reps program analysis graph reachability inf softw tech november reps undecidability context-sensitive data-dependence analysis trans prog lang syst january reps horwitz binkley patent number interprocedural slicing computer programs dependence graphs november reps horwitz sagiv precise interprocedural dataflow analysis graph reachability symp princ prog lang pages york acm press reps rosay precise interprocedural chopping symp found softw eng york october acm press reps sagiv horwitz interprocedural dataflow analysis graph reachability tech rep datalogisk institut univ copenhagen http wisc wpis papers diku-tr sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs sinha harrold rothermel slicing programs arbitrary control flow int conf softw eng pages wash ieee comp soc weiser program slicing int conf softw eng pages wash ieee comp soc weiser program slicing trans softw eng sejuly wilson lam efficient context-sensitive pointer analysis programs conf prog lang design impl pages york acm press wolfe optimizing supercompilers supercomputers phd thesis dept comp sci univ illinois urbana october yannakakis graph-theoretic methods database theory symp princ database syst pages 
technology year problem tools technology year problem tools program profiling year renovation testing thomas reps computer sciences department wisconsin west dayton street madison reps wisc http wisc reps world faces cataclysmic breakdown turn millennium alarm news present turn millennium significant reasons residents world concerned time computer programs digits record year values date-valued data process year cases intended intended --such represents current year computation performed calendar rolls january --then faulty computation carried approximate age born calculated january years computations involve dates future phenomenon occur calendar rolls january summer asked defense advanced research projects agency darpa plan project aimed reducing impact year problem department defense darpa interested techniques research community applied problem impact present commercial products services exciting ideas turned concerns method path profiling heuristic locate sites program problematic date manipulations works path profiling program instrumented number times loop-free path executes accumulated execution run instrumented program run set runs program generates path spectrum execution --a distribution paths executed path spectra identify paths program good candidates date-dependent computations finding differences path spectra execution runs pre-yeardata post-yeardata choosing input datasets hold factors constant dates program differences spectra obtained execution runs attributed date-dependent computations program differences spectra reveal paths program performed sort computation post-yearrun paths --and computations --that longer executed post-yearrun analysis spectra path shows spectral difference identify shortest prefix distinguishes paths path set problem path-spectrum comparison technique provide aspect problem determining sites date-manipulation code occurs post-renovation testing path-spectrum comparison technique guaranteed uncover sites date manipulations technique hope good heuristics path-spectrum comparison involves principle principles lie heuristics commercial tools good complement current techniques path-spectrum comparison technique applicable wider range software-maintenance problems problem offers perspectives program testing task creating test data tools created support program testing prototype tool gathering comparing path spectra called dynadiff built wisconsin dynadiff works programs run solaris sun sparcstations unix programs problem year problem unix time function reports number seconds january rolls --and turns negative --on tuesday january utc demonstrate principle path-spectrum comparison technique diagnosing problems applying dynadiff compare spectra generated normal runs spectra generated runs result time time-warped future unix cal utility called arguments prints calendar current month current month obtained calling time spectral differences dynadiff displays version cal modified optionally permit time-warping compares spectrum run february run made time set emulate run february post-rollover path-spectrum comparison technique detect runs program behaviors dynadiff user examine paths question clicking bars spectra brings window displays elements path contrasting colors paths executed yearrun --but yearrun --would displayed green longest prefix path shares path yearpath set yellow endpoints edge distinguishes path paths yearpath set red remainder path colors shown yearrun executed loop rem secsperday rem secsperday days yearrun execute loop examination code deduce timep negative program renovator information employing program slicing trace back source problem work path-spectrum comparison paper reps ball das larus program profiling software maintenance applications year problem proceedings esec fse sixth european software engineering conference acm sigsoft symposium foundations software engineering zurich switzerland sept lecture notes computer science springer-verlag york wisconsin alumni research foundation process seeking patent protection techniques reps method troubleshooting data-dependent anomalies computer programs patent filed january 
jfif mso palette cehih ounft ghe fvo qql hbl ybh evlu ehy aac fvw ivek yeah llj yjl kav xajm hfnj rpeqij accurate computation divided differences divided differences slopes cares divided differences computing divided differences computing divided differences evaluation horner rule evaluation horner rule evaluation horner rule laws outline programs data objects partial evaluation slicing computational differentiation computational divided differencing cdd generalizes higher-order cdd multi-variate cdd divided difference laws laws evaluation horner rule evaluation horner rule evaluation horner rule evaluation horner rule evaluation horner rule outline programs data objects partial evaluation slicing computational differentiation computational divided differencing cdd generalizes higher-order cdd multi-variate cdd accurate computation divided differences slopes slopes divided-difference table divided-difference table evaluation horner rule evaluation horner rule evaluation horner rule evaluation horner rule plotting function outline programs data objects partial evaluation slicing computational differentiation computational divided differencing cdd generalizes higher-order cdd multi-variate cdd divided-difference table polynomial newton interpolating polynomial divided-difference table polynomial taylor series divided-difference table polynomial divided-difference table polynomial divided-difference table polynomial divided-difference table polynomial divided-difference table polynomial linear interpolation linear interpolation linear interpolation linear interpolation divided difference slope divided-difference table polynomial divided difference slope divided difference slope divided-difference table surface avoid subtractions quadratic interpolation divided-difference table surface evaluation horner rule evaluation horner rule evaluation horner rule relationships cdd relationships cdd relationships cdd relationships cdd relationships cdd related work click edit master title style click edit master text styles level level fourth level level joint work louis rall differentiating version computational differentiation computational differentiation differentiating version computational differentiation differentiating version program chopping eval i-ans ans coeff return ans i-ans ans ans ans ans coeff return ans i-ans ans coeff return ans i-ans ans ans ans ans coeff return ans i-ans ans ans ans ans coeff return ans i-ans ans ans ans ans coeff return ans i-ans ans ans ans ans coeff return ans standard cdd eval i-ans ans coeff return ans i-ans ans coeff return ans time dzm dzm eval i-float temp int degree j-temp temp coeff ans ans temp return ans bivariatepoly eval dda dda dda ans int degree i-dda temp int degree j-temp temp coeff ans ans temp return ans dda var dda var dda surface eval computational differentiation differentiation arithmetic 
journal computer security ios press model checking spki sdsi jha reps computer sciences department wisconsin dayton street madison usa e-mail jha reps wisc spki sdsi framework expressing naming authorization issues arise distributedcomputing environment paper establish connection spki sdsi formalism pushdown systems pdss show spki sdsi-to-pds connection framework formalizing variety certificate-analysis problems connection computational significance analysis problems solved efficiently time polynomial size certificate set existing algorithms model checking pushdown systems keywords spki sdsi model checking pushdown system naming authorization certificate-chain discovery certificate-set analysis introduction systems shared resources access-control mechanisms protection fundamental problems access control authorization enforcement authorization addresses problem request specific principal allowed enforcement addresses problem implementing authorization execution centralized system authorization based closed-world assumption parties trusted distributed system closed-world assumption valid trust management systems solve authorization problem distributed systems defining formal language expressing authorization access-control policies rely algorithm determine specific request allowable survey trust management systems formal framework understanding presented prominent trust management systems keynote spki sdsi spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations clarke considered problem discovering work supported part national science foundation grant ccrby office naval research contracts alexander von humboldt foundation government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government ios press authors rights reserved jha reps model checking spki sdsi certificate chain authorization respect set spki sdsi certificates certificate chain proof client public key keys authorized access resource directly transitively name-definition authorization-delegation steps paper studies problem certificate analysis context spki sdsi establish connection spki sdsi threshold subjects formalism pushdown systems pdss section spki sdsi refers language defined threshold subjects section discusses work extended handle threshold subjects work stems simple observation set spki sdsi authorization certificates defines pds significance connection contributions made paper summarized spki sdsi-to-pds connection framework formalizing variety certificate-set analysis problems certificate-set analysis problem model checking pushdown systems analysis problems stated precisely standard formalisms posing model-checking queries problems include authorization problem addressed clarke authorized access resource principal isk authorized access questions interested respect certificate set suchas authorized access resource necessarily principal authorized access authorized access resource names necessarily principals authorized access shared access resources principals access shared access principals resource access shared access principals finite set resources resources accessed flavors model checking henceforth noted term model checking refers model checking pushdown systems background problem section general infinite set shown answer form finite-state automaton accepts names authorized access jha reps model checking spki sdsi compromisation assessment resources finite set principal gained access solely due presence maliciously accidentally issued certificate set prime compromisation assessment principals gained access resource solely due presence maliciously accidentally issued certificate set prime expiration vulnerability resources finite set resources principal prevented accessing certificate set prime cexpires expiration vulnerability principals excluded accessing resource certificate set prime cexpires universally guarded access case authorizations issued resource involve certificate signed principal universally guarded access case authorizations grant principal prime access finite set resources involve certificate signed analysis problems listed solved efficiently time polynomial size certificate set existing model-checking algorithms pdss addition annotating certificates labels semiring enables address additional types questions specific authorization expire section addition specific queries listed certificate-set analysis question posed ltl query solved time polynomial size case certificate-chain discovery show operation subroutine algorithms model checking pdss algorithm problem special-purpose algorithm certificate-chain discovery developed clarke worst-case asymptotic running time algorithm clarke improved handling tabulated data lead asymptotic improvement family examples clarke illustrate worst-case upper bound tight constant factor family examples algorithm exhibit worst-case behavior section closure star set certificates includes additional certificates derived chain certificates general closure star infinite set circumvent problem clarke defined restricted type closure called name-reduction closure guaranteed finite pds-based algorithm computes actual closure name-reduction closure pds-based algorithm finite-state automaton represent set certificates finite representation potentially infinite set spki sdsi context answer questions capability return infinite set jha reps model checking spki sdsi table kinds arrows paper spki sdsi cert square square spki sdsi auth cert delegation bit square squaresolid spki sdsi auth cert delegation bit arrowhookleft transition rule pds prime immediate-successor relation pds prime transitive closure immediate-successor relation pds star prime reflexive transitive closure immediate-successor relation pds reachability relation states configuration automaton fill relation epsilon star epsilon star configuration automaton authorized access resource names principals authorized access remainder paper organized section introduction spki sdsi describes algorithm certificate-chain discovery section background model checking pushdown systems section discusses applications formal machinery certificate-set analysis problems section discusses related work paper structured self-contained deals problem domains kinds arrows denote relationships kinds objects summarized table readers familiar skip sections minor notational differences papers footnotes background spki sdsi spki sdsi principals represented public keys principal individual process host active entity spki sdsi make distinction principal public key principal public key denotes set public keys specific keys denoted prime data-structure issues related representation keys found identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form wherek kand ais identifier bob local local names important spki sdsi create decentralized space set local names denoted local space local names form denoted jha reps model checking spki sdsi extended form wherek kand sequence identifiers length greater faculty extended set extended names denote set extended names beginning key set names space ofthekeyk set terms certificates spki sdsi types certificates certs type certificate called cert definitions local names authorizations authorization certs auth certs short certificates cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification information validity certificate validity specification takes form interval cert valid time inclusive validity specification form on-line check performed complete explanation validity specifications context authorization problem generally ignore validity specification assume working exclusively valid certificates extensions handle types validity specifications discussed section authorization certificates auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert issuer granting specific authorization subject term delegation bit turned key 
receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host authorization specification auth cert refers resource authorization specification dir afs wisc public tmp refers resource afs wisc public tmp slight abuse terminology refer authorization specification resource jha reps model checking spki sdsi assume partial order authorization specifications prime denotes fact permissive prime intheexample shown prime prime dir afs wisc public tmp read dir afs wisc public tmp set read write validity specification auth cert case cert treat certs rewrite rules cert written auth cert written square square delegation bit turned written square squaresolid authorization section describe authorization illustrative purposes paper traditional discretionary access control protected resource access-control list acl describing principals permissions access resource auth cert viewed acl entry keys principals represented subject permission access resource assume resource unique owner denoted owner certificate chains granting access resource start owner instance suppose alice login host initially owner host owner denies access reports acl entry alice written auth cert owner square facultysquare set certs shown fig alice prove authorized access host name-reduction closure describe algorithm reader referred additional details define concept closure set certificates aterms appearing rule viewed string alphabet elements beginning uniformity refer strings form set read write denotes read write permission read denotes read permission jha reps model checking spki sdsi owner square facultysquare faculty bob bob square alicesquaresolid alice fig set certs square squaresolid terms assume rewrite rule cert term case rewrite rule applied term denoted yields term rule viewed function terms terms bob bob myfriends myfriends aterms rule called compatible form givena set certificates term wedefinec set compatible rules andc assume prefix thereexistsanx composition rules rule rules friends bob myfriends bob composition rule friends myfriends rules called compatible composition welldefined set certificates closure denoted star smallest set certificates includesc closed composition general star infinite computed directly set certificates closure star set greaterorequalslant rule application write composition andc write finally star jha reps model checking spki sdsi set certificates isdefinedas star words set keys obtained rewrite rules set certs applications granted authorization key indirectly granted authorization instance authorization section shown faculty alice authorization login host closure star set certs infinite concept name-reduction closure introduced reducing cert form prime aname reduction composition compatible rules wherec reducing cert name-reduction closure sharp set certificates defined smallest set certificates closed reduction set certs equality proved star sharp words safe inspect name-reduction closure find set keys correspond certificate set return authorization describe four-step procedure determining principal authorized access resource authorization specification perform operation set certificates tuple isreferredtoasarequest remove useless certificates invalid auth certificates removed set auth certs negationslash removed reduction compute name-reduction closure sharp set name-reduction closure set shown fig yields additional certs shown fig faculty square squaresolid owner square facultysquare owner square facultysquare owner square square fig additional rules added name-reduction closure jha reps model checking spki sdsi depth-first search remove rules form square squareor square squaresolid rules remain step square squaresolid owner square square remove rules form square squaresolid wherek negationslash construct graph vertex key edge rule form square squaresolid square square edges owner fourth perform depth-first search determine path owner path owner alice key alice authorized login host reconstruct certificate chain information previous steps create certificate chain proves principal authorized access desired resource certificate chain proves alice authorized login host owner square squaresolid certificate-chain reconstruction requires additional information stored algorithm perform name-reduction closure smallest size certificate chain exponential number certs desirable report certificate chains factored form chapter time space complexity name-reduction closure analyzed set certificates number keys occurring typical certificate form reduction obtain rule form afteri mname reductions obtain rules form reductions obtain rule form therearen possibilities keys sotherearen possibilities rules generated sum lengths right-hand sides rules occur maximum number rules produced arule compatible reducing certs rule result work time complexity name-reduction closure number nodes edges graph constructed depth-first-search step bounded time complexity depth-first search authorization procedure jha reps model checking spki sdsi time complexity name-reduction closure step dominates running time procedure number rules produced bounded space complexity procedure term appears depth-first search data structures representing certs discussed detail elien thesis background model checking pushdown systems section background model checking pushdown systems pdss detailed treatment model checking pdss including computational complexity problems found improved algorithm model checking pdss presented material section largely based improvements found pushdown system triple finite set control locations finite stack alphabet star finite set transition rules prime write arrowhookleft prime configuration pair whereq control location star represents stack contents set configurations denoted asurface configuration pair whereq arrowhookleft prime star configuration predecessor prime prime successor denoted prime reflexive transitive closure reachabilityrelation andthe transitive closure immediate-successor relation denoted star run sequence configurations predecessor pushdown systems similar pushdown automata unlike pushdown automata input alphabet pds viewed language recognizer mechanism specifies infinite-state transition system transition system infinite number distinct states pds prime consists transition rules arrowhookleft arrowhookleft prime epsilon whereepsilon denotes empty string symbols starting configuration infinite-state transition system generated pds shown fig remainder section summarizes algorithms complexity results provide basic toolkit addressing reachability questions pdss basic backward forward reachability algorithms discussed sections linear time logic ltl powerful query language generalized reachability questions pds ltl model checking jfif mso palette cehih ounft ghe fvo qql hbl ybh evlu ehy aac fvw ivek yeah nbe krs llj yjl pddbr xvf aoin mtal ezph ubt kdt tkv udpf olb vbl fpk ecx qprr iiq qcv kjm ehq afwnf yow nqmc slee fbd qfl m-v k-w krs xfjy app nnn -lpk cdbr daa wrv kfj pdss discussed section symbol denotes reflexive transitive closure predecessor relation predecessor relation star reflexive transitive closure jha reps model checking spki sdsi hfnj fig infinite-state transition systems generated pds set configurations ipp hcou eqx ate m-v k-w set predecessors denoted pre prime prime penr reflexive transitive closure pre denoted pre star pre star prime star hen prime set successors post set configurations defined ctu similarly kzb -oyn reflexive transitive closure post denoted post star understood write pre pre star post andpost star fwy computing pre star assume pushdown system regular set configurations represented finite-state automaton called configuration automaton input alphabet stack alphabet formally leu configuration automaton automaton finite set states set locations subset set transitions set initial states andf set final states configuration automaton reachability relation denoted star defined smallest relation satisfying epsilon prime thenq prime primeprime primeprime prime raj thenq prime henceforth refer configuration automaton simply yjb automaton automaton accepts gnh recognizes configuration ofp set configurations recognized automaton denoted conf jha reps model 
checking spki sdsi fig automaton accepts yjl pds consists transition rules arrowhookleft arrowhookleft arrowhookleft epsilon automaton shown fig recognizes set configurations assume regular set configurations accepted automaton shown set configurations pre star isalsoregular automaton recognizing pre star constructed adding transitions saturation rule add transitions automaton added arrowhookleft prime prime current automaton add transition theorem letp pds configuration automaton exists automaton pre star recognizes pre star conf pre star constructed time space sum lengths right-hand sides transition rules length right-hand side transition rule arrowhookleft max pds recall automaton fig recognizes set configurations automaton recognizes pre star shown fig transition rule arrowhookleft epsilon self-loop tobeaddedtoa transition rule arrowhookleft fact holds transition added transition rule arrowhookleft inp fact holds transition added automaton shown fig accepts set configurations jha reps model checking spki sdsi fig automaton accepts pre star computing post star pds regular set configurations represented automaton assume transition rule arrowhookleft prime satisfies lessorequalslant assumption involves loss generality pds satisfy constraint converted suppose general pds prime prime prime transition rule arrowhookleft prime wherek greaterorequalslant add control locations replace original rule transition rules arrowhookleft arrowhookleft arrowhookleft arrowhookleft prime assume regular set configurations means automaton automaton post star accepts post star obtained two-phase procedure phase pair prime prime rule form arrowhookleft prime prime primeprime addanewstateq prime prime phase saturation phase phase transitions added automaton rules added symbol fill denotes relation epsilon star epsilon star rules adding transitions arrowhookleft prime epsilon fill current automaton add transition prime epsilon jha reps model checking spki sdsi arrowhookleft prime prime fill current automaton add transition prime prime arrowhookleft prime prime primeprime fill current automaton add prime prime prime prime andthen prime prime primeprime theorem letp pushdown system anda configuration automaton exists automaton post star recognizing post star conf post star constructed time space wheren number pairs prime prime rule form arrowhookleft prime prime primeprime fig automaton accepts fig automaton accepts post star jha reps model checking spki sdsi pds transition rules arrowhookleft arrowhookleft arrowhookleft epsilon automaton shown fig accepts set configurations automaton post star shown fig states states added phase saturation procedure automaton shown fig accepts set configurations model checking linear time logic pwr finite set atomic propositions ltl formula atomic propositions reader consult chapter syntax semantics ltl dagq pds labeling function associates set atomic propositions surface configuration extension set atomic propositions hold configuration interested model-checking problem configuration ltl formula determine satisfies head transition rule arrowhookleft prime surface configuration suppose set pre star equivalently star case path transition system defined pds head repeating star star star vbi star ige star identifying repeating xajm heads hfnj crucial ltl model checking pdss generalize slightly concept illustrated definition assume rpeqij pds set locations configurations rqo prime tvz prime ayi star prime path elv length greaterorequalslant prime passes configuration location set transition rule head called g-repeating exists star set heads g-repeating heads apdsp set locations denoted andr sfn jha reps model checking spki sdsi theorem assume pds set locations set repeating heads computed time space uchi automaton -tuple alphabet set states transition relation initial vbl state set final states set infinite words alphabet denoted vjp infinite word alphabet accepted cbwf exists sequence btt states state appears infinitely sequence sequence states called accepting run chi acceptance condition language accepted chi automaton assume configuration andanltlformula itiswellknown ltl formula atomic propositions exists chi automaton alphabet accepts -regular language efficient algorithms translate ltl formula chi automaton chi automaton ltl formula product pds andb produces chi pushdown system pds augmented chi acceptance condition prime arrowhookleft prime prime prime arrowhookleft prime prime chi pushdown system accepting-run t-n problem problem answering question accepting ysk run starting configuration run visits infinitely configurations control yjl locations ltl model checking answers question pds nnn labeling function configuration agn blu jfif icreator version rev quality smoothing satisfy ltl model checking reduced accepting-run problem construct chi automaton algorithm computing chi automaton ltl formula compute product chi automaton pds respect labeling function configuration violates iff accepting run starting configuration esparza shown accepting run starting iff condition holds pre star star jha reps model checking spki sdsi set g-repeating heads andr star rxs denotes set configurations prime prime prime prime prime prime repeating head set pre star star set configurations run leading configuration prime prime prime prime prime prime repeating head complexity computing repeating heads theorem chi pushdown system product chi automaton apdsp andn thenbp control locations rules gxcg computed time star represented automaton size theorem ltl model checking performed time space ando algorithms ltl model checking pdss time space complexity discussed section spki sdsi pdss section explains connection spki sdsi pdss demonstrates authorization problem variety certificate-set analysis problems viewed model-checking problems pdss assume set certs request assume invalid auth certificates auth certs negationslash removed assume useless certificates removed set keys identifiers denoted construct pds set locations key represents control location stack alphabet square squaresolid stack alphabet set identifiers filled unfilled squares encode delegation bits set transition rules rule arrowhookleft prime iff prime certs correspond transition rules term thetermn corresponds configuration pds ifn thenc epsilon lemma establishes correspondence closure star set certs reachability relation star pds lemma assume set certsc letp pds term terms prime prime star rxs star prime words equality star post star mor jha reps model checking spki sdsi proof jhv mapping icq one-to-one mapping set terms fwq set configurations pds construction prime iff exists rule csuch prime theresult directly definitions fill options solve authorization problem authorized access resource pre star post star proof authorization run pds starts configuration owner square ends configurations set square squaresolid terms pre star post star condition formalized owner square pre star square squaresolid post star owner square square squaresolid negationslash algorithms based conditions referred pre post spki sdsi algorithm section referred spki sdsi based lemma theorem easy prove theorem principal granted authorization access resource algorithm spki sdsi iff algorithm pre grants uan authorization access principal granted authorization access resource algorithm spki sdsi iff algorithm post grants authorization access proof gba algorithm pre checks condition true owner square pre star square squaresolid statement equivalent condition checked post post star owner square square squaresolid lmz negationslash spki sdsi context condition equivalent condition lemma star owner square square squaresolid negationslash question algorithm spki sdsi answers fill jha reps model checking spki sdsi algorithm pre works construct pds set certs set 
configurations square squaresolid construct automaton square squaresolid conf isy algorithm section create automaton pre star grant authorization iff owner square accepted automaton pre star complexity algorithm pre analyzed number states automaton one-to-one correspondence transition rules certs set equal number transitions automaton invoking theorem obtain time space complexity pre notice asymptotic complexity numz clarke obtain algorithm spki sdsi section set configurations shown fig pds xgo case control locations stack alphabet sets owner faculty bob alice square squaresolid transition rules shown fig interested authorization alice key set configurations square mcl squaresolid owner square arrowhookleft facultysquare mjmf arrowhookleft epsilon arrowhookleft epsilon faculty arrowhookleft bob bob arrowhookleft epsilon square arrowhookleft alicesquaresolid alice arrowhookleft epsilon fig set transition rules jha reps model checking zxs spki sdsi fig automaton accepts set configurations pre star square squaresolid configuration automaton accepts defined u-c square squaresolid automaton constructed pre star shown fig note configuration owner square accepted rhv automaton principal alice kwjtk rwl tmz authorized login host describe detail algorithm post construction post star suppose interested determining principal authorized access resource set certificatesc algorithm solving authorization problem construct pds set certs set configurations owner square construct automaton owner square conf iss computing post star transform pds transition rules arrowhookleft prime satisfy lessorequalslant add state prime prime rule right-hand side form prime prime primeprime finally complete construction automaton post star repeatedly applying saturation rule grant authorization iff square squaresolid accepted automaton post star analyze complexity algorithm number states automaton theorem obtain time space complexity post set certs showninfig thepdsp set certsc explicitly constructed fig principal signs certificate lessorequalslant time space complexity post worse pre reasons post interest serve subroutine algorithm ltl model checking answer general class certificate-set-analysis questions section kinds pds modelchecking problems found practice post star works faster pre star remains true certificate-set-analysis problems jha reps model checking spki sdsi recall post star algorithm assumes transition rule arrowhookleft prime satisfies lessorequalslant rule satisfy constraint owner square arrowhookleft facultysquare transform pds adding locations adding rules iii hmt deleting rule owner square arrowhookleft facultysquare faculty arrowhookleft faculty arrowhookleft original transition rules pds stack symbols righthand side square arrowhookleft alicesquaresolid configuration automaton ber accepts set owner square defined etr gml owner square phase construction section automaton components faculty qio alice owner square vzd automaton constructed xwc post xcn star shown fig note configuration squaresolid accepted automaton principal alice authorized login host fig automaton accepts set configurations post star figure andm stand faculty andq rbn alice jha reps model checking spki sdsi certificate-chain reconstruction describe augment automaton constructed algorithm pre extra oes information purpose certificate-chain reconstruction post augmented similarly automaton pre star created adding transitions oes transitions added saturation rule arrowhookleft prime andp prime current automaton add transition oes transition configuration automaton associate structure components integer identifier list transitions oes suppose transition added due pds transition rule arrowhookleft prime fact path prime holds automaton path prime consist possibly empty sequence transitions structure transition arrowhookleft prime identifier pds transition rule denoted collection structures forms dag explain construct certificate chain structures oes dae bha fxy euvr gcx -kl cey fei xcr iws trd kbq hizx mfg edd hlno dgve mkp emu tns jzt mfy irxc kya hmd mrku rgu xfo gqx kpz kyah dfm vqze xwm kxbh ctb jqj zxo gond gyl byeh iwt hvk xzufq muc agd dww mgop ojm pui xohkk pnr kqp utw nmbfv ude utw -ol mkl onw oym zjw nng xzh bim wsf sxcdk iwfk wzq i-m qoj qbuk gkc qim jrn ckt msu ngy bxew -zk -no hyw vmrv -euvy k-c rky uti ecmk mgt fxw kmq r-v exo bvig mvy xoj wgvfbo ffc inmb gru jdqe wisq fww asn kmf eym ufa muq xkq uom grn cki ckw vos jvzu ictfvf asc mumkp ixg ixg ixg yuo opo rxs rxs mor jhv icq fwq xxs kxnn unw ylt ppr hkrej bey kck pes -of yxws u-o yui ggg shzm mye lyd uew oam yiq ogee zwi wwqn weu fwj mzum fhne heh dgbu z-wt vqn kwy zhduxm yqy mnf hoda eih qvrruq mst zxah bvi jqi vmj f-iz qke xri dhlf fpk txs iua sis wzu pkk iwi xkt qip mgk mrmr mbi vzv fmm jmct hlse xin gwj cky ilbyo ciedr mej oan jsa yme pkk mkn wxo iga euu wsqpn kgwk dkwssu sqa vry xxhsi jeh umkp uomgm symeu wcc xef elm sfrx ucp eow fxm ihx wit mbo jcww idn nbub ffbi oay akeri rxk zijcogsr h-x gnn xxx vzv aih dla ykw lud tcy esnw gtkh msw qnn kqi sgk htov ynu -zkmm gxi vun uaet indkke teeu kif vzt sph bmv xwd exr imqs j-o prk ojmr utxtu ckm phs iuo -om szg eab imz bti lgm zle n-irfnvssq kksjmh mot tmv txo ndo ime ims ykv rko kki oywz igs iqx dqy hvf vokk rex oqu zhb coq hwge xck usc ivv n-db sxkn jona txo vvpg r-r kil vmg mqk kuyg wsxi qce fex imr uue iqsb jzo mki xlm jcww xcgm mlj mwt msr section final configuration automaton fig structures transitions automation fig shown fig empty structure empty list denoted epsilon null request succeeds final configuration automaton pre star square squaresolid transition owner square automaton accepting state pre star algorithm extended certificate chain request obtained auxiliary structure owner square final configuration automaton instance fig transition owner square structure certificate-chain reconstruction performed flattening dag rooted produce preorder listing repetitions rule identifiers dag symbol denote list concatenation structure epsilon flatten structure null flatten method information recover certificate chain general associate set pairs automaton transition pair consists integer identifier rule list transitions path automaton pair set transition represents rxs saturation rule derive recover dag certificate gxcg chains jha reps model checking spki sdsi transition structure square epsilon squaresolid epsilon alice null bob null null null square faculty owner square rxs fig structures transitions automaton shown fig structure mor flatten flatten jhv icq flatten flattening dag fwq create list exponentially larger size dag practice system manipulate certificate dags directly fig flatten whichproves alice proper authorization request threshold subjects document defines spki uan sdsi gba additional kind subject auth certs threshold subject subject form lessorequalslant lessorequalslant thevaluek threshold threshold subject specifies subjects spki sdsi defining document lmz permits threshold subjects auth certs clarke restrict auth certs section observing reason threshold subject cert cert define set public keys cert threshold subject subject notion generalized set keys set sets keys surely convoluted usable practice section adopt restriction section auth cert threshold subject square square certificate-set analysis certificates threshold subjects certs handled model checking alternating pushdown systems jha reps model checking spki sdsi normalized introducing keys serve placeholders replacing rule set rules square square square square square square square square right-hand side rule usedsquaresolid rules form square squaresolid usual determine principal authorization access start configuration automaton accepts language square squaresolid check owner square accepted final configuration automaton pre star algorithm changed implement saturation rules arrowhookleft prime prime current automaton add transition square arrowhookleft square andtherearek transitions form square current automaton add numz transition square initial configuration automaton transitions labeled square squaresolid final state transitions added labeled squaresolid andwhen transitions added label square xgo final state symbols transitions form squaresolid square contribute saturation steps type pre star algorithm maintain counter threshold mcl rule counters initialized algorithm identify mjmf time transition form squaresolid square generated point counter rule incremented transition square generated counter reaches costs time space perform operations dominated costs pre star algorithm change complexity certificate-set analysis algorithm pre handling multiple requests certificate-set-analysis problems multiple requests shared access compromisation assessment section describe authorization framework extended handle multiple requests assume requests remove useless certificates invalid auth certificates removed set jha reps model checking spki sdsi encoding multiple requests cert corresponds rewrite rule form auth cert generate rewrite rule auth cert perform steps lessorequalslant lessorequalslant generate rewrite rule braceleftbigg square square square squaresolid end essentially square squaresolid represent access resource delegation set rewrite rules generated algorithm denoted pds note stack alphabet square square squaresolid squaresolid algorithms pre post zxs extended handle multiple requests pre compute set configurations pre star parenleftbigg uniondisplay square u-c squaresolid parenrightbigg request granted iff owner square set similarly post compute post star parenleftbigg uniondisplay owner rhv square parenrightbigg request granted iff square squaresolid set discuss time space complexity extended algorithms sets auth certs kwjtk auth cert 
generate rewrite rules request size set bounded time space complexity algorithm pre similarly time space complexity algorithm post cases efficient running algorithms times request basic intuition work processing set certs shared requests processed simultaneously algorithm performs saturation steps due solely certs jha reps model checking spki sdsi note multiple requests handled name-reduction-closurebased algorithm clarke compute name-reduction closure sharp set remove rules sharp form prime square primeprime square prime square primeprime squaresolid partition rules sets wherec rules form prime square primeprime square prime square primeprime squaresolid intuitively rules pertaining request validity request determined depth-first-search algorithm earlier rules construct directed graph certificate-set-analysis problems section discusses applications model checking specific certificate-setanalysis problems show model checking furnishes algorithms analysis problems listed introduction term model checking problem checking pds satisfies ltl formula problem answering simple forward backward reachability queries stated terms set-former expressions basic automaton-building operations pre post set certs set configurations write pre star aspre star similarly post star written post star analysis problems involving multiple resources encoding section authorized access resource principal isk authorized access owner fill pre fill squaresolid alternatively fill squaresolid post owner fill negationslash authorized access resource necessarily principal authorized access owner fill pre square squaresolid alternatively square squaresolid post owner fill negationslash expression squaredenotes term obtained concatenating square authorized access resource names authorized access post owner fill jha reps model checking spki sdsi shared access resources principals access square squaresolid post star owner square square squaresolid post star owner square shared access principals resource access question answered checking set square squaresolid post star owner square shared access principals finite set resources resources accessed braceleftbigg vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle owner fill parenleftbigg pre uniontext fill squaresolid pre uniontext fill squaresolid compromisation assessment resources finite set principal gained access solely due presence maliciously accidentally issued certificate set prime braceleftbigg vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle owner fill parenleftbigg pre star uniontext fill squaresolid pre star prime uniontext fill squaresolid compromisation assessment principals gained access resource solely due presence maliciously accidentally issued certificate set prime square squaresolid post star owner square square squaresolid post star prime owner square expiration vulnerability resources finite set resources principal prevented accessing certificate set prime expires compromisation assessment expiration vulnerability principals excluded accessing resource certificate set prime cexpires compromisation assessment jha reps model checking spki sdsi universally guarded access case authorizations issued resource involve certificate signed principal ltl model checking labeling defined surface configurations involve location labeled atomic proposition surface configurations prime rwl tmz hmt ber etr gml qio vzd xwc xcn rbn oes oes oes oes oes dae bha fxy euvr kke xge riw iwiqm teeu nlw uxw hrh wwm jwv qso znq gcmw zxb j-k woov tanueg hti ghqt ssoin rpvu xst rwn isnnir ilo -lvf kql miv ddv qua yms usmmcs xop emu ogo oqs xkqtw mci qwk qep ome tjke yll pms vsm lew fuq nkiuh kgo muj nvh lkw bky fill prime squaresolid prime arelabeled atomic proposition configuration owner square satisfies ltl formula fill fill ltl formula describes types runs pds runs true globally run represent chains authorized access resource runs true true true represent chains principal receive authorization certificate issued principal utilized universally guarded access case authorizations grant principal prime access finite set resources involve certificate signed ltl formula case labeling defined surface configurations involve location labeled atomic proposition surface configurations form prime fill prime squaresolid labeled atomic proposition surface configuration form owner fill satisfies ltl formula efficiency automaton representation clarke give worst case name-reduction-closure algorithm illustrate efficiency automaton representation set configurations set certificates lessorequalslant lessorequalslant mod lessorequalslant jha reps model checking spki sdsi rules represents string length name-reduction closure yields rules lessorequalslant lessorequalslant lessorequalslant lessorequalslant lessorequalslant nand lessorequalslant pds set certificates itistruethat post star equal set configurations lessorequalslant lessorequalslant lessorequalslant lessorequalslant size set post star automaton representation post star size basic idea pair keys stack configuration configuration post star iff automaton representation commonalities captured means sharing automaton accepting set configurations post star states represent stack configurations locations representing keys haveepsilon -edges a-edges pointing shared states provide worst-case pds-based algorithm backward algorithm pre star one-to-one correspondence pdss spki sdsi system worst-case easily recast terms certificates pds transitions lessorequalslant arrowhookleft mod epsilon arrowhookleft thesizeofthepdsp suppose compute pre star epsilon epsilon -rules create cycle locations rule turns automaton clique resulting automaton transitions pre star algorithm time automaton transition created ways semiring labelings section discusses annotating pds configuration automaton labels bounded idempotent semiring answer questions long specific authorization trust level authorization describes alternative handle authorization specifications advantages previous proposals stefan schwoon providing complete treatment subject including justification extensions algorithm pre certificate-chain reconstruction found jha reps model checking spki sdsi definition quintuple set elements combine operation extend operation binary operations commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal iff infinite descending chains cert set annotated label semiring pds transition rule pds label cert recall algorithm pre constructs automaton pre star set configurations square squaresolid start automaton accepts set configurations transition automaton labeled element semiring denoted initially transitions labeled add transitions toa saturation rule arrowhookleft prime path string prime cost current automaton introduce transition automaton transition change label occurs automaton label transition computed transition cost path automaton computed taking labels transitions path semirings cases discussed shown table certificate chains maximal trust levels problem certificate assigned trust level issuer certificate intuitively denotes confidence issuer relationship expressed certificate elements semiring represent trust levels low medium high trust levels denoted andh fourth added jha reps model checking spki sdsi table semirings trust validity trust intersectionsqunionsqzh validity maxmin element andh form totally ordered set supersetsqequal supersetsqequal supersetsqequal semiring operations correspond join unionsq meet intersectionsq onthe totally ordered set unionsq braceleftbigg supersetsqequal intersectionsq braceleftbig supersetsqequal referring back section final automaton fig trust level drawn assigned certificate labels transition owner square automaton constructed algorithm pre represents trust level alice authorization answer reported monitor resource make authorization decisions labels owner square represents trust level certificate chain trust ordering supersetsqequal supersetsqequal supersetsqequal lower ordering corresponds higher level trust sense everyday speech instance label owner square exists certificate chain chain justifies granting authorization alice chain labels maximally valid certificate chains expiration cert cert expire time current current current time expiration certificate chain ismin suppose alice login host alice certificate chain valid minutes logged host minutes alice find certificate chain authorizes login maximum expiration certificate chains captured semiring max min label cert interval representing validity period label transition owner square automaton produced algorithm pre authorization alice login host valid time units 
monitor information log alice time units note highest level trust denoted element lowest total order infinite descending chains operations performed min max finite number values arise run saturation process semiring-labeling framework applies jha reps model checking spki sdsi authorization specifications semirings semiring-labeling framework approach handling authorization specifications auth certs earlier clarke imposed step auth cert removed include authorization specification prime request certificates retained prime step addition removes auth cert expired validity specification approach significant drawback handle situations proof authorization requires multiple certificate chains set certificate chains dag certificates path certificate chain proves part required authorization instance certificate set dir afs wisc public tmp read dir afs wisc public tmp write suppose alice makes request dir afs wisc public tmp set read write case chain authorizes alice read directory afs wisc public tmp separate chain authorizes write afs wisc public tmp prove read write privileges afs wisc public tmp certificates removed certificate set prior running certificatechain discovery algorithm read negationslash set read write write negationslash set read write proof authorization alice request found basis observation mitchell -tuple reduction rule incomplete speaks certificate chains refers finding correct list reductions appears imply single path carl ellison confirmed scenario requires justification set certificate chains dag certificates reasonable noted justification k-of-m threshold subjects requires set dag jha reps model checking spki sdsi table semiring authorization authorization resources resources semiring-labeling framework overcomes problems provided spki sdsi authorization specifications form bounded idempotent semiring semiring values shown table certificate-set analysis performed techniques generalized pushdown reachability weighted pdss developed auth certs expired validity specification removed generalized pushdown reachability algorithm run remaining certificates starting configuration automaton accepts language square squaresolid weighted configuration automaton constructed transition owner dir afs wisc public tmp square weight set read write alice read write request authorized algorithm identifying set certificate-chains justify authorization return set noted number semirings formally cross-product semiring elements tuples component semiring computed pointwise distributed authorization section describes automaton-based approach advantages distributed authorization problems subject on-going work sketched emphasize potential advantage approach certificate-set analysis paper computer sciences department uw-madison college letters sciences departments biology suppose resource accessible faculty department belongs owner issue cert owner square facultysquare system administrator issue set certs noted earlier acceptable infinite descending chains long finite number values arise run saturation process set resources finite infinite cardinality authorization specifications set certificates finite number sets durations valid certificates roots treestructured file hierarchies finite number values arise saturation jha reps model checking spki sdsi faculty faculty faculty bio faculty certs departments system administrator issue set certs faculty certs faculty members students certs students determine principal authorized access resource clarke setting compute name-reduction closure set certs proceed realistic setting sizes sets large computing closure union require significant time space algorithms presented paper automaton-based distributed setting automaton-based approach enjoy advantages approach clarke work partitioned authorization question determined distributed manner automata computed separate sites information shipped sites form automata instance compute sets post star owner square pre star square squaresolid intersection non-empty standard operation automata granted authorization similar operation answer authorization questions departments bio independent name-reduction closures yield certificates procedure proposed clarke provide basis savings distributed authorization-resolution procedure technical conditions hold approach correct principal refer local domain certs organized hierarchically issues subject on-going work jha reps model checking spki sdsi related work algorithm spki sdsi proposed clarke algorithm based idea computing namereduction closure certificate set algorithm role-based trust management language presented feature distinguishes work papers automatonbased model-checking techniques theory model checking pushdown systems present paper shown techniques pds model-checking literature solve problem discovering certificate chains provide answers broad array questions pose set spki sdsi certificates striking differences approach previous work pds-based algorithms compute actual closure certificate set name-reduction closure authorized access section general closure certificate set infinite set regular set fact aware observing authorization literature represented finite-state automaton fair amount research exists formal semantics spki sdsi research geared giving formal semantics local spaces tuple-reduction rules spki sdsi spki sdsi-to-pds connection presented paper alternative semantics spki sdsi names spki sdsi space identified configurations transition system defined pds compared existing work spki sdsi-topds connection advantages semantic account number aspects spki sdsi leverages substantial body research exists subject model-checking pdss immediately obtains polynomial-time algorithms number certificate-set analysis problems standard logic ltl answer general class certificateset-analysis questions queries answered time polynomial size certificate set model-checking problem context-free processes addressed context-free processes viewed pushdown systems single control location benedikt showed pushdown systems equivalent unrestricted version hierarchical state machines hsms introduced restricted form alur yannakakis hierarchical means system consists state machines call unrestricted hsms recursive calls machines benedikt gave algorithms ltl constant proportionality exponential size formula types verification problems based ltl model checking formulas interest small jha reps model checking spki sdsi ctl model checking unrestricted hsms similar algorithms ltl model checking developed independently contemporaneously alur acknowledgements grateful stefan schwoon discussions subject paper careful reviews suggestions improvement made referees greatly appreciated abadi sdsi linked local spaces journal computer security alur etessami yannakakis analysis recursive state machines proc computeraided verif alur yannakakis model checking hierarchical state machines volume software engineering notes york acm press benedikt godefroid reps model checking unrestricted hierarchical state machines icalp blaze feigenbaum ioannidis keromytis keynote trust-management system version rfc september blaze feigenbaum ioannidis keromytis role trust management distributed systems security secure internet programming security issues mobile distributed objects vitek jensen eds lncs bookandf otto string-rewriting systems springer bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur volume lec notes comp sci springer-verlag chi finite automata algebras grammars springer burkart steffen model checking context-free processes proc concur volume lec notes comp sci springer-verlag caucal regular structure prefix rewriting theoretical computer science clarke elien ellison fredette morcos rivest certficate chain discovery spki sdsi journal computer security clarke grumberg peled model checking mit press elien certificate discovery spki sdsi certificates master thesis massachusetts institute technology ellison personal communication jha reps schwoon april ellison frantz lampson rivest thomas ylonen spki certificate theory rfc september esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proc computer-aided verif volume lec notes comp sci springer-verlag jha reps model checking spki sdsi 
gerth peled vardi wolper simple on-the-fly automatic verification linear temporal logic protocol specification testing verification chapman hall warsaw poland halpern meyden logical reconstruction spki proceedings ieee computer security foundations workshop ieee computer society press howell kotz formal semantics spki technical report department computer science dartmouth college hanover march knoop demand-driven model checking context-free processes proc asian comp sci conf volume lec notes comp sci thiagarajan yap eds springer-verlag mitchell understanding spki sdsi first-order logic comp sec found workshop ieee comp soc wash winsborough mitchell distributed credential chain discovery trust management journal computer security local names spki sdsi proceedings ieee computer security foundations workshop schwoon model-checking pushdown systems phd thesis munich munich germany july schwoon jha reps stubblebine generalized authorization problems comp sec found workshop ieee comp soc wash weeks understanding trust management systems proceedings ieee symposium research security privacy research security privacy oakland ieee computer society technical committee security privacy ieee computer society press 
yig xgb dscs smke gsk tsi tmf uiz kmj xws dro iqy mui dkk kxz uxa eys riv gmkmf zzi yeeq -euvy -v-r dknv mji qmqo twk isq onxn bqi tyu ags u-wf aqu kie mqb xsz gmsjm mnsk br-voro kmahs giqh maz cyr jwz xnm bvig sqw tkh qmk pjq urdhet iek kxgd mgn nrv xnm iur mipa zgv exo mko akop -nt msl cto lkm occ jph exx yiz dwe yldp wiw skz rmz iwf xrm tzv -aky img xwt wfrar -ukk vmn iyc zmv mwf ksti sot puky oto urn kkkf oky cqci mwi mih jzl xxy vcn zxc syn icel wopn idm idwwf vuo utp hqj ifi irc gmcs u-wf hbi n-d znu gxf xeir iwm rjt bcq kfb vem ffq wdl axq pjmr owo gvn hxjjy xwt yjz -ci tie yoka ivvvra eha xwe hcoq llj ens hgx sgml mct xol gwon gto xst oou ksq wzu qea zzw mor yfv ssi euirc osq sto vry gan lnb wfr kki plr ayu cow vqk myt ito eoi eoi eoi iov zyi zls gwh kidm wvi ikzq cvy tep ueq wpx wfr msk ducf hzl caz oij iif yzf xsg eyiq lph lxg msr hs- ywr gdk jzi kup hto rxn gyw isx iuf ysa gml weub bqs dnmio nmk yew nmz wyb sds cako siq eyso yvb ggw ast yno bwk ydf jzw mkj jzw mkj jzw mkj jzw mkj kkr furst fqn xwu lvx tfxe sms njnny ijg gae yuus nmc umg fyk -wm jwn ugv zvq scnn qgq kqv rgw vqcsq hwt epy zvt jom akn tcfx ngo vms vms cjzo -zg rhw geu vpk sfw xbm sfw xbm sfw xbm sfw xbm sfw xbm sfw xvk rdy eyy x-f hmb wig khd kya oul ywy sur hzv ocq -eng xii iim nwp pis snuc zjrn wrtd vit ayj yrdy mwi u-w hpi rtkb gkfz hlz uax qop qew yhc fug goguu iko uuy mkm rwq donw kkiop lubz cvb vew kivj rwv aic rio umw iommo kso rqp gqe idp eoa jqj ddn okq nrk xfws euo r-qc xwn yav oml gmo hzv yvt qvs wos slfh kci qsjj ppi zkh wyn vwh iaa fpq wuq jfj jqiip vic xmo tuduvr xzw -uiu cua fxow ilr odqco rxgq xse tqg tqg tqg tqg tqg tqg tqg jfif icreator version rev quality smoothing rxs gxcg rxs mor jhv icq fwq uan gba lmz numz xgo mcl mjmf zxs u-c rhv kwjtk rwl tmz hmt ber etr gml qio vzd xwc xcn rbn oes oes oes oes oes dae bha fxy euvr gcx -kl cey fei xcr iws trd kbq hizx mfg edd hlno dgve mkp emu tns jzt mfy irxc 
kya hmd mrku rgu xfo gqx kpz kyah dfm vqze xwm kxbh ctb jqj zxo gond gyl byeh iwt hvk xzufq muc agd dww mgop ojm pui xohkk pnr kqp utw nmbfv ude suq qky syv mog tyc ggoe kui ssz wzq ruh hwj lku qmy gkc kit mkm sma ham mre ouj xmc ynnf ixb ywoo vhk att jpa pyrl msw cefnt izv art rwq n-d hvh -euvy k-c yck xkq kamu rmum dev dun ywv mcg moj ztm oqo sey bxk wgvfbo ffc inmb gru jdqe wisq fww asn kmf eym ufa muq xkq uom mrir gsc ofy kkh bcp axk sue tcvj psm j-g xyh -gd soi pjww sqi fjv xor nkh xtu ljdk qke suo xsf khn fhou kqq hze thf xoj awu yro mgb drg xpl tvz wkw ynq jfif icreator version rev quality smoothing rxs rxs mor jhv icq fwq xxs kxnn unw ylt ppr hkrej bey kck pes -of yxws u-o yui ggg shzm mye lyd uew oam yiq ogee zwi wwqn weu fwj mzum fhne heh dgbu z-wt vqn kwy zhduxm yqy mnf hoda eih qvrruq jqi mat vgy nvo yo-n skf kkg obm usj sqp tmc akm iuo bjnn oee yuh gko kec xfk jbb bde gmk gkx vkc idw u-y behxc mfm rzi qmf iwl mwe vwo sui irq rmifi omjid oyk wnr uqe onh feq ogo kcld xcs occ xou mtc mku iso wbt wsgy -nmt snx fvow zzxz lno aga tavu knk woh zyzi flk gri sev rpf cis usc bdd w-k nim kwz ekoo yzm nnat yul ymk htsw msw wih -sz akc xxe ds- xvo nko kwv kvp vzo ikj kqm nmo mxt oug ain zys 
undecidability context-sensitive data-dependence analysis thomas reps wisconsin anumber program-analysis problems tackled transforming kinds graph-reachability problems labeled directed graphs edge labels filter paths interest path vertex vertex counts valid connection word spelled language languages filtering purposes languages matching parentheses insome cases matched-parenthesis condition filter paths mismatched calls returns leads so-called context-sensitive program analyses context-sensitive interprocedural slicing contextsensitive interprocedural dataflowanalysis inother cases matched-parenthesis condition capture graph-theoretic analog mccarthy srules car cons cdr cons code fragment cons car fact structure-transmitted data dependence iscaptured graph avertexfor variable edge vertex vertex right-hand side assignment iii parentheses match labels edges run parentheses match labels edges run structure-transmitted data-dependence analysis context-insensitive constraints filter paths mismatched calls returns natural question twokinds parentheses combined create context-sensitive analysis structure-transmitted data dependences paper answers question negative ingeneral problem context-sensitive structure-transmitted data-dependence analysis undecidable results paper imply general context-sensitive set-based analysis -cfa data constructors selectors account undecidable categories subject descriptors programming languages processors compilers optimization mathematical logic formal languages mathematical logic computability theory mathematical logic formal languages formal languages decision problems discrete mathematics graph theory path circuit problems general terms languages theory additional key words phrases context-sensitive program analysis dependence analysis graph-reachability problem structure-transmitted data dependence set-based analysis set constraints control-flowanalysis -cfa linear matched-parenthesis language work supported part national science foundation grants ccrand ccrby united states-israel binational science foundation grant grant ibm vilas associate award wisconsin government authorized reproduce distribute reprints governmental purposes notwithstanding anycopyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government author saddress computer sciences department wisconsin dayton madison e-mail reps wisc introduction anumber program-analysis problems tackled transforming kinds graphreachability problems labeled directed graphs ordinary reachability transitive closure generalization edge labels effect filter paths interest path vertex vertex counts valid connection word spelled concatenation order ofthe labels edges isinacertain language definition language overalphabet graph edges labeled members path defines word word obtained concatenating order labels edges path apath l-path word member instance single-source single-target l-path problem asks exists l-path givensource vertex giventarget vertex family languages language overalphabet aninstance l-reachability problem l-path problem instance family languages defn context-free languages cflreachability problem graph context-free grammar shown note matched isthe context-free language consists strings matched parentheses square brackets interspersed matched matched matched matched matched graph matched -path path cycle generates word eee anumber program-analysis problems viewed instances cfl-reachability problem program-analysis problems languages filtering purposes languages matching parentheses cases matched-parenthesis condition filter paths mismatched calls returns order implement so-called context-sensitive program analyses cfl-reachability context-sensitive program analysis opposed ordinary graph reachability isillustrated paper word parentheses generic sense anykind matching delimiter round parentheses square brackets curly braces angle brackets specific sense round parentheses clear context twomeanings intended syntax examples augmented operator cons denotes pairing constructor operators car cdr select components pair operator atom constructs atomic object null givenstring notation simplify storage-allocation operations expressed examples operators imply results apply analysis lisp programs annotated source code data-dependence graph int void void enter exit enter exit call call outx outy diagram shows program sdata-dependence graph strictly speaking large ovoid shapes rectangular boxes labeled call enter exit part data-dependence graph twoovoids elements belong procedure rectangular boxes provide context control points program vertices directed edge graph represents data dependence flowdependence edge vertex vertex produced vertex instance edge dependence graph procedure execution statement case program procedure parameters data-dependence graphs reflect nonstandard treatment global variables global variable treated hidden value-result parameter subsequent return passed scope special scope-transfer variables interprocedural datadependence edge represents passing scope scope call note data-dependence edges dependences transmitted caller callee labeled symbols data-dependence edges dependences transmitted callee back caller labeled symbols data-dependence edges represent passed scope scope call labeled datadependence edges represent passed scope scope call labeled likewise data-dependence edges represent passed back scope scope twocalls finish labeled data-dependence graphs vertices correspond annotations program annotations denoted comments interested givenvariable givenpoint program comments give rise vertices acontext-insensitive analysis tracks dependences constants variables program report depends reason context-insensitive analysis ignores fact paths possibly feasible execution paths returns matched calls forinstance existence mismatched path graph shown serves evidence depends contrast context-sensitive analysis reports transmissions values paths returns matched calls forthis reports depends butnot depends butnot context-sensitive analysis expressed cfl-reachability problem respect language matched indexedcurly braces path valid connection label interprocedural data-dependence edge represents transfer entered call site match label edge represents transfer back return performed call originated call site hand matches matched path count valid connection path serves evidence problems cfl-reachability devise context-sensitive program analyses include interprocedural slicing interprocedural dataflowanalysis cfl-reachability amatched-parenthesis constraint capture graph-theoretic analog mccarthy srules car cons cdr cons illustrated program illustrates cfl-reachability context-insensitive structure-transmitted data-dependence analysis unfortunate clash terminology reader aware term context-sensitive analysis standard programming-languages community means static-analysis method analysis called procedure sensitive tothe context called context-sensitive analysis captures fact call sites call procedure effects program spossible execution states context-sensitive analysis confused context-sensitive languages formal-language theory principle context-free-language reachability formalizing approaches context-sensitive analysis fully articulated term context-sensitive analysis adopted programming-languages community annotated source code data-dependence graph list void cons null null car null cons null car null car null car car car enter exit cons null cons null null null graph labels data-dependence edges serveadifferent purpose labels edge labeled corresponds data construction position cons anedge labeled corresponds data construction position cons anedge labeled corresponds selection car anedge labeled corresponds selection cdr matched-parenthesis path null cons null null cons null car car null serves evidence null path null cons null null cons null car serveasevidence null occurrence matching fact matched-parenthesis path null context-insensitive structure-transmitted data-dependence analysis conclude null structure-transmitted data-dependence analyses givenin context-insensitive constraints filter paths mismatched calls returns natural question twokinds matching delimiters illustrated examples combined create context-sensitive analysis structure-transmitted data dependences interprocedural variation illustrates hope gain context-sensitive structure-transmitted data-dependence analysis program list void car void cons null null null cons null null null relevant portions program sdata-dependence graph shown enter enter exit exit car cons null cons null null null call call call outx outx outy outy forthis context-sensitive analysis report variable null path null program point serves evidence null null cons null null cons null car 
car contrast context-insensitive analysis path null program point evidence null null cons null null cons null car car problem path mismatch labels edge subsequent edge path excluded consideration context-sensitive analysis fact note path symbols match symbols symbols match symbols twopatterns matched symbols interleaved observation serves motivate study languages carried sections paper shows impossible create algorithm captures interleaved matched-parenthesis paths kind illustrated general problem context-sensitive structure-transmitted data-dependence analysis undecidable words capture matching calls returns car cons cancellation simultaneously inany amount time algorithms compute approximate safe solutions problem terms programming-language features needed result apply higher-order functions required main result paper implies context-sensitive structure-transmitted data-dependence analysis undecidable first-order languages functional imperative result applies languages java scheme manyothers noted questions kind posed givenvariable givenvalue point program turn undecidable general form independent reasons whythe problem undecidable itisundecidable givenstatement everexecuted undecidable givenpath everexecuted paper shows context-sensitive structure-transmitted data-dependence analysis undecidable evenifaconservative approximation made manyother program-analysis problems overcomes sources undecidability weassume paths procedure scontrol-flow graph executable remainder paper organized sections undecidability result shown reduction variant post scorrespondence problem pcp section defines pcp discusses variant suited motivates interest languages interleavedpatterns matching delimiters section shows set l-path problem instances language strings formed interleaving twolanguages matching parentheses undein paper term interleaved restricted sense compared standard usage formal-language theory exact nature patterns matched symbols allowed woventogether defined precisely sections cidable section relates result section tothe undecidability context-sensitive structuretransmitted data-dependence analysis section discusses results imply programanalysis problems avariant post correspondence problem undecidability result shown reduction variant post scorrespondence problem definition instance post scorrespondence problem orpcp consists twolists strings consist strings instance pcp solution exists nonempty sequence integers wehav xij xim yij yim instance pcp instance pcp solution pcp undecidable proofs hopcroft ullman lewis papadimitriou harrison forour purposes convenient work variant pcp definition parenthesis-pcp givenaninstance pcp define instance parenthesis-pcp orp-pcp yrk string equal replaced replaced string equal replaced replaced superscript onastring denotes reversed string asolution instance p-pcp defined aid linear context-free grammar balanced balanced balanced instance p-pcp solution exists nonempty sequence integers wehav xij xim yrim yrij yri yri balanced instance p-pcp corresponds linear context-free grammar nonterminal appears right-hand side production instance p-pcp solution balanced instance pcp solution instance p-pcp solution foragiv eninstance p-pcp yrk ery solution exists corresponds string language generated linear context-free grammar yri yri string corresponds solution strings balanced correspond solution giveninstance p-pcp solution language balanced isnon-empty observation implies theorem theorem undecidable arbitrary linear context-free grammarsg empty fact existence solution giveninstance p-pcp characterized nonemptiness intersection twolinear context-free grammars underlies result undecidability context-sensitive data-dependence analysis purpose investigating problem develop slightly elaborate characterizing solutions instance p-pcp definition instance p-pcp yrk solution wesay string exhibits solution taggedform xim yrim yri yri general suppose issome nonempty sequence integers wehav reg ardless solution instance p-pcp wesay string form yri yrij yri yri exhibits candidate solution taggedform forinstance sequence solution string exhibits candidate solution tagged form asolution tagged form contrast string exhibits candidate solution tagged form solution tagged form fortechnical reasons details constructions giveninsections work slight variants forinstance section weuse version occurrence isimmediately preceded occurrences symbol occurrence immediately twooccurrences undecidable familyofl-pathproblem instances section showhow toformulate p-pcp graph-theoretic terms weconstruct undecidable family l-path problem instances problem instance corresponds instance p-pcp remainder paper weassume givenafixed arbitrary instance p-pcp consisting pairs strings yrk interest p-pcp motivated fact string exhibits p-pcp solution tagged form twointerleavedpatterns matched delimiters string xij xim yrim yrij yri yri balanced string balanced language balanced strings made defined linear context-free grammar balanced balanced important note general string exhibits p-pcp solution tagged form balancing processes sync instance prefix string symbol match seventh-from-last symbol capture structure p-pcp solutions tagged form intersection twolinear context-free languages language consists strings balanced arbitrary number symbols form interspersed open-parenthesis open-bracket symbols arbitrary number symbols form interspersed close-parenthesis close-bracket symbols language consists candidate solutions tagged form giveninstance p-pcp yri yri languages capture twointerleavedpatterns matched delimiters noted consists candidate solutions tagged form giveninstance p-pcp consists strings symbols excluded left string balanced language consists solutions tagged form instance p-pcp instance strings string similar observed language balanced giveninstance p-pcp solution language isnon-empty showhow toconstruct graph twodistinguished vertices -path giveninstance p-pcp solution fig shows schematic diagram illustrates construction foraninstance p-pcp yrj yrk graph regions form call left part region x-string segment part yr-string segment note jth x-string segment begins sequence jth yr-string segment ends rkxk figure aschematic diagram graph constructed instance p-pcp yrj yrk sequence dotted edges labeled outsides fig servetoconnect x-string segment x-string segments yr-string segment yr-string segments anynumber x-string segments concatenated form path anyorder howev segment labeled word path symbol similarly number yr-string segments concatenated form path anyorder segment labeled word path symbol fact edges fig dotted special significance theyare displayed highlight fact edges correspond interprocedural data-dependence edges dependence graphs correspondence made clear section fig edges labeled path pass x-string segment yr-string segment -edge path extended yr-string segments paths form number x-string segments number yr-string segments reason remark made footnote word path occurrence isimmediately preceded twooccurrences symbol occurrence immediately twooccurrences technically definition candidate p-pcp solution tagged form changed occurrence ingrammars replaced occurrence replaced observethat ifthere -path solution instance p-pcp read offfrom word reading p-pcp solution tagged form ifthe instance p-pcp solution find -path edge choosing x-string segments order xim generating subpath word xim iii -edge ithm x-string segment ithm yr-string segment choosing yr-string segments order yrim yri yri yri generating subpath word yrim yrij yri yri edge word path exhibits solution instance p-pcp tagged form modulo extra occurrences observed earlier consists solutions tagged form giveninstance p-pcp path constructed isanl -path call graph constructed manner p-pcp graph case instance p-pcp introduced p-pcp graph shown fig observations prove lemma lemma instance p-pcp grammarss p-pcp graph thereisanl -path instance p-pcp solution undecidability context-sensitive structure-transmitted data-dependence analysis section showhow slight modification construction presented previous section implies impossible create precise algorithm context-sensitive structure-transmitted data-dependence analysis weconstruct family programs data-dependence graphs encode p-pcp graphs figure p-pcp graph constructed instance p-pcp giveninexample graph -path word instance p-pcp giveninexample solution forinstance fig shows program fragment data-dependence graph fig corresponds instance p-pcp giveninexample acontext-sensitive structure-transmitted data-dependence analysis report variable atom program point corresponds fact instance 
p-pcp solution fig symbols correspond data dependences call procedure procedure return symbol corresponds data construction position cons symbol corresponds data construction position cons symbol corresponds selection car symbol corresponds selection cdr data dependences calls procedure labeled symbols form data dependences returns labeled symbol corresponds data dependence occurs recursive call finally bypassed inspecting fig reader mind left-to-right encoding string astring consists open parentheses closed parentheses corresponds working sway occurrence expression encodes string idea illustrated figs carries overtoall instances p-pcp general pair strings yrj encoded procedure form list void cons null cons cons null cons null null encodes car cdr encodes void cons null cons cons null null encodes car cdr cdr encodes void cons null cons null cons null encodes car cdr cdr cdr cdr car cdr encodes void void main atom special program atom figure program scheme constructed instance p-pcp giveninexample relevant part program sdata-dependence graph shown fig role labels issimilar inthat kinds parenthesis pairs encode procedure call return introduced separate symbols emphasize fact calls procedure play role construction calls procedures void cons construction expression encoding car cdr selection expression encoding yrj procedure form void fkelse procedure main fig undecidability context-sensitive structure-transmitted data-dependence analysis properties data-dependence graph program form givenabove isvery likethe pcp graph giveninstance p-pcp fig variable atom program point path word language similar balanced forinstance portion data-dependence graph shown fig program giveninfig identical p-pcp graph shown fig dotted edges calls returns hav labels form path language interest identifying context-sensitive structure-transmitted data dependences nowincorporate labels formally accomplished -paths grammars defined yri yri change notion p-pcp solution tagged form occurrence innermost immediately occurrence occurrence yri innermost immediately preceded occurrence elements omitted data-dependence graph shown fig concern dependences null irrelevant question atom flows program embedding p-pcp graphs data-dependence graphs atom main figure relevant parts data-dependence graph program shown fig corresponds pcp graph shown fig dotted edges nowhav labels form argument prove lemma -path datadependence graph giveninstance p-pcp solution context-sensitive structure-transmitted data-dependence analysis determine atom program point giveninstance p-pcp solution context-sensitive structure-transmitted data-dependence analysis undecidable analgorithm context-sensitive structure-transmitted data-dependence analysis exist conclusions implications program-analysis frameworks earlier work author colleagues demonstrated usefulness formulating programanalysis problems terms graph-reachability questions approach obtain number positive results program-analysis problems specifically polynomial-time algorithms solving variety problems present paper demonstrates viewpoint valuable standpoint obtaining negative results program-analysis problems undecidability result paper concerns situation twointerleavedpatterns matching events viewed broadly notions paths pcp solutions tagged form twoconcepts provide insight program-analysis problems undecidable forinstance ramalingam showed recently context-sensitive interprocedural analysis multi-tasking concurrent programs undecidable result inspired giveninthe present paper insight context-sensitive interprocedural analysis involves twointerleavedpatterns matching events set constraints set-based analysis earlier work reynolds jones muchnick number people recent years explored set constraints analyzing programs set constraints typically collect asuperset set values program svariables hold execution typically set variable created program variable program point set constraints generated approximate program sbehavior program analysis problem finding solution set-constraint problem set constraints program analysis type inference melski reps obtained number results relationship classes set constraints cfl-reachability results establish relationships directions theyshowed cfl-reachability problems subclass called definite set constraints equivalent givenacfl-reachability problem construct set-constraint problem answer givesthe solution cfl-reachability problem likewise givenaset-constraint problem construct cfl-reachability problem answer givesthe solution set-constraint problem shown cfl-reachability equivalent class set constraints designed context-insensitive analysis programs written higher-order language socalled set-based analysis results sections imply start version context-insensitive set-based analysis precise context-insensitive structure-transmitted data-dependence analysis illustrated impossible create algorithm context-sensitive version set-based analysis evenfor first-order language control-flow analysis sharir pnueli defined twomethods carrying interprocedural dataflowanalysis ensure propagation dataflowinformation respects fact procedure finishes returns site recent call methods so-called call-strings approach piece dataflowinformation tagged call string records history uncompleted procedure calls data propagated call string piece information updated wheneverapropagation step call statement return statement performed information obtained principle call strings allowed growarbitrarily long called call-stringssolution sharir pnueli showthat distributive dataflow-analysis problems overafinite semilattice restrict length call strings fixed length bound length required quadratic size lattice linear number call sites program obtain result equivalent precision call-stringssolution suitable means approximate safe solutions obtained shorter call strings limiting call strings length defines call-strings-k solution algorithms interprocedural dataflowanalysis careful confuse separate issues algorithm computes solution equal precision call-stringssolution algorithm computes solution tracking entities labeled call strings length atypeii algorithm typically worst-case running time exponential howev suitably restricted classes interprocedural dataflow-analysis problems algorithms property worst-case running times polynomial size program algorithms dynamic programming utilizing entities labeled explicit call strings forthe class problems typeii algorithm general exponential running time results provide interesting contrast obtained program-analysis problem interest functional-programming community problem k-cfa control-flow analysis higher-order programming languages call strings length goal control-flowanalysis track data control flowinthe presence first-class anonymous functions data constructors selectors manyofthe algorithms givenfor k-cfaare typeii algorithms sense mentioned theyactually track entities labeled call strings length ingeneral running time algorithms exponential similar concept call-stringssolution interprocedural dataflow-analysis problem -cfasolution obtained principle call strings allowed growarbitrarily long results sections imply general data constructors selectors account -cfaisundecidable presence data constructors selectors -cfasolution computed acknowledgements iamgrateful discussions problem nielson ramalingam horwitz melski aiken murphy implementing regular tree expressions func prog comp arch acm conf cambridge aug lec notes comp sci hughes springer-verlag newyork aiken murphy static type inference dynamically typed language conf rec eighteenth acmsymp princ prog lang orlando jan acm newyork aiken wimmers type inclusion constraints type inference sixth conf onfunc prog comp arch copenhagen denmark june callahan program summary graph flow-sensitive interprocedural data flowanalysis proc acm sigplan conf onpro lang design implementation atlanta june sigplan july cooper kennedy interprocedural side-effect analysis linear time proc acm sigplan conf prog lang design implementation atlanta june sigplan july cooper kennedy fast interprocedural alias analysis conf rec sixteenth acm symp princ prog lang austin jan acm newyork emami ghiya hendren context-sensitive interprocedural points-to analysis presence function pointers proc acm sigplan conf onpro lang design implementation orlando june sigplan june harrison introduction formal language theory addison-wesley reading hecht flow analysis computer programs north-holland newyork theorem sharir pnueli establish greatest fixed point set equations equals meet-over-allvalid-paths movp solution theorem theyestablish movp solution equals call-stringssolution algorithms sharir pnueli give worklist algorithm finding greatest fixed point set 
equations section presents fairly general framework assumption semilattice finite dynamic-programming algorithm tabulates information size semilattice exponential size program algorithm time exponential size program achieve polynomial time bound tricks torestrict attention class semilattices class include semilattices size exponential size program powerset program points powerset program svariables totabulate sharir-pnueli functions pointwise onsingletons entire sets essentially class problems larger class distributive environment problems heintze jaffar adecision procedure class set constraints tech rep cmu-cs- school computer science carnegie mellon univ pittsburgh heintze set-based analysis programs tech rep cmu-cs- school computer science carnegie mellon univ pittsburgh july heintze jaffar set constraints set-based analysis workshop principles practice constraint programming heintze mcallester linear-time subtransitive control flowanalysis proc acm sigplan conf onpro lang design implementation las veg nevada june sigplan hopcroft ullman introduction automata theory languages computation addison-wesley reading horwitz reps binkley interprocedural slicing dependence graphs acmtrans program lang syst jan horwitz reps sagiv demand interprocedural dataflowanalysis sigsoft proc thirdacm sigsoft symp found softw eng wash oct acm sigsoft softw eng notes jagannathan weeks aunified treatment flowanalysis higher-order languages conf rec twenty-second acm symp princ prog lang san francisco jan acm newyork jones muchnick flowanalysis optimization lisp-likestructures programflow analysis theory applications muchnick jones prentice-hall englewood cliffs khedker dhamdhere ageneralized theory bit vector data flowanalysis acmtrans program lang syst sept kou live-dead analysis global data flowproblems acm july kuck structureofcomputersand computations vol john wiley sons newyork kuck kuhn leasure padua wolfe dependence graphs compiler optimizations conf rec eighth acm symp princ prog lang williamsburg jan acm newyork lewis papadimitriou elements theory computation prentice-hall englewood cliffs mccarthy abasis mathematical theory computation computer programming formal systems braffort hershberg north-holland amsterdam melski reps interconvertibility class set constraints context-free language reachability theor comp sci nov toappear nielson nielson infinitary control flowanalysis collecting semantics closure analysis conf rec twenty-fourth acm symp princ prog lang paris france jan acm newyork ramalingam context-sensitive analysis undecidable res rep ibm watson res cent yorktown heights reps horwitz sagiv rosay speeding slicing sigsoft proc acm sigsoft symp found softw eng neworleans dec acm sigsoft softw eng notes dec reps shape analysis generalized path problem proc acm sigplan symp part eval sem -based prog manip pepm jolla california june acm newyork reps horwitz sagiv precise interprocedural dataflowanalysis graph reachability conf rec twenty-second acm symp princ prog lang san francisco jan acm newyork reps sequential nature interprocedural program-analysis problems acta inf reps program analysis graph reachability information softwaretechnology elsevier science nov dec reynolds automatic computation data set definitions information processing proc ifip congress north-holland newyork sagiv reps horwitz precise interprocedural dataflowanalysis applications constant propagation theor comp sci sharir pnueli approaches interprocedural data flowanalysis programflow analysis theory applications muchnick jones prentice-hall englewood cliffs shivers control flowanalysis scheme proc acm sigplan conf onpro lang design implementation atlanta june sigplan july wilson lam efficient context-sensitive pointer analysis programs proc acm sigplan conf prog lang design implementation jolla june sigplan june yannakakis graph-theoretic methods database theory proc ninth acm symp princ database syst 
maximal-munch tokenization linear time thomas reps wisconsin lexical-analysis scanning phase compiler attempts partition input string sequence tokens convention languages input scanned left token identified maximal munch remaining input longest prefix remaining input token language standard compiler textbooks present perform maximal-munch tokenization algorithm describe sets token definitions scanner exhibit quadratic behavior worst case paper show maximal-munch tokenization performed time linear size input categories subject descriptors programming languages processors compilers computation abstract devices models computation automata analysis algorithms problem complexity nonnumerical algorithms problems pattern matching pattern recognition applications text processing general terms algorithms theory additional key words phrases backtracking dynamic programming memoization tabulation tokenization introduction lexical-analysis scanning phase compiler attempts partition input string sequence tokens convention languages input scanned left token identified maximal munch remaining input longest prefix remaining input token language string tokenized single integer token juxtaposition integer tokens similarly recognized floating-point numeral juxtaposition tokens rule token definitions match string earliest token definition takes precedence rule invoked tie longest match textbooks compiling extensive discussions lexical analysis terms finite-state automata regular expressions token classes defined set regular expressions lexical analyzer based form finite-state automaton recognizing language work supported part national science foundation grant ccrand defense advanced research projects agency monitored office naval research contracts -jand government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government author address computer sciences department wisconsin dayton madison e-mail reps wisc treatment unsatisfactory respect theory finite-state automata assumes end input string right-hand-side boundary candidate recognition priori scanner identify token knowing definite bound extent token standard compiler textbooks including discuss issue briefly aho ullman book discusses issue context lexical analyzer based deterministic finite-state automata dfas nuances procedure reader aware combined nfa accepting states accepting state token found convert dfa subsets construct include final states final states lose significance longest prefix input matches pattern reaching final state lexical analyzer continue simulate dfa reaches state state current input symbol reach termination meet input symbol dfa proceed presume programming language designed valid program fill input buffer reaching termination reaching termination review states dfa entered processing input state represents subset nfa states dfa state includes final state pattern-recognizing nfa final state token found states dfa entered includes final states nfa error condition dfa state include final nfa state fact includes final state final state pattern listed priority discussion problem book aho sethi ullman similar assume lexical analysis performed simulating nfa converting nfa dfa similar discussions waite goos fischer leblanc wilhelm maurer tokenization process based dfas nfas recommended technique backtracking recent final state restarting satisfactory drawback sets token definitions scanner exhibit quadratic behavior worst case suppose language classes tokens defined regular expressions abc abc suppose input string string repetitions string abc abc divide string tokens scanner advance end input failing find instance token abc back characters end instance abc reported token similar pattern action repeated identify instance abc token scanner advance end input failing find instance token abc back characters end instance abc essentially pattern action repeated remaining tokens method performs steps tokenize inputs abovementioned books explicitly point quadratic behavior simplest exhibits quadratic behavior involves token classes input string form case individual character input string represents separate token exhibit degeneracy form abc drawback serves blemish elegant treatment lexical analysis terms finitestate automata regular expressions possibility quadratic behavior unsettling separation syntax analysis separate phases lexical analysis parsing typically justified grounds simplicity instance aho sethi ullman separation lexical analysis parsing simplify phases compiler efficiency improved compiler portability enhanced program syntax typically defined lalr grammar parsing phase carried linear time peculiar state affairs recommended technique supposedly simpler phase lexical analysis linear time note division syntax analysis separate phases lexical analysis parsing source difficulties token classes grammar problem designing efficient automaton identifies longest prefix remaining input token language paper show dfa recognizes tokens language maximal-munch tokenization performed time linear size input present linear-time algorithms tokenization problem section give program tabulation memoization avoid repeating fruitless searches input string principle underlying program simple scanner processes character position input string state dfa tokenizing input conventional scanner pass character position times backtracking moving case passes lead failure processing deterministic repeat transition doomed failure avoid repeating search possibly bear fruit tabulating scanner track pairs states index positions encountered failed lead identification longer token number states constant constant upper bound number times tabulating scanner makes transition character position performs maximal-munch tokenization linear time section discusses ways reduce amount storage scanner presented section technique section detect cases unbounded amount lookahead final states section presents concluding remarks remainder paper relies assumptions notational conventions assume regular expressions define language tokens admit empty string assume whitespace treated lexeme identified input stream maximal munch higher level compiler assumed filter whitespace tokens phase called screening symbol denote length input string issues related buffering input suppose language tokens defined regular expressions assume deterministic finite-state automaton dfa standard notation dfas dfa five-tuple finite nonempty set states finite nonempty set input symbols transition function partial function initial state set final states tabulating scanner section presents algorithm performs maximal-munch tokenization linear time easiest understand linear-time algorithm version algorithm run linear time program presented figure program prints positions input string final characters token algorithm viewed variant standard quadratic-time backtracking algorithm stack explicit pushes pops test popped state final state implement explicit search recent final state version procedure tokenize figure implements backtracking stacking pairs form state position dfa unable make transition final state end input reached tokenize repeatedly pops elements stack variables means backs final state found symbol bottom found condition implies left-to-right maximal-munch tokenization consideration backtracking loop searches recent final state figure lines extra work maximal-munch tokenization algorithm stack review states dfa entered processing input input scanned maintain pair variables final state position final state record position state maximum index position final state compared approach stack explicit search stack entry recent final state overkill method madness linear-time solution tokenization problem shown figure obtained adding lines figure added code lines contrasting typeface figure tabulates pairs states index positions previously encountered failed lead identification longer token information gathered time 
pairs popped stack line scana impact standpoint asymptotic worst-case complexity worst-case running time quadratic matter backtracking methods procedure tokenize dfa input string begin loop push bottom scan tokens length input input defined reset stack empty push input backtrack recent final state pop bottom return failure tokenization print length input return success pool end procedure tokenize dfa input string begin length input failed previously false loop push bottom scan tokens length input input defined failed previously break reset stack empty push input backtrack recent final state failed previously true pop bottom return failure tokenization print length input return success pool end figure tokenization algorithm employs stack state position pairs implement backtracking backtracking occurs dfa unable make transition final state end input reached modified tokenization algorithm tabulates pairs states index positions previously encountered failed lead identification longer token information avoid repeating fruitless searches input text algorithm obtained adding lines algorithm additions helvetica-bold typeface ning loop determine current configuration unproductive line precisely algorithm shown figure carries process figure two-dimensional table failed previously tabulate previously encountered pairs states index positions failed lead identification longer token consulting table line scanning loop lines algorithm track avoids repeating fruitless searches input text algorithm repeatedly identifies character longest prefix remaining input token pair failed previously true line represent failed previous search started position state unproductive make search position state reason algorithm exits scanning loop switches backtracking mode scanning proceeds left processing character time scanning loop lines encounter pair times worst case reach configurations input length pairs form algorithm running time constant proportionality depends instructive behavior figure introduction caused standard backtracking algorithm exhibit quadratic behavior assume working dfa state-transition diagram shown figure dfa recognizes language abc abc suppose algorithm invoked input string abc abcabcabcabc invocation loop lines advance end input failing find instance token abc process pairs form state position stacked loop lines pops stack entries made table failed previously pairs states index positions loop continues pair popped stack point final state dfa program exits loop lines leaving set instance abc reported token set initial state bottom pushed now-empty stack scanning resumed position state invocation scanning loop characters abca positions processed variable attains positions end abc token program encounters configuration previously failed lead identification longer token program exits scanning loop time iteration loop lines performed pops pair stack loop terminate final state dfa leaves set instance abc reported token pattern action repeated instance abc scanning resumed state position variable attains positions end abc token program reaches configuration previously failed lead identification longer token algorithm exits scanning loop performs iteration loop lines popping pair reports instance abc token figure state-transition diagram finite-state automaton recognizes language abc abc fourth instance abc identified token final state end input reached general processing pattern carries inputs form abc scanning backtracking pass input string results recognition instance abc token table failed previously entries configurations form state-transition diagram shown figure property state entered reading string form abc abc entered reading abca subsequent passes attain configuration previously failed lead identification longer token variable positioned characters end instance abc state pass configuration form point algorithm exits loop lines performs iteration loop lines popping pair reports instance abc ends position token linear amount work recognize token constant amount work token recognized algorithm performs steps tokenize inputs form abc dfa language abc abc similar effect occur program switch scanning mode backtracking mode enters previously encountered configuration failed lead identification longer token point previously encountered configuration reached place number characters input string number constant depends dfa language abc abc total cost tokenization linear length input string optimizing tabulating scanner straightforward implementation tabulating scanner figure table bits time initialization section describe optimization techniques aimed reducing storage utilization concern languages lexical analysis compilers designed unbounded amount lookahead final states mechanism avoids overheads tabulating scanner cases tabulation warranted address concern present implementation tabulating scanner imposes overhead cases produce superlinear behavior strategy reducing storage utilization based idea tabulation carried index position scanner tabulate position constant initialization time space fall factor running time increase factor running time linear space bits quantity independent number states running time technique aho hopcroft ullman problem sidestep initialize failed previously increases space bits pointers statement fortran requires unbounded lookahead fortran maximal-munch convention strategy optimization conjunction previous based idea tabulating states index position input string tokenize maintain tabulation information states members set tab table failed previously size tab bits non-tabulating scanner substituted tab postpone moment question identify suitable set tab version tabulating scanner figure makes concrete idea means maintain tabulation information states tab figure lines changed figure repeated figure reader convenience code appears right-hand side contrasting typeface procedure tokenize dfa input string begin length input failed previously false loop push bottom scan tokens length input input defined failed previously break reset stack empty push input backtrack recent final state failed previously true pop bottom return failure tokenization print length input return success pool end procedure tokenize dfa input string begin tab length input failed previously false loop push bottom scan tokens length input input defined tab cand failed previously break reset stack empty tab push input backtrack recent final state tab failed previously true pop bottom return failure tokenization print length input return success pool end figure tabulating tokenization algorithm figure tabulating tokenization algorithm tabulates states tab algorithm obtained changing lines algorithm modifications helvetica-bold typeface ideas failed previously entries members tab initialized loop lines failed previously accessed states members tab lines iii stack entries bottom line final states line states members tab line note tab single pair appears stack form bottom position final-state position essence figure degenerates case variant algorithm maintains record final state final-state position simulation tab code cleaned replacing stack explicit pair variables eliminating array failed previously iii removing dead code guarded tests tab lines simplifying condition line tab goal find suitable tab sets version tokenize shown figure linear-time behavior cut defining tab tab tokenize backtracks final-state position configuration reserve space failed previously tabulate final states tab essential differences behavior figures identify nontrivial tab set analyze finite-state control dfa purpose convenient transition function defining labeled directed graph statetransition diagram usual 
nodes states transition yields edge labeled addition assume graph augmented explicit failure node qfail represents non-final state graph normalized nodes states path final-state node useless useless nodes condensed qfail node useless edges form replaced edges form qfail qfail graph made total representation edge form qfail added graph undefined transition iii qfail made sink node edges form qfail qfail removed graph figure shows augmented version state-transition diagram figure tokenize backtracks final-state position configuration tokenize tabulate states reachable final states reachablefromfinal holds iff possibly empty path final state simple reachability question determine set reachablefromfinal holds depth-first search starting members equivalently finding solution set equations nodes graph ordering falsea true true reachablefromfinal reachablefromfinal fail figure state-transition diagram figure augmented node qfail arrows labeled letters shorthand multiple edges solution equations obtained iteration starting initial approximation solution node reachablefromfinal false define set reachablefromfinal reachablefromfinal reachablefromfinal cut defining tab tab reachablefromfinal narrow tab set tokenize retain linear-time behavior bounded set states property tokenize continues reaches final state bounded number steps fails bounded number steps observed earlier tokenize maintain tabulation information final states reason tokenize maintain tabulation information non-final states bounded total amount work performed tokenize processing states bounded scanning loop lines figure tokenize reaches non-final states bounded charge work performed scanning loop final state reached failure occurs position appears pair bottom stack note bottom line final state line line properties tokenize consume bounded amount input reaches non-final states bounded tokenize backtracks finalstate position configuration accounting scheme charges constant amount work index position total cost processing non-final states bounded choosing tab reachablefromfinal bounded assured version tokenize shown figure linear-time behavior presence cyclic accepting-state-free paths graph unbounded behavior recast definition bounded bounded iff qfail accepting-state-free paths nodes qfail acyclic identify members bounded find solution set equations nodes graph ordering falsea true bounded bounded true qfail bounded bounded solution equations obtained iteration starting initial approximation solution node bounded false finding solution pessimistically assume proven exists cyclic accepting-state-free path member qfail instance graph shown figure state reachablefromfinal bounded false true false true false true true true true false true false true false true true qfail true true tabulate states tab reachablefromfinal bounded languages lexical analysis compilers designed unbounded amount lookahead final states evident discussion cases algorithm set tab tabulatingscanner generator extended method test input lexical specification tab occurs supply scanner maintains record final state final-state position simulation common case tabulation play impose overhead scanner-generation time verify tab scanner generator applied non-standard situation involving set highly ambiguous token definitions tabulating scanner lines figure supplied prevent superlinear behavior occurring case analysis algorithm serves reduce size tabulation table failed previously bits tab bits consequent reduction initialization time concluding remarks presenting quadratic-time backtracking algorithm tokenization problem waite goos advance conjecture tacitly assumed initial state automaton independent final state reached previous invocation token tokenizer assumption relaxed permitting state retained invocation avoid limited backtracking discussed technique solves problems open question solutions present paper based principle permitting state retained invocation rely tabulation avoid repeating work sense waite goos mark notion state broadened include memoization table table failed previously addition initial state automaton correct solution problem involve retention state invocation tokenizer author motivated develop algorithms presented paper observing result automata theory due mogensen extends earlier result cook implied maximal-munch tokenization performed linear time mogensen showed variant two-way deterministic pushdown automaton so-called wormdpda simulated linear time ram computer wormdpda perform exponential number steps mogensen technique exploits fact matter steps wormdpda performs linear number stack configurations wormdpda ram program dynamic programming tabulate information sequences transitions configurations wormdpda repeat computation sequences times information obtained dynamic programming ram program shortcuts essence skip successive repetitions computation sequences proceed directly configuration computation dfa recognizes tokens language easy construct wormdpda identifies maximal-munch tokens proper insights obtained tabulation cook mogensen constructions easy write linear-time algorithm maximal-munch tokenization problem directly effect produced lines added figure similar effect produced mogensen simulation technique wormdpda identifies maximal-munch tokens process illustrates interesting algorithm-design methodology design wormdpda language-recognition problem relative problem interest study mogensen construction introduce shortcuts previously tabulated information insights obtain linear-time algorithm problem interest well-known algorithm knuth morris pratt linear-time pattern matching strings algorithm developed similar fashion lengthier discussion ideas found programming languages property token class tokens prefixes tokens token class integer floating-point constants potential quadratic behavior lexical analyzers problem practice lexical-analysis tools lex tasks domain compilation aho ullman mention lex recognize imperfections printed circuits nonstandard applications represent situations algorithms presented paper importance acknowledgements sagiv introduced problem showed student nathaniel illustrate potential quadratic behavior standard backtracking algorithm essentially discussed introduction section grateful discussions problem sagiv fischer horwitz wilhelm wilhelm offered valuable suggestions initiated development material section comments suggestions referees contributed greatly present form paper aho hopcroft ullman design analysis computer algorithms addison-wesley reading aho ullman principles compiler design addison-wesley reading aho sethi ullman compilers principles techniques tools addison-wesley reading aho algorithms finding patterns strings handbook theor comp sci vol algorithms complexity van leeuwen press cambridge cook linear time simulation deterministic two-way pushdown automata information processing proc ifip congress freiman north-holland amsterdam deremer lexical analysis compiler construction advanced bauer eickel springer-verlag york fischer leblanc crafting compiler benjamin cummings publishing company menlo park hopcroft ullman introduction automata theory languages computation addison-wesley reading knuth morris pratt fast pattern matching strings siam computing mogensen wormdpdas extension dpdas simulated linear time inf proc reps maximal-munch tokenization linear time trcomp sci dept univ wisconsin madison revised august waite goos compiler construction springer-verlag york wilhelm maurer compiler design english edition addison-wesley reading 
program analysis graph reachability thomas reps wisconsin abstract paper describes number program-analysis problems solved transforming graph-reachability problems program-analysis problems amenable treatment include program slicing dataflow-analysis problems version problem approximating shapes heap-allocated structures program flow-insensitive points-to analysis relationships graph reachability approaches program analysis techniques pure graph reachability discussed introduction purpose program analysis ascertain information program running program classical dataflow analysis imperative programs goal associate set dataflow facts program point assignment statement call statement statement predicate loop conditional statement typically dataflow facts program point describe aspect execution state holds control reaches expressions live variables reaching definitions information obtained program analysis program optimizers tools software engineering reengineering program-analysis frameworks abstract common characteristics class program-analysis problems examples analysis frameworks range gen kill dataflow-analysis problems compiler textbooks elaborate frameworks typically analysis engine find solutions problems framework analyzers program-analysis problems created plugging details programanalysis problem interest dataflow functions nodes edges program control-flow graph program-analysis frameworks instantiation framework programanalysis problem yields set equations analysis engine underlying framework mechanism solving family equation sets chaotic iteration find greatest solution forward gen kill dataflow-analysis problem instance yields set equations solved domain finite sets variables equations correspond program points equation form valp pred valq killp genp values killp genp constants program point killp represents dataflow facts removed genp represents dataflow facts created paper presents program-analysis framework based principle analysis problems posed graph-reachability problems discussed express convert program-analysis problems context-free-language reachability problems cfl-reachability problems generalization ordinary graph-reachability problems cfl-reachability defined section program-analysis problems amenable treatment include abbreviated version paper appeared invited paper proceedings international symposium logic programming work supported part david lucile packard fellowship science engineering nsf grants dcrccr- ccrby darpa monitored onr contracts -kand -jby grants rockwell ibm vilas associate award wisconsin author address computer sciences department wisconsin madison dayton madison e-mail reps wisc http wisc reps interprocedural program slicing interprocedural versions large class dataflow-analysis problems method approximating shapes heap-allocated structures flow-insensitive points-to analysis fourth applications cfl-reachability apply programs written imperative programming language application cfl-reachability shape analysis applies functional imperative languages permit heap-allocated storage permit destructive updating fields number benefits gained graph reachability vantage point studying program-analysis problems expressing program-analysis problem graph-reachability problem obtain efficient algorithm solving program-analysis problem case program-analysis problem expressed single-source ordinary graph-reachability problem problem solved time linear number nodes edges graph case program-analysis problem expressed cfl-reachability problem problem solved time cubic number nodes graph difference asymptotic running time needed solve ordinary reachability problems cflreachability problems insight trade-offs accuracy running time program-analysis problems cfl-reachability problem solved approximate fashion treating ordinary reachability problem automatic obtain approximate safe solution method asymptotically faster method obtaining accurate solution program optimization gains obtained making improvements program hot spots innermost loops means dataflow information needed selected locations program similarly software-engineering tools dataflow analysis require information set program points response user queries suggests applications dataflow analysis made efficient demand dataflow-analysis algorithm determines dataflow fact holds point program-analysis problems expressed cfl-reachability problems demand algorithms easily obtained solving single-source single-target multi-source multi-target cfl-reachability problems graph reachability offers insight bottleneck exists kinds programanalysis problems number program-analysis problems solvable time sub-cubic-time algorithm erroneously attributed perform transitive closure problem solved transitive closure performed sub-cubic time correct explanation long believed cases real source bottleneck cfl-reachability problem solved constructions show case set-constraint problems source bottleneck attributed solve dynamic transitiveclosure problem basis statement cubic-time algorithms solving programanalysis problems maintain transitive closure relation on-line fashion sequence insertions relation performed present time sub-cubic-time algorithm version dynamic transitive-closure problem opinion statement dynamic transitive-closure problem solved operational characterization bottleneck alternative characterization cfl-reachability problem solved offers declarative characterization source bottleneck graph-reachability approach insight prospects creating parallel programanalysis algorithms connection program analysis cfl-reachability establish number results imply limitations ability create efficient parallel algorithms interprocedural slicing interprocedural dataflow analysis specifically shown interprocedural slicing log-space complete interprocedural dataflow analysis p-hard interprocedural dataflow-analysis problems involve finite sets dataflow facts classical gen kill problems log-space complete consequence results exist algorithms interprocedural slicing interprocedural dataflow analysis number processors bounded polynomial input size running time bounded polynomial log input size graph-reachability approach offers insight ways powerful machinery brought bear program-analysis problems remainder paper organized sections section defines cfl-reachability section discusses algorithms solving cfl-reachability problems section discusses graphreachability approach tackle interprocedural dataflow analysis interprocedural program slicing shape analysis flow-insensitive points-to analysis section concerns demand versions program-analysis problems section describes techniques pure graph reachability section discusses related work context-free-language reachability problems theme paper number program-analysis problems viewed instances general problem cfl-reachability cfl-reachability problem ordinary reachability problem transitive closure path considered connect nodes concatenation labels edges path word context-free language definition context-free language alphabet graph edges labeled members path defines word word obtained concatenating order labels edges path path l-path word member define varieties cfl-reachability problems all-pairs l-path problem determine pairs nodes exists path single-source l-path problem determine nodes exists l-path source node iii single-target l-path problem determine nodes exists l-path target node single-source single-target l-path problem determine exists l-path source node target node variants cfl-reachability include multi-source l-path problem multi-target l-path problem multi-source multi-target l-path problem graph shown language consists strings matched parentheses square brackets interspersed matched matched matched matched matched graph l-path path cycle generates word eee instructive cfl-reachability relates familiar problems ordinary graph-reachability problem treated cfl-reachability problem labeling edge symbol letting regular language instance transitive closure all-pairs -problem ordinary graph reachability regular-language reachability special case cfl-reachability language referred definition regular language context-free-language recognition problem cfl-recognition answers questions form string context-free language cfl-recognition problem formulated special kind single-source single-target cfl-reachability problem create linear graph edges label edge letter l-path iff general result cfl-reachability problems solved time cubic number nodes graph section method analysis engine program-analysis framework instructive general case relates special cases ordinary reachability cfl-recognition single-source ordinary reachability problem solved time linear size graph nodes edges depth-first search valiant showed cfl-recognition performed cubic time algorithm handles cfl-reachability problems trees directed acyclic graphs chain graphs algorithm generalize cfl-reachability problems arbitrary graphs standpoint program analysis cfl-reachability constraint tool employed filter paths irrelevant solution analysis problem program-analysis problems graph intermediate representation program paths graph represent potential execution paths desirable analysis results polluted polluted presence paths question path program representation 
corresponds execution path general undecidable cases paths identified infeasible correspond execution paths mismatched calls returns specific applications cfl-reachability program-analysis problems discussed length section moment content illustrate context-free language exclude attention paths represent infeasible computations case interprocedural dataflow analysis characterize superset feasible execution paths eliminate consideration subset infeasible execution paths introducing context-free language realizable defined mimics call-return structure program execution paths possibly feasible execution paths returns matched calls paths called realizable paths realizable paths defined terms program supergraph shown fig supergraph consists collection control-flow graphs procedure represents program main procedure flowgraph unique start node unique exit node nodes flowgraph represent statements predicates program usual procedure call program represented nodes call node return-site node addition ordinary intraprocedural edges connect nodes individual control-flow graphs procedure call represented call node return-site node edges intraprocedural call-to-return-site edge interprocedural call-to-start edge start node called procedure interprocedural exit-to-return-site edge exit node called procedure call node unique index callsites callsites total number call sites program call site label call-to-start edge exit-to-return-site edge symbols label edges symbol path matched path iff path word language matched balanced-parenthesis strings interspersed strings generated nonterminal realizable context-free grammar matched matched matched matched callsites path realizable path iff path word language realizable realizable matched realizable realizable callsites language realizable language partially balanced parentheses parenthesis nodes flowgraph represent individual statements predicates alternatively represent basic blocks declare int procedure main begin declare int read call end procedure int begin read call print end enter enter main main read call return exit main main return exit call read print start exit pexit start program supergraph fig program supergraph supergraph annotated dataflow functions possibly-uninitialized variables problem notation denotes set renamed balanced preceding left parenthesis converse hold understand concepts helps examine paths occur fig path start main startp exitp word matched path realizable path general matched path procedure represents sequence execution steps call stack temporarily grow deeper calls shallower original depth eventually returning original depth path start main startp word realizable path matched path call-to-start edge startp matching exit-to-return-site edge realizable path program start node smain node represents sequence execution steps ends general number activation records call stack pending activation records correspond unmatched path word path start main startp exitp word matched path realizable path exit-to-return-site edge exitp correspond preceding call-to-start edge startp path represents infeasible execution path algorithms solving cfl-reachability problems cfl-reachability problems solved simple dynamic-programming algorithm grammar normalized introducing nonterminals right-hand side production symbols terminals nonterminals additional edges added graph patterns shown fig edges added solution obtained edges labeled grammar root symbol worklist algorithm suitable indexing structures running time algorithm cubic number nodes graph algorithm thought generalization cyk algorithm cfl-recognition cfl-reachability problems solved time cubic number graph nodes asymptotically taking advantage structure graph arises program-analysis problem instance class dataflow-analysis problems discussed section number graph nodes number nodes program supergraph size universe dataflow facts taking advantage special structural properties graph cfl-reachability problems arise construction section solved time number edges program supergraph asymptotically general-case time bound similar improvement general-case time bound obtained interprocedural-slicing problem discussed section approaching cfl-reachability problems stems observation cflreachability problems correspond restricted class datalog programs so-called chain programs edge labeled graph represented fact production form context-free grammar terminals nonterminals encoded chain rule rule form cfl-reachability problem solved bottom-up semi-naive evaluation chain program observation program-analysis tools advantage methods developed logic-programming deductive-database communities efficient evaluation recursive queries deductive databases tabulation magic-sets transformation instance algorithms demand versions program-analysis problems obtained exhaustive counterparts essentially free problem horn clauses applying magic-sets transformation note datalog problem rules chain rules immediately converted cfl-reachability problem graph constructed set base facts involve binary relations fact edge node node labeled datalog rule form converted context-free-grammar production form fig patterns adding edges solve cfl-reachability problem symbols terminals nonterminals case dotted edge labeled nonterminal added graph make transformation section examples section show program-analysis problems transformed cfl-reachability problems problems discussed illustrate limited class context-free languages constructions make partially balanced parenthesis problems similar language realizable defined section sections application cfl-reachability flowinsensitive points-to analysis presented section program-analysis problem solved expressing l-path problem context-free language language partially balanced parentheses interprocedural dataflow analysis dataflow analysis concerned determining dataflow associate point program summarize safely aspect execution state holds control reaches define instance dataflow problem supergraph program domain dataflow values point program member meet operator combining information obtained paths assignment dataflow functions type edges supergraph fig supergraph annotated dataflow functions possiblyuninitialized variables problem possibly-uninitialized variables problem determine node set program variables uninitialized execution reaches power set set program variables variable possibly uninitialized x-definition-free path start program path start program definition variable possibly uninitialized dataflow function edge shown fig adds set possiblyuninitialized variables node set possibly-uninitialized variables node show large class interprocedural dataflow-analysis problems handled transforming realizable-path reachability problems non-standard treatment dataflow analysis ordinarily dataflow-analysis problem formulated path-function problem path function pfq path composition functions label edges goal determine node meet-over-all-paths solution mopn paths start paths start denotes set paths control-flow graph start node mopn represents summary execution states arise special represents execution state beginning program pfq represents contribution path summarized state interprocedural dataflow analysis goal shifts meet-over-all-paths solution precise solution mrpn rpaths startmain rpaths startmain denotes set realizable paths main procedure start node realizable path means path word language realizable defined section realizable paths infeasible execution paths non-realizable paths feasible execution paths restricting attention realizable paths startmain exclude infeasible execution paths general mrpn characterizes execution state precisely mopn dataflow-analysis problems constant propagation meet-over-all-paths solution uncomputable sufficient condition solution computable edge function distribute meet operator problems amenable graph-reachability approach distributive interprocedural finite distributive subset problems ifds problems interprocedural dataflow-analysis problems involve finite set dataflow facts dataflow functions distribute confluence operator set union set intersection depending problem instance ifds problem consists supergraph finite set universe dataflow facts point program member domain assignment distributive dataflow functions type edges assume meet operator union hard show ifds problems meet operator intersection handled dualizing transforming problem complementary problem meet operator union informally must-be-x problem intersection ifds problem may-not-be-x problem union ifds problem node solution must-be-x problem complement respect solution may-not-be-x problem ifds framework languages variety features including procedure calls parameters global 
local variables pointers call-to-return-site edges included ifds framework handle programs local variables parameters dataflow functions call-to-return-site exit-to-return-site edges permit information local variables parameters holds call site combined information global variables parameters holds end called procedure ifds problems include limited classical gen kill problems bit-vector separable problems reaching definitions expressions live variables addition ifds problems include non-gen kill problems including possibly-uninitialized variables truly-live variables copy-constant propagation expressing problem falls ifds framework cases involve loss precision loss precision involved formulating ifds version problem account aliasing problem cast ifds problem find mrp solution loss precision solve ifds problem convert realizable-path reachability problem problem instance build exploded supergraph node represents dataflow fact supergraph node edge represents dependence individual dataflow facts supergraph nodes key insight explosion distributive function represented graph nodes graph called representation relation half nodes graph represent input half represent output nodes represent individual dataflow facts form set remaining node call essentially represents empty set edge means edge means graph includes edge function composition corresponds compositions representation relations explained main procedure shown fig variables representation relations dataflow functions procedure nodes function edge startmain variables added set possibly-uninitialized variables representation relation function shown fig representation relation function edge shown fig note output set iff function representation relation captures function semantics sense representation relation evaluate function result applying function input union values represented output nodes representation relation targets edges input nodes represent node applying dataflow function set representation relation shown fig edge initial node edge initial node final node result application result applying function set fig representation relations functions ways composing functions edge initial node final node composition functions represented pasting graphs represent individual functions composition functions discussed represented graph shown fig paths pasted-together graph represent result applying composed function fig path initial node final node means final set composed function applied path initial node final node means final set understand edges representation relations composition functions opposite order represented graph shown fig note final set composed functions applied fig reflected paths initial node final nodes edge initial node intermediate node paths graph correctly represent composition functions returning definition exploded supergraph node supergraph exploded nodes edge exploded representation relation function node node node dataflow fact node function edge iii edge node node edge node node edge node node pasted representation relations correspond function composition path exploded supergraph node node means dataflow fact holds supergraph node dataflow fact holds node paths start node startmain represents fact dataflow facts hold start procedure main determine dataflow facts hold node interested paths correspond realizable paths realizable paths proof dataflow fact mrpn iff realizable path node startmain node exploded supergraph corresponds instance possibly-uninitialized variables problem shown fig shown fig dataflow functions replaced representation relations fig closed circles represent nodes reachable realizable paths startmain open circles represent nodes reachable realizable paths note enter enter main main read call return exit main main return exit call read print start exit exit start fig exploded supergraph corresponds instance possibly-uninitialized variables problem shown fig closed circles represent nodes reachable realizable paths startmain open circles represent nodes reachable paths nodes reachable non-realizable paths startmain information nodes values solution dataflow-analysis problem instance solution node exitp set variable possibly-uninitialized variable execution reaches exit node procedure fig information obtained determining realizable path startmain exitp startmain exitp interprocedural program slicing slicing operation identifies semantically meaningful decompositions programs decompositions consist elements necessarily textually contiguous slicing subsequent manipulation slices applications software-engineering tools including tools program understanding maintenance debugging testing differencing specialization reuse merging kinds slices backward slice program respect set program elements set program elements affect directly transitively values variables members forward slice respect set program elements affected computations performed members program backward slices shown fig variable defined directly affected values variables predicates control times executed variable directly affected assignments reach predicates control times executed slice obtained chains dependences directly-affects relation observation due ottenstein ottenstein noted program dependence graphs pdgs originally devised parallelizing vectorizing compilers convenient data structure slicing pdg program directed graph nodes connected kinds edges nodes pdg represent individual statements predicates program edges pdg represent control flow dependences procedure statements predicates program represented pdg slices obtained time linear size pdg solving ordinary reachability problem pdg compute backward slice respect pdg node find pdg nodes path control flow edges problem interprocedural slicing concerns determine slice entire program slice crosses boundaries procedure calls purpose convenient system dependence graphs sdgs variant pdgs extended handle multiple procedures sdg consists collection procedure dependence graphs refer pdgs procedure including main procedure addition nodes represent assignment statements statements predicates procedure call statement represented procedure pdg int add int return void main int sum sum sum add sum add printf sum sum printf int add int return void main inta add printf enter ret call sum inin sum ret sum call ret printfprintf edge key control edge flow edge edge slice call parameter parameter edge sum add add enter main add fig program slice program respect statement printf program system dependence graph slice starting point slice shown italics empty boxes program elements removed original program dependence graph edges shown boldface edges slice call node collection actual-in actual-out nodes actual-in node actual parameter actual-out node return value-result parameter modified call similarly procedure entry represented entry node collection formal-in formal-out nodes global variables treated extra value-result parameters give rise additional actual-in actual-out formal-in formal-out nodes edges pdg represent control flow dependences usual pdgs connected form sdg call edges represent procedure calls run call node entry node parameter-in parameter-out edges represent parameter passing run actualin node formal-in node formal-out node actual-out nodes fig graph shown sdg program appears left noted sdgs class program representations sense term sdg generic meaning represent programs programming languages kinds pdgs depending features constructs language large body work exists techniques building dependence graphs wide variety programming-language features constructs previous work addressed arrays parameters pointers non-structured control flow issue create pdgs sdgs orthogonal issue slice sdg constructed slicing formulated cfl-reachability problem algorithm interprocedural slicing presented weiser original paper slicing algorithm equivalent solving ordinary reachability problem sdg weiser algorithm imprecise sense report effects transmitted paths mismatched calls returns represent 
feasible execution paths slices obtained include unwanted components path sdg shown fig node procedure main labeled sum node main labeled printf path corresponds execution procedure add called call site main returns call site main happen node labeled sum included slice respect node labeled printf undecidable path sdg corresponds feasible execution path language partially balanced parentheses exclude consideration paths calls returns mismatched parentheses defined call node sdg unique index callsites callsites total number call sites program call site label outgoing parameter-in edges incoming parameter-out edges symbols label outgoing call edge label edges symbol fig slicing slightly cfl-reachability problems defined definition instance backward slice respect target node consists set nodes lie realizable path entry node main definition long dealing program unreachable procedures procedures transitively callable main change backward-slicing problem single-target cfl-reachability problem sense definition iii path sdg slice path iff path word language slice unbalanced-right unbalanced-right matched unbalanced-right callsites slice unbalanced-right realizable nodes backward slice respect nodes exists slice -path nodes backward slice solution single-target slice -path problem target node suppose slice -path connects unbalancedright -path realizable -path assumption procedures transitively callable main exists path control call edges connects entry node main realizable -path balances path matched -path path form realizable matched realizable shown realizable -path shape analysis shape analysis concerned finding approximations shapes heap-allocated structures program section addresses shape analysis imperative languages support non-destructive manipulation heap-allocated objects similar techniques apply shape analysis pure functional languages assume working imperative language assignment statements conditional statements loops statements goto statements procedure calls parameter-passing mechanism value-result recursion direct indirect permitted language atomic data integer real boolean identifiers lisp-like constructor selector operations nil cons car cdr predicates equal atom null rplaca rplacd operations restriction circular structures created dag structures trees created assume read statement reads atom entire tree dag convenience assume constructor selector performed statement cons car broken statements temp car cons temp assumption essential simplifies presentation program shown fig program reads atoms forms list traverses assign reversal remainder section illustrate techniques collection dataflow equations capture approximation shapes superset terms arise points program domain shape shape descripa nil read cons read nil nil temp car cons temp cdr nil nil temp car cons temp exit start nil read cons read atom temp temp empty cdr fig program control-flow graph equation dependence graph edges equation dependence graph shown labels label path shown dotted lines path -path atom node tors set selector sequences terminated nil shape nil sequence nil represents root-to-leaf path note single shape descriptor shape selector sequences paths occur single term dataflow variables correspond program-point program-variable pairs program variable point program dataflow variable dataflow equations control-flow graph edges dataflow equations edge program variable equations edge reflect execution actions performed node dataflow variable approximates shape executes dataflow-equation schemas shown fig procedure calls parameters handled introducing equations dataflow variables actual parameters dataflow variables formal parameters reflect binding occur procedure called introducing equations dataflow variables formal out-parameters dataflow variables actuals return site call-by-value-result handled solved suitable domain equations define abstract interpretation program question domain solved approach dataflow variable set shapes set sets root-to-leaf paths join operation union functions cons car cdr functions shape sets shape sets cons defined cons work alternative approach dataflow variable single shape single set root-to-leaf paths join operation union functions cons car cdr functions shape shape cons defined cons approaches solutions shape-analysis equations general infinite practice report shape information characterizes values program variable program point indirectly terms values program variables program points indirect information viewed simplified set equations equivalently regular-tree grammar domain shape place shape involve loss precision feeling kind information lost obtained program fragment cons cons form source-node equations edge atom read nil nil car car cdr cdr cons cons fig dataflow-equation schemas shape analysis information program point approaches represented tree grammars cons cons cons grammar multiple cons right-hand sides nonterminal grammar link branches cons alternatives broken single cons right-hand side formed collection alternative nonterminals arm shape descriptions sharper grammars type grammar nonterminals occur simultaneously children grammar associates nonterminal trees form cons show shape-analysis information obtained solving cfl-reachability problems graph obtained program dataflow equations definition eqng set equations shape-analysis problem control-flow-graph equation dependence graph special nodes atom empty node variable eqng edges graph labeled defined shown table form equation edge equation dependence graph label atom nil empty hdv cons car cdr equation dependence graph section shown fig shape-analysis information obtained solving cfl-reachability problems equation dependence graph context-free grammars path path path path path path path path path path path language represents paths balanced matching paths correspond values transmitted execution paths cons operation rise label edge path eventually matching car cdr operation rules grammar grammar-theoretic analogs mccarthy rules car cons cdr cons language represents paths slightly unbalanced unmatched paths correspond values accessed performing additional car operation extend path additional language represents paths slightly unbalanced case unmatched paths correspond values accessed performing additional cdr operation extending path suppose interested characterizing shape program variable exit statement program shown fig determine information origin root constituent solving single-target -path problem yields set empty nil allocated execution loop similarly solution single-target -path problem set temp atom atom car originally read fig shows -path atom finally solution single-target -path problem set empty tail nil allocated execution loop information interpreted regular-tree grammar empty cons temp atom empty flow-insensitive points-to analysis languages analysis ways pointers program crucial obtaining good results static analysis direct results pointer analysis optimizations performed pointer analysis preprocessing step static analyses payback permits precise information obtained dataflow problems dataflow function point depends set memory locations pointer variable point estimate provided set precise dataflow function employed points-to analysis approach pointer analysis concerned determining point program superset set variables pointer variable point execution points-to analysis concentrates variables stack-allocated storage heap-allocated storage completely points-to analysis common approach handling heapallocated storage fold single allocation-site-specific pseudo-variable memory locations allocated individual allocation site statement malloc purposes analysis treated statement malloc malloc newly created variable flow-insensitive analysis program ignores actual structure program control-flow graph assumes statement executed immediately statement type-inference algorithms examples flow-insensitive analyses flow-insensitive points-to analyses developed andersen steensgaard shapiro horwitz section show variant andersen analysis 
reformulated shapiro horwitz expressed cfl-reachability problem section assume assignment statements program normalized suitable introduction temporary variables assignment statements forms assume malloc statements handled transformation discussed shapiro horwitz reformulate andersen algorithm builds graph represents points-to relationships program variables nodes points-to graph represent program variables edge node variable node variable means point algorithm processes assignment statements program additional edges added points-to graph figure illustrates rules applied kinds assignment statements general statements considered multiple times rules applied iteratively graph obtained application rule statement program fails add additional edges points-to graph suppose program assignment statements give full description method final points-to graph steps graph created explained statement fact generated assignaddr assign assignstar starassign statement effect points-to graph horn-clause rule pointsto assignaddr pointsto assign pointsto pointsto assignstar pointsto pointsto pointsto starassign pointsto pointsto fig points-to analysis expressed datalog program examples base facts generated statement kinds examples illustrating kind statement points-to graph modified shapiro-horwitz formulation andersen algorithm case dotted edges added points-to graph horn-clause rules express form datalog program algorithm equivalent shapirohorwitz formulation andersen algorithm statements processed order listed considered points-to analysis reach quiescence statements processed order points-to graph built case dotted edge edges added points-to graph process statement shown bottom box graph final points-to graph statement program reapplying rule fails add additional edges points-to graph goal show formulation problem reformulated cfl-reachability problem show problem reformulated additional ways datalog program chain program step easy figures show shapiro-horwitz formulation andersen algorithm expressed datalog program figure shows examples base facts generated statement kinds fact generated assignment statement program figure shows rules adding edges points-to graph shapirohorwitz formulation expressed horn clauses step show expressed chain program easy figure horn clauses chain rules fourth rule required form pointsto starassign pointsto pointsto recast program chain program start rewriting fourth rule pointsto pointsto starassign pointsto form required order variables literal reversed chain rule precede finesse issue introduce relation pointsto maintain reversal pointsto relation corresponds maintaining edge shapiro-horwitz points-to graph directions label pointsto label pointsto rewrite rule chain rule pointsto pointstoa starassign pointsto question build set pointsto tuples datalog introducing rule pointstoa pointsto unsatisfactory purposes rule chain rule overcome difficulty shown figure figure shows revised set base facts generated construction give step due david melski statement facts generated assignaddr assignaddr assign assign assignstar assignstar starassign starassign form statement chain rules inferring pointsto tuples pointsto tuples pointsto assignaddr pointsto assignaddr pointsto assign pointsto pointsto pointsto assign pointsto assignstar pointsto pointsto pointsto pointsto pointsto assignstar pointsto pointsto starassign pointsto pointsto pointsto starassign pointsto fig points-to analysis expressed chain program revised set base facts generated statement kinds chain rules express algorithm equivalent shapiro-horwitz formulation andersen algorithm statement kinds introduced reversed base relations assignaddr assign assignstar starassign figure shows chain rules inferring pointsto pointsto tuples rules figure rules figure respective reversals addition rule pointsto assignaddr rule pointsto assignaddr addition rule pointsto assign pointsto rule pointsto pointsto assign notice rule order literals right-hand side reversed order variables literal reversed addition rule pointsto assignstar pointsto pointsto rule pointsto pointsto pointsto assignstar order literals right-hand side reversed order variables literal reversed cases rule rule chain rules eighth rule figure obtained applying reversal process seventh rule rule pointsto pointsto starassign pointsto obtain pointstoa pointstoa starassigna pointsto order literals variables reversed final literal substituted pointsto pointsto notice rule chain rule rules figure chain rules final step extract context-free grammar chain program figure method discussed section pointsto assignaddr pointsto assignaddr pointsto assign pointsto pointsto pointsto assign pointsto assignstar pointsto pointsto pointsto pointsto pointsto assignstar pointsto pointsto starassign pointsto pointsto pointsto starassign pointsto points-to facts determined solving pointsto -reachability problems graph created facts generated table figure solve pointsto reachability problems graph nodes correspond program variables edges labeled symbols assignaddr assignaddr assign assign assignstar assignstar starassign starassign graph assignment statements starassign assignaddr assignaddr assignaddr assign assignstar avoid clutter left reversed edges graph grammar discover instance points paths assignaddr assignaddr assignaddr paths pointsto pointsto pointsto paths assignaddr assignaddr assignaddr paths pointsto pointsto pointsto path pointsto path assignstar pointsto pointsto path pointsto path pointsto starassign pointsto path pointsto path assignstar pointsto pointsto solving demand versions program-analysis problems exhaustive dataflow-analysis algorithm associates point program set dataflow facts guaranteed hold point reached program execution contrast demand dataflow-analysis algorithm determines single dataflow fact holds single point demand analysis preferable exhaustive analysis reasons narrowing focus specific points interest software-engineering tools dataflow analysis require information set program points similarly program optimization gains obtained making improvements program hot spots innermost loops demand algorithm cases potential reduce greatly amount extraneous information computed narrowing focus specific dataflow facts interest dataflow information desired program point full set dataflow facts required uninitialized-variables problem ordinarily interested determining variables uninitialized determining information variables reducing work preliminary phases problems decomposed separate phases information phase required subsequent phases maymod problem determines call site variables modified call problem decomposed phases computing side effects disregarding aliases so-called dmod problem computing alias information demand maymod set call site demand algorithm potential reduce drastically amount work spent earlier phases propagating relevant demands alias pairs dmod sidestepping incremental-updating problems transformation performed point program affect previously computed dataflow information points program cases information points longer safe dataflow information updated perform transformations points incremental dataflow analysis maintain complete information program points updating invalidated information expensive alternative demand dataflow information needed validate proposed transformation demand solved current program answer up-to-date demand analysis user-level operation desirable program-development tools user questions interactively aspects program tools debugging understand complicated code transform program execute efficiently parallel machine programmer questions program points solving user sequence demands significantly costly performing exhaustive analysis determining fact holds point require determining related facts hold points facts facts interest sense bullet-point desirable demand-driven program-analysis algorithm minimize amount auxiliary information computed program-analysis problems transformed cfl-reachability problems demand algorithms obtained free solving single-source single-target multi-source multi-target cflreachability problems instance problem transformation section devise demand algorithms interprocedural dataflow analysis algorithm solving single-target multi-target reachability problems focuses nodes reach specific target minimizes amount extraneous information computed case ifds problems discussed section answer single demand solve single-source single-target realizable -path problem realizable path node startmain node exhaustive algorithm solve single-source realizable -path problem set 
nodes realizable path startmain general solve single-source single-target single-source multi-target cfl-reachability problems faster single-source cfl-reachability problems experimental results showed situations small number demands made demands answered demand algorithm idfs problems single-source single-target single-source multi-target realizable -path problems runs faster exhaustive algorithm single-source realizable -path problem case partially balanced parenthesis problems hybrid scheme pure exhaustive pure demand-driven approach hybrid approach takes advantage fact natural divide partially balanced parenthesis problems stages stage carried exhaustive fashion individual queries answered demand-driven basis description explain hybrid technique backward interprocedural slicing similar technique applies case ifds problems preprocessing step adds summary edges sdg summary edge represents matched path actual-in actual-out node nodes call site number procedures program maximum number control flow edges procedure pdg params maximum number actual-in nodes procedure pdg callsites params summary edges task identifying summary edges performed time params callsites params augmented sdg sdg summary edges added demand-driven stage involves regular-reachability problems augmented sdg stage linear grammars unbalanced-right unbalanced-right summary realizable summary realizable unbalanced-right realizable unbalanced-right callsites realizable callsites suppose find backward slice respect sdg node solve single-target realizable -path problem node yields set nodes subset actual-out nodes set nodes slice solution multi-target unbalancedright -path problem respect advantage approach regular-reachability problem slice solved time linear number nodes edges augmented sdg time callsites params approach wisconsin program-slicing tool slicing system supports essentially full language system license wisconsin successfully applied slice programs large lines program analysis graph reachability graph-reachability approach offers insight ways machinery powerful graphreachability techniques brought bear program-analysis problems generalize cfl-reachability approach stems observation cfl-reachability problems correspond chain programs restricted class datalog programs fact cfl-reachability problems related chain programs fact chain programs special case logic programs tabulation transformation techniques apply suggests powerful program-analysis algorithms obtained class pure chain programs generalize cfl-reachability approach bring powerful techniques bear interprocedural dataflow analysis presented method applies problems dataflow information program point represented finite environment mapping finite set symbols finite-height domain values effect program operation captured distributive environment-transformer function class dataflow problems called interprocedural distributive environment problems ide problems short dataflow-analysis problems ide framework handles decidable variants constant-propagation problem copy-constant propagation linear-constant propagation interprets assignment statements form interprets statements form means explosion transformation similar utilized section interprocedural problem transformed problem program supergraph problem graph larger edge labeled simpler edge function so-called micro-function micro-function edge captures effect symbol argument environment symbol result environment fig shows exploded representations environment-transformer functions constant propagation fig shows identity function env env represented figs show representations functions env env env env env env env env dataflow functions statements represent effects function independent argument environment graph includes edge form labeled section edges needed capture function composition properly dynamic programming exploded supergraph find paths solution original problem exhaustive algorithm find values symbols program points demand algorithm find individual symbol env env env env env env env env env env fig exploded representations environment-transformer functions constant propagation program point experiment carried exhaustive demand algorithms perform constant propagation programs ranged size lines lines experiment found contrast previous results numeric fortran programs linear-constant propagation found constants copy-constant propagation programs demand algorithm demand values scalar integer variables faster exhaustive algorithm factor ranging related work paper describes number program-analysis problems solved transforming cfl-reachability problems section discusses cfl-reachability approach relates previous work program analysis graph reachability analyzing programs variety work exists applied graph reachability forms analysis imperative programs kou hecht gave linear-time graph-reachability algorithms solving intraprocedural bit-vector dataflow-analysis problems approach applied intraprocedural bidirectional bit-vector problems khedker dhamdhere cooper kennedy reachability give efficient algorithms interprocedural side-effect analysis alias analysis cfl-reachability program analysis callahan work flowsensitive side-effect analysis horwitz reps binkley work interprocedural slicing cases limited forms cfl-reachability employed kinds matched-parenthesis dyck languages paper relates work general concept cfl-reachability dyck languages earlier work interprocedural dataflow analysis sharir pnueli contributions kinds infeasible execution paths filtered dataflow-analysis algorithms sharir pnueli based machinery pure graph reachability dyck-language reachability shown reps sagiv horwitz utility wide variety interprocedural program-analysis problems ideas elaborated sequence papers applied shape-analysis problem papers limited forms cfl-reachability variations dycklanguage reachability author aware connection general concept cfl-reachability fall papers mentioned mentions cflreachability explicitly yannakakis paper construction melski presented section constructions melski reps converting set-constraint problems cfl-reachability problems show cfl-reachability path languages dyck languages utility program analysis ifds framework interprocedural dataflow analysis ide framework interprocedural dataflow analysis summarized sections related earlier interprocedural dataflow-analysis frameworks defined sharir pnueli knoop steffen ifds ide frameworks basically variants sharir-pnueli framework modifications case ifds framework dataflow domain restricted subset domain finite set case ide framework dataflow domain restricted domain environments dataflow functions required distributive iii edge call node return-site node dataflow function conditions restrictions make ifds ide frameworks general full sharir-pnueli framework condition iii generalizes sharir-pnueli framework permits cover programming languages recursive procedures local variables parameters sharir-pnueli framework generalization handle recursive procedures local variables parameters proposed knoop steffen ifds ide problems solved number previous algorithms including elimination iterative call-strings algorithms sharir pnueli algorithm cousot cousot general ifds ide problems iterative call-strings algorithms exponential time worst case knoop steffen give algorithm similar sharir pnueli elimination algorithm efficiencies sharir-pnueli knoop-steffen elimination algorithms depend things functions represented representations discussed sharir-pnueli knoop-steffen algorithms manipulate functions pointwise efficient algorithms presented recently ramalingam shown framework similar ide framework develop theory dataflow frequency analysis information obtained probability dataflow fact holds true program execution holley rosen investigated qualified dataflow analysis problems qualifications device paths flow graph considered employ expansion phase similarities creation exploded supergraph section holley rosen advantage distributivity expansion pointwise interprocedural problems holley-rosen approach equivalent sharir-pnueli callstrings approach recently work demand-driven dataflow analysis considered intraprocedural case work based cfl-reachability discussed section work demanddriven interprocedural dataflow analysis includes fact demand algorithms obtained free program-analysis problem expressed cfl-reachability problem means demand algorithms exist shape-analysis points-toanalysis problems section classes setconstraint problems section logic programming analyzing programs logic programming performing interprocedural dataflow analysis emphasis obtaining demand algorithms reps presented algorithms solve demand versions interprocedural analysis problems obtained automatically exhaustive counterparts expressed logic programs making magic-sets transformation general transformation developed logic-programming deductive-database communities creating efficient demand versions bottom-up logic programs reps illustrated approach showing obtain demand algorithm interprocedural locally separable problems interprocedural versions classical 
bit-vector gen-kill problems reaching definitions expressions live variables work warren tabulation techniques top-down evaluation logic programs alternative method obtaining demand algorithms programanalysis problems applying magic-sets transformation horn-clause encoding exhaustive dataflow-analysis algorithm bottom-up evaluator original untransformed horn-clause encoding simply evaluated oldt top-down tabulating evaluator obtain implementations demand algorithms interprocedural dataflow analysis interprocedural slicing cfl-reachability problems make suny-stony brook xsb system algorithms ifds ide frameworks straightforward implementations logic programs demand algorithms frameworks obtained applying magic-sets transformation tabulating top-down evaluator previous work intraprocedural dataflow-analysis problems expressed horn clauses instance examples ullman book shows logic database solve intraprocedural reaching-definitions problem assmann examined variety intraprocedural program-analysis problems assmann expresses problems kind graph grammar points formalism equivalent datalog relationship cfl-reachability problems set-constraint problems earlier work reynolds jones muchnick number people recent years explored set constraints analyzing programs set constraints typically collect superset set values program variables hold execution typically set variable created program variable program point set constraints generated approximate program behavior program analysis problem finding solution set-constraint problem set constraints program analysis type inference papers literature converting set-constraint problems graph-reachability problems exploited conceptual standpoint implementation standpoint melski reps obtained number results relationship set constraints graph reachability results establish relationship directions showed cflreachability problems subclass called definite set constraints equivalent cfl-reachability problem construct set-constraint problem answer solution cfl-reachability problem likewise set-constraint problem construct cfl-reachability problem answer solution set-constraint problem results extended cover class set constraints analyzing programs written higher-order languages benefits gained knowing cfl-reachability problems classes set-constraint problems interconvertible advantage conceptual standpoint confronted program-analysis problem reason terms whichever paradigm analogous situation formal-language theory finite-state automata regular expressions pushdown automata context-free grammars sections cfl-reachability leads natural formulations interprocedural dataflow analysis interprocedural slicing set constraints lead natural formulations shape analysis problems formulated respective opposite formalism awkward discussed section interconvertibility formalisms offers insight bottleneck program-analysis problems interconvertibility formalisms results previously obtained cfl-reachability problems applied set-constraint problems vice versa cfl-reachability log-space complete polynomial time ptime-complete construction performed log-space set-constraint problems considered ptime-complete ptime-complete problems believed efficiently parallelizable solved polylog time polynomial number processors extends class program-analysis problems efficient parallel algorithms discussed section demand algorithm computes partial solution problem part full answer needed cfl-reachability problems solved demanddriven fashion melski reps results show principle set-constraint problems solved demand-driven fashion knowledge previously investigated literature set constraints set constraints analyzing programs written higher-order languages applications cfl-reachability program analysis limited first-order languages recent work interconvertibility cfl-reachability problems class set constraints analyzing programs written higher-order languages shows cflreachability framework capable expressing analysis problems program slicing shape analysis higher-order languages constructions shows cfl-reachability applied problem slicing programs written higher-order language manipulates heap-allocated data structures permit destructive updating fields problem previously addressed literature program slicing applications cfl-reachability yannakakis surveys literature applications graph-theoretic methods database theory discusses types graph-reachability problems including cfl-reachability dolev karp cfl-reachability devise formal model studying vulnerability intrusion party class two-party ping-pong protocols distributed systems intrusion party messages system protected public-key encryption setting studied dolev karp intruder legitimate user network intercept alter messages impersonate users initiate instances protocol users order responses complex manipulations read messages supposed protected cracking cryptographic systems dolev karp reduce security-validation problem single-source single-target cflreachability problem labeled edges represent operations context-free language captures natural laws cancellation pairs actions place protocol encryption user encryption function cancels decryption decryption function decryption decryption function cancels encryption encryption function action sender appending message cancels action recipient stripping appended message comparing protocol shown insecure graph path word language language words correspond sequences actions intruder provoke reveal contents unencrypted message horwitz reps binkley pointed correspondence call structure program context-free grammar intraprocedural transitive dependences pdg parameter nodes dependences attributes attribute grammar exploited correspondence compute summary edges hybrid partly exhaustive partly demand scheme interprocedural slicing discussed section generally computation graphs attribute grammars similar approximations characteristic graphs attribute grammar nonterminals computed polynomial time tds graphs ordered attribute grammars expressed cfl-reachability problems cfl-reachability algorithms number problems formal-language theory including determining regular language resulting intersection regular language context-free language empty cfl-reachability regular language finite-state automaton context-free language context-free grammar solving recognition problem two-way pushdown automata applications string-matching problems two-way pushdown automaton pushdown automaton head reading input tape permitted move directions single transition machine input head remain move square move square left two-way pushdown automaton deterministic dpda nondeterministic npda problem dpda-recognition resp npda-recognition dpda resp npda string determine determining input-free deterministic non-deterministic pushdown automaton accepts acknowledgements paper based part joint work horwitz sagiv rosay melski section based heretofore unpublished result melski kleinberg pointed cflreachability afrati papadimitriou parallel complexity simple chain queries proc sixth acm symp princ database syst san diego mar agrawal slicing programs jump statements proc acm sigplan conf prog lang design implementation orlando june sigplan june aho hopcroft ullman design analysis computer algorithms addison-wesley reading aho algorithms finding patterns strings handbook theor comp sci vol algorithms complexity van leeuwen press cambridge aiken murphy implementing regular tree expressions func prog comp arch acm conf cambridge aug lec notes comp sci vol hughes springer-verlag york aiken murphy static type inference dynamically typed language conf rec eighteenth acm symp princ prog lang orlando jan acm york aiken wimmers type inclusion constraints type inference sixth conf func prog comp arch copenhagen denmark june allen baumgartner kennedy porterfield ptool semi-automatic parallel programming assistant proc int conf parallel processing ieee comp soc press wash andersen program analysis specialization programming language diss report topps datalogisk institut univ copenhagen copenhagen denmark assmann edge addition rewrite systems relevance program analysis proc workshop graph grammars application comp sci williamsburg nov lec notes comp sci vol cuny springer-verlag york babich jazayeri method attributes data flow analysis part demand analysis acta inf oct ball horwitz slicing programs arbitrary control flow proc int workshop automated algorithmic debugging linko ping sweden lec notes comp sci vol springer-verlag york bancilhon maier sagiv ullman magic sets strange ways implement logic programs proc acm symp princ database syst cambridge mar bannerjee speedup ordinary programs diss tech rep dept comp sci univ illinois urbana oct banning efficient find side effects procedure calls aliases variables conf rec sixth acm symp princ prog lang san antonio jan acm york bates horwitz incremental program 
testing program dependence graphs conf rec twentieth acm symp princ prog lang charleston jan acm york beeri ramakrishnan power magic proc sixth acm symp princ database syst san diego mar binkley semantic differencing reduce cost regression testing proc ieee conf softw maint orlando nov ieee comp soc wash binkley gallagher program slicing advances computers vol zelkowitz academic press san diego callahan program summary graph flow-sensitive interprocedural data flow analysis proc acm sigplan conf prog lang design implementation atlanta june sigplan july chase wegman zadeck analysis pointers structures proc acm sigplan conf prog lang design implementation white plains june sigplan june choi ferrante static slicing presence goto statements acm trans program lang syst july cooper kennedy interprocedural side-effect analysis linear time proc acm sigplan conf prog lang design implementation atlanta june sigplan july cooper kennedy fast interprocedural alias analysis conf rec sixteenth acm symp princ prog lang austin jan acm york cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixpoints conf rec fourth acm symp princ prog lang los angeles jan acm york cousot cousot static determination dynamic properties recursive procedures formal descriptions programming concepts ifip andrews canada aug neuhold north-holland york deransart jourdan lorho attribute grammars definitions systems bibliography lec notes comp sci vol springer-verlag york dolev karp security ping-pong protocols information control duesterwald gupta soffa demand-driven program analysis tech rep tr- dept comp sci univ pittsburgh pittsburgh oct duesterwald gupta soffa demand-driven computation interprocedural data flow conf rec twenty-second acm symp princ prog lang san francisco jan acm york hndrich foster aiken partial online cycle elimination inclusion constraint graphs proc acm sigplan conf prog lang design implementation montreal canada june acm press ferrante ottenstein warren program dependence graph optimization acm trans program lang syst july fischer leblanc crafting compiler benjamin cummings publishing company menlo park gallagher lyle program slicing software maintenance ieee trans softw eng sepp aug giegerich ncke wilhelm invariance approximative semantics respect program transformation conf inf -fach springer-verlag york goff kennedy tseng practical dependence testing proc acm sigplan conf prog lang design implementation toronto ontario june sigplan june grove torczon interprocedural constant propagation study jump function implementation proc acm sigplan conf prog lang design implementation albuquerque june acm york june hecht flow analysis computer programs north-holland york heintze jaffar decision procedure class set constraints tech rep cmu-cs- school computer science carnegie mellon univ pittsburgh heintze set-based analysis programs tech rep cmu-cs- school computer science carnegie mellon univ pittsburgh july heintze jaffar set constraints set-based analysis workshop principles practice constraint programming holley rosen qualified data flow problems ieee trans softw eng sepp jan horwitz reps binkley interprocedural slicing dependence graphs proc acm sigplan conf prog lang design implementation atlanta june sigplan july horwitz pfeiffer reps dependence analysis pointer variables proc acm sigplan conf prog lang design implementation portland june sigplan july horwitz prins reps integrating non-interfering versions programs acm trans program lang syst july horwitz reps binkley interprocedural slicing dependence graphs acm trans program lang syst jan horwitz identifying semantic textual differences versions program proc acm sigplan conf prog lang design implementation white plains june sigplan june horwitz reps sagiv demand interprocedural dataflow analysis trcomp sci dept univ wisconsin madison aug horwitz reps sagiv demand interprocedural dataflow analysis sigsoft proc acm sigsoft symp found softw eng wash oct acm sigsoft softw eng notes jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications muchnick jones prentice-hall englewood cliffs kastens ordered attribute grammars acta inf kennedy warren automatic generation efficient evaluators attribute grammars conf rec acm symp princ prog lang atlanta jan acm york khedker dhamdhere generalized theory bit vector data flow analysis acm trans program lang syst sept kildall unified approach global program optimization conf rec acm symp princ prog lang acm york knoop steffen interprocedural coincidence theorem proc fourth int conf comp construct paderborn frg oct lec notes comp sci vol kastens pfahler springer-verlag york knuth morris pratt fast pattern matching strings siam computing kou live-dead analysis global data flow problems acm july kuck kuhn leasure padua wolfe dependence graphs compiler optimizations conf rec eighth acm symp princ prog lang williamsburg jan acm york landi ryder pointer-induced aliasing problem classification conf rec eighteenth acm symp princ prog lang orlando jan acm york larus hilfinger detecting conflicts structure accesses proc acm sigplan conf prog lang design implementation atlanta june sigplan july lyle weiser experiments slicing-based debugging tools proc conf empirical studies programming june ablex publishing masinter global program analysis interactive environment tech rep ssl- xerox palo alto res cent palo alto jan maydan hennessy lam efficient exact data dependence analysis proc acm sigplan conf prog lang design implementation toronto ontario june sigplan june mccarthy basis mathematical theory computation computer programming formal systems braffort hershberg north-holland amsterdam melski personal communication reps fall melski reps interconvertibility set constraints context-free language reachability proc acm sigplan symp part eval sem -based prog manip pepm amsterdam netherlands june acm york melski reps interconvertibility set constraints context-free language reachability theor comp sci accepted pending minor revisions mogensen separating binding times language specifications fourth int conf func prog comp arch london sept acm york ncke wilhelm grammar flow analysis attribute grammars applications systems int summer school saga prague czechoslovakia june lec notes comp sci vol alblas melichar springer-verlag york nielson nielson hankin principles program analysis flows effects cambridge univ press cambridge preparation ning engberts kozaczynski automated support legacy code understanding commun acm ottenstein ottenstein program dependence graph software development environment proc acm sigsoft sigplan softw eng symp practical softw develop env pittsburgh apr sigplan pugh omega test fast practical integer programming algorithm dependence analysis supercomputing nov pugh wonnacott eliminating false data dependences omega test proc acm sigplan conf prog lang design implementation san francisco june sigplan july ramalingam data flow frequency analysis proc acm sigplan conf prog lang design implementation philadelphia acm press reps sagiv horwitz interprocedural dataflow analysis graph reachability datalogisk institut univ copenhagen copenhagen denmark apr reps horwitz sagiv rosay speeding slicing sigsoft proc acm sigsoft symp found softw eng orleans dec acm sigsoft softw eng notes 
dec reps demand interprocedural program analysis logic databases applications logic databases ramakrishnan kluwer academic publishers boston reps solving demand versions interprocedural analysis problems proc int conf comp construct edinburgh scotland apr lec notes comp sci vol fritzson springer-verlag york reps shape analysis generalized path problem proc acm sigplan symp part eval sem -based prog manip pepm jolla california june acm york reps horwitz sagiv precise interprocedural dataflow analysis graph reachability conf rec twenty-second acm symp princ prog lang san francisco jan acm york reps sequential nature interprocedural program-analysis problems acta inf reps turnidge program specialization program slicing proc dagstuhl seminar partial evaluation schloss dagstuhl wadern ger feb lec notes comp sci vol danvy glueck thiemann springer-verlag york reps program analysis graph reachability proc ilps int logic program symp port jefferson oct maluszynski press cambridge reynolds automatic computation data set definitions information processing proc ifip congress north-holland york rohmer lescoeur kersit alexander method technique processing recursive axioms deductive databases generation computing ross sagiv building bridge pointer aliases program dependences proc european symp programming lisbon portugal april sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci shapiro horwitz fast accurate flow-insensitive points-to analysis conf rec twentyfourth acm symp princ prog lang paris france jan acm york sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications muchnick jones prentice-hall englewood cliffs steensgaard points-to analysis almost-linear time conf rec twenty-third acm symp princ prog lang petersburg jan acm york tip survey program slicing techniques program lang ullman van gelder parallel complexity logical query programs proc twenty-seventh ieee symp found comp sci ieee comp soc wash ullman principles database knowledge-base systems vol technologies computer science press rockville valiant general context-free recognition cubic time comp syst sci apr warren memoing logic programs commun acm mar warren xsb logic programming system software system comp sci dept state univ york stony brook ftp sbcs sunysb weiser program slicing ieee trans softw eng sepp july wolfe optimizing supercompilers supercomputers diss tech rep dept comp sci univ illinois urbana oct yannakakis graph-theoretic methods database theory proc ninth acm symp princ database syst younger recognition parsing context-free languages time inf cont zadeck incremental data flow analysis structured program editor proc sigplan symp comp construct montreal june sigplan june 
logical characterizations heap abstractions greta yorsh school comp sci tel-aviv thomas reps comp sci dept wisconsin mooly sagiv school comp sci tel-aviv reinhard wilhelm informatik univ des saarlandes shape analysis concerns problem determining shape invariants programs perform destructive updating dynamically allocated storage recent work shown shape analysis performed abstract interpretation based -valued first-order logic work concrete stores finite -valued logical structures sets stores possibly arise execution represented conservatively family finite -valued logical structures paper show -valued structures arise shape analysis characterized formulas first-order logic transitive closure define non-standard supervaluational semantics -valued first-order logic precise conventional -valued semantics demonstrate supervaluational semantics implemented existing theorem provers categories subject descriptors software program verification general general terms verification additional key words phrases logic characterization canonical abstraction shape analysis introduction abstraction abstract interpretation cousot cousot key tools automatically verifying properties systems hardware systems clarke dams software systems nielson abstract interpretation sets concrete stores represented conservative manner abstract values explained transition system interpretation abstract values conservative respect interpretation sets concrete stores result executing transition abstract describes superset concrete stores arise methodology guarantees results abstract interpretation overapproximate sets concrete stores permission make digital hard copy part material fee personal classroom provided copies made distributed profit commercial advantage acm copyright server notice title date notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee acm acm transactions computational logic vol july pages yorsh arise point system issue arises abstraction employed concerns expressiveness abstraction method collections concrete states expressed abstraction method issue arises abstraction employed extract information abstract instance fundamental problem clients abstract interpretation verification tools program optimizers program-understanding tools interpret abstract means abstract represents set concrete stores ideally query return answer summarizes result posing concrete store true summary answer true false summary answer false true false summary answer unknown paper presents results questions class abstractions originally arose work problem shape analysis jones muchnick chase sagiv shape analysis concerns problem finding shape descriptors characterize shapes data structures program pointer variables point shape analysis challenging problems abstract interpretation generally deals programs written languages java dynamic allocation deallocation cells heap destructive updating structure fields case java iii dynamic creation destruction threads combination features creates considerable difficulties abstract-interpretation method motivation present paper understand expressiveness shape abstractions defined sagiv work concrete stores finite -valued logical structures sets stores possibly arise execution represented conservatively family finite -valued logical structures setting abstract set -valued logical structures notion abstraction sagiv based logical structures results broadly applicable shape-analysis problems applied verification sorting algorithms lev-ami showing absence concurrent modification exception ramalingam correct usage jdbc streams java collections iterators yahav ramalingam correctness concurrent queue algorithms yahav sagiv modelling concurrency java programs dynamic creation objects threads yahav analyzing processes ambient calculus nielson reducing space consumption java programs compile-time memory management application javacard programs shaham fact results apply abstraction concrete states system represented finite -value logical structure abstraction performed mechanisms sections approach paper relevant addressing expressibility issues number abstractions related sagiv including mcmillan kuncak godefroid jagadeesan huth clarke clarke acm transactions computational logic vol july logical characterizations heap abstractions allocation-site abstraction points-to analysis andersen steensgaard shapiro horwitz ahndrich das heintze tardieu objects allocated single statement represented single abstract memory object jones muchnick chase paper shape-analysis examples illustrate concepts discussed paper investigates expressiveness finite -valued structures giving logical characterization structures examine question -valued structure circumstances create formula hatwide satisfies hatwide valued structure represents hatwide iff represents paper presents results question give formulahatwide written first-order logic transitive closure arbitrary structure section well-defined class -valued structures class includes -valued structures shown shape analysis sagiv give ahatwide general powerful formalism monadic second-order formulas ability write formula hatwide captures represents fundamental tool improving tvla lev-ami sagiv symbolic methods current tvla system performs iterative fixed-point computations yields program point set -valued structures represent superset stores arise point execution tvla suffers limitations precise explained scale handle large programs worst-case complexity algorithm doubly-exponential parameters typically number program variables contributions paper lay required groundwork symbolic techniques address limitations ability characterize -valued structure formulahatwide key step harnessing standard -valued theorem prover aid abstract interpretation computing effect program statement abstract most-precise shape-analysis abstraction developing modular shape-analysis assume-guarantee reasoning idea arbitrary first-order formulas express preand post-conditions enabling code procedure analyzed potential contexts shape analysis applications source code specifically profitable recursive procedures saves iterate shape analysis methods subject yorsh lam contribution paper directly addresses aforementioned limitations tvla current technique give procedure extracting information -valued logical structure most-precise give nonstandard check formula holds acm transactions computational logic vol july yorsh hatwide valid holds -valued structures evaluates -valued structures represented hatwide valid evaluates -valued structures represented exists -valued structure represented evaluates exists -valued structure represented evaluates method represents most-precise extracting information -valued logical structure method returns standing unknown sound method extracting information return contrast techniques sagiv return -valued structures represented practical purposes success symbolic methods depends terminating theorem prover validity question undecidable first-order logic transitive closure theorem provers first-order logic created paper report experiments tools implement symbolic procedures extracting information -valued structure most-precise performed successful experiments symbolic operations yorsh erez experiments preliminary approach made work practice progress recently spass including transitive closure lev-ami immerman identified decidable subset first-order logic transitive closure shape analysis define conditions whichhatwide expressed logic section investigating decidable logics remainder paper organized section defines terminology explains -valued structures abstractions -valued structures section presents results expressiveness -valued structures algorithm generatinghatwide families -valued structures section discusses problem reading information -valued structure most-precise section discusses applications ofhatwide program analysis implementation issues section discusses related work appendix defines alternative abstract domain shape analysis based canonical abstraction hatwide operation domain appendix shows characterize general -valued structures appendix details paper examples proofs appendix preliminaries section defines syntax standard tarskian semantics first-order logic transitive closure equality section introduces integrity formulas exclude structures represent potential store section introduces -valued logical structures extend ordinary logical structures extra represents unknown values arise concrete nodes represented single abstract node powerset -valued structures forms abstract domain related concrete domain consisting powerset -valued structures embedding section acm transactions computational logic vol july logical characterizations heap abstractions list typedef struct node struct 
node int data list insert include list void insert list int list assert acyclic list null null malloc data fig declaration linked-list data type function searches list pointed parameter splices element fig shows declaration linked-list data type fig shows program searches list splices element list program running paper syntax semantics first-order formulas transitive closure represent concrete stores ordinary -valued logical structures fixed finite set predicate symbols designated binary predicate denoting equality nodes maxr denote maximal arity predicates loss generality exclude constant function symbols logic table lists set predicates running unary predicates correspond program variables binary predicate corresponds fields list elements unary predicate shared captures heap sharing list elements pointed field introduced chase capture list tree data structures unary predicates hold heap nodes reachable program variables heap node reachable program variable variable points heap node n-links reachability defined term reflexive transitive closure predicate notion reachability plays crucial role defining abstractions proving program properties practice instance effect preventing disjoint lists collapsed abstract representation significantly improve precision answers obtained program analysis constant symbols encoded unary predicates n-ary functions -ary predicates acm transactions computational logic vol july yorsh predicate intended meaning denote heap node pointer variable point node field point pointed field node reachable table set predicates representing stores manipulated programs list data-type fig denotes arbitrary predicate set predicate program variable type list case insert pvar define first-order formulas inductively vocabulary logical connectives quantifier operator standard variables formulas set free variables formula defined usual formula closed free variables operator denotes transitive closure formula free variables formula free variables shorthand notations transitive closure binary predicate reflexive transitive closure binary predicate order precedence connectives highest lowest drop parentheses emphasis definition -valued logical structures denote set predicate symbols arity logical structure pair possibly infinite set nodes interpretation predicate symbols predicate symbol determines tuples holds interpretation equality iff define standard tarskian semantics first-order logic definition semantics first-order logical formulas logical structure assignment function maps free variables nodes assignment functionality assignment defined free variables formula called complete sequel assume assignment arises connection discussion formula complete satisfy formula denoted holds hold acm transactions computational logic vol july logical characterizations heap abstractions exists node mapsto exists mapsto mapsto closed formula omit assignment satisfaction relation write integrity formula logical structures represent stores designated closed formula called integrity formula exclude structures interest application structures correspond stores restrict set structures satisfying definition structure admissible rest paper assume work fixed integrity formula notations parameterized list data type conditions define admissible structures time execution program variable point heap node field heap node point heap node predicate shared holds nodes predecessors reachability predicate variableq holds nodes reachable program variable set pvar predicate program variable type list case insert pvar integrity formula flist list data-type pvar pvar -valued logical structures embedding section define -valued logical structures provide represent set -valued logical structures compact conservative values definite values indefinite define partial order truth values reflect information content denotes possibly definite information definition information order define information order truth values sagiv called hygiene conditions acm transactions computational logic vol july yorsh fig examples -valued structures representing linked-lists pointed program variable length represents lists pointed program variable elements including lists represented definition -valued logical structure generalization -valued structures definition predicates means addition distinct nodes node called summary node node represent node -valued structure denote set -valued logical structures -struct set -valued logical structures denoted -struct -valued structure depicted directed graph nodes graph nodes unary predicate represented graph solid arrow predicate node node arrow nodes binary predicate holds pair nodes indefinite predicate shown dotted arrow shown solid arrow shown absence arrow fig shows -valued structure represents inputs insert program structure represents lists pointed program variable elements structure nodes head list pointed summary node drawn double circle represents tail list predicate holds indicating elements list reachable unary predicates shown indicating values nodes program variables null sharing list dotted edge n-links head list elements tail fact -edge represents n-link points list element conjunct integrity formula contrast dotted self-loop represents n-links occur tail embedding order define embedding ordering structures acm transactions computational logic vol july logical characterizations heap abstractions definition logical structures surjective embeds denoted predicate symbol embedded denoted exists function fig show -valued structures embedded -valued structure shown fig function embeds maps node usa function embeds maps node usb usb holds predicate definite predicate similarly binary predicate remark embedding viewed variant homomorphism hell nesetril cases -valued structure predicates definite values including interpreted standard equality checking -valued structure embeds equivalent checking isomorphism cases nodes summary nodes values predicates definite embedding equivalent strong homomorphism cases nodes summary nodes values predicates embedding equivalent homomorphism cases predicate tuple embedding generalizes notion homomorphism remark definition require surjective order guarantee quantified formula consistent values -valued structures related embedding surjective exist individual range assigned permit structures concretization -valued structures embedding define potentially infinite set concrete structures set -valued structures represents definition concretization -valued structures set structures -struct denote set -valued structures represents -struct exists xsuch singleton set write shows valued structures figs a-c integrity formula satisfied concretization -valued structure note indefinite values predicates values reflects fact abstract acm transactions computational logic vol july yorsh node represent concrete node nodes represented abstract domain powerset -valued structures ordering relation defined sets -valued structures iff exists embedded analysis technique tvla lev-ami sagiv system carries abstract interpretation cousot cousot collect set structures program point involves finding fixed point set equations ensure termination analysis carried respect finite abstract domain set structures finite fixed point reached structures collected program point describe superset concrete stores occur determine query satisfied checks holds structures collected instantiations framework capable establishing nontrivial properties programs perform complex pointerbased manipulations priori unbounded-size heap-allocated data structures characterizing -valued structures first-order formulas section presents results characterizing -valued structures first-order formulas -valued structure question answer give formulahatwide accepts set -valued structures represents hatwide iff question answers depending assumptions made task generating characteristic formula -valued structure challenging find formula identifies embedding satisfied -valued structures embed characterize arbitrary -valued structure first-order formula exists -valued structure first-order formula transitive closure accepts set -valued structures -valued structure shown fig absence loop 
summary nodes implies -valued structure embedded structure colored colors lemma appendix well-known exists first-order formula transitive closure expresses -colorability undirected graphs immerman courcelle first-order formula accepts set remark fact condition stronger first-order logic transitive closure express non-deterministic logspace computations np-complete problem -colorability expressible first-order logic shown immerman ordering relation nodes context ordering logic expressive condition -colorability expressible stronger valued structure expressible logic independently question main focus current paper acm transactions computational logic vol july logical characterizations heap abstractions fig -valued structure represents -colorable undirected graphs -valued structure embedded structure colored colors fo-identifiable structures intuitively difficulty characterizing -valued structures uniquely identify correspondence concrete abstract nodes first-order formula fortunately subclass -valued structures shape analysis bounded structures correspondence easily defined first-order formulas bounded structures subclass -valued structures identify uniquely node first-order formula definition -valued structure called fo-identifiable node exists first-order formula nodesu designated free variable -valued structure embeds function concrete node node mapsto nodesui idea definition formula uniquely identifies node -valued structure identify set nodes -valued structure mapped embedding words concrete node satisfies node formula abstract node formalized lemma lemma fo-identifiable structure distinct nodes -valued structure embeds hold mapsto nodesu mapsto nodesu remark definition generalized handle arbitrary -valued structures allowing extra designated free variables concrete node equality check concrete node equal designated variable nodesui equality formula identify nodes -valued structure equality evaluates summary nodes introduce standard concept turning valuations formulas definition predicate arity truth define formula characteristic formula acm transactions computational logic vol july yorsh main idea definition holds unrestricted formalized lemma lemma -valued structure assignment iff definition constructive definition premises range arbitrary -valued structures arbitrary embedding functions reason introduce testable condition implies fo-identifiability bounded structures subclass -values structures defined sagiv motivation guarantee shape analysis carried respect finite set abstract structures analysis terminate definition bounded structure vocabulary structure negationslash exists predicate symbol negationslash intuitively pair nodes bounded structure predicate definite values nodes finite number bounded structures isomorphism lemma shows bounded structures fo-identifiable formulas unary predicates denoted lemma bounded -valued structure fo-identifiable nodesui logicalanddisplay first-order node formulas structure shown fig nodesu nodesu remark case bounded -valued structure definition bounded structure trivial reason node named quantifierfree formula built unary predicates essentially node named constant structure embeds isomorphic nodes constants restricted case interest guarantee termination shape analysis operates structures summary nodes indefinite values definition bounded structures sagiv slightly restrictive sagiv lev-ami impose requirement limit set problems handled method structure bounded weak sense fo-identifiable acm transactions computational logic vol july logical characterizations heap abstractions fig -valued structure fo-identifiable bounded case summary node structure embeds unbounded number nodes nodes named finite set constants language interesting cases fo-identifiable structures bounded generalize abstraction defined sagiv -valued structure fig fo-identifiable nodes nodes nodes bounded structure nodes values unary predicates distinguish nodes extended nodes underlined subformula captures fact directly pointed n-edge shown fo-identifiable structure converted bounded structure introducing instrumentation predicates methodological reasons notion fo-identifiable directly capture ability uniquely identify embedding formulas interesting features fo-identifiable structures structures generated common tvla operation focus defined lev-ami fo-identifiable lemma appendix fig shows structure structures resulting applying focus operation structure fig formula fo-identifiable bounded structures shown fig fo-identifiable characterizing fo-identifiable structures characterize fo-identifiable -valued structure ensure existence surjective embedding function concrete node represented abstract node concrete abstract predicate values meet embedding condition subsequent sections redefine notion capture classes structures acm transactions computational logic vol july yorsh definition first-order characteristic formula fo-identifiable -valued structure define totality characteristic formula closed formula stotal nlogicalordisplay nodesui define nullary characteristic formula closed formula snullary logicalanddisplay predicate arity define predicate characteristic formula closed formula logicalanddisplay logicalandtextr node characteristic formula defined logicalandtextni nodesui stotal snullary logicalandtextmaxrr logicalandtextp characteristic formula set -struct defined hatwide logicalordisplay finally singleton set writehatwide ofhatwide main ideas conjuncts existential quantification conjunct requires -valued structures distinct nodes abstract node sub-formula locates concrete node conjunct guarantees embedding surjective totality formula ensures concrete node represented abstract node guarantees embedding function well-defined nullary characteristic formula ensures values nullary predicates -valued structures precise values nullary predicates predicate characteristic formulas guarantee predicate values -valued structures obey requirements imposed embedding definition relates fo-identifiable structures bounded structures bounded structures simplified omitting unary predicates implied stotal fact omitted abstraction predicates defined sagiv paper unary predicates abstraction predicates acm transactions computational logic vol july logical characterizations heap abstractions small amount simplification characteristic formulahatwide structure shown fig flist nodesu nodesu nodesu nodesu logicalandtextp logicalandtexti nodesui nodesu nodesu nodesu nodesu node formulas predicates insert program fig shown table simplified formula combining implications premises integrity formula flist note transitive closure define reachability predicates hatwide formula first-order logic transitive closure predicate indefinite node tuple conjunct omitted simplifies size simplified version linear number definite values predicates assuming nodes formulas quantifiers transitiveclosure operator bounded formula quantifier alternation occurrences transitive-closure operator formulahatwide existential-universal normal form decidable satisfiability existential-universal normal form transitive closure maximal arity predicate hatwide two-variable fragment first-order logic mortimer section discuss conditions whichhatwide expressed decidable logic theorem shows fo-identifiable structure formula hatwide accepts set -valued structures represented theorem fo-identifiable -valued structure -valued structure iff hatwide supervaluational semantics first-order formulas section problem extract information -valued structure evaluating query compositional semantics -valued first-order logic defined sagiv semantics precise defined semantics section providing limit obtainable precision notion supervaluational semantics defined van fraassen bruns godefroid definition supervaluational semantics first-order formulas set -valued structures closed formula supervaluational semantics denoted defined join values obtained practical reasons replace node formula definable predicate add definition integrity formula acm transactions computational logic vol july yorsh procedure supervaluation formula set -valued structures valid return valid return return fig procedure computing supervaluational formula encodes query -valued structures -valued structures represents most-precise conservative reported formula -valued structures represented negationslash compositional semantics sagiv tvla yield -valued structures represents contrast supervaluational semantics yields sound extraction information return demonstrate supervaluational semantics formula nextnegationslash null structure fig argue -valued structures structure fig represents formula nextnegationslash null reason represents list nodes -valued structures represented nodes node pointed program variable node summary node reachable sequence nodes reachable starting denote node sequence embeds definition reachability n-link node embedded integrity rules guarantee node embeds formula holds mapsto mapsto note formula evaluated tvla evaluates assignment mapsto 
mapsto compositional semantics yields notice definition provide constructive compute infinite set computing supervaluational semantics theorem provers theorem prover hand computed procedure shown fig procedure algorithm theorem prover terminate termination assured standard techniques theorem prover return safe answer time-out threshold exceeded cost losing ability guarantee most-precise result obtained queries posed operation supervaluation expressed decidable logic algorithm computing supervaluation implemented decision procedure logic section discuss decidable logics shape analysis acm transactions computational logic vol july logical characterizations heap abstractions applications experiments discussed section demonstrate hatwide operation harnessed context program analysis results previous systems capable section discuss existing theorem provers limitations section suggest overcome limitations decidable logic present examples usehatwide read information -valued structures conservative precise demonstrates supervaluational semantics obtain precise information -valued structure compositional semantics demonstrates -valued structures obtained tvla analysis construct loop invariant show properties linked data structure hold loop iteration addition briefly describe hatwide algorithms computing most-precise abstraction operations shape analysis finally report work employshatwide generate concrete counter-example shape analysis remark thehatwide operation defines symbolic concretization respect abstract domain section defined hatwide abstract domain sets -valued structures appendix describe related abstract domain definehatwide applications section domain whichhatwide defined logic theorem prover logic exists examples hatwide defined section first-order logic transitive closure first-order theorem prover spass tvla lev-ami sagiv system performs iterative fixed-point computation yields program point set bounded structures guarantees superset -valued structures arise execution implemented hatwide operation tvla employed spass weidenbach check formulahatwide properties heap hold program point implemented supervaluational procedure section employing spass enhanced version tvla generates formula hatwide makes calls spass compute supervaluational query structure section report experience spass problems encountered calls spass theorem prover terminate first-order logic undecidable general examples spass terminated manually proved supervaluational formula nextnegationslash null structure fig check automatically spass determine validity ofhatwide nextnegationslash null spass formula valid guarantees formula nextnegationslash null evaluates -valued structures embed contrast tvla kleene semantics -valued formulas evaluate formula nextnegationslash null assignment mapsto mapsto evaluates equals generating querying loop invariant tvla compute program point set bounded structures overapproximate set acm transactions computational logic vol july yorsh stores occur point generated hatwide tvla sound hatwide invariant holds program point theorem program point begins loop hatwide loop invariant denote set -valued structures tvla found beginning loop insert program fig table table iii appendix show characteristic formulas loop invariant defined hatwide flist logicalordisplay spass formula check structure occur beginning loop points valid list acyclic unshared property defined formulas acycx unsx listx acycx unsx applied spass check validity ofhatwide listx spass formula valid addition termination issue obstacle spass considers infinite structures allowed setting consequence spass fail verify formula valid intended set structures opposite happen spass formula valid valid intended set structures verify concrete linked-list represented valued structure fig element condition expressed formula supervaluational structure reasons definite concrete nodes represented summary node reachable nodes form linked list concrete nodes node n-edge concrete node represented node n-edge back nodes represented create sharing predicate node n-edge concrete node represented predicate pair element outgoing n-edge spass determine validity hatwide spass formula valid considered structure infinitely concrete nodes represented concrete nodes n-edge node validity test formula hatwide failed exists finite structure represented satisfies hatwide element spass input tau gretay intended structures finite represent memory configurations guaranteed finite size bounded acm transactions computational logic vol july logical characterizations heap abstractions fig spass takes account structures predicate overapproximates predicate structure shown figure structure fig represents list size procedure supervaluation implemented spass returns supervaluational severe problem face spass support transitive closure transitive closure expressible first-order logic partially model transitive closure spass spass theorem provers allowing axioms express requirements set structures considered spass axioms model integrity rules partially model transitive closure replaced designated predicate spass structures represent stores consequence spass fail verify formula valid intended set structures opposite happen spass formula valid valid intended set structures avoid spurious failures prove validity added axioms guarantee transitive includes includes transitive closure requires minimal set expressible first-order logic approach looser set integrity rules case spass formula valid valid set structures spass takes account structure shown fig n-edge remark practical purposes success symbolic methods depends terminating theorem prover successfully spass part prototype implementation assume operation section path-pruning optimization counter-example generation section experiments preliminary approach made work practice recent progress spass including transitive closure lev-ami investigated complementary approach discussed section decidable logic obstacles mentioned section specific spass occur theorem provers first-order logic aware address obstacles investigating decidable logic reason linked data structures acm transactions computational logic vol july yorsh notion reachability expressible transitive closure logic decidable includes reachability limited aspects decidable second-order theory successors rabin decision procedure implemented tool called mona henriksen second-order quantification suffices express reachability problems decision procedure necessarily non-elementary meyer applies trees equivalently function graphs graphs edge leaving vertex subset first-order logic transitive closure restriction imposed formulas existential-universal form single unary function arbitrary number unary predicates immerman shows decision procedure satisfiability nexptime-complete spite limitations reasoning shape invariants mutation operations data structures singly doubly linked lists shared trees graph types klarlund schwartzbach key simulation technique immerman encodes complex datastructures tractable structures function graphs simple trees reason decidable logics suitable simulation hatwide formula expressed integrity formula definition ofhatwide fact quantifier alternation makes candidate implementations decision procedure supervaluational semantics algorithms assume-guarantee shape analysis hatwide operation computing supervaluational semantics operation algorithms yorsh reps algorithms perform abstract operations symbolically representing abstract values logical formulas theorem prover check validity formulas algorithms improve existing shape-analysis techniques conducting abstract interpretation most-precise fashion improving technique tvla system lev-ami sagiv sagiv guarantees precision basic mechanisms performing modular verification assume-guarantee reasoning procedure specifications most-exciting potential application ofhatwide logic existing mechanisms shape analysis including tvla support assume-guarantee reasoning counter-example generation preliminary work techniques presented paper improve applicability tvla carried tool erez erez hatwide operation generate concrete counter-example potential error message produced tvla intermediate -valued structure program point tool check reported error real error false-alarm occurs concrete store acm transactions computational logic vol july logical characterizations heap abstractions generation concrete counter-examples proceeds converted formulahatwide tool weakest precondition generate formula represents stores entry point lead execution trace reaches store satisfieshatwide finally separate tool mccune generates concrete store 
satisfies formula entry point related work sizeable literature structure-description formalisms describing properties linked data structures benedikt sagiv motivation present paper understand expressive power shape abstractions defined sagiv previous work benedikt benedikt showed translate kinds shape descriptors path matrices hendren hendren nicolau variant shape graphs discussed sagiv logic called logic reachability expressions shape graphs sagiv amenable techniques presented present paper characteristic formula defined simpler translation benedikt applies general class shape descriptors logic benedikt decidable guarantees terminating procedures problems addressed pointer analysis logic engine pale ller schwartzbach structure-description formalism serves assertion language assertions translated second-order monadic logic fed mona pale handle data structures handle data structures describable graph types klarlund schwartzbach logic mona decidable pale guaranteed terminate point contrast shape abstractions based -valued structures studied paper pale assertion language powerset -valued structures forms abstract domain means -valued structures program analysis setting set equations finding fixed point sagiv contrast pale program analysis invariant supplied loop structure-description formalisms literature include adds hendren shape types fradet metayer supervaluational semantics first-order logic discussed section related number supervaluational semantics partial logics -valued logics discussed literature van fraassen blamey bruns godefroid compared previous work innovation fig hatwide translate -valued structure formula fact fig general reductionist strategy providing supervaluational evaluation procedure abstract domains existing logics theorem-provers decision-procedures recent work kuncak rinard abbreviated version extensive presentation results reported kuncak rinard alternative characterization -valued structures logical formulas equivalent characterization presented present paper present paper extends elaborates results yorsh unlike kuncak rinard reports experience algorithmic issues logical characterization structures shape acm transactions computational logic vol july yorsh analysis material important shape analysis primary motivation intended application paper kuncak rinard section present paper simple semantic argument property closure negation shown kuncak rinard formalism technical similarities differences works note tau gretay final remarks reps discuss perform operations required abstract interpretation most-precise relative abstraction primitive operations carried sufficiently powerful theorem prover hand chief primitive operations hatwide material presented paper shows fulfill requirements reps family abstractions based -valued structures essentially past work sagiv tvla system lev-ami sagiv ongoing work investigating feasibility applying techniques reps perform abstract interpretation abstractions based -valued structures approach precise tvla instance account first-class integrity formula abstraction contrast tvla operations temporarily ignore integrity formula rely clean-up steps rectify matters step direction eliminate -valued structures directly carry fixed-point computations logical formulas investigating feasibility results paper develop precise modular version tvla assume-guarantee reasoning yorsh idea arbitrary first-order formulas transitive closure express preand post-conditions analyze code procedure separately electronic appendix electronic appendix article accessed acm digital library visiting url http acm pubs citations journals tocl -v-n -urlend acknowledgments neil immerman viktor kuncak tal lev-ami alexander rabinovich contributions paper andersen binding-time analysis taming pointers proc acm symposium partial evaluation semantics-based program manipulation pepm schmidt acm press york benedikt reps sagiv decidable logic describing linked data structures proceedings european symposium programming blamey partial logic handbook phil logic vol gabbay guenthner eds kluwer academic publishers bruns godefroid generalized model checking reasoning partial state spaces proc concur springer-verlag acm transactions computational logic vol july logical characterizations heap abstractions chase wegman zadeck analysis pointers structures sigplan conf prog lang design impl acm press york clarke grumberg jha veith counterexample-guided abstraction refinement proc computer-aided verif clarke grumberg long model checking abstraction trans prog lang syst courcelle expression graph properties fragments monadic second-order logic descriptive complexity finite models proceedings diamcs workshop immerman kolaitis eds american mathematical society chapter cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points symp princ prog lang acm press york dams abstract interpretation partial refinement model checking thesis technical univ eindhoven eindhoven netherlands das unification-based pointer analysis directional assignments conf prog lang design impl erez generating concrete counter examples arbitrary abstract domains thesis tel-aviv tel-aviv israel preparation erez sagiv yahav generating concrete counter examples arbitrary abstract domains unpublished manuscript fagin monadic generalized spectra math logik ahndrich foster aiken partial online cycle elimination inclusion constraint graphs sigplan conf prog lang design impl acm press york fradet metayer shape types symp princ prog lang acm press york godefroid jagadeesan expressiveness -valued models vmcai heintze tardieu ultra-fast aliasing analysis cla million lines code sigplan conf prog lang design impl acm press york hell nesetril graphs homomorphisms oxford press hendren parallelizing programs recursive data structures thesis cornell univ ithaca hendren hummel nicolau abstractions recursive pointer data structures improving analysis transformation imperative programs sigplan conf prog lang design impl acm press york hendren nicolau parallelizing programs recursive data structures ieee trans par dist syst january henriksen jensen rgensen klarlund paige rauhe sandholm mona monadic second-order logic practice proc tacas huth jagadeesan schmidt modal transition systems foundation threevalued program analysis esop immerman descriptive complexity springer-verlag immerman rabinovich reps sagiv yorsh boundary decidability undecidability transitive-closure logics csl immerman rabinovich reps sagiv yorsh verification structure simulation cav jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications muchnick jones eds prentice-hall englewood cliffs chapter jones muchnick flexible approach interprocedural data flow analysis programs recursive data structures symp princ prog lang acm press york klarlund schwartzbach graph types symp princ prog lang acm press york kuncak lam rinard role analysis popl acm transactions computational logic vol july yorsh kuncak rinard boolean algebra shape analysis constraints vmcai kuncak rinard boolean algebra shape analysis constraints tech rep mit csail http mit vkuncak papers index html lam kuncak rinard hob tool verifying data structure consistency conf compiler construction tool demo lev-ami tvla framework kleene based static analysis thesis tel-aviv tel-aviv israel lev-ami immerman reps sagiv srivastava yorsh simulating reachability first-order logic applications verifciation linked data structures submitted lev-ami reps sagiv wilhelm putting static analysis work verification case study proc int symp software testing analysis lev-ami sagiv tvla system implementing static analyses static analysis symp mccune mace manual guide http wwwunix mcs anl gov mace mcmillan verification infinite state systems compositional model checking charme meyer weak monadic second-order theory successor elementary recursive logic colloquium proc symposium logic boston ller schwartzbach pointer assertion logic engine sigplan conf prog lang design impl mortimer languages variables zeitschr math logik grundlagen math nielson nielson hankin principles program analysis springer-verlag 
nielson nielson sagiv kleene analysis mobile ambients proc esop smolka lncs vol springer rabin decidability second-order theories automata infinite trees trans amer math soc ramalingam varshavsky field goyal sagiv deriving specialized program analyses certifying component-client conformance pldi reps sagiv yorsh symbolic implementation transformer vmcai sagiv reps wilhelm solving shape-analysis problems languages destructive updating trans prog lang syst jan sagiv reps wilhelm parametric shape analysis -valued logic symp princ prog lang acm press york sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst shaham yahav kolodner sagiv establishing local temporal heap safety properties applications compile-time memory management proc static analysis symposium sas lncs vol springer shapiro horwitz fast accurate flow-insensitive points-to analysis symp princ prog lang steensgaard points-to analysis almost-linear time symp princ prog lang ahndrich aiken projection merging reducing redundancies inclusion constraint graphs symp princ prog lang reps acm press york van fraassen singular terms truth-value gaps free logic phil weidenbach spass automated theorem prover first-order logic equality http spass mpi-sb mpg index html yahav verifying safety properties concurrent java programs -valued logic symp princ prog lang acm transactions computational logic vol july logical characterizations heap abstractions yahav ramalingam verifying safety properties separation heterogeneous abstractions proceedings acm sigplan conference programming language design implementation acm press yahav sagiv automatically verifying concurrent queue algorithms electronic notes theoretical computer science cook stoller visser eds vol elsevier yorsh logical characterizations heap abstractions thesis tel-aviv tel-aviv israel http math tau gretay yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tacas received april revised march accepted april acm transactions computational logic vol july logical characterizations heap abstractions app document online-only appendix logical characterizations heap abstractions greta yorsh school comp sci tel-aviv thomas reps comp sci dept wisconsin mooly sagiv school comp sci tel-aviv reinhard wilhelm informatik univ des saarlandes acm transactions computational logic vol july pages characterizing canonical abstraction first-order formulas section defines alternative abstract domain shape analysis logic-based analyses domain explicit information section enjoys nice closure properties section domain class embedding functions defined simple operation called canonical abstraction maps -valued structures limited subset bounded structures canonical abstraction canonical abstraction defined sagiv abstraction properties uniform obtain -valued structures priori bounded size important automatically derive properties programs loops employing iterative fixed-point algorithms canonical abstraction maps concrete nodes abstract nodes definite values unary predicates information loss minimized multiple nodes mapped node formalized definition definition structure canonical abstraction structure canonical canonical surjective mapping canonical permission make digital hard copy part material fee personal classroom provided copies made distributed profit commercial advantage acm copyright server notice title date notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee acm acm transactions computational logic vol july app yorsh arity unionsqdisplay canonical canonical canonical node subscript canonical involves sets unary predicate symbols true false structure fig canonical names nodes node canonical context canonical abstraction shown fig represents represents lists pointed nodes represent list nodes reason predicates indefinite values list nodes values entries required minimizing information loss defined contrast abstraction relies embedding defined section represents lists elements characterize canonical abstraction define set -valued structures images canonical abstraction ica results applying canonical abstraction -valued structures definition image canonical abstraction ica structure ica exists -valued structure canonical abstraction concretization -valued structures canonical abstraction define potentially infinite set -valued structures represented set -valued structures ica definition concretization ica structures set structuresx -struct ica structures denote set -valued structures represents braceleftbiggs -struct exists xsuch canonical abstraction bracerightbigg singleton set write abstract domain powerset ica structures order relation set inclusion note abstract domain finite finite number ica structures isomorphism denote extension abstraction function canonical sets defines galois connection sets valued structures sets ica structures called tight-embedding condition sagiv acm transactions computational logic vol july logical characterizations heap abstractions app structures define notion nodes canonical abstraction embedding notion fo-identifiable nodes definition definition node -valued structures exists formula nodesu designated free variable valued structure canonical abstraction concrete node canonical mapsto nodesu called nodes prove lemma case canonical abstraction embedding characterizing canonical abstraction ica structure bounded structure nullary unary predicates definite values formalized lemma lemma -valued structure vocabulary ica bounded structure nullary predicate iii element unary predicate lemma shows ica structures lemma -valued structure ica nodesui logicalanddisplay fact define formula accepts set -valued structures represented canonical abstraction formula additional conjuncts ensure information loss minimized predicate entry -valued structure entry entry definition first-order characteristic formula canonical abstraction -valued structure ica predicate arity define closed formula logicalanddisplay parenleftbigg logicalandtextr node logicalandtextrj nodesu parenrightbigg unary predicates defined abstraction predicates result bounded structure restrictive kind mentioned section unary predicates abstraction predicates indefinite values acm transactions computational logic vol july app yorsh formula defined maxrlogicalanddisplay logicalanddisplay characteristic formula canonical abstraction set ica structures -struct defined hatwide logicalordisplay singleton set ica structure writehatwide hatwide characteristic formula canonical abstraction structure shown fig hatwide hatwide nodesu nodesu nodesu nodesu nodesu nodesu nodesu nodesu nodesu nodesu nodesu nodesu hatwide explained represent list nodes -valued structure shown fig satisfy lines satisfied assignment remark formula quantifier alternation transitive closure hatwide existential-universal normal form decidable existential-universal form transitive closure theorem -valued structure ica -valued structure iff hatwide closure properties ica structures section simple semantic proof class formulas characterize ica structures closed negation result shown kuncak rinard formalism distinct ica structures intuitively -valued structure represented ica structure implies complement concretization ica structure represented precisely finite set ica structures denote set -valued structures satisfy integrity formula -struct lemma ica structure exists set ica structures dintegerdivide acm transactions computational logic vol july logical characterizations heap abstractions app reformulated theorem terms characteristic formulas ica structures shows class formulas characterize canonical abstraction closed negation sense lemma formula ica structure exists set ica structures formula equivalent formulahatwide remark note lemma lemma hold bounded structures section reason intuitively -valued structures represented bounded structure -valued structure fig denotes linked-list length concretization -valued structures considered -valued structure represents single -valued structure structure fig purpose assume integrity formula defines requires elements reachable addition integrity formula flist complement integerdivide dintegerdivide set empty linked list linked list length linked lists length representation set bounded structures 
capture linked lists length -valued structure fig includes list length denoted contradiction obtained characterizing general -valued structures formulas section show characterize general -valued structures motivating input structure fo-identifiable theorem ensures result operationhatwide precisely captures concretization input structure purpose show apply hatwide operation defined section structure fo-identifiable fo-identifiable hatwide sufficient test embedding -valued structures -valued structure shown fig describes undirected graphs draw undirected edges two-way directed edges structure set predicates denote forward backward directions edge nodes applied -valued structure shown fig logicalandtext node logicalortext nodesui nodesuk nodesuj nodesuk nodesuj logicalandtext nodesui nodesui logicalandtext nodesui nodesui acm transactions computational logic vol july app yorsh include unary predicates node formula lemma evaluates elements simplified logicalandtext logicalortext logicalandtext logicalandtext simplification formula simplification due fact implication unconditionally holds pairs distinct nodes evaluate pairs requirement imposed absence self-loops formula fulfilled graphs edges -colorable formula restrictive capture -colorable graphs characterizing general -valued structures existential monadic second-order formulas subset fagin second-order formulas fagin named formulas capture computations formula existential monadic second-order logic form set variables first-order formula membership tests show subset second-order logic characteristic formula definition generalized handle arbitrary -valued structures existential quantification set variables set variable abstract node definition characteristic formula -valued structure define formula ensure sets empty snon empty nodesui define formula ensure sets disjoint sdisjoint nodesuk nodesuj characteristic formula defined logicalandtextni snon empty sdisjoint stotal snullary logicalandtextmaxrr logicalandtextp stotal snullary defined definition nodesui formula nodesui abuse notation slightly referring result theoretical principle encoding falls monadic-second order logic decidable restrict concrete structures interest trees investigated direction acm transactions computational logic vol july logical characterizations heap abstractions app nodesui formalized passing extra parameters nodesui characteristic formula finite set -struct defined hatwide logicalordisplay finally singleton set writehatwide ofhatwide small amount simplification characteristic formula graph shown fig logicalandtext logicalortext iii logicalandtext logicalandtextj formula represent color classes line line formula color class member color classes pairwise disjoint iii node color class nodes color class connected undirected edge theorem generalizes result theorem arbitrary -valued structure np-formula hatwide accept set -valued structures represented theorem -valued structure -valued structure iff hatwide generating querying loop invariant table table iii show structures characteristic formulas experiment interesting note size bigger size natural definite values impose restrictions imposed proofs lemma -valued structure shown fig -valued structures embedded colored colors proof direction suppose -colorable mapping nodes colors define embedding function node color mapped easy preserves predicate values definite values absence self-loops preserved edges endpoints color proof only-if direction suppose embedded show -colorable node color node absence loops summary nodes guarantees pair adjacent nodes mapped acm transactions computational logic vol july app yorsh structure characteristicformula nodes nodes cei nodes cfi nodes cei nodes cei nodes nodes nodes cei nodes cfi nodes cei nodes cei nodes cei nodes nodes nodes nodes cei nodes cfi nodes cei nodes cei nodes nodes nodes nodes nodes nodes nodes table continued table iii left column shows structures arise beginning loop insert program fig column shows characteristic formula structure note omit redundant sub-formulas part stotal nodesiuj definitions summary node edge endpoints mapped summary nodes colors lemma fo-identifiable structure distinct individuals -valued structure embeds hold mapsto nodesu acm transactions computational logic vol july logical characterizations heap abstractions app structure characteristicformula nodes nodes nodes nodes cei nodes cfi nodes cei nodes cei nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes nodes cei nodes cfi nodes cei nodes cei nodes nodes nodes nodes nodes nodes nodes table iii table continued mapsto nodesu proof embeds exists embedding function sake argument assume claims hold definition function yields contradiction assumption distinct individuals lemma -valued structure assignment iff acm transactions computational logic vol july app yorsh proof direction suppose cases definition definition similarly implies proof only-if direction assume trivially holds apply definition assumption implies similarly assumption implies lemma bounded -valued structure fo-identifiable nodesui logicalanddisplay proof bounded -valued structure show element fo-identifiable formula defined valued structure embeds function concrete element definition show holds mapsto nodesu proof direction suppose mapsto nodesu conjunct nodesu hold predicate mapsto lemma addition embedding condition requires unary predicate holds sake argument assume negationslash recall bounded structure individual unique combination definite values unary predicates consequence unary predicate negationslash definite yields contradiction definite values implies equality hold simultaneously assumption proof only-if direction suppose embedding function guarantees unary predicate means mapsto lemma mapsto assumption holds unary predicates holds conjunction formula nodesu lemma set formulas -valued structure focus algorithm lev-ami sec terminates returns set structures formula evaluates compositional semantics definite structure assignment input structure fo-identifiable structures fo-identifiable proof induction iterations loop focus algorithm sufficient show structures returned procedure focusassignment lev-ami acm transactions computational logic vol july logical characterizations heap abstractions app fig fo-identifiable interesting case input literal focusassignment form resulting set structures copies set fo-identifiable fo-identifiable result splitting node setting copies simplify exposition suppose node split fo-identifiable formulas nodesu nodes nodesu logicalandtextj nodesuj nodes nodesu logicalandtextj nodesuj theorem fo-identifiable -valued structure -valued structure iff hatwide proof lemma show if-direction holds foidentifiable concrete structure satisfying characteristic formula hatwide lemma show only-if part fo-identifiable structure direction true lemma first-order structure set individualsu nodesui inhatwide arbitrary first-order formula free lemma holds hatwide proof concrete structure hatwide construct surjective function assignment logicalandtextni nodesui line existential quantification note distinct lemma define function negationslash arbitrary element mapsto nodesuj show concrete element mapped element case concrete element mapped total holds disjuncts satisfied mapsto satisfy nodesuj definition map well-defined addition element assigned concrete element lemma elements surjective nullary predicate satisfies snullary satisfy conjunct lemma predicate arity show assignment conclude satisfies body conjunct body acm transactions computational logic vol july app yorsh premise logicalandtextrj nodesf definition mapsto satisfies nodesf means premise satisfied conclusion hold result lemma lemma -valued fo-identifiable structure -valued structure proof surjective function arbitrary element define assignment exist surjective fo-identifiable definition conclude nodesui function distinct elements lemma function definition mapsto nodesu assignment satisfies disjunct stotal satisfies stotal nullary predicate lemma conclude satisfies satisfies snullary predicate arity assignment show satisfy body premise implication satisfied formula vacuously holds nodesui definition means holds lemma conclude satisfies lemma -valued structure vocabulary ica bounded structure nullary predicate iii 
element unary predicate proof -valued structure canonical abstraction canonical mapping identifies canonical abstraction show bounded structure abstract element represents concrete elements canonical distinct abstract elements canonical concrete elements represented canonical concrete elements represented loss generality assume canonical names differ unary predicate evaluates concrete elements represented evaluates concrete elements represented join operation shows general pair distinct elements differs definite unary predicate proving bounded structure nullary predicate show means acm transactions computational logic vol july logical characterizations heap abstractions app concrete structure definite iii unary predicate show suppose opposite holds exist concrete elements denoted canonical canonical evaluates concrete elements canonical names mapped canonical abstract element contradicts supposition lemma -valued structure ica nodesui logicalanddisplay proof -valued structure ica show element formula defined -valued structure canonical abstraction induced function canonical definition show holds canonical mapsto nodesu proof direction suppose mapsto nodesu canonical sake argument assume negationslash ica lemma bounded structure definition exists unary predicate evaluates definite values loss generality suppose evaluates implies facts property definition canonical abstraction evaluates concrete values mapped canonical evaluate recall assumption conjunct nodesu hold predicate mapsto evaluates definition mapsto means contradiction obtained proof only-if direction suppose canonical ica lemma iii unary predicates definite values unary predicate definite definite concrete nodes mapped canonical definition mapsto words mapsto holds unary predicates holds conjunction formula nodesu theorem -valued structure ica -valued structure iff hatwide proof lemma show if-direction holds -valued structure canonical abstraction concrete structure satisfying characteristic formula hatwide lemma show direction acm transactions computational logic vol july app yorsh lemma ica set individuals nodesui arbitrary formula free hatwide lemma holds hatwide canonical abstraction proof concrete structure hatwide construct surjective function canonical canonical abstraction definition assignment logicalandtextni nodesui line existential quantification note distinct lemma define function canonical canonical negationslash arbitrary element mapsto nodesuj show concrete element mapped element case concrete element mapped canonical total holds disjuncts satisfied mapsto satisfy nodesui canonical definition map canonical well-defined addition element assigned canonical concrete element lemma elements canonical surjective show canonical satisfies canonical identifies canonical abstraction show holds abstraction imposed canonical predicate precise abstract concrete values represents imposed canonical ica nullary predicates definite values lemma satisfies snullary definition nullary predicates definite values shows holds nullary predicates ica unary predicates definite values lemma iii unary predicate individual show definite concrete elements mapped canonical join values holds recall satisfies formula assignment satisfies conjunct nodesu individual canonical assignment mapped definition canonical assignment satisfies nodesu premise conjunct satisfies conclusion mapsto satisfies definition predicate arity definite tuple requires evaluates definite concrete tuple canonical argument unary predicates join operation returns precise abstract concrete tuples evaluates tuples elements acm transactions computational logic vol july logical characterizations heap abstractions app mapsto mapsto mapsto mapsto evaluates tuple tuple concrete structure precise obtained join operation values show canonical satisfies maps elements canonical names involves showing directions sake contradiction assume distinct elements canonical meaning canonical negationslash canonical bounded structure unary predicate evaluates canonical canonical shown evaluates definite values concrete structure contradiction obtained sake contradiction assume concrete elements denoted canonical names mapped canonical element canonical canonical denoted definition canonical mapsto satisfies nodescanonical words mapsto satisfies nodesu satisfies conjunct node formula mapsto satisfies fact unary predicates definite values ica conclude definition canonical contradiction obtained lemma -valued structure ica -valued structure canonical abstraction proof canonical mapping identifies canonical abstraction canonical surjective function possesses properties show arbitrary element canonical define assignment exist canonical surjective lemma conclude nodesui lemma distinct elements canonical function canonical definition mapsto nodesu assignment satisfies disjunct stotal satisfies stotal ica nullary predicates definite values lemma definition satisfies nullary predicate means satisfies snullary predicate arity assignment show satisfies body conjunct body premise implication conjunct satisfied conjunct vacuously holds nodesui lemma canonical cases acm transactions computational logic vol july app yorsh words satisfies definition holds assignment complete proof show arity holds predicate evaluates tuple ica means join operation yields definition join upper bound information order definition conclude distinct tuples denoted canonical lemma mapsto nodesuj tuple nodesuj evaluates tuple tuple shows lemma denote set -valued structures satisfy integrity formula -struct ica structure exists set ica structures dintegerdivide proof denote set ica structures fixed vocabulary claim defined integerdivide definition integerdivide show integerdivide integerdivide definitions integerdivides dintegerdivide holds complete proof show direction inclusion holds sake argument assume exists -valued structure belongs integerdivide definition exists ica structure canonical canonical negationslash contradicts assumption lemma formula ica structure exists set ica structures formula equivalent formula hatwide proof set -valued structures satisfy integrity formula set ica structures describes complement lemma -valued structure dintegerdivide right-hand side simplifies applying theorem hatwide satisfies satisfy hatwide equivalent theorem -valued structure -valued structure iff hatwide proof lemma show if-direction holds concrete structure satisfying np-characteristic formula hatwide lemma show only-if part lemma logical structure set individualsu hatwide proof concrete structure hatwide construct surjective function assignment body existential quantifiers sets definition acm transactions computational logic vol july logical characterizations heap abstractions app set size pair satisfies sub-formula sdisjoint insures sets disjoint concrete element belongs set simplicity show concrete element mapped element satisfies stotal conclude concrete element satisfies formula nodesui nodesui definition membership test set concrete element member set mapped definition shows well-defined satisfies snon empty element mapped sets disjoint elements surjective nullary predicate satisfies snullary satisfy conjunct lemma predicate arity show extension assignment conclude satisfies body conjunct body premiselogicalandtextrj nodesf definition mapsto satisfies nodesf means premise satisfied conclusion hold result lemma lemma -valued structure -valued structure proof surjective function define assignment surjective function exist concrete element mapped element belongs set logicalandtextni snon empty well-defined function maps concrete element element induces set concrete element belong set sdisjoint function maps concrete element element concrete element belongs set satisfies disjunct stotal stotal nullary predicate lemma conclude satisfies snullary predicate arity extension assignment show satisfy body premise implication satisfied formula vacuously holds nodesui definition belongs set definition implies means lemma conclude satisfies acm transactions computational logic vol july 
next-generation platform analyzing executablesa repsa balakrishnana lima teitelbauma comp sci dept wisconsin reps bgogul junghee wisc grammatech grammatech abstract recent years growing tools analyst understand workings cots components plugins mobile code dlls memory snapshots worms virus-infected code static analysis techniques problems obstacles overcome kinds potentially malicious programs symbol-table debugging information absent present relied understand memory-access operations determine set addresses accessed operation difficult memory operations explicit memory addresses instruction easy indirect addressing address expressions difficult arithmetic addresses pervasive instance local variable loaded slot activation record address arithmetic performed notion type hardware level address values distinguished integer values memory accesses aligned word-sized address values potentially cobbled misaligned reads writes developed static-analysis algorithms recover information contents memory locations manipulated executable combining analyses facilities provided idapro codesurfer toolkits created codesurfer prototype tool browsing inspecting analyzing executables executable codesurfer recovers intermediate representations similar created compiler program written high-level language codesurfer supports scripting language kinds sophisticated pattern-matching capabilities facilities provide platform development additional tools analyzing security properties executables introduction market forces increasingly pushing companies deploy cots software source code typically unavailable outsource development custom software required great deal legacy code design documents out-of-date source code unavailable non-existent continue left deployed important challenge coming decade identify bugs security vulnerabilities systems methods needed determine third-party legacy application programs perform malicious operations induced perform malicious operations make judgments absence source code portions paper appeared recent research programming languages software engineering computer security led kinds tools analyzing code bugs security vulnerabilities tools static analysis determine conservative answer question program reach bad state principle tools great analyst detect malicious code hidden software important detail aforementioned tools focus analyzing source code written high-level language source code number reasons analyses start source code provide level detail checking kinds properties bugs security vulnerabilities malicious behavior invisible tools contrast work addresses problem finding bugs security vulnerabilities programs source code unavailable goal create platform carries static analysis executables information analyst understand workings potentially malicious code cots components plugins mobile code dlls memory snapshots worms virus-infected code goal platform create tools analyst employ determine information program inadvertent security vulnerabilities program deliberate security vulnerabilities back doors time bombs logic bombs goal provide information activation mechanisms payloads latencies developed tool called codesurfer serves prototype next-generation platform analyzing executables codesurfer security analyst powerful flexible platform investigating properties behaviors executable static analysis recover intermediate representations irs similar compiler creates program written high-level language analyst codesurfer gui mechanisms understand program chains data control dependences codesurfer scripting language access intermediate representations codesurfer builds iii grammatech path inspector model-checking tool sophisticated pattern-matching engine answer questions flow execution program codesurfer designed provide platform analyst understand workings potentially malicious code major challenge tool assume executable untrustworthy symbol-table debugging information relied present algorithms codesurfer provide ways meet challenge present version codesurfer targeted executables techniques language-independent applied types executables addition extend codesurfer static analysis obtain information states program reaches execution running program specific inputs static-analysis techniques explore program behavior inputs states program reach make feasible program run aggregate descriptors represent collections memory configurations symbol-table debugging information situations information trusted instance source code program invoke compiler trust compiler supply correct symbol-table debugging information techniques extend naturally source code treat executable code collection irs obtainable source code mapping information back source code similar source-code tools perform preprocessor kind issues arise debugging optimized code complicate matters remainder paper organized illustrates advantages analyzing executables describes codesurfer overview model-checking facilities coupled codesurfer discusses related work advantages analyzing executables section discusses analysis works executables provide accurate information analysis works source code analysis works source code fail detect bugs vulnerabilities due wysinwyx phenomenon execute mismatch programmer intends executed processor source-code fragment login program illustrates issue memset password len free password login program temporarily stores user password clear text dynamically allocated buffer pointed pointer variable password minimize lifetime password sensitive information code fragment shown zeroes-out buffer pointed passwordbefore returning heap compiler performs useless-code elimination reason program values written call memset call memset removed leaving sensitive information exposed heap hypothetical similar vulnerability discovered windows security push vulnerability invisible source code detected examining low-level code emitted optimizing compiler analysis executable typical sourcelevel analyses involves pointer arithmetic indirect call int void int diff char char offset int char diff points indirect call existing source-level analyses ill-prepared handle code conventional assumption arithmetic function pointers leads undefined behavior source-level analyses assume indirect function terms analysis works source code source-level analyses shorthand analyses work irs built source code call call function ignore arithmetic operations assume indirect function call calls assumption code ansi-c compliant contrast analysis balakrishnan reps correctly identifies invoked function analysis detect arithmetic addresses creates address point beginning function address perform function call bug subtle deliberately introduced security vulnerability involves function call passes fewer arguments procedure expects parameters compilers accept unsafe code easy implementing functions variable number parameters compilers effectively means call-site passes parts local variables calling procedure remaining parameters effect passed assignment parameter callee overwrite local caller analysis works executables created capable determining extra parameters source-level analysis make cruder over-approximation unsound under-approximation fig unexpected behavior due compiler optimization box top shows variants code generated optimizing compiler prolog callee analysis reveals variable local necessarily final shown fig code left uninitialized variable triggers compiler warning compiles successfully source-code analyzer assume local main assembly listings show code compiled including variants prolog functioncallee microsoft compiler variant includes strength reduction instruction esp allocates space local replaced push instruction arbitrary register case ecx analysis executable determine optimization results local initialized main summarize advantage analysis works executables executable actual instructions executed information reveals actual behavior arises program execution information includes memory-layout details positions offsets variables runtime stack activation records padding structure fields register usage execution order actual parameters optimizations performed artifacts compiler bugs access information crucial instance security exploits depend platform-specific features structure activation records vulnerabilities escape notice tool information adjacency relationships variables contrast number reasons analyses based source code provide level detail checking kinds properties source-level tools applicable source limits usefulness security applications analyzing code open-source projects analyses based source code typically make unchecked assumptions program ansi-c compliant means analysis account behaviors allowed compiler arithmetic performed 
pointers subsequently indirect function calls pointers move ends arrays subsequently dereferenced programs typically make extensive libraries including dynamically linked libraries dlls source-code form typically sourcelevel analyses performed code stubs model effects library calls created hand errors analysis return incorrect results programs modified subsequent compilation perform optimizations insert instrumentation code modified insert malicious code modifications visible tools analyze source source code written language complicates life designers tools analyze source code multiple languages supported quirks source code primarily written high-level language inlined assembly code selected places source-level analysis tools typically skip inlined assembly code push analysis sites inlined assembly code source code substantial amount information hidden analyses start source code bugs security vulnerabilities malicious behavior invisible tools source-level analysis tool strives greater fidelity program executed duplicate choices made compiler optimizer approach doomed failure analyzing executables absence source code apply techniques encounters challenging program-analysis problem perspective compiler community problem recovery recover intermediate representations executable similar started source code perspective model-checking community problem model extraction extract suitable model executable solve ir-recovery problem obstacles overcome kinds potentially malicious programs symbol-table debugging information absent present relied understand memory-access operations determine set addresses accessed operation difficult memory operations explicit memory addresses instruction easy indirect addressing address expressions difficult arithmetic addresses pervasive instance local variable loaded slot activation record address arithmetic performed notion type hardware level address values distinguished integer values memory accesses aligned word-sized address values potentially cobbled misaligned reads writes past years working create prototype next-generation platform analyzing executables tool set developed extends static vulnerability-analysis techniques work directly executables absence source code tool set builds recent advances static analysis program executables techniques software model checking dataflow analysis main components tool set codesurfer wpds path inspector codesurfer recovers irs executable similar irs source-code-analysis tools create respects irs codesurfer builds precise codesurfer api irs wpds library answering generalized reachability queries weighted pushdown systems wpdss library provide mechanism defining solving model-checking dataflow-analysis problems extend codesurfer analysis capabilities codesurfer api extract wpds model executable run wpds model path inspector software model checker built top codesurfer wpds supports safety queries program control configurations addition writing scripts traverse irs codesurfer recovers tool set extended capabilities decompilation code rewriting fig shows components fit codesurfer makes idapro disassembly toolkit grammatech codesurfer system toolkit originally developed building program-analysis inspection tools analyze source code components glued piece called connector static analyses value-set analysis vsa aggregate-structure identification asi recover information contents memory locations manipulated executable fig organization codesurfer companion tools executable disassembled idapro addition disassembly listing idapro access information statically memory addresses offsets idapro identifies statically memory addresses stack offsets program renames occurrences quantities consistent database define set data objects terms initial run vsa carried objects called a-locs abstract locations vsa analysis instruction determines over-approximation set values a-loc hold information procedure boundaries executables information procedure boundaries idapro identifies boundaries procedures executable calls library functions idapro discovers calls library functions algorithm called fast library identification recognition technology flirt idapro access internal resources api users create plug-ins executed idapro codesurfer plug-in idapro called connector creates data structures represent information obtains idapro fig vsa asi implemented data structures vsa makes results additional static-analysis phase called affine-relation analysis ara program point identifies affine relationships hold values registers idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete information computed vsa augment call graph control-flow graphs on-the-fly account indirect jumps indirect calls created connector idapro connector combination create data structures dlls link data structures represent program infrastructure permits whole-program analysis carried including analysis code library functions called codesurfer makes symbol-table debugging information results vsa asi provide substitute absent untrusted symbol-table debugging information initially set a-locs determined based static memory addresses stack offsets instructions executable run asi refines set a-locs run vsa irs codesurfer recovers extracted directly executable code run machine entire program analyzed including libraries linked program approach higher fidelity platform software model checking irs derived source code software model checkers codesurfer supports scripting language access irs codesurfer builds executable connect codesurfer analysis tools model checkers implement tools top codesurfer decompilers code rewriters analyst mechanism develop additional one-off analyses create memory-access analysis connector analyses codesurfer great deal ambitious sophisticated disassemblers idapro technical level codesurfer addresses problem stripped executable identify procedures data objects types libraries instruction libraries interprocedural calling context machine register a-loc statically compute accurate over-approximation set values executes instructions defined values instructions values defined execution provide effective means access information interactively program control value-set analysis vsa combined numeric pointer-analysis algorithm determines over-approximation set numeric values addresses set a-loc holds program point information computed vsa augment call graph control-flow graphs on-the-fly account indirect jumps indirect function calls vsa related pointer-analysis algorithms developed programs written high-level languages determine over-approximation set variables addresses pointer variable hold vsa determines over-approximation set addresses data object hold program point time vsa similar range analysis numeric static-analysis algorithms over-approximate integer values variable hold vsa determines over-approximation set integer values data object hold program point insights shaped design vsa non-aligned access memory access address aligned -byte word boundary spans parts words forge address parts addresses important vsa discover information alignments strides memory accesses indirect-addressing operations possibly non-aligned accesses prevent loops traverse arrays appearing stacksmashing attacks analysis relational information values a-locs assigned loop related values a-locs loop branch condition desirable vsa track integer-valued address-valued quantities simultaneously crucial analyzing executables integers addresses indistinguishable execution time compilers address arithmetic indirect addressing implement features pointer arithmetic pointer dereferencing array indexing accessing structure fields information integer values lead improved tracking addressvalued quantities information address values lead improved tracking integer-valued quantities vsa produces information precise obtained conventional numeric analyses compilers including constant propagation range analysis integer-congruence analysis time vsa analog pointer analysis suitable executables aggregate-structure identification major stumbling blocks analysis executables difficulty recovering information variables types aggregates structures arrays codesurfer iterative strategy recovering information round refines notion program variables types initially vsa set variables a-locs obtained idapro idapro limited information time applies variable-discovery heuristics statically memory addresses stack offsets limited generally leads coarse-grained approximation program variables run vsa completes value-sets a-locs instruction provide identify over-approximation memory accesses performed instruction information refine current 
set a-locs running variant asi algorithm identifies commonalities accesses parts aggregate data asi originally developed analysis cobol programs context asi ignores type declarations program considers aggregate sequence bytes length aggregate broken smaller parts depending aggregate accessed program context asi analysis executables asi applied results vsa hand asi requires points-to range stride information executable information vsa run asi exploits information made vsa values a-locs hold sizes arrays iteration counts loops generally leads accurate set a-locs initial set a-locs discovered idapro instance simple loop implemented source code int executable idapro determine variables size bytes size bytes provide information substructure -byte variable contrast addition -byte variable asi correctly identify bytes array ten -byte quantities connector refinement loop performs repeated phases vsa asi fig asi results refine previous set a-locs refined set a-locs analyze program round vsa number iterations controlled command-line parameter asi information greatly increases precision vsa analyze contents dynamically allocated objects memory locations allocated malloc recall initial set a-locs identified idapro a-loc abstraction exploits fact accesses program variables high-level language complied static addresses globals fields struct-valued globals static stack-frame offsets locals fields struct-valued locals fields dynamically allocated objects accessed terms offsets relative base address object idapro contrast vsa considers malloc site memory region consisting objects allocated memory region serves representative base addresses objects lets asi handle offset object base address similar handles stack-frame offset net result asi capture information fine-grained structure dynamically allocated objects object fields discovered a-locs round vsa discover over-approximation contents asi complementary vsa asi addresses issue identifying structure aggregates vsa addresses issue over-approximating contents memory locations asi improved method variableidentification facility idapro cruder techniques takes account statically memory addresses stack offsets asi requires information hand idapro sizes arrays iteration counts loops fortunately information vsa carried means asi conjunction vsa obtain improved results round vsa results asi refine a-loc abstraction vsa run generally producing precise results codesurfer value-sets a-locs program point determine point sets killed possibly-killed a-locs emitted format suitable input codesurfer codesurfer tool code understanding code inspection supports graphical user interface gui api scripting language provide access program system dependence graph sdg information stored codesurfer irs sdg consists set program dependence graphs pdgs procedure program vertex pdg corresponds construct program instruction call procedure actual parameter call formal parameter procedure edges correspond data control dependences vertices pdgs connected interprocedural edges represent control dependences procedure calls entries data dependences actual parameters formal parameters data dependences return values receivers return values dependence graphs invaluable applications highlight chains dependent instructions widely scattered program instruction data-dependence predecessors instructions write locations read instruction controldependence predecessors control points affect instruction executed similarly instruction datadependence successors instructions read locations written instruction control-dependence successors instructions execution depends decision made control point codesurfer gui supports browsing surfing sdg variety operations making queries sdg slicing chopping gui user navigate program source code dependences manner analogous navigating world wide web codesurfer api programmatic interface operations lower-level information individual nodes edges program sdg call graph control-flow graph node sets killed possiblykilled a-locs writing programs traverse codesurfer irs implement additional program analyses api extend codesurfer capabilities addition sdg codesurfer irs include abstract-syntax trees control-flow graphs cfgs call graph vsa results sets killed possibly killed a-locs instruction information structure layout global memory activation records dynamically allocated storage backward slice program respect set program points set program points affect computations performed forward slice respect set program points affected computations performed members program chop set source program points set target program points shows affect points chopping key operation information-flow analysis codesurfer unique capabilities answering analyst questions instance worm codesurfer analysis results obtain information worm target-discovery propagation activation mechanisms locating sites system calls finding instructions arguments passed dependences backwards instructions identify values techniques recover rich information memory-access operations answers codesurfer furnishes questions account movement data memory movement data registers prior work goals capabilities assumptions words order goals capabilities assumptions underlying codesurfer constraint symbol-table debugging information off-limits complicated task creating codesurfer results vsa asi provide substitute information allowed create tool symbol-table debugging information absent untrusted executable input goal check executable conforms standard compilation model runtime stack maintained activation records ars pushed stack procedure entry popped stack procedure exit global variable resides fixed offset memory local variable procedure resides fixed offset ars actual parameters pushed stack caller formal parameters reside fixed offsets ars program instructions occupy fixed area memory self-modifying separate program data executable conforms model codesurfer creates conform model violations discovered error reports issued goal codesurfer provide tool security analysis general infrastructure additional analysis executables practical measure system produces error report choice made accommodate error analysis continue error optimistically treated false positive produced analyst determine error report false positive valid analyzer care program compiled high-level language hand-written assembly code fact pieces program output compiler multiple compilers high-level languages hand-written assembly code easiest talk information vsa asi capable recovering terms features high-level programming language vsa asi capable recovering information programs global variables local variables pointers structures arrays heap-allocated storage pointer arithmetic indirect jumps recursive procedures indirect calls function pointers virtual-function calls dlls present run-time code generation self-modifying code compiler optimizations make vsa asi difficult computation critical data resides registers memory register operations easily deciphered memory operations major assumption make idapro disassemble program build adequate collection preliminary irs cfg created idapro incomplete due indirect jumps callgraph created idapro incomplete due indirect calls incomplete irs trigger error reports cfg call-graph fleshed information recovered vsa asi iteration fact relationship vsa asi iteration preliminary irs created idapro similar relationship points-to-analysis algorithm compiler preliminary irs created compiler front end cases preliminary irs fleshed analysis model-checking facilities model checking involves sophisticated pattern-matching techniques answer questions flow execution program model program behavior created checked conformance model expected behavior user query essence model-checking algorithms explore program state-space answer questions bad state reached execution program model checking codesurfer irs build weighted pushdown system wpds models program behaviors wpdss generalize model-checking technology pushdown systems pdss software model checking moped mops systems compared ordinary unweighted pdss wpdss capable representing powerful kinds abstractions runtime states capabilities pdss instance wpdss address kinds security-related queries answered mops wpds library implements symbolic algorithms solving 
wpds reachability problems follow standard approach pds model interprocedural cfg codesurfer irs stack symbols correspond program locations single pds state pds rules encode control flow rule control flow modeled intraprocedural cfg edge call returns return procedure exit node configuration pds symbol top stack corresponds current program location rest stack holds return-site locations pds model behavior program runtime execution stack encoding interprocedural cfg pds sufficient answering queries reachable control states path inspector reachability algorithms wpds determine undesirable pds configuration reachable wpds supports weighted pdss pdss rule weighted element user-defined semiring weights wpds perform interprocedural dataflow analysis semiring extend operator compute weights sequences rule firings semiring combine operator meet weights generated paths weights rules conservative abstract data transformers over-approximation set reachable concrete configurations obtained means counterexamples reported wpds infeasible advantage answering reachability queries wpdss conventional dataflow-analysis methods merge values states program point states calling context wpdss queries posed respect regular language stack configurations conventional merged dataflow information obtained codesurfer conjunction grammatech path inspector tool path inspector user interface automating safety queries concerned control configurations executable reach path inspector checks sequencing properties events program answer questions program bypass authentication routine program trapdoor login program bypass code writes log file program trojan login program path inspector questions posed questions existence problematic event sequences checking query problematic path exists displayed path inspector tool lists program points occur problematic path items linked source code analyst navigate point path source-code element addition path inspector analyst step forward backward path simultaneously stepping source code code-stepping operations similar single-stepping operations traditional debugger path inspector automaton-based approach model checking query finite automaton captures forbidden sequences program locations query automaton combined program model wpds cross-product construction reachability algorithms wpds determine error configuration reachable error configuration reachable witnesses produce program path drives query automaton error state path inspector includes gui instantiating common reachability queries displaying counterexample paths disassembly listing current implementation transitions query automaton triggered program points user specifies manually result sets codesurfer queries future versions path inspector support sophisticated queries transitions triggered matching ast pattern program location query states instantiated based pattern bindings related work previous work analyzing memory accesses executables dealt memory accesses conservatively generally register assigned memory assumed vsa job previous work tracks integer-valued address-valued quantities program data objects hold vsa tracks values data objects hardware registers forced give precision load memory encountered basic goal algorithm proposed debray similar vsa find over-approximation set values register hold program point find over-approximation set values abstract data object hold program point data objects include memory locations addition registers analysis set addresses approximated set congruence values track low-order bits addresses unlike vsa algorithm make effort track values registers lose great deal precision load memory cifuentes fraboulet give algorithm identify intraprocedural slice executable program use-def chains algorithm makes attempt track values registers cuts short slice load memory encountered pieces work closely related vsa algorithm data-dependence analysis assembly code amme algorithm pointer analysis low-level intermediate representation guo algorithm amme performs intraprocedural analysis clear algorithm fully accounts dependences memory locations algorithm guo partially flow-sensitive tracks registers flowsensitive manner treats memory locations flow-insensitive manner algorithm partial transfer functions achieve context-sensitivity transfer functions parameterized unknown initial values uivs clear algorithm accounts possibility called procedures corrupting memory locations uivs represent prefast driver-specific rules october whdc microsoft corp http microsoft whdc devtools tools prefast-drv mspx amme braun zehendner thomasset data dependence analysis assembly code int parallel proc balakrishnan reps analyzing memory accesses executables comp construct pages balakrishnan reps melski teitelbaum wysinwyx execute ifip working conf verified software theories tools experiments ball rajamani slam toolkit computer aided verif volume lec notes comp sci pages bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur volume lec notes comp sci pages springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures princ prog lang pages bush pincus sielaff static analyzer finding dynamic programming errors software practice experience chen dean wagner model checking million lines code network dist syst security chen wagner mops infrastructure examining security properties software conf comp commun sec pages november cifuentes fraboulet intraprocedural static slicing binary executables int conf softw maint pages clarke grumberg peled model checking press codesurfer grammatech http grammatech products codesurfer corbett dwyer hatcliff laubach pasareanu robby zheng bandera extracting finite-state models java source code int conf softw eng pages cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points princ prog lang pages coutant meloy ruscetta doc practical approach source-level debugging globally optimized code prog lang design impl das lerner seigle esp path-sensitive program verification polynomial time prog lang design impl pages york acm press debray muth weippert alias analysis executable code princ prog lang pages dwyer avrunin corbett patterns property specifications finite-state verification int conf softw eng engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions syst design impl pages ferrante ottenstein warren program dependence graph optimization trans prog lang syst finkel willems wolper direct symbolic approach model checking pushdown systems elec notes theor comp sci fast library identification recognition technology datarescue ege belgium http datarescue idabase flirt htm guo bridges triantafyllis ottoni raman august practical accurate low-level pointer analysis int symp code gen opt pages havelund pressburger model checking java programs java pathfinder softw tools tech transfer hennessy symbolic debugging optimized code trans prog lang syst henzinger jhala majumdar sutre lazy abstraction princ prog lang pages horwitz reps binkley interprocedural slicing dependence graphs trans prog lang syst january howard bad news good news october msdn microsoft corp http msdn microsoft library default asp url library enus dncode html secure asp idapro disassembler http datarescue idabase kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds lal reps balakrishnan extended weighted pushdown systems computer aided verif uller-olm seidl analysis modular arithmetic european symp programming ramalingam field tip aggregate structure identification application program analysis princ prog lang pages reps rosay precise interprocedural chopping found softw eng reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis static analysis symp reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog 
schwoon moped system http fmi uni-stuttgart szs tools moped schwoon model-checking pushdown systems phd thesis technical univ munich munich germany july wagner foster brewer aiken step automated detection buffer overrun vulnerabilities network dist syst security february wall systems late code modification giegerich graham editors code generation concepts tools techniques pages springer-verlag wilson lam efficient context-sensitive pointer analysis programs prog lang design impl pages zellweger interactive source-level debugging optimized programs phd thesis univ california berkeley 
computational differentation differentiating version computational differentation computational differentation differentiating version differentiating version computational differentation computational divided differencing standard divided differencingx mathematical functions operators programs program transformations divine discovering variables executables gogul balakrishnan thomas reps comp sci dept wisconsin fbgogul repsg wisc abstract paper addresses problem recovering variable-like entities analyzing executables absence debugging information show variable-like entities recovered iterating value-set analysis vsa combined numeric-analysis pointer-analysis algorithm aggregate structure identi cation algorithm identify structure aggregates initial experiments show technique successful correctly identifying local variables elds heap-allocated objects previous techniques recovered local variables elds heap-allocated objects values computed vsa variables recovered algorithm subsequent analysis job interpreting instructions indirect addressing access arrays heap-allocated data objects indirect operands resolved sites writes sites reads memory-access operations dif cult analyzer obtain results introduction increasing tools programmers security analysts understand executables instance companies military increasingly commercial off-the shelf cots components reduce cost software development interested ensuring cots components perform malicious actions forced perform malicious actions viruses worms ubiquitous tool aids understanding behavior ensure early dissemination signatures control extent damage caused domains questions answered answered perfectly problems undecidable static analysis answer conservatively long-term goal work develop bug-detection securityvulnerability analyses work executables means end goal advance state art recovering executables intermediate representations irs similar started source code envisage irs aid human analyst understand behavior program basis static analysis executables irs hand position leverage substantial body work bug-detection security-vulnerability analysis based irs built source code obstacles recovery program data objects easily identi executable instance data dependence statement statement transmitted write read accesses variable performing source-code analysis programmer-de ned variables provide convenient compartments tracking data manipulations dependence analyzer show nes x-def-free path executables memory accessed directly absolute address indirectly address expression form base index scale offset base index registers scale offset integer constants clear expressions natural compartments analysis executables intrinsic entities analysis analogous source-level variables crucial step analysis executables identify variable-like entities debugging information trusted possibility debugging information analysis techniques account bit-level byte-level wordlevel bulk-memory manipulations performed programmers introduced compiler violate variable boundaries program suspected malicious code debugging information present relied reasons desirable debugging information rely identifying program data objects similarly past work source-code analysis shown valuable ignore information declarations infer replacement information actual usage patterns found code kinds programs including cots products viruses worms debugging information absent situations alternative source information variable-like entities needed reader effective determining information program behavior low-level code surprisingly large number people daily basis engaged inspecting low-level code equipped debugging information include hackers hat shades black grey white employees anti-virus companies members computer incident emergency response teams members intelligence community heretofore state art recovering variable-like entities represented idapro commercial disassembly toolkit idapro algorithm based observation accesses global variables absolute-address accesses local variables esp offset ebp offset executable idapro recovers variables based purely local techniques approach limitations instance account accesses elds structures elements arrays variables accessed pointers accesses fall patterns idapro considers generally recovers coarse information arrays structures approach fails provide information elds heap-allocated objects crucial understanding programs manipulate heap aim work presented paper improve state art abstract interpretation replace local analyses comprehensive view operations performed program present algorithm combines value-set analysis vsa combined numeric-analysis pointer-analysis algorithm works executables aggregate structure identi cation asi algorithm infers substructure aggregates program based program accesses recover variables recovered idapro explained combination vsa idapro incorporate global analyses determining stack height call-sites techniques ad-hoc based heuristics asi recover variables based indirect accesses memory explicit addresses offsets occur program identify structures arrays nestings structures arrays variables recovered algorithm vsa precision vsa improves leads interesting abstraction-re nement scheme improved precision vsa improvement quality variables recovered algorithm turn leads improved precision subsequent round vsa speci technical contributions paper present algorithm recovering variable-like entities executable show information provided vsa combination asi purpose evaluate usefulness variables recovered algorithm human analyst compare variables recovered algorithm debugging information generated compile time initial experiments show technique successful correctly identifying local variables elds heap-allocated objects previous techniques based local analysis recovered local variables elds heap-allocated objects evaluate usefulness variables values recovered algorithm platform additional analyses initial experiments show values computed vsa variables recovered algorithm subsequent analysis job interpreting instructions indirect addressing access arrays heap-allocated data objects indirect memory operands resolved sites writes sites reads current implementation variable-recovery algorithm incorporated tool called codesurfer works executables algorithms architecture-independent remainder paper organized abstract memory model analyzing executables overview approach recover variable-like entities analyzing executables background vsa asi describes abstraction-re nement algorithm recover variable-like entities reports experimental results discusses related work abstract memory model section present abstract memory model analyzing executables simple model memory array bytes writes reads trivial memory model treated writes reads element array disadvantages simple model determine speci address values memory blocks allocated heap malloc analysis sound writes reads blocks memory treated writes reads part heap runtime stack reused execution run general area runtime stack procedures times execution instruction speci numeric address ambiguous address belong activation records times execution denote variable procedure variable procedure variable procedure address correspond variables activations instruction updates variable proceduref treated possibly updating variables procedures heap global data concrete address space heapalloc global data heapalloc abstract memory model fig memory-regions overcome problems work abstract memory model concrete semantics activation records ars procedures heap memory global data part address space purposes analysis separate address space set disjoint areas referred memory-regions fig memory-region represents group locations similar runtime properties runtime locations belong ars procedure belong memory-region program kinds regions global-regions memory locations hold global data ar-regions locations ars procedure malloc-regions locations allocated malloc site overview approach goal subdivide memory-regions executable variable-like entities call a-locs abstract locations variables tools analyze executables memory-regions subdivided information program accesses data intuition approach dataaccess patterns program provide clues data laid memory instance fact instruction executable accesses sequence bytes memory-regionm indication programmer compiler intended four-byte-long variable eld offset section present problems developing approach insights solution addresses problems details provided problem indirect memory accesses past work analyzing executables addresses stack-frame offsets occur explicitly program recover variable-like entities call semi-nacurrency algorithm based observation access global variables absolute-address access local variables esp offset ebp offset executable absolute addresses offsets occur explicitly executable generally starting addresses program variables based observation semi-nacurrency algorithm identi set locations neighboring absolute addresses offsets single variable approach produces poor results presence indirect 
memory operands program initializes elds local struct pointer returns located offset struct located offset activation record main address expression ebprefers address address expression ebprefers address typedef struct int point int main point ppx ppy return proc main mov ebp esp esp lea eax ebpmov ebpeax mov eax mov eax mov eax add esp retn instruction initializes instruction lea eax ebpis equivalent assignment eax ebpinstructions update elds observe executable elds updated eax pointer resides address ebpin offsets relative frame pointer ebp occur explicitly program semi-nacurrency algorithm offsets main constitute variable var offsets throughof main constitute var semi-nacurrency algorithm correctly identi position size groups elds single variable consideration indirect memory operand eax instruction typically indirect operands access arrays elds structures elds heap-allocated data recover collection variables executables explicitly occurring addresses stack-frame offsets unlike operands considered semi-nacurrency algorithm local methods provide information indirect memory operand accesses instance operand ebp offset accesses local variable eax access local variable global variable eld heap-allocated datastructure depending eax obtaining information indirect memory operand accesses straightforward eax initialized register general register indirect memory operand initialized read memory cases determine register contents memory location fortunately value-set analysis vsa summarized provide information follow convention esp stack pointer beginning procedure marks origin procedure ar-region problem granularity expressiveness granularity expressiveness recovered variables affect precision analysis clients recovered variables executable data objects program shown initializes elements array members element initialized y-members initialized disassembly shown instruction updates x-members array elements instruction updates y-members typedef struct int point int main int point return proc main mov ebp esp esp mov ecx lea eax ebpl mov eax mov eax add eax ecx cmp ecx mov eax ebpadd esp retn fig shows variables laid main note space variablei formainbecause compiler promotedi register ecx ret-addr ret-addr var var fig main program actual layout layout obtained semi-nacurrency approach speci analysis client data-dependence analyzer answers questions write memory instruction affect read memory instruction note write memory instruction affect read memory instruction updates members elements array instruction reads member array element simplify discussion assume data-dependence analyzer works annotate instruction killed possibly-killed variables compare variables instruction killed possibly-killed variables instruction determine data dependences partitions main varset shown fig semi-nacurrency approach main variables var bytes var bytes variables possibly killed fvar var variable var data-dependence analyzer reports write memory affect read sound imprecise varset shown fig variables element array variables possibly killed variable instruction sets disjoint data-dependence analyzer reports memory write instruction nitely affect memory read instruction varset suppose main partitioned summary variables representative members elements array representative members elements array summary variable possibly killed instruction summary variable instruction disjoint data-dependence analyzer reports nite answer write affect read alternatives presented varset desirable features smaller number variables varset set variables data-dependence analyzer results varset variables varset capable representing set non-contiguous memory locations instance represents locations ability represent non-contiguous sequences memory locations crucial representing speci eld array structures main partitioned varset summary variable represents members elements array member element array assigned separate variable varset good variable-recovery algorithm partition memory-region set variables obtained partition desirable features varset debugging information trivial task debugging information data-access patterns program provide information serve substitute debugging information instance instruction accesses four-byte sequences start offsets main common difference successive offsets evidence offsets represent elements array instruction accesses bytes starting offsets elements array judged structures elds bytes long background section describe value-set analysis vsa aggregate structure identi cation asi material related core paper vsa mechanism understand indirect memory accesses obtain data-access patterns executable show information gathered vsa harness asi problem identifying variable-like entities executables value-set analysis vsa vsa combined numeric-analysis pointer-analysis algorithm determines over-approximation set numeric values addresses register memory location holds program point program point vsa information contents registers indirect memory operand key feature vsa tracks integer-valued address-valued quantities simultaneously crucial analyzing executables numeric values addresses indistinguishable runtime unlike earlier algorithms analyze executables vsa takes account data manipulations involving memory locations track contents memory locations initial run vsa variables recovered semi-nacurrency approach program initial run vsa computes over-approximation contents registers eax ebx memorylocations correspond var bytes var bytes similarly program initial run vsa computes over-approximation contents registers memory-locations correspond var bytes var bytes examples initial a-locs ned abstraction-re nement algorithm remainder paper overload term a-loc entities recovered semi-nacurrency algorithm previous work entities identi abstraction-re nement algorithm confusion clear context kind a-loc intended vsa ow-sensitive context-sensitive interprocedural abstract-interpretation algorithm parameterized call-string length based independentattribute domain call-strings call-graph program labeled graph node represents procedure edge represents call label edge represents call-site call represented edge call-string sequence call-sites call-site belongs entry procedure exists path call-graph consisting edges labels callstring set call-strings program call-string suf length call-sites represents string call-sites referred saturated call-string represents set fcsjcs callstring callstringk set saturated callstrings length non-saturated call-strings length value-sets vsa set numeric values addresses represented value-set safe approximation actual set suppose number memory-regions executable value-set n-tuple strided intervals form component tuple representing set addresses region -bit machine strided-interval represents set integers mod called stride called interval represents singleton set flg value-sets -tuples follow convention rst component refers set addresses numbers global region denotes empty set instance tuple represents set numbersf tuple represents set offsets ar-region formain refer tracking integer-valued address-valued quantities simultaneously analysis makes distinction values global region treated appropriately instruction performed vsa domain proc denote set memory-regions procedures program allocmemrgn denote set memory-regions heapallocation sites global denote memory-region global data area a-loc denote a-locs belong memory-region work basic domains memrgn fglobalg proc allocmemrgn valueset memrgn stridedinterval alocenv a-loc valueset absenv maps region alocenv register valueset absenv register valueset fglobalg alocenv global proc alocenv proc allocmemrgn alocenv allocmemrgn vsa associates program point absmemcon absmemcon callstringk absenv nitions denote partial map instance valueset offsets memory-regions similarly absenv procedurep activation record stack alocenv addition determining over-approximation set numeric values addresses a-loc executable vsa nds conservative estimate targets indirect function-calls indirect jumps describing vsa detail highlight features a-loc recovery information indirect memory operands program vsa determines value-set eax instruction means eax holds offset ar-region ofmain information conclude eax refers offset main vsa data-access patterns program vsa determines value-set ofeaxat program pointl means 
thateax holds offsetsf gin ar-region ofmain offsets starting addresses eld elements array implementation augmented abstract domain overcomes imprecision arises due perform weak updates accumulate information join elds summary malloc-regions augmented domain analysis establish nite link heap-allocated object class virtual functions virtual-function table due space considerations aspect present paper results reported inx based augmented domain vsa tracks updates memory important general registers indirect memory operand initialized read memory updates memory tracked information indirect memory operands data-access patterns executable aggregate structure identi cation asi asi uni cation-based ow-insensitive algorithm identify structure aggregates program algorithm ignores type information aggregates considers aggregate sequence bytes length aggregate broken smaller parts depending accessed program smaller parts called atoms data-access patterns program speci asi algorithm data-access constraint language dac syntax dac programs shown fig kinds constructs dac program dataref set bytes means data accessed program unifyconstraint means data program note direction data considered unifyconstraint justi cation data sequence bytes evidence structure asi constraints dac program coarsest nement aggregates pgm unifyconstraint pgm unifyconstraint dataref dataref dataref progvars dataref uint uint datarefnuint fig data-access constraint dac language uint set non-negative integers uint set positive integers progvars set program variables kinds data variable progvar refers bytes variable dataref refers bytes dataref refers bytes variable datarefnn interpreted dataref array elements datarefnn refers bytes element array dataref refers sequences bytes details asi algorithm provide intuition algorithm means source-code program shown data-access constraints program const const return main constraints ect fact size point laid rst constraint encodes initialization members dataref refers bytes correspond members array constraint corresponds return statement represents fact return main assigned bytes correspond struct int int struct int int fig asi dag asi tree struct recovered program result asi dag shows structure aggregate relationships atoms aggregates dag shown fig asi dag properties node represents set bytes sequence bytes accessed array program represented array node array nodes labeled number array node represents number elements array array node child dag rooted child represents structure array element fig bytes array identi array -byte elements array element struct elds bytes sequence bytes accessed struct program represented struct node number struct node represents length struct children struct node represent elds struct fig bytes identi struct elds -byte scalars -byte array nodes shared data program involving sequence bytes directly indirectly fig nodes sequences bytes return main shared returnstatement inmain similarly sequence bytes correspond members array share node assigned constant instruction asi dag converted asi tree duplicating shared nodes atoms aggregate leaves asi tree fig shows asi tree asi identi structure shown fig recovering a-locs iteration atoms obtained asi a-locs reanalyzing executable atoms identi asi close set variablesvarset discussed hope apply asi executable treating memoryregion aggregate determining structure memory-region vsa results requirements applying asi extract data-access constraints program applying asi programs written languages cobol data-access patterns apparent syntax constructs consideration case executables instance memory operand eax represent access single variable elements array fortunately value-sets provide information generate data-access constraints recall value-set over-approximation set offsets memory-region information number bytes accessed argument instruction information needed generate data-access constraints executable atoms asi a-locs vsa results vsa improve program recall length var bytes value-sets capable representing set -byte addresses -byte values vsa recovers information var reports value-set var meaning address applying asi data-access patterns provided vsa results splitting var -byte a-locs var var var var bytes long vsa track set values addresses a-locs speci cally vsa determine var var end main vsa results perform round asi valuesets computed vsa improved previous round round asi improve repeat process long desired process converges illustrated additional rounds asi vsa result improvements suppose program chain pointers link structs types variable points structa eld points structb eld points structc typically rst round vsa recovers lets asi discover a-loc code compiled apbp round vsa recovers apbp lets asi discover a-loc code compiled apbp- summarize algorithm recovering a-locs run vsa a-locs recovered semi-nacurrency approach generate data-access patterns results vsa run asi run vsa repeat steps improvements results vsa important understand vsa generates sound results collection a-locs supplied supplied coarse a-locs a-locs found points ning a-locs precise answers generally obtained reason asi heuristic a-locs vsa generate data-access constraints memory accesses program asi uni cation-based algorithm generating data-access constraints kinds instructions leads undesirable results discusses cases short abstraction-re nement principles vsa results interpret memory-access expressions executable equivalently set a-locs discovered step unchanged set previously discovered step step asi heuristic determine structure memory-region information recovered vsa asi tree ects memory-access patterns memory-region leaves asi trees a-locs round vsa asi replacement vsa asi applied executables information obtained vsa value-sets rest section describe interplay vsa asi show value-sets generate data-access constraints input asi atoms asi trees a-locs round vsa generating data-access constraints section describes algorithm generates asi data-references operands forms operands considered register operands memory operands form register memory operands form base index scale offset prevent unwanted uni cation asi rename registers live-ranges register asi data-reference rlr live-range register instruction size register bytes rest section describe algorithm memory operands indirect operands form gain intuition algorithm operand eax instructionl value-set eax stride interval main provide evidence eax access elements array -byte elements range ofmain array access generated operand recall value-set n-tuple strided intervals strided interval component represents offsets memory-region alg shows pseudocode convert offsets memory-region asi asi takes memory-region strided interval length number bytes accessed arguments length parameter obtained instruction length eax instruction atl four-byte data transfer algorithm returns pair rst component asi component boolean signi cance boolean component section algorithm works singleton asi accesses offsets length aggregate memory-region singleton offsets represented treated array size array element stride length length overlapping set locations accessed indirect memory operand overlapping set locations represented asi algorithm chooses length size array element problem soundness subsequent rounds vsa nement principle boolean component pair denotes algorithm generated exact asi number elements array sizec operands form set asi generated invoking alg non-empty memory-region value-set value-set eax set asi main theglobalregion set offsets region empty algorithm asi algorithm convert strided interval asi input memory-region strided interval number bytes accessed length output pair rst component asi sequence length bytes starting offsets memory-region component 
boolean represents asi exact true approximate false singleton return length truei size max length sizec ref size length return href length end algorithm converting indirect operands form base index scale offset alg typical indirect operands form base index scale offset access two-dimensional arrays note scale offset statically-known constants abstract values strided intervals absorb scale offset base index loss generality discuss memory operands form base index assuming two-dimensional array stored row-major format registers base holds starting addresses rows register index holds indices elements row alg shows algorithm generate asi set offsets memory-region expressed sum strided intervals base index note alg computing abstract sum strided intervals results loss precision strided intervals represent single stride prevent recovering structure two-dimensional arrays circumstances implementation asi recover structure arrays higher dimensions alg works determines strided intervals base apparent representation operand strided interval base stride greater length interval strided interval roles strided intervals established algorithm generates asi base asi index cases algorithm establish strided intervals base cases algorithm computes abstract sum strided intervals invokes asi alg generates richer set asi alg indirect memory operand eax ecx loop traverses two-dimensional array type char suppose value-set ecx offsets dataref negative negative offsets paper clarity negative offsets mapped range non-negative offsets mapped range value-set eax length asi generated accessed array -byte entities -byte entity accessed array ten -byte entities algorithm algorithm convert set offsets represented sum strided intervals asi input memory-region strided intervals number bytes accessed length output asi sequence length bytes starting offsets memory region singleton return asi length end length basesi indexsi length basesi indexsi return asi size end hbaseref exactrefi asi basesi stride basesi exactref false return asi length return concat baseref asi indexsi length end interpreting indirect memory-references section describes lookup algorithm nds set a-locs accessed memory operand algorithm interpret pointer-dereference operations vsa instance instruction mov eax vsa lookup algorithm determine a-locs accessed eax value-sets a-locs updated algorithm determine set a-locs value-set trivial memory-region consists linear list a-locs generated semi-nacurrency approach asi performed structure memory-region asi tree ramalingam present lookup algorithm retrieve set atoms asi expression lookup algorithm vsa algorithm assumes asi expressions arise lookup atomization phase case vsa reasons asi heuristic discussed data-access patterns arise vsa asi executable possibly access elds structures broken atoms initial round asi based a-locs recovered semi-nacurrency approach include accesses elds structures rst round vsa access structure elds tree shown fig describe lookup algorithm node tree unique shown parentheses terms describing lookup algorithm nodefrag descriptor part asi tree node denoted triple hname start lengthi asi tree node start starting offset asi tree node length length fragment nodefraglist ordered list nodefrag descriptors ndn nodefraglist represents contiguous set offsets aggregate represents offsets node offsets offsets lookup algorithm traverses asi tree guided asi memory operand memory operand converted asi algorithm resulting asi parsed list asi operations kinds asi operations getchildren aloc getrange start end getarrayelements list asi operations getchildren getrange getarrayelements getrange operation takes nodefraglist argument returns set nodefraglist values operations performed left argument operation result operation immediately left a-locs accessed a-locs nal set nodefrag descriptors getchildren aloc operation returns nodefraglist nodefrag descriptors children root node tree aggregate aloc getrange start end returns nodefraglist nodefrag descriptors representing nodes offsets range start end getarrayelements treats nodefraglist array elements returns set nodefraglist lists nodefraglist list represents array element nodefraglist array elements array split atomization phase parts array represented nodes examples illustrate traces lookups lookup getchildren getrange getchildren returns nodefraglist applying getrange returns describes offsets nodefraglist a-loc accessed lookup getchildren getrange getarrayelements getrange getarrayelements operations similar getarrayelements applied total length nodefraglist number required array elements size array element intuitively operation unrolls givennodefraglistand creates nodefraglistfor unique byte sequence starting left length array element unrolled nodefraglist set unique -byte nodefraglists ordered lists partial updates a-locs abstract transformers vsa prepared perform partial updates a-locs updates parts a-loc becausenodefragelements nodefraglist refer parts asi tree node lookup operation returns refers rst bytes abstract transformer part affected sets value-set cases lead imprecise results value-set domain bit-wise operations bit-wise bit-wise jvs left shift shift operations adjust value-set a-loc partial update performed vsa assuming underlying architecture little-endian abstract transformer updates value-set valueset valueset xffff jvs hierarchical a-locs iteration asi vsa over-re memory-regions instance suppose -byte a-loc fig round partitioned -byte a-locs round sort over-re nement affect results vsa general properties strided-intervals -byte value-set reconstructed adjacent -byte a-locs precise information retrieved -byte a-loc instance suppose instruction holds round information numbers start hexadecimal format represented -byte strided interval hand set numbers over-approximated -byte strided intervals little-endian machine -byte read round handled reconstituting result precise valueset valueset jvsvalueset fig hierarchical a-locs avoid effects over-re nement keeping track value-sets a-loc a-locs round updated round overlapping locs updated updated rst bytes value-set a-loc updated little-endian machine -byte read value-set returned general a-loc length partitioned sequence a-locs round asi subsequent round vsa ang remember parent-child relationship a-locs ang update updated vsa vice versa asi tree round vsa identical tree fig node replaced tree shown fig sources over-re nement union types program hierarchical a-locs degree precision retained presence unions convergence rst round vsa uncovers memory accesses explicit program asi a-locs round vsa produce precise value-sets based set a-locs similarly subsequent rounds vsa uncover memory accesses asi a-locs nement a-locs inde nitely worst case a-loc partitioned sequence -byte chunks cases nement process converges worst-case partitioning occurs set targets vsa determines indirect function-calls indirect jumps change set a-locs value-sets successive rounds process inde nitely set locs change successive rounds forever iteration process converges set a-locs set targets indirect function calls indirect jumps change successive rounds pragmatics asi takes account accesses data transfers involving memory nds partition memory-regions consistent transfers standpoint accuracy vsa clients bene cial account accesses vsa obtain conservative estimate value-set register instance value-set forrcould meaning registerrcan possibly hold addresses numbers memory operand generate asi refer memory-region array -byte elements compilers initialize local stack frame aid debugging uninitialized variables runtime instance versions microsoft visual studio compiler initialize bytes local stack frame compiler initialization memcpy generating asi mimic memcpy memory-region procedure broken array -byte elements desirable deal cases options provided tune analysis user supply 
integer threshold number memory locations accessed memory operand threshold asi generated user supply set instructions asi generated option suppress memcpy-like instructions user supply explicit asi experiments integer-threshold option set experiments section present results preliminary experiments designed answer questions a-locs identi abstraction nement compare program debugging information insight usefulness a-locs recovered algorithm human analyst static analysis a-locs recovered abstractinterpretation-based technique compared a-locs recovered purely local techniques comparison a-locs program variables measure quality a-locs identi abstraction-re nement algorithm set benchmarks collected characteristics benchmarks shown tab programs tab make heavy inheritance virtual functions challenging set examples algorithm compiled set programs shown tab microsoft compiler debugging information ran a-loc recovery algorithm executables produced compiler results converged round asi program variablev present debugging information comparedv structure identi algorithm debugging information classi categories fig breakdown percentages a-locs matched program variables local variables elds heap-allocated data-structures variable classi matched a-loc-recovery algorithm correctly identied size offsets memory-region variable classi over-re ned a-loc-recovery algorithm partitionedv smaller a-locs instance -byte int partitioned array char elements classi over-re ned variable under-re ned a-loc-recovery algorithm identi part larger a-loc instance algorithm failed partition struct constituent elds elds struct classi under-re ned variable classi incomparable fall categories results classi cation process local variables elds heapallocated data structures shown fig fig leftmost column program shows results a-locs recovered semi-nacurrency approach rightmost bar shows results nal round abstraction-re nement algorithm average technique successful identifying correctly local variables elds heap-allocated objects correct elds heap-allocated objects half examples contrast semi-nacurrency approach recovered local variables elds heap-allocated objects fig fig show programs results improve rounds analysis carried programs round asi required identify elds heap-allocated data structures correctly programs required round elds heapallocated data-structures programs required round asivsa iteration chain pointers link structs types discussed insts procs mallocs primes family vcirc fsm trees deriv chess objects simul greed ocean deriv richards deltablue table examples programs structures declared local procedure reason semi-nacurrency approach identi large fraction local variables correctly programsprimesand fsm structures local procedure shown fig approach identi local variables correctly examples usefulness a-locs static analysis aim experiment evaluate quality variables values discovered platform performing additional static analysis resolution indirect operands fundamental primitive essentially subsequent analysis experiment measured resolve indirect memory operands based global address stack-frame offsets accesses arrays heapallocated data objects ran rounds vsa collection commonly windows executables listed tab set benchmarks tab programs tab ran vsa-asi iteration convergence programs tab limited number vsa-asi rounds round vsa performs analysis a-locs recovered semi-nacurrency approach nal round vsa a-locs recovered abstraction-re nement algorithm rst nal rounds vsa labeled memory operand memory operand untrackable size a-locs accessed memory operand greater bytes value-set address expression memory operand memory operand weakly-trackable size a-loc accessed memory operand equal bytes value-set address expression memory operand memory operand strongly-trackable size a-locs accessed memory operand equal bytes value-set address expression memory operand recall vsa track value-sets a-locs equal bytes reports value-set a-locs greater bytes untrackable memory operands vsa information strongly-trackable memory operands vsa nitely information weakly-trackable memory operand vsa information operand update contents memory information obtained operand read contents memory instance eax mov eax weakly-trackable vsa updated value-set a-locs accessed eax size equal bytes eax mov ebx eax weakly-trackable value-set ebx set a-locs accessed eax situation case eax untrackable refer memory operand read contents memory use-operand memory operand update contents memory kill-operand insts procs mallocs time mplayer smss print doskey attrib routemon cat table windows executables number vsa-asi rounds tab weakly-trackable kills column shows fraction kill-operands weakly-trackable rst nal rounds abstraction nement algorithm strongly-trackable column shows fraction use-operands strongly-trackable rst nal round algorithm table classi memory operands direct indirect direct memory operand memory operand global address stack-frame offset indirect memory operand memory operand global address stack-frame offset memory operand accesses array heap-allocated data object semi-nacurrency approach a-loc-recovery algorithm provide good results direct memory operands results indirect memory operands substantially based method set programs tab results vsa improve indirect kill-operands indirect useoperands similarly windows executables tab results vsa improve routemon mplayer indirect kill-operands attrib print indirect use-operands surprised semi-nacurrency approach provide small amount information indirect memory operands instance trees greed ocean deltablue windows executables non-zero percentage trackable memory operands closer inspection found indirect memory operands access local global variables accessed directly program source-level terms variables accessed directly pointer indirection instance local variable procedure passed procedureq accessed directly indirectly sources imprecision vsa prevent obtaining information indirect memory operands source imprecision widening vsa widening operator abstract interpretation accelerate xpoint computation due widening vsa fail non-trivial bounds registers indices indirect memory operands indirect memory operands labeled untrackable fact vsa domain non-relational ampli problem limited extent overcome lack relational information obtaining relations registers additional analysis called ne-relation analysis details note widening problem orthogonal issue nding correct set variables a-loc recovery algorithm recovers variables correctly imprecision due widening persists recently ideas implemented techniques reduce undesirable effects widening numbers report weakly-trackable strongly-trackable kills indirect direct indirect direct round primes family vcirc fsm trees deriv chess objects simul greed ocean deriv richards deltablue mplayer smss print doskey attrib routemon cat table fraction memory operands trackable vsa number parenthesis shows number rounds vsa-asi iteration executable windows executables maximum number rounds set boldface bold-italics indirect columns maximum minimum improvements results encouraging windows executables number memory operands information round times number memory operands information round results static analysis signi cantly improve a-locs recovered abstractioninterpretation-based algorithm place a-locs recovered purely local techniques initial experiments show techniques feasible terms running time related work min describes combined data-value points-to analysis program point partitions variables program collection cells accessed computes over-approximation values cells min algorithm similar avor vsa-asi iteration scheme min nds variable-like quantities static analysis min partitioning algorithm based set variables program algorithm assumes implementation support analysis programs heap-allocated storage techniques infer loop access patterns asi unstructured cell unsigned char internal array substructures int struct fint int cells correspond variables algorithm assumes variable disjoint aware relative positions variables algorithm issues alarm indirect access end variable abstraction memory terms memory-regions thought cells entire activation records interpret out-of-bound access precisely cases instance suppose integersaandbare laid sequence statements access min implementation issues out-of-bounds access alarm 
identify write variable out-of-bounds accesses occur commonly vsa a-loc-recovery algorithm split single source-level variable a-loc array work analyzing memory accesses executables previous techniques deal memory accesses conservatively generally register assigned memory assumed instance basic goal algorithm proposed debray similar vsa goal over-approximation set values register hold program point over-approximation set values abstract data object hold program point data objects include global stack-allocated heap-allocated memory locations addition registers analysis proposed debray set addresses approximated set congruence values track low-order bits addresses unlike vsa algorithm make effort track values registers loses great deal precision load memory cifuentes fraboulet give algorithm identify intraprocedural slice executable program use-def chains algorithm makes attempt track values registers cuts short slice load memory encountered pieces work closely related vsa algorithm data-dependence analysis assembly code amme algorithm pointer analysis low-level intermediate representation guo algorithm amme performs intraprocedural analysis clear algorithm fully accounts dependences memory locations algorithm guo partially ow-sensitive tracks registers owsensitive manner treats memory locations ow-insensitive manner algorithm partial transfer functions achieve context-sensitivity transfer functions parameterized unknown initial values uivs clear algorithm accounts possibility called procedures corrupting memory locations uivs represent platforms created manipulating executables presence additional information source code symbol-table information debugging information including atom eel bergeron present staticanalysis technique check executable debugging information adheres user-speci security policy rival presents analysis abstract interpretation check assembly code program produced compiler possesses safety properties source code analysis assumes source code debugging information source code assembly code program analyzed debugging information map results assemblycode analysis back source code results program points source assembly code compatible assembly code possesses safety properties source code identi cation structures aggregate structure identi cation devised ramalingam partition aggregates cobol program memory-access patterns similar algorithm devised eidorff incorporated annodomani system original motivation algorithms year problem provided identify date-valued quantities program mycroft gave uni cation-based algorithm performing type reconstruction instance register dereferenced offset perform -byte access algorithm infers register holds pointer object -byte eld offset type system disjunctive constraints multiple type reconstructions single usage pattern mycroft algorithm weaknesses instance mycroft algorithm unable recover information sizes arrays identi paper implementation incorporates analysis phase called ne-relation analysis ara program point identi relations hold values registers essence information induction-variable relationships loops vsa recover information array sizes register sweep array control loopindex register decompilation past work decompiling assembly code high-level language peripherally related work decompilers reported literature limited translating assembly code high-level code instance cifuentes work primarily concentrates recovery expressions instruction sequences control decompilers bene memory-access-analysis method paper performed prior decompilation proper recover information numeric values address values physical types nite links objects virtual-function tables aigner hcurrency olzle eliminating virtual function calls programs european conf object-oriented programming amme braun zehendner thomasset data dependence analysis assembly code int parallel proc backes programmanalyse des xrtl zwischencodes phd thesis universitaet des saarlandes german balakrishnan reps analyzing memory accesses executables comp construct balakrishnan reps recency-abstraction heap-allocated storage sas bergeron debbabi desharnais erhioui lavoie tawbi static detection malicious code executable programs int req eng bourdoncle cient chaotic iteration strategies widenings int conf formal methods prog appl cifuentes fraboulet intraprocedural static slicing binary executables icsm pages cifuentes simon fraboulet assembly high-level language translation icsm cousot cousot abstract interpretation uni lattice model static analysis programs construction approximation xpoints popl debray muth weippert alias analysis executable code popl eidorff henglein mossin niss rensen tofte anno domini type theory year conversion tool popl gopan reps lookahead widening cav guo bridges triantafyllis ottoni raman august practical accurate low-level pointer analysis int symp code gen opt idapro disassembler http datarescue idabase lal reps balakrishnan extended weighted pushdown systems cav larus schnarr eel machine-independent executable editing pldi min field-sensitive analysis embedded programs union types pointer arithmetics lctes mcurrency uller-olm seidl analysis modular arithmetic esop mycroft type-based decompilation esop callahan jackson lackwit program understanding tool based type inference int conf softw eng pande ryder dataow-based virtual function resolution sas ramalingam field tip aggregate structure identi cation application program analysis popl reps balakrishnan lim intermediate representation recovery low-level code pepm reps balakrishnan lim teitelbaum next-generation platform analyzing executables aplas rival abstract interpretation based certi cation assembly code vmcai sharir pnueli approaches interprocedural data analysis program flow analysis theory applications chapter pages prentice-hall siff reps program generalization software reuse found softw eng srivastava eustace atom system building customized program analysis tools pldi van deursen moonen type inference cobol systems wcre wilson lam cient context-sensitive pointer analysis programs pldi 
verifying temporal heap properties evolution logic yahav school computer science tel aviv tel aviv israel yahave post tau reps computer sciences deptartment wisconsin madison usa reps wisc sagiv school computer science tel aviv tel aviv israel msagiv post tau wilhelm informatik universit des saarlandes saarbr ucken germany wilhelm uni-sb abstract paper addresses problem establishing temporal properties programs written languages java make extensive heap allocate deallocate objects threads establishing liveness properties hard challenge crucial obstacles heap locations static names number heap locations unbounded paper presents framework verification java-like programs unlike classical model checking propositional temporal logic first-order temporal logic temporal properties heap evolutions logic domain expressed permits allocation deallocation modelled naturally paper presents abstractinterpretation algorithm automatically verifies temporal properties expressed logic keywords verification first-order logic temporal logic abstract interpretation introduction modern programming languages java make extensive heap contents heap evolve program execution due dynamic allocation deallocation objects java threads first-class objects dynamically allocated statically reasoning temporal properties programs challenging priori bounds number allocated objects restrictions heap evolve proving liveness properties programs thread eventually created response request made web server difficult task contributions paper summarized introduce first-order modal temporal logic specifications temporal properties programs dynamically evolving heaps stated natural manner igpl vol oxford press verifying temporal heap properties evolution logic develop abstract interpretation verifying program satisfies specification implement prototype analysis tvla system apply verify temporal properties including liveness properties java programs evolving heaps framework general heap-evolution properties framework general manner properties heap evolution properties garbage-collection algorithms verifying termination sequential heap-manipulating programs termination shown providing ranking function based set items reachable variable iterating linked data structure verified termination programs verifying temporal properties concurrent heap-manipulating programs framework verify temporal properties concurrent heap-manipulating programs liveness properties absence starvation programs mutual exclusion response properties applied analysis programs unbounded number threads remainder paper organized section overview verification method contrasts previous work section introduces trace semantics based first-order modal logic discusses state trace properties language evolution logic section defines implementation trace semantics first-order logic section shows abstract traces conservatively represent sets concrete traces section summarizes related work overview temporal logic supporting evolution specification language evolution temporal logic vtl first-order linear temporal logic properties program execution dynamically allocated memory heap evolve natural concrete semantics program set execution traces trace infinite sequence worlds first-order logical structures provide natural representation worlds unbounded number objects individual structure domain universe corresponds anonymous unique store location predicates represent properties store locations representation properties heap contents maintained abstracting information actual physical locations store rise traces worlds trace domains traces models first-order modal logic varying-domain semantics equivalently naturally modelled constantdomain semantics framework generalizes specification methods address dynamic allocation deallocation objects threads descriptive power propositional ltl finite-state machines verifying temporal heap properties evolution logic program properties verified showing hold traces technically evaluating first-order modal-logic formulae traces variant lewis counterpart theory cast modal models formula evaluation terms classical predicate logic transitive closure program verification concrete semantics non-computable general represent potentially infinite sets infinite concrete traces abstract trace infinite parts concrete traces folded cycles abstract traces termination abstract interpretation arbitrary program guaranteed bounding size abstract trace abstractions employed representing multiple concrete worlds single abstract world creating cycles abstract world reoccurs trace abstractions fail show correctness programs correct fortunately reduction arguments progress monitors employed program-verification techniques finite-state model checking specification formula affect abstraction making abstract traces fulfill formula distinguished abstraction fold history trace single state idea specification affect precision analysis handle safety properties overview verification procedure property vtl formula translated straightforward manner logical formula translation procedure appendix abstract-interpretation procedure applied explore finite representations set traces kleene -valued logic conservatively interpret formulae abstract-interpretation procedure essentially computes greatest fixed point set traces starting abstract trace represents infinite traces initial state gradually increasing set abstract traces reducing set represented concrete traces finally formula evaluated abstract traces fixed point satisfied original vtl formula satisfied infinite traces program case programs satisfy vtl specification analysis yields running web server thread dynamically allocated handle http request received thread handles single request terminates subject garbage collection assume worker threads compete exclusively shared resource exclusive access data file fig shows fragments java program implements naive web server number properties naive web-server implementation shown table properties ignore formulae column clear vtl syntax introduced section verifying temporal heap properties evolution logic public class worker implements runnable request request resource resource public void run synchronized resource resource processrequest request fig java fragment worker thread web server explicit scheduling due unbounded arrival requests web server fact thread dynamically created request absence starvation hold naive implementation guarantee absence starvation introduce scheduler thread web server web server consists listener thread queue worker threads managed scheduler thread listener thread receives http request creates worker thread places thread scheduling queue scheduler thread picks worker thread queue starts execution naive implementation web server scheduler number additional properties interest exist labeled additional properties interest fig shows fragments web-server program threads explicit fifo scheduler ability framework model explicit scheduling queues mechanism addressing issues fairness presence dynamic allocation threads discussion fairness scope paper trace-based evolution semantics section define trace-based semantic domain programs manipulate unbounded amounts dynamically allocated storage concrete semantics serves basis abstract traces semantics presented section representing program traces temporal properties heap-manipulating programs employ first-order modal logic logics defined general constant-domain semantics domain worlds fixed varying-domain semantics domains worlds vary domains worlds overlap general setting types semantics object exist single world equality relation predefined express global equality individuals model semantics languages java hide implementation details dynamic memory allocation semantics varying domains semantics deliberately restricted intended application program analysis design evolution semantics notion equality verifying temporal heap properties evolution logic public class scheduler implements runnable protected queue schedq protected resource resource public void run true synchronized resource resource isacquired resource wait block queue empty worker schedq dequeue worker start public class listener implements runnable protected queue schedq public void run true req rqstream readobject worker thread worker req schedq enqueue worker public class worker implements runnable request req resource resource public void run synchronized resource resource processrequest req resource notifyall fig java code fragment web server explicit scheduler description formula mutual 
exclusion shared resource thread negationslash absence starvation worker threads thread thread created request received thread circledot thread circledot request circledot request thread creation request circledot thread circledot mutual exclusion listener scheduler scheduling queue thread negationslash created thread eventually inserted scheduling queue thread circledot queue rval head scheduled worker thread removed scheduling queue thread queue rval head worker thread waiting queue eventually leaves queue queue thread rval head rval head table web server vtl specification predicates table verifying temporal heap properties evolution logic presence dynamic allocation deallocation update predefined global-equality relation evolution semantics adapted lewis counterpart semantics evolution counterpoint semantics individual exist single world world domain domains worlds non-intersecting model equality defined single world boundary individuals worlds unequal definition relate individuals worlds evolution mapping defined unlike lewis interested evolution mapping reflexive transitive symmetric models fact computation allocated memory cell change identity deallocated section show track statically presence abstraction equivalence relation induced evolution mapping add skip action exit program terminating traces embedded infinite traces semantics program set infinite traces rest paper work fixed set predicates vocabulary denote set predicates arity definition world world program configuration represented first-order logical structure domain universe structure interpretation function mapping predicates truth values distinct individuals definition trace trace infinite sequence worlds world represents global state program initial state successor world derived applying single program action set individuals deallocated set individuals newly allocated iii pair consecutive worlds related stepwise evolution function bijective renaming function extracting trace properties extract trace properties language relate information worlds trace define language evolution logic vtl first-order linear temporal logic transitive closure definition vtl syntax vtl formula defined circledot circledivide logical variables set free variables formula denoted defined usual verifying temporal heap properties evolution logic predicates intended meaning thread thread lab lab labels thread label lab rval fld fld fields field fld object points object heldby lock held thread blocked thread blocked lock waiting thread waiting lock table predicates record information single world transitive closure formula operators circledot circledivide specification refer exact moments birth death individual transitive closure operator specification naturally express transitive reachability heap-paths shorthand formulae convenience formulae shorthand notations defines negationslash defines defines defines defines defines defines shorthand binary predicate examples predicates record information single world include predicates table additional predicates defined sections set predicates lab lab labels parameterized set program labels similarly set predicates rval fld fld fields parameterized set selector fields shorthand notation rval fld defines prime rval prime rval fld prime transitive closure properties relating unbounded length heap-allocated data structures rval fld prime unary predicates thread represent type information expressed many-sorted logic decided avoid expository purposes convenience define shorthands type defines type type defines type property table specifies absence starvation worker threads fig formula thread states thread eventually enters critical section formula thread expresses fact globally thread eventually enters critical section property circledot circledividev states globally individual allocated program execution eventually deallocated note universal quantifier quantifies individuals world evaluated property instance commonly response structure allocation world deallocation response future world operators extended handle allocation deallocation possibly unbounded set individuals verifying temporal heap properties evolution logic properties thread rval rval thread rval rval establish ranking function linked data structures based transitive reachability properties state loop head set individuals transitively reachable program variable decreases iteration loop typically pointer traverses linked data structure loop note properties relate unbounded number individuals world property thread logicalandtext fld fields rval fld circledividev desired property garbage collector non-reachable items eventually collected evolution semantics definitions head denotes world trace tail denotes suffix world denotes suffix starting i-th world denote world finite trace prefix definition evolution mapping finite prefix length trace individual head evolves individual prime trace steps write squiggleright prime sequence individuals prime successive worlds definition assignment evolution finite prefix length trace formula assignment mapping free variables individuals domain head squiggleright prime evolves prime steps free variable squiggleright prime head prime definition vtl evolution semantics define inductively vtl formula satisfied trace assignment denoted head exists head mapsto exists head mapsto mapsto circledotv head tail circledividev head exists prime tail prime squiggleright prime verifying temporal heap properties evolution logic currworld succ succx currworld succ succx fig interaction first-order quantifiers temporal operators exists prime primeprime prime squiggleright prime primeprime squiggleright primeprime write assignment worth noting first-order quantifiers definition range individuals single world effect achieved evolution mapping ability reason individuals worlds relate essence assignment mapsto binds evolution individual domain world quantifier evaluated semantics combination first-order quantifiers modal operators creates complications occur propositional temporal logics quantification domain quantifier vary domain underlying worlds varies verification vtl properties requires mechanism recording domain related quantifier relating members quantification domains individuals future worlds vtl mechanism provided evolution-mappings relate individuals world individuals successor world transitively composing evolution-mappings captures evolution individuals trace formula states pointer variable remains constant program execution points object existed program initial world hand formula states null allowed point objects times program execution point objects exist initial world examples illustrating situations shown fig points object worlds points objects worlds definition program satisfies vtl formula infinite traces program satisfy evolution semantics world domain conceptually representing varying-domain semantics dynamic allocation deallocation objects threads section give implementation semantics terms evolving first-order logical structures verifying temporal heap properties evolution logic separable specifications interesting subclasses vtl verification problem easier classes spatially separable specifications place requirements relationships individuals world individual considered separately verification problem handled set propositional verification problems temporally separable specifications relate individuals worlds essentially corresponds extraction propositional information world temporal specifications extracted propositions class addressed expressing trace semantics first-order logic section first-order logic express trace semantics encode temporal operators standard first-order quantifiers automatically derive abstract semantics section approach extends kinds temporal logic -calculus initial experience demonstrate temporal properties including liveness properties hold programs dynamically allocated storage representing infinite traces first-order structures encode trace infinite first-order logical structure set designated predicates table successive worlds connected succ predicate world trace arbitrary number individuals predicate exists relates individual world exists individual exists single world evolution predicate relates individual counterpart successor world predicates isnew isfreed hold newly created deallocated individuals model allocation deallocation operators definition concrete trace trace encoded infinite first-order logical 
structure domain trace interpretation function mapping predicates truth logical structure exclude structures represent valid traces impose integrity constraints require world successor predecessor equality reflexive fig shows worlds trace natural world depicted large node nodes worlds trace related successor edges information single world represented first-order logical structure shown directed graph node graph corresponds heap-allocated object hexagon nodes correspond thread objects small round nodes types heap-allocated objects predicates holding object shown inside object node binary predicates shown edges brevity label rval stand rval resource grey edges crossing world boundaries verifying temporal heap properties evolution logic predicate intended meaning world world currworld current world initialworld initial world succ successor exists object world evolution object evolves isnew object isfreed object freed table trace predicates rval rval rval succsucc rval rval rval heldby rval rval rval heldby blocked currworld rval rval rval heldby blocked blocked succ initialworld succ fig concrete trace natural evolution edges relate objects worlds note edges cross world boundaries exact extraction trace properties traces represented first-order logical structures trace properties extracted evaluating formulae first-order logic transitive closure translate vtl formula formula making underlying trace structure explicit translating temporal operators claims worlds trace translation procedure straightforward appendix property thread translated world thread initialworld exists prime prime thread succ prime exists prime prime evolution prime prime evaluates trace prefix fig definition meaning formula concrete trace respect assignment denoted yields truth meaning defined inductively verifying temporal heap properties evolution logic explore init traces enabled traces gfp traces intersectiontext init traces negationslash report error fig greatest fixed-point computation scheme computing set infinite concrete traces evaluating property gfp greatest fixed-point operator max max mapsto max min mapsto mapsto satisfy denoted write correctness translation established theorem theorem closed vtl formula trace rep rep first-order representation first-order structure corresponds world mapped world rep succ predicate holding consecutive worlds semantics actions informally program action consists precondition pre action enabled expressed logical formula set formulae updating values predicates effect action enabled action specifies world trace interpretations predicate arity determined evaluating formula predicates exploring trace space liveness properties violated infinite traces verification procedure reason infinite traces section present non-computable verifying temporal heap properties evolution logic scheme exploring infinite space program traces section show conservatively approximate scheme abstract-interpretation algorithm explores finitely representable over-approximation space fig shows non-computable greatest fixed-point computation scheme exploring infinite space program traces scheme start infinite set infinite traces iteratively refine set eliminating traces agree explored prefixes program traces step iteratively apply enabled action traces traces set action applied trace extends explored prefix resulting extended prefixes added set traces step scheme fig replaces traces explored prefix set traces longer explored prefixes process stabilizes traces extended process stabilized evaluate violation property trace resulting set traces trace found satisfy violation property report error noted earlier scheme operates infinite set infinite traces non-computable obtain conservative solution verification problem apply conservative approximation section exploring finite abstract traces abstract interpretation section give algorithm conservatively determining validity program respect vtl property key difficulty proving liveness properties fact liveness property violated infinite trace procedure verifying liveness properties greatest fixedpoint computation works initial approximation represents infinite traces section present abstract-interpretation algorithm procedure explore fig approach finite representations infinite traces finite representations obtained abstraction three-valued logical structures logical represents unknown result abstraction abstract semantics conservatively models effect actions abstract representations noted abstract-interpretation algorithm guaranteed terminate produce sound results misses error algorithm over-approximates set program traces report errors occur execution program false alarms finite representation infinite traces step making algorithm fig feasible define finite representation sets infinite traces technically -valued logical structures finitely represent sets infinite traces definition abstract trace -valued first-order logical structure domain abstract trace interpretation mapping predicates verifying temporal heap properties evolution logic truth values refer values definite values definite individual called summary individual summary individual represent concrete individual meaning formula -valued abstract trace respect assignment denoted defined interpreted trace assignment potentially satisfies formula denote define concrete traces represented abstract traces idea individual concrete trace mapped abstraction individual abstract trace definitions permit abstract concrete trace related less-precise abstract trace abstraction special case trace concrete trace definition imposes order truth values -valued logic definition information order define information order truth values subsetsqequal embedding ordering abstract traces defined definition trace embedding prime prime prime abstract traces encoded first-order structures function prime surjective embed prime predicate subsetsqequal prime prime represents exists embedding creating embedding function canonical abstraction canonical abstraction maps individuals abstract individual based values individuals unary predicates individuals values unary predicate symbols mapped abstract individual denote canonical abstraction trace embed canonical abstraction guarantees abstract trace larger fixed size priori fig shows abstract trace abstract worlds represents concrete trace fig individual double-line boundaries summary individual representing possibly single concrete individual similarly worlds double-line boundaries summary worlds possibly represent single world dashed edges edges represent relations hold successor edge worlds represents succession worlds summary world initial world represents concrete worlds initial current world natural values unary predicates similarly summary node labeled represents thread individuals worlds reside label note verifying temporal heap properties evolution logic rval succ succ rval heldby currworld rval rval heldby blocked rval rval succ initialworld rval succ succ fig abstract trace represents concrete trace natural note abstract trace represents concrete traces natural concrete traces current world threads blocked lock blocked abstract interpretation abstract semantics represents abstract traces -valued structures intuitively applying action abstract trace unravels set successor worlds trace abstract action elaborates abstract trace materializing world summary world tail trace definite successor current world currworld indefinite successor summary world tail trace currworld advanced currworld merged predecessor trace extended evaluate formula precondition update formulae -valued logic figures illustrate application action releases lock fig shows materialization successor world trace fig successor world thread label longer holds lock advanced label currworld predicate advanced currworld merged predecessor resulting abstract trace shown fig abstract-interpretation procedure explore shown fig computes greatest fixed point starting set latticetop latticetop abstract traces represent concrete infinite traces start initial state latticetop latticetop worlds initial world represents initial program configuration connected -valued successor edge summary world represents unknown suffixes summary world latticetop summary individual related summary individual values predicates 
including exists meaning future worlds trace necessarily individuals summary world latticetop summary individual related represents suffixes future worlds empty fig shows initial abstract trace latticetop representing traces verifying temporal heap properties evolution logic rval succ succ rval heldby currworld rval rval heldby blocked rval rval succ initialworld rval succ succ rval rval blocked succ fig intermediate abstract trace represents stage applying action rval succ succ rval heldby currworld rval rval blocked rval rval succ initialworld rval succ succ fig resulting abstract trace applying action advancing currworld explore traces latticetop latticetop occur select remove traces action enabled traces traces uniontext traces negationslash report error fig computing set abstract traces evaluating property rval succ initialworld succ currworld fig initial abstract trace latticetop verifying temporal heap properties evolution logic initialworld succ succ succ succ succ fig holds concrete traces abstract trace represents evaluates starting arbitrary number worker threads label sharing single lock procedure explore accumulates abstract traces set traces fixed point reached process set concrete traces represented abstract traces traces decreasing sense explore computing greatest fixed point fixed point reached property interest evaluated abstract traces fixed point formula evaluation abstract trace exploits values instrumentation predicates explained section recorded definite values re-evaluation yielded show soundness approach extend mappings individuals operate assignments prime function assignment denotes assignment prime nice features -valued logic soundness analysis established theorem generalizes infinite case theorem embedding theorem prime prime prime traces encoded first-order structures prime function subsetsqequal prime formula complete assignment subsetsqequal prime algorithm fig terminate report error program satisfies original vtl formula approach verifying temporal properties yields due overly conservative approximation section present machinery refining abstraction successful verification interesting cases clarity ease presentation artificial section fig shows abstract trace property holds concrete traces represented abstract trace formula evaluates successor evolution edges property-guided instrumentation refine abstraction maintain precise information correctness temporal formulae traces constructed principle referred verifying temporal heap properties evolution logic predicate intended meaning formula twe object equal object possibly worlds evolution evolution current object member current world world currworld table trace instrumentation predicates rval succ succ rval heldby currworld rval rval heldby blocked rval rval succ initialworld rval twe twe twe twe twe twe twe twe twe twe succ succ twe fig abstract trace transworld equality instrumentation -valued transworld equality edges shown instrumentation principle work mentioned showing obtain instrumentation predicates temporal specification trace instrumentation predicates table required preserving properties interest abstraction instrumentation predicate current denotes member current world distinguished individuals predecessor worlds predicate required due limitations canonical embedding predicate twe records equality worlds required due loss information concrete locations caused abstraction transworld equality evolution semantics individuals considered incarnations individual transitively evolve refer notion equality transworld equality introduce instrumentation predicate twe capture notion abstraction operates traces single worlds individuals worlds abstracted transworld equality crucial distinguishing summary node represents incarnations individual worlds summary node represent number individuals transworld equality illustrated fig -valued twe self-loop summary thread-node label records fact summary node represents multiple incarnations single thread number threads verifying temporal heap properties evolution logic initialworld succ succ succ twetwe twe twe twe succ succ fig abstract trace evaluates temporal instrumentation vtl specification formula construct set instrumentation predicates refining abstraction trace property interest set instrumentation predicates corresponds sub-formulae original specification property evaluated satisfied concrete traces represents add temporal instrumentation predicates record values temporal subformulae predicates updated previous worlds note transworld equality instrumentation precisely record transitive evolution objects information summary node world abstraction incarnations single object shown fig related work bandera specification language bsl writing specifications common high-level patterns bsl impossible relate individuals worlds impossible refer exact moments allocation deallocation object special case abstraction named counter abstraction abstract infinite-state parametric system finite-state static abstraction preceding model-extraction phase contrast work abstraction applied dynamically step state-space exploration enables handle dynamic allocation deallocation objects threads observing-propositions defined first-order configuration extract propositional kripke structure first-order extracted structure subject pltl model-checking techniques approach limited individuals worlds specifically related conclusion work foundation verifying properties programs manipulating heap dynamic allocation deallocation objects threads future plan develop scalable approaches verifying temporal heap properties evolution logic abstract-interpretation algorithms tailored vtl acknowledgments patrick cousot nissim francez amir pnueli helpful discussions insightful comments anonymous referees providing comments paper translation vtl vtl sub-formula temporally-bound appears temporal operator translations temporally-bound non-temporally-bound formulae non-temporallybound formulae bound initial world trace definition vtl translation denote bounded translation formula world nonbounded translation world initialworld atomic formula circledotx circledividex circledotx isnew circledividex isfreed exists exists exists prime world prime prime succ prime prime prime prime evolution prime world prime prime succ succ prime prime prime evolution prime prime world prime prime succ prime prime prime prime evolution prime exists prime prime note necessarily distinct simplified translations temporal operators -valued appendix give summary valued material presented fairly standard included completeness presentation syntax formally syntax first-order formulae transitive closure defined definition formula vocabulary defined inductively atomic formulae logical literals atomic formulae free variables predicate symbol arity atomic formula free variables logical connectives formulae sets free variables formulae free variables verifying temporal heap properties evolution logic quantifiers formula free variables formulae free variables transitive closure formula free variables negationslash formula free variables formula closed free variables -valued interpretation section define -valued semantics first-order logic transitive closure standard definition -valued interpretation language formulae -valued logical structure set individuals maps predicate symbol arity truth-valued function assignment function maps free variables individuals assignment functionality assignment defined free variables formula called complete sequel assume assignment arises connection discussion formula complete -valued meaning formula denoted yields truth meaning defined inductively atomic formulae atomic formula consisting logical literal atomic formula form logical connectives formula built subformulae min max quantifiers formula quantifier outermost operator min mapsto max mapsto transitive closure formula form max min mapsto mapsto satisfy denoted write -valued interpretation generalize defn define meaning formula respect -valued structure definition -valued interpretation language formulae -valued logical structure set individuals maps predicate symbol arity truth-valued function verifying temporal heap properties evolution logic assignment -valued meaning formula denoted yields truth meaning defined inductively defn potentially satisfy denoted write proofs proving theorem additional definitions formally define rep introduce intermediate assignment record values intermediate 
assignments evaluation definition trace representation trace define rep rep rep representation first-order logical structure world exists world individual rep rep world individual universe world trace exists non-world individual rep rep world successive worlds world individuals rep rep succ world trace world individual rep rep initialworld world world individual individual individual rep rep exists world negationslash world individual rep exists consecutive worlds individuals individuals rep rep evolution iff world individual individual rep rep isnew iff world individual individual rep rep isfreed iff augment notion assignment assignment assigns individuals universe logical variables assigns world trace designated logical variable definition trace vtl formula assignment world trace suffix starting world assigned satisfies property lemma prefix redundancy trace assignment assigning world proof definition definition definition define additional operation traces triangleright takes trace logical variable assigned world trace operation returns suffix trace starting world initial assignment assigns world trace verifying temporal heap properties evolution logic proof theorem prove closed vtl formula trace rep rep first-order representation show rep triangleright trivially holds rep triangleright definition rep triangleright definition head triangleright definition definition rep triangleright definition rep triangleright rep triangleright inductive assumption definition rep triangleright definition rep triangleright rep triangleright inductive assumption definition rep triangleright definition rep triangleright exists assume free loss generality exists head triangleright rep triangleright mapsto exists head triangleright mapsto definition rep triangleright definition rep triangleright exists exists exists rep triangleright mapsto mapsto exists exists exists head triangleright rep triangleright mapsto mapsto rep triangleright lemma rep triangleright prime prime prime succ prime prime evolution prime prime chop worlds prime lemma tail prime prime definition verifying temporal heap properties evolution logic rep triangleright definition rep triangleright prime world prime prime succ prime prime prime prime evolution prime world prime prime succ succ prime prime prime evolution prime exists prime rep triangleright succ prime exists prime rep triangleright prime prime rep triangleright succ succ prime implies exists rep triangleright lemma exists prime prime exists prime rep triangleright prime prime rep triangleright succ succ prime implies exists rep triangleright exists prime prime exists prime rep triangleright prime prime exists rep triangleright exists prime prime exists prime rep triangleright prime prime prime exists rep triangleright ind exists prime prime exists prime prime prime exists lemma exists prime prime exists prime prime prime exists definition lemma rep triangleright rep triangleright prime prime prime succ prime prime evolution proof rep triangleright rep triangleright prime world prime prime succ prime prime prime prime evolution prime exists prime prime succ prime rep triangleright prime prime prime prime prime prime evolution prime exists prime prime prime evolution rep triangleright prime prime prime lemma trace assignment assigning world individual logical variable prime rep triangleright succ prime exists prime proof trivial definition operator lemma provided emphasize succ prime corresponds existence successor finite future proof theorem theorem generalizes embedding theorem infinite case proof structural induction basis atomic formula verifying temporal heap properties evolution logic mapsto mapsto mapsto definition subsetsqequal prime definition prime definition definition subsetsqequal definition prime definition induction step suppose formula free variables complete assignment prime theorem holds trivially assume prime distinguish cases logical-and proof splits subcases case prime case prime prime loss generality assume prime induction hypothesis conclude definition case prime case prime prime induction hypothesis conclude definition logical-negation proof splits subcases case prime case prime induction hypothesis conclude definition case prime case prime induction hypothesis conclude definition proof splits subcases case prime case prime mapsto induction hypothesis conclude mapsto definition case prime case exists prime prime prime mapsto prime surjective exists prime prime mapsto induction hypothesis conclude mapsto definition transitive closure proof splits subcases case prime definition exist prime prime prime prime prime mapsto prime mapsto prime prime prime surjective exist prime induction hypothesis mapsto mapsto definition case prime show assume contrary prime negationslash verifying temporal heap properties evolution logic negationslash definition exist mapsto mapsto negationslash induction hypothesis exist prime prime prime prime prime prime prime mapsto prime mapsto prime negationslash definition prime negationslash contradiction clarke grumberg peled model checking mit press corbett dwyer hatcliff robby language framework expressing checkable properties dynamic software spin courcelle expression graph properties fragments monadic second-order logic immerman kolaitis editors descriptive complexity finite models proceedings diamcs workshop chapter pages american mathematical society cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points symp princ prog lang pages york acm press cousot cousot temporal abstract interpretation proc popl pages january dor rodeh sagiv checking cleanness linked lists sas static analysis symposium springer http math tau nurr dwyer avrunin corbett patterns property specifications finitestate verification proc int conf software engineering pages fitting mendelsohn first-order modal logic volume synthese library kluwer academic publishers dordrecht hughes creswel introduction modal logic methuen london kesten pnueli vardi verification augmented abstraction automatatheoretic view jcss comp sys sci lev-ami sagiv tvla framework kleene based static analysis sas static analysis symposium springer http math tau tla lewis counterpart theory quantified modal logic journal philosophy lxv manna pnueli temporal verification reactive systems safety springer-verlag york pnueli zuck liveness infinity -counter abstraction proceedings cav sagiv reps wilhelm parametric shape analysis -valued logic acm transactions programming languages systems toplas vardi pierre wolper reasoning infinite computations information computation november yahav http tau yahave yahav verifying safety properties concurrent java programs -valued logic proc popl pages march yahav reps sagiv ltl model checking systems unbounded number dynamically created threads objects technical report trcomputer sciences department wisconsin madison march received september 
weighted pushdown systems trust-management systems somesh jha stefan schwoon hao wang thomas reps computer science department wisconsin madison hbwang jha reps wisc institut formale methoden der informatik universit stuttgart universit atsstr stuttgart germany schwoosn fmi uni-stuttgart abstract authorization problem decide security policy principal allowed access resource trustmanagement system spki sdsi security policy set certificates proofs authorization form certificate chains problem discover proof authorization request algorithms spki sdsi investigated researchers variant certificate-chain discovery problem certificates distributed number servers cooperate identify proof authorization request propose protocols purpose protocols based distributed model-checking algorithms weighted pushdown systems wpdss protocols handle cases certificates labeled weights multiple certificate chains combined form proof authorization implemented protocols prototype report preliminary results evaluation introduction access control shared computing resources authorization problem addresses question security policy principal allowed access specific resource trust-management systems spki sdsi security policy set signed certificates proof authorization consists set certificate chains spki sdsi principals public keys identity principal established checking validity public key spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations problem discover set certificate chains proof authorization request principal access resource efficient algorithm spki sdsi presented clarke improved algorithm presented jha reps algorithm based translating spki sdsi certificates rules pushdown system demonstrated translation enables questions answered security policy expressed set certificates algorithms presented assume proof authorization consists single certificate chain general proof authorization spki sdsi requires set certificate chains proves part required authorization algorithms presented incomplete observation basis observation mitchell -tuple reduction rule incomplete schwoon introduced algorithm certificate-chain discovery translates spki sdsi certificates rules weighted pushdown system wpds algorithm presented schwoon discover proofs authorization consist multiple certificate chains algorithm presented addresses issues trust privacy recency context authorization spki sdsi paper translate spki sdsi certificates rules wpds authorization specifications certificates translated weights rules translation wpds yields complete algorithm section algorithms assume set certificates relevant request single site compute answer authorization problem principal resource practice central authority certificates held number sites subset certificates principal site access resource site certificate chain authorizing involve certificates ands possibly number sites instance computer sciences department wisconsin part college letters sciences department college sites sense grant access resource faculty members issuing authorization certificate actual principals authorized access certificates declare faculty members declare faculty members list faculty members members access chain certificates sites certificates involved paper makes major contributions present distributed model-checking algorithm wpdss algorithm develop distributed algorithm spki sdsi certificates distributed sites background trust-management system spki sdsi section distributed algorithm spki sdsi section implemented prototype algorithm experimental results presented section demonstrate algorithm incurs moderate overhead related work algorithm spki sdsi proposed clarke improved based theory pushdown systems presented jha reps earlier algorithms centralized assume proof authorization consists single certificate chain pca framework appel felten client theorem prover twelf construct proof authorization client presents server assume logical facts theorem prover reside single server presented distributed algorithm trust-management system algorithm certificates distributed proof authorization maintained site spki sdsi subset spki sdsi equivalent role intersection distributed algorithm sites summarize part proof authorization sending sites proof authorization distributed summarizing intermediate results privacy implemented algorithm trust-management server knowledge implement algorithm bauer present algorithm assembling proof request satisfies access-control policy expressed formal logic bauer advocate lazy strategy party enlists prove subgoals precise relationship distributed algorithm bauer algorithm presented paper explored future semantics spki sdsi widely studied context work relevant mitchell pointed -tuple reduction rule incomplete general proof authorization require multiple certificate chains algorithm suffer problem due translation wpds work jim suciu successor qcm related trust-management system based datalog algorithms distributed evaluation authorization queries author claims express roughly policies sdsi claim substantiated true differences set work describes generic evaluation algorithm instantiation corresponds strategy distributing computation propose concrete evaluation strategies argue strategies advantages respect efficiency privacy provide concrete encoding spki sdsi comparison relative merits encoding bound speculative site-safety requirement limit evaluation forward mode algorithms search forward backward explained section unlike framework certificates weights pointed solution situations proofs authorization require multiple certificate chains prove part authorization solves problem semantic incompleteness pointed mitchell pointed weights address issues privacy recency validity trust weighted pushdown systems weighted pushdown systems introduced short pushdown system defines infinite-state transition system states involve stack unbounded length weighted pushdown system rules values domain weights weight domains interest bounded idempotent semirings defined defn definition bounded idempotent semiring quintuple set elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal iff infinite descending chains definition pushdown system triple finite sets called control locations stack alphabet elements conf called configurations finite number rules form arrowhookleft pprime pprime define transition relation configurations arrowhookleft pprime wprime pprime wwprime wprime write cprime express exists rule cprime omit subscript understood reflexive transitive closure denoted set configurations define pre cprime cprime post cprime cprime sets configurations reachable backwards forwards elements single step pre cprime cprime post cprime cprime configuration reachable backwards forwards arbitrarily steps called regular language regular definition weighted pushdown system triple pushdown system bounded idempotent semiring function assigns rule sequence rules associate define configurations cprime path cprime denote set rule sequences transform cprime cprime definition set configurations forwards resp backwards dag edge-labeled directed acyclic graph conf vertex incoming edges incoming edges circleplustextki forwards -dag circleplustextki backwards -dag call forwards backwards -dag witness dag finite vertex outgoing edges notice extender operation calculate path set paths computed combiner operation existence witness dag considered proof exists set paths vice versa combined defn identify finite witness dag set paths exists results briefly review results weighted pushdown systems pushdown system regular subset conf sets pre post regular effectively computable form finite automaton results show result extended generalized pushdown reachability gpr problems weighted pushdown systems definition weighted pushdown system regular set configurations generalized pushdown predecessor gpp problem find pre circleplustext path cprime cprime backwards witness dag generalized pushdown successor gps problem find post circleplustext path cprime cprime forwards witness dag solutions gps gpp computed form annotated finite automata describe gpp case gps case analogous modulo details sake keeping presentation simple concentrate computation values method computing witness dags straightforward transfer 
distributed case input weighted pushdown systemw wherep regular set configurations output pre general infinitely configurations pre finite hope compute solution symbolically annotated finite automata purpose definition p-automaton quintuple finite set states set transitions final states initial states control locations sequence transitions reads configuration arbitrary states sequence accepting iff final state configuration denote acca set accepting transition sequences accepted acca non-empty note set configurations regular accepted p-automaton fixed omit prefix speak simply automata convenient property regular sets configurations closed forwards backwards reachability words automaton accepts set construct automata accept sets configurations forward backwards reachable additional labelings transitions computed solve gpp gps problems assigns weight automaton transition compute compute function mentioned earlier omit labeling sake simplicity loss generality assume henceforth rule arrowhookleft pprime restrictive pushdown system simulated obeys restriction larger constant factor present abstract version procedure designed centralized computation proceed give implementation distributed case abstract algorithm p-automaton accepts set configurations loss generality assume transition leading initial state initially set transition updated action add set update gpp add transitions saturation rule arrowhookleft pprime rule sequence reads ends state update procedure terminates saturation rule longer applied fixed point reached concrete algorithm concrete implementation reproduced figure iteration loop starting line executes applications saturation rule computation finished resulting automaton accepts configurations pre circleplustextt acc aprime time complexity gpp algorithm figure stated lscript lscript length longest descending chain space complexity determined number transitions final automaton algorithm input weighted pushdown system automaton accepts transitions states output automaton aprime accepts pre annotation function procedure update begin newvalue newvalue negationslash workset workset newvalue end workset arrowhookleft pprime update pprime workset negationslash remove transition qprime workset arrowhookleft update qprime arrowhookleft tprime qprime qprimeprime update qprimeprime tprime arrowhookleft pprime tprime pprime update qprime tprime return fig algorithm creating weighted automaton gpp problem distributed algorithm discuss computation distributed rules distributed set sites servers section discuss gpp gps case give concrete implementation gpp gps similar fix weighted pushdown system regular set configurations solution discuss distributes workload servers control locations control location server responsible precisely make assumptions exists mapping sites assigns control locations sites rule arrowhookleft pprime stored site gps problem pprime gpp problem stating assumption differently working collection sites weighted pushdown systems differ rules set satisfies assumption rule arrowhookleft pprime boundary rule pprime assigned sites boundary rule exists call sites responsible pprime neighboring sites definition -dag sites edge vprime called boundary edge boundary rule vprime called boundary node site denote configurations begin control locations site responsible s-region subgraph vprime informally s-region subgraph induced nodes configurations sis responsible fringe subgraph boundary edges originating target nodes abstract algorithm give abstract description gpp gps algorithms site computes set cpre pre pre gpp case cpost post post gps case write cpre cpost depending context intuitively speaking site computes partition pre post set configurations control locations responsible extended configurations reached boundary rules note set configurations generated rules stored idea site involved gpp gps computation discovered negationslash initially site starts set boundary rule site discover configurations belongs sprime site sprime negationslash send configurations sprime sprime continues gpp gps computation configuration concrete algorithm concrete level description site computes automaton accepts labeling functions witness dags basically distributed algorithm straightforward extension non-distributed case site runs gpp gps algorithm similar figure main complication parts automata shared sites precise automaton accepts initially automaton accepts constructed taking states transitions reachable initial states site carries algorithm figure sprime neighboring sites stage computation automaton accept configurations sprime configurations maintained sprime sprime set transitions uniontextc sprime accas transitions form part accepting path configurations detects transition belongs sprime update transition automaton sends sprime site ends automaton accepts configurations site computes information construct function witness dags notice vertices s-region -dag labeled configurations edges region labeled rules stored information needed construct s-region precisely information needed construct s-region generated annotation automaton maintained function computed form annotation labels automaton transitions semiring values sending transition site semiring values configuration obtained evaluating automaton afs shown section figure shows made algorithm implement approach figure shows algorithm point view site algorithm maintains mapping sites sites sprime sites current automaton path leads initial state sprime state means transitions form qprime part accepting paths configurations sprime consequence transition generated updated sprime qprime added sites sprime algorithm consist parts procedure update replaced version additional procedure add recursive couple lines added beginning main procedure lines main procedure initialize sites function update function extended lines lines send updated transition sites required sending transition site sprime represented updatesprime thought remote procedure call function update site sprime adds worklist sprime finally target state added sites sprime procedure add recursive takes care sending additional transitions sprime required algorithm running site input weighted pushdown system automaton accepts transitions states output automaton aprimes accepts cpre annotation function replacement update procedure procedure update begin newvalue newvalue negationslash workset workset newvalue assume sprime sites updatesprime add recursive sprime end procedure add recursive procedure add recursive sprime begin sprime sites return sites sites sprime tprime prime qprime updatesprime tprime tprime add recursive qprime sprime end additions main procedure sites arrowhookleft pprime negationslash sites sites fig modification algorithm distributed gpp complexity state complexity algorithm run site main procedure unchanged runs lscript time lscript longest descending chain additional work required sending receiving transitions neighboring sites suppose neighboring sites sites send transitions send receive action perform constant amount work note bounded transition received lscript times effort received transitions lscript practice expect lower worst case send transitions neighbors lscript times lscript expect number lower practice background spki sdsi spki sdsi principals represented public keys principal public key principal individual process host entity denotes set public keys specific keys denoted kprime identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates spki sdsi types certificates certs certificates certs cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification certificate 
takes form interval cert valid time inclusive authorization certificates auth certs auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert subject term delegation bit turned subject receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert labeled rewrite rule pair component rewrite rule component authorization specification notational convenience write labeled rewrite rule treat certs labeled rewrite rules cert written labeled rewrite rule latticetop latticetop authorization specification authorization specifications latticetop latticetop latticetop write latticetop simply rewrite rule form implicit label latticetop auth cert written square squareif delegation bit turned written square squaresolid authorization labeled rewrite rules paper refer rewrite rules simply rules term appearing rule viewed string alphabet elements beginning uniformity refer strings form square squaresolid terms assume labeled rewrite rule corresponds authorization problems valid certificates validity specification certificate included rule issue intersection union authorization specifications discussed detail cert term case labeled rewrite rule applied term denoted yields term rule viewed function terms terms rewrites left prefix argument bob bob myfriends myfriends rules tprime addition assume prefix exists composition rule tprime rules friends bob myfriends bob tprime composition friends tprime myfriends rules called compatible composition defined authorization problem spki sdsi assume set certs principal access authorization specification authorization question granted access resource certificate chain sequence certificates certificate chain defines transformation label denoted label assume authorization specification unique principal viewed owner resource refers set certificates authorization specification principal algorithm finite set certificate chains prove principal allowed make access formally certificate-chain discovery attempts find finite set chm certificate chains chi square square squaresolid uniontextmi chi clarke presented algorithm certificate-chain discovery spki sdsi time complexity number keys sum lengths right-hand sides rules algorithm solved restricted version certificate-chain discovery general composition operator associative compatible compatible exist exist exists expressions equal defined omit parentheses assume associative solution consist single certificate chain instance certificate set dir read dir write suppose alice makes request dir set read write case chain authorizes alice read directory separate chain authorizes write prove read write privileges certificates removed certificate set prior running certificate-chain discovery algorithm clarke read negationslash set read write write negationslash set read write proof authorization alice request found schwoon presented algorithms full problem based solving reachability problems weighted pushdown systems formalization proof authorization consist set certificate chains paper wpds-based algorithm introduced weighted pushdown systems spki sdsi section show wpdss tool solving problems related certificate-chain discovery spki sdsi definitions largely correspondence spki sdsi pushdown systems presented finite set certificates keys identifiers set authorization specifications drawn latticetop intersection union auth specs discussed forms semiring domaint associate withc weighted pushdown systemwc wherepc square squaresolid keys ofc control locations identifiers form stack alphabet rule set defined set labeled rewrite rules derived auth certs shown section maps rule authorization specification usefulness correspondence stems simple observation configuration reach configuration kprime prime chain certificates kprime prime label certificate chain precisely solving gpp gps problem find set certificate chains prove principal kprime allowed access resource principal solution problem identifies set certificate chains union labels maximal respect semiring ordering subsetsqequal authorization problem set certs principal resource pds context access resource authorization specification iff statement true gpp problem square squaresolid holds square subsetsqequal equivalently gps problem square square squaresolid subsetsqequal distributed certificate-chain discovery algorithms gpr problems proposed work assumption pushdown rules certificates resp stored centrally site carries computation real-world setting certificates issued principals centralized storage site desirable propose versions algorithms solve problems distributed environment finite set certificates wpds section details section assume rules certificates distributed set servers function describes distribution principals sites assume certificate rule stored site responsible issuer subject remainder section distributed solutions distributed problem aforementioned assumptions principal resource principal client public keys set certificate chains access combined problem equivalent problems wpds setting gpp problem square squaresolid square compute backwards witness dag gps problem square square squaresolid compute forwards witness dags sections propose protocols communication client resource servers co-operate solve distributed access problem propose protocols based gpp formulation problem gps formulation protocols assume algorithms solving gpp gps distributed setting provided section relative merits protocols security privacy-related issues discussed section gps protocol distributed certificate-chain discovery distributed setting multiple access requests happen time unique request ids distinguish gps variant protocol consists phases initialization initialization consists steps client sends message resource requesting access message public key client resource responds sending unique request identifier reqid distinguish request requests progress client sends message site called client site denoted message key request reqid iii so-called client certificate request signed client client site checks contents signature client certificate match expectations check successful client site tells client certificate discovery begin client asks resource initiate search resource sends message site called resource site written public key request reqid request initiate certificate discovery search resource site initiates gps query singleton set square reqid distinguish query servers work multiple requests time query resolved servers details search algorithm section crucial points starts local gps computation notices post intersects site boundary certificate asked participate search site computation contact sites site constructs set cpost maintains information construct s-region required witness dags verification earlier communication client client site square squaresolid targets search client site finished search reached complete algorithm result reported resource verification phase direction flow information contrary search phase client site starts constructing sc-region witness dags sends sub-dag starting boundary nodes upstream neighboring sites neighboring sites information complete sub-dags send upstream full witness dags result reported resource communications phase accompanied client certificate mentioned earlier resource verifies result checks integrity dag signatures certificates dags client certificate matches reqid signature matches client depending outcome access allowed denied client verification complete dag place great workload resource alternative sending complete sub-dags sites report sum paths inside dags result resource consists certificates issued resource combined values paths reduces amount network traffic gpp protocol distributed certificate-chain discovery setting search started client site comparison section flow information sites reversed initialization client sends message resource requesting access resource generates reqid sends pair reqid resource site notify incoming search acknowledged receipt message resource sends reqid client client contacts client site 
asks initiate gpp computation request sends reqid client certificate section client site checks correctness client certificate correct begins search search search stage analogous gps protocol started client site set squaresolid square site involved search pre intersects communications sites tagged reqid client certificate verification end search resource site search reqid target square determine reachable generate complete witness dag request sites downstream regions witness dag pass complete dag client certificate resource verify successful grant access client alternative solution report resource certificates issued resource combined values paths case communication sites rules shown square arrowhookleft kuw facultysquaresolid kuw faculty arrowhookleft kls faculty kls faculty arrowhookleft kcs faculty kls faculty arrowhookleft kbio faculty kcs faculty arrowhookleft kbob latticetop assume sites bio sitemap kuw equal kls equal kbio equal bio kcs kbob equal case section suppose bob site access resource site site starts search kbob square kbob squaresolid discovers pre intersects site involved notices site part search automata computed shown figure notice site bio involved end computation site sees square accepted automaton auw weight result reported resource kuw kbob faculty kcs faculty kls faculty fig pre automata square computed sites weights transitions shown parentheses discussion discuss privacy security-related topics compare protocols discuss improvements privacy search parties involved learn resource client client asked access resource resource site request made resource client site client made request sites request made surmise nature request judging identifiers transitions direction query direction confirmation observe communication neighbor sites privacy access request ensured search witness dag constructed construction phase sites learn identity client avoided alternative method values paths dag transmitted sites alternative solution prevents unnecessary spread certificates sites sensitive information security attacks spoofing eavesdropping assume parties involved search communicate securely identification spoofing place trusting sites main part computation carried sites protocols potentially susceptible malicious behavior sites malicious site invent ignore certificates ignoring certificates detriment users site responsible concern inventing certificates problem verification stage constructs full witness dag case certificates signed issuers supplied alternative solution values reported problematic essence reporting paths sub-dag rooted node amounts issuing confirmation principal certificate chain client alternative solution requires trust site certificates truthfully note boundary certificates subjects direct control respective site operator problem client certificate resource verify reported result valid client initiated request verification stage constructs full witness dags straightforward maximal nodes dags refer client alternative solution verification client certificate serves purpose provided resource client site verify correctness comparison protocols gpp-based protocol search starts client site gps-based protocol starts resource site site responsible popular resource gps-based protocol put workload denial-of-service attacks conceivable malicious client large number gps computations identities doomed fail gpp-based protocol happen workload fall client site assumed relationship client site client company isp social safeguard denial-ofservice attacks construction complete witness dags omitted gpp-based solution require separate verification stage reasons gpp-based solution advantages gps-based solution carry precise investigation issue improvements caching results notice methods describe carried time client access resource contact client resource outcome successful resource remember grant access full search time caching sites site client site resource site request result local search independent request identifier sites cache recent results reuse identical request modulo reqid guided search protocols sets pre post intersect domains sites request involve sites relevant search increases length computation amount network traffic protocol improved limiting scope search client idea allowed access resource possibility client client site suggest set sites suitable certificates termination distributed gpp gps computation standard terminationdetection algorithm applied determine search terminated entails additional time communication overhead search terminated relevant certificate chains found client site gps case resource site gpp case discovered paths tentative larger respect ordering goal search establish larger threshold information terminate search early computation limited timeout implementation implemented prototype distributed algorithm figure shows site organized spki sdsi site consists spki sdsi server wpds server spki sdsi server deals spki sdsi certificates interface clients perform requests authorization wpds server implements distributed certificate-chain discovery algorithm solving reachability problems weighted pushdown systems wpds clients interact directly wpds servers typical authorization-request scenario client initiates request contacting spki sdsi server spki sdsi server parses request sends wpds server site point wpds server starts distributed process contacts wpds servers proof authorization found verified client granted access resource request denied examples illustrate system works examples graph illustrate configuration sites graph shaded nodes represents distinct sites distributed spki sdsi system labels fig architecture diagram inside site represent cross-boundary spki sdsi certificates nodes symbol denote resource spki sdsi auth certs issued dashed lines denote certificate chain discovered algorithms bob requests access resource case case demonstrates basic idea distributed certificatechain discovery assume hierarchical structure shown figure site represents level site denotes top level wisconsin denotes colleges college letters sciences bio represent departments sites linked spki sdsi certificate refers sites instance site issued certificates respect site auth cert square kuw faculty squaresolid grants access kuw faculty cert kuw faculty kls faculty states kls faculty kuw faculty assume bob requests access service located process starts continues hierarchy reaches bob granted access rights note individual site sufficient knowledge decide authorization request certificates path show bob required permissions case case demonstrates basic idea distributed certificate-chain discovery case illustrates situation certificates multiple paths combined obtain required authorization specifications access permission instance continuing case add joint department bcs formed bio departments structure shown figure issues authorization certificates distinct authorization specifications bio suppose bob bcs access request granted paths separately wpds approach solves issue combining authorizations paths bcs grant authorization bob case case shown figure builds top demonstrates complex environment case constructed purposes demonstrate scalability wpds algorithm study performance respect certificate-chain length measure computation time length chains section performance analysis section report performance implementation examples discussed response time perspective clients performance metrics resources perform real-world test tests conducted simulated environment site runs separate machine local area network timing results reflect network latency real distributed environment test machines mhz pentium iii processors ram running tao linux version experiment configurations base simple complex comparison purposes collected performance data running certificate-chain discovery centralized mode certificates stored single site complex configuration base configuration base bare minimum number certificates required tests shown figures number certificates ranges certs tests results configuration baseline test cases simple 
configuration real-world scenario site certificates simple configuration adds certificates base configuration site added number additional certificates students staff kuw student kls student kcs faculty kprofa complex configuration measure system scales tested case certificates table shows performance results configurations expect certificates system longer takes perform certificate-chain discovery time takes perform certificate-chain discovery increases lower rate compared increase number certificates data shows insignificant base configuration simple configuration shows small increase average simple complex figure illustrates data case addition table shows performance difference running certificate-chain discovery distributed centralized mode significant instance case distributed certificate-chain discovery ten times long centralized version distributed certificate-chain discovery significant percentage time spent network-related operations sending receiving messages expect reduce network overhead optimizations reduce number messages exchanged certificate-chain discovery bundling messages totwo cases tested showed similar results omitted square faculty squaresolid kuw faculty kls facultyd kls faculty kcs faculty faculty kbio faculty kcs faculty kbob bio fig case grants read permission directory faculty tag dir read bob requests read access directory kuw faculty kls faculty square faculty squaresolid square bio faculty squaresolid kcs faculty kbcs faculty bio kbio faculty kbcs facultyd kbio faculty kalice bcs kbcs faculty kbob fig case authorization multiple paths grants read privilege directory faculty tag dir read write privilege bio faculty tag dir write bob requests read write directory nsf square knsf programs squaresolid knsf kedu square knsf gov programs squaresolid knsf gov kgov kedu programs kmanagera programs kedu schools faculty kedu schools kwisc schools gov kgov programs kgov schools faculty kgov schools kwisc schoolsd kgov programs kmanagerb wisc kwisc schools kuwd kuw faculty kchancellor kuw faculty kls faculty kls faculty kcs faculty kls faculty kbio faculty kcs faculty kbob bio fig case authorizes nsf programs apply funda tag funda apply nsf gov programs apply fundb tag fundb apply bob attempts apply funda gether sending bundle packet part planned future work table performance results time distributed centralized client request base simple complex complex case figure bob dir read case figure bob dir read bob dir write bob dir read write alice dir write case figure managera funda apply managerb fundb apply chancellor funda apply bob funda apply bob fundb apply performance data case illustrates area future work reducing response time long certificate chains define length certificate chain number distinct sites request site resource site manager chain length site hop resource site nsf illustrated ascending line top figure length certificate chain great impact performance longer chain longer takes service request comparison purposes flat line shows response time centralized certificates location time reflects cost running gps algorithm site network overhead investigating techniques improve average performance long certificate chains instance section discussed possibility caching reduce discovery time abadi sdsi linked local spaces journal computer security appel felten proof-carrying authentication conf comp commun sec nov bauer garriss reiter distributed proving access-control systems proceedings ieee symposium security privacy pages blaze feigenbaum ioannidis keromytis role trust management distributed systems security vitek jensen editors secure response time certificates manager funda apply manager fundb apply changellor funda apply alice funda apply alice fundb apply fig response time certificates case response time chain length manager funda apply manager fundb apply changellor funda apply alice funda apply alice fundb apply distributed centralized fig response time chain length case complex configuration internet programming security issues mobile distributed objects pages lncs blaze feigenbaum ioannidis keromytis keynote trustmanagement system version rfc sept bouajjani esparza maler reachability analysis pushdown automata application model-checking proceedings concur volume lecture notes computer science pages springer bouajjani esparza touili generic approach static analysis concurrent programs procedures proceedings popl clarke elien ellison fredette morcos rivest certficate chain discovery spki sdsi journal computer security ellison frantz lampson rivest thomas onen rfc spki certificate theory internet society september esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems emerson sistla editors proceedings cav volume lecture notes computer science pages springer july finkel willems andp wolper pushdown systems elec notes theor comp sci halpern van der meyden logical reconstruction spki proceedings ieee computer security foundations workshop pages ieee computer society press howell kotz formal semantics spki technical report department computer science dartmouth college hanover mar jha reps analysis spki sdsi certificates model checking proceedings ieee computer security foundations workshop csfw pages ieee computer society june jha reps model checking spki sdsi journal computer security jim trust management system certified evaluation proceedings ieee symposium security privacy page ieee computer society jim suciu dynamically distributed query evaluation pods proceedings twentieth acm sigmod-sigact-sigart symposium principles database systems pages acm press lampson abadi burrows wobber authentication distributed systems theory practice acm transactions computer systems november mitchell understanding spki sdsi first-order logic proceedings ieee computer security foundations workshop csfw ieee computer society winsborough mitchell distributed credential chain discovery trust management journal computer security february pfenning sch urmann system description twelf meta-logical framework deductive systems ganzinger editor int conf auto deduc pages springer-verlag lnai july reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis proceedings internation static analysis symposium sas san diego june reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis science computer programming october schwoon jha reps stubblebine generalized authorization problems proceedings ieee computer security foundations workshop csfw pages ieee computer society june weeks understanding trust management systems proceedings ieee symposium research security privacy research security privacy oakland ieee computer society technical committee security privacy ieee computer society press 
static program analysis -valued logica thomas repsa mooly sagiva reinhard wilhelma comp sci dept wisconsin reps wisc school comp sci tel aviv msagiv post tau informatik univ des saarlandes wilhelm uni-sb abstract paper reviews principles paradigm abstract interpretation -valued logic discusses recent work extend approach summarizes ongoing research aimed overcoming remaining limitations ability create programanalysis algorithms fully automatically introduction static analysis concerns techniques obtaining information states program passes execution running program specific inputs static-analysis techniques explore program behavior inputs states program reach make feasible program run aggregate abstract descriptors represent collections states years researchers made important advances applying static analysis kinds program-analysis tools identifying bugs security vulnerabilities tools static analysis properties program behavior verified alternatively ways bugs security vulnerabilities detected static analysis provide safe answer question program reach bad state successes substantial challenges remain pointers dynamically-allocated storage features modern imperative programming languages error-prone dereferencing null-valued pointers accessing previously deallocated storage common programming mistakes pointers dynamically-allocated storage program build complex graph data structures simple data structure intended incorrect assignments pointers indirect assignments pointers bugs symptoms hard diagnose tools finding bugs detecting security vulnerabilities answers questions pointer variables contents structure heap usage pointers programs major obstacle goal addressing software reliability means static analysis effects assignments pointer variables pointer-valued fields make hard determine aliasing relationships pointer expressions program precise pointer information effectiveness static techniques decreases work algorithms flow-insensitive points-to analysis including algorithms exhibit varying degrees context-sensitivity work simple abstraction heap-allocated storage nodes allocated site folded single summary node approach severe consequences precision allocation site supported onr contract israel science foundation von humboldt foundation term heap refers collection nodes allocated free-storage pool loop function called allocate multiple nodes addresses points-to fact points means program variable point nodes represents assignment form selector points-to-analysis algorithms ordinarily forced perform weak update selector edges emanating nodes points accumulated abstract execution assignment field summary node kill effects previous assignment general nodes represents updated concrete execution assignment statement imprecisions snowball additional weak updates performed assignment statements form selector selector flow-insensitive algorithm exacerbates problem literature points-to analysis leads information structure heap study characteristics results obtained flow-insensitive points-to-analysis algorithms reports experiments show points-to graph single node blob large number outgoing flow edges graph blob order magnitude outgoing edges node imprecision turn leads overly pessimistic assessments program behavior representations pointer relationships proposed literature points-to analysis express simple fact points acyclic list representations unable confirm behavioral properties input list-insert program acyclic list output acyclic list input list-reversal program destructiveupdate operations acyclic list output acyclic list points-toanalysis algorithms report possibly cyclic structure arise programs lists points-to-analysis algorithms report end program lists share list elements fact lists remain disjoint failings conventional pointer-analysis algorithms discussed symptomatic general problem general tools finding bugs detecting security vulnerabilities answers questions wide variety behavioral properties questions answered tracking relationships program runtime entities general number entities fixed upper bound nature relationships tracked depends program analyzed queries answered aim work create parametric framework program analysis addresses issues parametric framework instantiated ways create program-analysis algorithms provide answers questions varying degrees efficiency precision key aspect approach makes -valued -valued logic -valued -valued logical structures collections predicates represent concrete abstract stores individuals represent entities memory cells threads locks unary binary predicates encode contents variables pointer-valued structure fields aspects memory states firstorder formulas transitive closure properties sharing cyclicity reachability formulas store affected execution kinds statements programming language analysis framework instantiated ways varying predicate symbols logic varying unary predicates control nodes folded explained detail sect set predicates determines set properties tracked properties stores discovered hold points program instance analysis methodology verifying properties programs advantages valued-logic approach loop invariants required theorem provers involved abstract execution step terminate method based abstract interpretation satisfies conditions guarantee entire process terminates method applies programs manipulate pointers heap-allocated data structures analyses capable performing strong updates abstract execution assignment pointer-valued field method eliminates user write usual proofs required abstract interpretation demonstrate abstract descriptors analyzer manipulates correctly model actual heap-allocated data structures program manipulates prototype implementation implements approach created called tvla three-valued-logic analyzer points counterintuitive work undecidable logic first-order logic transitive closure footnote properties shared verification method based abstract interpretation consequences point points equally surprising experts field static analysis key aspects approach point fundamental effect precision approach capable confirming behavioral properties mentioned earlier input list-insert program acyclic list output acyclic list input list-reversal program destructive-update operations acyclic list output acyclic list addition program multiple lists remain disjoint approach confirm fact point keys making approach accessible users methodology abstract interpretation difficult task obtain abstract semantics abstract-interpretation papers complicated proofs show abstract semantics sound respect concrete semantics approach case abstract semantics falls automatically specification concrete semantics provided case abstract interpretation employed soundness instantiations framework single meta-theorem theorem remainder paper organized sect summarizes framework static analysis sect describes applications extensions sect discusses related work logic program analysis modeling abstracting heap logical structures static-analysis framework defined concrete memory configurations stores modeled logical structures logical structure vocabulary predicate symbols arities eqa finite set predicate symbols denotes set predicate symbols arity logical structure supplies predicate vocabulary predicate symbols typedef struct node int data struct node list predicate intended meaning denote memory cell pointer variable point memory cell n-field point data-field equal table declaration linked-list datatype core predicates representing stores manipulated programs type list write predicate names italics code typewriter font concrete store modeled -valued logical structure fixed vocabulary core predicates core predicates part underlying semantics language analyzed record atomic properties stores tab definition linked-list datatype lists predicates represent stores manipulated programs type list store shown fig null fig store consisting four-node linked list pointed -valued logical structures represent memory configurations individuals set memory cells nullary predicate represents boolean variable program unary predicate represents pointer variable boolean-valued field record binary predicate represents pointer field record -valued structure shown upper-left-hand corner fig encodes store fig individuals represent list cells graphical notation depictinga -valued logical structures individual represented circle inside unary predicate represented solid arrow froma individual absence -arrow individual whicha predicatea individuals shown binary predicate represented solid arrow labeled pair individuals absence -arrow pairs structure pointer variables point individual n-field points individual pointer variables 
point individual restricted class logical structures encode stores exclude 
popseq popseq popseq popseq popseq popseq structures represent admissible stores integrity constraints imposed instance predicate fig captures pointer variable points memory cell attribute unique imposes integrity constraint hold individual structure concrete operational semantics programming language defined structure transformer kind edge control-flow graph formally structure transformer edge defined collection simplify matters examples involve modeling numeric-valued variables numeric-valued fields data introducing predicates binary predicate stands data less-than-or-equal-to listed tab captures relative order nodes data values alternatively numericvalued entities handled combining abstractions logical structures previously techniques creating numeric abstractions structure unary preds binary preds indiv gfed abc gfed abc gfed abc gfed abc abstracts unary preds binary preds indiv onmlhijkgfed abc statement predicate update formulas structure unary preds binary preds indiv gfed abc gfed abc gfed abc gfed abc abstracts unary preds binary preds indiv gfed abc gfed abc onmlhijkgfed abc embeds unary preds binary preds indiv onmlhijkgfed abc fig top row illustrates abstraction -valued structure -valued structure -abstraction boxes tables unary predicates individuals grouped equivalence classes boxes tables anda truth-blurring quotients performed commutative diagram illustrates relationship transformation -valued structures defined predicate-update formulas concrete semantics abstraction iii sound abstract semantics obtained predicate-update formulas transform -valued structures predicate-update formulas core predicate define core predicates logical structure arises source transformed create structure target define predicate denoted update formulas fig function predicates edge optionally precondition formula filters structures follow transition canonical abstraction create abstractions -valued logical structures stores encode related class -valued logical structures vocabulary -valued logical structures truth denoted introduced denote uncertainty -valued logical structure valuea predicatea tuple individuals allowed definition truth values definite values indefinite information order defined iff symbol denotes least-upper-bound operation respect abstract stores program analysis -valued logical structures construction discussed priori bounded size general -valued logical structure corresponds possibly infinite set -valued logical structures members families structures related canonical abstraction principle canonical abstraction illustrated top bottom rows fig show -valued structures abstracted -valued structures abstraction function determined subset unary predicates predicates called abstraction predicates act applying abstraction function called -abstraction canonical abstraction illustrated fig -abstraction abstraction driven values vector abstraction predicates individual values equivalence classes formed individuals vector values abstraction predicates equivalence classes boxes table unary predicates show individuals grouped equivalence classes members equivalence class mapped individual -valued structure members mapped individual called similarly members mapped individual called non-abstraction predicate -valued structure predicatea -valued structure formed truth-blurring quotient tuple join tuples equivalence relation individuals maps instance equals equal equal equals names individuals completely arbitrary distinguishes vector abstraction predicates equal anda equal upper-left-hand corner fig boxes tables predicates groupings values -valued structure predicate represents equality relation individuals general canonical abstraction individuals lose identity uncertainty arises predicate instance represents single individual hand represents individuals quotient operation individual called summary individual -valued logical structure abstract descriptor set -valued logical structures general summary individual models set individuals -valued logical structures represents graphical notation -valued logical structures structure fig derived -valued structures additions individuals represented circles names figs place unary predicates correspond pointer-valued program variables inside circles summary individual represented double circle unary binary predicates represented dotted arrows concrete structure represented abstract structure fig pointer variables point concrete node represents n-field node point concrete nodes represents summary individual represent concrete node possibly n-field concrete nodes points concrete nodes represents ann-field concrete nodes points concrete node represents note -valued structure represents acyclic lists length pointed cyclic lists length pointed back-pointer head list element additional memory configurations cyclic acyclic list pointed garbage cells reachable finite representation infinite set possibly cyclic concrete lists accompanied unreachable cells section discuss options fine-tuning abstraction canonical abstraction define abstraction acyclic lists cyclic lists mapped -valued structures presence absence unreachable cells readily apparent canonical abstraction ensures -valued structure priori bounded size guarantees fixed-point reached iterative staticanalysis algorithm advantage -valued logic basis static analysis language extracting information concrete world abstract world identical syntactic expression logical formula interpreted -valued world -valued world formulas first-order formulas transitive closure formula vocabulary defined stands reflexive transitive consistency -valued -valued viewpoints ensured basic theorem relates logics explains point mentioned sect method eliminates user write usual proofs required abstract interpretation single meta-theorem embedding theorem theorem shows information extracted -valued structure evaluating formula sound respect -valued structures represents abstract semantics falls automatically specification concrete semantics formulas define concrete semantics interpreted -valued logic define sound abstract semantics interpreted -valued logic fig soundness instantiations analysis framework ensured embedding theorem program analysis -valued logic run analyzer carries abstract interpretation collect set -valued structures program point involves finding fixed-point set equations canonical abstraction ensures -valued structure priori bounded size finite number sets -valued structures guarantees fixed-point reached structures collected program point describe superset execution states occur determine property holds checks holds structures collected unary preds binary preds indiv xyz xyz xyz xyz abstractsto unary preds binary preds indiv xyz xyz wvutpqrs fig abstraction -valued structure -valued structure -abstraction contrast fig represents acyclic lists length garbage cells instrumentation predicates care design analysis danger abstract interpretation proceeds indefinite pervasive destroy ability recover interesting information -valued structures collected soundness maintained key role combating indefiniteness played instrumentation predicates record auxiliary information logical structure provide mechanism user fine-tune abstraction instrumentation predicate arity defined logical formula core predicate symbols captures property -tuple nodes possess general adding additional instrumentation predicates refines abstraction defining precise analysis prepared track finer distinctions nodes properties program stores identified analysis introduction unary instrumentation predicates abstraction predicates control concrete individuals merged summary nodes control amount information lost closure formulasa variables abstraction instrumentation predicates involve reachability properties defined transitive closure play crucial role definitions abstractions fig instance program-analysis applications reachability properties specific pointer variables effect keeping disjoint sublists subtrees summarized separately important analyzing program pointers advanced disjoint sublists tab lists instrumentation predicates important analysis programs type list reachable n-fields reachable pointer variable n-fields directed cycle n-fields table defining formulas commonly instrumentation predicates typically separate predicate symbol pointer-valued variable standpoint concrete semantics instrumentation predicates represent cached information recomputed reevaluating instrumentation predicate defining formula current store standpoint abstract semantics reevaluating formula current -valued store lead drastic loss precision gain maximum benefit instrumentation predicates abstract-interpretation algorithm obtain values problem problem 
solved incremental computation instrumentation predicate transition abstract state transformer state computed incrementally algorithm defining formula generate incremental predicate-maintenance formula fora presented problem automatically identifying instrumentation predicates process abstraction refinement addressed paper input required program analysis consists program characterization inputs iii query formula characterizes intended output work framework eliminating previously required user inputs tvla criticized past operations logical structures fact embedding theorem applies pair structures embedded operations -valued structures constrained manipulate -valued structures images canonical abstraction perform canonical abstraction application abstract structure transformer ensure abstract interpretation terminates canonical abstraction applied widening operator loop target back-edge control-flow graph simple abstract semantics obtained applying predicate-update formulas -valued structures imprecise instance fig sets point element list abstract semantics evaluation structure predicate-update formula set surmise point cells summary node represents contrast canonical abstraction demonstrates abstract domain capable representing precise abstract semantics -to-a transformation illustrated fig shown galois connection defined abstraction function concretization function abstract transformer concrete transformer denoted expressed defines limit precision obtainable abstract domain non-constructive definition provide algorithm finding applying prevent analysis losing precision operations logical structures implement approximation transformer focus operation invoked elaborate -valued structure allowing replaced set precise structures necessarily images canonical abstraction represent set concrete stores coerce clean-up operation sharpen -valued structure setting indefinite definite discard structure structure exhibits fundamental inconsistency represent concrete store transformers tvla make focus coerce incremental predicatemaintenance formulas implement approximation transformer -to-a transformation fig tvla capable materializing non-summary nodes summary nodes instance tvla transformer fory nwould create structure essence materializing materialization permits abstract execution assignment pointervalued field newly created non-summary node perform strong update dynamically allocated storage model semantics ofx malloc model free-storage list explicitly exploit materialization gfed abca freelist freelist freelist freelistn gfed abc gfed abc onmlhijkgfed abc freelist malloc modeled advancing pointerfreelist list returning memory cell pointed free modeled inserting head freelist list cell deallocated applications extensions interprocedural analysis application canonical abstraction interprocedural analysis programs recursion studied main idea expose runtime stack explicit data structure concrete semantics activation records individuals suitable core predicates introduced capture activation records linked form stack instrumentation predicates record information calling context invisible copies variables pending activation records stack analysis based logical structures doubled vocabularya denotes disjoint union approach creates finite abstraction relates predicate values individual beginning transition predicate values individual end transition two-vocabulary -valued structures create summary transformer procedure summary transformer call site called checking multithreaded systems shown apply -valued logic problem checking properties multithreaded systems addresses problem state-space exploration languages java dynamic creation destruction unbounded number threads dynamic storage allocation destructive updating structure fields threads modeled individuals abstracted canonical abstraction case collection unary thread properties hold thread naming scheme automatically discovers commonalities state space relying explicitly supplied symmetry properties analysis algorithm builds explores -valued transition system on-the-fly unary core predicates represent program counter thread object focus implement nondeterministic selection runable thread numeric abstractions abstractions sect capable representing pointer variables contents structure heap direct representing actual data items stored nodes data structures recent work coupled canonical abstraction variety previously numeric abstractions intervals congruences polyhedra restrictions polyhedral domains difference constraints -variable constraints overapproximate states arise program sets points -dimensional space canonical abstraction create bounded-size representations memory configurations number nodes abstract descriptor points program numeric abstractions means number axes program point program point fixed capture numeric properties summarizing framework analysis capture relationships values groups numeric objects relationships values individual numeric objects abstract transformers mentioned sect galois connection non-constructive definition abstract transformer concrete transformer expressed defines limit precision obtainable abstract domain provide algorithm finding applying graf showed decision procedures generate abstract transformers abstract domains finite cartesian products boolean values domains predicate abstraction ability perform abstract interpretation abstract transformers play key role combating indefiniteness -valued structures ensure abstract interpretation computes answers precise inherent limitations abstraction recent work made start goal defined approaches computing transformers applications canonical abstraction applications problems -valued-logic approach applied include tvla establish partial correctness bubble-sort insert-sort routines sorting linked lists abstractionrefinement method extend work address stability antistability properties sorting routines tvla demonstrate total correctness mark-and-sweep garbage collector operating arbitrary heap java iterator object created collection long remains unmodified counting modifications made concurrent modification exception thrown tvla create verification tool establishing absence concurrent modification exceptions area multithreaded systems -valued-logic approach establish absence deadlock dining-philosophers program permits unbounded number philosophers establish partial correctness concurrent queue algorithms results obtained imposing priori bound number allocated objects threads related work predicate abstraction canonical abstraction confused predicate abstraction variety systems level predicate abstraction canonical abstraction essentially mechanism predicate abstraction abstract possibly-infinite transition system finite concrete states transition system grouped abstract states values vector properties transition relation quotiented equivalence relation induced concrete states canonical abstraction abstract possibly-infinite logical structure finite -valued concrete individuals mapped abstract individuals values vector unary abstraction predicates predicates quotiented equivalence relation induced concrete individuals canonical abstraction applied encodings stores logical structures machinery developed -valued structures define parametric abstract domain abstract interpretation predicate abstraction define parametric abstract domain alternative comparison criterion relationship parametric abstract domains predicate abstraction yields parametric abstract domain based finite cartesian products booleans nullary predicates abstract consists finite set finite-sized vectors nullary predicates canonical abstraction yields parametric abstract domain based -valued logical structures abstract consists finite set finite-sized -valued structures special case canonical abstraction occurs abstraction predicates case individuals collapsed single individual structures information remaining resides nullary core instrumentation predicates predicate abstraction step retaining nullary predicates point view canonical abstraction strictly general predicate abstraction red green yellow red red red fig transition diagram stoplight transition diagram abstracted method green yellow mapped transition diagram abstracted canonical abstraction reda abstraction predicate existential abstraction canonical abstraction related notion existential abstraction canonical abstraction yields -valued predicates distinguishes summary nodes non-summary nodes existential abstraction yields -valued predicates distinguish summary nodes non-summary nodes fig shows transition diagram stoplight abstracted method fig canonical abstraction reda abstraction predicate fig existential abstraction soundness preserved restricting attention universal formulas formulas actla canonical abstraction soundness preserved switching logics case syntactic restriction switch -valued firstorder logic -valued first-order logic advantage approach formula query concrete state syntactic formula pose query abstract state one-sided versus two-sided answers static-analysis algorithms provide -valued answers one-sided answer definite conservative 
means means means means contrast basing abstract semantics -valued logic definite truth definite falseness tracked capturing indefiniteness determine formula holds evaluated structures collected answer join values insight true nature one-sided approach instance analysis definite respect -valued analysis conflates place noted two-sided analysis answers definite respect concrete semantics overapproximate behavior actual system modeled acknowledgments students collaborators havelund pressburger model checking java programs java pathfinder softw tools tech transfer wagner foster brewer aiken step automated detection buffer overrun vulnerabilities network dist syst security engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions syst design impl corbett dwyer hatcliff laubach pasareanu robby zheng bandera extracting finite-state models java source code int conf softw eng bush pincus sielaff static analyzer finding dynamic programming errors software practice experience ball rajamani slam toolkit int conf computer aided verif volume lec notes comp sci chen wagner mops infrastructure examining security properties software conf comp commun sec andersen binding-time analysis taming pointers part eval semantics-based prog manip steensgaard points-to analysis almost-linear time princ prog lang das unification-based pointer analysis directional assignments prog lang design impl ahndrich rehof das scalable context-sensitive flow analysis instantiation constraints prog lang design impl cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation prog lang design impl foster ahndrich aiken polymorphic versus monomorphic flow-insensitive points-to analysis static analysis symp whaley lam cloning-based context-sensitive pointer alias analyses binary decision diagrams prog lang design impl zhu calman symbolic pointer analysis revisited prog lang design impl das liblit ahndrich rehof estimating impact scalable pointer analysis optimization static analysis symp sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points princ prog lang lev-ami sagiv tvla system implementing static analyses static analysis symp tvla system http math tau rumster tvla gopan dimaio dor reps sagiv numeric domains summarized dimensions tools algs construct anal syst reps sagiv loginov finite differencing logical formulas static analysis european symp programming loginov reps sagiv abstraction refinement -valued-logic analysis tech rep comp sci dept univ wisconsin cousot cousot systematic design program analysis frameworks princ prog lang rinetzky sagiv interprocedural shape analysis recursive programs comp construct volume lec notes comp sci jeannet loginov reps sagiv relational approach interprocedural shape analysis tech rep comp sci dept univ wisconsin yahav verifying safety properties concurrent java programs -valued logic princ prog lang emerson sistla symmetry model checking courcoubetis int conf computer aided verif cousot halbwachs automatic discovery linear constraints variables program princ prog lang dill timing assumptions verification finite-state concurrent systems automatic verification methods finite state systems min graph-based relational numerical abstract domains static analysis symp simon king howe variables linear inequality abstract domain int workshop logic based prog dev transformation graf construction abstract state graphs pvs int conf computer aided verif volume lec notes comp sci reps sagiv yorsh symbolic implementation transformer verif model checking abs interp yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tools algs construct anal syst lev-ami reps sagiv wilhelm putting static analysis work verification case study int symp softw testing analysis ramalingam warshavsky field goyal sagiv deriving specialized program analyses certifying component-client conformance prog lang design impl yahav sagiv automatically verifying concurrent queue algorithms workshop software model checking das dill park experience predicate abstraction int conf computer aided verif springer-verlag henzinger jhala majumdar sutre lazy abstraction princ prog lang ball podelski rajamani boolean cartesian abstraction model checking programs tools algs construct anal syst clarke grumberg jha veith counterexample-guided abstraction refinement int conf computer aided verif clarke grumberg long model checking abstraction trans prog lang syst 
popseq popseq popseq popseq popseq popseq exit null false true null null 
wysinwyx execute balakrishnanbd repsbdbnbe melskibe teitelbaumbe comp sci dept wisconsin cubgogul repscv wisc grammatech cumelski ttcv grammatech abstract execute computers execute source-code programs execute machine-code programs generated source code wysinwyx phenomenon create mismatch programmer intends executed processor analyses performed source code fail detect bugs vulnerabilities issue arises favorite approach assuring programs behave desired based theorem proving model checking abstract interpretation introduction recent research programming languages software engineering computer security led kinds tools analyzing code bugs security vulnerabilities tools static analysis determine conservative answer question program reach bad state tools focus analyzing source code written high-level language drawbacks mismatch programmer intends executed processor analyses performed source code fail detect bugs vulnerabilities due wysinwyx phenomenon execute source-code fragment login program illustrates issue memset password len free password login program temporarily stores user password clear text dynamically allocated buffer pointed pointer variable password minimize lifetime password sensitive information code fragment shown zeroes-out buffer pointed passwordbefore returning heap compiler performs useless-code elimination reason program values written call memset call memset removed leaving sensitive information exposed heap hypothetical similar vulnerability discovered windows security push vulnerability invisible source code detected examining low-level code emitted optimizing compiler wysinwyx phenomenon restricted presence absence procedure calls contrary pervasive bugs security vulnerabilities exist myriad platform-specific details due features idiosyncrasies compilers optimizers including static analysis obtain information states program reaches execution running program specific inputs static-analysis techniques explore program behavior inputs states program reach make feasible program run aggregate descriptors represent collections memory configurations memory-layout details positions offsets variables runtime stack activation records padding structure fields register usage execution order actual parameters optimizations performed artifacts compiler bugs access information crucial instance security exploits depend platform-specific features structure activation records vulnerabilities escape notice tool information adjacency relationships variables analyses based source code typically make unchecked assumptions program ansi-c compliant means analysis account behaviors allowed compiler arithmetic performed pointers subsequently indirect function calls pointers move ends arrays subsequently dereferenced programs typically make extensive libraries including dynamically linked libraries dlls source-code form typically analyses performed code stubs model effects library calls created hand errors analysis return incorrect results programs modified subsequent compilation perform optimizations insert instrumentation code modified insert malicious code modifications visible tools analyze source source code written language complicates life designers tools analyze source code multiple languages supported quirks source code primarily written high-level language inlined assembly code selected places source-level tools typically skip inlined assembly code push analysis sites inlined assembly code short number reasons analyses based source code provide level detail checking kinds properties source-level tools applicable source limits usefulness security applications analyzing code open-source projects source code substantial amount information hidden analyses start source code bugs security vulnerabilities malicious behavior invisible tools source-code tool strives greater fidelity program executed duplicate choices made compiler optimizer approach doomed failure issue source code level verifying program properties concern interested assuring programs terms analyses based source code source-level analyses shorthand analyses work intermediate representations irs built source code behave desired issues discussed arise favorite approach based theorem proving model checking abstract interpretation remainder paper organized presents examples show analysis executable provide accurate information source-level analysis discusses approaches analyzing executables describes work codesurfer analyze executables absence source code advantages analyzing executables presented showed overzealous optimizer mismatch programmer intends executed processor additional examples sort discussed boehm points threads implemented library languages threads part language specification compiler transformations reasonable absence threads multi-threaded code fail exhibit unexpected behavior subtle reasons visible tools analyze source code class examples analysis executable provide accurate information source-level analysis arises programming languages behaviors left unspecified semantics cases source-level analysis account behaviors analysis executable generally deal behavior code sequence chosen compiler instance order actual parameters evaluated actuals evaluated left-to-right right-to-left order compiler evaluation orders functions evaluation orders give rise behaviors actual parameters expressions side effects source-level analysis sound call site join abstract descriptors result analyzing permutation actuals contrast analysis executable analyze sequence instructions lead call class involves pointer arithmetic indirect call int void int diff char char offset int char diff points indirect call existing source-level analyses ill-prepared handle code conventional assumption arithmetic function pointers leads emain call ret call ret xmain 
undefined behavior source-level analyses assume indirect function call call function ignore arithmetic operations assume indirect function call calls assumption code ansi-c compliant contrast analysis balakrishnan reps correctly identifies invoked function analysis detect arithmetic addresses creates address point beginning function address perform function call bug subtle deliberately introduced security vulnerability related unspecified behavior shown fig code left uninitialized variable triggers compiler warning compiles successfully source-code analyzer assume local main assembly listings show code compiled including variants prolog functioncallee microsoft compiler variant includes strength reduction instruction esp allocates space local replaced push instruction arbitrary register case ecx contrast analysis based source code analysis executable determine optimization results local initialized main int callee int int int local local return return int main int int int callee return mov ebp var mov ebp var mov eax ebp var push eax mov ecx ebp var push ecx call callee standard prolog prolog local push ebp push ebp mov ebp esp mov ebp esp esp push ecx fig unexpected behavior due compiler optimization box top shows variants code generated optimizing compiler prolog callee analysis reveals variable local necessarily fourth related unspecified behavior involves function call passes fewer arguments procedure expects parameters compilers accept unsafe code easy implement functions variable number parameters compilers effectively means call-site passes parts local variables calling procedure remaining parameters effect passed assignment parameter callee overwrite local caller analysis works executables created capable determining extra parameters source-level analysis make cruder over-approximation unsound under-approximation approaches analyzing executables examples illustrate advantages analyzing executables source code executable actual instructions executed reveals accurate information behaviors occur execution analysis incorporate platform-specific details including memory layout register usage execution order optimizations artifacts compiler bugs issues arise analyzing source code disappear analyzing executables entire program analyzed including libraries linked program library code analyzed directly rely potentially unsound models library functions executable modified subsequent compilation modifications visible analysis tool source code source code written language tool analyzes executables support language instructions inserted inlined assembly directives source code visible 
treated differently instructions challenge build tools benefit advantages provide level precision dichotomy classifying approaches tool assumes information addition executable source code symboltable information debugging information instance aim translation validation verify compilation change semantics program translation-validation system receives source code target code input attempts verify target code correct implementation refinement source code rival presents analysis abstract interpretation check assembly code produced compiler possesses safety properties original source code analysis assumes source code debugging information source code assembly code program analyzed debugging information map results assembly-code analysis back source code results program points source code assembly code compatible assembly code possesses safety properties source code analyzing executables absence source code codesurfer build sdg browse executable connector value-set analysis initial estimate code data procedures call sites malloc sites ida pro build cfgs parse executable fleshed-out cfgs fleshed-out call graph killed may-killed variables cfg nodes points-to sets reports violations code rewriter decompiler path inspector user scripts wpds codesurfer fig organization codesurfer companion tools past years working create platform support analysis executables absence source code goal work extend static vulnerability-analysis techniques work directly stripped executables developed prototype tool set analyzing executables members tool set codesurfer wpds path inspector fig shows components codesurfer fit recovering irs executables apply analysis techniques encounters challenging program-analysis problem perspective model-checking community problem model extraction extract suitable model executable perspective compiler community problem recovery recover intermediate representations executable similar started source code solve ir-recovery problem obstacles overcome kinds potentially malicious programs symbol-table debugging information absent present relied understand memory-access operations determine set addresses accessed operation difficult memory operations explicit memory addresses instruction easy indirect addressing address expressions difficult arithmetic addresses pervasive instance local variable loaded slot activation record address arithmetic performed notion type hardware level address values distinguished integer values recover irs executables codesurfer makes idapro disassembly toolkit grammatech codesurfer system toolkit building program-analysis inspection tools executable disassembled idapro addition disassembly listing idapro access information procedure boundaries calls library functions statically memory addresses offsets idapro access internal resources api users create plug-ins executed idapro created plug-in idapro called connector creates data structures represent information obtains idapro idapro connector combination create data structures dynamically linked libraries link data structures represent program infrastructure permits whole-program analysis carried including analysis code library functions called data structures connector implemented static-analysis algorithm called value-set analysis vsa vsa assume presence symbol-table debugging information step set data objects called a-locs abstract locations determined based static memory addresses offsets provided idapro vsa combined numeric pointer-analysis algorithm determines over-approximation set numeric values addresses value-set a-loc holds program point key feature vsa tracks integer-valued address-valued quantities simultaneously crucial analyzing executables numeric values addresses indistinguishable execution time vsa flow-sensitive interprocedural dataflow-analysis algorithm callstrings approach obtain degree context sensitivity idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete information computed vsa augment call graph control-flow graphs on-the-fly account indirect jumps indirect calls vsa checks executable conforms standard compilation model runtime stack maintained activation records pushed stack procedure entry popped stack procedure exit procedure modify return address stack program instructions occupy fixed area memory self-modifying separate program data confirmed executable conforms model possibly incorrect call-graph incorrect procedure modifies return address stack vsa issues error report finds violation standard compilation model represent memorysafety violations analyst reports determine false alarms real violations vsa completes value-sets a-locs program point determine point sets killed possibly-killed a-locs emitted format suitable input codesurfer codesurfer builds collection irs consisting abstract-syntax trees control-flow graphs cfgs call graph system dependence graph sdg vsa results sets killed possibly killed a-locs instruction information structure layout global memory activation records dynamically allocated storage codesurfer supports graphical user interface gui api scripting language provide access structures model-checking facilities model checking codesurfer irs build weighted pushdown system wpds models program behaviors weighted pushdown systems generalize model-checking technology pushdown systems pdss software model checking moped mops systems compared ordinary unweighted pdss wpdss capable representing powerful kinds abstractions runtime states capabilities pdss instance wpdss address kinds security-related queries answered mops wpds library implements symbolic reachability algorithms weighted pushdown systems follow standard approach pushdown system pds model interprocedural control-flow graph codesurfer irs stack symbols correspond program locations single pds state pds rules encode control flow rule control flow modeled cwd cwdacx intraprocedural cfg edge cwcrcx cwctd call returns cwdccx cwcx return procedure exit node configuration pds symbol top stack corresponds current program location rest stack holds return-site locations pds model behavior program runtime execution stack encoding interprocedural control-flow pushdown system sufficient answering queries reachable control states path inspector reachability algorithms wpds determine undesirable pds configuration reachable wpds supports weighted pdss pdss rule weighted element user-defined semiring weights wpds perform interprocedural dataflow analysis semiring extend operator compute weights sequences rule firings semiring combine operator meet weights generated paths weights rules conservative abstract data transformers over-approximation set reachable concrete configurations obtained means counterexamples reported wpds infeasible advantage answering reachability queries wpdss conventional dataflow-analysis methods merge values states program point states calling context wpdss queries posed respect regular language stack configurations conventional merged dataflow information obtained path inspector user interface automating safety queries concerned control configurations executable reach automaton-based approach model checking query finite automaton captures forbidden sequences program locations query automaton combined program model wpds cross-product construction reachability algorithms wpds determine error configuration reachable error configuration reachable witnesses produce program path drives query automaton error state path inspector includes gui instantiating common reachability queries displaying counterexample paths disassembly listing current implementation transitions query automaton triggered program points user specifies manually result sets codesurfer queries future versions path inspector support sophisticated queries transitions triggered matching ast pattern program location query states instantiated based pattern bindings related work previous work analyzing memory accesses executables dealt memory accesses conservatively generally register assigned memory assumed vsa job previous work tracks integer-valued address-valued quantities program data objects hold vsa tracks values data objects assume source code techniques extend naturally treat executable code collection irs obtainable source code mapping information back source code similar sourcecode tools perform preprocessor kind issues arise debugging optimized code complicate matters hardware registers forced give precision load memory encountered basic 
goal algorithm proposed debray similar vsa find over-approximation set values register hold program point find over-approximation set values abstract data object hold program point data objects include memory locations addition registers analysis set addresses approximated set congruence values track low-order bits addresses unlike vsa algorithm make effort track values registers lose great deal precision load memory cifuentes fraboulet give algorithm identify intraprocedural slice executable program use-def chains algorithm makes attempt track values registers cuts short slice load memory encountered pieces work closely related vsa algorithm data-dependence analysis assembly code amme algorithm pointer analysis low-level intermediate representation guo algorithm amme performs intraprocedural analysis clear algorithm fully accounts dependences memory locations algorithm guo partially flow-sensitive tracks registers flowsensitive manner treats memory locations flow-insensitive manner algorithm partial transfer functions achieve context-sensitivity transfer functions parameterized unknown initial values uivs clear algorithm accounts possibility called procedures corrupting memory locations uivs represent challenges future number challenging problems additional research needed similar challenges faces analyzing source code efficiency scalability analysis algorithms including create summary transformers procedures accounting non-local transfers control setjmp longjmp exception handling analysis variable-argument functions analysis multi-threaded code analysis heap-allocated data structures source-code analysis develop specialized analyses kinds data programming idioms including strings program macro-level effects loops perform array operations arrayinitialization loop initializes elements array effects loops perform sentinel search analysis self-modifying code prefast driver-specific rules october windows hardware driver central whdc web site http microsoft whdc devtools tools prefast-drv mspx amme braun zehendner thomasset data dependence analysis assembly code int parallel proc balakrishnan reps analyzing memory accesses executables comp construct pages ball rajamani slam toolkit computer aided verif volume lec notes comp sci pages boehm threads implemented library pldi pages bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur bouajjani esparza touili generic approach static analysis concurrent programs procedures popl pages bush pincus sielaff static analyzer finding dynamic programming errors software practice experience chen wagner mops infrastructure examining security properties software conf comp commun sec pages november cifuentes fraboulet intraprocedural static slicing binary executables int conf softw maint pages codesurfer grammatech http grammatech products codesurfer corbett dwyer hatcliff laubach pasareanu robby zheng bandera extracting finite-state models java source code icse cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points popl coutant meloy ruscetta doc practical approach source-level debugging globally optimized code pldi das lerner seigle esp path-sensitive program verification polynomial time pldi debray muth weippert alias analysis executable code popl dwyer avrunin corbett patterns property specifications finite-state verification icse engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions syst design impl pages finkel willems wolper direct symbolic approach model checking pushdown systems elec notes theor comp sci gerth formal verification modifying code proc int conf young computer scientists pages gopan reps sagiv framework numeric analysis array operations popl pages guo bridges triantafyllis ottoni raman august practical accurate low-level pointer analysis int symp code gen opt havelund pressburger model checking java programs java pathfinder softw tools tech transfer hennessy symbolic debugging optimized code trans prog lang syst henzinger jhala majumdar sutre lazy abstraction popl pages horwitz reps binkley interprocedural slicing dependence graphs trans prog lang syst january howard bad news good news msdn october http msdn microsoft library default asp url library enus dncode html secure asp idapro disassembler http datarescue idabase kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds lal reps improving pushdown system model checking cav lal reps balakrishnan extended weighted pushdown systems cav necula translation validation optimizing compiler pldi pnueli siegel singerman translation validation tacas reps balakrishnan lim recovery low-level code part eval semantics-based prog manip reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis sas reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog october rival abstract interpretation based certification assembly code vmcai schwoon moped system http fmi uni-stuttgart szs tools moped schwoon model-checking pushdown systems phd thesis technical univ munich munich germany july sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs wagner foster brewer aiken step automated detection buffer overrun vulnerabilities network dist syst security february wall systems late code modification giegerich graham editors code generation concepts tools techniques pages springer-verlag wilson lam efficient context-sensitive pointer analysis programs pldi pages zellweger interactive source-level debugging optimized programs phd thesis univ california berkeley 
enterf enterf exitf entermain exitmain emain call ret xmain call ret call ret emain call xmain ret ret ret call call 
constructing specialized shape analyses uniform change tal lev-ami mooly sagiv neil immerman thomas reps school computer science tel aviv ftla msagivg post tau department computer science umass amherst immerman umass computer science department wisconsin madison reps wisc abstract paper concerned basic problems abstract interpretation abstraction set concrete transformers express concrete semantics program create abstract transformers develop methodology addressing problem based syntactically restricted language expressing concrete transformers methodology produce abstract transformers abstractions important data structures introduction abstraction abstract interpretation key tools automatically verifying hardware software systems paper concerned basic problems abstract interpretation abstraction set concrete transformers express concrete semantics program create abstract transformers develop methodology addressing problem based syntactically restricted language expressing concrete transformers interest employing previous results dynamic algorithms dynamic descriptive complexity methods precise reachability information maintained abstractions data structures methodology produce abstract transformers abstractions important data structures shape analysis canonical abstraction dynamic descriptive complexity approach general main application shape analysis analysis linked data structures analyses based canonical abstraction family abstractions introduced sagiv reps wilhelm analyzing programs dynamic data structures including allocation deallocation memory cells destructive updates pointer-valued fields approach data structures modeled -valued logical structures element universe structure represents single memory cell element summary element represents set memory cells analysis simulates program step-by-step updating structures appropriately mimicking approximating soundly semantics program statements fixpoint reached resulting set structures finite summary relevant supported adams fellowship israel academy sciences humanities supported nsf grants ccfand ccfsupported nsf grants ccfand ccfproperties data structures built program note resulting properties set structures proven hold necessarily hold runs program analysis framework implemented tvla system acronym stands three-valued logic analyzer key technical difficulty concerns summary elements needed unbounded-size set unbounded-size concrete data structures arise abstracted finite set finite-size logical structures guarantees analysis reaches fixpoint problem caused summary nodes relations cells memory true elements represented summary node false truth introduced framework based -valued logic analysis propagates -valued structures tendency logical values don increase limits quality information analysis provide good combat problem maintain extra auxiliary relations logical structures approach dynamic descriptive complexity motivation completely dynamic descriptive complexity work objects undergo series inserts deletes queries query goal return answer respect current object fundamental issue dynamic descriptive complexity efficiency auxiliary information maintained answer query quickly goal maintaining extra information avoid recomputing answer scratch static analysis based -valued logic issue save computation time preserve high-quality information definite truth values key technical difficulty concerns reachability information needed express connectivity separation properties data structures extensive work dynamic descriptive complexity efficiently maintain reachability information dong showed acyclic graphs reachability maintained first-order formulas interest result hesse reachability not-necessarily acyclic functional graphs maintained quantifier-free formulas methodology explained tvla maintains abstract -valued structures represent sets concrete -valued structures abstract structure feasible iff abstraction operator individual concrete structures abstract representation approximate inverse operations adjoined functions program statement tvla update formula concrete structure concrete structure produced executing statement update formula safe abstract structures meaning abstraction gold standard abstract transformers called transformer satisfies property btst flfl infinite equation provide algorithm computing transformer tvla employs heuristics efficiently compute safe transformer necessarily transformer paper introduce syntactic condition called monadic uniform property thm main theorem update formulas data structure monadic uniform algorithm abstract structure decides feasible automatically compute transformers operations data structure show main theorem applies important situations modify results dynamic descriptive complexity create monadic-uniform update formulas important classes data structures including linked lists cyclic linked lists doubly-linked lists cyclic doubly-linked lists trees shared trees directed graphs undirected cycles data structures arbitrary unary relations ordering relation included present efficient feasibility algorithms data structures implement abstract transformers automatically vision build specialized shape analyses programs observed properties paper important step direction shows build systematic manner specialized shape analyses good theoretical properties important data structures predicate abstraction results limited tvla context provide improve predicate-abstraction method rakamaric linked-list abstraction relation capture path rakamaric give complete decision procedure checking feasibility abstract state left open question handle transformers most-precise methodology solves problem quantifier-free update formulas hesse build transformers abstraction compute abstract transformer addition removal edge extend vocabulary constant capturing current target edge replace abstract state set states provide interpretations predicates involving constant rakamaric decision procedure remove infeasible abstract states remaining states evaluate hesse update formulas successor states overview node reverse node node null null node return fig running section informal overview methodology presented paper simple java procedure reverses singly-linked list fig running run reverse cyclic singly-linked list graphical representation logical structures depict store graph fig singly linked list cycle memory cells represented individuals structures nodes graph program variables represented constants text inside nodes pointer fields memory cell represented binary relations edges graph annotated relation case field list nodes represented relation total function add structure auxiliary relations defined order logic transitive closure formulas core relations fig unary relation written nodes existence path node pointed defined unary relation states node cycle fields defined fig concrete structure represents singly-linked list loop pointed consists nodes singly-linked list time auxiliary information abstraction singly-linked lists loops result computing abstract transformer operation note concrete node null self-loop edges draw save space abstract interpretation represent large possibly infinite set stores finite set structures collapsing nodes summary nodes drawn double circles three-valued logic additional truth binary relations depicted dotted edge capture case nodes represented summary node true false fig shows abstract structure constants untouched nodes values unary relations collapsed type abstraction called canonical abstraction guaranteed result structures bounded size vocabulary embedding theorem guarantees evaluating formulas kleene semantics abstract structure results definite evaluating formula concrete structure represents yield kleene semantics understood evaluating pointwise transformers operation program operational semantics transformers guarded commands formulas called update formulas operation line fig guard null ensure null-dereference bind field temporary constant update formulas precise abstract readers familiar tight embedding paper summary node represents nodes transformer return set abstract structures captures tightly abstraction result applying transformer concrete structures represented original abstract structure kind abstract transformer called abstract transformer theoretically computed finding concrete structures represented abstract structure concretization computing transformer abstracting results number concrete structures represented abstract structure unbounded potentially infinite algorithm fig fig show result structure fig structure fig represents case list cycle length structure fig represents 
case length note simply evaluating update formulas structure fig precise result seek compute result transformer resorting full concretization key principles methodology find partial concretization computable returns finite set abstract structures represents concrete structures structures abstract transformer computed simply evaluating update formulas call operation finding partial concretization focus similar operation focus replaces structure set structures representing concrete structures partitioning concrete nodes summary nodes fine-grained achieved bifurcating summary nodes groups nodes atomic formula holds nodes hold call formula focus formula fig show result focus focus formula structure fig nodes lists fig result bifurcating node fig focus formula node formula holds node formula hold process result multiple structures fig corresponds case original summary node represents concrete nodes fig case summary node represents concrete nodes cases node materialized original summary node automate focus operation propose algorithm compute partial concretization set focus formulas phase understand intended meaning relations phase applies feasibility check supplied developer abstraction algorithm feasibility checking return true iff abstract structure represents concrete structure fig show structures arising focus process infeasible structure infeasible node represent nodes node direct edge contradicts function structure infeasible self-loop node means self-loop self-loop provide algorithms checking feasibility abstractions commonly data structures note check feasibility abstraction sound approximation resulting transformer sound approximation transformer problem finding focus formulas focus transformer computation require evaluation return precise results element cycle return means edges cycle means lengths segment list cycle solve problem limit update formulas leads principle monadic-uniform update formulas update formula rewritten cycle cycle reachable reachable node reachable reachable evaluating updated transformer structures fig results structures fig fig focusing coincidence show limit update formulas syntactic class call monadic-uniform automatically find focus formulas needed focus operation result focus guaranteed bounded function size original structure process finding monadic-uniform update formulas trivial update reachability fortunately existing results dynamic descriptive complexity database communities maintaining reachability edges added removed key step finding monadicuniform update formulas addition auxiliary relations relations maintained monadic-uniform update formulas provide monadic-uniform transformers abstractions analyses successfully tvla methodology summarized find abstraction captures properties verify describe framework parameterized shape analysis insure update formulas monadic-uniform adding extra auxiliary relations needed optionally develop feasibility check abstract structures possibly augmented vocabulary settle sound approximation transformer paper presents algorithms binding ingredients compute abstract transformers fig structures arising process focus operation structure fig preliminaries represent stores logical structures logical formulas define semantics statements abstractions stores simplify presentation describe context specific vocabulary clear description formulas schematic instantiated specific program fields variables formal definition syntax formulas shorthand default sequential case split formally -valued logical structure triple hus csi universe individuals map relation symbols truth-valued functions map constant symbols individuals formal definition programming-language statements formulas update store standard definition store updates update formula relation arity form formula free variables update formula constant form default closed formulas constant symbols shorthand formula free variable default special case simply write statement programming language transformer consists guard formula guard set update formulas relation constant symbol vocabulary guard formula free variables update formulas refer constants -valued logical structure expansion set expand structures identical interpretation free variables guard expanded application transformer structure expand valued structure relation symbol constant symbol unique element note interpretation original constants free variables guard meaning transformer set expand guard guardst update formulas null null sel null tsel sel tsel sel null sel sel table relation-update formulas define semantics statements manipulate pointers pointer-valued fields free variables guard formula introduction nondeterminism free variables considered additional constants update formulas syntactic form update formulas constants guarantees constant symbol free variables assigned computation transformer deterministic simplicity support operations change universe infinite universes easily model allocation deallocation individuals designated relation holds allocated individuals operational semantics free list table lists transformers define operational semantics kinds java-like statements constants denote target pointer variables sel binary relation models pointer field sel update-formulas relations constants unchanged values guard formulas statements access sel ensure null-dereference occurred case field traversal guard formula selects target field free variable tsel note program conditions simply modeled guard formulas integrity constraints restriction potential stores arise program finite set closed formulas called integrity constraints denoted assume meaning transformer maintains integrity constraints -valued structure case pointer fields require field total function pointer field null points null auxiliary information interesting integrity constraints occur result extra relations values derived relations formally auxiliary relation arity defined defining formula free variables results integrity constraint statement maintain invariant auxiliary information reduce complexity update formulas information maintained auxiliary relations enables compute abstract transformers introduced types auxiliary relations reachability program variable cyclicity interaction define monadicuniform update formula traversal edge monadic-uniform updates section restrict semantics statements allowed defined formulas syntactic class stores differ original store values change uniform sense defined begin defining atomic formulas essentially unary definition atomic formula monadic form k-ary relation constant symbols formula monadic atomic formulas appearing monadic ground formulas monadic formulas variables position monadic note single variable monadic define monadic update formulas restricted case update formulas tuple classified monadic formulas class existing relation copied definition monadic-uniform updates monadic-uniform formula syntactically equivalent default monadic formulas free variables restricted literal distinct variables monadic-uniform transformer transformer update formulas guard formula monadic uniform transformers table constructed monadic-uniform transformers monadic-uniform formulas disallow direct interaction non-monadic relations monadic-uniform monadicuniform equivalent captures interaction equality canonical abstraction section -valued logic conservatively represent sets stores formally define lattice static information lattice elements sets valued structures -valued structure similar -valued structure maps -valued truth functions range formal definition values definite values indefinite define partial information order truth values symbol denotes least-upper-bound operation respect definition tight embedding function surjective function relation arity tight embedding embedding function maps node node summary node call node concrete node summary nodes note summary node nodes mapped equals canonical embedding denoted embedding obtained unary relation symbols distinguish individuals concrete individuals mapped individual agree values unary relation symbols constant implied unary relation true embedding theorem formula definite structure embedded concrete structures canonical abstraction define set stores represented -valued structure definition -valued structure denotes set -valued structures represents structure feasible complexity checking feasibility structure satisfy integrity constraints interactions auxiliary relations core relations methodology developing computable transformers shape-analysis problem characterized triple class allowed structures initial abstraction 
set atomic operations running fig instance shape-analysis problem class allowed structures possibly cyclic singly-linked lists initial abstraction tracks pointed program variable representing program variables logical constants field maintaining binary relation refer embedding tight embedding term tight embedding emphasis reachability program variables unary relations form reachable program variable thenextfield cyclicity unary relation part cycle step developing computable transformers shape-analysis problem find monadic-uniform transformers operations required key step finding update formulas introduction additional auxiliary relations original relations maintained monadic-uniform main difficulty maintaining relations shape-analysis problem running maintenance reachability fortunately small modification make monadic-uniform dynqf update formulas transitive closure hesse introduce auxiliary binary relations relation maintains reflexive transitive closure relation existence path field relation cutn holds edge cycle enforced integrity constraints relation pcn called pathcut hesse maintains reflexive transitive closure un-cut edges relations create monadic-uniform transformers needed operations details imperative programs lead monadic-uniform transformers change information directly pointed variables difficulty relations reachability local update widespread change advantage specific structure graphs case build monadic-uniform transformer final step methodology develop algorithm checking feasibility abstract structure chosen vocabulary account integrity constraints including set allowed structures meaning auxiliary relations show check feasibility abstract structure arise shape-analysis problem defined compute candidate concrete structure abstract structure feasible iff concrete structure consistent satisfies integrity constraints original structure size candidate structure linear size original abstract structure check feasibility time polynomial size original abstract structure rest section describes compute transformers shape-analysis problem monadic-uniform transformers decidable feasibilitychecking problem proofs found define concept focused structure monadic-uniform transformer structures transformers transformer preserves embedding lem definition focused denoted focused expanded monadic atomic formulas update formula guard evaluate definite truth values constants interpreted mapped concrete nodes define canonical embedding function honors constants monadic atomic formulas appearing transformer defined analogously relation structures fig focused map concrete node mapped node list guard formula hold fig interpret satisfy guard formula node worth node list reasons structure focused node summary node constant mapped appears guard formula evaluates note fact structures fig focused update formulas evaluate definite values nodes relation indefinite tuples resulting structure fig structures focused transformer canonical embedding function referring feasibility focused structure nonemptiness lemma monadic-uniform transformer structure focused holds concrete structure embedding function properties hold guard guard unary relation node constant maps concrete node embedding preserved unary relations definite constants mapped non-summary nodes return updated structures cor entails monadic-uniform transformer transformer focused abstract structures corollary monadic-uniform transformer focused cor suggests compute abstract transformer abstract structure find set feasible focused structures represent concrete structures makes notion formal definition focus operation feasible structure returns finite set structures expand feasible focused sketch algorithm computes focus algorithm systematically replaces monadic formulas duplicating structures large bounded number structures candidate structure checked feasibility discarded infeasible algorithm compute focus fsorig expand current set structures monadic atomic formulas including constants node summary node remove replace split summary node iff structure tuple created relation add structures fsorig structure remove return focus yield double-exponential number structures maximum number individuals single structure exponential number predicates number structures exponential number nodes experience tvla blowup maximal number individuals rarely practice contrast tvla tight embedding suggests blowup occur practice working ways remedy situation moving non-tight embedding correctness alg main theorem theorem feasible automatically compute transformer flfl focus guard note feasibility check methodology guarantees obtain transformer respect force concrete structures adhere integrity constraints abstraction strong establish properties desire applications structures vocabulary feasibility acyclic sll pvar direct acyclic sll pvar colors direct cyclic sll pcn pvar direct cyclic sll rcx pvar colors direct dll pvar colors direct open ordered sll rcx dle pvar inordn dle inrordn dle open trees pvar direct trees pvar colors mso nuc pvar direct nuc pvar colors mso shared trees pvar open table summary shape-analysis problems feasibility-check status section describes applications methodology computing transformers shape-analysis problems problem class allowed structures relations maintain algorithm checking feasibility details found table summarizes shape-analysis problems section type feasibility checks problems show monadic-uniform transformers field manipulations sll dll stands singly doubly linked lists nuc undirected cycles pvar stands program variables description class structures meaning relation subsection note vocabulary require feasibility-checking algorithm dong show update reachability general acyclic graph first-order logic formulas monadic-uniform unclear make monadic-uniform relation update formula guard null null null guard null null null default guard null null default table monadic-uniform transformers acyclic singly-linked lists direct means direct algorithm check feasibility abstract structure mso means reduce feasibility check satisfiability check mso formula trees open means working checking feasibility problem checking feasibility decidable problems singly-linked lists class allowed structures examine acyclic singly linked lists vocabulary includes constants represent program variables functional binary relation represents field unary relation program variable represents reachability unary reachability binary relation path represents reachability elements guard formulas detect null dereferences formation garbage cycles monadic-uniform update formulas easily written needed operations table lists transformers field-manipulating operations update formulas unchanged relations omitted update formulas reachability follow traversal field free variable guard formula capture target field similarly removal edge check feasibility focused abstract structure build single candidate concrete structure original structure feasible iff result applying candidate structure candidate structure satisfies integrity constraints algorithm checking feasibility replace summary node concrete nodes connected edge incoming edges summary node concrete node outgoing edges summary nodes start node edge abstract structure translated single edge concrete structure simply compute structure return true equals original structure satisfies integrity constraints total function cyclicity handle cyclicity ideas quantifier-free update reachability singly-linked lists update based addition binary relation called pathcut auxiliary relation cycle call edge added cycle edge closed cycle cut edge pathcut reachability minus cut edges cycle broken cut edge readded pathcut update formula suggested removal edge monadic-uniform fortunately easily rewrite formula monadicuniform analyze programs manipulate cyclic singly-linked lists vocabulary similar acyclic singly-linked lists additional relations needed updates monadic-uniform ease feasibility checking cutn binary relation representing cut edges pcn binary relation representing pathcut rcx unary relation indicating reachable program variable pcn unary relation indicating cycle resulting abstraction similar distinctions makes cutn needed update feasibility check recover cut edges pcn remove cutn compute transformer dynqf updates basis monadic-uniform update formulas feasibility checking ideas acyclic lists support cut edges trees analyze trees monadic-uniform transformers 
vocabulary constants represent program variables functional binary relations represent left fields constants program variable target left fields binary relation represents reachability existence path elements fields unary relation sel program variable represents reachability sel field guard formulas verify operation maintains treeness key updating reachability case observation nodes path paths removed removing edge added edge added check feasibility reduction satisfiability mso formula similar trees check directly lower complexity building single candidate concrete structure similar singly-linked lists undirected cycles introduced class structures underlying undirected graphs acyclic undirected cycles show abstraction handling class structures algorithms computing abstract transformers abstraction structures undirected cycles acyclic interesting property pair program variables meet single shared node reachable variables nodes pointing node reachable variables nodes path define abstraction similar apply methodology vocabulary trees extended constants pair distinct program variables add unique node meet create sharing null node exists guard formulas detect formation undirected cycles maintain unary reachability constants write monadic-uniform guard formula transitive closure detects formation undirected cycles check feasibility structures methods similar trees shared trees shared trees graphs nodes possibly empty path visualize shared trees node graph tree shared trees arise applicative data structures operating systems databases performing shadow paging vocabulary case trees updating reachability class structures trees nodes path detecting shared-trees property violated guard formula adding edge formula monadic-uniform quantifier-free working checking feasibility shared trees vocabulary decidable shared trees unbounded tree width direct translation satisfiability mso formula yield decidability uninterpreted unary relations sets boolean fields added shape-analysis problems introducing uninterpreted unary relations colors addition removal element set query existence element set selection arbitrary element set additional update formulas needed trivial selection guard formula free variable difficulty checking feasibility adding colors vocabulary contrast original feasibility-checking problem fact colors make distinctions original abstraction binary relations now-separate nodes account checking feasibility singly-linked lists checking feasibility ignoring colors reducing feasibility segment list directed chinese postman problem solved polynomial time checking feasibility trees structures undirected cycles reduction mso cases relations required analyzing doubly linked lists ordered lists maintained monadic-uniform transformers general feasibility check structure vocabulary doubly-linked lists check feasibility structures arising programs manipulate doubly-linked lists programs tvla structures small perturbations well-formed doubly linked lists related work specialized shape analyzers developing specialized shape analysis commonly data structures active line research encouraged fact express above-cited work methodology methodology supports shared trees addition arbitrary colors scope existing methods noted current algorithms costly ad-hoc algorithm runs time essentially linear output hard beat future plan reduce costs creating transformers focusing parts developing efficient focus algorithms iii incrementality reduce cost feasibility checks tvla system results paper inspired tvla system tvla system require update formulas monadic-uniform arbitrary classes graphs includes algorithm automatically generating update formulae auxiliary information fully integrated system describes application machinery abstraction similar cyclic singly-linked lists tvla system guarantee transformers system issue runtime exception cases operation lead infinite number structures paper build specialized shape analyses handle cases tvla cases compute abstract transformer future combine methods method generate monadic-uniform update formulas cases focus operation tvla differs paper key aspects including requires user formulas focus yield infinite number structures contrast paper show monadic-uniform update computable set focused structures lead transformers results shed light cases updates tvla precise procedures libraries paper focused handling programs procedures libraries handle procedures libraries tabulation input output relations abstract values handle specific libraries allowing monadic-uniform specifications auxiliary relations describe abstraction effect client module employing theorem provers decision procedures theorem provers decision procedures employed prove properties programs manipulate heap fully automate process generating transformers results dynamic descriptive complexity methodology paper improve aforementioned results ways instance contrast method lahiri qadeer requires user intervention method handles programs manipulate cyclic lists totally automatic essence introduction transformers monadic-uniform update formulas replace characterization mutations data structures characterization terms invariants two-vocabulary structures describe state transition natural express mutations standard one-vocabulary structures express invariants cases switch two-vocabulary one-vocabulary structures results order-ofmagnitude complexity improvement cases decision procedures exist two-vocabulary structures reduction onevocabulary structures restores possibility employing decision procedures two-vocabulary structures easy monadic second-order logic undecidable linked lists intuitive reason functions unary relations encode grid monadic second-order logic trees decidable perform feasibility checks one-vocabulary structures needed method employed rakamaric gave complete decision procedure checking feasibility one-vocabulary abstract state left open question handle transformers most-precise methodology solves problem dynqf updates singly linked lists hesse recast problematic transformers one-vocabulary formulas transformer computable explained cousot cousot systematic design program analysis frameworks popl immerman descriptive complexity springer-verlag sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst loginov reps sagiv abstraction refinement inductive learning proc computer-aided verif dong incremental decremental evaluation transitive closure first-order queries inf comput hesse dynamic computational complexity phd thesis department computer science umass amherst rakamaric bingham logic decision procedure predicate abstraction heap-manipulating programs tech rep tr- dept comp sci univ canada lev-ami sagiv immerman reps constructing specialized shape analyses uniform change technical report tr- tel-aviv univ http tau tla papers tr- pdf manevich yahav ramalingam sagiv predicate abstraction canonical abstraction singly-linked lists vmcai yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tacas lev-ami immerman sagiv abstraction shape analysis fast precise transformers cav myers efficient applicative data types popl okasaki purely functional data structures cambridge press brown persistent object stores univ andrews edmonds johnson matching euler tours chinese postman mathematical programming hendren parallelizing programs recursive data structures phd thesis cornell univ ithaca distefano hearn yang local shape analysis based separation logic tacas reps sagiv loginov finite differencing logical formulas static analysis esop loginov refinement-based program verification three-valued-logic analysis phd thesis comp sci dept univ wisconsin madison cousot cousot static determination dynamic properties recursive procedures formal descriptions programming concepts rinetzky sagiv yahav interprocedural shape analysis cutpoint-free programs sas nelson verifying reachability invariants linked structures popl ller schwartzbach pointer assertion logic engine pldi lahiri qadeer verifying properties well-founded linked lists popl lev-ami immerman reps sagiv srivastava yorsh simulating reachability first-order logic applications verification linked data structures cade ball rajamani automatically validating temporal safety properties interfaces spin henzinger jhala majumdar sutre software verification blast spin reps sagiv yorsh symbolic implementation transformer proc vmcai rabin decidability second-order theories automata infinite trees trans amer math soc 
source nodes edges source rchd dst recovery low-level code thomas reps gogul balakrishnan junghee lim wisconsin-madison cud ctd cqcvd cvd cyd cvcwctctcvbscrd badbcxd crbactcsd abstract goal work create tools cons analyst cons understand cons workings cons cots cons components plugins cons mobile code dlls memory snapshots worms virusinfected code paper describes static analysis techniques recover intermediate representations similar created program written high-level language introduction past years considerable amount research activity develop static-analysis tools find bugs security vulnerabilities effort static-analysis source code issue analyzing executables largely security context unfortunate source-code analysis fail detect vulnerabilities due wysinwyx phenomenon execute mismatch programmer intends executed processor source-code fragment login program mismatch ctd ctd cpd dbd csb cod bcb ctd cud ctctb cpd dbd csb login program temporarily stores user password clear text dynamically allocated buffer pointed pointer variable cpd dbd minimize lifetime password sensitive information code fragment shown zeroes-out buffer pointed cpd dbd returning heap compiler performs useless-code elimination reason program values written call ctd ctd call ctd ctd removed leaving sensitive information exposed heap hypothetical similar vulnerability discovered windows security push vulnerability invisible source code detected examining low-level code emitted optimizing compiler portions paper appeared research supported part nsf grants ccfand ccrand onr contracts -cu permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee pepm january charleston south carolina usa copyright cad acm wysinwyx phenomenon restricted presence absence procedure calls contrary pervasive security vulnerabilities exist myriad platformspecific details due features idiosyncrasies compiler optimizer include memory-layout details offsets variables run-time stack activation records ars padding fields struct register usage iii execution order optimizations artifacts compiler bugs information hidden tools work intermediate representations irs built directly source code number reasons analyses based source code provide level detail checking kinds properties source-level tools applicable source limits usefulness security applications analyzing code open-source projects analyses based source code typically make unchecked assumptions program ansi-c compliant means analysis account behaviors allowed compiler arithmetic performed pointers subsequently indirect function calls pointers move ends arrays subsequently dereferenced programs typically make extensive libraries including dynamically linked libraries dlls source-code form typically source-level analyses performed code stubs model effects library calls hand-crafted errors analysis return incorrect results programs modified subsequent compilation perform optimizations insert instrumentation code modified insert malicious code modifications visible tools analyze source source code written language complicates life designers tools analyze source code multiple languages supported quirks source code primarily written high-level language inlined assembly code selected places source-level analysis tools typically skip inlined assembly code push analysis sites inlined assembly code source code substantial amount information hidden analyses start source code bugs security vulnerabilities malicious behavior invisible tools source-level analysis tool strives greater fidelity program executed duplicate choices made compiler optimizer approach doomed failure long-term goal work develop bug-detection security-vulnerability analyses work executables advantage approach executable actual instructions executed information reveals actual behavior arises program execution access information crucial instance security exploits depend platform-specific features structure activation records vulnerabilities escape notice tool information adjacency relationships variables apply techniques encounters challenging program-analysis problem perspective compiler community problem recovery recover intermediate representations executable similar started source code perspective modelchecking community problem model extraction extract suitable model executable goal advance state art recovering executables irs similar started source code expose platform-specific details discussed specifically interested recovering irs represent information control-flow graphs cfgs indirect jumps resolved call graph indirect calls resolved information program variables values pointer variables sets killed possibly-killed variables cfg node data dependences including dependences instructions involve memory accesses type information base types pointer types structs irs hand position leverage substantial body work analysis recovery numerous obstacles overcome situations debugging information debugging information present relied program potentially malicious reason designed ir-recovery techniques rely debugging information present paper term executable means stripped executable current implementation recovery incorporated tool called codesurfer works executables algorithms language-independent debugging information absent executable data objects easily identifiable instance data dependence statement statement transmitted write read accesses variable performing sourcecode analysis programmer-defined variables provide convenient compartments tracking data manipulations dependence analyzer show defines dc-def-free path executables memory accessed directly absolute address indirectly address expression form base index scale offset base index registers scale offset integer constants clear expressions natural compartments analysis executables intrinsic entities analysis analogous source-level variables crucial step recovery identify variable-like entities past work recovery executables relied simple techniques identifying variable-like entities instance idapro commercial disassembly toolkit recovers variables based statically known-addresses stack-frame offsets approach limitations instance generally recovers coarse information arrays codesurfer build sdg browse executable connector vsa initial estimate code data procedures call sites malloc sites ida pro build cfgs disassemble executable fleshed-out cfgs fleshed-out call graph killed may-killed variables cfg nodes points-to sets reports violations code rewriter decompiler path inspector userscripts wpds codesurfer asi ara figure organization codesurfer companion tools approach provide information fields heap-allocated objects crucial understanding programs manipulate heap seedc main challenges static analysis low-level code recover information memory-access operations set addresses accessed operation difficult memory operations explicit memory addresses instruction easy indirect addressing address expressions difficult arithmetic addresses pervasive instance local variable loaded slot activation record address arithmetic performed notion type hardware level address values intrinsically integer values memory accesses aligned word-sized address values potentially cobbled misaligned reads writes research static analysis low-level code developed techniques cope issues tool set developed analyzing executables builds recent advances static analysis program executables techniques software model checking dataflow analysis main components tool set codesurfer wpds path inspector codesurfer recovers irs executable similar irs source-code-analysis tools create respects irs codesurfer builds precise instance code dlls imported irs codesurfer builds irs sourcecode-analysis tools create typically require hand-written stubs library routines codesurfer api irs wpds library answering generalized reachability queries weighted pushdown systems wpdss library provide mechanism defining solving model-checking dataflow-analysis problems extend codesurfer analysis capabilities codesurfer api extract wpds model executable run wpds model path inspector software model checker built top codesurfer wpds supports safety queries program control configurations addition writing scripts traverse irs codesurfer recovers tool set extended capabilities decompilation code rewriting fig shows components fit codesurfer makes idapro 
disassembly toolkit grammatech codesurfer system toolkit originally developed building program-analysis inspection tools analyze source code components glued piece called connector static analyses aggregatestructure identification asi affine-relation analysis ara value-set analysis vsa recover information contents memory locations manipulated executable material codesurfer presented previous papers present paper describes enhancements abstract domains abstract arithmetic developed remainder paper organized overview main analyses codesurfer variable type discovery asi vsa ara describes work enhance vsa discusses related work overview codesurfer analyses codesurfer great deal ambitious sophisticated disassemblers idapro previous work analyzing executables dealt memory accesses conservatively generally register assigned memory assumed research data-dependence analysis executables variety shortcomings analysis single-procedures handles memory locations flowinsensitive manner account possibility called procedures corrupting memory locations tracked address issues brought bear variety static-analysis techniques technical level work addresses problem stripped executable debugging information removed identify procedures data objects types libraries instruction libraries interprocedural calling context machine register variable statically compute accurate over-approximation set values executes constraint debugging information unavailable complicated task creating codesurfer results static-analysis phases provide substitute information allowed create tool debugging information absent untrusted words order scope ambition capabilities assumptions underlying codesurfer assume executable analyzed standard compilation model executable procedures ars global data region heap virtual functions dlls maintains runtime stack global variable resides fixed offset memory local variable procedure resides fixed offset ars actual parameters pushed stack caller formal parameters reside fixed offsets ars program instructions occupy fixed area memory self-modifying analysis assumptions checked violations detected error report issued analysis proceeds generally making optimistic choice instance analysis finds return address modified procedure reports potential violation proceeds modifying control flow program analyst tool determine error report false positive valid major assumption make idapro disassemble program build adequate collection preliminary irs cfgs created idapro incomplete due indirect jumps call-graph created idapro incomplete due indirect calls incomplete irs trigger error reports cfgs call-graph fleshed information recovered memory-access analysis relationship memory-access analysis preliminary irs created idapro similar relationship points-to-analysis algorithm compiler preliminary irs created compiler front end cases preliminary irs fleshed results static analysis analyzer care program compiled high-level language hand-written assembly code fact pieces program output compiler multiple compilers high-level languages hand-written assembly code easiest talk information tool capable recovering terms kinds features high-level languages support capable recovering information programs global variables local variables pointers structures arrays heap-allocated storage pointer arithmetic indirect jumps recursive procedures virtual functions indirect calls function pointers present run-time code generation self-modifying code compiler transformations confuse analysis long conform aforementioned compilation model analysis capable handling tail recursion sees loop results tail-call optimization local variables accessed ctd -relative offsets pascalstyle displays applications custom allocators user identify allocators optimizations make task memory-access analysis difficult unoptimized programs generally memory accesses optimized programs optimizations typically arrange computation critical data registers memory operations registers easier analyze operations access memory register target pointer variable type discovery major stumbling blocks analysis executables difficulty recovering information variables types aggregates structures arrays variable type-discovery phase codesurfer recovers information variables allocated globally locally run-time stack dynamically heap iterative strategy round analysis consisting asi ara vsa notion program variables types refined memory model abstraction concrete runtime address space parts memory-regions concrete semantics ars procedures heap memory global data part address space purposes analysis separate address space set disjoint areas referred memory-regions memory-region represents group locations similar runtime properties runtime locations belong ars procedure belong memory-region program kinds regions global-regions represent memory locations hold global data ar-regions represent locations ars procedures malloc-regions represent locations allocated malloc sites a-locs part memory model set proxies variables inferred memory-region objects called a-locs stands abstract locations addition a-locs identified memory-region registers represent additional class a-locs initially codesurfer set variables a-locs obtained idapro idapro limited information time applies variablediscovery heuristics statically memory addresses stack offsets limited generally leads coarse-grained approximation program variables seedc round vsa completes value-sets a-locs instruction provide identify overapproximation memory accesses performed instruction information refine current set a-locs running variant asi algorithm identifies commonalities accesses parts aggregate data seedc limitations idapro a-loc identification algorithm version work idapro approach recovering variables instantiate memory model a-locs idapro approach recovering variables based observations layout memory compile time compiler decides priori locations global variables local variables direct accesses program variables performed absolute addresses globals offsets relative frame pointer stack pointer locals absolute addresses offsets generally starting addresses program variables version work a-loc consisted set locations consecutive statically addresses stack-frame offsets approach limitations addresses offsets occur explicitly program considered approach identify variables accessed indirectly instance idapro identify fields heap-allocated data objects accessed memory-access expressions lie class considered fields dynamically allocated objects accessed terms offsets relative base address object idapro idapro trouble locals globals idapro discover fields elements array accessed relative ctcpdc cjctcpdccl cjctcpdcb bgcl accessed relative stack pointer ctd frame pointer ctcqd recover fields set values ctcpdc hold determined analysis explicitly addresses stack-frame offsets idapro account memory-access operations executable produce too-coarse set locs affect precision vsa suppose procedure program bg-byte local variables laid suppose compiler generates explicit accesses generates indirect accesses terms addresses case idapro account explicit accesses identifies -byte a-locs bdbe spans bfbg spans -bit machine value-sets represent addresses numeric values bits vsa represent addresses numeric values bdbe bfbg hold reads writes parts bdbe bfbg treated conservatively vsa report bdbe bfbg hold address numeric program points hand bg-byte a-locs vsa produce precise non-bq value-sets limitation relying idapro variable-identification algorithm a-locs recovered expressive idapro a-locs capture information repeating structure arrays array identified contiguous block data idapro identify fields heap-allocated objects information crucial tracking contents heap a-locs idapro a-loc represent contiguous sequence memory locations memory-region internal substructure represent non-contiguous memory locations locations instances specific field array structures lack expressiveness idapro a-locs affect precision clients vsa dependence analyzer codesurfer sets killed possibly-killed a-locs program point generated results vsa build system dependence graph executable idapro a-locs coarse-grained representation killed possibly-killed memory locations lead extra edges dependence graph aggregate structure identification asi asi unification-based flow-insensitive algorithm identify structure aggregates program asi originally developed analysis cobol programs context asi ignores type declarations aggregates considers aggregate sequence bytes length aggregate broken smaller parts depending accessed program smaller parts referred atoms hope apply 
asi executable treating memory-region aggregate applying asi vsa results requirements applying asi extract data-access constraints program asi applied programs written language cobol data-access patterns apparent syntax constructs consideration executables data-access patterns readily apparent instance memory operand cjctcpdccl represent access single variable elements array fortunately value-sets recovered vsa furnish information generate asi data-access constraints information values a-locs hold terms range stride information seedc information pointsto relationships extent repeating structure memory-access operation extension asi exploits information made vsa create data structures record structure memory-region relationships memory-regions atoms correspond newly discovered a-locs generally leads accurate set a-locs initial set a-locs discovered idapro instance simple loop implemented source code cxd cpcjbdbcclb cxbn cud bcbn bdbcbn cxb cpcjcxcl cxbn executable idapro determine variables size bytes size bgbc bytes provide information substructure bgbc-byte variable contrast addition bg-byte cons cons cons cons cons cons variable asi correctly identify bgbc bytes array ten bg-byte quantities current version connector refinement loop performs repeated phases asi ara vsa fig round asi performed variables discovered idapro subsequent round asi refine previous set a-locs refined set a-locs analyze program round vsa number iterations controlled command-line parameter round asi a-locs hand permit vsa start analyze contents dynamically allocated objects memory locations allocated malloc vsa considers malloc site memory-region consisting objects allocated memory-region serves representative base addresses objects lets asi handle offset object base address similar handles stack-frame offset net result round asi starts identify finegrained structure dynamically allocated objects object fields discovered a-locs round vsa discover over-approximation contents value-set analysis vsa goal vsa determine program point overapproximation set numeric values addresses valueset register memory location a-loc holds information computed vsa augment call graph control-flow graphs account indirect jumps indirect function calls vsa combined numeric pointer-analysis algorithm vsa related pointer-analysis algorithms developed programs written high-level languages determine over-approximation set variables addresses pointer variable hold program point vsa determines over-approximation set addresses data object hold time vsa similar range analysis numeric static-analysis algorithms over-approximate integer values variable hold program point vsa determines over-approximation set integer values data object hold insights shaped design vsa non-aligned access memory access address aligned bg-byte word boundary spans parts words forge address parts addresses important vsa discover information alignments strides memory accesses indirect-addressing operations possibly non-aligned accesses discussion indc prevent loops traverse arrays appearing corrupt stack analysis relational information values a-locs assigned loop related values a-locs loop branch condition seedc desirable vsa track integer-valued addressvalued quantities simultaneously crucial analyzing executables implementation precise abstraction dynamically allocated memory footnote integers addresses indistinguishable execution time compilers address arithmetic indirect addressing implement features pointer arithmetic pointer dereferencing array indexing accessing structure fields information integer values lead improved tracking address-valued quantities information address values lead improved tracking integervalued quantities vsa produces information precise obtained conventional numeric analyses compilers including constant propagation range analysis integercongruence analysis time vsa analog pointer analysis suitable executables affine-relation analysis ara vsa relational track relationships hold registers memory locations interpreting conditional branches specifically implement loops important relationships separate affine-relation analysis ara performed recover affine relations hold conditional branch points affine relations vsa interpreting conditional branches ara recovers affine relations involve registers ara implements affine-relation domain based arithmetic modulo bebfbe accounts arithmetic overflow call instruction subset registers saved stack caller callee restored return registers called caller-save callee-save registers preserve values call ara treats caller-save callee-save registers local variables calling procedure values caller-save callee-save registers call set values call values registers set values exit node callee enhancements value-set analysis vsa combined numeric-analysis pointer-analysis algorithm determines program point overapproximation set numeric values addresses a-loc holds basic abstract domains vsa value-set domain seedc safe approximation set concrete addresses numeric values value-set map memory-regions strided intervals seedc associates memory-region strided interval represents set offsets section describe strided intervals value-sets sketch define abstract transformers instructions notational conventions typefaces make distinctions integers mathematical expressions written ordinary mathematical notation bebfbd bebfbd variables hold integers italics bounded integers unsigned numbers signed s-complement numbers variables hold quantities bold bfbd bfbd fragments code courier bfbd bfbd cxcub cqb cubmbmbmcv ddbn appears typefaces convention meaning appropriately refer program variable signed s-complement unsigned integer names denote strided intervals written bold cjdccl denote congruence class mod defined cjdccl bpcudc cxa cycxbecicv note cjdccl bpcudccv strided-interval arithmetic cz-bit strided interval triple cjd cqbnd cqcl thata becz akd cqak cqakbe meaning strided interval defined definition meaning strided interval cz-bit strided interval cjd cqbnd cqcl represents set integers adb cjd cqbnd cqclb bpcucxbecja bnbe bdclcyd cqakcxakd cqbncxbecjd cqcl cvbm note strided interval form bccjcpbncpcl represents singleton setcucpcv noted assume working bfbe-bit strided intervals strided interval cjd cqbnd cqcl called stride cjd cqbnd cqcl called interval stride unsigned bounds signed stride unsigned two-element set bfbebit numbers including sets ascua bebfbdbnbebfbda bdcv denoted instance cua bebfbdbnbebfbda bdcvis represented strided interval bebfbea bdb cja bebfbdbnbebfbda bdcl defined sets numbers represented strided interval instance adb bgcjbgbnbdbgclb cubgbnbkbnbdbecv adb bgcjbgbnbdbeclb loss generality assume strided intervals reduced upper bounds tight upper bound equals lower bound stride bgcjbgbnbdbecl bccjbdbebnbdbecl reduced strided intervals bgcjbgbnbdbgcl bgcjbdbebnbdbecl remainder subsection describes abstract arithmetic bit-level operations strided intervals abstract interpretation definition soundness criterion opsi opsi adb ajcucp cqcycpbeadb cqbeadb sound algorithms performing arithmetic bit-level operations intervals strided intervals stride book warren provided starting point operations define strided intervals extend warren operations strides account summarize warren interval operations describe sound stride obtained operation opsi becub sibndfsi bndf bnb bndf bncy bnao bnb addition suppose bounds complement values bfbe-bit arithmetic result interval cjcp crbncq cscl bound calculations overflow positive negative direction warren method shown tab calculate bound case tab case bound calculation overflows cases tab result bounded cjcp crbncq cscl bound calculations overflow identify cases case bounds imposed extreme negative positive numbers lines fig code appears lines fig negative case holds negative case holds reduce notation rely context typeface conversion denotes conversion signed s-complement unsigned stride denotes unsigned interval bound denotes signed s-complement bdb boa bfbd bncq boa bfbd crakdc ddakcq beb boa bfbd bncq csala bfbd bfbd akdc ddakbe bfbd bfb bfbd akcp bfbd bncq bfbd crakdc ddakcq bgb bfbd akcp bfbd bncq csalbe bfbd bfbd akdc ddakbe bfbd bhb cralbe bfbd bncq csalbe bfbd crakdc ddakcq 
table cases bounding result adding signed s-complement numbers cjbdcl dad cxcs cpcscscbc cxd cpb cxd cqb cxcvd ctcs bdb cjbecl cxd crb cxd csb cxcvd ctcs beb cjbfcl cxd cqd csb cxd cqd csb cxcvd ctcsb cjbgcl cqd crbn cjbhcl cqd csbn cjbicl cxd aod cqd aob aod cqd csb cjbjcl cxd crb aob cqd csb aocq aocs cqd csb cjbkcl cxcub bcb bbbb crcpd beb crcpd bgb cjblcl bdbn cjbdbccl cqd bcdcbkbcbcbcbcbcbcbcbn cjbdbdcl cqd bcdcbjbybybybybybybybn cjbdbecl cjbdbfcl ctd cvcrcsb bdb beb cjbdbgcl figure implementation abstract addition strided intervals proof thm make observation observation case tab sums yield values high bfbe compared similarly case sums yield values low bebfbe fig shows procedure ideas compute bdcjcpbncqclb becjcrbncscl takes strides account cvcrcs greatest common divisor operation find sound stride result theorem soundness adb ajcucp cqcycpbeadb cqbeadb proof soundness interval arguments show stride computed procedure cpcscscbc fig sound lines fig correspond cases answer entire interval cja bebfbdbnbebfbda bdcl stride sound situations cvcrcs find stride cjd bnd adb cjd bnd adb cases gcdb bnd cjd bnd clbm bpd bpd cud cud bnbm bmbmbn cud cud bnbm bmbmbn bpcud bnbmbmbmbnd cxa cya bnbmbmbmbnd convention gcd bcbn cpb gcdb cpbnbcb gcdb bcbnbcb assumption work reduced strided intervals strided interval cjd cqbnd cqcl bibp implies divides evenly cqb cjbdcl cxcvd ctcs cxd cab cxcvd ctcs cpb cxcvd ctcs cqb cjbecl cxcvd ctcs crb cxcvd ctcs csb cjbfcl cxcvd ctcs ctd cjbgcl bcdcbkbcbcbcbcbcbcbcbn cjbhcl dbcwcxd ctb axbp bcb cjbicl cxcub aocp cjbjcl ctd cjbkcl cxcub ctd bobp cqb cjblcl ctd cjbdbccl cqd ctcpczbn cjbdbdcl cjbdbecl cjbdbfcl ctd cxcub aocr cjbdbgcl ctd cjbdbhcl cxcub ctd bobp csb cjbdbicl ctd cjbdbjcl cqd ctcpczbn cjbdbkcl cjbdblcl cjbebccl bqbq bdbn cjbebdcl cjbebecl ctd crbn cjbebfcl figure implementation minor gcdb bnd show divides evenly difference arbitrary element lower-bound element cxa cya bcakcxakcq bcakcyakcq difference cta nonnegative equals cxa cya equals cxa cya divisible obs compare values interval cja bfbd bnbe bfbd bdcl low bfbe case tab interval cja bfbd bnbe bfbd bdcl case tab high bfbe case tab bebfbd ctbc bebfbd adjusted multiple bebfbe similarly leta bebfbd bebfbda adjusted multiple bfbe note obs minimum element elements similarly adjusted argument cta divisible carries case argument ctbc cjlbcl adb ajsi shown unary minus suppose bounds complement aka aka numbera bebfbd representable -bit s-complement number bebfbd bebfbd bebfbd means necessarily havea ddaka note thata s-complement expression cases aka aka assumption work reduced strided intervals cjcrbncscl upper bound achievable retain stride dfsi cjcrbncsclb cjcrbncsclb bccja bfbd bna bfbd bpa bfbd cja csbna crcl crbibpa bfbd bdcja bfbd bnbe bfbd bdcl subtraction dfsi increment decrement dfdfsi dfsi operations strided intervals implement arithmetic operations subtraction dfsi increment decrement dfdf dcdf dcb ddb dcb bccjbdbnbdcl dcb bccja bdbna bdcl cjbdcl cxcvd ctcs cpdcc cab cxcvd ctcs cpb cxcvd ctcs cqb cjbecl cxcvd ctcs crb cxcvd ctcs csb cjbfcl cxcvd ctcs ctd cjbgcl bcdcbkbcbcbcbcbcbcbcbn cjbhcl dbcwcxd ctb axbp bcb cjbicl cxcub cjbjcl ctd bdb cjbkcl cxcub ctd bqbp cpb cjblcl ctd cjbdbccl cqd ctcpczbn cjbdbdcl cjbdbecl ctd bdb cjbdbfcl cxcub ctd bqbp crb cjbdbgcl ctd cjbdbhcl cqd ctcpczbn cjbdbicl cjbdbjcl cjbdbkcl bqbq bdbn cjbdblcl cjbebccl ctd csbn cjbebdcl figure implementation maxor bitwise cysi warren develop algorithm forcysi bitwise-or strided intervals examining bound bitwise-or unsigned values subroutine algorithm forcysi suppose bounds unsigned values algorithms warren book figs provide bounds minimum maximum values dccydd attain warren argues minimum dccydd found scanning left-to-right finding leftmost position changed bits set yielding number cpbc cpbcakcq cpbccycrb cpcycrb changed bits set yielding number crbc crbcakcs cpcycrbcb cpcycrb implemented function cxd fig instance suppose bcbcbcbcbdbcbd cpakdcakcq bcbcbcbdbcbcbd bcbcbdbcbcbdbd crakddakcs bcbdbcbdbcbcbdbm reject bcbcbdbcbcbcbc bcbcbdbcbcbcbc biak bcbcbcbdbcbcbd find bcbcbdbcbdbcbc meets condition cpcycr bcbcbdbcbdbcbd bcbcbdbcbdbdbd cpcycrb note warren algorithm relies assumption working intervals strides instance select contribution lower bound crbc bcbcbdbcbdbcbc bcbcbdbcbcbdbd worry stride repeatedly added miss crbc algorithm find maximum dccydd fig similar flavor tab shows method warren finding bounds bitwise-or signed s-complement values cpakdcakcq crakddakcs method calls procedures figs find bounds bitwise-or unsigned values function fig counts number trailing zeroes argument line fig set mask identifies trailing zeroes set binary number bfbe equals number trailing zeroes signed cxd signed cpdcc cxd cab cpbncqbncrbncsb cpdcc cab cpbncqbncrbncsb albc albc albc cxd cab cpbncqbncrbncsb cpdcc cab cpbncqbncrbncsb albc albc albc cxd cpbncrb cpdcc cab bcbncqbnbcbncsb albc albc albc cxd cab cpdcc cab bcbncqbncrbncsb albc albc cxd cab cpbncqbncrbncsb cpdcc cab cpbncqbncrbncsb albc albc albc cxd cab cpdcc cab cpbncqbnbcbncsb albc albc albc albc cxd cab cpbncqbncrbncsb cpdcc cab cpbncqbncrbncsb table signed cxd cab cpbncqbncrbncsb cpdcc cab cpbncqbncrbncsb warren method unsigned cxd cpdcc find bounds bitwise-or signed s-complement values cpakdcakcq crakddakcs cpakcq crakcs cases shown exhaustive cjbdcl cxd deb cxcvd ctcs dcb cjbecl cxd cjbfcl cxd dcb bdb cjbgcl bcbn cjbhcl dbcwcxd ctb axbp bcb cjbicl bdbn cjbjcl bqbq bdbn cjbkcl cjblcl ctd cjbdbccl figure counting trailing trailing counted while-loop lines turn algorithm bitwise-or strided intervals cysi suppose perform cjcpbncqclcy cjcrbncscl illustrated topmost set shown fig elements adb cjcpbncqclb share ntzb low-order bits low-order bits stride repeated addition affect low-order bits similarly elements adb cjcrbncsclb share ntzb low-order bits illustrated set shown fig values answer strided interval share low-order bits minb bnd bobo stride answer shared low-order bits calculated cpb cpd czb cyb crb cpd czb cpd bobo bfbea high-order bits handled masking loworder bits applying method tab finding bounds bitwise-or signed s-complement values compute cjcpbncqclcy cjcrbncscl perform steps set minb ntzb ntzb set calculate shared low-order bits cpb cpd czb cyb crb cpd czb cpd bobo method tab bound cydd cpb aod cpd czb cqb aod cpd czb crb aod cpd czb csb aod cpd czb call bounds return strided interval cjb cqb aod cpd czb cyd bnb cqb aod cpd czb cyd bitwise aosi xor cmsi suppose bounds cpakdcakcq bound result applyingaotodc isaocqakaodcakaocp similarly strided intervals cjd cqbnd cqclb cjaod cqbnaod cqclbm adb cjcpbncqclb bpcucpbncp bncp bed bnbmbmbmbncqcv adb cjcrbncsclb bpcucrbncr bncr bed bnbmbmbmbncscv ntzb ntzb minb bnd min min min min min min min min min mask mask mask min figure justification minb ntzb ntzb stride calculation abstract bitwise-or 
operation cysi values answer strided interval share low-order bits eqn relies assumption strided intervals reduced assumption guarantees beadb cjd cqbnd cqclb aod element adb cjd cqbnd cqclb morgan laws fact thataosib aosib cjd cqbnd cqclb cjd cqbnd cqcl computed bpao bpao strided-interval arithmetic radices arithmetic operation radix lead result operation performed radix radices powers effects fixed applying mask result values flags condition codes depend radix operation performed suppose bdbi-bit register cpdc bcdcabab abstract transformer bdbi-bit addition operation btbwbw cpdcb account effect carry flag arithmetic bit-level instructions instruction set affect subset flags condition codes stored processor bxbyc btbzcb register bvc instruction subtracts operand operand sets bxbyc btbzcb register results values bits bxbyc btbzcb instructions crcr bvc cecrcr cbbxcccrcr families instructions direct flow control program false true false false false false false true false true cycy false true false false true true true true true true xor false true false false true true true false false true true false join false true false false true true figure operations bool set modeled bdbi-bit addition bfbe-bit addition bcdcbcbcbcbcabab bcdcbcbcbcbcbcbcbcbd masked lower bdbi bits bfbe-bit addition set carry results bfbe-bit operation make convenient define abstract transformers track flag values operations strided-interval arithmetic compute abstract condition-code values over-approximate values computed cpu including carry sign parity auxiliary carry overflow strided-interval operation opsi returns descriptor condition-code values result applying concrete operation concretizations arguments opsi represent multiple boolean values abstract domain bool bool bpcufalsebn maybebn truecv addition booleans false true bool means false true fig shows tables bool operations cycy xor andd join account effects illustrated stridedinterval arithmetic implemented template parameterized number bits zero-extend sign-extend operations provided convert bk-bit strided intervals bdbi-bit bfbebit strided intervals bdbi-bit strided intervals bfbe-bit strided intervals value-set arithmetic vsa set addresses numeric values represented value-set map memory-regions strided intervals value-set associates memory-region abstract represents set offsets proc denote set memory-regions procedures program allocmemrgn denote set memory-regions heap-allocation sites global denote memory-region global data area work basic domains memrgn valueset memrgnaxstridedinterval section give sketch abstract value-set arithmetic codesurfer implementation augmented abstract domain overcomes imprecisions arise due perform weak updates accumulate information join fields summary malloc-regions augmented domain analysis establish definite link heap-allocated object class virtual functions virtual-function table brevity write value-sets tuples follow convention component value-set refers set addresses numbers global andbndenotes empty set instance tuple represents set numbers cubcbnbdbnbmbmbmbnblcv tuple bnbnbgcja bgbcbna bgclbnbnbnbmbmbmb represents set offsetscua bgbcbna bfbibnbmbmbmbna bgcvin ar-region classify value-sets terms value-set kinds kind form value-set vsglob bnbnbnbmbmbmb set offsets global memory-region vssingle bnbnbmbmbmbn bnbnbnbmbmbmb set offsets -th memory-region bibp global vsarb bnbmbmbmbn bnbmbmbmb set offsets cz-th memory-region bnbq bnbmbmbmb addresses numeric values note value-set bnbmbmbmb implicit set concrete addresses corresponds ar-region procedure concrete stack-frame base addresses relative local-variable offsets calculated corresponds mallocregion concrete base addresses heapallocated memory objects value-set operations performed component-wise instance unsound bndf bnbmbmbmb value-set negation dfvs implicit set concrete addresses dfsi bndf bnbmbmbmb negated contrary implicit set concrete addresses dfsi bndf bnbmbmbmb implicit set concrete addresses bnbmbmbmb similar considerations hold arithmetic bit-level operations value-sets entries withbqvs tables addition table shows value-set kinds produced kinds arguments vsglob vssingle vsarb vsglob vsglob vssingle vsarb vssingle vssingle vsarb vsarb value-set operation symmetric arguments defined vsglob vsglob bnbnbn bmbm bmb bnbnbn bmbm bmb sibe bnbnbn bmbmbmb vsglob vssingle bnbnbn bmbm bmb bnbn bmbmbm bnbnbn bmbm bmb bnbn bmbmbm sibe bnbnbn bmbmbmb vssingle vsglob bnbn bmbm bmbn bnbnbnbm bmbmb bnbnbn bmbm bmb bnbn bmbmbm sibe bnbnbn bmbmbmb vsglob vsarb bnbnbn bmbm bmb bmbmbm bnbmbm bmb sibe bnbmbm bmbn sibe bmbm bmb vsarb vsglob bnbmbm bmbn bnbm bmbmb bnbnbn bmbm bmb sibe bnbmbm bmbn sibe bmbm bmb subtraction dfvs table shows value-set kinds produced dfvs kinds arguments vsglob vssingle vsarb vsglob vsglob vssingle vssingle vsarb vsarb operation symmetric arguments produces cases vsglob vsglob bnbnbn bmbm bmb bnbnbn bmbmbmb sibe bnbnbnbm bmbmb vssingle dfvs vsglob bnbn bmbm bnbnbn bmbm bmb bnbnbn bmbmb bnbn bmbmbn sibe bnbnbn bmbmbmb vsarb dfvs vsglob bmbmbm bnbmbm bmb bnbnbn bmbmb sibe bnbmbm bmbn sibe bnbm bmbmb bitwise cyvs xor cmvs opvs becub vsbncyvsbncmvscvdenote binary bitwise value-set operations opsi becub bncy denote strided-interval operation cxcs cpd cxcwcxd cpd denote value-sets opvs cxcs cpd cxcwcxd cpd bccja bdbna bdclbnbnbnbmbmbmb bccja bdbna bdclbnbnbnbmbmbmb vsglob opvs vsglob bnbnbnbmbmbmb bnbnbnbmbmbmb opvs opsi sibe bnbnbnbmbmbmb vsglob opvs denote value-set kind cxcs opvs cpd cxcwcxd cpd opvs cpd cxcwcxd cpd bnbnbnbmbmbmb bpbq opvs vsglob denote value-set kind opvs cxcs opvs cpd cxcwcxd cpd cpd cxcwcxd cpd opvsb bnbnbnbmbmbmb bpbq value-set arithmetic radices value-set arithmetic templatized account radices operations component strided intervals performed strided-interval arithmetic radix abstract operations instruction set vsa flow-sensitive context-sensitive abstract-interpretation algorithm parameterized call-string length based independent-attribute domain vsa associates instruction absmemconfig call-string maps register valueset flag bool global-region ar-region malloc-region alocenv orbr flag bpcucfbn zfbn sfbn pfbn afbn ofcv alocenv a-locaxvalueset absenv registeraxvaluesetb flagaxbool cuglobalcvaxalocenvb procaxalocenv allocmemrgnaxalocenv absmemconfig callstringaxabsenv vsa obtains absmemconfig instruction abstract interpretation performed interprocedural cfg interprocedural cfg node instruction executable node instruction dlls executable edges interprocedural cfg labeled instruction source edge source edge branch instruction edge labeled outcome branch intraprocedural analysis absenvs call-strings propagated separately cfg applying abstract transformer absenv level transformer type absenvaxabsenv instance simple move instruction form ctcvbdb ctcvbe abstract transformer absenv level expressed whereaycx denotes selection cx-th component absenv tuple cjcz dacl denotes update map associate key alenvbmd ctd envaybd cxd cjd ctcvbdawd ctcvbeb clbn envaybebn envaybfbn envaybgbn 
cons cons cons envaybhb discussion issues arise intraprocedural propagation including vsa handles memory-access operations found interprocedural analysis basic steps handle parameter passing calls returns discussed implementation codesurfer extended degree context-sensitivity call-strings approach interprocedural dataflow analysis call-strings information improve intraprocedural propagation vsa call-string current absenv executable call graph determine pending ars current abstract calling context represent procedures called recursively distinction important a-locs ar-regions potentially recursive procedures represent concrete memory location term summary locs assignments modeled weak updates value-set computed a-loc abstract transformer joined value-set a-loc incoming absenv replacing call-string call-graph information a-locs abstract calling contexts identified non-summary locs case strong updates weak updates abstract calling contexts assignment a-loc treated kill kill improves treatment reported callstrings information abstract calling contexts weak updates performed a-locs procedures 
called recursively calling context idioms applying abstract transformer instruction checked matches pattern carry abstract interpretation precisely value-set arithmetic performed directly examples cgc ctcvb ctcv cgc instruction sets operand bitwise exclusive-or instruction operands idiom catches case cgc set register a-loc register ctcv set value-set ccbxcbcc ctcvb ctcv ccbxcbcc instruction computes bitwise operands sets flags result idiom addresses set value-set ctcv form cxbnbnbnbmbmbmb bmbp true adb cxb cubccv false adb cxb ckcubccv bvc cpb bvc cqb present implementation assume allocation succeeds value-set analysis explores behavior system executions allocations succeed assumption apply idiom suppose czbdbnczbebnbmbmbm malloc-regions value-set bnbnbmbmbmbn czbd czbe bnbmbmbmb value-set set false related work work analyzing memory accesses executables proposed techniques obtain information executables means static analysis including work summarized xgcc tool analyzes xrtl intermediate code aim verifying safety properties absence buffer overflow division uninitialized variables tool abstract domain based sets intervals supports arithmetic domain takes account properties signed s-complement numbers domain xgcc support notion strides intervals strided intervals strides processors memory accesses aligned word boundaries abstract arithmetic based solely intervals provide information check non-aligned accesses instance bg-byte fetch memory starting address interval cjbdbcbebcbnbdbcbebkcl considered fetch bg-byte sequences suppose program writes addresses words abstract domain distinguish unaligned fetch aligned fetch bg-byte fetch starting address interval cjbdbcbebcbnbdbcbebkcl address forging bg-byte fetch high-order bytes concatenated low-order byte contrast analysis starting address bg-byte fetch characterized strided interval bgcjbdbcbebcbnbdbcbebkcl discover set values restricted cucp bncp bncp tool intervals strided intervals suffer catastrophic loss precision chains indirection operations indirection operation fetches values indirection operation follow possibilities including addresses potentially forged sequence intervals strided intervals tool attempts identify potential bugs security vulnerabilies large number false alarms reported work deals memory accesses conservatively register assigned memory assumed instance basic goal algorithm proposed debray similar vsa goal find over-approximation set values register hold program point find over-approximation set values abstract data object hold program point data objects include global stack-allocated heap-allocated memory locations addition registers analysis proposed debray set addresses approximated set congruence values track low-order bits addresses unlike vsa algorithm make effort track values registers loses great deal precision load memory cifuentes fraboulet give algorithm identify intraprocedural slice executable program use-def chains algorithm makes attempt track values registers cuts short slice load memory encountered pieces work closely related vsa algorithm data-dependence analysis assembly code amme algorithm pointer analysis lowlevel intermediate representation guo algorithm amme performs intraprocedural analysis clear algorithm fully accounts dependences memory locations algorithm guo partially flow-sensitive tracks registers flow-sensitive manner treats memory locations flow-insensitive manner algorithm partial transfer functions achieve contextsensitivity transfer functions parameterized unknown initial values uivs algorithm account possibility called procedures corrupting memory locations uivs represent platforms created manipulating executables presence additional information source code debugging information including atom eel vulcan bergeron present static-analysis technique check executable debugging information adheres userspecified security policy rival presents analysis checks assembly code produced compiler possesses safety properties original source code analysis assumes source code debugging information source code analyzed source-level invariants translated low-level invariants system attempts prove lowlevel code identification structures aggregate structure identification asi devised ramalingam partition aggregates cobol program memory-access patterns similar algorithm devised eidorff incorporated anno domini system original motivation algorithms year problem provided identify date-valued quantities flow program work asi complements vsa asi addresses issue identifying structure aggregates vsa addresses issue over-approximating contents memory locations asi improved method variable-identification facility idapro cruder techniques takes account statically memory addresses stack offsets asi requires information hand idapro range stride memory-access operation fortunately information vsa carried means asi conjunction vsa obtain improved results round vsa results asi refine a-loc abstraction vsa run generally producing precise results mycroft unification-based algorithm performing type reconstruction including identifying structures instance register dereferenced offset perform bgbyte access algorithm infers register holds pointer object bg-byte field offset type system disjunctive constraints multiple type reconstructions single usage pattern mycroft points weaknesses algorithm due absence information addressed information obtained techniques paper mycroft explains simplifications triggered interprocedural side-effect information information computed methods codesurfer hand interprocedural side-effect information computed standard techniques mycroft algorithm unable recover information sizes arrays identified work affine-relation analysis ara identify program point affine relations hold essence information induction-variable relationships loops turn vsa recover information array sizes register sweep array control loop-index register mycroft stride information vsa abstract domain based strided intervals mycroft excludes consideration programs addresses local variables unclear address-taken object ends crd size bytes coincidentally contiguously allocated cxd hard distinguish crd bytes problematic restriction decompiler common idiom programs addresses local variables frequently explicit arguments called procedures programmers simulate call-by-reference parameter passing java compilers addresses local variables implement call-by-reference parameter passing methods presented paper provide information usage patterns pointers stack mycroft techniques applied presence pointers stack decompilation past work decompiling assembly code high-level language related work decompilers reported literature limited translating assembly code high-level code instance cifuentes work primarily concentrates recovery expressions instruction sequences control flow memory-access-analysis methods paper enable decompiler job performing analyses prior decompilation proper information numeric values address values physical types definite links objects virtual-function tables decompiler prefast driver-specific rules october whdc microsoft corp http microsoft whdc devtools tools prefastdrv mspx amme braun zehendner thomasset data dependence analysis assembly code int parallel proc backes programmanalyse des xrtl zwischencodes phd thesis universitaet des saarlandes german balakrishnan reps analyzing memory accesses executables balakrishnan reps recency-abstraction heap-allocated storage uw-madison december balakrishnan reps recovery variables heap structure executables uw-madison balakrishnan reps melski teitelbaum wysinwyx execute vstte ball rajamani slam toolkit cav bergeron debbabi desharnais erhioui lavoie tawbi static detection malicious code executable programs int req eng bergeron debbabi erhioui ktari static analysis binary code isolate malicious behaviors wetice bouajjani esparza touili generic approach static analysis concurrent programs procedures popl bush pincus sielaff static analyzer finding dynamic programming errors chen dean wagner model checking million lines code ndss chen wagner mops infrastructure examining security properties software ccs cifuentes fraboulet interprocedural data flow recovery high-level language code assembly queensland cifuentes fraboulet intraprocedural static slicing binary executables icsm cifuentes simon fraboulet assembly high-level language translation icsm codesurfer grammatech http grammatech cooper kennedy interprocedural side-effect analysis linear time pldi corbett dwyer hatcliff laubach pasareanu robby zheng bandera 
extracting finite-state models java source code icse cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points popl das lerner seigle esp path-sensitive program verification polynomial time pldi debray muth weippert alias analysis executable code popl eidorff henglein mossin niss rensen tofte anno domini type theory year conversion tool popl engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions osdi guo bridges triantafyllis ottoni raman august practical accurate low-level pointer analysis int symp code gen opt pages havelund pressburger model checking java programs java pathfinder sttt henzinger jhala majumdar sutre lazy abstraction popl horwitz reps binkley interprocedural slicing dependence graphs toplas january howard bad news good news october msdn microsoft corp idapro disassembler http datarescue idabase kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds lal reps balakrishnan extended weighted pushdown systems cav larus schnarr eel machine-independent executable editing pldi uller-olm seidl analysis modular arithmetic esop mycroft type-based decompilation esop ramalingam field tip aggregate structure identification application program analysis popl reps balakrishnan lim teitelbaum nextgeneration platform analyzing executables aplas reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis sas reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis scp october rival abstract interpretation based certification assembly code vmcai sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications chapter prentice-hall englewood cliffs srivastava edwards vulcan binary transformation distributed environment microsoft research srivastava eustace atom system building customized program analysis tools pldi wagner foster brewer aiken step automated detection buffer overrun vulnerabilities ndss wall systems late code modification giegerich graham editors code generation concepts tools techniques pages springer-verlag warren hacker delight addison-wesley wilson lam efficient context-sensitive pointer analysis programs pldi 
ground ground con cons ground con ground ground con cons ground con edge path non-path edge legend path edge cons ground idrev edgev tov ground cons rev cons cons ground rev cons rev idrev ground edgevjtovj rev ground edgevjtovj ground-id g-edgevjtovj ground rev edgevjtovj edgevjtovj input return range apply return input crx case edgey tox edgey toy edgey toy non-c-vals case return input input return range idrev callee-side entities caller-side entities return input input return range idrev callee-side entities caller-side entities edge path non-path edge legend path edge cons cons cons cons ground edgey toy edgey tox ground cons-value rev edgey toy edgey tox rev ground succ-value non-cons-vals ground succ-value non-cons-vals edgey toy edgey toy edgey tox cons cons cons cons ground cons-value succ rev rev ground succ-value edgey toy edgey tox rev ground c-value ground-c-id-edgey tox edgey toy -rev cons car cons cdr cons cons cons idctrloratomicuse ctrloratomicuse atom equal cons cons ctrloratomicuse null call input inputk ctrloratomicusereturn returninput input cons cons cons cons cons cons cons cons cons cons cons cons cons cons swap returninput cons cons carcdr cons returninput swap call input ctrloratomicusereturn ctrloratomicusereturn main cons cons cons cons cons cons cons cons slice unbalright cons return returncons idreturn return pairfn swap returninput input pairfn call input input ctrloratomicusereturn cons carcdr cons returninput mycons swap call input input ctrloratomicusereturn mycons returninput input cons cons return main cons cons cons cons ctrloratomicuse cons cons cons verifying concurrent message-passing programs recursive callsstar chaki clarke kidd reps touili carnegie mellon pittsburgh usa wisconsin madison usa liafa cnrs paris paris france abstract model-checking problem programs data ranging large domains recursive procedure calls concurrent parallel components communicate synchronizing actions model programs communicating pushdown systems reduce reachability problem model deciding emptiness intersection context-free languages tackle undecidable problem counterexample guided abstraction refinement cegar scheme implemented technique model checker magic found previously unknown bug version windows bluetooth driver introduction analysis concurrent software represents major challenge model-checking community concurrent programs include complex features manipulation data ranging unbounded domains integers reals large domains -bit ints floats presence recursive procedure calls lead unbounded number calls concurrency existence synchronization statements checking control point reachable undecidable program includes recursive procedures synchronization statements method solving reachability problem systems incomplete hope approximate technique semi-decision procedure termination guaranteed work approach sidestep undecidability issue guaranteed terminate approach instance tool found previously unknown bug version windows bluetooth driver years authors addressed related issues pushown systems proposed adequate formalism describe pure sequential recursive programs represent potentially infinite configurations recursive programs symbolic manner regular languages recently compositions pushown systems called communicating pushown systems model concurrent recursive programs cases data assumed small finite domain hand abstract-interpretation techniques deal data ranging unbounded large domains recently automated predicate-abstraction techniques proposed deal issue idea predicate abstraction abstract infinite data domain finite defined set predicates precision abstraction modelchecking algorithm depend number form predicates size star supported onr contracts model increases number predicates increases cost model checking central problem predicate abstraction discovery small set predicates sufficient prove desired property counterexample guided abstaction refinement cegar techniques find small set idea start empty set predicates perform verification procedure obtained model property satisfied model conclude satisfied real program program fewer behaviors model obtain counterexample counterexample corresponds execution program conclude program satisfy property compute set predicates eliminate future exploration spurious trace back step schema successfully applied handle pure non-concurrent sequential recursive programs tool slam concurrent non-recursive programs tools blast magic work step combine cegar predicate-abstraction techniques pushdown-system modeling handle concurrency recursion large data domains time approach consists communicating pushdown systems cpdss model concurrent programs define cegar predicate-abstraction techniques obtain successively precise cpdss source code parallel program define model-checking algorithms cpdss main contributions paper defining automatic cegar predicate-abstraction techniques create cpds source code concurrent recursive program manipulates variables range large domains refine cpds abstractions eliminate counterexample techniques defined componentwise makes compositional scalable large programs experiment kloc program ran seconds defining model-checking techniques cpdss restrict work solving reachability queries reduce reachability problem cpdss undecidable problem checking emptiness intersection context-free languages cfls tackle problem apply cegar scheme consists computing over-approximations conclude check intersection spurious case refine overapproximations return step semi-decision procedure guaranteed terminate intersection empty implementing technique model-checker magic carrying number non-trivial experiments implementation handle nontrivial examples windows bluetooth driver algorithm concurrent insertions binary search tree handled previous version magic addition discovered previously unknown bug version windows bluetooth driver implementation improved performance non-recursive examples previous version magic handle in-lining shows technique represents advance non-recursive recursive concurrent programs features work applies cegar scheme levels model-checking level solve reachability queries cpdss cpds model checker cegar scheme semi-decision procedure testing emptiness intersection cfls predicate-abstraction level deal unbounded domain variables time cegar model-checker remainder paper organized defines cpds model describes generate cpds program predicate abstraction presents semi-decision procedure model-checking cpds presents techniques reports experimental results discusses related work preliminary definitions pushdown system pds four-tuple act finite set states act finite set actions finite stack alphabet finite set transition rules form aarrowhookleft qprime qprime act loss generality assume rules restrictive pds transformed pds form transition rules obtained program form configuration pair contents stack set configurations regular language regular act define transition relation configurations aarrowhookleft qprime qprime act relation defined obvious set configurations post set successors defined post cprime act cprime communicating pushdown system cpds tuple pdss set actions act act lab lab set synchronization actions represents internal actions property lab reduce reachability problem cpdss checking emptiness intersection cfls global configuration tuple configurations ofp relation extended global configurations cprime cprimen index cprimei negationslash cprimej cprime cprimen distinct indices negationslash cprimei cprimej negationslash negationslash cprimek set global configurations successors denoted post defined componentwise predicate abstraction model concurrent recursive programs cpdss section describes extract cpds parallel program in-depth discussion suppose concurrent recursive components component extract pdspi parallel composition components represented cpds tuple extract extend approach originally magic automatically extracts finite-state automaton code extract pds loss generality assume kinds statements programs assignments procedure calls if-then-else branches gotos synchronization statements returns cil transform arbitrary programs form pds defined terms current set seed predicates initially empty predicate represents set assignments variables program predicate sets variables resp set local resp global variables ploc resp pglob projection local variables resp global variables predicate represents set values local variable global ploc denotes predicate pglob predicate extend notations sets predicates obvious manner predicate inference weakest precondition set predicates defined assignment form weakest precondition respect denoted obtained replacing occurrence assignments pointers statements form handled approach morris set seed predicates create pds abstraction sequential component relative predicates seed set repeatedly compute weakest preconditions control point compute set predicates initially point repeat longer modified statement corresponds control point assignment nprime successor add wsnparenleftbigp nprimeparenrightbig statement nprime successor add nprime condition add goto synchronisation statement nprime successor add nprime call procedure nprime successor epi initial control point procedure add locnprime globepi method terminate presence loops recursive procedure calls case impose termination bounding number predicates control point explain intuition item predicate set capable making set distinctions concrete states arise execution time point assignment nprime successor item adds wsnparenleftbigp nprimeparenrightbig wsn true true nprime minimize loss precision characterizing states nprime determine holds nprime wsn holds finally union control points sequential component set generated predicates pds extraction assign sequential possibly recursive component pds act defined set valuations glob act action synchronization actions program set pairs loc control point sequential component loc valuation locn defined sequential component control flow graph non-synchronizing assignment statement control location successor pds rules glob loc arrowhookleft globprime locprime glob globn globprime globprimen resp loc locn 
locprime locprimen potentially satisfy globprime glob resp locprime loc formulas ensure generated pds behaviors concrete program synchronizing statement action pds rules glob loc aarrowhookleft globprime locprime glob globprime resp loc locprime potentially satisfy conditions stated details converting types statements pds rules comparision predicate-abstraction technique slam slam tool predicate-abstraction techniques extract boolean program source code schwoon translation obtain pds boolean program compared techniques slam approach sketched main differences translation efficient produces directly step pds code intermediate boolean program close set seed predicates computing weakest preconditions paths program contrast slam seed set predicates computing closure weakest precondition computes largest disjunctions predicates imply weakest preconditions abstract model obtain precise slam predicates reachability analysis cpdss program consists sequential components query suppose system starts configuration component initial control point components reach error point technique answers kind question modeling program cpds initial configurations error configurations cprime cprimen states configurations cprimei correspond error points states configurations cprime cprimei cprimei cprimen unconstrained error configurations reachable initial configurations algorithm returns sequence synchronization actions yield failing program run show determining satisfiable general undecidable firstorder formulas integers sidestep problem sound validity checker terminates answers true false unknown question formula valid validity checker returns false unknown question valid potentially satisfiable section tackle reachability analysis systems remainder paper restrict systems consist components technique extended straightforward manner general case details implementation discussed supports arbitrary number components reduce reachability problem cpdss deciding emptiness question intersection cfls cpds cprime cprime sets global configurations system internal actions represented neutral element concatenation cprime cprime reachable exists sequence synchronization actions simultaneously leads configuration configuration cprime configuration configuration cprime holds iff cprime cprime negationslash cprimei cfl consisting sequences actions equivalently synchronization actions internal actions represented lead cprimei deciding emptiness intersection cfls undecidable propose semi-decision procedure case termination answers intersection empty cprime cprime negationslash semi-decision procedure guaranteed terminate return witness sequence intersection semi-decision procedure based counterexample guided abstraction refinement cegar scheme abstraction compute over-approximation path language cprimei verification check conclude cprime cprime cprime cprime unreachable compute counterexample counterexample validation check sequence cprime cprime case spurious conclude cprime cprime negationslash cprime cprime reachable proceed step refinement spurious refine over-approximations compute over-approximations aprime aprime cprimei aprimei continue step remainder section discuss steps detail fix sets global configurations cprime cprime brevity denote cprime cprime computing over-approximations path languages compute over-approximations pds path languages technique based approach presented bouajjani summarized abstract lattice intersectionsq unionsq latticetop idempotent semiring circledot unionsq associative commutative idempotent operation circledot associative operation neutral elements circledot annihilator circledot acircledot circledota circledot distributes finally related concrete domain lab element letter lab abstraction function lab concretization function lab defined circledot circledotvan lab circledot circledotvan easy language lab parenleftbig parenrightbig words parenleftbig parenrightbig over-approximation represented abstract domain element intuitively abstract operations circledot correspond concatenation union intersectionsq correspond inclusion intersection abstract elements correspond empty language compute over-approximation parenleftbig parenrightbig compute representative abstract domain finite-chain abstraction abstraction infinite ascending chain maximal height chain theorem act pds cprime regular sets configurations finite-chain abstraction defined abstract domain parenleftbigl cprime parenrightbig effectively computed time algorithms provide basis theorem due bouajjani reps implemented tool called wpds tool compute abstractions path languages check emptiness intersection over-approximations parenleftbig parenrightbig parenleftbig parenrightbig suffices check intersectionsq fact show lab intersectionsq parenleftbig parenrightbig parenleftbig parenrightbig defining refinable finite-chain abstractions apply cegar scheme define refinable finite-chain abstractions series precise language lab iparenleftbig parenrightbig jparenleftbig parenrightbig define ith-prefix abstraction set words lab length equal abstract lattice equal lab intersectionsq circledotv prefix length abstraction concretization functions domain easy set words length union set prefixes length lab iparenleftbig parenrightbig lab note decide lab finite set words easy precise iparenleftbig parenrightbig jparenleftbig parenrightbig defined refinable series finite-chain abstractions remark ith-prefix abstraction abstraction instantiate framework ith-suffix ith-subword abstractions defined analogous checking counterexample spurious remains check iparenleftbig iparenleftbigl parenrightbig iparenleftbig parenrightbig element amounts deciding problem undecidable regular language lab iparenleftbig parenrightbig regular sidestep problem check common word length amounts checking parenleftbig parenrightbig parenleftbig parenrightbig decidable finite set semi-decision procedure summarizing previous discussion obtain semi-decision procedure based ith-prefix abstraction reachability problem cpdss initially compute common words length common prefixes length cprime cprime iprime iparenleftbigl cprime parenrightbig iparenleftbigl cprime parenrightbig iprime conclude cprime cprime cprime cprime unreachable determine iprime spurious check iprime cprime cprime negationslash holds conclude cprime cprime common word length equal cprime cprime negationslash cprime cprime reachable increment continue step theorem cprime cprime negationslash semi-decision procedure terminates exact solution proof cprime cprime length kparenleftbigl cprime parenrightbig kparenleftbigl cprime parenrightbig remark theorem step computing necessitates lab time lab words length lab elements worst-case complexity algorithm practice implementation behaves discussed pds rules aarrowhookleft arrowhookleft barrowhookleft barrowhookleft pds rules rprime aarrowhookleft rprime barrowhookleft rprime arrowhookleft rprime barrowhookleft rprime darrowhookleft forp lparenleftbig parenrightbig akbbk forp lparenleftbig parenrightbig kdbk note straightforward illustrate approach negationslash refine abstraction negationslash refine abstraction conclude componentwise refinement construction cpds model program involves predicate abstraction parametrized set predicates central issue predicate abstraction find small set predicates property interest established case property question system reach error configuration initial configuration component starts configuration globi loci initial control point component globi loci initial valuations global local variables similarly error configuration configuration component configuration form glob nie loc nie correponds error point glob loc arbitrary valuations variables magic finds set predicates applying cegar approach start model involving empty set seed predicates perform model-checking step model checker answers error state unreachable cpds model case concrete program program fewer behaviors model model checker finds cpds reach error state performing sequence synchronization actions iprime cprime cprime verify behavior corresponds real execution program case shown program correct apparentlyerroneous behavior introduced abstraction case refine cpds model precisely model checker returns sequences rules cpds reaches error state performs sequence rimi case sequence synchronization actions sequences rules sequence rimi counterexample component check counterexample spurious check component perform sequence statements correspond rule sequence rimi component fails perform sequence refine pds eliminate spurious rule sequence note steps componentwise makes technique compositional scalable large programs counterexample validation present subsection algorithm takes input counterexample sequence rules pds models sequential component answers spurious sequence statements corresponds intuitively algorithm simulates steps determine concrete component possibly perform algorithm starts initial point valuations 
glob loc variables applies successively statements updates values variables checks if-then-else conditions satisfied sequence instructions precisely algorithm works initially glob loc assignment compute strongest postcondition respect assignment valuation true updated valuation true statement condition corresponds successor corresponds successor satisfiable program execute sequence statements counterexample valid counterexample spurious eliminating counterexample counterexample spurious component refine pds model component adding seed predicates predicates add subsets set conditions if-then-else branches program intuitively works cases counterexample spurious abstract model modeled condition sufficient precision allowed branches moment abstract execution concrete execution run branch counterexample corresponds trace takes wrong branch eliminate trace add condition statement seed predicate precisely set conditions statements program current set seed predicates computed set predicates proceed increment step cprime create pds pprimei corresponds predicates cprime model eliminates counterexample seed set cprime increment step predicates succeeds eliminating counterexample add predicates step possibilities counterexample eliminated add predicates step illustrating cegar predicate-abstraction technique sequential components running parallel synchronization action main void proc main int proc return return proc return cpds model case set seed predicates empty model component pds local variables stack alphabet set control points set seed predicates empty unique state corresponds valuation empty rules arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft aarrowhookleft arrowhookleft arrowhookleft similarly represent component pds unique state rules rprime aarrowhookleft rprime arrowhookleft case model component pds pprime points computing find predicate ignore predicates trivially true false states pprime alse true empty pprime rules arrowhookleft arrowhookleft arrowhookleft arrowhookleft arrowhookleft aarrowhookleft arrowhookleft arrowhookleft refinement query reach point system starts case component synchronizes action component perform model concurrent program seed predicates model model checker answers reachable sequences rprime method check spurious satisfiable refine pds obtain pds pprime easy cpds pprime reach experimental results version procs abstractionlen time secs mem ith-prefix ith-suffix ith-prefix ith-suffix ith-suffix ith-suffix table performance bluetooth driver len counterexample length abstraction length mem memory usage implemented method comfort model checker built top magic experimented set non-trivial benchmarks implementation supports kinds abstractions ith-prefix ith-suffix abstractions application concurrent recursive programs applied technique nontrivial recursive concurrent programs handled original non-recursive version magic windows bluetooth driver algorithm concurrent insertions binary search tree experiments performed ghz smp memory running linux bug windows bluetooth driver tool found bugs versions program verified correctness two-process instantiation version version kiss previously found bug tool identified bug contrast kiss work reported approach verify correctness determining error configurations unreachable authors correctness verified found bug arise concurrent processes running bugs detected ith-prefix abstraction ith-suffix abstraction counterexample found tool modified create analyzed two-process configuration tool reported error state unreachable tab shows running times memory consumption experiments ith-suffix abstraction efficient compute pre error states language stop growing pre traversed actions error state note bluetooth driver recursive recursive process model counter real program counter integer global variable needed represent global variables means synchronization actions represent counter process modeled counter process pds stack alphabet number stack corresponds counter incrementing counter amounts pushing stack decrementing amounts popping stack procs len time secs table times needed detect bug concurrent-insertions algorithm algorithm concurrent insertions binary search tree considered algorithm handles finite number concurrent insertions binary search tree algorithm applied handle simultaneous insertions database users reduce time single insertion algorithm modified process adhere required lock unlock semantics applied tool ith-prefix abstraction modified version times needed detect bug function number processes shown tab application non-recursive examples applied implementation examples recursion magic applied previous version magic handles non-recursive procedure calls in-line expansion purpose non-recursive experiments test technique inlining tested sequential programs determine implementations comparable speed complication concurrency times srvr-i clnt-i examples show overhead introduced technique substantial times columns tab labeled verif reason difference magic performs reachability query fsm full cpds machinery includes cegar loop sequentialexperiments concurrent experiments program magic cpds abs verif mem abs verif mem len srvrsrvr- srvrsrvr- srvrsrvr- srvrsrvr- clntclnt- clntclnt- clntclnt- clntclnt- program magic cpds abs verif mem abs verif mem len sslssl- sslssl- sslssl- sslucos ucosucos- casting table abs predicate-abstraction time sec verif model-checking time sec mem memory usage exceeded memory limit len abstraction length handicap model checking concurrent programs technique in-lining technique base magic system bold entries right-hand table tab technique outperforms magic cases avoids state-space explosion occur in-lining cost technique depends heavily length synchronization sequences examined model checker comparing times non-recursive examples bluetooth non-recursive examples verifed strings synchronization actions actions running times larger interesting aspect technique limiting factor length synchronization sequences considered program size analysis times encouraging programs ucosand ucoswhich loc loc tab related work bouajjani reduced reachability problem cpdss computing overapproximations cfls cegar techniques presented precisely work computes over-approximations cfls concludes conclusion made automatically negationslash conclude negationslash contrast cegar-based semi-decision procedure guaranteed terminate case correct answer cegar-based predicate-abstraction techniques c-program model-checking tools slam blast zing kiss mentioned previously slam deal concurrency blast handle recursion kiss discover errors number interleavings parallel components greater zing extension slam concurrent programs slam zing based procedure summarization zing terminate cases technique concurrent case track calling stack unbounded presence recursive calls contents stack explicitly represented zing contrast pds modeling framework symbolically represented regular languages hand slam zing predicate-abstraction techniques extract boolean program program recursion schwoon implemented translation boolean programs pdss moped tool moped handle concurrent programs cpds predicateabstraction-refinement techniques performed componentwise amount performing successive sequential pds predicate-abstractions refinements successive steps performed slam moped paper present predicate-abstraction techniques create pds source code sequential component directly efficently intermediate boolean program finally techniques presented multiple pdss model concurrent recursive programs restricted programs communicate finite number locks assumes nesting condition locks shared-variables communication threads synchronizing actions models simulate technique presented sidesteps undecidability reachability problem multiple pdss putting bound number interleavings threads sidestep undecidability computing abstractions cfls bounding number interleavings cases technique powerful presented find infer target configurations reachable technique establish property computes underapproximation correcting create tool verified correct processes finally technique implemented automatic techniques translate code pds presented acknowledgments sighireanu helpful discussions bluetooth driver program qadeer providing lal helpful insights ramalingam context-sensitive analysis undecidable toplas esparza knoop automata-theoretic approach interprocedural data-flow analysis fossacs esparza schwoon bdd-based model checker recursive programs cav bouajjani esparza maler reachability analysis pushdown automata application model checking concur finkel willems wolper direct symbolic approach model 
checking pushdown systems infinity bouajjani esparza touili generic approach static analysis concurrent programs procedures popl bouajjani esparza touili generic approach static analysis concurrent programs procedures int found comp sci cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points popl graf saidi construction abstract state graphs pvs cav kurshan computer-aided verification coordinating processes automatatheoretic approach princeton press clarke grumberg jha veith counterexample-guided abstraction refinement cav ball rajamani automatically validating temporal safety properties interfaces spin henzinger jhala majumdar sutre lazy abstraction popl chaki clarke groce jha veith modular verification software components icse schwoon model-checking pushdown systems phd thesis tum chaki clarke kidd reps touili verifying concurrent message-passing programs recursive calls tech rep univ wisconsin necula mcpeak weimer liblit bhargava intermediate lang http manju berkeley cil morris assignment linked data structures theoretical foundations programming methodology reidel publishing nelson techniques program verification phd thesis stanford reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis sas reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis scp kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds chaki ivers sharygina wallnau comfort reasoning framework cav qadeer kiss simple sequential pldi qadeer rehof context-bounded model checking concurrent software tacas kung lehman concurrent manipulation binary search trees tods qadeer rajamani rehof summarizing procedures concurrent programs popl kahlon ivancic gupta reasoning threads communicating locks cav 

extracting output formats executables junghee lim junghee wisc thomas reps reps wisc ben liblit liblit wisc computer sciences department wisconsin-madison abstract describe design implementation ffe file-format extractor analysis tool works stripped executables source code debugging information extracts output data formats file formats network packet formats construct hierarchical finite state machine hfsm over-approximates output data format hfsm defines language operations generate output data value-set analysis vsa aggregate structure identification asi annotate hfsms information partially characterizes output data values vsa determines over-approximation set addresses integer values data object hold program point asi analyzes memory accesses program recover information structure aggregates series filtering operations performed over-approximate hfsm finite-state machine result final answer easier understand experiments ffe uncovered bug image-conversion utility png ico introduction reverse engineering helps gain insight program internal workings performed retrieve source code program source code lost analyze program malicious virus fix bug improve performance program paper describes reverseengineering tool human understand program produces output cots commercial off-the-shelf software increasingly deployed source code documentation proprietary intermediate formats reverse engineering increasingly needed work supported part nsf grants ccfand ccrand onr contracts dayton madison usa interoperability cots tool proprietary file format interoperability inhibited tool tool chain consumer producer files format technique presented paper promotes reuse components tool chain software engineer build program process files cots software product generates tool obtain information format specification creating program act substitute consumer producer technique presented malware detection instance identify live versions malware figure format network traffic technique provide problem technique provide summary program behavior produces structure consists reduced number entities compared call graph instance make easier understand program contributions work technique extracting overapproximation program output data format including extract preliminary structure output data format elaborate structure annotating information output values sizes simplify structure provide greater understanding output data format information lead greater understanding program behavior report experimental results applying ffe applications experiments uncovered bug png ico concentrated problem extracting output file formats executables approach applied source code advantage information program variables declared types extracting input file formats remainder paper organized discusses key observations inspired work assumptions approach explains process constructing structure output data format overview infrastructure implementation based discusses elaborate structure generated step static analyses presents series filtering operations making hfsms understandable describes validated ffe presents experimental results describes related work describes future directions observations assumptions programming styles section makes observations programming styles typical application programs produce output data programming styles relevant writing output data categorized individual writes bulk writes present approaches tailored handle sections programs styles tool capable handling programs void put byte char void put long long void writes char void type switch case put byte break case put byte break void chksum put long void fill data put byte void main put long magic put long magic writes filename type put long size chksum return figure individual writes individual writes programming style write individual data items separately file network standard functions fputs fputc programs practice wrapper functions tend frequently fig shows programming style wrapper functions put byte put long writes fields output including magic numbers types sizes checksum written calling wrapper functions functions provide api append output items internal buffer buffer filled contents buffer flushed buffer written bulk individual calls wrapper functions represent individual writes referred style refer standard functions user-defined wrapper functions output functions output operation operation relevant generating output data object specifically term output operation defined call site calls output function standard library function wrapper function lines fig experience application programs coded programming style instance gzip compress png ico follow programming style typedef struct header byte magic char char type long size long chksum header void write file header header malloc magic strcpy type size chksum fwrite sizeof header write data figure bulk write bulk writes programming style structs classes manipulate headers fig shows header structure write output data header struct object created line field struct set lines finally lines object written file entirety programming style calls fwrite output operations practice observed tar cpio aggregate structures storage preparation bulk write suspect style headers applications output files consist sequence records user-supplied information current implementation user identify output functions supply additional information information outputrelevant parameter numeric written gzip source macros functions output operations call sites gzip executable compatible approach user identify output operations supplying names output functions convert gzip output operations visible procedure calls proof concept experimental study modified gzipsource code change output macro definitions explicit functions automatically identifying low-level code fragments represent output operations remains challenging problem future work address pointing memory data written bytes written details case standard functions information step approach hierarchical finite state machine hfsm represent output data format hfsm structure nesting finite automata states allowed hfsm captures commonalities organizing states hierarchy note points hfsms languages paths recursive hfsms context-free languages languages paths non-recursive hfsms regular languages call bar foo bar baz call bar call baz call baz figure fsm hierarchical fsm non-recursive hierarchical fsms exponentially succinct conventional fsms due sharing illustrated fig construction hfsm code fragment shown fig explain approach code emulates archive utility writes magic numbers file layout type size check-sum wrapper functions fig shows disassembled code generated idapro procedure involved output operation rise fsm program wrapper functions include put byte disassembled code put long writes calls functions represent output operations ffe finds output operations constructs hfsm based cfgs provided codesurfer analyzer creates reduced interprocedural control-flow graph hfsm projection interprocedural control-flow graph enter nodes exit nodes call nodes output operations fig shows outcome running ffe node hfsm output operation call put long call put long call write bytes call fill data call put long call type call chksum call put byte call put long call put long call put long figure hfsm fig shaded boxes signify calls fsms dotted lines implicit connections fsms proc type push ebp mov ebp esp esp mov eax ebpmov ebpeax cmp ebpjz short loc cmp ebpjz short loc jmp short loc loc mov eax ebpd mov esp eax call jmp short loc loc mov eax ebpa mov esp eax call loc leave retn proc chksum push ebp mov ebp esp esp mov eax 
ebpd mov esp eax call leave retn proc fill data push ebp mov ebp esp esp loc cmp ebpjz short loc movsx eax ebpmov esp eax call jmp short loc loc leave retn proc main push ebp mov ebp esp esp esp fffffff mov eax add eax add eax shr eax shl eax mov ebph eax mov eax ebph call call main mov eax ebph mov esp eax call mov eax ebpch mov esp eax call mov esp mov eax ebpce mov esp eax call call call mov eax ebpe mov esp eax call call mov eax leave retn figure disassembled code fig transparent boxes output operations shaded boxes calls sub-fsms call-site sub-fsm type call-site node represents call sub-fsm implicitly connects fsms hfsm hfsm generated tool gzip shown fig thesis hfsms including elaborations refinements hfsms explained provide basis gaining understanding program behavior regard instructive compare hfsm program call graph call graph structure programmer gain high-level understanding program fig shows part call graph gzip gzip composed control-flow graphs cfgs cfg nodes call sites hfsm produced tool appears complicated substantially complicated program call graph interprocedural control-flow graph hfsm gzip fsms nodes call sites entry call call call call call call call call entry entry call call call call entry call call entry dfd call entry call call call call call call entry call entry entry entry entry call call call call call call call call entrycall call call call call call figure hfsm gzip fragment call graph gzip existing infrastructure ffe intermediate representations irs provided codesurfer framework fig analyst powerful flexible platform investigating properties behaviors executables codesurfer includes static analyses including set analysis vsa aggregate structure identification asi executable disassembleexecutable build cfgs ida pro vsa asi connector codesurfer back-end file format extractor codesurfer figure organization codersurfer ffe interacts components vsa combined numeric-analysis pointeranalysis algorithm determines over-approximation set numeric values addresses memory location holds program point asi recovers information variables types aggregates including arrays structs variables recovered asi vsa obtain information variables values values recovered vsa asi identify refined set variables codesurfer runs vsa asi repeatedly quiescence user-supplied bound reached vsa asi quiesced bound reached codesurfer initial estimate program variables call graph control-flow graphs cfgs program procedures provided idapro idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete contrast codesurfer values vsa discovers resolve indirect jumps indirect calls supply sound over-approximation call graph discusses ways vsa asi exploited purposes augmenting hfsm static-analyses information section explain exploit static analyses mentioned elaborating hfsms set analysis hfsm generated method information understanding output format hfsm made precise annotating additional information label node information size bytes data node represents over-approximation written values interest actual parameters formal parameters output functions suppose put byteis output functions fig suppose call sites safe results final round vsa round vsa over-approximation set numeric values addresses memory location modulo treatment memory-safety violations due loss precision vsa details void put byte char outbuf outcnt uch outcnt outbufsize flush outbuf mov byte ptr esp call put byte figure code fragment put byte output function call sites call output operations calls put byte output operations actual parameter fig information obtained information collected vsa note call put byte relevant stored stack byte pointed byesp abstract memory configuration amc vsa call site instance fig illustrates values amc tool obtain overapproximation set values actual hold evaluating operand expression esp amc amounts amc contents cell cells esp point result singleton set buf ptr size count esp esp size fhvalue size size count number bytes written size size esp figure obtain information vsa kinds parameters passed output function numeric values addresses numeric values case actual parameter holds numeric explained fig size obtained asi infers size usage pattern formal parameter called function case output operation calls standard function information signature function put bytewould -byte argument put short -byte argument addresses type formal parameter pointer set addresses memory location actual parameter amc values cells actual parameter point fig case fwrite lines fig falls category address heap-allocated memory location data passed argument size tfwrite constvoid buf ptr size size size count file product parameters fwrite number bytes written fig roles kind abstract recovered vsa suggests role singleton vsa recovers singleton actual parameter output operation parameter correspond magic number reserved field set numeric valuesif vsa recovers non-singleton set numeric values parameter correspond optional field topif vsa top means actual parameter output operation parameter correspond variant data aggregate structure identification mentioned programmers frequently struct class collect data written char outpack maxpacket static void pinger void register struct icmphdr icp register int int icp struct icmphdr outpack icpicmp type icmp echo icpicmp code icpicmp cksum icpicmp seq ntransmitted icpicmp ident sendto char outpack whereto sizeof struct sockaddr figure code fragment illustrate asi information fig shows fragment ping network packet constructed writing individual data items time output operations struct object store output data multiple fields prepared shown lines fig aggregate object written lines aggregate structure identification asi unification-based flow-insensitive algorithm identify structure aggregates program read write part memory object encountered asi records memory object subdivided smaller objects consistent memory access assume user sendto gnu library function mov eax dword ptr ebp mov byte ptr eax mov edx dword ptr ebp mov byte ptr edx mov eax dword ptr ebp mov word ptr eax mov eax dword ptr ntransmitted mov edx dword ptr ebp mov word ptr edx dword ptr ntransmitted mov eax dword ptr ident mov edx dword ptr ebp mov word ptr edx global struct byte outpack byte outpack byte outpack byte outpack byte outpack figure disassembled code fragment fig outcome asi output function argument sendto pointer struct object unknown substructure asi information substructure instructions correspond assignment statements lines fig shown fig lines vsa information extent memory accessed instructions asi information subdivide portion memory accessed producing structure shown fig structure packet header consist -byte fields -byte fields asi capable recovering information structure aggregates allocated heap illustrates case output function emits completely-constructed chunk output data hfsm represents program output operations high level abstraction bulk writes structure information recovered asi identifying structure output data format fig 
pinger call sendto elaborated sequence -byte header-field writes larger packet payload filtering hfsm hard understand experimented applying series filtering operations including simplification conversion fsm regular expression inline expansion generate simpler representation output format regular expression experiments manually process easy automate simplification nodes hfsm helpful understanding output format unnecessarily complicated hfsm prevent users understanding key aspects output format portions hfsm shown fig turn top-value top-size unbounded loop includes top-valuemeans node top-size means node size cases node node set provide meaningful information node top-size top-value node set unbounded loop top-size top-value considered meaningful node node node non-top-size algorithm simplification algorithm input hfsm output trimed hfsm set status fsms meaningful exists meaningful fsm non-meaningful nodes calls non-meaningful fsms set non-meaningful fsm transform fsm self-loop node labeled top-size top-value end alg describes algorithm simplifying hfsms generated ffe idea algorithm cases mentioned fsm consists nodes top-value top-size unbounded loop includes items simplify top original fsm provide meaningful information output format size top top size top top call size top top size top top size top top call size top top figure simplification fig shows simplification shaded fsm non-meaningful fsms non-meaningful nodes simplified unbounded selfloop consisting node top-size top-value conversion regular expression convert fsm hfsm regular expression kleene construction expansion final step apply inline expansion recursion encountered applications experiments inline expansion applied worrying nontermination recursion encountered summarized strongly connected components call graph fig represents final outcome techniques size size size top top size top size size size top size top figure final result simplification conversion inline expansion validation dynamic output validate approach testing outcome algorithm regular expression matches output data produced actual runs application flex tool generating scanners compilers input specification form list pattern-action pairs pattern regular expression flex generates program repeatedly finds longest prefix remaining input matches patterns create tool testing regular expression generated algorithm describes output application give flex -pattern specification consisting action report success default pattern action report failure discussed earlier box shown fig regular expression generated technique labeled kinds information size size top singleton set numeric values singleton set numeric values top feed flex regular expression transformed basic unit -byte character table shows transformation rules applied boxes table transformation boxes size conversion singleton singleton split multiple boxes -byte box fig transformed boxes fig singleton top top transformed matches character transformed sequence boxes box fig transformed boxes fig top top transformed box self-loop box fig transformed box loop fig table describes cases size singleton top note case size top non-top outcome vsa case size set numeric values split shorthand character flex pattern size size top top size size top size top figure transformation means character box multiple boxes singleton singleton size box fig values transformed boxes fig values case size singleton shaded boxes fig show converted note process validation original values sets values understandable human subdivided values experimental results evaluated ffe applications gzip png ico ping gzip gzip gnu data-compression program fig represents outcome filtering hfsm fig size size size size top size top top size top top size top size top size top size top size top figure final result gzip table part specification gzip format xflmtimeflgcmid flg fhcrc set isizecrc compressed blocks fixed values xlf identifies compression method reserved demotes deflate compression method flg divided individual bits bit ftext bit fhcrc mtime recent modification time original file compressed xfl specific compression methods identifies type file system compression place fat filesystem amiga crc cyclic redundancy check uncompressed data isize size original input data modulo format files generated gzip rfc table outcome shown fig correctly over-approximates specification words language outcome superset output language gzip outcome magic numbers constant positions shown table -byte element mtime -byte elements toxflandos end -byte elements correspond tocrc isize applied validation process outcome flex-generated validator accepted files chosen arbitrarily internet png ico size size top size size top size top size size top size size top size size size size top top size size top top size size size top size top size top size top size size size top size top size top figure outcome png ico table unofficial specification ico format size description reserved byte type byte count byte number icons file entries count list icons width byte cursor width height byte cursor height commonly width colorcount byte number colors reserved byte planes byte bitcount byte bits pixel sizeinbytes byte size infoheader andbitmap xorbitmap fileoffset byte filepos infoheader starts repeated count times infoheader bytes variant bmp infoheader size bytes size infoheader structure width bytes icon width height bytes icon height added height xorbitmap and-bitmap planes bytes number planes bitcount bytes bits pixel compression bytes type compression imagesize bytes size image bytes uncompressed xpixelsperm bytes unused ypixelsperm bytes unused colorsused bytes unused colorsimportant bytes unused colors number-of-colors bytes color map xor-bitmap red byte red component green byte green component blue byte blue component reserved byte repeated numberofcolors times xorbitmap bitmap andbitmap monochrome bitmap png icoconverts png files windows icon-resource files fig shows final outcome compared unofficial specification ico image format table constant data items format recovered ffe fields ico format including reserved type constant values recovered technique structure fig similar table difference format recovered ffe shows loops top level sequence entries sequence structures consist infoheader sequence colors sequence xorbitmaps sequence andbitmaps constrast table shows single infoheader color xorbitmapandbitmap structure inspection source code confirmed png ico supports sequence infoheader color xorbitmapandbitmap structures ffe revealed bug png ico showed format produced png ico satisfy specification table table planes field entries shown eighth box size row fig png icoalways produces discrepency discovered ran flex-generated validator checks conformance png ico output format extracted ffe pre-existing ico files files windows installation created running freeware png ico utility validator rejected files accepted ico files generated png ico tracked problem line png ico source writeword outfile wplanes ping ping sends icmp echo request packets host host reachable network sendto output function ping discussed structure hfsm shown fig represents program output operations high level abstraction hfsm inferred main calls pinger catcher pinger calls sendto pinger sub-fsm fig constructed information recovered sendto asi format sizes successive elements 
bytes shown fig shown fig icmp packet struct includes -byte fields uint icmp type uint icmp code -byte field uint icmp checksum unions icmp hun icmp dun outcome ffe satisfies part specification -byte fields match uint icmp type uint icmp code call sendto size top size top size top size top size top pinger pinger pinger pinger entry pinger pinger size top top pinger exit pinger entry pinger exit catcher entry catcher exit pingermainentry mainexitpinger catcher pinger figure outcome ping hfsm hints program behavior ping packet -byte icmp header data typedefstructicmp uint icmp type type message uint icmp code type code uint icmp checksum complement cksumof struct define icmp cksumicmp checksum union uint pptr icmp paramprob structin addrih gwaddr icmp redirect structih idseq uint icd uint icd seq idseq intih void icmp unreach needfrag --path mtu discovery rfc structih pmtu uint ipm void uint ipm nextmtu pmtu structih rtradv uint irt num addrs uint irt wpa uint irt lifetime rtradv icmp hun define icmp pptricmp hun pptr union structid uint otime uint rtime uint ttime structid structipidi options bits data structicmp addrid radv uint mask char data icmp dun define icmp otimeicmp dun otime icmp figure icmp packet structure -byte field matches uint icmp cksum -byte fields match union icmp hun includes struct idseq consists uint icd uint icd seq union icmp dun discovered asi assignment union code asi partition memory locations union corresponds signal outcome ffe incomplete respect shown fig lines ping calls signal library function signal asynchronous event handling means statically generated control-flow graph cover flows control technique based cfg statically generated codesurfer output operations apvoid signal sitint finish void signal sigalrm catcher preload-pinger options flood catcher struct sockaddr register int size fromlen options flood floodok floodok pinger figure code fragment ping pear handler function signal call establishes resultant hfsm over-approximate outputs related work previous work reverse engineering file formats dynamic manual eilam describes strategy deciphering file formats symbol table sample output file approach requires manually stepping disassembled code inspecting memory contents debugger program produces file approaches ignore program rely heuristic generalization sample output files reverse-engineering case study searched zlib-compressed data file names length bytes typical structures approaches require considerable manual effort guarantee chosen sample files sufficiently general constrast static approach over-approximates file format relying sample files symbol tables extensive manual analysis human intervention needed identify output functions assign higher-level interpretations file selected fields identified analysis similar attempts statically recover information program data christensen presented technique discovering values string expressions java programs context-free grammar generated constructing dependence graphs class files grammar widened regular language strings dynamically generated method christensen applied low-level code christodorescu method string analysis executables approach similar sense executables targets tools recovered output data format analysis represented regular language denotes superset actual output language approach sense initial context-free structure recovered tool structure operations purely internal procedure call-return structure program tool approach related work host-based intrusion detection models expected program behavior constructed model over-approximates sequences system calls comparing actual sequence system calls allowed model detect malicious input hijacked program pushdown-system models employed purpose constructed source code low-level code sparc executables hfsms similar yield context-free languages projection portion program behavior previous work results dataflow analyses vsa asi elaborate models information sets values sizes conclusion future work paper focus output operations approach applied kinds operations treat input operations examining parsing input file approach paper case paths exit points represent successful runs program correspond successful well-formed input files addition apply approach network communication operations parse construct packets suggested referees characterization input language generate test inputs similarly knowledge output language component tool chain source test inputs component chain discussion ping signal calls factor hfsm overapproximate actual output language program description static-analysis tool handle features paper mops approach mops hfsms mentioned earlier assume output functions identified user create automatic tool extracting data formats desirable find automatically identify output functions wrapper functions loop hfsm transformed node-set node-set cases bound number iterations loop obtained vsa cases information loop iteration bounds provide users precise information output format basic file format ico files http daubnet formats ico html compress spec benchmark http itee emmerik specbench html cpio gnu project http gnu software cpio cpio html file format reversing everquest vpk http openrce articles full vew flex http gnu software flex gzip gnu project http gzip ping http packages debian stable net netkit-ping png ico http winterdrache freeware png ico tar gnu project http gnu software tar tar html freebsd linux kernel cross http fxr watson fxr source netinet icmp gzip file format specification version http gzip zlib rfc-gzip html alur benedikt etessami godefroid reps yannakakis analysis recursive state machines toplas alur yannakakis model checking hierarchical state machines fse pages balakrishnan reps analyzing memory accesses executables balakrishnan reps recovery variables heap structure executables tech rep trcomp sci dept univ wisconsin madison sept chen wagner mops infrastructure examining security properites software ccs christensen ller schwartzbach precise analysis string expressions sas christodorescu kidd goh string analysis binaries paste eilam reversing secrets reverse engineering wiley publishing giffin jha miller detecting manipulated remote call streams usenix security symposium giffin jha miller efficient contextsensitive intrusion detection ndss ramalingam field tip aggregate structure identification application program analysis popl pages reps balakrishnan lim next-generation platform analyzing executables aplas reps balakrishnan lim intermediaterepresentation recovery low-level code pepm wagner dean intrusion detection static analysis ieee symposium security privacy 
lookahead widening denis gopan thomas reps wisconsin grammatech gopan reps wisc abstract present lookahead widening technique existing widening narrowing operators improve precision static analysis technique self-contained fully-automatic sense rely separate analyzes human involvement show integrate lookahead widening existing analyzers minimal effort experimental results technique achieve sizable precision improvements reasonable costs introduction abstract interpretation general framework static analysis verification software abstract interpretation collecting semantics program expressed fix-point set equations equations solved abstract domain chosen based desired precision cost typically equations solved iteratively successive approximations solution computed converge fix-point abstract domains analyzing numeric properties intervals octagons polyhedra chains approximations long infinite make domains abstract interpretation extrapolation technique called widening widening attempts predict fix-point based sequence approximations computed earlier iterations analysis typically widening degrades precision analysis obtained solution fix-point post-fix-point necessarily fix-point obtained solution post-fix-point refined computing descending approximation sequence converges necessarily fix-point chain approximations long infinite ensure convergence fixed finite number descending iterations performed counterpart widening called narrowing widening narrowing sufficient precise results loops regular behavior illustrate loses precision complex loops paper present approach existing widening narrowing operators improve precision numeric program analysis idea approach separate loops phases simpler behavior apply existing analysis methods individual phases offers supported onr nsf ccrand ccfin paper term regular sense ordinary usage consistent action orderly predictable mathematical sense formal-language theory opportunity obtain results phases loop regular behavior lost considered simultaneously practice achieve effect propagating abstract values analysis current loop phase decide program conditionals widened compute solution current phase widening narrowing applied stabilizes promoted allowing analysis advance phase refer main solution analysis converges pilot previews behavior program paths analysis restricted technique called lookahead widening point view main pilot determines suitable extrapolation sampling analysis future show implement lookahead widening practice integrated existing analyzers minimal effort idea implementation construct arbitrary abstract domain intervals octagons polyhedra abstract domain implements technique constructed domain directly plugged existing analyzers guarantee analysis converges impose minor restrictions iteration strategy employed analyzer properties widening operator base domain major benefit implementation directly analyzers equipped computing descending iteration sequences situation arises capability model numeric properties added existing symbolic analyzer present experimental results obtained applying prototype implementation technique handful benchmarks appeared recently literature widening lookahead widening improves precision half benchmarks present experimental results on-going work weighted pushdown systems numeric program analysis lookahead widening framework allowed establish tighter loop invariants loops selected set benchmarks overheads ranging contributions paper make contributions present technique lookahead widening existing widening narrowing operators improve precision static analysis technique self-contained fully-automatic show implement lookahead widening practice integrated existing analyzers minimal effort present experimental results obtained prototype implementations lookahead widening results suggest lookahead widening improves analysis precision modest cost word pilot sense sitcom pilot television industry true y-if break fig running loop non-regular behavior control-flow graph program set program states points integer coordinates lie dark upside-down precise set concrete states gray triangle approximation set polyhedral domain single program state reaches paper organization paper organized introduces basic concepts presents running describes lookahead widening addresses implementation issues presents experimental results discusses related work preliminaries section briefly introduce concepts paper due space limitations assume reader familiar abstract interpretation standard widening narrowing discussion topics assume widening points selected bourdoncle technique assume weak topological order wto computed nodes program control-flow graph cfg widening performed heads components wto defines concept important paper recursive iteration strategy requires analyzer stabilize analyzed wto component proceeding cfg nodes component examples paper abstract domain polyhedra running program fig running fig illustrates results applying solver incorporates standard widening techniques program brevity ofthe programpoints shown widening performed node iterations iteration analysis converges post-fix-point descending structuredprograms componentsdefinedbya wto correspond toprogram loops cfg ascending iterations descending iterations node iteration iteration iteration iteration fig standard analysis trace widening performed node join point polyhedra joined shown dark gray result shown light gray iteration sequence converges iteration recovers precision lost application widening iteration recover precision lost application widening iteration lookahead widening start explaining weaknesses standard approach technique aims overcome loop fig explicit phases phase iterations variables incremented phase iterations variable incremented variable decremented loop behavior phase regular captured precisely standard widening narrowing loop behavior non-regular shown standard approach yields imprecise solution limitation standard approach manifested beginning iteration point analysis application widening yields overapproximation behavior phase loop upper bounds discovered result analysis starts exploring phase loop imprecise initial assumptions fig syntactic program restrictions program fig omitted cfg nodes edges shown gray dashed restriction corresponds loop phase restriction consists loop phases loop exit edge solution restriction solution restriction solution restriction shown fig effect propagating precision loss incurred phase column fig shows descending iteration sequence fails recover lost precision general idea technique improve precision analysis obtaining precise solution loop phase proceeding intuitively envisioned applying standard analysis techniques finite sequence syntactic restrictions analyzed program eventually converge entire program result obtained program restriction starting point analysis restriction sequence fig illustrates process running fig shows programrestrictionthat considered note restriction corresponds phase loop fig shows solution node obtained restriction standard method fig shows restriction program restriction encompasses loop phases include edges lead loop analysis starts values obtained restriction yields solution shown fig precise invariant loop polyhedral domain final restriction consists entire program fig applying standard analysis methods restriction yields node solution shown fig fix-point polyhedral domain set equations generated program fig idea leads superior results hard implement practice obvious automatically derive program restrictions correspond loop phases remainder section show implicitly confine analysis individual loop phases implement technique directly integrated existing analyzers minor implementations approximation loop phases explicitly derive syntactic program restrictions technique approximates behavior specially designed abstract guide analysis program analysis propagates pair abstract values referred main decide conditional points paths explored referred pilot compute solution paths widening narrowing applied pilot intuitively main restricts analysis loop phase pilot computes solution pilot stabilizes update main essentially switching analysis syntactic restriction sequence arbitrary abstract domain set domain elements partial order denote upper bound operation greatest element element respect widening operator narrowing operator set monotonic abstract transformers edges program cfg construct abstract domain dla dla element pair elements main pilot pilot equal main overapproximate main pilot bottom add special element represent bottom domain dla negationslash 
top element domain defined trivially abstract transformers applied elements pair make main guide analysis program application transformer main yields bottom make entire operation yield bottom braceleftbigg define partial order domain lexicographic order pairs defines ordering accommodate decrease pilot strict increase main giving appearance increasing sequence join operator induced applied pairs incomparable main values sets pilot equal main result suitable technique joins loop heads incomparable values typically combined lose information accumulated pilots overapproximation join operator defined component-wise join definition widening operator encompasses essence technique main left intact pilot ascending phase descending phase promoted main stabilization conceptually widening operator defined pilot ascending pilot descending pilot stabilized direct implementation definition requires analyzer modified detect pilot ascending mode descending mode stabilized short phases possibility main exits phase pilot stabilizes case pilot switched ascending mode global properties modifications required depend heavily implementation analyzer implementation route describe section practical implementation simplify integration technique existing analyzer impose analyzer underlying abstract domain restrictions check locally globalproperties defining widening operator analyzer restriction analyzer follow recursive iteration strategy analysis stay wto component values component stabilize abstract domain restriction abstract domain possess stable widening operator imply implementation utilize narrowing operators computes equivalent single descending iteration loop phase simplification reasonable meaningful narrowing operators defined abstract domains experimental evaluation encounter examples significantly benefited longer descending-iteration sequences define widening operator case ensures widening operator stable case checks pilot stabilized promotes main note reducing dependence spki pilot sdsi pki promoted hao wang somesh jha thomas reps stefan obtained schwoon stuart propagating stubblebine loop collect wisconsin madison effect loop hbwang conditionals jha reps wisc possibly-descending iteration universit performed stuttgart germany case schwoosn incorporates fmi pilot uni-stuttgart ascending sequence main values joined pilot values widened soundness easy results obtained technique sound considerthe operationsthat applied mainvalues stubblebine precisely mimic research labs operations stuart stubblebine standardapproachapplies abstract trust-management widening systems address computed differently authorization problem distributed application systems offer decreases main advantages values main approaches values support stabilize delegation analysis making authorization terminate decisions obtained results decentralized guaranteed manner nonetheless sound trust-management convergence systems keynote show spki standard sdsi analyzer limited deployment constructed real accordance world reason principles outlined systems employs require dla public-key abstract infrastructure domain pki converges authentication pki recursive proven iteration difficult strategy deploy limit user attention required manage single wto component private public key show pair key insight analysis work converges issuance arbitrary certificates component trust-management systems converge task entire requires program public-key focus cryptography head achieved arbitrary secret-key component cryptography demonstrate widening concept applied showing stabilization spki checked sdsi modified show kerberos pilot secret-key based promoted authentication system entire issue component spki stabilizes sdsi certificates finite number resulting iterations trustmanagement system retains rely capabilities property spki sdsi recursive-iteration strategy easier stabilization public component key detected required stabilization spki sdsi server head longer theorem user main kerberos slow ascending established sequence approach makes time spki analysis sdsi-based trust restricted management subset systems easier component deploy body real world introduction pilot authorization central accelerated problem ascending distributed sequence environments resources underlying widening shared operator users defined correctly administrative converge domains finite number trustmanagement iterations systems designed detects address stabilization authorization pilot problem ascending distributed sequence environments encountering answer pilot question principal allowed equal perform operation pilot shared resource previous iteration existing trust-management widening systems operator stable keynote spki application sdsi widening rely heavily change public-key previous pilot infrastructure pki note pki produce postfix-point digitally-signed certificates restricted component authorize principal result perform propagating operation shared postfix-point resource pki-based restricted systems component proved difficult deploy postfix-point practice scenarios reasons considered issues main naming addressed stabilized trust-management systems case keynote spki sdsi entire user component required possess stabilizes due public-private stability key pair main cumbersome securely transport stabilized retrieve case private keys complexity postfix-point pki promoted issue main makes pki-based systems show difficult deploy finite number implementing promotions pki-based supported occur nsf argument grants based ccfand number edges ccrand onr cfg depending grants cfg strictly edges speaking spki component sdsi body brought considered consideration trust-management system promotion pilot definition blaze main scenarios processing certificates edges standardized brought application specific consideration context analysis paper stabilizes assume iteration certificate processing main spki sdsi pilot standardized postfix-points spki sdsi component alternatively trust-management system cfg solutions edges requires in-depth knowledge iteration pki iteration modification iteration existing iteration systems iteration issues mentioned trust-management systems desirable authorization distributed environments offer advantages traditional centralized authorization systems trust-management system spki sdsi conceptual requirement central authority ability make authorization decisions distributed fashion scalable important requirement distributed fig systems spki lookahead-widening sdsi analysis trace simple wideningis applied noden supports main delegation values simplifies shown access dark control gray light locally gray defined extent spaces pilot user define main pilot security values policies promoted introduce technique reduce iterations dependence consideration trust-management case systems process pki previous easier paragraph deploy starts anew real-world eventually leading observethat main promotion pkiin body trust-managementsystems component digitallysign finite certificate edges private key brought principal consideration issues finite number certificate times key work finite number signing process promotions achieved analysis component secretkey-based systems converges revisiting running notion illustrate secret-key technique cryptography place lookahead widening public-key applying cryptography building running block fig security shows operations trace studied abstract previously operations performed analysis distributed due military space constraints banking systems show abstract values knowledge accumulated work program points interest apply technique iteration context identical trust-management standard systems approach specifically shown spki fig sdsi differences utilizing existing manifested secret-key-based systems iteration widening widely operator propagates deployed reduce unmodified main dependence applies trust-management widening systems pki pilot end users node longer note pilot public-private key pairs filtered conditional approach site edge distributed environment contrast fig dedicated trust-management abstract state server sole purpose issue digitally-signed iteration certificates unbounded band server running possesses public-private key pair users site authenticate server secret key server issues digitally-signed certificates behalves solution server site public-private key pair opposed traditional trust-management systems principal possess public-private key pair kerberized spki sdsi server certificates certificates certificates certificates issued bob charlie original spki sdsi system kerberized spki sdsi system charliebobspki sdsi site spki sdsi site certificate encrypted requests kstkstkb kckb kst fig reducing spki sdsi dependence pki kerberos paper focus trust-management system spki sdsi show reduce dependence pki kerberos widelydeployed secret-key-based authentication system approach authenticated kerberos users northeast iteration pilot reaches node smaller pilot stored iteration pilot promoted main corresponds solution loop phase fig iteration progresses analysis starts exploring cfg edges brought consideration promotion essence analyzing program restriction fig fourth iteration widening operator applied pilot note pilot filtered conditional edge iteration pilot promoted analysis proceeds fashion standard analysis converges iteration analysis obtains precise abstract values program points shown figure implementation notes accumulating analyzers analyzers computing abstract cfg node join values coming predecessors unionsqtext analyzers accumulate abstract joining single abstract contributed predecessor stored wpds implementation weighted pushdown systems main target integrating technique model challenge analyzer design poses lookahead widening pilot promoted directly main applying previous section sound update pilot promoted main lose contribution predecessors instance fig iteration accumulating analyzer attempt widen identity transformation edge pilot strictly smaller pilot qualifies promoted promoting result unsound main point excluded lookahead widening setting slightly redefine widening operator accumulating analyzers making decisions promotion join pilot main stored node makes pilot account values propagated incoming edges widening operator defined runaway pilots loops loop phases consist small number iterations analysis exit loop phase pilot stabilized instance condition if-statement running changed pilot widened contrast analyzers update join values predecessors promotion pilot laf account contributions predecessors iteration effectively filtered conditionals contribution path node enabled main result analysis propagate pilot larger desired lead loss precision future promotions refer problem runaway pilots approach alleviating problem perform promotion indirectly replacing main pilot apply widening main values symbolic issue spki sdsi certificates kerberized spki sdsi server k-spki sdsi accepts certificate requests authenticated kerberos users generates spki sdsi certificates behalves original spki sdsi system shown figure principal ability issue certificates auth certificates signed public-private key contrast solution shown figure user longer public-private key pair site dedicated kerberized spki sdsi server public-private key responsible signing certificates issue spki sdsi certificate user authenticates local kerberos server obtains secure communication channel k-spki sdsi server user issue certificates form certificate requests public-private key pair certificate requests user secure channel k-spki sdsi server creates signs certificates signed certificates stored k-spki sdsi server back user depending configuration system case newly issued certificates back user system operates identically original spki sdsi system certificates stored locally authorization decisions made locally certificates server server act repository certificates issued users domain repositories organize certificate-chain discovery centrally distributed manner leaving burden certificate management completely server technique offers tangible benefits end-users system authenticate dedicated trust-management server secret keys rids trust-management systems requirement principal possess public-private key pair secret keys authenticate users dedicated server secret-key cryptography widely deployed solution present make easier deploy pki-based trust-management systems addition small change required end-user level deploy solution kerberos application pass optional parameter kerberos library function kuserok k-spki sdsi server perform authorization check finally dedicated trust-management server public-private key pair solution retains advantages trust-management systems delegation distributed authorization contributions paper show make spki sdsi easier deploy real world reducing dependence pki leveraging kerberos secret-keybased system widely deployed approach synthesizes benefits secret-key-based authentication systems kerberos pki-based trust-management systems spki sdsi utilize kerberos proven authentication framework retaining spki sdsi elegant distributed authorization feahere kerberize means modify spki sdsi server kerberos library tures delegation authorization proofs local spaces distributed certificate-chain discovery created prototype implements technique paper preliminary report implementation performance background spki sdsi section readers knowledge spki sdsi choose skip section method combining spki sdsi kerberos section section discusses deployment performance issues prototype section discusses related work background spki sdsi spki sdsi public-key infrastructure designed address authorization problem distributed systems spki sdsi principal individual process host entity principals represented public keys principal public key denote set public keys specific keys denoted identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates spki sdsi types certificates certs certificates certs cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification certificate takes form interval cert valid time inclusive authorization certificates auth certs auth cert grants delegation privileges specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert subject term delegation bit turned subject receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert certificates rewrite rules labeled rewrite rule triple terms authorization specification authorization specification authorization specifications write simply rewrite rule form implicit label treat certs labeled 
rewrite rules cert written labeled rewrite rule auth cert willbe written square squareif delegation bit turned written square squaresolid note authorization problems valid certificates pre-processing step check validity specification certificate rest paper assume valid certificates considered authorization proofs labeled rewrite rules paper refer rewrite rules simply rules term appearing rule viewed string alphabet elements beginning uniformity refer strings form square squaresolid terms assume labeled rewrite rule corresponds auth cert term case labeled rewrite rule applied term denoted yields term rule viewed function terms terms rewrites left prefix argument bob bob myfriends myfriends rules addition assume prefix exists concretization composition rule pilot set constraints memory usage abstract states shown fig suggest main rules pilot friends equal bob myfriends running bob holds abstract states composition arise friends iterations myfriends analysis rules half abstract states called arise compatible implementation composition improve memory usage detect situation defined store certificate single chain sequence pair values certificates pilot label equal certificate main chain delayed widening denoted interesting label implementation obtained detail interaction kerberizing lookahead spki widening sdsi commonly section technique explain called delayed reduce widening idea dependence spki delayed sdsi widening pki avoid utilizing applying secret-key-based widening authentication operator system kerberos iterations introduce loop predefined constant section abstract states issue accumulate intersection explicit union constraints authorization specifications discussed widening operator general generalize composition loop operator behavior found associative practice reset exists delayed-widening counter promotion expressions pilot equal resetting defined omit parentheses assume associative illustrate original spki sdsi system works finally section describe analysis perform reliance spki widening-free sdsi iterations beginning pki phase experimental reduced results experimented kerberos assume implementations reader lookahead widening familiar kerberos implementation detailed built description small kerberos intraprocedural analyzer suppose implementation built sites bio off-the-shelf correspond weighted-pushdown-system solver biology wpds computer science cases departments incorporation lookahead widening professors required alice bob analysis engine bio implementations collaborating polyhedral project bob abstract domains delegate built alice full parma access polyhedral rights library shared intraprocedural implementation applied implementation number small benchmarks appeared recent papers widening benchmarks test work policy iteration astree examples motivate threshold widening human-assisted widening technique phase running merge program merges sorted arrays lookahead widening essentially makes round descending resourcer iteration addition alice wto plans component delegate controlled access rights effect resource experiments students comparing lookahead involved widening slight project modification allowing standard delegate widening approach rights standard bobx alice wto ycs component bio stabilizes single descending kalicestudents iteration applied kalicestudents kbobsquare modified analysis converged alicesquare kalicesquare weighted kalice pushdown systems studentssquaresolid fig default distributed support authorization widening spki made sdsi authorization engine spki make sdsi widening-aware section program vars describe loops spki depth sdsi standard authorization lookahead works overhead improved distributed steps environment lfp steps lfp steps precision components test spki sdsi authorization test scenario denoted test circled numbers figure test certificate issuance figure test user issues auth test certs test bob delegates access rights test resource alice test issuing auth cert test signed private key astree kbob square kalice square astree alice grants phase 
merge table intraprocedural implementation results columns labeled steps number node visits performed lfp analysis obtains leastfix-point solution determine fix-point benchmark improved precision reports percentage important program points analysis lookahead widening yielded smaller values increase precision important program points include loop heads exit nodes benchmarks yielded solutions precise precise obtained standard analysis exception test results program points incomparable standard technique tab shows results obtained determine least-fix-points ran analysis applying widening results lookahead widening achieved higher precision strengthened standard approach half benchmarks cost running lookahead widening extremely high peaking extra node visits test space constraints limit discussing benchmarks astree inequation loop condition assume inequation negationslash hard express abstract domains rely convexity modeled replacing cfg edge edges labeled labeled application widening extrapolates upper bound descending iterations fail refine bound contrast lookahead widening obtain precise solution main widening applied forces analysis follow edge pilot picks students constraint access issuing promoted wpds implementation certs wpds auth implementation cert signed determine linear alice relations private registers key executables kalice codesurfer students kalice extract students pushdown system kalice square executable contents kalice memory students squaresolid modeled reads memory certs state handled conservatively andy students program alice push-down auth cert states students access resource system authorization time sec specification overhead delegate access assume student access site bio authorization specification perform steps certificate-chain discovery figure request access resource user performs certificate-chain discovery obtain proof access resource achieved executing distributed certificatechain-discovery algorithm algorithm finds authorized returns proof form finite set certificate chains chm student initiates distributed certificate-chain discovery involve alice bob distributed returns singleton set chains certificates kbob square kalice square kalice square kalice students squaresolid kalice students requesting resource figure user obtains set certificate chains sch chm previous step presents sch owner resource refers owner authorizes iff uniontextmi chi step called compliance checking making request kbob square resolve kxsquare kxsquaresolid authorization specification student presents kbob kbob checks true grants access resource authorization kerberized spki sdsi notice spki sdsi user public-private key pair section describe reduce spki sdsi dependence pki distributed authentication system kerberos spki sdsi implementation key insight work certificate issuance process spki sdsi achieved secret-key-based systems kerberos spki sdsi certificate signed issuer private key signature serves proof authenticity certificate secret-key-based system kerberos authentication process produces evidence user evidence employed user issue certificates kerberos authenticated user obtains token called ticket granting ticket tgt digital evidence user token obtain secure communication channel kerberos services approach kerberized spki sdsi server site authenticated kerberos user securely issue certificate requests kerberized spki sdsi server essence approach relaxes spki sdsi binding requirement user identified public key principal kerberos principal kerberos realm approach spki sdsi user longer public-private key pair require public-private key pair site spki sdsi server system called k-spki sdsi short kerberized spki sdsi system spki sdsi site runs kerberized spki sdsi server k-spki sdsi shares public-private key pair kerberos key distribution center kdc site public-private key site denoted kst describe components authorization scenario setting figure illustrates high-level idea approach certificate issuance figure issue k-spki sdsi certificates kerberos user authenticates local kdc standard kerberos authentication protocol receives ticket granting ticket tgt spki sdsi kerberized server spki sdsi kerberized server xyalice bob bio alice students bobsquare alicesquare kbio bobsquare kbio alicesquare kcs alice students kcsx kcs alice students kcsy kcs square kcs alice studentssquaresolid fig reducing spki sdsi dependence pki kerberos dashed lines represent secure kerberos communication channels kdc tgt user requests service granting ticket sgt accessing kerberized spki sdsi k-spki sdsi server rest section assume user obtained sgt spki sdsi server site sgt user issues requests generating spki sdsi certs auth certs session key provided sgt protect integrity confidentiality requests communication channel issue auth cert user site sends cert request eks encrypted session key sgt k-spki sdsi server user subject delegation bit authorization specification validity information receiving encrypted auth-cert request k-spki sdsi server ascertains validity auth cert valid creates k-spki sdsi auth cert form kst kst signs private key newly issued certificates stored k-spki sdsi server authorization efficiently fully emulate spki sdsi certs back users requested scenario authorization carried original spki sdsi notice auth cert public key kst site added bob sends encrypted appropriatesession key obtained sgt k-spki sdsi server sbio bob square alice square auth cert states bob delegates full access rights resource alice k-spki sdsi server sbio verifies encrypted auth certs shown creates signs k-spki sdsi auth cert kbio bob square kbio alice square issue cert user site sends encrypted name-cert request eks k-spki sdsi server auth cert identifier validation step issuing auth certs request validated k-spki sdsi server creates cert form kst kst signs private key similar auth certs certs stored k-spki sdsi server back users requested write cert alice sends certs auth cert figure encrypted session key k-spki sdsi server site k-spki sdsi server verifies encrypted certs creates k-spki sdsi certs signs figure notice left-hand sides k-spki sdsi certificates symbols left-hand side extended auth cert form squareor squaresolid public key site user left-hand side extended cert form identifiers spki sdsi left-hand sides auth certs symbols translation user certificate requests actual certificate automatically special case left-prefix rewriting primitives generalize arbitrary left-prefix rewriting systems covers case k-spki sdsi certs left-hand-side symbols alice students kcs alice students kcs alice students kcs alice students kcs alice square alice students squaresolid kcs alice square kcs alice students squaresolid name-cert requests k-spki sdsi certs fig issuing spki sdsi certificates k-spki sdsi user-issued certificates spki sdsi site exchange public key spki 
sdsi sites represented certificates site bio issue certificate kbio kcs certificate chain discovery figure suppose useru site wishes access resource site access rights initiates certificate-chain discovery algorithms case certificates stored k-spki sdsi servers distributed algorithm search successful returns set certificate chains sch site prepare proof authorization present owner sch proves user site access assure owner possibly resides site requesting user sends sch sends back kerberos tokens tokenu eks ticketu ticketu ekst sch lifetime kst session key fresh secret keys generated kst denotes data signed intuitively tokenu makes key ticketu sch proof authorization access site access type user site signing message site confirms possession key notice implicitly contained sch omitted practice assume student receives token set certificate chains sch certificate chain notice kbiobob square kcs square kcs squaresolid kbio bob square kbio improved instr coverage stack push pop std precision sym level ahead speex gzip grep diff plot graph calc table wpds implementation results instr lists number instructions program coverage portion program analyzed stack symbols correspond program points roughly stack symbols basic block same-level rules correspond intraprocedural cfg edges basic blocks push rules correspond procedure calls pop rules correspond procedure returns reported times wpds poststar operation precision improvement percentage loop heads solution improved lookaheadwidening technique chose ignore unresolved indirect calls jumps result portion program analyzed applied implementation number gnu linux programs compiled cygwin lookaheadwidening technique compared standard widening descending iteration sequence applied required major redesign wpds solver tab presents results obtained lookahead widening improves precision analysis benchmarks runs overhead related work improving widening operators research direction design precise widening operators widening operators capturing constraints present arguments approach orthogonal technique lookahead widening benefit availability precise base-domain widening operators widening limited widening technique widening point augmented fixed set constraints obtained application standard widening operator restricted constraints satisfied arguments widening operator well-chosen set constraints technique powerful number heuristics deriving constraint sets principle propagation pilot technique viewed automatic collect propagate constraints widening points alternatively constraint sets derived external analysis heuristic lookahead widening utilize applying widening pilot values beneficial lookahead widening break loop simpler phases instance loop non-deterministic conditional new-control-path heuristic heuristic addresses imprecision due loop behaviors loop iterations detects paths loop body explored analysis iteration case application widening delayed captured relationships evolve widening applied heuristic handles introductionof loopbehaviorswell doesnot cope complete loop behavior improve analysis precision running lookahead-widening technique viewed extension application widening delayed control paths solution explored control paths refined computing descending iteration sequence policy iteration technique abandons chaotic iteration altogether favor equation-solving strategies technique guaranteed find alice square kcs alicesquare kcs alice students squaresolid kbio kcs kcs alice precise students kcs solution requesting search carried resource figure policy space appears receiving tokenu expensive user decrypts approach eks requires building retrieves dedicated analyzers session key contrast technique constructs easily integrated kerberos existing authenticator analyzers authenticatoru bagnara hill lifetime ricci user sends zaffanella message precise ticketu widening operators authenticatoru convex owner polyhedra resource sas site bagnara ricci requests zaffanella local k-spki sdsi hill server possibly verify closed convex message polyhedra server parma performs polyhedra library steps decrypts sas blanchet message ekst cousot cousot private feret key mauborgne retrieves min decrypts monniaux part ticketu rival encrypted design implementation obtains special-purpose public static key program kst analyzer verifies safety-critical signature real-time embedded software ascertains freshness essence validity computation token complexity analysis time-stamp transformation springer-verlag lifetime lifetime bourdoncle checks efficient chaotic sch iteration strategies proves widenings desired formal access methods similarly prog k-spki sdsi server appl ascertains costan validity gaubert goubault authenticator martel making putot policy sender iteration algorithm user computing notice fixed points server static analysis session key programs ticketu cav steps cousot verification successful abstract k-spki interpretation sdsi server symp sends message verification indicating cousot granted access cousot abstract interpretation unified lattice communication protected model key static analysis programs construction approximation fixed points popl cousot halbwachs automatic discovery linear constraints variables program popl halbwachs proy roumanoff verification real-time systems linear relation analysis fmsd kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds mine octagon abstract domain wcre nielson nielson hankin principles program analysis springerverlag reps sagiv yorsh symbolic implementation thebest transformer vmcai pages 
analysis correctness protocol key idea work rely kerberos provide secure channel users submit spki sdsi certs auth certs signed stored site contrast original spki sdsi system user issue sign certs note conceptual difference approaches underlying security mechanisms secretkey cryptography public-key cryptography original spki sdsi approach user issues cert subscript denotes cert signed user private key comparison step approach implemented issuing certificate request denotes name-cert request encrypted session key shared user k-spki sdsi server request validated translated k-spki sdsi server actual certificates signed k-spki sdsi server private key cases possession secret spki sdsi kerberos digital links certs issued user issued actual content authenticator irrelevant trade offs previous work shown secret keys place public keys implement security objectives building secure broadcast-communication channel pros cons approach secret-key-based system simpler set secret-key-based systems require communication parties online function properly sending message kerberos users requires sender receiver active time exchange secret encryption key hand publickey-based systems operate ine mode send message pki sender simply encrypt messageusing recipient public key contacting recipient key management major issue hindered wider acceptance pki-based systems cumbersome maintain public-private key pairs approach eliminates public-private key pairs individual users k-spki sdsi server dedicated public-private key pair signing spki sdsi certificates users secret keys communication server requesting certificates chose hybrid approach reasons pki authorization mechanism spki sdsi lends ine checking certificate chains user requesting access resource presents set certificate chains owner resource architecture spki sdsi ensures owner check validity chains contacting owners keys involved chains fact verifying identities worth noting adopting ideas lampson davis swick emulate spki sdsi secret keys scheme ine checking certificates communication users servers online motivates secret keys context finally certificates issued users stored spki sdsi servers approach combined distributed certificate-chain algorithm presented threat analysis message exchange requesting resource similar exchange messages client kdc kerberos essence ticket ticketu states tokenu encrypted user sgt issued assuming authentication kerberos correct adversary replay message ticketu authenticatoru resource masquerade attack fails communicate unknown attacker extension pki-based trust-management systems trust-managementsystems havedifferent logicsto expresssecurity policies components auth certs spki sdsi security policies signed principals private keys recall protocol essentially server sign statements behalf authentiunless sides previously agreed shared secret key keynote-version local -constants alice dsa authorizer rsa abc licensees alice conditions app domain rfc -email address labs signature rsa-sha fig keynote credential line represents alice public key keynote-version local -constants alice kerberos alice labs authorizer rsa abc licensees alice conditions app domain rfc -email address labs signature rsa-sha fig keynote credential requiring alice public key cated user explained protocol spki sdsi clear trust-management systems demonstrate protocol extended trust-management system keynote figure shows keynote credential grants rights rfc -email alice public key dsa line achieve goal technique shown figure approach credential states alice authenticated kerberos user kerberos identity alice labs rights credential noted credentials similar operational semantics original keynote alice delegate rights received issuing credentials directly compliance checking kerberized scenario alice longer public-private key pair delegate rights authenticating kerberos issue delegation request dedicated kerberized keynote server cases authorizer line represents public-private key kerberized keynote server implementation evaluation built prototype system evaluate approach implementation mit kerberos distribution version distributed spki sdsi library based model checker weighted pushdown systems test environment certs auth certs distributed sites site runs dedicated machine local area network test machines identical configurations mhz pentium iii ram running tao linux version evaluated approach criteria ease deployment performance implementation prototype deployed system real-world environment evaluated prototype simulated environment synthetic data summarize results based criteria ease deployment steps required deploy system assuming kerberos installed install public-private key pair approach public-private key pair needed kerberos site addition sites exchange public keys reasonable requirement exchange alternatively public keys obtained demand existing solutions public-key exchange install k-spki sdsi server kerberos site spki sdsi server k-spki sdsi server implemented kerberos service require kerberos setting secret key kdc k-spki sdsi server enhance kerberos clients kerberos clients advantage distributed authorization features updated easily library call access k-spki sdsi server performance tested implementation model certificates stored k-spki sdsi servers distributed algorithm certificate-chain discovery results section experiments performance distributed authorization highly dependent k-spki sdsi certificates distributed sites distributed certs sites needed resolve authorization queries longer takes process authorization query study distributed authorization performed test environment certificates kerberos sites process complex authorization request half long process simple prototype implementation plenty opportunity optimizations improve performance notice issue slightly orthogonal issue integrating spki sdsi kerberos certificate-chain discovery locally ease deployment objective work make spki sdsi potentially pkibased trust-management systems reliant pki easier deploy real world achieve means spki sdsi reliance pki reduced authentication provided existing infrastructures kerberos proven approach make spki sdsi fit existing systems seamlessly introducing substantial presentan impediment adoption deploying system 
environments kerberos installed requires small terms implementation minimize kerberos result additional complications deployment achieved goal implementing k-spki sdsi server independent unit changing kdc result implementation requires kdc minor modification kerberos library approach drawbacks separate server clients modified provided features change simple alternative provide functionalities inside kdc kerberos client requests sgt service kdc automatically performs authorization query behalf client stores authorization token part sgt approach makes authorization process transparent clients require kdc technique adding authorization support inside kerberos evaluating approaches addition deploying system site install public-private key pair site send public key sites plans collaborate reasonable requirement setting collaboration administrative task collaborating site performance evaluated performance system simulated distributed environment algorithm considered performance distributed authorization issuing certificates infrequent administrative task simulated test environment consisted kerberos sites shown figure node graph represents kerberos site nodes symbol represent service kerberos users access illustrate certificates experiments shown site distributed environment kerberos site stores certificates resolving authorization request involve multiple sites depending k-spki sdsi certificates distributed instance figure manager site gov attempts access resource nsf sites involved distributed authorization solid arrow contrast alice access resource multiple sites dashed arrows participate distributed authorization expect number sites involved distributed authorization important factor performance reason tested distributed authorization scenarios types arrows figure table shows results experiments expected number sites involved distributed authorization direct impact performance system complex case alice kerberos sites involved resolving authorizationrequest long time required simplest case manager gov sites involved prototype expect improve performance future optimizing code test setup extreme changed function kuserok called evaluates kerberos principal allowed login host change option callers function k-spki sdsi server check authorization nsf knsf square knsf programs squaresolid knsf kedu knsf square kgovsquared kedu programs kedu schools faculty kedu schools kwisc schools gov kgov square govprograms squaresolid kgov programs kgovmanager wisc kwisc schools kuw kuw faculty kuwchancellor kuw faculty kls faculty kls faculty kcs faculty kls faculty kbio faculty cskcs faculty kcsalice bio fig test setup certs auth certs shown due space constraints case kerberos site physical kdc practice logical kerberos sites share single physical kdc improve performance reducing communication overhead table distributed authorization performance results scenario sites request time manager gov fundb apply chancellor squiggleright funda apply alice funda apply related work key idea approach secret-key cryptography implement spki sdsi operations issuing certificates level security public-key cryptography notion secret keys place public-private key pairs building block security operations proposed lampson showed relay agent trusts kerberos kdc build public-key-style secure communication channels idea extended davis swick build public-key-style security protocols secret keys work idea applies context pki-based trust-management systems specifically spki sdsi leveraging advantages kerberos public-key infrastructure pki explored pkinit pkcross pkda extend kerberos public-key cryptography authentication purposes work goal targeted authorization authentication goal kerberos reduce dependence spki sdsi pki approaches require modifications kerberos infrastructure approach k-pki addresses problem accessing kerberos services pkibased systems web applications k-pki special kerberos server kca generate short-term certificates authenticated kerberosclients client web applications authenticates web services generated certificate web services turn obtain kerberos credentials access kerberos services behalf client pki glue kerberos pki world complexity pki systems reduced clients required manage public-private key pairs work hand reduce reliance trustmanagement systems pki individual users longer public-private key pairs aspectofour workisto bring trust management suchasspki sdsi kerberos-based infrastructures previous work extending kerberos authentication framework authorization services work generally assumes centralized authority address cross-realm authorization neuman work restricted proxy closest restricted proxy model building authorization services authorization servers capabilities access control spki sdsi superset restricted proxy offers features distributed trust management dce privilege service ecma sesame microsoft kerberos extension provide authorization capability optional field called authorization data provided kerberos authenticated kerberos principal authorization information group membership security identifiers principal stored field authorization data application serversto check users access privileges systems common drawback unlike spki sdsi rely centralized authority granting access privileges contrast approach spki sdsi require central authority authorization decisions made decentralized manner spki sdsi based public-key infrastructure designed address centralized authority issue conventional pki-based systems spki sdsi framework managing trust form certificates decentralized approach spki sdsi central authority needed principal issue certificates previous work spki sdsi focuses theoretical aspects spki sdsi work spki sdsi adopted real world primarily due difficulty key-management issues pki-based systems work addresses problem reducing spki sdsi reliance pki making kerberos essentially unchanged relying kerberos well-accepted widely system approach make spki sdsi adopted real world easily bauer garriss reiter distributed proving access-control systems proceedings ieee symposium security privacy pages blaze feigenbaum ioannidis keromytis keynote trustmanagement system version rfc sept blaze feigenbaum ioannidis keromytis role trust management distributed systems security secure internet programming security issues mobile distributed objects pages brezak utilizing windows authorization data kerberos tickets access control resources http msdn microsoft library default asp myurl library enus dnkerb html msdn pac asp caucal regular structure prefix rewriting theoretical computer science citi projects kerberos leveraged pki http citi umich projects kerb pki clarke elien ellison fredette morcos rivest certficate chain discovery spki sdsi journal computer security davis swick network security private-key certificates proceedings usenix security symposium september ellison frantz lampson rivest thomas onen rfc spki certificate theory internet society september european computer manufacturers association ecma secureeuropean system applications multi-vendor environment sesame https cosic esat kuleuven sesame html sesame documents html howell kotz formal semantics spki technical report department computer science dartmouth college hanover mar hur tung ryutov neuman medvinsky tsudik sommerfeld public key cryptography cross-realm authentication kerberos nov internet-draft txt jha reps model checking spki sdsi journal computer security jha schwoon wang reps weighted pushdown systems trust-management systems tacas kornievskaia honeyman doster coffman kerberized credential translation solution web access control usenix security symposium pages lampson abadi burrows wobber authentication distributed systems theory practice acm transactions computer systems linn branchaud examination assorted pki issues proposed alternatives proceedings annual pki workshop april neuman proxy-based authorization accounting distributed systems icdcs pages neuman kerberos authentication service computer networks ieee communications magazine september schwoon jha reps stubblebine generalized authorization problems proceedings ieee computer security foundations workshop csfw pages ieee computer society june sirbu chuang distributed authentication kerberos public key cryptography feb open group dce authentication security services 
http opengroup onlinepubs tung neuman hur medivinsky medvinsky wray trostle public key cryptography initial authentication kerberos internetdraft txt 
model checking executables codesurfer wpds balakrishnana repsa kidda lala lima melskia gruiana yonga chen teitelbauma comp sci dept wisconsin bgogul reps kidd akash junghee wisc grammatech melski radu suan chi-hua grammatech abstract paper presents toolset model checking executables members toolset codesurfer wpds path inspector codesurfer extract model executable form weighted pushdown system wpds library answering generalized reachability queries weighted pushdown systems path inspector software model checker built top codesurfer wpds supports safety queries program control configurations introduction paper presents toolset model checking executables toolset builds recent advances static analysis program executables techniques software model checking dataflow analysis approach codesurfer extract model executable reachability algorithms wpds library check properties model path inspector software model checker automates process safety queries involving program control configurations data state tools capable answering queries supported path inspector involve data state illustrate describing custom analyses analyze executable run-time stack work distinguishing features program model extracted executable code run machine means automatically takes account platform-specific aspects code memory-layout details offsets variables run-time stack activation records padding fields struct register usage execution order optimizations artifacts compiler bugs information hidden tools work intermediate representations irs built directly source code entire program analyzed including libraries linked program ir-construction model-extraction processes assume access symbol-table debugging information properties approach higher fidelity tool software model checkers analyze source code important kinds analysis instance security exploits depend platform-specific features structure activation records vulnerabilities escape notice tool information adjacency relationships variables present toolset targeted executables techniques language-independent applied types executables remainder paper organized sketches methods codesurfer recovery overview model-checking facilities toolset discusses related work recovering intermediate representations executables recover irs executables codesurfer makes idapro disassembly toolkit grammatech codesurfer system toolkit building program-analysis inspection tools fig shows components codesurfer fig organization codesurfer executable disassembled idapro addition disassembly listing idapro access information procedure boundaries calls library functions algorithm called fast library identification recognition technology flirt statically memory addresses offsets idapro access internal resources api users create plug-ins executed idapro created plug-in idapro called connector creates data structures represent information obtains idapro idapro connector combination create data structures dynamically linked libraries link data structures represent program infrastructure permits whole-program analysis carried including analysis code library functions called data structures connector implemented static-analysis algorithm called value-set analysis vsa vsa assume presence symbol-table debugging information step set data objects called a-locs abstract automated locations verification determined based static deutsch-schorr-waite memory addresses tree-traversal offsets algorithm provided alexey idapro vsa loginov thomas combined numeric reps pointer-analysis mooly algorithm sagiv comp determines sci over-approximation dept set numeric values wisconsin alexey addresses reps value-set wisc a-loc holds school program comp point sci key tel-aviv feature vsa msagiv post tracks integer-valued tau address-valued quantities abstract simultaneously paper crucial reports analyzing executables automated verification numeric values addresses indistinguishable execution time idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete information computed vsa augment call graph control-flow graphs on-the-fly account indirect jumps indirect calls vsa checks total executable conforms correctness partial standard correctness compilation model termination runtime stack deutsch-schorr-waite maintained activation dsw records algorithm ars dsw pushed algorithm stack procedure traversing entry binary popped tree stack procedure exit stack procedure means modify destructive return pointer address manipulation stack prior program approaches instructions occupy verification fixed area algorithm memory involved self-modifying applications theorem separate provers program data handwritten proofs confirmed tvla abstract-interpretation approach executable made conforms model automatic symbolic possibly exploration incorrect memory configurations call-graph arise incorrect procedure introduction modifies return simple address core stack instrumentation vsa relations issues tvla error report finds establish violation partial correctness standard compilation termination model represent dsw introduction memorysafety violations deutsch-schorr-waite analyst dsw algorithm reports determine traverse false tree alarms real violations stack vsa completes temporarily value-sets systematically a-locs stealing pointer program point fields tree determine nodes point sets serve place killed possibly-killed stack a-locs emitted ordinarily format suitable input in-order codesurfer traversal codesurfer benefits builds collection irs perform consisting tree abstract-syntax traversal trees control-flow graphs cfgs stack call graph system dependence context graph garbage sdg collection model-checking facilities algorithm model checking employed codesurfer irs mark phase build weighted garbage pushdown collection system wpds scarcity models program memory behaviors wpds preclude library implements symbolic explicit reachability stack algorithms traversing weighted tree pushdown recursive systems tree follow traversal standard convention implicit pushdown stack system activation pds model interprocedural control-flow graph records codesurfer subtlety irs algorithm stack symbols complexity correspond program analyzing locations due single fact pds state pds rules traversal encode control algorithm flow visits rule node control flow modeled tree times performs kind pointer rotation node visit time algorithm finishes restored original values node left-child right-child pointers restoring original tree richard bornat singles algorithm key test intraprocedural cfg formal edge methods deutschschorr-waite algorithm mountain formalism pointer analysis call climb past approaches returns involved hand-written proofs complicated invariants verify partial correctness algorithm return automation procedure efforts exit node laborious configuration proof pds performed top stack symbol corresponds jape proof current editor program location pages rest key stack holds return-site locations standard run-time execution advantage tvla stack abstractinterpretation encoding approach interprocedural proof-theoretic cfg approaches pushdown system small sufficient number answering concepts queries involved reachable control states path inspector reachability algorithms wpds determine undesirable pds configuration reachable wpds defining supports abstraction weighted pdss structures pdss arise rule variant weighted algorithm element analyzed user-defined works semiring correctly applied weights directed wpds acyclic perform graph interprocedural dag dataflow analysis current semiring analysis applies extend operator compute weights input sequences binary rule firings tree discusses semiring combine limitation operator addressed meet weights execution generated verification paths carried weights automatically rules symbolic conservative abstract exploration data transformers memory configurations overapproximation set reachable concrete arise configurations obtained means defined counterexamples abstraction reported wpds simple infeasible instrumentation stack-qualified relations dataflow key formulas queries codesurfer irs atomic rich source subformulas opportunities contributions work summarized defined abstraction canonical-abstraction framework tvla captures sufficient invariants dsw demonstrate partial correctness termination fact tree node passes states induced original state visits node define state-dependent abstraction requires fewer structures represent memory configurations arise dsw state dependence abstraction establish partial correctness dsw automatic symbolic exploration memory configurations state-dependent abstraction establish bound number iterations algorithm loop establishing dsw terminates program analysis -valued logic root fig concrete store binary tree section give overview framework parametric shape analysis three-valued logic details reader referred program states represented first-order logical structures consist collection individuals interpretation finite vocabulary finite-arity relation symbols interpretation truth-value assignment relation symbol appropriate-arity tuple individuals ensure termination framework puts bound number distinct logical structures arise analysis grouping individuals indistinguishable special subset unary relations grouping nodes referred canonical abstraction setais referred set abstraction relations application canonical abstraction typically transforms logical structure -valued logical structure denotes possibility false true program state updated queried logical formulas interpreted three-valued structure straightforward extension kleene -valued semantics canonical abstraction individuals -valued structure represent individual -valued structure individuals referred summary individuals general -valued logical structure represent infinite set -valued structures program states encoded terms core relations core relations part underlying semantics language analyzed record atomic properties stores instance tab definition binary-tree datatype typedef struct node struct node left int data struct node tree relation intended meaning pointer variable point heap cell left left field point left child field point child table declaration binary-tree datatype core relations representing stores manipulated programs type tree lists core relations represent stores manipulated programs type tree store fig unary relations represent pointer variables binary relations left represent left fields tree node fig shows -valued structure represents store fig relations tab intended meaning defining formula left fields point left child tdown reachable left fields reachable check properties interest wpds instance wpds implement illegalstack-manipulation check node procedure checks net change stack height paths entrya perfectly matched calls returns same-level valid paths analysis weight function represents stack-height change instance push ecx esp weight heighta height extend reversal function composition combine performs meet stack-height-change functions analysis similar linear constant propagation memory access performed relative activation record out-of-bounds stack-height-change values identify a-locs accessed ars procedures vsa interprocedural dataflow-analysis algorithm call-strings approach obtain degree context sensitivity dataflow fact tagged call-stack suffix call-string form call-string dataflow-fact pairs call-string exit node procedure determine call site call-string dataflow-fact pair propagated call-strings arise node provide opportunity perform stack-qualified dataflow queries wpds codesurfer identifies induction-variable relationships affine-relation domain uller-olm seidl weight domain posta query builds automaton find affine relations hold calling context call-string querying posta -automaton respect regular language constructed program call graph path inspector path inspector user interface automating safety queries concerned control configurations executable reach automaton-based approach model checking query finite automaton captures forbidden sequences program locations query automaton combined program model wpds cross-product construction reachability algorithms wpds determine error configuration reachable error configuration reachable witnesses produce program path drives query automaton error state path inspector includes gui instantiating common reachability queries displaying counterexample paths disassembly listing current implementation transitions query automaton triggered program points user specifies manually result sets codesurfer queries future versions path inspector support sophisticated queries transitions triggered matching ast pattern program location query states instantiated based pattern bindings future versions eliminate infeasible counterexamples transition weights represent abstract data transformers similar interprocedural dataflow analysis related work proposed techniques obtain information executables means static analysis previous techniques deal memory accesses conservatively register assigned memory assumed vsa job previous assume source code techniques extend naturally treat executable code collection irs obtainable source code mapping information 
back source code similar source-code tools perform preprocessor work tracks integer-valued address-valued quantities program data objects hold vsa tracks values data objects hardware registers forced give precision load memory encountered fundamental issue absence information places severe limitations previously developed tools applied christodorescu jha model-checking techniques detect malicious code variants sample malicious code extract parameterized state machine accept variants code codesurfer extract model procedure program determine potential matches program code fragments malicious code technique intraprocedural analyze data state groups run-time program monitoring checkpointing perform systematic search program dynamic state space approach model checking properties low-level code run machine dynamic state space unbounded approaches perform exhaustive search contrast static analysis perform conservative exhaustive search abstract state space balakrishnan reps analyzing memory accesses executables comp construct lec notes comp sci pages springer-verlag chen dean wagner model checking million lines code symp network distributed systems security christodorescu jha static analysis executables detect malicious patterns usenix security symposium codesurfer grammatech http grammatech products codesurfer dwyer avrunin corbett patterns property specifications finite-state verification int conf softw eng fast library identification recognition technology datarescue ege belgium http datarescue idabase flirt htm godefroid model checking programming languages verisoft acm editor princ prog lang pages acm press idapro disassembler http datarescue idabase kidd reps melski lal wpds library weighted pushdown systems univ wisconsin lal reps balakrishnan extended weighted pushdown systems computer aided verif leven mehler edelkamp directed error detection assemblylevel model checker steam spin workshop uller-olm seidl analysis modular arithmetic esop musuvathi park chou engler dill cmc pragmatic approach model checking real code syst design impl reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications prentice-hall englewood cliffs 
relational abstraction functions jeannet gopan reps irisa bertrand jeannet irisa comp sci dept univ wisconsin gopan reps wisc abstract paper concerns abstraction sets functions abstract interpretation paper overview existing methods illustrated applications shape analysis formalizes family relational abstract domains sets functions abstracted precisely approaches machine-representable introduction major strength abstract interpretation ability create complex abstract domains simpler galois connections composed complex abstraction composition simpler ering ability identify erent kind approximations place abstractions sets elements exist techniques abstracting functions signature starting point paper abstraction method ned presents family abstract domains desired connect storage elements elements arrays lists numeric quantities paper reformulates abstraction general general method abstracting set functions basic idea applied widely formulation compared previously ways abstracting set functions yields precise abstractions beginning explore instantiations method formalize generic abstract-interpretation combinator abstract sets functions signature relational assuming existence abstractions nite cardinality obtained abstract domain precisely contrast complex lattice relational nite nite height lattice octagons convex polyhedra relational function-abstraction precise classical approach literature ability represent relationships images erent elements mapped set functions instance set functions represent set values array reals satisfy abstraction preserve information abstract domain precise sense quali relational ers usual nition terms precision relational function-abstraction lies in-between classical function-abstraction disjunctive completion important point nitely representable circumstances nitely representable assuming tabulated representation contribution paper give overview existing approaches abstracting functions relations analyze loss information induced state approach abstracting functions compare existing terms expressiveness implementability illustrate erent abstractions shape analysis side-e ect show canonical abstraction partially recast terms powerful combination elementary abstractions resorting logical framework contrast domain construction nement approach operates general lattices approach explicitly exploits functional structure concrete states remainder paper organized sections section introduces terminology notation section reviews classical abstractions functions signature relations elements section describes relational function-abstraction section presents related work draws conclusions preliminaries lattices galois connections denote lattice ned set partial order andudenote smallest element greatest element upper bound greatest lower bound set powerset lattice ordered set inclusion set functions lattice ordered pointwise ordering lattices lattice ordered componentwise pair identi component function strict total monotonic additive xty denote sets functions lattice called lattice formed set unordered elements smallest element greatest element added galois connection lattices ned abstraction concretization functions satisfy program analysis powerset states galois connection extensive greater identity function represents information lost abstraction preserves preserves iii one-to-one identity case notation identity loses information isomorphic information standpoint denoted one-to-one set-theoretic model set cells pointer variable pointer eld real-valued eld cell cell fnilg cell cell fnilg cell universe unary predicate binary predicate real-valued function logical model fig models program state galois connection ned disjunctive completion corresponds equipped inclusion order takes account order nement disjunction abstract properties represented loses information general xta denote galois connection disjunctive completion lattice disjunctive isomorphic disjunctive completion mentioned introduction galois connections composed denote composition connection connection existence galois connection lattices nes pre-order concrete lattice set equivalence class lattices abstract ordered lattice top element instance fig shape analysis modeling program states section background semantic domains shape analysis material paper illustrate aspects erent approaches abstracting sets functions aim shape analysis analyze properties programs manipulate heap-allocated storage perform destructive updating pointervalued elds goal recover shape descriptors provide information characteristics data structures program pointer variables point typically work shape analysis considers imperative language equipped operational semantics ned transition relation program states control point program state ned values local variables heap control point set concrete properties states collecting semantics programs ned system equations lattice concrete properties describe ways state modeled fig set-theoretic model intuitive xed set cell memory cells pointer variable modeled element cell fnilg nil denotes null cells pointer-valued eld values elds modeled function cell cell fnilg associates memory cell eld models state tools logic set cells replaced universe individuals program variable ned unary predicate eld ned binary predicate integrity constraints capture fact instance unary predicate represents program variable points true memory cell real-valued eld modeled real-valued function term predicate arity boolean function predicate relation belonging denote set predicates symbols arity denote set real-valued function symbols notation concrete state-space considered jrj concrete property relation functions unbounded size concrete properties belonging abstracted idea canonical abstraction partition nite set equivalence classes introduce unknown top element boolean set yielding predicate abstracted object eqn basic sets universe set booleans set reals universe partitioned equivalence relation resulting denote projection function obtain galois connection domain completed top bottom elements booleans abstracted domain abstracted cases abstractions reals sequel implicitely denote classical abstractions functions relations recall classical abstractions functions signature relations elements built galois connections notation make observations sec exploiting interplay functions relations obtain suitable abstractions rst describe isomorphisms sequel eqn concrete state-space techniques combined simplify eqn omitted nullary predicates model boolean-valued variables nullary functions model real-valued variables sets functions relations means means disjunctive completion fig lattice abstract domains functions relations set lattice fdg isomorphism directly galois connection abstract domain functions sets isomorphism code relations elements relations sets elements fxg fyg denotes set relations satis converse corresponds kind upward-closure classical abstraction functional space fig shows classical abstract domains sets functions relationships rst abstraction consists abstracting set functions single function equivalently relation words collects argument set images functions abstraction loses relationship hold set real-valued functions signature abstracted element fig section depicts concrete abstracted relationship holds lost abstract equivalent transformer function abstracting domain codomain abstract separately domain abstraction codomain pointwise abstraction obtain intermediate abstractions full composition galois connections galois connection closer abstractions function abstracted function image element computed unioning images elements represented application abstraction illustrated fig pointwise abstraction function abstracted representing images abstraction basic galois connections set unary predicates signature abstracted element fact canonical abstraction represent false true values predicates conservative values understood unary predicates ordinary functions abstracted holds binary predicates remark practice abstraction domain functions lattice induced partitioning remark implemented elements nitely representable implies nitely representable nite case size partition dimension represent image built image carry additional information property hold introduce additional dimension abstract domain image classical abstraction relation binary relation elements belonging element fig shows classical abstractions relations roughly speaking right-hand side fig abstracts relation concrete elements pair sets abstracts pair sets componentwise left-hand side fig abstracts relation concrete 
elements relation abstract elements abstraction ned obtained disjunctive completion observation similar remark holds choosing building principles natural simple sets structure notation heavy power combinators relations instance sets functions turn abstracted principles section state-space equation abstract functions relations functions obtain galois connection jrj codomains functions abstracted abstract values nitely representable exploiting classical abstractions interplay abstraction methods functions abstraction methods relations functions coded relations conversely instance function coded relation relation turn viewed boolean function view induces erent abstract domain abstractions previous sections shown fig coming back view data-structure eld function binary relation abstract abstraction conservative respect true abstraction false means false true means true equivalent abstraction obtained starting abstracting con ating values true section domain abstracted codomain precise disjunctive completion viewing function abstracting sets functions resulting abstract domains fig erent ways coding set functions resulting abstractions generally speaking abstraction methods functions precise abstraction methods relations illustrated fig abstract relations viewing boolean functions abstracting pairs elements nitely related suitable coding depend induced abstraction operations functions relations xpoint equations solved instance concrete abstract function application operations ned straightforward viewing function element relational function-abstraction set functions type abstract technique section convex polyhedra abstracting obtain pol interval associate abstract individual interval proposed abstract convex polyhedron dimension corresponds abstract individual section formalize approach general terms analyze carefully erent kinds abstractions performed compare approach classical approach section real-valued functions provide intuition rst instantiate abstraction scheme functions universe partitioned projection function cardinality denoted byju aim starting lattice abstract lattice form relational abstractions exist lattice obtained classical technique relational abstraction proposed decomposed pol isomorphisms mentioned equation encode functions vectors function vector elements rewriting ashf fig illustrates abstraction steps ned detail ned ffg fhx xnijxi ffg lifted sets expression galois connection composition depicted fig ned disjunctive completion explains fact preservest intuitively abstraction merge functions illustrated abstract fig merges values projected abstract individual ordered completely characterized maximal elements respect ordering fig show maximal elements subtle xni fhx xnij note right-hand-side lattice dimension corresponds real set reals subtle point eqn set vectors undercovered union cartesian products pol pol abstraction sets vectors convex polyhedra case pol complete lattice abstraction formalized weaker relationship galois connection numerical lattices place pol focus abstraction domain discussion fig ignore abstraction codomain assume codomain abstracted notation fig rede ning abstraction intuitively composition abstractions capturing relationships images erent arguments functions belong erent equivalence classes contrast abstraction fig relationships lost due abstraction fig abstraction concrete relational function-abstraction abstract concretizes concrete inspection reveals abstract preserves properties functions functions functions functions relational function-abstractiond standard abstraction fig erent abstractions concrete set functions loss information induced shown concrete values abstract concretization abstract obtained relational functionabstraction abstract concretization abstract obtained abstraction section loses property contrast abstraction section obtain abstract functional deduce weaker properties shown concretization cardinality cardinality study loss information induced abstraction abstractionstep expression xni yni words means adds cartesian products underapproximate unions cartesian products fig information lost generally lose relational information merged generalization section generalize results section abstraction functions signature analyze ect abstracting codomain assumptions suppose galois connection nite lattice assumption needed abstraction step addition suppose galois connection k-dimensional abstract domain denote assume inequality equality relational instance intervals reals inequality strict relational instance convex polyhedra nition relational function-abstraction relational functionabstraction ned composition abstractions ned ned abstraction abstraction sets -valued vectors notice drop assumption nite provide original method abstracting identify important class properties preserved abstraction generalizing properties mentioned theorem relational properties preserved abstraction binary relations property functions ned assume preserved abstraction property preserved abstraction coming back fig property satis set functions preserved abstraction equal satis theorem generalizable k-ary relations theorem implies addition relation preserved abstraction property preserved full relational function-abstraction case octagons instance proof notice due assumption fully ned confess eqn derived nition cult understand formulation general eqn nite show proves easy show monotone desired relationship holds instructive illustrate relational function-abstraction case boolean functions assuming codomain abstracted obtain abstract set bit-vectors equivalently propositional formula abstraction obtain abstract trivector single monomial means speci case abstraction reduces disjunctive completion abstraction abstraction lose information property true general shown compare relational function-abstraction ned traditional approach abstracting sets functions disjunctive completion theorem relationships rst inequality reduces equality disjunctive inequality reduces equality relational proof cardinality isomorphism hypothesis consequence corresponds inequality theorem equality strict-inequality cases follow nition relational lattice denote galois connection inequality galois connection vyg easily check nes galois connection proves rst inequality theorem equality strict-inequality cases follow nition disjunctive lattice section fact trivially disjunctive implementability issues abstract lattice implementable interesting semantic domain abstraction chain adopting pragmatic standpoint interested knowing abstract domains practice elements nitely representable sake discussion assume nitely representable argument table nite nitely representable domain nitely representable nite lattice nite lattice nite subsets incomparable elements anti-chains contrast relational function-abstraction nitely representable assumptions nitely representable nite-height lattice case nite-height nitely representable nite-height lattice practice provided equipped widening operator instance relational lattice octagons convex polyhedra language alphabet relational lattice reg regular languages vectors letters equipped suitable widening operator lattices niteheight disussion assumed argument tabular representations functions cases cient representations exploit underlying structure domain codomain instance regular transducers ective representation subset functions nite domain codomain abstracting relations functions relational function-abstraction strength relational lattices ability abstract powerset cartesian products precisely abstractions discussed section illustrated suppose abstract relations vectors concrete domain sets vectors abstracted convex polyhedra abstraction fig results abstract domain pol pol nitely representable abstraction results pol pol capture relationships pairs precisely well-known precise abstract relational lattice pol similar phenomenon arises abstracting relations functions relational function-abstraction abstract relation relation functions share domain codomain words exploit set-isomorphism apply relational functionabstraction coming back eqn illustrate principles paper obtain nitely representable abstract domain jrj rjrj pol jrj function eqn abstracted function-abstraction fig abstraction domain relational functionabstraction codomain intuitively associate convex polyhedra vector abstract boolean functions related work conclusions formalized paper generic abstract-interpretation combinator abstracts sets functions relational assuming existence abstractions viewed angle shown give semantics terms sets functions previously abstract lattices octagons convex polyhedra achieved developing nonstandard concretization functions domains intermediate step formalized abstraction sets functions sets functions identi class properties preserved abstraction terms precision abstract domains obtain relational function-abstraction lie in-between classical function-abstraction disjunctive completion important point 
abstract domains obtained relational function-abstraction nitely representable general circumstances disjunctive completions classical functionabstractions fact nitely representable circumstances classical function-abstraction nitely representable tabulated representation focused paper compositional construction abstract domains algorithmic issues choice basic abstract domains relational function-abstraction paper implemented shape-analysis framework abstracting real-valued elds dynamically allocated data structures recently addressed problem abstracting arrays reals viewed functions signature address cult problem abstracting domain function space suitable appears xed partition useless support dynamic partitioning compared solution classical solutions nement disjunctive-completion method review renement methods tensor product combines relational erent abstract domains abstract concrete domain denoted tensor product sati equation powersets extends operation general lattices reduced cardinal power reduced relative power combine erent lattices functions captures dependencies logical setting implications case nement capture autodependencies general incomparable disjunctive completion fully explore nements generate relational function-abstraction classical abstractions functions construction complicated approach functional structure concrete states exploited syntactic structure obtained abstract lattice erent isomorphism exists chase wegman zadeck analysis pointers structures proceedings acm sigplan conference programming language design implementation acm press cousot cousot systematic design program analysis frameworks acm symposium principles programming languages popl san antonio january cousot cousot abstract interpretation application logic programs journal logic programming cousot cousot higher-order abstract interpretation application comportment analysis generalizing strictness termination projection analysis functional languages invited paper proc int conf computer languages toulouse france ieee computer society press cousot halbwachs automatic discovery linear restraints variables program acm symposium principles programming languages popl tucson arizona january giacobazzi ranzato reduced relative power operation abstract domains theoretical computer science giacobazzi scozzari logical model relational abstract domains acm trans program lang syst gopan dimaio dor reps sagiv numeric domains summarized dimensions int conf tools algs construction analysis systems tacas volume lncs gopan reps sagiv framework numeric analysis array operations acm symposium principles programming languages popl acm press january jones muchnick complexity analysis inducive assertion synthesis language due dijkstra jones muchnick editors program flow analysis theory applications prentice-hall min octagon abstract domain ast working conference reverse engineering ieee press october nielson tensor products generalize relational data analysis method fourth hungarian computer science conference sagiv reps wilhelm solving shape-analysis problems languages destructive updating symposium principles programming languages popl pages york january acm press sagiv reps wilhelm parametric shape analysis -valued logic acm transactions programming languages systems 
pointer variable tdown left fields table defining formulas instrumentation relations commonly employed analyses programs type tree separate relation program variable root left left lef righ righ rroot rroot rroot rroot rroot rroot root left dow left dow lef righ dow righ dow fig logical structure represents store shown fig graphical form relations tab relations tabs relations tab grey unlabeled curved arcs nodes represent tdown relation self-loops tdown relation reflexive tuples omitted reduce clutter abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation relations record derived properties varying unary core unary instrumentation relations set abstraction relations set instrumentation relations denoted byi arity-k relation symbol defined instrumentation-relation defining formula free variables instrumentation relation symbols defining formulas instrumentation relations long circular dependences tab lists instrumentation relations important analysis programs type tree instrumentation relations involve reachability properties relation play crucial role definitions abstractions relations effect keeping disjoint subtrees summarized separately fig shows -valued structure represents store fig core relations tab instrumentation relations tab rroot rroot root lef rig left tdown tdown fig -valued structure canonical abstraction structure addition represents tree size pointed program variable root unary relations abstraction relations canonical abstraction -valued logical structure shown fig tree nodes pointed byrootrepresented summary individual bottom nodes left subtree root target indistinguishable subtree consisting relations program variable represents trees elements root node pointed program variable root graphical notation depicting -valued logical structures individuals represented circles nonval- ues unary relations summary individuals represented double circles unary relation pointer-valued program variable represented solid arrow individual absence p-arrow node individuals relation shown binary relation represented solid arrow labeled pair individuals absence q-arrow pairs relations represented dotted arrows kind statement programming language concrete semantics defined relation-update formulas core relations structure transformers abstract semantics defined relation-update formulas core relations relation-maintenance formulas instrumentation relations generated automatically finite differencing abstract interpretation collects set -valued structures program point implemented iterative procedure finds fixed point set equations fixed point reached structures collected program point describe superset execution states arise logical structures represent admissible stores exclude structures impose integrity constraints instance relation tab captures pointer variable points memory cell attribute unique imposes integrity constraint hold individual structure formula evaluates -valued logical structure corresponds admissible store integrity constraints contribute concretization function abstraction integrity constraints enforced coerce clean-up operation sharpen -valued logical structure setting indefinite definite discard structure integrity constraint violated structure represent admissible store analyzing programs manipulate trees analyzing program data structure point tree property call treeness advantage fact reduce abstract state space explored achieved analysis perform semantic reduction step filter non-trees crept representation analysis relies program maintain treeness guarantee results sound analysis check treeness preserved step address obligation techniques applicable wishes analyze programs input output intermediate data structures trees call analyses tree-specific shape analyses dsw analysis tree-specific shape analysis work tree-specific shape analyses developed include checking 
treeness maintained analyzer checks treeness maintained asserting logical formulas capture conditions execution program statement result violation treeness computation transfer function logical formulas assertions evaluated formula possibly fails hold evaluate error report issued analysis terminated purposes paper binary tree structure cycles nodes multiple incoming left pointers definition disallows sharing subtrees restrictive traditional definition requires path pair nodes inherent limitation tvla sharing subtrees permitted restriction sharing relaxed footnote data structure satisfies data-structure invariants binary tree type statement potential transform data structure violates properties statement form sel sel left creates sel-connection data structure logical formulas capture conditions guarantee application transformer statement form sel maintains treeness formula captures precondition remain acyclic tdown formula captures precondition statement avoid introducing sharing semantic reduction trees application abstract transformer perform semantic reduction filter non-trees crept abstract structures computed transformer reduction implemented application coerce enforce integrity constraints express data-structure invariants instance relation attributes acyclic invfunction acyclic attribute results automatic generation integrity constraint tdown tdown invfunction attribute results automatic generation integrity constraint operation coerce applied steps algorithm application abstract transformer enforce constraints prevent analysis admitting non-trees possibly losing precision deutsch-schorr-waite tree-traversal algorithm original deutsch-schorr-waite algorithm reverses direction ofleftandright pointers traverses tree attaches bits mark tag node mark bit serves prevent multiple visits nodes cycle shared subtrees tag bit records traversal reversed pointers node reached left child lindstrom gave variant eliminated bits provided input data structure cycles insight treat visit step internal node kind pointer-rotation operation completion tree-traversal established algorithm watch distinguished explained ensure sel null prior assignment form sel assignment creates sel-connection relaxed restriction sharing subtrees place formula employ slightly complex formula precludes possibility creating paths pair tree nodes path existed prior statement created due introduction sel edge tdown tdown tdown void traverse tree root tree prev cur root null return prev cur root save left subtree curleft rotate pointers curleft curright curright prev move forward prev cur cur cur traversal completed break cur null swap prev cur cur prev prev null void traverse tree root tree prev cur tmp root null return prev sentinel cur root save left subtree curleft rotate pointers tmp curright maintain treeness curright null curright prev curleft null curleft tmp move forward prev cur cur cur sentinel traversal completed break cur null swap prev cur cur prev prev null fig original version deutsch-schorr-waite algorithm adapted modified version deutsch-schorr-waite algorithm analyzed tvla differences bold serves kind sentinel paper lindstrom variant continue refer deutsch-schorr-waite dsw connection analysis lindstrom variant original version dsw discussed briefly fig shows versions deutsch-schorr-waite algorithm left-hand column shows version adapted lindstrom scanning right-hand column shows slightly modified version algorithm work differences versions constant lines replaced sentinel sentinel assumed distinguished node part input tree tvla pointer values equal null situation pointer point heap object point heap object allocated malloc sense tvla semantics java non-null pointer values generated memory-allocation operations purely local transformation involving introduction temporary variable tmp applied lines curleft curright curright prev tmp curright maintain treeness curright null curright prev curleft null curleft tmp involved transformations assignment statements formxsel sel normalized statement sequences tmp sel sel tmp lines fig assignment statements form sel normalized statement sequencesxsel null sel lines fig ensures statements formxsel ycan destroy existing sel-paths data structure simplifying task maintaining information reachability tree nodes program variables assignments curright null curright prev moved lines assignments curleft change prevents child cur target temporarily incoming edges assignment curleft line resulting algorithm maintains invariant nodes input tree make data structures satisfy binary-tree properties assignment line fig nodes input tree make trees rooted target rooted atcur target original root descendant cur target transformations simple normalizations expect find translation programs written high-level language lower-level intermediate representation transformation prevents temporary sharing cur subtree briefly cur left cur subtree relax restriction sharing analyze version algorithm include transformation discusses approach task chose verify total correctness preservation treeness slightly modified version dsw algorithm shown fig transformation techniques apply analysis version describe version detail tree node body loop executed times cur pointing time considered left pointers rotated counter-clockwise fashion lines fig lines assignment curright nullneeds moved achieve desired effect moved assignments clarity fig execution original values left pointers re-established explain cur tmp prevn cur prev tmp cur tmp prev nextn cur tmp prev nextn fig states subtree cur pointing execution statement line fig state execution statement line fig state execution statement line fig state execution statement line fig state grey edges represent original values left fields execution lines fig cur pointing nodes subtrees rooted left subtrees original tree visited left pointers nodes subtrees rooted modified situation state fig illustrates situation pointer node left child prior rotation left pointers saved line rotation traversal continues moving tree rooted lines cur null values cur prev swapped lines traversal backtrack recently visited node subtree original tree traversal backtracks algorithm reaches lines fig time withcurpointing point nodes subtree nodes subtree visited left pointers nodes subtree rotated times restored original values left pointers nodes subtree modified situation state fig illustrates situation pointer node left child prior rotation pointers saved rotation traversal continues moving tree rooted lines algorithm backtracks cur null traversal backtracks algorithm reaches lines fig final time cur pointing point nodes subtrees visited left pointers nodes subtrees rotated times restored original values situation state fig illustrates situation subsequent execution lines fig cur pointing left pointers restored original values point nodes subtree rooted visited left pointers subtree rotated times restored original values situation state fig illustrates situation algorithm traverses tree order visiting node times originalleftpointers parent subtree backtracking subtree traversing subtree backtracking subtree parent original tree cur fig states tree nodes subtree pointed cur grey edges represent original values left fields fig depicts states tree nodes subtree pointed cur ancestors original tree cur target state indicating left subtree traversed ifcur target lies left subtree ancestor ancestor state state triangular shapes left represent nodes occur earlier cur target inorder traversal tree nodes exists ancestor cur target node left subtree ancestor cur target subtree ancestor nodes category state visited times left pointers reset original values triangular shapes represent nodes occur cur target in-order traversal tree nodes exists ancestor cur target 
node subtree ancestor cur target left subtree ancestor nodes category state visited original values shape abstraction verifying dsw problem establishing deutsch-schorr-waite algorithm shown fig partially correct assertion compares state store end procedure state start partial correctness dsw means tree produced exit identical input tree node visited back property discuss total correctness dsw property left left left denote initial values relations left additionally correct traversal routine lose nodes input tree gain property implied properties challenge abstraction track unintended pointers stack simulation sufficient precision verify end algorithm correct usage reestablished canonical abstraction properties listed tabs insufficiently precise abstraction demonstrate tree edges restored key relations establishing properties end program capture relationships pointers arise tree nodes traversal set unary relations capture properties nodes state nodes left pointers state nodes left pointer values restored eql left left eqr unary relations eql eqr distinguish individuals represent tree nodes whoseleft respectivelyright pointers initial values eql place formula eqr place formula asserting partial correctness dsw set unary relations capture properties nodes state visit nodes rotation left pointers eql left rer left rer unary relation eql distinguishes individuals represent tree nodes whoseleft field points input tree subtree unary relations rer rer mnemonic reverse distinguish individuals represent tree nodes fields point parents input tree assuming left child case rer child set unary relations capture properties nodes state visits nodes rotations left pointers eqr left rel left left rel left unary relation eqr distinguishes individuals represent tree nodes field points left input tree subtree unary relations rel rel distinguish individuals represent tree nodes left fields point parents input tree assuming left child case rel child give intuition relations defined formulas partial-correctness verification dsw involves establishing left pointers initial values end dsw relations maintain relationship current original values left pointers prior rotation pointers node entries staterelations formulas change starting pointer values entries analysis conclude current iteration rotation pointers entry staterelations formula formulas similarly entries staterelations node establish entries staterelations formula formulas rotation pointers finally entries staterelations node establish entries staterelations formulas rotation pointers initial attempt establish partial correctness dsw added relations formulas set abstraction relations attempt failed terminated analysis days computation vast abstract state space needed explored pare abstract state space observed node distinctions introduced relations formulas instance note leaf node state state satisfies relations formula defines eql nominally staterelation outgoing left pointers internal tree node state state satisfy result eql prevents canonical abstraction summarizing leaf node state internal node states resulting abstraction larger-than-necessary state space ensure tree nodes state left field pointing original subtree property defined relation eql remove unnecessary distinctions introduce concept statedependent abstraction component abstraction collection unary core state relations state state state state time rotation left pointers tree node pointed cur completed line fig node state changed state state relations carry semantics respect pointer values nodes simply record visit counts node component abstraction introduce state-relation-guarded versions relations formulas eql state eql eqr state eqr eql state eql rer state rer rer state rer eqr state eqr rel state rel rel state rel state relations added set abstraction relations eql state eql eqr state eqr replace relations formulas set abstraction relations formulas resulting abstraction grouping nodes values relation eql long nodes state establishing dsw terminates establish dsw terminates unary state relations simple progress monitor describe state relation create copy save values relation start currently-processed loop iteration line fig give relations superscript hold loop-head values abstract operation iteration loop takes snapshot current states nodes statelhi statei binding individuals abstract structure processed additionally asserts cur point tree node state head loop operation loop iteration performs progress test asserting formula parenleftbigstatelh state statelh state statelh state negationslash statelh state statelh state statelh state statelh state assertion ensures node state makes forward progress line assertion node state lines assertion assertion cur point tree node state start loop progress monitor establishes tree node visited times establishing algorithm terminates fact node fact visited algorithm property partial correctness experimental evaluation applied tvla dsw algorithm shown fig analyzed abstraction defined input algorithm supplied -valued structure shown fig essentially structure fig refined values relations introduced additionally special sentinel node part input tree referenced program variable sentinel fig fig relations left omitted reduce clutter values identical left omitted values stateand staterelations eql rer rer eqr rel rel non-sentinel nodes figures sentinel nodes performing tree-specific shape analysis figures represent concrete structures satisfy treeness integrity constraints rroot state eql eqr eql eqr root lef rig left tdown tdown rroot state eql eqr eql eqr state sentinel eql eqr eql eqr tdown fig -valued structure represents trees size fig shows unique structure collected analysis exit node definite values relations eql eqr defined formulas individual establish outgoingleft pointers tree node restored establishing partial correctness property tree produced exit identical input tree absence violations progress monitor defined establishes dsw terminates fact node visited partial correctness property analysis hours ghz linux memory authors number ideas performance optimizations research system main goal demonstrate feasibility automatic symbolic exploration heapmanipulating programs vast abstract state spaces cost verifying dsw terminates negligible compared cost dsw partially correct progress monitor increase size reachable state space number distinct abstract structures collected program points exceeded number structures program points exceeded number surprising structures contained individuals intermediate steps analysis explored abstracts structures individuals limit imposed number distinct -valued structures represents number subsets individuals vector unary abstraction-relation values unary abstraction relations pointer relations reachability relations pointer-valued program variables ten relations formulas fig shows sample abstract structure arises line fig structures arise point state relations state-relation-guarded relations defined formulas precise values individuals summary experiment showed abstraction defined automatic analysis maintain precision identify sufficient invariants demonstrate partial correctness termination dsw discussion future work analysis carried tvla performs fully-automatic state-space exploration bring bear expertise tvla analyses concept tree-specific shape analysis general utility reused analysis input output intermediate data structures trees instrumentation relations defined formulas capture pointer relationships tree nodes core state relations state state control precision abstraction specific problem verifying total correctness dsw rroot rprev state eql eqr eql eqr root prev lef rig left tdown tdown rroot rprev state eql eqr eql eqr rcurr sentinel state eql 
eqr eql eqr tin tdown fig -valued structure collected exit dsw key difference approach theoremprover-based approaches loop invariants collection node distinctions node relationships relations eql rer formulas node distinctions observable analysis node distinctions abstract interpretation automatically infers invariants satisfied program recently machine-learning technique identify key instrumentation relations automatically future identify key relations verifying dsw relations formulas instrumentation relations introduced tailored establishing correctness dsw concept state-dependent abstractions general utility fact simpler versions state-dependent abstractions arisen past work unary relation inorder establish partial correctness sorting state-dependent abstractions defined paper prepared deal states initial final case relation inorder state guard reduce number distinct properties recorded individuals reducing size abstract state space explored interesting analogy explicit state-tracking original dsw algorithm performs mark tag bits state relations abstraction sense state relations introduced purposes analysis impose dsw-like view world track actions lindstrom variant algorithm chose apply transformation ensures algorithm maintains treeness transformation verify unmodified algorithm fig introducing instrumentation relation islocallyshared left relation islocallyshared nodes input -valued structure indicating input valid binary tree relax restriction sharing tracking sharing occurs requiring absence cur state cur state cur prev state prev root state prev root sentinel state prev root sentinel tmp state cur tmp state prev state prev left leftdown leftdown rightdown state cur tmp left left downt rightdown left fig -valued structure arises prior rotation pointers node pointed cur line fig relations left omitted figure initially node child node pointed prev node root tree leaf sentinel original root parent sentinel nodes subtree visited subtree modified initial state applicable version algorithm include transformation tree-specific shape analysis generalized handle limited class dags arise lines fig precondition absence sharing formula removed integrity constraints forbid structures sharing modified include islocallyshared guard permit kind local sharing arises fig constraint islocallyshared dsw algorithm shown fig algorithm shown fig work correctly applied data structure cycle traversal terminates prematurely edges properly restored algorithm works correctly applied dag node paths root visited times times note exponential size graph bound verify correctness dsw dags relax restriction sharing introduce state relations state-relation-guarded relations small reachable state space explored computing resources general case input dag bound partial-correctness result obtained state relations nodes wrap visit node state results changing node state change sufficient establish outgoing left pointers dag node restored node visited analysis longer establish termination simple progress monitor practice rarely interested algorithm traverse dag potentially exponential cost applications process node depth-first order visit node constant number times achieved equipping nodes bits record visit count number nodes reachable node visit count visited times cur set point node visit count direction traversal reversed swapping values cur prev terminating exploration node subgraph relaxing restriction sharing verify total correctness modified algorithm related work general form deutsch-schorr-waite algorithm works correctly arbitrary graphs unlike algorithm work general form constant-space mark tag bits divide discussion related work kind data structures analyzed algorithm applied dsw arbitrary graphs formal proofs partial correctness dsw performed manually morris topor suzuki automated steps partial-correctness verification algorithm introducing decision procedures handle heap-manipulating programs recently bornat discussion relies reported jape proof editor construct partial-correctness proof dsw resulting proof pages automated approach obvious benefit disposing provide manual proofs require significant investments time expertise presence powerful theorem prover proof-based approaches rely user provide loop invariants sufficient establish property verified instance properties nodes subtrees figs text loop invariants discussed obligation simpler instrumentation relations act ingredients loop invariant analysis automatically synthesizes loop invariant form collection -valued structures overapproximate set concrete structures arise means statespace exploration yang mehta nipkow gave manually-constructed machinecheckable proofs partial correctness dsw approaches share goal making formal reasoning heap-manipulating programs natural approach logic bunched implications precursor formalism separation logic permits user reason hoare triples presence complicated aliasing relationships approach isabelle hol construct formal proofs human-readable approaches improve usability proof-based techniques lack automation approach dsw trees dags yelowitz duncan present termination argument deutsch-schorr-waite algorithm analyzed knuth version algorithm tag bits work correctly graphs cycle work dags version termination argument involved program invariants prove bounds number executions statements loop showed state relations defined simple progress monitor algorithm loop establish dsw terminates trees case partial correctness task reduced establishing distinctions nodes state relations complete state-space exploration shows violation progress monitor establishes bound number visits tree node algorithm terminate previous papers reported automatic verification weaker properties deutsch-schorr-waite algorithm algorithm unsafe pointer operations memory leaks data structure produced end fact binary tree authors established properties typo stating work establishes partial correctness reused tvla specification establishes properties finally extended framework grammars provide convenient syntactic sugar expressing shape properties data structures work relied grammars instrumentation relations express tree properties absence memory leaks bornat proofs pointer programs jape http dcs qmul erichard pointers bornat proving pointer programs hoare logic mathematics program construction pages july bornat sufrin animating formal proofs surface jape proof calculator computer journal hendren parallelizing programs recursive data structures phd thesis dept computer science cornell january ishtiaq hearn assertion language mutable data structures symp principles programming languages pages january knuth art computer programming vol fundamental algorithms addisonwesley lee yang automatic verification pointer programs grammar-based shape analysis european symp programming pages april lev-ami immerman sagiv fast precise abstraction shape analysis proc computer-aided verification august lev-ami reps sagiv wilhelm putting static analysis work verification case study int symp software testing analysis pages august lindstrom scanning list structures stacks tag bits information processing letters june loginov reps sagiv abstraction refinement inductive learning proc computer-aided verification pages july manevich sagiv ramalingam field partially disjunctive heap abstraction static analysis symp pages august mehta nipkow proving pointer programs higher-order logic automated deduction cadepages july morris verification-oriented language design tech report trcomputer science div california berkeley december reps sagiv loginov finite differencing logical formulas applications program analysis european symp programming pages april reynolds separation logic logic shared mutable data structures symp logic computer science pages july sagiv reps wilhelm parametric shape analysis -valued logic acm trans programming languages systems toplas schorr waite efficient machine independent procedure garbage collection list structures communications acm august suzuki automatic verification programs complex data structures phd thesis dept computer science stanford february topor correctness schorr-waite list marking algorithm tech report mip-rschool artificial intelligence 
edinburgh july yang local reasoning stateful programs phd thesis dept computer science illinois urbana-champaign june yelowitz duncan abstractions instantiations proofs marking algorithms symp artificial intelligence programming languages pages august yorsh reps sagiv wilhelm logical characterizations heap abstractions acm transactions computational logic tocl 
improving pushdown system model checking akash lal thomas reps wisconsin grammatech akash reps wisc abstract paper reduce pushdown system pds model checking graphtheoretic problem apply fast graph algorithm improve running time model checking pds questions techniques carried setting including witness tracing incremental analysis benefits fast graph-based algorithm introduction pushdown systems pdss served important formalism program analysis verification ability concisely capture interprocedural control flow program tools pushdown systems abstract model program reachability analysis models verify program properties pdss infinite-state abstraction control state program tools verify properties finitestate data abstraction tools based generalized setting weighted pushdown systems wpdss capable verifying infinite-state data abstractions heart tools pds reachability-analysis algorithm chaotic-iteration strategy explore reachable states work address worst-case running time algorithm knowledge addressed issue giving direction chaotic-iteration scheme improve running time algorithm practice paper improve worst-case running time running-time observed practice provide common setting discuss pds model checkers wpdss describe improvements pds reachability interprocedural control flow graph icfg set graphs procedure connected special call return edges wpds initial query decomposed set graphs structure similar underlying pds obtained standard encoding icfg pds program analysis decompositions coincide fast graph algorithm tarjan path-expression algorithm represent graph regular expression wpds reachability reduced solving set regular equations underlying pds obtained structured reducible control flow graph regular expressions found solved efficiently control flow structured regular expressions provide fast iteration strategy improves standard chaotic-iteration strategy work inspired previous work dataflow analysis single-procedure programs shown class dataflow analysis problems supported onr nsf ccrand ccfcan advantage fact single-procedure cfg represented regular expression generalize observation multiple-procedure programs wpdss contributions paper summarized present reachability algorithm wpdss improves previously algorithms pds reachability algorithm asymptotically faster pds regular decomposes single graph offers substantial improvement general case algorithm completely demand-driven computes information needed answering user query implicit slicing stage disregards parts program needed answering user query show pds analysis questions techniques including witness tracing incremental analysis carry approach rest paper organized background pdss wpdss presents previously algorithm algorithm solving reachability queries wpdss describe algorithms witness tracing incremental analysis presents experimental results describes related work pds model checking definition pushdown system triple set states control locations set stack symbols set pushdown rules configuration pair rule written rules define transition relation configurations reflexive transitive closure denoted loss generality restrict pds rules stack symbols right-hand side standard approach modeling program control flow icfg call node split nodes interprocedural edge entry node procedure called incoming edge exit node procedure set nodes graph set control-flow edges fig shows icfg fig shows pushdown system models pds single state stack symbol node rule edge rules stack symbol right-hand side model intraprocedural edges rules stack symbols right-hand side push rules call edges rules stack symbols right-hand side pop rules return edges easy valid path program corresponds path pushdown system transition system vice versa pdss encode ordinary control flow graphs provide convenient mechanism modeling kinds non-local control flow setjmp longjmp setjmp push special symbol stack longjmp environment variable identified preprocessing pop stack symbol reached longjmp passed state pds number configurations pushdown system unbounded finite automata describe infinite sets configurations emain null loc false flag false call foo ret foo exitmain efoo loc true flag loc false exitfoo fig icfg exit nodes represent entry exit points procedures flag global variable loc loc local variables main foo dashed edges represent interprocedural control flow pushdown system models control flow graph shown definition pushdown system p-automaton finite automaton finite set states transition relation set initial states set final states automaton configuration accepted p-automaton automaton accept started state written set configurations called regular p-automaton accepts weighted pushdown system obtained supplementing pushdown system weight domain bounded idempotent semiring semirings powerful encode finite-state data abstractions required boolean program verification infinite-state data abstractions copy-constant propagation affine-relation analysis definition bounded idempotent semiring quintuple set elements called weights elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule sequence rules associate define configurations path denote set rule sequences transform reachability problems pushdown systems generalized weighted pushdown systems definition letw weighted pushdown system wherep regular set configurations generalized pushdown predecessor gpp problem find circleplustext path generalized pushdown successor gps problem find circleplustext path illustrate definitions encode boolean programs wpds program shown fig global variableflag ignore local variables details treatment found set valuations global variables case global variable icfg edge transformer binary relation describes effect executing edge global variables edge relation flag set false weight domain pds rule associate transformer icfg edge assertion checking program performed configuration set configurations reached non-zero weight negationslash boolean programs encoded pdss states pds encode valuations global variables wpdss provide efficient representation boolean programs weights symbolically encode transformers bdds wpdss strictly powerful pdss infinite-width abstract domains perform copy-constant propagation affine relation analysis details pdss model checking encoding wpdss found solving reachability problems section review existing algorithm solving generalized reachability problems wpdss based chaotic iteration present algorithm tarjan path-expression algorithm limit discussion gpp gps similar slightly complicated solving gpp chaotic iteration wpds pushdown system weight domain regular set configurations recognized p-automaton gpp solved saturating automaton weighted transitions transition weight label create automaton apre read-off efficiently apre combine weights accepting paths starting weight path extend weight-labels transitions path order present algorithm building apre based abstract grammar problem definition meet semilattice abstract grammar collection context-free grammar productions production form parentheses commas production terminal symbols production function string terminal symbols derived grammar denotes composition functions corresponds unique call valg denote strings terminals derivable nonterminal abstract grammar problem compute nonterminal modg valg called define abstract grammars meet semilattice set weights shown fig non-terminal derive string val fig simple abstract grammar productions production popseq popseq popseq popseq popseq popseq popseq fig abstract grammar problem solving gpp abstract grammar solving gpp shown fig grammar non-terminal popseqt transition apre productions describe weights transitions computed weight label transition mod popseqt meet-overall-derivation obtained initialize transitions popseqt popseqt popseqt production grammar possibly fewer non-terminals right-hand side update weight label existing algorithm solving gpp worklist-based algorithm 
chaotic iteration choose transition worklist productions transition side updates weight transitions left-hand side productions earlier weight transition added worklist defn guarantees convergence chaotic-iteration scheme efficient abstract grammar fig efficient saturating weights transitions start production alternating productions converge choosing production strategy choose production multiple times important identify loops transitions stay loop exiting solving gpp path expressions find iteration scheme gpp convert gpp hypergraph problem definition directed hypergraph generalization directed graph generalized edges called hyperedges multiple sources source edge ordered set vertices transition dependence graph tdg grammar hypergraph vertices non-terminals hyperedge production left-hand side non-terminals order right-hand side fig tdg pds shown fig wpds obtained pds supplementing rule number weight stand node thick bold arrows form hyperedge nodes source nodes dashed arrow summary edge edge labels explained construct tdg grammar shown fig underlying pds obtained icfg initial set configurations tdg identical icfg edges reversed fig shows observed fact pds states fig transition dependences identical dependences encoded pushdown rules turn icfg edges icfg edge corresponds transition dependence fig call-return pair icfg corresponds hyperedge pushdown systems constructing tdgs unnecessary choose initial set configurations defines region interest program pdss encode stronger properties icfg setjmp longjmp programs convenient tdg icfg rest paper illustrate issues tdg grammar fig reduce meet-over-all-derivation problem grammar meet-over-all-paths problem tdg intraprocedural iteration tdgs special form intraprocedural case hyperedges tdg correspondingly push rules pds assume tdg fig part procedurefoo hyperedges tdg edge inserted production weight label edge insert special node tdg production form insert edge label weight called source node graph weights edge define weight path graph standard reversed weight path extend weights constituent edges reverse order easy mod circleplustext path path set paths tdg weight path solve mod chaotic iteration make tarjan path-expression algorithm problem directed graph fixed vertex single-source path expression sspe problem compute regular expression represents path vertices graph syntax regular expressions stands edge sspe algorithm compute regular expressions path compact description set paths kleene-star operator identifies loops tdg reverse compute mod regular expression path replace edge weight solve expression weight computed bounded-height property semiring iteration converges main advantages regular expressions compute mod loops identified expression evaluation strategy saturates loop exiting compute faster normal iteration observe exponentiation defined computed repeatedly squaring converges computed logn operations chaotic-iteration strategy steps compute words closed representation loops exponential speedup tarjan algorithm dominators construct regular expressions sspe effect computing weight dominators node computing weight node avoids unnecessary propagation partial weights node case exit loop early graph edges grammar productions case nodes non-terminals regular expressions path computed nodes time mlogn graph reducible evaluating expressions additionalo mlognlogh semiring operations height semiring high-level languages well-structured icfgs reducible graph reducible running time degrades mlogn logh semiring operations sum cubes sizes dominator-strong components graph worst case experiments seldom found irreducibility problem small constant pure chaotic-iteration strategy semiring operations worst case comparing complexities expect algorithm path expressions faster chaotic iteration benefit greater height semiring increases interprocedural iteration generalize algorithm tdg hyperedge delete graph replace edge assumes semiring operation takes amount time absence assumption semiring aim decrease number semiring operations cases bdd-based weight domains repeated squaring reduce running time user supply procedure computing efficient computing simple iteration combined sizes regular expressions bounded running time sspe algorithm edge called summary edge node called out-node fig delete hyperedge replace edge called summary edge crosses call-site return node call node summarize effect procedure call node out-node supply procedure summary weight resultant tdg collection connected graphs graph roughly procedure fig transitions correspond procedures main foo split connected graph called intragraph intragraph introduce source node add edges source node nodes -productions weight labels added summary edge obtained hyperedge production function label collection intragraphs edges labeled weight simple expression out-node solve mod construct set regular equations call out-node equations intragraph unique source node out-node construct regular expression paths path expression replace edge label resulting expression out-nodes add equation set outnode equations repeat intragraphs resulting set out-node equations describe hyperpaths tdg out-node collection source nodes mod out-nodes greatest fix-point equations respect defn tdg shown fig assuming out-node obtain out-node equations shorthand solve equations chaotic iteration start initializing out-node greatest element semiring update values out-nodes repeatedly solving equations converge give direction iteration constructing dependence graph equation equation rise dependences strongly connected component scc decomposition graph solve equations component moving equations component topological order regular expressions define evaluation order equations details chose simpler implementation sccs dependence graph correspond mutually recursive procedures tend small practice regular expression out-node equations summarizes paths intragraph large avoid evaluating repeatedly solving equations end incrementally evaluate regular expressions part expression reevaluated modified out-node algorithm fig entire expression traversed reevaluations performed selectively regular expression represented usthe equations depending sspe algorithm implemented equations solution ing abstract-syntax tree leaves weights out-nodes internal nodes correspond optimization regular expressions share common subtrees represented dags trees incremental algorithm takes care sharing identifies modified out-nodes expression automatically dag node maintain integers change weight weight subdag rooted node assume regular expressions share leaves out-nodes global counter update count incremented time weight out-node updated node counter change records update count weight subdag changed counter records update count subdag reevaluated evaluation algorithm shown fig weight out-node changed leaf node updated weight update count incremented out-node counters set update count procedure evaluate begin update count return case return case evaluate evaluate max change change weight weight weight negationslash change weight update count end fig incremental evaluation algorithm regular expressions prefix version solve values out-nodes change out-node labels summary edges intragraphs replace weight mod values nodes tdg obtained intraprocedural version intragraph isolation time required solving system equations depends reducibility intragraphs time required solve sspe intragraph mlogn worst-case ignorable practice equations mutual dependences recursion running time summationtextg logh sum ranges intragraphs equation solved presence recursion observation weight subdag regular expression change times equations solved decrease monotonically size regular expression obtained intragraph bounded worst-case time solving equations summationtextg bound pessimistic worse chaotic iteration make fact incrementally computing regular expressions faster reevaluating regular expression modified out-node perform semiring operations node out-node leaf root expression balanced regular expression tree path root small logsg empirically found incrementally computing expression required fewer operations recomputing expression 
unlike chaotic-iteration scheme weights tdg nodes computed compute weights out-nodes weights rest nodes computed lazily evaluating regular expression needed applications require weight tdg nodes additional savings limit computation weights out-nodes intragraphs tdg node weight required corresponds slicing out-node equations respect user query rules computation procedures irrelevant query handling local variables wpdss recently extended extended-wpdss provide convenient mechanism handling local variables reachability problems ewpds based abstract grammars similar wpds easily adapt algorithm ewpdss details ewpdss experiments solving pds problems section give algorithms important pds problems witness tracing incremental analysis technical report algorithm differential weight propagation witness tracing differential propagation discussed wpdss witness tracing program-analysis tools program satisfy property provide justification property satisfied terms wpdss amounts reporting set paths rule sequences justify reported weight configuration formally notation defn witness tracing problem gpp find configuration set uniontext path circleplustext definition witness tracing impose restrictions size reported witness set compact representation set suffices applications algorithm witness tracing gpp requires memory algorithm requires memory number out-nodes expected smaller gpp algorithm head start regular expressions describe paths intragraph intragraphs label edge weight rule justifies edge push rules summary edges pop rules edges originate source node edges source node inserted production fig rule empty rule sequence solving sspe intragraphs replace edge rule label out-node regular expression terms out-nodes captures set rule sequences reach out-node solving regular equations record weights out-nodes solve equation record weights weight set rule sequences create transition weight expression replace tdg edges rule labels replacing out-node regular expression rule sequences create weight obtained recursively regular expression witness set out-node witness sets transitions obtained solving sspe intragraphs replacing out-node labels witness-set expression require space recording witnesses remember history weights out-nodes pdss obtained icfgs empty initial automaton number procedures icfg small compared incremental analysis incremental algorithm verifying finite-state properties icfgs conway methods presented paper generalize algorithm wpdss incremental approach model checking advantage amortizing verification time program development debugging time cases addition rules deletion existing case work granularity intragraphs rule added fix-point solution out-node equations monotonically decreases reuse existing computation identify intragraphs changed edges rule recompute regular expressions out-nodes intragraphs add set out-node equations solve equations set initial weights out-nodes existing out-nodes added set initial deletion rule requires work identify changed intragraphs recompute out-node equations call out-nodes intragraphs modified out-nodes dependence graph out-node equations constructed perform scc decomposition graph topologically sort sccs weights out-nodes scc modified out-node changed recompute solution out-nodes topological order stop values agree previous values start out-nodes scc modified out-node solve weights weight out-node previously computed weight out-nodes sccs dependent marked modified repeat procedure modified out-nodes advantage incremental analysis framework information stored analysis runs store weights out-nodes experiments aware implementations wpdss wpds nmoped call implementation algorithm fwpds stands fast incremental algorithms sspe solving sspe single intragraph fast plugged-in back-end wpds libraries wpds supports optimized iteration strategy user supply priority-ordering stack symbols chaotic iteration choose transition priority refer version bfs-wpds supply breadth-first ordering icfg obtained treating graph bfs-wpds performs wpds measure end-to-end performance fwpds computes weight transitions required application report time compute weight transitions refer fwpds-full comparison fwpds-full give indication application-independent improvement provided approach computes amount information previous wpds algorithms measure speedups fwpds running times show potential lazy-evaluation real settings fwpds-full left-associative evaluation order computing weights regular expressions worth noting repeated squaring computing appreciable difference compared simple iterative method tested fwpds applications wpdss perform gps wpds entry point program initial configuration application performs affine-relation analysis ara programs program translated wpds find affine relationships machine registers application requires affine relationships branch points results shown table experiments performed fwpds provided average speedup times reduced running time bfs-wpds time speedup prog insts procs wpds bfs-wpds fwpds-full fwpds print finger winhlp regsvr cmd notepad table comparison ara results column show speedup ratio running times fwpds versus bfs-wpds programs common windows executables experiments run ghz machine ram application btrace debugging performs path optimization programs set icfg nodes called critical nodes find shortest icfg path touches maximum number nodes path starts entry point program stops failure point program fwpds computes weight failure point shown table fwpds performs bfs-wpds application speedup times experimental results incremental analysis btrace presented observed roughly -fold improvement incrementally computing solution deleted procedure reinserted program application nmoped model checker boolean programs wpds library performing reachability queries weights binary time speedup prog icfg nodes procs bfs-wpds fwpds-full fwpds make indent patch gawk wget table comparison btrace results column shows speedup fwpds bfs-wpds critical nodes chosen random icfg nodes failure site set exit point program programs common unix utilities experiments run ghz machine ram relations valuations boolean variables represented bdds measure performance fwpds library set programs error configuration program supplied schwoon compute set variable valuations hold error configuration computing meetover-all-paths weight shown table fwpds times faster nmoped technical report set experiments smaller programs led inconclusive results nmoped asked stop finds error configuration reachable exploring paths leading error configuration case error configuration reachable nmoped performed fwpds completing expected evaluation strategy fwpds oriented finding complete weight mod transition avoid saturating loop completely propagate partially computed weights hope finding error configuration reachable error configuration unreachable abstraction-refinement mode nmoped turned explores paths program computes mod transitions situations fwpds prog nmoped fwpds-full fwpds speedup bugs slam-fixed slam unified-serial iscsi iscsi table nmoped results column shows speedup fwpds nmoped programs provided schwoon publically related work basic strategy regular expression describe set paths previously dataflow analysis single-procedure programs work aware technique multi-procedure programs ramalingam regular expressions analysis execution frequency analysis technique motivated special requirements execution frequency analysis creating procedure summaries efficiency generalized approach apply broader set problems encoded wpds showed enhancements incremental recomputation regular expressions computing lazily contribute creating faster analysis host previous work incremental program analysis interprocedural automaton-based analysis incremental algorithm presented similar algorithm generalizes wpdss applicable domains finite-state property verification key difference algorithm explore property automaton on-the-fly program explored encoding wpds requires automaton program explored difference significant automaton large small part automaton generated balakrishnan reps analyzing memory accesses executables bouajjani esparza maler reachability analysis pushdown automata application model checking concurrency theory concur pages bouajjani esparza touili generic approach static analysis concurrent programs procedures popl pages 
conway namjoshi dams edwards incremental algorithms inter-procedural analysis safety properties cav pages esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems cav pages esparza schwoon bdd-based model checker recursive programs cav pages finkel willems wolper direct symbolic approach model checking pushdown systems electronic notes theoretical computer science kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds kiefer schwoon suwimonteerabuth nmoped http informatik uni-stuttgart fmi szs tools moped nmoped lal lim polishchuk liblit path optimization programs application debugging european symposium programming pages lal reps improving pushdown system model checking technical report wisconsin-madison jan lal reps balakrishnan extended weighted pushdown systems cav pages matsunaga mcgeer brayton computing transitive closure state transition relation design automation conference dac pages myers precise interprocedural data flow algorithm popl pages ramalingam data flow frequency analysis pldi pages reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis science computer programming schwoon model-checking pushdown systems phd thesis technical univ munich munich germany july schwoon moped http fmi uni-stuttgart szs tools moped tarjan fast algorithms solving path problems acm tarjan unified approach path problems acm 

simulating reachability first-order logic applications verification linked data structures lev-ami immerman reps sagiv srivastava yorsh school comp sci tel aviv univ ftla msagiv gretayg post tau dept comp sci univ massachusetts amherst fimmerman siddharthg umass comp sci dept univ wisconsin reps wisc paper shows harness existing theorem provers first-order logic automatically verify safety properties imperative programs perform dynamic storage allocation destructive updating pointer-valued structure fields main obstacles proving absence reachability properties dynamically allocated cells main technical contributions methods simulating reachability conservative first-order formulas formulas describe superset set program states arise methods employed semi-automatic program verification programmer-supplied loop invariants programs mark-and-sweep garbage collection destructive reversal singly linked list mark-and-sweep previously reported capabilities esc java introduction paper explores harness existing theorem provers first-order logic prove reachability properties programs manipulate dynamically allocated data structures approach involves simulating reachability conservative first-order formulas formulas describe superset set program states arise automatically establishing safety liveness properties sequential concurrent programs permit dynamic storage allocation low-level pointer manipulations challenging dynamic allocation state space infinite program permitted mutate data structure destructively updating pointervalued fields nodes features remain programming language good capabilities data abstraction abstract-datatype operations implemented loops procedure calls sequences low-level pointer manipulations hard prove data-structure invariant reestablished sequence operations finished languages java concurrency poses challenge establishing absence deadlock requires establishing absence cycle threads waiting locks held threads reachability crucial reasoning linked data structures instance establish memory configuration garbage elements show supported nsf grant ccrand guggenheim fellowship supported onr contracts partially supported israeli academy science element reachable program variable cases reachability notion include acyclicity data-structure fragments element reachable node reach effect procedure calls passed arguments elements reachable formal parameter modified absence deadlocks safety conditions establishing data-structure traversal terminates path node sink-node data structure verification properties presents challenge simple decidable fragments first-order logic undecidable reachability added utility monadic second-order logic trees limited programs non-tree data structures expressing postconditions procedures essential modular reasoning requires referring pre-state holds procedure executes general expressed monadic second-order logic trees procedures manipulate singly-linked lists in-situ list-reversal program shown fig iii complexity prohibitive work motivated experience abstract interpretation tvla system establish properties programs manipulate heap-allocated data structures paper problem verifying data-structure operations assuming user-supplied loop invariants similar approach systems esc java pale contributions paper summarized handling formulas theorem provers firstorder theorem provers discuss transitive closure binary predicates first-order theorem provers handle transitive closure solve conundrum adding relation symbol ftc first-order axioms assure ftc interpreted correctly theoretical details presented sections fact handle transitive closure effectively automatically major contribution surprising explained section axioms add control behavior added predicates ftc sound necessarily complete simulating formula transitive closure occurs pure first-order formula axioms complete allowing denote stores motivated fact abstraction aid verification properties definite answer obtained information lost conservative manner means methods sound potentially incomplete proven valid valid fail prove valid valid failure due incompleteness axioms lack time space theorem prover complete proof easy write sound axiom complete limited sense finite acyclic model satisfying interpret ftc reflexive transitive closure interpretation practice worth well-known finiteness expressible first-order logic properties prove follow prove complete positive transitive-closure properties real difficulties lie proving properties involving negation induction axiom scheme solve problem add induction axiom scheme general complete recursively-enumerable axiomatization transitive closure found examples induction automatically prove desired properties axioms aides first-order theorem prover employ spass prove properties question giving spass instances induction scheme experience finds proof faster give axioms simpler induction mentioned hard part show paths exist coloring axiom schemes axiom schemes partitioning memory small set colors call instances schemes coloring axioms coloring axioms simple easily proved usingspass ten seconds induction axioms coloring axiom scheme noexit f-edges leave color class paths leave turns noexit axiom scheme implies equivalent induction scheme found practice explicitly adding coloring axioms consequences noexit enables spass prove properties fails assume programmer colors means first-order formulas transitive closure initial experience generated coloring axioms spass ability verify programs mark phase mark-and-sweep garbage collector previously reported capabilities esc java tvla succeeds approach verification methods instances precise tvla prototype implementation exciting implemented heuristics selecting colors axioms prototype spass automatically choose color axioms verify small heap-manipulating programs work initial results encouraging strengthening nelson results greg nelson considered set axiom schemes reasoning reachability function graphs graphs f-edge leaving node left open question axiom schemes complete function graphs show nelson axioms provable induction axioms show nelson axioms complete fact imply noexit outline remainder paper organized section explains notation setting section introduces induction axiom scheme fills formal framework section states coloring axiom schemes section explains details heuristics section describes related work section describes future directions preliminaries section defines basic notations paper setting notation syntax relational vocabulary pkg set relation symbols fixed arity write first-order formulas quantifiers logical connectives atomic formulas include equality vai arity binary denotes existence finite path edges formula called first-order formula precedence logical operators highest precedence lowest precedence semantics model vocabulary consists non-empty universe jaj relation universe interpreting relation symbol write formula true model setting primarily interested formulas arise proving correctness programs assume programmer specifies pre post-conditions procedures loop invariants first-order formulas transitive closure binary relations transformer loop body produced automatically program code instance establish partial correctness respect user-supplied specification program single loop establish properties loop invariant hold beginning iteration show loop invariant precondition code leading loop loop invariant provided user maintained show loop invariant holds beginning iteration loop condition holds transformer loop invariant hold end iteration finally postcondition follow loop invariant condition exiting loop general formulas form vocabulary state vocabulary state transformer predicates describe meaning module executed symbol denotes predicate operation denotes predicate operation interesting special case proof maintenance formula loop invariant form condition entering loop loop invariant loop invariant remains true body loop executed challenge formulas interest transitive closure validity formulas directly proven theorem prover firstorder logic axiomatization transitive closure original formula prove transitive closure firstorder theorem provers handle address problem replace formula appearances replaced binary relation symbol ftc show paper automatically generate first-order axiom properties valid valid theorem prover successfully proves valid explain theory process model model ftc vocabulary ftc interprets ftc reflexive transitive closure interpretation first-order formula valid iff true models axiomatization 
sound formula valid first-order reasoning sound sound iff valid complete tc-valid complete sound first-order valid tc-complete set axioms proves first-order formulas formula valid axiomatizations sound recursively enumerable tc-complete axiom system tc-sound axioms begin axiom scheme binary relation symbol ftc ftc observe complete limited finite acyclic graphs characterizes meaning ftc finite acyclic graphs reason limited give complete set first-order axioms first-order axiomatization finite proposition finite acyclic model model proof finite acyclic jaj assume f-path easy ftc conversely suppose ftc path length exists jaj ftc note acyclic f-path length exist jaj ftc generating set equal acyclicity finiteness model direction ftc ftc proposition ftc occur positively valid proof suppose note ftc occurs negatively easy show induction length path f-path ftc define model formed interpreting ftc model differs fact removed pairs ftc form ftc ftc occurs negatively contradicts assumption valid proposition shows proving positive facts form ftc easy task proving paths exist subtle proposition shows missing acyclic case first-order axiomatization finiteness traditionally reasoning natural numbers problem mitigated adding induction axioms introduce induction scheme sufficient prove property notation general denote set binary relation symbols occurs formula formula occurs conjunction axiom binary relation symbols consideration definition first-order formulas binary relation symbol induction principle ind first-order formula ftc induction principle point satisfies preserved edges point reachable point satisfies principle sound easy application induction principle cousin ftc ftc easy implies presence induction principle imply easy prove ind ftc ind prove induction reachable satisfies right-hand side related axiom scheme found transitivity reachability trans ftc ftc ftc coloring axioms describe tc-sound axioms schemes implied provable induction principle section sequel coloring axioms proving paths exist permitting verify variety algorithms section present heuristics automatically choosing instances coloring axiom schemes enable prove goal formulas coloring axiom scheme noexit axiom scheme ftc first-order formula binary relation symbol noexit f-edge leaves color class f-path leaves color class observe simple noexit follow ftc consist disjoint cycles ftc edges satisfies violates noexit acyclic models noexit follow infinite models implication hold noexit easily induction principle edges leave induction tells reachable point satisfies similarly noexit implies induction axiom ind formula coloring axiom scheme goout axiom first-order formulas binary relation symbol goout edges leaving color class path point point pass ftc ftc ftc goout induction principle assume edges enter fixed prove induction point reachable predecessor reachable coloring axiom scheme newstart axiom context dynamically changing graphs first-order formula binary relation symbols previous edge relation current edge relation newstart edges nodes path leave make change gtc ftc gtc gtc newstart induction principle proof similar proof goout remark spirit consideration coloring axioms similar found paper greg nelson introduced set reachability axioms functional predicate edge leaving point nelson asked axiom schemes complete functional setting remark nelson axiom schemes provable induction principle nelson axiom schemes complete constructed functional graph satisfying nelson axioms violating noexit nelson axiom schemes orthogonal coloring axioms proofs nelson axiom scheme states points reachable point linearly ordered soundness axiom scheme due fact functional make simplified version nelson ordering axiom scheme func order func ftc ftc ftc ftc heuristics coloring axioms section presents heuristics coloring axioms end answers questions coloring axioms theorem prover prove specific instance coloring axiom theorem prover prove part process automated present running sections illustrate heuristics explain coloring axioms describe search space axioms give algorithm exploring space conclude discussing prototype implementation developed proves presented reverse specification heuristics sections illustrated problems arise verification partial correctness list reversal procedure examples proven technique found full version paper procedure reverse shown fig performs in-place reversal singly linked list destructively updating list precondition requires input list acyclic unshared simplicity assume garbage postcondition ensures resulting list acyclic unshared ensures nodes reachable formal parameter entry reverse nodes reachable return reverse exit importantly ensures edge original list reversed returned list node reverse node node null null node return fig simple java-like implementation in-place reversal singly-linked list specification reverse shown fig unary predicates represent program variables binary predicates represent data-structure fields fig defines shorthands unary predicate point single node time binary predicate node point node partial function unique func cycles f-fields graph acyclic graph nodes shared f-fields nodes incoming f-fields unshared nodes graph reachable f-fields total helpful shorthand specifies reachable node pointed f-edges precondition reverse procedure shown fig predicates record values variable field beginning procedure precondition requires list pointed acyclic unshared requires unique func hold unary predicates represent program variables binary predicates represent fields simplicity assume garbage nodes reachable post-condition shown fig ensures resulting list acyclic unshared ensures nodes reachable formal parameter entry procedure nodes reachable return exit importantly show edge original list reversed returned list loop invariant fig describes state program beginning loop iteration node disjoint lists pointed lists acyclic unshared edge list pointed edge original list edge list pointed reverse edge original list original edge transformer fig primed predicates describe values predicates end iteration unique func acyclic unshared total pre total acyclic unshared unique func post total acyclic unshared total acyclic unshared unique unique func fig specification reverse procedure shorthands precondition pre postcondition post loop invariant transformer effect loop body proving formulas coloring axioms coloring axioms form closed formulas call axiom premise axiom conclusion axiom theorem prover prove premise subgoal conclusion proof goal formula coloring axioms explain premise proved conclusion give noexit premise pnoexit states f-edges exiting color class unary predicate appearing program premise direct result loop invariant color heavily section reachability unary predicate unary reachability formally defined examine cases pnoexit definition transitivity ftc pnoexit states path edge holds doesn change respect absence f-paths prove absence -paths cases change important part loop invariant paths part specification sketch proof refutation pnoexit arises reverse fig numbers brackets stages proof negation premise expands ntc ntc reachable transitivity ntc definition transformer edge differs clauses generated holds definition incoming edge holds list pointed acyclic cycle contradiction pnoexit hold gfed abcu ntc ntc lll llll gfed abcu yyrrrr rrr gfed abcu fig proving pnoexit cnoexit states paths ftc edges exiting proving absence paths difficult part proving formulas goout premise pgoout states edges color class unary predicates program premise holds direct result loop invariant interesting special case defined case premise note case conclusion provable 
experience axiom improving performance orders magnitude proving acyclic part reverse post condition cgoout states paths pass premise pgoout path path case nodes reachable nodes transitivity ftc means nodes reachable nodes reachable cgoout prove original list pointed reachable addition newstart premise pnewstart states edges nodes edges iteration added edges removed edges selection cases premise holds direct result definition loop invariant cnewstart means path path pass cnoexit proves paths reverse newstart scheme outgoing edges added nodes reachable edges nodes reachable nodes reachable paths added nodes reachable list pointed acyclic loop body prove acyclic end loop body newstart theorem prover reason paths color axioms theorem prover reason paths colors colors theorem prover prove facts paths prove formula interest search space axioms answer question specific instance coloring axiom attempting prove target formula define search space instances axioms instantiated colors defined arbitrary unary formula free variable binary predicates limit binary predicates target formula infeasible arbitrary unary formulas start limiting set colors initial set colors unary predicates occur formula prove interestingly colors prove postcondition mark sweep implied loop invariant axiom noexit marked extension effective reachability unary predicates defined instantiating axioms unary predicates appearing formula unary reachability predicates prove reverse list axioms needed prove reverse fig presented finally boolean combinations colors examples shown paper needed presence sharing splicing lists noexit goout newstart newstart noexit goout newstart newstart noexit newstart newstart noexit newstart newstart fig instances coloring axioms proving reverse colors based unary predicates original formula prove reverse needed part initial colors table heuristic finding initial colors cases deduced formula applies reverse interesting observation initial colors cases deduced program code previous section good deducing paths colors colors edges changed program manipulates fields pointers traverse edge direction unary predicates represent program variables including temporary variables cases initial colors group criteria roots reachable colors ftc startchange edges differ start node colors endchange edges differ end node colors group colors group colors roots startchange roots endchange table heuristic choosing initial colors results applying heuristic reverse exploring search space automate process choosing colors problem set colors choose doubly-exponential number initial colors giving axioms directly theorem prover infeasible section define heuristic algorithm exploring limited number axioms directed pseudocode algorithm shown fig operator implemented call theorem prover explore init ftrans order frc init init forever phase phase phase return success phase foreach pgoout fcgoout phase foreach pnoexit fcnoexit phase foreach cnoexit pnewstart fcnewstart fig iterative algorithm instantiating axiom schemes iteration consists phases augment axiom set coloring axioms form theorem prover prove axiom pseudocode works iteratively prove current successful adds algorithm colors increasing levels complexity boolean combinations predicates size iteration prove goal formula conclusion axiom prove premise noexit axioms proving pnewstart order instantiations axioms proving premises axioms acquired ordering chose based phases instantiate axioms axiom scheme goout instantiate axioms axiom scheme noexit finally instantiate axioms axiom scheme newstart newstart show incoming paths outgoing paths instantiate axiom pnoexit pnoexit proven implementation algorithm presented implemented perl script spass theorem prover successfully verify programs section method optimized instance added axioms prove details important practice omitted brevity prove premises spass fail terminate formula prove invalid limit time spass spend proving formula fail acquire axioms related work shape analysis work motivated experience tvla generic system abstract interpretation tvla system automatic methods paper rely user-supplied loop invariants techniques presented present paper potentially precise due full first-order reasoning shown noexit scheme infer reachability precisely evaluation rules -valued logic kleene semantics future hope develop efficient non-interactive theorem prover enjoys benefits approaches interesting observation colors needed examples prove formula unary predicates tvla define abstraction similarity future find ways automatically instantiate required axioms inductive logic programming recently learn formulas tvla abstractions holds possibility applying similar methods automate approach present paper decidable logics decidable logics employed define properties linked data structures weak monadic second-order logic define properties heap-allocated data structures conduct hoare-style verification programmer-supplied loop invariants pale system decidable logic called logic reachability expressions defined rich express shape descriptors studied path matrices introduced present paper develop decision procedures suggests methods conjunction existing theorem provers techniques incomplete theorem provers terminate initial experience extra flexibility gained first-order logic transitive closure promising prove correctness imperative destructive list-reversal natural correctness mark sweep garbage collectors scope mona simulate existing data structures decidable logics realized tricky programmer prove specific simulation invariant program giving inaccurate simulation invariant simulation unsound advantages technique present paper soundness guaranteed matter axioms instantiated simulation requirements necessarily expressible decidable logic first-order axiomatizations linked data structures closest approach aware nelson describe full version paper follow-up work leino joshi impression write-up leino joshi work pushed forward coloring axioms dynamic maintenance transitive closure orthogonal promising approach transitive closure maintain reachability relations incrementally make unit data structure cases reachability maintained first-order formulas quantifier-free formulas cases automatically derive first-order update predicates finite differencing conclusion paper reports initial attempts applying methodology preliminary conclusions drawn mentioned earlier proving absence paths difficult part proving formulas promise approach handle formulas effectively automatically shown fact successfully handle programs section full version paper issues remain work establishing induction scheme complete interesting subclasses formulas functional graphs exploring heuristics identifying color classes exploring variations algorithm fig instantiating coloring axioms exploring additional axiom schemes schemes dealing predicates partial functions predicates arise programs manipulate singly-linked doublylinked lists generally data structures acyclic dimensions iterated application field selector return previously visited node aharon abadi roman manevich interesting suggestions hoare recursive data structures int comp inf sci adel otto rosen undecidability results two-variable logics archive math logic immerman rabinovich reps sagiv yorsh boundery decidability undecidability transitive closure logics csl lev-ami sagiv tvla system implementing static analyses static analysis symp sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst reps sagiv wilhelm static program analysis -valued logic cav flanagan leino recency-abstraction lillibridge nelson heap-allocated saxe stata storage extended static checking gogul java balakrishnan sigplan conf thomas reps prog comp lang sci design dept impl ller wisconsin bgogul schwartzbach reps wisc pointer assertion abstract logic engine paper sigplan conf present prog abstraction lang heap-allocated design storage called impl recency-abstraction weidenbach gaede abstract-interpretation rock algorithms spass recover flotter non-trivial version information cadeproceed- heap-allocated ings data objects international application conference automated recency-abstraction deduction show springer-verlag resolve nelson virtual-function calls verifying stripped reachability executables invariants linked executables structures symp debugging information princ prog removed approach lang succeeded avron resolving transitive closure virtual-function call-sites mechanization previous tools mathematics analyzing thirty executables fail years resolve automating mathematics kluwer virtual-function academic call-sites introduction publishers great deal lev-ami work immerman reps algorithms sagiv 
flow-insensitive srivastava points-to yorsh analysis including simulating algorithms reachability exhibit first-order varying logic degrees applications verification contextsensitivity linked data structures algorithms flow-sensitive http points-to tau analysis tla papers aforementioned cade work full pdf simple cousot abstraction cousot heap-allocated abstract storage interpretation call unified lattice allocation-site model abstraction static analysis nodes programs allocated construction approximation allocation site fixpoints folded popl proceedings single summary acm node sigact-sigplan symposium terms principles precision programming allocation-site abstraction produce poorquality information strong updates performed strong update overwrites contents abstract object represents definite change concrete objects abstract object represents strong updates generally performed summary objects concrete update affects summarized concrete objects allocation site loop function called allocate multiple nodes addresses points-to fact points means program variable point nodes represents assignment form selector pointsto-analysis algorithms ordinarily forced perform weak update selector edges emanating nodes points accumulated abstract execution assignment field summary node kill effects previous assignment general nodes represents updated concrete execution assignment statement imprecisions snowball additional weak updates performed assignments form selector selector weak updates adverseeffects determine properties heap-allocated data structures mitigate effects weak updates pointer-analysis algorithms literature side-step issue soundness instance number pointer-analysis algorithms flow-insensitive flow-sensitive initial points-to set pointer variable assumed void foo int int malloc sizeof int initialization void foo int int malloc sizeof int fig weak-update problem malloc blocks local variables malloc-site variables assumption initial safe over-approximate program behaviors program shown fig illustrates issue fig initialized paths leading fig initialized paths leading pointer-analysis algorithm makes unsafe assumption mentioned detect malloc-blockpointed possibly uninitialized dereference fig algorithm concludes correctlythat modifieseither orb fig algorithm concludes incorrectly modifies sound hand assuming malloc-block point variable heap-allocated object immediately call malloc leads sound imprecise points-to sets versions program fig problem pointer-analysis algorithm interprets statements performs weak update assumed point variable heap-allocated object performing weak update improve points-to sets malloc-block remains algorithm concludes modify variable heap-allocated object program overcome lack soundness tracking variables fields heap-allocated data structures uninitialized separate analysis part pointer analysis approach encounter weak-update problem fields heap-allocated data structures instance program fig initial state malloc-block set uninitialized dataflow analysis processing change state source-code analyses typically criterion variable address place variable unsound programs pointer arithmetic perform arithmetic operations addresses executables malloc-block initialized points summary object fields memory allocated malloc-siteswill reported possibly uninitialized multiple summary nodes allocation site summary node qualified amount calling context overcome problem algorithms perform weak updates extreme family heap abstractions introduced discover information shapes heap-allocated data structures program pointer variables point abstractions generally strong updates performed capable providing precise characterizations programs manipulate linked data structures methods costly space time inability perform strong updates precise points-to information obtained pointer-valued fields precise numeric information obtained int-valued fields instance interval analysis abstract interpretation determines interval variable over-approximates variable set values int-valued field heap-allocated data structure initialized meaning int performing weak update leave field making unsound assumptions empty interval initial int-valued fields nullifies soundness guarantees abstract-interpretation results analysis prove absence bugs paper present abstraction heap-allocated storage referred recency-abstraction middle extremes summary node malloc site complex shape abstractions recency-abstraction enables strong updates performed cases time ensures results sound recency-abstraction incorporates number ideas literature including associating abstract malloc-blocks allocation sites allocationsite abstraction isolating distinguished non-summary node represents memory location updated statement k-limiting approach shape analysis based -valued logic history relation record information node past state attaching numeric information summary nodes characterizethe number concrete nodes represented efficiency associating program point single shape-graph independent-attribute abstraction track information individual heap locations contributions work propose inexpensive abstraction heap-allocated data structures obtain results objects allocated heap apply abstraction challenging context study effectiveness measured resolves virtualfunction calls stripped executables obtained code recency-abstraction permits tool recover information pointers virtual-function tables assigned objects source code call class virtual methods recencyabstraction ourtool wasable resolve virtual-function call-sites previous tools analyzing executables including idapro commercial disassembler previous work recency abstraction fail resolve virtual-function call-sites recency-abstractionis beneficial initialization objects successive allocations allocation site effective initializing vft-field field object holds address virtual-function table usual case vft-field initialized constructor remains unchanged inside methods operate lists doubly-linked lists linked data structures analysis based recency-abstractionwould typically forced perform weak updates recency-abstraction methods shape analysis based -valued logic materialize non-summary node memory location updated statement make strong update analysis methods considerably expensive time space remainder paper organized background issues arise resolving virtual-function calls executables describes recency-abstraction heap-allocated data structures experimental results evaluating techniques discusses related work resolving virtual-function calls executables recent years increasing tools programmers security analysts understand executables instance commercial companies military increasingly commercial off-the shelf cots components reduce cost software development interested ensuring cots components perform malicious actions forced perform malicious actions resolving virtual-function calls executables important code-understanding aid analysts examine executables recovering intermediate representations irs additional analyses performed recovered engler chen wagner poor information virtual-function calls typically forces tool builders treat conservatively call function address source false positives call execution halt analysis proceed sites virtual-function calls source false negatives iii unsound fashion call no-op function returns immediately lead false negatives false positives section discuss issues arise resolve virtualfunction calls executables executable compiled program inheritance virtual functions bytes object address virtual-function table refer bytes vft-field executable call results operations call malloc allocate memory call constructor initialize things vft-field virtual-function call source code translated indirect call vft-field fig malloc mallocblock virtualtable fig resolving virtual-function calls executables double box denotes summary node source code resolving virtual-function calls associate type information pointer returned call propagatethat information pointers assignmentstatements type information executables resolve virtual-function call information contents vft-field static-analysis algorithm determine information track flow information instructions constructor fig illustrates results allocation-site abstraction allocation-site abstraction establish link object virtual-function table summary node represents block interpretation instruction sets vft-field perform weak update join virtualfunction table address existing addresses overwrite vftfield object address virtual-function table call malloc fields object shown computing join results means vft-field point memory shown dashed arrows definite link object virtual-function table established conservative algorithm desired client analysis conclude virtual-function call resolve function key resolving virtual-function calls executables establish 
vft-field points virtual-function table describes abstract domain value-set analysis vsa combined pointer-analysis numeric-analysis algorithm track flow data executable version vsa domain version limitations discussed perform weak updates describes extension vsa domain recency-abstraction shows establish definite link object vft-field virtual-function table circumstances value-set analysis vsa combined numeric-analysis pointer-analysis algorithm determines over-approximation set numeric values addresses variable holds program point key feature vsa takes account pointer arithmetic operations tracks integer-valued address-valued quantities simultaneously crucial analyzing executables numeric values addresses indistinguishable runtime pointer arithmetic extensively executables vsa set addresses numeric values represented safe approximation refer value-set memory-regions runtime address space separation activation records procedures heap memory global data analysis executable break address space set disjoint memory areas referred memory-regions memory-region represents group locations similar runtime properties runtime locations belong activation record procedure belong memory-region program kinds regions global-region information locations correspond global data arregions information locations corresponds activationrecord procedure malloc-regions information locations allocated malloc site performing source-code analysis programmer-defined variables provide convenient compartments tracking data manipulations involving memory stripped executables information programmer-defined variables work variable-recovery mechanism obtain variable-like entities stripped executables variable-recovery algorithm identifies structure memory-region based data-access patterns executable treats field structure recovered memory region variable instance suppose structure ar-region procedure struct int struct int int procedure treated int-valued variables similarly fields malloc-regions treated variables general memory-region varr denotes variables uniformity registers treated variables value-sets value-set safe approximationfor set addressesand numeric values suppose number regions executable valueset n-tuple strided intervals form component tuple representing set addresses region -bit machine strided-interval represents set integers mod called stride called interval languages acm represents press loginov reps singleton sagiv set abstraction call-strings refinement call-graph inductive learning program proc labeled graph computer-aided node verif represents elgaard procedure edge ller represents call schwartzbach label compile-time debugging edge represents programs working call-site trees call european represented symp edge programming callstring benedikt sequence reps call-sites sagiv decidable logic call-site belongs describing linked entry data procedure structures exists european path symp call-graph consisting programming edges sagiv labels reps wilhelm callstring solving set shape-analysis problems languages call-strings program destructive updating trans prog lang syst call-string hendren suffix parallelizing length programs recursive data structures phd thesis cornell univ ithaca call-sites immerman represents rabinovich string reps call-sites sagiv yorsh verification referred structure saturated call-string simulation represents proc set computer-aided callstring verif leino callstringk recursive set object callstring types suffixes length logic object-oriented non-saturated programs call-strings nordic length call-graph shown computing fig dong set callstring incremental call-graph decremental evaluation transitive closure first-order queries inf call-string length memory-region comput status patnaik map comment immerman dyn-fo mainmapsto parallel amapsto dynamic complexity mapsto class journal inaccessible computer system mainmapsto bmapsto sciences mapsto hesse dynamic inaccessible computational complexity mainmapsto phd thesis amapsto department mapsto computer science mapsto umass fig amherst reps call-graph sagiv memory-region loginov status map finite differencing call-strings logical key formulas non-summary static analysis summary refers european symp saturated call-string vsa programming hendren flow-sensitive hummel context-sensitive nicolau abstract-interpretation algorithm abstractions parameterized recursive call-string pointer data length independent-attribute method structures sense improving analysis based abstract transformation domain imperative programs simplify sigplan conf presentation prog discussion lang design sectionuses impl york acm heap-allocated storage press 
proc denote set memory-regions procedures program allocmemrgn denotes set memory regions heapallocation sites global denote memory-region global data area work basic domains memrgn global proc allocmemrgn valueset memrgn stridedinterval varenv varr valueset absenv maps region varenv register valueset absenv register valueset global varenv global proc varenv proc allocmemrgn varenv allocmemrgn vsa associates program point absmemconfig absmemconfig callstringk absenv vsa abstract transformers passed memory-region status map memory-regions context call-string summary memory-regions global region alwaysnon-summary malloc-regions summary decide procedure memory-region summary memory-region call-string traversed call graph traversed runtime stack multiple pending activation records fig shows memory-region status map call-strings length memory-regionstatus map providesone twopieces information identify strong update performed abstract transformer perform strong update operation modifies register non-array variable non-summary memory-region illustrate vsa program shown fig regions global main malloc value-sets obtained vsa bottom loop body shown fig fig shows value-sets terms variables program mapsto global mapsto global address range elem mapsto malloc mapsto elem offset malloc-region malloc-site head mapsto malloc mapsto head offset malloc-region malloc-site elema mapsto elemnext mapsto elema elemnextmay vsa determine value-sets variables weak-update problem mentioned earlier malloc initialize block memory rein implementation vsa applied executables code ease understanding struct list int struct list int main int struct list head null struct list elem elem struct list malloc sizeof struct list elema elemnext head head elem return main mapsto mapsto global mapsto head mapsto malloc mapsto elem mapsto malloc mapsto malloc mapsto field mapsto field mapsto mapsto global mapsto head mapsto malloc mapsto elem mapsto malloc mapsto elema mapsto elemnext mapsto elem head fig value-set analysis vsa results allocation-site abstraction program value-sets registers global variables omitted value-sets interpreted terms variables program graphical depiction double box denotes summary region dashed edges denote may-points-to information turns vsa assumes safely elema elemnext call malloc malloc summary memory-region weak updates performed instructions initialize fields elem value-sets fields elem remain fig shows information pictorially double box denotes summary object dashed edges denote may-points-to information vsa recovered head elem point objects represented summary object elemnext point location elema square abstraction heap-allocated storage section describes recency-abstraction recency-abstraction similar respects allocation-site abstraction abstract node allocation site recency-abstraction memory-regions allocation site allocmemrgn mrab nmrab allocation site mrab represents most-recently-allocated block allocated block concrete configuration mrab summary memory-region nmrab represents blocks allocated blocks concrete configuration nmrab generally summary memory-region addition mrab nmrab allocmemrgn count denoted mrab count nmrab count type smallrange count records range concrete blocks memoryregion represents nmrab count smallrange mrab count restricted values represent counts non-summary regions abstract transformer perform strong update field mrab addition count mrab nmrab allocmemrgn size denoted mrab size nmrab size type stridedinterval size represents over-approximation set sizes concrete blocks memoryregion represents information report potential memoryaccess violations involve heap-allocated data instance mrab size allocation site dereference pointer value-set mrab mapsto reported memory-access violation fig shows trace evolution parts absenvs instructions loop vsa assumed fields memory-regions mrab nmrab shown rectangles mrab nmrab double boxes nmrab objects fig summary memory-regions brevity fig effect instruction denoted syntax original source code loop body statement class virtual methods symbols fig represent addresses methods symbol fields represent variables global region dotted lines fig nmrab malloc statement depends mrab nmrab malloc statement absenvs stabilize iterations note fig established instruction modifies field non-summary memory-region strong update performed establishes definite link must-point-to link mrab net effect analysis establishes definite link nmrab field object represented nmrab point square fig shows improved vsa information recovered program fig end loop recency-abstraction information elem head point beginning mrab region elema values global addresses mrab mrab malloc mrab nmrab nmrab mrab malloc mrab nmrab nmrab mrab malloc mrab nmrab nmrab mrab malloc fig trace evolution parts absenvs instructions loop values unspecified values presented illustrate applied fields previous mrab merged nmrab abstract interpretation allocation site elemnextmay null point beginning nmrab region nmrab values global addresses nmrab null 
point beginning nmrab region square mrab nmrab head elem fig improved vsa information program fig end loop recency-abstraction double box denotes summary region dashed edges denote may-points-to information idea formalized basic domains underlining differences domains memrgn global proc allocmemrgn valueset memrgn stridedinterval varenv varr valueset smallrange allocabsenv smallrange stridedinterval varenv analysis associates program point absmemconfig absenv register valueset global varenv global proc varenv proc allocmemrgn allocabsenv allocmemrgn absmemconfig callstringk absenv count size varenv denote smallrange stridedinterval varenv allocmemrgn allocmemrgn absenv absenv maps allocation memory-regions mrab nmrab count size varenv triples transformers operations defined entry point program absmemconfig describes initial state records allocation site allocabsenvs mrab nmrab stridedinterval var valueset transformer allocation site transforms absenv absenv absenv isidentical absenv valuesets absenv mrab mapsto nmrab mapsto nmrab mapsto absenv code return values passed back register eax size denote size block allocated allocation site size obtained value-set parameter allocation method addition absenv updated arguments absenv mrab size var valueset absenv nmrab count absenv nmrab count absenv mrab count absenv nmrab size absenv nmrab size absenv mrab size absenv nmrab varenv absenv nmrab varenv absenv mrab varenv absenv eax global mapsto mrab mapsto denotes smallrange addition present implementation assume allocation succeeds place lines absenv mrab size var valueset absenv eax mrab mapsto analysis explores behavior system executions allocations succeed join absenv absenv absenv absenv absenv performed pointwise absenv mrab absenv mrab absenv mrab absenv nmrab absenv nmrab absenv nmrab join allocmemrgns performed pointwise count size varenv count size varenv count count size size varenv varenv abstract transformers assignments data movements interpretation conditions mrab nmrab treated memory regions global ar-regions exception vsa abstract transformers passed memory-region status map memory-regions context call-string suffix summary memory-regions summary-status information mrab nmrab obtained values absmemconfig mrab count absmemconfig nmrab count experiments section describes results preliminary experiments columns numbers tab show characteristics set examples evaluation programs originally pande ryder evaluate algorithm resolving virtual-function calls programs programs compiled optimization microsoft visual studio compiler obj files obtained compiler analyzed make debugging information experiments final columns tab report performance accuracy time version vsa incorporates recency abstraction resolve virtual-function calls examples indirect call-site executable corresponds virtual-function call-site source code columnlabeled showsthe number apparently unreachableindirect call-sites column labeled shows number reachable indirect call-sites vsa determine targets non-zero column means indirect call-sites vsa resolve virtual-function call specific subset procedures vsa reports note unoptimized programs generally memory accesses optimized programs optimized programs make registers easier analyze memory accesses static analysis stripped executables unoptimized programs generally represent greater challenge optimized programs procs indirect reachable time instructions call-sites call-sites resolved secs primes family vcirc fsm office trees deriv chess objects simul greed shapes ocean deriv table characteristics programs distribution number callees indirect call-sites running times vsa bold entry call-sites deriv identified unreachable call-sites user explore procedures call-site source false negatives occurred programs hand programs -column callsites reported -column unreachable call-sites identified unreachable deriv unreachable columns show distribution number targets indirect call-sites column labeled denotes number indirect call-sites single target important realize results obtained solely abstract interpretation track flow data memory including heap analysis algorithm rely symbol-table debugging information structure-discovery mechanism average method resolved virtual-function call-sites previous tools analyzing executables idapro previous work vsa recency abstraction fail resolve virtual-function call-sites manual inspection revealed situations vsa resolve indirect call-sites due vsa establish loop initializes elements array problem programs array pointers objects initialized loop pointers perform virtual-function call vsa succeeded establishing link vft-field virtual-function table vsa establish elements array initialized instruction loop abstract represents values elements array remains note issue orthogonal problem addressed paper mechanisms establish elements array initialized problem establishing link vft-field virtual-function table requires mechanisms similar recency-abstraction issue makes difficult give direct comparison approach makes unsafe assumption elements array pointers locally allocated heap allocated initially point suppose array pointers loop initializes element sound result elements point algorithmused points-to set initially determine elements point unsound related work relationships approach past work abstractions heap-allocated storage mentioned end recency-abstraction similar flavor allocation-site abstraction abstract node allocation site recency-abstraction designed advantage fact vsa flow-sensitive context-sensitive algorithm note recency-abstraction flow-insensitive algorithm provide additional precision allocation-site abstraction flow-insensitive algorithm abstract memory configuration expresses program-wide invariant algorithm perform weak updates assignments mrab nodes assignments nmrab nodes edges emanating mrab node accumulated flow-sensitive algorithm recency-abstraction abstract nodes allocation-site abstraction conditions sound algorithm perform strong updates assignments mrab nodes crucial establish definite link set objects allocated site virtual-function table ignores actual addresses allocated objects adopts fiction allocation site generates objects independent produced allocation site difference recency-abstraction allocation-site abstraction light allocation-site abstraction imposes fixed partition set allocated nodes recency-abstraction shares multiple-partition property sees shape-analysis abstractions mrab node represents unique node concrete memory configuration recently allocatednode allocationsite general abstract memory configuration represents multiple concrete memory configurations mrab node generally represents concrete nodes concrete memory configurations hackettandrugina describea method useslocalreasoningabout individual heap locations global reasoning entire heap abstractions essence independent-attribute abstraction tracked location trackedindependently locations concretememory configurations recency-abstractionis independent-attribute abstraction count information mrab nodes inspired heap abstraction yavuz-kahveci bultan attaches numeric information summary nodes characterize number concrete nodes represented information summary node abstract memory configuration describes number concrete nodes mapped concrete memory configuration represents gopan attach numeric information summary nodes information provide characterizationof number concrete nodes represented present paper concrete node combined summary node contributes sum labels summary node contrast concrete nodes combined approach presented effect create set values additional numeric abstraction applied size information mrab nodes thought abstraction auxiliary size information attached concrete node concrete size information abstracted style strictly speaking counts abstract heap nodes lies frameworkof programanalysisusing -valued logic framework extended counting quantifiers sect counts related notion active inactive individuals logical structures -valued logic framework give compact representation logical structures chap general independent-attribute method heap abstraction avoid combinatorial explosion -valued logic framework suffers -valued logic framework retains separate logical structures combinations present absent nodes counts permit combined algorithms proposed resolve virtualfunction calls java programs pointer algorithms determine over-approximation set types objects point virtual-function call invocation set types disambiguate targets call static information class hierarchy aliases set instantiated objects reduce size set types pointer work stripped executables type information method presented 
analyzes code constructor initializes virtual-function pointer object establish definite link object virtual-function table subsequently resolve virtual-function calls algorithms rapid type analysis rta class hierarchy analysis cha rely programs type-safe results cha rta relied presence arithmetic operations addresses present executables andersen binding-time analysis taming pointers pepm pages bacon sweeney fast static analysis virtual function calls object-oriented programming systems languages applications pages balakrishnan reps analyzing memory accesses executables comp construct pages balakrishnan reps recovery variables heap structure executables tech rep comp sci dept univ wisconsin madison september calder grunwald reducing indirect function call overhead programs princip prog lang pages chase wegman zadeck analysis pointers structures prog lang design impl pages chen wagner mops infrastructure examining security properties software conf comp commun sec pages november cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation prog lang design impl pages das unification-based pointer analysis directional assignments prog lang design impl pages dean grove chambers optimization object-oriented programs static class hierarchy analysis european conference object-oriented programming pages engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions syst design impl pages ahndrich rehof das scalable context-sensitive flow analysis instantiation constraints prog lang design impl foster ahndrich aiken polymorphic versus monomorphic flowinsensitive points-to analysis sas gopan dimaio dor reps sagiv numeric domains summarized dimensions tools algs construct anal syst pages gopan reps sagiv framework numeric analysis array operations princip prog lang pages guo bridges triantafyllis ottoni raman august practical accurate low-level pointer analysis ieee acm int symp code gen opt pages hackett rugina region-based shape analysis tracked locations princip prog lang pages hind pioli assessing effects flow-sensitivity pointer alias analyses sas horwitz pfeiffer reps dependence analysis pointer variables prog lang design impl pages idapro disassembler http datarescue idabase immerman descriptive complexity springer-verlag jones muchnick flow analysis optimization lisp-like structures muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs jones muchnick flow analysis optimization lisp-like structures muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs jones muchnick flexible approach interprocedural data flow analysis programs recursive data structures princip prog lang pages larus hilfinger detecting conflicts structure accesses prog lang design impl pages lev-ami tvla framework kleene based static analysis master thesis tel-aviv tel-aviv israel lev-ami reps sagiv wilhelm putting static analysis work verification case study int symp softw testing analysis pages milanova rountev ryder parameterized object sensitivity points-to analysis java tosem pande ryder data-flow-based virtual function resolution sas pages patnaik immerman dyn-fo parallel dynamic complexity class symp princ database syst reps balakrishnan lim recovery low-level code pepm sagiv reps wilhelm solving shape-analysis problems languages destructive updating trans prog lang syst january sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications chapter pages prentice-hall steensgaard points-to analysis almost-linear time princip prog lang stransky lattice abstract interpretation dynamic lisp-like structures inf comp nov sundaresan hendren razafimahefa vall ee-rai lam gagnon godin practical virtual method call resolution java object-oriented programming systems languages applications pages whaley lam cloning-based context-sensitive pointer alias analyses binary decision diagrams prog lang design impl yavuz-kahveci bultan automated verification concurrent linked lists counters sas 
codesurfer platform analyzing executables gogul balakrishnan radu gruian thomas reps tim teitelbaum comp sci dept wisconsin fbgogul repsg wisc grammatech fradu ttg grammatech abstract codesurfer prototype system analyzing executables static-analysis algorithm called value-set analysis vsa recover intermediate representations similar compiler creates program written high-level language major challenge building analysis tool executables providing information operations involving memory cult symbol-table debugging information absent untrusted codesurfer overcomes challenges provide analyst powerful exible platform investigating properties behaviors potentially malicious code cots components plugins mobile code worms trojans virus-infected code codesurfer gui codesurfer scripting language access intermediate representations codesurfer builds executable iii grammatech path inspector tool sophisticated pattern-matching engine answer questions execution program introduction recent years growing tools analyze executables computer-security issues provide motivation ensure third-party applications perform malicious operations context important analysts decipher behavior trojans worms virus-infected code static analysis techniques problems obstacles overcome potentially malicious programs symbol-table debugging information absent relied present instructions perform memory operations explicit memory addresses indirect addressing complicates task understanding behavior code proposed algorithms statically analyzing executables existing tools assume presence symbol-table debugging information ignore instructions memory operands altogether assume instruction memory operands writeto read-from part memory solutions satisfactory terms understanding executable works recently balakrishnan reps developed static-analysis algorithm called value-set analysis vsa supported air force afrl rome sbir contracts -fcc- onr contracts -c-c- nsf grant ccrto recover information contents memory locations manipulated executable combining vsa facilities provided idapro codesurfer toolkits created codesurfer prototype tool browsing inspecting analyzing executables executable codesurfer recovers intermediate representation similar created compiler program written high-level language document emphasize facilities codesurfer provide analyst powerful exible platform investigating properties behaviors executable codesurfer works actual executable code run machine automatically takes account platform-speci aspects code positions sets variables run-time stack activation records key ability security exploits depend platform-speci features structure activation records sense codesurfer higher delity tool tools analyze source code codesurfer codesurfer outcome joint project univ wisconsin grammatech codesurfer makes idapro disassembly toolkit grammatech codesurfer system toolkit building program-analysis inspection tools fig shows components codesurfer section sketches components combined codesurfer fig organization codesurfer executable rst disassembled idapro addition disassembly listing controlow graphs idapro access information procedure boundaries calls library functions identi algorithm called fast library identi cation recognition technology flirt statically memory addresses sets idapro access internal resources api users create plug-ins executed idapro created plug-in idapro called connector creates data structures represent information obtained idapro idapro connector combination create data structures dynamically linked libraries link data structures represent program infrastructure permits whole-program analysis carried including analysis code library functions called based data structures connector implemented static analysis algorithm called value-set analysis vsa vsa assume presence symbol-table debugging information rst step set data objects called a-locs abstract locations determined based static memory addresses sets provided idapro vsa combined numeric pointer-analysis algorithm determines over-approximation set numeric values addresses a-loc holds program point set addresses numeric values referred value-set key feature vsa tracks integer-valued address-valued quantities simultaneously crucial analyzing executables numeric values addresses indistinguishable executable note idapro identify targets indirect jumps indirect calls call graph controlow graphs constructs complete information computed vsa augment call graph controlow graphs on-they account indirect jumps indirect calls fact relationship vsa preliminary irs created idapro similar relationship points-to-analysis algorithm compiler preliminary irs created compiler front end cases preliminary irs eshed analysis vsa completes value-sets a-locs program point determine point sets killed possibly-killed locs emitted format suitable input codesurfer codesurfer takes information builds collection irs consisting abstract-syntax trees controlow graphs cfgs call graph system dependence graph sdg sdg consists set program dependence graphs pdgs procedure program vertex pdg corresponds construct program statement instruction call procedure actual parameter call formal parameter procedure edges correspond data control dependences vertices pdgs connected interprocedural edges represent control dependences procedure calls entries data dependences actual parameters formal parameters return values dependence graphs invaluable applications highlight chains dependent instructions widely scattered program instruction data-dependence predecessors instructions write locations read instruction control-dependence predecessors control points ect instruction executed similarly vsa debugging symbol-table information principle extend vsa information instruction data-dependence successors instructions read locations written instruction control-dependence successors instructions execution depends decision made control point codesurfer facilities sect executable input codesurfer builds collection irs addition building irs codesurfer checks executable conforms standard compilation model runtime stack maintained activation records ars pushed stack procedure entry popped stack procedure exit procedure modify return address stack program instructions occupy xed area memory self-modifying separate program data con rmed executable conforms model possibly incorrect call-graph incorrect procedure modi return address stack codesurfer issues error reports nds violations standard compilation model analyst reports determine false alarms real violations codesurfer gui supports browsing sur sdg variety operations making queries sdg slicing chopping gui user navigate assembly code dependences manner analogous navigating world wide web codesurfer api programmatic interface operations lower-level information individual nodes edges program sdg call graph controlow graph node sets killed possibly-killed a-locs writing programs traverse codesurfer irs implement additional program analyses api extend codesurfer capabilities codesurfer conjunction grammatech path inspector tool sophisticated pattern-matching engine answer questions execution program path inspector checks sequencing properties events program context security analysis answer questions program bypass authentication routine program trapdoor path inspector questions posed questions existence problematic event sequences checking query problematic path exists displayed path explorer tool lists program points occur problematic path items backward slice program respect set program points set program points ect computations performed forward slice respect set program points ected computations performed members program chop set source program points set target program points shows ect points chopping key operation informationow analysis linked disassembly analyst navigate point path assembly-code element addition path inspector analyst step forward backward path simultaneously stepping assembly code code-stepping operations similar single-stepping operations traditional debugger balakrishnan reps analyzing memory accesses executables comp construct pages cifuentes fraboulet interprocedural data recovery high-level language code assembly technical report univ queensland cifuentes simon fraboulet assembly high-level language translation int conf softw maint pages codesurfer grammatech http grammatech products codesurfer debray muth weippert alias analysis executable code princ prog lang pages ferrante ottenstein warren program dependence graph optimization trans prog lang syst fast library identi cation 
recognition technology datarescue ege belgium http datarescue idabase irt htm horwitz reps binkley interprocedural slicing dependence graphs trans prog lang syst january idapro disassembler http datarescue idabase mycroft type-based decompilation european symp programming reps rosay precise interprocedural chopping found softw eng rival abstract interpretation based certi cation assembly code int conf verif model checking abs int 
automatic assume guarantee reasoning heap-manipulating programs ongoing work greta yorsh alexey skidanov thomas reps mooly sagiv school comp sci tel-aviv univ fgretay skidanov msagivg post tau comp sci dept univ wisconsin reps wisc abstract assume guarantee reasoning heap-manipulating programs challenging heap mutated arbitrary procedure calls potential side-effects procedure non-trivial report on-going effort reduce burden reasoning heap-manipulating programs automatically generating post-conditions estimating side-effects non-recursive procedures method sound combines theorem provers abstract-interpretation algorithms key words assume-guarantee reasoning side-effect mod-clauses shape analysis abstract interpretation theorem prover introduction shape-analysis algorithms statically analyze program determine information heap-allocated data structures program manipulates algorithms conservative sound discovered information true input analysis large programs presents major problem existing shape analyzers ongoing work investigates possibility scaling shape analysis handle larger programs assume guarantee reasoning main idea require programmer aspects behavior procedure called contract apply shape analysis analyze procedure isolation contracts procedures contracts impose burden programmer potential sideeffects procedure complex issue express preand post-conditions method independent calling context research investigates orthogonal alternative assume potential side-effects programmer require pre-condition method code include preprint submitted elsevier preprint january recursive calls apply abstract-interpretation algorithms compute procedure conservative over-approximation postcondition method conservative over-approximation potential side-effects method depend formal parameters method fields assuming loss generality global variables program information computed analysis procedure analyzing invocations shown method applicable partially postconditions order estimate potential side-effects strengthening provided post-conditions details scope paper technically employ theorem prover compute safely initial abstract corresponds procedure pre-condition calculate abstract effects procedure calls precise avoid compute potential side-effects abstract fields called instrumentation relation tvla jargon object oriented programs challenging features including intensive usage heap ability redefine behavior inheritance paper address problem analyzing heap rely existing methods handle inheritance make simplifying assumption working single-threaded programs overview section semi-technical overview method automatic assume guarantee reasoning programs manipulate heap-allocated data structures process paper restrict attention non-recursive procedures analyze procedures procedure analyzed abstract represents superset stores fulfilling precondition outcome analysis safe approximation post-condition including potential side-effects procedure analysis verify safety properties absence memory leaks null dereferences user-defined assertions including post-conditions analysis procedure computed post-conditions invoked procedures symbolic operations realize process implemented operations theorem prover assert assume assert operation takes formula first-order logic transitive closure abstract returns true concrete stores represented abstract satisfy formula assume operation takes formula first-order logic transitive closure abstract returns abstract recursive calls handled employing existing interprocedural shape-analysis algorithms typedef struct listf int struct list list list create int requires true list null k-f list malloc sizeof struct list return list append list list requires acyclic list null return null return void main requires true list create create create append append fig running program allocates disjoint acyclic singly-linked lists calls append concatenate lists integers refines input abstract eliminating concrete stores satisfy formula running fig shows simple program manipulates linked lists show analysis establish absence memory leaks null dereferences program analyzing procedure analyze append create leaf procedures analyze main procedure results analyses create append analyzing append start analyzing procedure append method generates abstract conservatively represents stores satisfy precondition append precondition append requires list argument acyclic list pointed assume operation generates set shape graphs denoted describes concrete stores singly-linked lists pointed list acyclic abstract shape graphs denoted shown fig degenerate cases list pointed empty element rest examples ignore degenerate cases nodes represent locations pointed summary nodes depicted double circles represent location tails respective lists nodes precision analysis depends ability assume eliminate sufficiently stores assume generate abstract cases problem undecidable solve efficiently fig shape graphs generated assume pre append shape graphs result analysis append relations rea reb record entry values relations summary node denotes rest store nodes reachable fig shape graph represents non-empty stores generated assume pre create shape graphs generated create acyclic newly allocated list length pointed fig shape graphs call append shape graphs result assume post append nodes marked marked represent locations reachable note nodes marked means concrete stores represented list pointed acyclic required precondition append dotted edge node node locations represented n-fields point locations represented require precondition lists unshared nodes pointed field dotted edges represent n-fields locations represented nodes note marked meaning locations represented nodes reachable summary node denotes rest store nodes reachable soundness analysis presence complex heap-aliasing calling context ensured conservatively representing heap cells represent stack contexts invisible variables modified procedure abstract interpretation analyze code ofappend conservative shape analysis capable demonstrating absence memory leaks null dereferences append generates abstract describes concrete stores arise exit append shape graphs denoted shown fig degenerate cases analysis detects location list pointed modified location n-field node points exit locations reachable formal parameters append modified shape graph remove information local variable ofappend invisible caller ofappend proceduremain fig means erasing node general abstract nodes merged resulting set shape graphs formal parameters n-fields values recorded entry procedure instrumentation relations track correlation values fields entry exit abstraction track location field modified depicted marking node corresponds location marked change explained sec abstract encoded equivalent logical formula precisely describes stores represented formula postcondition forappend post-condition formulas differ pre-condition formulas relate stores entry procedure stores exit technically expressed special auxiliary relations pentry refers relation entry procedure similar keyword eiffel jml notice analysis establishes absence memory leaks null dereferences inappendnot program programs precondition append satisfied reason conservatively analyzed append input abstract describes stores satisfy precondition post-condition generated describes behavior append programs analyzing create precondition create true method generates abstract shape graph shown fig shape graph represents empty store describes stores location n-fields unknown values denoted dotted edge node shape analysis establishes absence memory leaks null dereferences create generates abstract shape graph shown fig represents stores return create points acyclic unshared list length remove local variable shape graphs generated exit create encode resulting abstract values equivalent formula post-condition create analyzing main intraprocedural statements analyzed usual procedure calls interpreted checking precondition assuming postcondition crucial issue maintain information store call allowing procedure mutate parts store precondition procedure main true analysis main starts abstract describes concrete stores skip description analysis calls create result denoted shown fig represents stores point disjoint acyclic unshared lists length check assert operation precondition append holds stores represented analyzing code append call assume operation generate abstract 
post-condition append generated previous step post-condition information fields modified fields modified information assume operation figure stores generated append list pointed acyclic input lists pointed acyclic call locations unmodified location introduce cyclicity lists disjoint shows precondition call append holds fact conclude memory leaks null dereferences main technically calls handled standard notion two-vocabulary store relates store call procedure twovocabulary store versions binary relation symbol unprimed version describes store call primed version describes store call two-vocabulary store locally modelling call primed relations involved analysis program statements shows establishing simple properties caller absence memory leaks requires establishing stronger properties callee acyclicity analysis conservative fail establish properties program hold analysis precise compute post-condition stronger post-condition user provide preliminaries method paper based shape-analysis framework implemented tvla system three-valued-logic analyzer stores logical structures approach concrete memory configurations stores encoded logical structures vocabulary relation symbols arities terms fixed collection core relations core relations part underlying semantics language analyzed record atomic properties stores instance represent stores manipulated programs type list declared fig relation denote pointer variable points memory cell denote n-field points -valued logical structures represent memory configurations individuals set memory cells nullary relation represents boolean variable program unary relation represents pointer variable booleanvalued field record binary relation represents pointer field record integrity constraints capture semantic requirements logical structures represent stores binary relation represents pointer field partial function model dynamic memory allocation additional unary relation active conceptually assume number nodes structure infinite active set false nodes empty heap allocation modelled setting active true newly allocated node simplify exposition omit active relation paper set stores represented finite set -valued logical structures abstraction defined equivalence relation individuals finite quotient structure respect equivalence relation individual -valued logical structure representing concrete memory cell mapped individual -valued logical structure vector values concrete individual user-chosen collection unary abstraction relations relations collapsed canonical abstraction ensures -valued structure larger fixed size priori graphical notation depicting -valued logical structures individuals represented circles names values unary relations values omitted summary individual represented double circle unary relation pointer-valued program variable represented solid arrow individual absence p-arrow node binary relation represented solid arrow labeled pair individuals absence q-arrow pairs relations represented dotted arrows instrumentation relations abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation relations record derived properties varying unary core unary instrumentation relations set abstraction relations instrumentation relation symbol arity defined instrumentation-relation definition formula free variables instrumentation relation symbols defining formulas instrumentation relations long circular dependences introduction unary instrumentation relations abstraction relations control concrete individuals merged abstract individual control amount information lost abstraction instrumentation relations involve reachability properties defined operator transitive closure play crucial role definitions abstractions instance reachability properties specific pointer variables effect keeping disjoint sublists summarized separately instrumentation relations analysis programs type list relation denotes reachable pointer variable fields defined relation means directed cycle fields defined relation symbols abbreviated figures shown sec standpoint concrete semantics instrumentation relations represent cached information recomputed reevaluating instrumentation relation defining formula local state standpoint abstract semantics refines abstraction keeping information precise reevaluating instrumentation relations defining formula assume pre aentry record entry analyze aentry project post pre formals actuals pre assert pre post formals actuals post post rename post primed unknown assume post primed unprimed fig analysis procedure call procedure local -valued structure lead precise bottom-up assume-guarantee reasoning specifications pre post denote preand post-conditions procedure method pre post formulas first-order logic transitive closure vocabulary describes formal parameters visible fields procedure precondition user postcondition generated system running precondition append expressed pre append analysis procedure consists operations shown fig assume algorithm generate abstraction concrete stores satisfy pre procedure analyzed separately abstractions procedure canonical abstraction means sets relation symbols analysis procedure relations denote visible variables fields represent variables main analyzing append coarse representation data-structures change execution procedure operation record entry records information store entry auxiliary relation symbols information express post-condition refers values relations entry record information distinguishes nodes shape graph information expressed terms formal parameters prevents loss important information stores call analysis append introduce additional relation symbols denoted aentry bentry rentrya rentryb entry nentry note instrumentation relations operation analyze aentry performs abstract interpretation generates set shape graphs represent superset concrete stores arise exit operation project generates sub-structure taking restriction relations denote formal parameters entry information instrumentation relations applies canonical abstraction restriction result denoted finally generate formula concrete store satisfies represented satisfies integrity constraints post-condition change instrumentation abstraction significant loss precision binary information special instrumentation relations introduced recording values binary relation entry insufficient fig meaning locations represented fields point location represented operation record entry initializes nentry values abstraction correlation lost fact nentry means locations nentry fields necessarily locations fields address problem track locations n-field modified instrumentation relation change defined change nentry operation record entry initializes change nodes tvla system automatically updates change instrumentation relations analysis differencing note project operation remove change instrumentation relation expressed terms variables visible caller change part postcondition conceptually method handle number fields generating change instrumentation relation field practice affects ability theorem prover discharge queries posed analysis change nodes reachable implies n-fields list pointed modified call append shown section information crucial establishing result call append acyclic required precondition call append procedure call call procedure replaced operations shown fig replace formal parameters pre actual arguments passed operation called formals actuals note renaming variables renaming relation symbols check precondition holds concrete stores call assert subsequent operations create set shape graphs represents superset stores call append replace occurrence pre append formula pre defined set shape graphs represents concrete stores arise program location main shape graph shown fig represents disjoint acyclic unshared singly-linked lists pointed precondition append holds standard notion two-vocabulary store relates store call procedure two-vocabulary store versions binary relation symbol unprimed version describes store call primed version describes store call introduce primed versions unary relation symbols relation symbols denote program variables caller values changed procedure call invisible callee exception return procedure primed version relation symbol remark important distinguish two-vocabulary store primed unprimed versions relations entry relations entry relations record values formal parameters entry main calling procedure exit main generate post-condition introduce primed versions entry relations changed call append two-vocabulary stores locally modeling call 
primed relations involved standard fixpoint computation important analysis exponential number relations replace formal parameters post actual arguments passed formals actuals result formula denoted post note formula post entry relations constrain store call unprimed relations constrain store call operation rename rename unprimed nonentry alternatively define primed version relation denotes program variable precondition formal invisible program variables solution undesirable analysis exponential number variables relation symbol post primed version replace entry relations unprimed versions result formula post vocabularies suppose post formula call toappend rentryx rentryy post formula effect occurrences aentry bentry nentry post append replaced occurrences entry superscripts replaced evaluate two-vocabulary formula post extend primed version relations initialized unknown operation called primed unknown results set shape graphs apply symbolic operation assume generates set shape graphs assume operation refines primed relations precise values excluding values happen valid store note instrumentation relation primed version primed version defining formula instrumentation relation defined primed version defined primed version call assume operation theorem prover infer values definitions primed instrumentation relations values primed core relations includes reachability instrumentation change shown abstract fields so-called ghost-fields treated similar instrumentation relations omit paper reasons space neat solution problems updating reachability abstract fields breaking abstraction layers finally assume completed discard unprimed values return single-vocabulary structure operation called primed unprimed copies values primed relations unprimed relations evaluation method evaluate feasibility method implemented method tvla system simplify theorem prover established correctness running paper tvla enhanced symbolic engine compute assume assert simplify theorem prover discharge queries posed symbolic part modeled transitive closure binary relation set simple axioms developing java front end plan perform experiments apply approach java methods barnett deline leino fhndrich schulte verification object-oriented programs invariants journal object technology cousot cousot systematic design program analysis frameworks popl pages acm detlefs nelson saxe simplify theorem prover program checking technical report hpl- labs http research compaq src esc simplify html jeannet loginov reps sagiv relational approach interprocedural shape analysis sas lecture notes computer science springer rustan leino poetzsch-heffter zhou data groups check side effects pldi pages lev-ami sagiv tvla framework kleene based static analysis sas static analysis symposium springer http tau tvla reps sagiv loginov finite differencing logical formulas static analysis esop pages rinetzky sagiv interprocedural shape analysis recursive programs lecture notes computer science sagiv reps wilhelm parametric shape analysis -valued logic acm transactions programming languages systems yorsh logical characterizations heap abstractions master thesis tel-aviv tel-aviv israel http tau gretay yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tacas pages 
analyzing memory accesses executables gogul balakrishnan thomas reps wisconsin motivation goal create intermediate representation similar compiler cfgs call graph killed may-killed variables cfg nodes points-to sets tool security analyst general infrastructure binary analysis goal codesurfer architecture codesurfer architecture outline challenges value-set analysis performance future work running int arrval parray int main int initialize pointers parray initialize array challenges debugging symbol-table information explicit memory addresses similar variables a-locs initial estimate code data procedures call sites malloc sites extend on-the-fly disassemble data add cfg similar elaboration cfg call-graph compiler calls function pointers challenges multiple source languages optimizations make task easier optimizers registers memory deciphering memory operations hard part memory-regions abstraction address space idea group similar runtime addresses collapse runtime ars procedure memory-regions value-set analysis resembles pointer-analysis algorithm interprets pointer-manipulation operations pointer arithmetic resembles numeric-analysis algorithm over-approximate set values addresses held a-loc range information stride information interprets arithmetic operations sets values addresses value-set value-set affine-relation analysis affine-relation analysis affine-relation analysis performance future work aggregate structure identification ramalingam popl ignore declarative information identify fields access patterns improving a-loc abstraction discovering type information future work future work main insights codesurfer architecture analyzing memory accesses executables mmm click edit master title style click edit master text styles level level fourth level level cfgs call graph killed may-killed variables cfg nodes points-to sets initial estimate code data procedures call sites malloc sites whole-program analysis stubs global mmm global mainv mainv extended weighted pushdown systems akash lal thomas reps gogul balakrishnan wisconsin madison wisconsin akash reps bgogul wisc abstract recent work weighted-pushdown systems shows generalize interprocedural-dataflow analysis answer stack-qualified queries answer question dataflow values hold program node set calling contexts generalization account precise handling local variables systems address issue provide answers stack-qualified queries presence local variables introduction important static-analysis technique dataflow analysis concerns calculating program point information set states occur point abstract domain ideal compute meet-over-allpaths mop kam ullman gave coincidence theorem sufficient condition calculated single-procedure programs sharir pnueli generalized theorem multiple-procedure programs local variables knoop steffen extended theorem include local variables modeling run-time stack program alternative techniques handling local variables proposed lose relationships local global variables mop over-approximates set states occur program point calling contexts recent work weighted-pushdown systems wpdss shows generalize interprocedural-dataflow analysis answer stack-qualified queries calculate over-approximation states occur program point regular set calling contexts sharir pnueli coincidence theorem clear wpdss handle local variables accurately paper extend wpds model extendedwpds ewpds model accurately encode interprocedural-dataflow analysis programs local variables answer stack-qualified queries ewpds model generalizing wpdss knoop steffen generalized sharir pnueli coincidence theorem contributions paper summarized give handling local variables extension wpds model advantage wpdss give calculating dataflow values hold program node calling context set calling contexts provide set witness program execution paths justify reported dataflow show ewpds model powerful capture knoop steffen coincidence theorem means calculate recently schwoon shown computational power wpdss ewpdss present result paper due space constraints involves simulating program run-time stack dataflow mop referred imovp multiple-procedure programs local variables distributive dataflow-analysis problem domain transfer functions infinite descending chains monotonic problems distributive safely approximate imovp addition ewpdss support stack-qualified imovp queries extended wpds library support ewpdss calculate affine relationships hold registers code result lengthy included paper illustrates approach shown imovp result single-level pointer analysis instance framework immediately answering stack-qualified aliasing problems rest paper organized background wpdss explains ewpds model presents algorithms solve reachability queries ewpdss show compute imovp ewpds presents experimental results describes related work extended-wpds model pushdown systems definition pushdown system triple set states control locations set stack symbols set pushdown rules configuration pair rule written rules define transition relation configurations subscript transition relation omitted clear context reflexive transitive closure denoted set configurations define pre post backward forward reachability transition relation restrict pushdown rules stack symbols right-hand side means rule form restriction decrease power pushdown systems increasing number stack symbols constant factor arbitrary pushdown system converted satisfies restriction pushdown systems stack symbols right-hand side rule sufficient modeling control flow programs denote set rules stack symbols right-hand side instructive program control flow modeled ewpds model work pushdown system geared performing dataflow analysis programs construction present interprocedural control flow graph call node split nodes source interprocedural edge callee multi-level pointer analysis problems kind occur java programs safely approximated single-level pointer-analysis problems entry node target edge callee exit node set nodes graph set control-flow edges fig shows interprocedural control-flow graph fig shows pushdown system models pds single state stack symbol node rule edge rules model intraprocedural edges rules called push rules call edges rules called pop rules return edges easy valid path program corresponds path pushdown system transition system vice versa emain call ret exitmain exitp emain exitmain exitmain exitp exitp exitp fig interprocedural control flow graph exit nodes represent entry exit points procedures local variable main global variable dashed edges represent interprocedural control flow edge labels correspond dataflow facts explained pushdown system models control flow graph shown number configurations pushdown system unbounded finite automaton describe set configurations definition pushdown system p-automaton finite automaton finite set states transition relation set initial states set final states automaton configuration accepted p-automaton automaton accept started state written set configurations called regular p-automaton accepts important result regular set configurations post pre regular sets configurations weighted pushdown systems weighted pushdown system obtained supplementing pushdown system weight domain bounded idempotent semiring definition bounded idempotent semiring quintuple set elements called weights elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule sequence rules associate define configurations path denote set rule sequences transform weighted pushdown systems geared solving reachability problems definition letw weighted pushdown system wherep regular set configurations generalized pushdown predecessor gpp problem find circleplustext path generalized pushdown successor gps problem find circleplustext path extended weighted pushdown systems reachability problems defined previous section compute rule sequence taking extend weights rules sequence weighted pushdown systems dataflow analysis programs rule sequences general represent interprocedural paths program summarize weight paths maintain information local variables unfinished procedures path lift weighted pushdown systems handle local variables knoop steffen lifted conventional dataflow analysis handle local variables local variables stored call sites special merging functions appropriately combine returned procedure semiring domain define merging function definition function merging function respect bounded idempotent semiring satisfies properties strictness distributivity function distributes path extension property restrictive cases app discusses property dispensed definition extended weighted pushdown system quadruple weighted pushdown system assigns merging function rule set merging functions semiring write shorthand note push rule weight merging function merging functions combine effects called procedure made calling procedure call figure shows interprocedural control flow graph pushdown system represent perform constant propagation uninterpreted expressions graph assigning weight pushdown rule set variables program standard constant-propagation semilattice greatest-lower-bound operation partial order stands not-a-constant weight semiring env env set environment transformers environment mapping variables env denote infeasible environment restrict set -strict transformers extend meet operation environments taking meet componentwise env env env env env env env env semiring operations constants defined weights pds models program fig shown edge labels weight form main main mainv mainv mem ecx mainv edi mainv mainv mainv mainv mainv mainv mapsto returns environment agrees argument bound stack-smashing environment attack updated mapsto merging function call site receive environment transformers summarizes effect caller entry point call site emain summarizes effect called procedure exitp produce transformer summarizes effect caller entry point return site emain define mapsto mapsto copies local variable call site called procedure merging function access environment transformer call pass local variable procedure call stops 
tracking weight mapsto formalize redefine generalized pushdown predecessor successor problem changing definition rule sequence denote sequence denote empty sequence context-free grammar shown fig simply represents balanced sequence rules matched calls returns number rules inbetween regular-language terminology represents sequences increase fig grammar parsing rule sequences start symbol grammar stack height represents sequences decrease stack height derive rule sequence grammar define rule sequence definition ewpds define sequence rules parsing sequence grammar giving meaning production rule shorthand terminal derived main thing note definition application merging functions balanced sequences grammar presented fig ambiguous parsings rule sequence produce extend operation associative unique balance generalized pushdown problems gpp gps ewpds wpds changed definition rule sequence merging function ewpds reduces wpds justifies calling model extended weighted pushdown system solving mainv reachability problems ewpdss section present algorithms solve mainv generalized reachability problems ewpdss section ewpds pushdown system weight domain fixed regular set configurations recognized p-automaton transition leading initial state note automaton converted equivalent transition initial state duplicating initial states assume -transitions case weighted pushdown systems construct annotated automaton read efficiently automaton automaton constructed simple pushdown reachability annotations show calculation witness annotations obtained weighted pushdown systems witnesses record paths justify weight stack-smashing values attack paths calculated solving gpp solve gpp input p-automaton describes set configurations query ewpds output create automatonapre weights annotations transitions read reported values automaton algorithm based saturation rule shown starting automaton applying rule longer applied termination guaranteed finite number transitions height weight domain bounded transition automaton created store weight function saturation rule predecessor reachability ordinary pushdown systems weights weighted pushdown systems case merging function applied update annotation assume transition exist transition update annotation transitions update annotation braceleftbiggf awk negationslash convenience write transition apre define path theorem shows calculated theorem configuration combine values accepting paths apre calculate efficiently algorithm similar simulation algorithm nfas algorithm solving gps section assume rule form combination involves loss generality replace rule rules weight merging function weight state replacement change reachability problem answers lookup function returns unique push rule triple presenting algorithm operational definition rule sequence importance alternative definition shows correspondence call semantics program interprocedural path program define stack weights weight unfinished call path elements stack set recall defined set push rules signifies call made rule weight time call iii weight call rule stack set nonempty stacks topmost element rest write element rule form associate function stack stack symbol right-hand tar side accumulate weight top stack symbols right-hand side save weight push rule push rule stack start fresh entry top stack symbols right-hand side apply merging function pushed stack represents unbalanced pop rule simply accumulate weight stack note drop weight push rule apply merging function accordance case defn sequence rules define flatten stack operation computes weight stack flatten flatten flatten flatten flatten rule sequence takes program fig emain exitp node apply stack stack height mapsto mapsto mapsto mapsto push rule calls procedure rule fig flex top stack weight computed inside rules bottom stack pair weights component weight computed main call rules component weight call rule apply flatten operation stack weight mapsto mapsto apply pop rule rule stack mapsto mapsto mapsto mapsto mapsto applying flatten stack lemma formalizes equivalence lemma valid sequence rules path configurations flatten corollary configuration stack defined paths set configurations p-automaton flatten corollary shows information compute directly solve pushdown successor problem inputp-automatona describes set configurations create annotated p-automaton apost weights annotations transitions read configuration algorithm based saturation rule transition automaton created function stores weight transition based operational definition path create apost pairs weights semiring defined component wise introduce state push rule states apost set states added saturation rule shown fig saturation rule path apost invariant algorithm fact create transitions state state state state state state define transition label lookup path describes stack vpath component projected weightpair means path apost represents stack saturation algorithm make automaton rich encode stacks configurations cases saturation rule applying rules stack symbols right-hand side applying fourth case immediately case applying pop rules transition annotation update annotation transition assume transition exist transition annotation update annotation transition transition annotation update annotations transitions annotations update annotation transition defined lookup fig saturation rule constructing apost theorem configuration flatten vpath paths paths denotes set paths transitions apost input easy computing combine theorem replace annotation transition extend weight components standard nfa simulation algorithms algorithm apre interprocedural meet paths section show extended weighted pushdown systems compute imovp solution dataflow analysis problem define imovp strategy show solve ewpds meet semilattice describing dataflow facts graph program call return nodes semantic transformer node program represents over-approximates effect executing statement program stk set nonempty stacks elements stk abstract representation run-time stack program define operations stacks newstack stk creates stack single element push stk stk pushes element top stack pop stk stk removes top element stack top stk returns top element stack describe interprocedural semantic transformer program node stk stk stk stk stk push pop stk top stk push stk top stk push pop pop stk top pop stk top stk merging function ewpdss applied dataflow computed called procedure top stk computed caller time call top pop stk definition assumes dataflow fact information required procedure transformer top stack passed return nodes top elements stack define path transformer cat valid interprocedural path program leads definition definition starting node program defined imovpc newstack represents set valid interprocedural paths meet stacks meet topmost values stk stk top stk top stk construct ewpds compute infinite descending chains semantic transformers distributive merging relations distributive arguments define semiring consists set distributive functions special function braceleftbigg pushdown system constructed including rule edge eintra intraprocedural edges einter interprocedural call return edges include rules eintra include rule einter return site call include rule exit node procedure include rule small technical detail merging functions defined satisfy path-extension property defn app give cut alternative definition assign weight rule sequence path-extension property longer limitation leads theorem theorem p-automaton accepts configuration starting point program apost automaton obtained saturation rule shown fig read apost accordance thm imovpc regular language stack configurations imovpc imovp restricted paths end configurations calculated imovpc case semantic transformers distributive monotonic combines thm safely approximate imovpc imovpc present proof paper essential idea carries solving monotonic dataflow problems wpdss experimental results 
balakrishnan reps present algorithm analyze memory accesses code goal determine over-approximation set values memoryaddresses register memory location holds program point core dataflow-analysis algorithm called value-set analysis vsa relational track relationships hold registers memory locations interpreting conditional branches specifically implement loops important relationships separate affine-relation analysis ara performed recover affine relations hold registers conditional branch points affine relations interpret conditional branches vsa ara recovers affine relations involving registers recovering affine relations involving memory locations require points-to information end vsa ara implemented affine-relation domain weight domain based machine arithmetic arithmetic module care overflow call instruction subset registers saved stack caller callee restored return registers called callersave callee-save registers ara track information involving registers ara implemented wpds affine relations involving caller-save callee-save registers lost call ewpds preserve calls treating caller-save callee-save registers local variables call values caller-save callee-save registers call set values call values registers set values exit node callee results shown tab column labeled branches information refers number branch points ara recovered affine relation column shows number branch points ara implemented ewpds recovered affine relations compared ara implemented wpds tab shows information recovered ewpds branch points information ewpds version slower space due fact dataflow transformer spoiling affine relations involve register space transformer preserves relations branches memory time information prog insts procs branches calls wpds ewpds wpds ewpds wpds ewpds improvement mplayer print attrib tracert finger lpr rsh javac ftp winhlp grep winhlp javac affine-relations seconds value-set analysis seconds ninsts nproc program bcomic sans analyzing memory accesses system bcomic sans executables bcomic sans gogul balakrishnan bcomic sans thomas reps bcomic sans wisconsin on-screen show wisconsin arial comic sans times roman itc avant garde gothic demi symbol wingdings courier microsoft sans serif simsun default design microsoft equation analyzing memory accesses executables motivation goal goal codesurfer architecture codesurfer architecture outline running tutorial instructions running running running address space running address space challenges challenges slide memory-regions memory-regions memory-regions similar variables a-locs a-locs a-locs a-locs a-locs value-set analysis value-set value-set value-set analysis value-set analysis value-set analysis affine-relation regsvr analysis affine-relation analysis value-set analysis notepad affine-relation analysis performance future work future cmd work table future comparison work ara main results insights implemented codesurfer ewpds versus architecture wpds analyzing related memory work accesses libraries tools based executables model-checking fonts pushdown systems dataflow design analysis template embedded moped ole wpds servers wpds slide weighted pushdown systems finding titles uninitialized pid variables hlinks live variables linear constant propagation detection affine relationships cases local variables handled introducing special paths transition system pds models program paths skip call sites avoid passing local variables callee leads imprecision breaking existing relationships local global variables dataflow analysis wpdss generalized authorization problems moped performing relational dataflow analysis finite abstract domains basic approach embed abstract transformer program statement rules pushdown system models program contrasts wpdss abstract transformer separate weight pushdown rule moped associates global variables states pds local variables stack symbols stack pds simulates runtime stack program maintains copy local variables procedure invocation simple pushdown reachability query compute required dataflow facts disadvantage approach handle infinite-size abstract domains associating abstract transformer pushdown rule create infinite number pushdown rules ewpds capable performing analysis infinite-size abstract domains domain copy-constant propagation dataflow analysis model-checking pushdown systems verifying security properties programs wpdss ewpds purpose added precision due presence merging functions thomas reps result presented paper ewpdss singlelevel pointer analysis enables answer stack-qualified aliasing queries stackqualified aliasing studied whaley lam recursive programs collapse strongly connected components call graph make approximation answer aliasing queries respect language stack configurations single stack configuration idea transition wpds ewpds attach extra meaning run pushdown system run tree matching calls returns push pop values run-time stack program treatment program run explored uller-olm seidl interprocedural dataflow-analysis algorithm identify set affine relationships explicitly match calls returns avoid passing relations involving local variables procedures allowed directly translate work ewpds experiments aho sethi ullman compilers principles techniques tools addisonwesley balakrishnan reps analyzing memory accesses executables int conf comp construct bouajjani esparza maler reachability analysis pushdown automata application model checking concur pages springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures symp princ prog lang pages chen wagner mops infrastructure examining security properties software conf comp commun sec november esparza cera schwoon model-checking ltl regular valuations pushdown systems tacas pages esparza schwoon bdd-based model checker recursive programs proc cav lncs pages springer-verlag finkel willems wolper direct symbolic approach model checking pushdown systems electronic notes theoretical computer science jensen etayer thorn verification control flow based security properties ieee symposium security privacy pages kam ullman monotone data flow analysis frameworks acta inf kidd reps melski lal wpds library weighted pushdown systems knoop steffen interprocedural coincidence theorem int conf comp construct pages landi ryder pointer-induced aliasing problem classification symp princ prog lang pages landi ryder safe approximate algorithm interprocedural pointer aliasing conf prog lang design impl pages uller-olm seidl precise interprocedural analysis linear algebra symp princ prog lang uller-olm seidl analysis modular arithmetic european symp programming reps horwitz sagiv precise interprocedural dataflow analysis graph reachability symp princ prog lang pages reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis static analysis symp pages sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci schwoon model-checking pushdown systems phd thesis technical univ munich munich germany july schwoon moped http fmi uni-stuttgart szs tools moped schwoon jha reps stubblebine generalized authorization problems comp sec found workshop wash ieee comp soc sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications prentice-hall englewood cliffs whaley lam cloning-based context-sensitive pointer alias analysis binary decision diagrams conf prog lang design impl pages relaxing merging function requirements appendix discusses merging functions satisfy property defn pre algorithm creating apre compute correct values parses rule sequences grammar defn post algorithm creating apost work utilizes grammar relies path-extension property compute correct modify post algorithm introduce alternative definition rule sequence suited cases merging functions satisfy path-extension property definition involves changing productions valuations balanced sequences rule sequence defined defined defn merging functions satisfy path-extension property absence property make merging functions applied weight computed caller call weight computed callee enforce eqn stack values calculated rule sequences eqn means lem holds post algorithm correctly solves general version gps pre algorithm closely based defn solve generalized version gpp based alternative definition 

abstraction refinement inductive learning alexey loginov thomas reps mooly sagiv comp sci dept wisconsin alexey reps wisc school comp sci tel-aviv msagiv post tau abstract paper concerns automatically create abstractions program analysis show inductive learning goal identify general rules set observed instances leverage problem advantage approach based inductive learning require theorem prover introduction present approach automatically creating abstractions program analysis previous work approach involves successive refinement abstraction unlike previous work work presented paper aimed programs manipulate pointers heap-allocated data structures demonstrate approach shape-analysis problems approach applicable program-analysis setting first-order logic paper presents abstraction-refinement method static analyses based -valued logic semantics statements query interest expressed logical formulas setting memory configuration modeled logical structure individual structure universe models single memory element case summary individual models collection memory elements summary individuals ensure abstract descriptors priori bounded size guarantees fixed-point reached constraint working limited-size descriptors implies loss information store intuitively properties concrete individuals lost due abstraction groups multiple individuals summary individuals property true concrete individuals group false individuals tvla system tool creating analyses method proposed paper refinement performed introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations instrumentation relations record auxiliary information logical structure providing mechanism fine-tune abstraction instrumentation relation captures property individual memory cell possess general introduction additional instrumentation relations refines abstraction prepared track finer distinctions stores choice instrumentation relations crucial precision cost analysis tvla users faced task identifying instrumentation-relation set definite answer query make cost prohibitive arguably key remaining challenge tvla user-model contributions work summarized establishes connection program analysis machine learning showing inductive logic programming ilp relevant problem creating abstractions ilp learning instrumentation relations preserve information lost due abstraction method implemented extension tvla system user-level obligations tvla criticized past addressed input required program analysis consists transition system query formula identifies acceptable outputs iii characterization program valid inputs present experimental evidence approach tested method sortedness stability antistability queries set programs perform destructive list manipulation partial-correctness queries binary-search-tree programs method succeeds cases tested inductive learning concerns identifying general rules set observed instances case relationships observed logical structure advantage approach based inductive learning require theorem prover beneficial setting logic undecidable fig store linked list paper organized introduces terminology notation readers familiar tvla skip briefly summarizes ilp illustrates goals problem verifying partial correctness sorting routine describes techniques learning abstractions details found presents experimental results discusses related work background stores logical structures abstractions typedef struct node struct node int data list relation intended meaning denote memory cell pointer variable point memory cell field point dle data field equal table declaration linked-list datatype core relations representing stores manipulated programs type list dle dle dle dle dle dle dle fig logical structures represents store shown fig graphical tabular forms work extends program-analysis framework approach concrete memory configurations stores encoded logical structures terms fixed collection core relations core relations part underlying semantics language analyzed instance tab definition linked-list datatype lists relations represent stores manipulated programs type list store fig -valued logical structures represent memory configurations individuals set memory cells unary relations represent pointer variables binary relation represents n-field list cell data field modeled indirectly binary relation dle stands data less-than-or-equal-to listed tab fig shows -valued structure represents store fig relations explained finite vocabulary relation symbols denotes set relation symbols arity -valued logical structure overr set individualsus interpretation maps relation symbol arity truth-valued function eqs equality relation individuals set -valued structures denoted -valued logic truth introduced denote uncertainty information order defined iff -valued logical structure defined -valued logical structure values relations individual eqs called summary individual summary individual abstracts fragments data structure represent concrete memory cell set -valued structures denoted concrete abstract semantics concrete operational semantics defined structure transformer kind edgee transition system structure transformer providing relation-update formulas core relations formulas define core relations -valued logical structures arises source ofeare transformed byeto create -valued logical structures target ofe edgeemay optionally precondition formula filters structures follow transition sets -valued structures yield suitable abstract domain instance language modeled supports allocation heap set individuals structure unbounded priori upper bound number -valued structures arise analysis ensure termination abstract sets -valued structures -valued structures set stores represented finite set -valued logical structures abstraction defined equivalence relation individuals individual -valued logical structure representing concrete memory cell mapped individual -valued logical structure vector values concrete individual user-chosen collection unary abstraction relations definition canonical abstraction chosen subset unary relation symbols relations aare called abstraction relations define equivalence relation surjective function maps individual equivalence class canonical abstraction respect denoted performs join information order predicate values introducing unary relations abstraction relations canonical abstraction -valued logical structure shown fig formulas first-order formulas transitive closure formula vocabulary defined stands reflexive transitive closure formulas variables represents lists elements element sdatavalue lower thedatavalues rest list graphical notation depicting -valued logical structures individuals represented circles names nonvalues unary relations summary individuals represented double circles unary relation pointer-valued program variable represented solid arrow individual absence p-arrow node individuals relation shown binary relation represented solid arrow labeled pair individuals absence q-arrow pairs relations represented dotted arrows dlex dle dle dle fig -valued structure canonical abstraction structure canonical abstraction ensures -valued structure larger fixed size priori meaning formula concrete domain consistent meaning abstract domain formula abstract structure precise concrete structure abstract interpretation collects set -valued structures program point implemented iterative procedure finds fixed point collection equations variables values intendedmeaning reachable fields reachable pointer variable fields directed cycle fields table defining formulas commonly instrumentation relations separate reachability relation program variable instrumentation relations abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation relations record derived properties varying unary core unary instrumentation relations set abstraction relations set instrumentation relations denoted relation symbol defined instrumentation-relation definition formula instrumentation relation symbols defining formulas instrumentation relations long circular dependences introduction unary instrumentation relations abstraction relations control concrete individuals merged control amount information lost abstraction tab lists instrumentation relations important analysis programs type list inductive logic programming ilp logical structure goal ilp algorithm learn logical relation defined terms logical structure relations agrees classification input examples ilp algorithms produce answer form logic program non-recursive logic programs correspond subset first-order 
logic logic program thought disjunction program rules rule conjunction literals variables appearing head rule implicitly existentially quantified definition ilp set positive tuples set negative tuples logical structure goal ilp find formula satisfied covered satisfied fig linked list shared elements learning unary formula holds linked-list elements pointed fields element -valued structure fig formula isshared meets objective covers positive negative tuples input target relation structure set tuples pos set tuples neg posnegationslash newdisjunct newneg neg newneg negationslash cand candidate literals cand max gain newdisjunct newdisjunct newdisjunct newneg subset newneg satisfying -quantify newdisjunct variables newdisjunct pos subset pos satisfying newdisjunct fig pseudo-code foil fig presents ilp algorithm systems foil modified construct answer first-order logic formula disjunctive normal form algorithm capable learning formula isshared performing iteration outer loop iterations loop successively choose literals sequential covering algorithm parameterized functiongain characterizes usefulness adding literal generally heuristic fashion algorithm creates disjunct long positive examples covered existing disjuncts disjunct extended conjoining literal covers negative examples literal relation symbol vocabulary structure valid arguments literal variables target relation variables long arguments variable current disjunct foil literal chosen heuristic based information gain line foil information gain find literal differentiates positive negative examples verifying sortedness ilp algorithms capable producing recursive programs correspond first-order logic least-fixpoint operator general transitive closure void insertsort list list null null null data data prn null pln break fig stable version insertion sort static-analysis algorithm defined demonstrate partial correctness procedure user automatic discovery api-level exploits vinod ganapathy sanjit seshia somesh jha thomas reps randal bryant computer sciences department school computer science wisconsin-madison carnegie mellon madison wipittsburgh pavg jha reps wisc sanjit bryant cmu abstract argue finding vulnerabilities software components finding exploits exploits compromise security low-level details component layouts stack frames existing software analysis tools effective identifying vulnerabilities fail model low-level details unsuitable exploit-finding study issues involved exploit-finding application programming interface api level exploits software component vulnerable api-level exploit security compromised invoking sequence api operations allowed component present framework model low-level details apis develop automatic technique based bounded infinite-state model checking discover api-level exploits present instantiations framework show format-string exploits modeled api-level exploits demonstrate technique finding exploits vulnerabilities widely-used software framework model cryptographic-key management api ibm cca demonstrate tool identifies previously exploit categories subject descriptors software engineering software program verification general terms algorithms security verification keywords api-level exploit bounded model checking introduction vulnerability software component error implementation possibly alter intended behavior component exploit sequence operations attacks vulnerability typically malicious intent devastating supply programspecific information procedure control-flow graph data-structure constructor dsc code fragment non-deterministically constructs valid inputs query formula identifies intended outputs analysis algorithm run dsc concatenated procedure control-flow graph query evaluated structures generated exit problem establishing insertsort shown fig partially correct assertion compares state store end procedure state start correct sorting routine perform permutation input list list elements reachable variable start routine reachable xat end express permutation property denotes reachability relation beginning insertsort formula holds elements reachable reachable beginning procedure performs permutation list general relation history relation fig shows structures characterize valid inputs insertsort represent set stores program variable points acyclic linked list verify insertsort produces sorted permutation input list check structures arise procedure exit node formula evaluates dle nodes reachable non-decreasing order abstract interpretation collects -valued structure shown fig line note formula evaluates list element guaranteed correct order respect remaining elements guarantee list nodes represented summary node correct order represents shown fig analysis admits possibility correct implementation insertion sort fig produce store shown fig abstraction fine-grained establish partial correctness insertsort fact abstraction fine-grained separate set sorted lists lists sorted order lev-ami tvla establish partial correctness insertsort key step introduction instrumentation relation inorderdle holds nodes data-components equal n-successors inorderdle defined inorderdle dle sortedness property stated formula inorderdle empty list -element list lists elements dle dle dle dle fig structures describe inputs insertsort introduction relation inorderdle -valued structures collected abstract interpretation end insertsort describe stores variable points acyclic sorted linked list structures formulas evaluate insertsort guaranteed work correctly valid inputs learning abstraction instrumentation relation inorderdle defined explicitly tvla user heretofore burdens tvla user insight behavior program translate insight instrumentation relations input transition system data-structure constructor query closed formula construct abstract input perform abstract interpretation set -valued structures exit negationslash break find formulas instrumentation rels refine actions define transition system refine abstract input true fig pseudo-code iterative abstraction refinement goal paper automate identification instrumentation relations inorderdle forinsertsort goal obtain definite answers evaluating formula structures collected abstract interpretation line fig fig pseudo-code method steps explained line data-structure constructor compute abstract input structures represent valid inputs program perform abstract interpretation collect set structures program point evaluate query structures exit definite answer obtained structures terminate perform abstraction refinement line find defining formulas instrumentation relations line replace occurrences formulas query definitions instrumentation relations instrumentation relation symbols apply finite differencing generate refined relation-update formulas transition system line obtain precise values newly introduced instrumentation relations abstract structures define valid inputs program achieved reconstructing valid inputs performing abstract interpretation data-structure constructor attempt abstraction refinement introduction query instrumentation relation lead definite answer instance insertsort introducing query instrumentation relation ineffective statement program effect changing instrumentation relation contrast unary instrumentation relation inorderdle present statements program abstract interpretation results definite entries inorderdle instance comparison line fig insertion lines node pointed node pointed results definite entry inorderdle algorithm generate instrumentation relations account sources imprecision describes subformula-based refinement describes ilp-based refinement present employ subformula-based refinement cost strategy reasonable strategy successful subformula-based refinement longer refine abstraction turn ilp query finitely subformulas limit round ilp-based refinement number abstraction-refinement steps finite additionally run analysis explores bounded number -valued structures algorithm guaranteed terminate subformula-based refinement query evaluates structures collected exit node invoke function instrum recursive-descent procedure generate defining formulas instrumentation relations based subformulas responsible imprecision details function instrum abstract interpretation collects -valued structure fig exit node insertsort sortedness query formula evaluates triggering call instrum formula structure arguments column tab shows instrumentation relations created result call note sorted defined inorderdle key insight results call instrum final version sorted dle sorted sorted dle sorted sorted dle sorted sorted dle dle table instrumentation relations created subformula-based refinement actions define program transition relation modified gain precision improvements storing maintaining instrumentation relations accomplish refinement program actions line fig replaces occurrences defining formulas instrumentation relations query definitions instrumentation relations instrumentation-relation symbols insertsort formula query replaced stored sorted definitions instrumentation relations scanned occurrences sorted sorted occurrences replaced names relations case relations definitions changed yielding consequences recent years definitions witnessed sharp column increase tab number security exploits tricky structures collected craft exit node insertsortby run low-level details abstract interpretation program sorted execution permutation instance property typical holds exploit buffer-overrun structures vulnerability facts establish details partial layout correctness insertsort stack constraints process buffer required sizes iteration abstraction architecture refinement machine basic supported version onr contracts specification vocabulary consisted relations tabs aro grant daad permission history make relations digital needed hard user copies intervention part ilp-based work refinement shortcomings personal classroom subformula-based refinement granted illustrate fee weakness provided copies subformula-based refinement made introduce distributed stability profit property commercial stability advantage property copies arises bear context notice full citation sorting procedures page copy applies republish listmanipulating programs post servers general stability redistribute query lists formula requires asserts prior specific permission relative order fee elements icse equal data-components remains louis missouri usa dle copyright acm dle growing procedure concern insertsort consists security nested important loops find exploits fig controlled outer loop environment traverses list found setting pointer variable attackers point analysis tool list nodes finds security iteration exploit outer potential loop vulnerability loop component finds correct place concrete evidence insert target vulnerability traversing exists list analyst start pointer insight variable consequences target inserted instance static analyzers target data data boon insertsort satisfies percent-s invariant benefit list analysis nodes finds exploits list vulnerabilities identify target tools produce correct false order positives data-component imprecision target analysis process data-component classifying nodes 
warnings ahead whichr target moved insertsortpreserves original order elements equal data-components insertsort stable routine subformula-based refinement capable establishing stability insertsort subformulas query case formula candidate instrumentation relations strategy unable introduce instrumentation relations maintain information transitive successors list node correct relative order learning instrumentation relations fig shows structure arises abstract interpretation line fig tabular version relations dle omit reachability relations figure clarity assignment nodes identical vectors values unary abstraction relations subsequent application canonical abstraction produces structure shown fig bold entries tables fig definite related property antistability asserts order elements equal datacomponents reversed dle dle test suite includes program insertsort identical insertsort line fig correct place insert current node implementation insertion sort antistable values transformed structure satisfies sortedness invariant discussed node amongu dle relationship nodes appearing list target piece information lost structure dle indicating nodes represented summary node sorted order respect successors refer abstraction steps information-loss points dle dle dle rnl dle fig structure arises line fig unlabeled edges nodes represent dle relation abstract structure transformer temporarily create structure image canonical abstraction subsequent application canonical abstraction transforms structure grouping set individuals single summary individual loss precision due circumstances individuals possesses property individual possess property summary individual individuals property common recomputed precisely rnpr dle dle fig structure transformation ofs statement line fig unlabeled edges nodes represent dle relation cases solution lies introduction instrumentation relations case introduce unary abstraction relation individuals possess property grouped case sufficient introduce non-abstraction relation arity captures common property individuals inu algorithm learn formulas kinds relations type unary relation type unary relation type iii binary relation type relations intended prevent grouping individuals properties types iii intended capture common properties individuals type iii relations generalized higher-arity relations logical structure serves input ilp pass structure identified information-loss point restrict algorithm non-history needed analysis framework abstractions generalize predicate-abstraction domains fourth ilp technique predicate abstraction ilp identify nullary relations differentiate positiveexample structure structures arising program point steps ilp forming boolean combinations existing relations involve creation relations introducing quantifiers learning process relations structure lose definite entries result abstraction dle definite entries relations learn formulas evaluate positive negative modified algorithm learn multiple formulas invocation algorithm motivation find single instrumentation relation explains structure find instrumentation relations analysis establish property interest find multiple literals quality line fig extend distinct copies current disjunct literals extend distinct copies current formula resulting disjuncts variant ilp learn binary formula structure fig set individuals grouped abstraction input set positive examples set relations lose definite values due abstraction includes dle literal dle covers examples holds bindings mapsto mapsto mapsto algorithm picks literal negative examples dle disjunct literal covers remaining positive algorithm returns formula dle re-written dle relation abstraction maintain information transitive successors list node correct relative order dle establishing fact list nodes real vulnerabilities false appearing prior target sorted order formulas dle learned ilp fig verification process introducing extra instrumentation relations harm analysis increasing cost experimental evaluation extended tvla perform iterative abstraction refinement applied queries programs fig insertsort test programs included sorting procedures bubblesort insertsort list-merging procedure merge in-situ list-reversal procedure reverse present employ subformula-based refinement iteration subformula-based refinement save logical structures information-loss points failure subformula-based refinement invoke ilp algorithm lower cost analysis prune returned set formulas remove formulas defined terms single relation symbol formulas tautologies dle dle define instrumentation relations relations refine abstraction performing steps lines fig implementation learn relations types unary binary nullary due present cost maintaining unary instrumentation relations tvla experiments reported learn binary formulas type iii define instrumentation relations learned formulas simple form atomic subformulas process extending techniques pruning useless instrumentation relations make practical types relations learned ilp refining abstraction attempting verify stability insertsort ilp creates formulas including formula subsequent run analysis successfully verifies stability insertsort test program sortedstableantistable bubblesort insertsort insertsort merge reverse fig results applying iterative abstraction refinement verification properties programs manipulate linked lists fig shows method generate instrumentation relations tvla establish properties expect hold tvla succeeds demonstrating sorting routines produce sorted lists bubblesort insertsort merge stable routines insertsort reverse antistable routines indefinite answers entries important understand occurrences fig precise correct answers instance result applying reverse unsorted list unsorted list case input list non-increasing order reverse produces sorted list precise answer query sorted stable antistable test program instrum rels instrum rels instrum rels total ilp total ilp total ilp bubblesort insertsort insertsort merge reverse fig numbers instrumentation relations total learned ilp iteration abstraction refinement fig shows numbers instrumentation relations iteration abstraction refinement number ilp-learned relations analysis small relative total number instrumentation relations fig execution times collected ghz linux longest-running analysis verifies insertsort stable takes minutes analyses minute rest seconds minutes total time tests minutes numbers close long takes verify sortedness queries user carefully chooses instrumentation relations maximum amount memory analyses varied cost invocations ilp algorithm attempting verify antistability bubblesort seconds total information-loss points benchmarks ilp cost ten seconds additional experiments tested applicability method queries data structures experiment subformula-based refinement successfully verified in-situ list-reversal procedure reverse produces list reversal input list query expresses property experiment seconds memory experiments involved programs manipusortedness query set tvla applied work tvla written java report maximum total memory minus free memory returned runtime late binary-search trees insertbst inserts node binary-search tree deletebstdeletes node binary-search tree programs subformulabased refinement successfully verified query nodes tree pointed variable remain sorted order end programs left dle dle initial specifications analyses included standard instrumentation relations similar listed tab relation formula distinguishes nodes tree pointed insertbst experiment seconds memory deletebst experiment approximately minutes memory related work bubble insert sort insert sort merge reverse post-ilp iteration pre-ilp iterations sorted stable antistable fig execution times program bars represent sorted stable antistable queries cases subformula-based refinement failed upper portion bars shows cost iteration analysis dsc program ilp cost work reported similar spirit counterexample-guided abstraction refinement key difference work prior work modelchecking community abstract domain prior work abstract domains fixed finite cartesian products boolean values predicate-abstraction domains relations introduced nullary relations work applies richer class abstractions -valued structures generalize predicate-abstraction domains abstraction-refinement algorithm paper introduce unary binary ternary relations addition nullary relations demonstrated approach shape-analysis queries approach applicable setting first-order logic describe program states distinguishing feature work method 
driven counterexample traces imprecise results evaluating query case subformula-based refinement loss information abstraction steps case ilp-based refinement exist theorem provers first-order logic extended transitive closure capable identifying infeasible error traces needed develop techniques slam blast slam identifies shortest prefix spurious counterexample trace extended feasible path general information-loss point occurs end prefix information-loss-guided refinement identify earliest points information lost due abstraction instrumentation relations added abstraction points potential advantage counterexample-guided refinement information-loss-guided refinement goal-driven information-loss-guided refinement discover relationships establishing query alleviate problem restricted ilp algorithm relations occur query abstraction-refinement techniques abstract-interpretation community capable refining domains based predicate abstraction polyhedra-based domain dynamically refined work based abstract domain led develop approaches abstraction refinement based machine learning abstract-interpretation community strong albeit unattainable form abstraction refinement identified goal make abstract interpretation complete optimal case goal extend abstraction answer query make abstraction optimal tvla system http tau tvla ball rajamani automatically validating temporal safety properties interfaces spin pages chase wegman zadeck analysis pointers structures pldi pages clarke grumberg jha veith counterexample-guided abstraction refinement cav pages das dill counter-example based predicate discovery predicate abstraction fmcad pages flanagan software model checking iterative abstraction refinement constraint logic queries giacobazzi ranzato scozzari making abstract interpretations complete acm henzinger jhala majumdar mcmillan abstractions proofs popl pages immerman rabinovich reps sagiv yorsh boundary decidability undecidability transitive closure logics csl pages jeannet halbwachs raymond dynamic partitioning analyses numerical properties sas pages jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications pages prentice-hall kurshan computer-aided verification coordinating processes princeton press lakhnech bensalem berezin owre incremental verification abstraction tacas pages lavra zeroski inductive logic programming techniques applications ellis horwood lev-ami reps sagiv wilhelm putting static analysis work verification case study issta pages loginov reps sagiv learning abstractions verifying data-structure properties report trcomp sci dept univ wisconsin january http wisc wpis papers muggleton inductive logic programming generation comp pasareanu dwyer visser finding feasible counter-examples model checking java programs tacas pages quinlan learning logical definitions relations mach learn reps sagiv loginov finite differencing logical formulas applications program analysis esop pages sagiv reps wilhelm parametric shape analysis -valued logic toplas 
positives typically manual security exploit generated vulnerability identified tools offers benefits evidence threat posed vulnerability real exploit test case stress resilience patched versions component finally cases analysis fails produce security exploit vulnerability automatically classified false positive reducing manual effort involved classifying warnings current tools adequately address problem finding security exploits software tools based model checking proved effective finding control-flow-intensive vulnerabilities tools finite-state abstractions abstract details layout program stack heap interest keeping analysis tractable details important produce security exploits result counter-examples produced tools lack detail generate security exploits similarly type-based analysis tools constraint-based analysis tools track actual values program variables result tools effective localizing vulnerabilities effective generating exploits paper study issues involved exploit-finding api-level security exploits component vulnerable api-level exploit security compromised invoking allowed sequence operations api instance sequence seteuid execl allowed unix obtain root privileges make contributions present formal framework capture low-level details api operations key idea abstract details produce model mimics concrete system closely resulting model typically infinitestate analyzed model checking determine state violates property reachable counterexample produced translated exploit instantiation framework real-world apis significant complexity present analyze printf-family format-string exploits apilevel exploits interpreting format-string sequence api operations reasoning api critically depends modeling runtime execution stack application precisely formal framework model api demonstrate tool discover format-string exploits tool generate exploits vulnerabilities real-world software packages technique analyze subset ibm common cryptographic architecture cca api cryptographic key management api case crucial model attacker enhance knowledge operations api tool based technique discovered previously exploit technique models data precisely existing tools demonstrate presence vulnerability producing security exploit lowlevel details system demonstrate showing technique find exploits vulnerabilities identified percent-s format-string vulnerabilityfinding tool discussed earlier demonstrate finding exploits benefit vulnerability-finding tools automatically classifying vulnerabilities real threats false positives rest paper organized present overview technique section present formal framework section apply analyze printf section ibm cca api section discuss related work section conclude section overview technique section describe toy protection system harrison framework apis technique check specification section printffamily format-string attacks shows framework checker generate security exploits low-level details organization program runtime stack protection system defined finite set rights commands state triple set subjects set objects access matrix row subject column object presented harrison subject object entry access matrix set rights subject object restrict rights read write natural meanings api step analysis involves api formal framework safety property checked framework ingredients set variables describe state component implements api initial state component set api operations semantics operations terms change state component representation set sequences api operations checked fourth component helps encode restrictions ordering api commands restrictions exclude sequences api commands inconsequential analyzing system arise execution system environment system operates generates sequence api calls set sequences forms regular language component expressed finite-state automaton discussed earlier state protection system triple initial state protection system initial values assume read write words rights rights commands presented protection system define api command state protection system restrict types commands shown semantics create adds creates column enters conferread enters read conferwrite analogous conferread assume protection system operations applied order assume check protection system obeys security policy subject read write object checking api explained earlier discover security exploits important work concrete system checking finite-state abstraction results loss low-level details required craft security exploit result finding securityexploit corresponds checking infinite-state system purpose bounded model checking overview technique shown figure safetycondition apispecificationinteger bound counter violation safety model checkerbounded increase bound iterateno violation figure schematic overview method model checker accepts description api framework safety property integer bound systematically explores allowed sequences api operations shorter length integer bound determines trace satisfies safety condition model checker finds violation safety policy terminates trace api operations demonstrates vulnerability instance bound discovers api-level vulnerability protection system create file conferread file conferwrite file sequence api operations adds file read file write add file violates safety condition file read write model checker terminates counter-example increase bound iterate section note undecidable check arbitrary system vulnerable apilevel exploits general iterative process forever procedure sound incomplete vulnerabilities found exploitable model discover vulnerabilities cases including study section derive values bound procedure complete formal framework present formal framework model analyze apis api interface component system analyzed presents client modules command api state component predefined state transformer sequence api operations defines state transformer obtained composing state transformers individual api operations focus sequences api operations affect security underlying component formally 
component defined init denotes finite set variables possibly infinite domain values vector vectorx state component note vectorx init bool predicate characterizes initial states component state vectorx init vectorx holds initial state component denotes finite set api operations opm operation opi input parameters denoted vector vectorai domain opi defines family relations opi vectorai semantics opi vectorai predicates define preand post-conditions prei vectorai bool posti vectorai bool opi vectorai vectorx vectory prei vectorai vectorx posti vectorai vectorx vectory vectorx vectory denote state application opi vectorai prei vectorai vectorx hold opi vectorai aborts language api operations plays roles encodes temporal restrictions api operations inherent implementation component monitor formalizes notion usage patterns api operation sequences invoked client instance suppose api question set system calls supported operating system verify application system calls conforms safety property launch api-level exploit operating system sequences system calls sufficient restrict attention call sequences generated application formally viewed intersection languages api operations plays role plays two-fold conceptually similar optimistic approach interface design language recognizer machine accepts string api operations determines member general recognizer exist restrict cases recognizer exists instance regular context-free case study section special case framework presented regular language recognizer finite-state machine called api-automaton addition predicate bad bool defines set error states state vectorx bad vectorx holds state component enter bad defined based security properties required verifying enters state satisfyingbad restrict attention sequences api operations avoids wasteful exploration state space verification reduces false alarms formally check notion api-safety definition api-safety predicate bad component safe respect vectorx satisfying assignment formula finite opi opi opik vectora vectora vectorak init vectorx opi opi opik opi vectora opi vectora opik vectorak vectorx vectory bad vectory denotes concatenation denotes relational composition vectorx vectorz vectory vectorx vectory vectory vectorz api-level exploit component defined sequence api operations opi opi opik opi opi opik violates api-safety ofs predicatebad surprisingly arbitrary component predicate bad checking safe respect state vectorx undecidable proof undecidability easily similar theorem protection systems approach api-safety problem based bounded infinite-state model checking restrict attention sequences api operations construct product language recognizer api-automaton infinitestate system defined init safety property bad checked resulting infinite-state system stot bounded model checking bounded model checker explores api operation sequences length integer bound stot checking state reached sequence bad satisfied generates concrete error trace sequence states leading error state variable domain exploit extracted concrete error trace recent advances sat solving made bounded model checking practical analyzing finite-state systems led development efficient sat-based decision procedures expressive decidable first-order logics turn fueled progress infinite-state bounded model checking key reason technique illustrative illustrate concepts developed protection system section recall initially subjects objects framework init note variables set-valued matrix viewed set triples denotes init read write create conferread conferwrite predicate pre create asserts entry exist post asserts entry created predicate pre conferread asserts post asserts read predicates conferwrite similar interleavings api operations permitted verify subject read write object predicate bad read write apiautomaton single-state finite-state machine transitions api operations bounded model checking case equivalent unrolling apiautomaton finite number times checking property holds presented bound bounded model checker discovers exploit create conferread conferwrite format-string vulnerabilities format-string vulnerabilities dangerous class bugs attacker execute arbitrary code victim machine printf variable-argument function treats argument format-string restrict discussion printf concepts discussed apply printf-family functions syslog sprintf format-string conversion specifications instructions types call printf expects arguments instructions format output instance conversion specification instructs printf pointer char argument print location string arg conversion specifiers statements printf arg printf arg effect printf arg application user control passed arg application susceptible format-string vulnerability fix vulnerabilities source-to-source transformation replaces occurrences ofprintf arg withprintf arg instance source code application application generates format-strings dynamically shankar built tool percent-s analyze source code identify tainted format-strings controlled attacker potentially vulnerable printf locations identified binary executables aforementioned techniques produce format-strings exploit vulnerabilities identify present analyze understand printffamily format-string vulnerabilities format-string viewed sequence commands instructs printf types arguments application runtime stack built tool analyze potentially vulnerable call sites printf determine exploit exploit tool produces format-string demonstrates exploit technique require source code application analyze potentially vulnerable printf locations binary executables tool conjunction percent-s generate format-strings exploit vulnerabilities identified section discussion implementation make platform-specific assumptions technique applies platforms work architecture runtime stack application grows higher addresses lower addresses machine assumed little-endian arguments function stack left call foo arg arg places arg stack arg popular calling convention implemented compilers analyze printf glibclibrary understanding printf int foo char usrinp char fmt len int strncpy fmt usrinp len fmt len printf fmt figure procedure vulnerable call printf section reviews printf works code fragment shown figure procedure foo accepts user input copied local variable fmt local array len characters printf called fmt argument argument printf controlled user program potentially exploited printf called line arguments passed printf stack return address frame pointer saved space allocated local variables printf shown figure case printf called pointer fmt local character buffer foo pointer shown darkly shaded region figure mentioned earlier printf assigns special meaning argument passed treats format-string arguments passed printf higher addresses format-string runtime stack case fmt passed argument arguments runtime stack printf implementation internally maintains pointers stack refer pointers fmtptr argptr purpose fmtptr track current formatting character scanned format-string argptr track location stack read argument printf begins read arguments fmtptr positioned beginning format-string argptr positioned pointer format-string fmt shown figure whenprintfbegins execute moves fmtptr formatstring fmt advancing pointer makes move higher addresses memory fmtptr moves direction opposite stack grows printf modes printing mode reads bytes format-string prints argument-capture mode reads arguments stack location pointed argptr type argument number bytes argptr advanced reads argument determined contents location pointed fmtptr fmtptr argptr move higher addresses reach intermediate configurations shown figure note argptr advances contents fmt printf enter argument-capture mode localvariables foo return address frame pointer return address frame pointer fmtptr argptrfmtptr argptr local variablesof printfprintfstack frame stack framefoo local variables foo direction stack growth dis len printflocal variables fmt fmt figure runtime execution stack program figure concrete suppose fmt printf called figure printf starts printing mode advances fmtptr printing stdout result fmtptr encounters byte enters argument-capture mode fmtptr advanced points byte instructs 
printf read bytes location pointed argptr print resulting terminal integer results argptr advanced bytes size integer note integer arguments explicitly passed printf figure reading legitimate integer stack case argptr reads values local variables stack frame foo result read contents stack possibly values interest attacker return addresses format-string exploits discussed paper goal attacker control contents format-string argptr advances stack enters format-string attacker control arguments read printf section develops point formally printf api key observation byte format-string instruction printf move fmtptr argptr amount bytes instruct printf types arguments passed formulation byte format-string treated api command printf format-string specifies sequence api operations goal discover possibly malicious sequences corresponds finding format-strings exploit printf call characterized parameters values dis len shown figure format-string vulnerabilities occur format-string controlled attacker buffer runtime stack len denotes length buffer dis denotes number bytes separate pointer format-string format-string figure shows simple scenario stack frame format-string stack frame printf adjacent general separated stack frames intermediate functions resulting larger values dis note values dis len sufficient capture relevant details problem values dis len printf call obtained disassembling binary executable application calls printf examining call graph sizes functions stack frames formally printf init denotes set local variables implementation printf capture current state identified local variables flags integer boolean values examining source code manuals printf implementation considers flags purposes explanation restrict flags fmtptr argptr longlong fmtptr argptr pointers functionality discussed earlier treat integer values integer counts number bytes printed longlong boolean variable determines argument stack long long long long int bytes length init initial state printf determined initial values flags assume addressing relative initial location argptr init defined argptr fmtptr dis longlong false variables discussed explained byte format-string interpreted instruction printf byte values values pre post operation based state printf obtained examining source code printf instance pre true post captures semantics printf printing mode determined variable mode fmtptr incremented printf enters argument-capture mode printf argument-capture mode fmtptr incremented actual implementation printf flags integer pointer data types finite-precision bit-vectors model flags values treated boolean rest treated unbounded integers approach achieves efficiency raising level abstraction model integer overflow lead imprecision printf enters printing mode corresponds printing stdout formally mode printing fmtptrprime fmtptr modeprime argument-capture mode argument-capture fmtptrprime fmtptr doneprime modeprime printing primed variables denote next-state values variables set language legal format-strings turns regular language extracted api-automaton recognizes legal format-strings control-flow graph implementation printf possibilities forbad determines attack exploits format-string vulnerabilities present possibilities bad section general predicate expressed formula elements decidable logic includes quantifier-free presburger arithmetic uninterpreted functions theory memories arrays formula quantifier-free presburger arithmetic consists set linear constraints integer variables combined boolean operators implemented tool examine system detect format-string exploits tool encodes printf parameterized values dis len predicate bad choice bounded model checker influenced logic needed express model printf elaborated model values stack precisely track contents format-string serves concrete counter-example bad satisfied necessitates theory memories uninterpreted functions printf integer boolean variables integer variables modified linear-arithmetic operations addition multiplication constant express formulas variables quantifier-free presburger arithmetic based requirements chose bounded model checking capabilities uclid verifier details uclid works scope paper found description printf encoded uclid model straightforward manner bad satisfied uclid produces counter-example directly translated format-string demonstrates exploit call-site printf examine format-strings length equal len exclude terminating bound len suffices make bounded model checking complete call-site printf location deemed safe tool bound len safe respect property checked checking printf api exploits goal attacker manipulate contents format-string force argptr move format-string argptr move dis bytes time fmtptr moves len bytes attacker controls format-string control arguments printf reads stack demonstrated vulnerability read data write data location memory reading arbitrary location ways attacker print contents memory address most-significant byte construct format-string moves fmtptr argptr printf printing mode fmtptr points beginning argptr points bad read exploit bad write exploit fmtptr dis len argptr dis argptr dis len fmtptr fmtptr argptr argptr argptr argptr mode printing fmtptr dis len argptr dis argptr dis len fmtptr fmtptr argptr argptr argptr argptr writeval mode printing figure predicate bad read exploit write exploit beginning sequence bytes pointer printf reads interprets argument argptr pointer prints contents memory location pointer string attacker achieve goal formalized predicate bad shown figure note little-endianness machine reflected formulation bad bytes arranged most-significant leastsignificant addresses decrease appears lower address symbolic values stack locations fmtptr argptr bad show track stack contents precisely figure shows results produced tool values dis len instance line shows formatstring read contents memory dis len exploit proceeds initially fmtptr points format-string argptr smaller fmtptr printf starts execution printing mode advances fmtptr prints bytes stdout printf reads advances fmtptr enters argument-capture mode reads advances fmtptr reads integer bytes location pointed argptr prints integer stdout returns printing mode result argptr points beginning format-string fmtptr positioned beginning sequence printf processes contents memory location printed stdout observations figure line tool infer exploit intuitively format-string small sequence commands carry exploit lines present format-strings parameters achieved observing case running tool appending suitable term bad exclude case technique iterated infer variants exploit desired writing arbitrary location kind format-string exploit attacker write choice location memory chosen makes feature provided printf printf printing mode encounters format-string reads argument stack interprets pointer integer writes flag location constraint non-zero interpreted terminates format-string ease explanation impose additional restriction negationslash address parts conversion specifier tool discover exploits address counts number bytes output call printf figure shows case attacker writes integer writeval address figure shows format-strings obtained tool write integer memory address line instance values dis len tool inferred format-string printf starts execution printing mode argptr bytes fmtptr stack fmtptr moves format-string bytes printed stdout incrementing byte increments fmtptr byte forces printf argumentcapture mode bytes treated width parameter printf stores internal flag width part printf printf processes byte advances argptr bytes reads double stack prints appropriately formatted stdout increments width returns printing mode point argptr points beginning format-string bytes fmtptr points beginning sequence printf processes written completing exploit execution times shown figure obtained machine intel pentiumprocessor running ghz ram running redhat linuxall runs completed minutes general trend time increases len increases monotonically reason larger values len run bounded model checker uclid steps leading 
larger formula check largest formulas boolean combinations thousand linear constraints hundred integer variables uclid translates problem checking validity boolean formula checked sat solver called siege note time finding read exploits lower finding write exploits finding write exploit involves solving constrained problem read exploit addition finding sequence conversion specifications moves argptr format-string find width values add desired figure length sequence len optimizations model printf byte format-string considered api operation optimization add aggregated api operations treat sequences primitive api operations single operation create aggregated api operation moves fmtptr bytes argptr bytes reads long double similarly conservative width specifiers form aggregate api operation increments addition changing flags augmenting affect soundness format-strings uclid previously generate generated optimization longer strings potentially found fewer iterations bounded model checking comparison existing tools demonstrate effectiveness tool compared percent-s tool analyzes source code typethe number bytes printed maximum width specifier needed precisely represent output width specifier conservatively large dis len read exploit write exploit exploit string discovered time sec exploit string discovered time sec exploit exploit exploit figure exploits generated tool write exploit chose write integer memory location specific address software dis len exploit exploit string discovered represents non-zero nonascii character phpwrite xbfff xbfff assume qpopperread contents xbfff wu-ftpdwrite xbfffbcab xbfff assume figure exploits generated vulnerabilities real-world software packages qualifiers identify tainted user-controlled inputs potentially format-strings report experiments showing reduce false alarm rate showing confirm true vulnerability generating exploit program figure compiled machine dis bytes irrespective len size bufferfmt percent-s reports theprintf statement line exploitable small values len preclude possibility attack result percent-s produces false alarms account values parameters dis len hand model printf infer read-exploit similar reported earlier len bytes write-exploit write integer len bytes cases analysis produces formatstring demonstrates exploit percent-s tool analyze format-string vulnerabilities real-world software packages figure details phpis language-processor widely-used webscripting language php qpopperis pop mail server wu-ftpdis popular file-transfer daemon explain detail exploit againstwu-ftpdthe similar percent-s correctly identified location vulnerability wu-ftpdbut produce format-string demonstrating exploit dis len obtained disassembling binary executable values dis len checked attacker perform exploit attacker buffer stores format-string additionally store malicious code overwrites return address stack frame printf write exploit section point beginning malicious code sequence assumed return address overwritten stack location xbfff malicious code located address xbfffbcab bytes located buffer stores format-string address values easily read stack exploit explained section written fairly large variant predicate bad writing single address multiple slightly misaligned writes smaller values details misaligned writes found values dis len large optimizations section infer minutes format-string concatenation strings prefix middle part consisting repetitions aggregated api operation suffix xbfff verified string writes desired desired location write performed writes xbcab writes xbfff existing format-string exploit generators attempt construct format strings fixed conversion specifiers instance thuemmel constructs format-strings conversion specifier building block result techniques lack soundness exploit strings space strings explored tools exhaustive search state space technique guarantees soundness model printf addition existing tools incapable finding variants exploit demonstrated lines figure technique discover variants exploit values dis len ibm cca api present case study ibm cca api cca api cryptographic-key management api secure hardware devices coprocessors ibm coprocessor cryptographic services key-management host computer ibm loaded distinct secret master key denoted safeguarded physical security device security host relies secrecy background cca cca ibm key-management host computer issues commands api communicated cca coprocessor noteworthy feature cca ability assign types called control vectors keys control vector key determines subset operations api accessible cca defines control vectors classes keys compute message authentication codes pin numbers control vectors cca implement role-based access control rbac important preserve integrity cryptographic keys clear values keys stored host computer similarly preserve integrity rbac key tightly coupled control vector ibm achieves objectives storing key hard disk host computer operational key-token discussion paper restrict components keytoken denoted emk cvk cvk denotes bit-wise exclusive-or denotes symmetric-key encryption algorithm des key component encrypted clear cvk presented key token ibm cvk component decrypt component retrieve clear revealed ibm observe retrieved component key-token modified note key-token function ibm master keys hosts share cryptographic-keys instance establish session-keys communication discuss communication hosts ibm keys mka mkb cca api key management supported methods communication involves establishing secure communication channel symmetric key-encrypting key encrypt cca-managed keys transported channel key-encrypting key clear denote kek cca key control vector cvkek stored operational key-tokens emka cvkek kek cvkek emkb cvkek kek cvkek techniques supported cca installing key-encrypting keys works parties generates key parts kek key parts transported clear separately entered key part import cca api-operation figure result api-operation operational key-token kek idea clear kek retrieved key-part holders collude situation key control vector cvk stored key-token emka cvk cvk share key-token directly clear encrypted mka keysharing ibm cca api-operation key export shown figure makes key-token deviceindependent api-operation operational key-tokens kek produce token ekek cvk cvk export key-token device-independent intuitively key-token emka cvkek kek cvkek retrieve kek ibm produce kek cvk cvk retrieved key-token emka cvk cvk ibm emka cvk cvk retrieve values produce export key-token export key-token transported network referred import key-token apioperation key import specification figure convert key-token operational key-token input api-operation operational key-token kek input key-token received communication channel key export key import retrieves clear kek cvk input produce kek cvk retrieve decrypting ekek cvk clear cvk produce operational key-token emkb cvk cvk formally api formalize cca api framework developed section focus security cca api restrict attention sequence api operations issued coprocessor make assumptions host analyze communicate hosts establish secure communication channel key-exchange protected keyencrypting key kek assume initiates communication key-encrypting key stored emkb cvkek kek cvkek api-operation key part import install key-encrypting keys framework section init denotes single set-valued variable keytokens denotes set key-tokens init keytokens empty set key part import key import key export subset cca api analyze intuitively track set key-tokens ibm variable keytokens assume set initially empty assume api-operations interleaved arbitrarily denoted operations accept arguments pre post defined key part import pre true post emka cvkek cvkek keytokens key import pre asserts structure key-tokens enc denote half half key-token similarly post asserts emka key keytokens key enc eval key val enc emka val key export analogous 
key import intuitively val denotes clear key-encrypting key retrieved retrieve key produce operational keytoken required post keytokens safety property verify integrity rbac operational key-token obtained key import control vector control vector export key-token communication channel ekek cvk cvk operational key-token emka cvk cvk bad defined emka cvnew cvnew keytokens cvnewnegationslash cvk key study security provided cca api assume attacker complete control attacker observe manipulate messages communication channel addition manipulate key-token stored host computer invoke cca api operations ibm arguments choice assumptions follow standard dolev-yao attacker model formal statement attacker abilities shown figure figure denote set terms attacker rules capture attacker enhance knowledge set terms instance rule attacker terms checking api built prolog-based bounded model checker analyze specification chose prolog inference rules api operation expected input expected input output key part import clear clear emk cvkek cvkek key export emk cvkek kek cvkek emk cvk cvk ekek cvk cvk key import emk cvkek kek cvkek ekek cvk cvk emk cvk cvk figure api operations ibm cca denotes master key coprocessor cca operates kek denotes clear key-encrypting key denotes clear cca key cvk denotes control vector cvkek denotes control vector key-encrypting keys rules turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft cryption turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft pairing turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft turnstileleft figure knowledge enhancement rules associativity commutativity rules shown presented figure api operations easily encoded prolog rules refer reader accompanying technical report details model checker api specification discussed model checker produces counter-example trace shown figure chosendifference exploit control vectors discovered bond key part import input input cvk cvnew output emka cvkek kek cvk cvnew cvkek key import input emka cvkek kek cvk cvnew cvkek input ekek cvk cvnew output emka cvnew cvnew figure counter-example trace showing exploit exploit works suppose attacker kek instance attacker holder statement figure attacker installs key choice key-encrypting key attacker manipulate key part produce cvk cvnew cvk control vector key transported network cvnew control vector chosen attacker key part import executed modified key part argument key-token emka cvkek kek cvk cvnew cvkek results thinks key-token shared key-encrypting key input statement figure corresponds step attacker unpairing pairing rules figure obtain ekek cvk cvnew ekek cvk cvk invokes key import modified key-token key-token shared key obtained step attack key import produces mka cvkek cvkek input retrieve kek cvk cvnew half input normal operation retrieved kek key import extracts cvnew input xor kek cvk cvnew obtain kek cvk retrieve portion ekek cvk input process fooled thinking key control vector cvnew key import terminates producing operational key-token emka cvnew cvnew violates integrity rbac completes exploit bond demonstrates learn sensitive values pin-encrypting keys worth noting analyzing apis requires modeling kinds low-level details instance section considered layout stack frames discover format-string exploits hand cca api considered adversary increase knowledge standard rules figure note rules employed security-protocol verifiers cca api potentially analyzed security-protocol verifier related work model checking software model checking tools proposed recent years tools check software violations user-defined assertions temporal-ordering rules events finite-state abstractions model data values successful verifying control-flow-intensive properties discussed earlier api-level exploit concrete trace model satisfies bad key difference apilevel exploit concrete counter-examples produced tools exploit low-level details unlike aforementioned tools technique capable finding exploits permits modeling low-level details layout program runtime stack strategy employ finding exploits based bounded infinite-state model checking uclid verifier printf case study driven reason quantifier-free presburger arithmetic bound len guarantees completeness general choice analysis tool depend logic needed reason system underlying logic first-order relational logic alloy analyzer similarly unbounded infinite-state model checking techniques potentially test generation formal specifications software generate test cases bounded exhaustive testing specifications typically form preand post-conditions tools exhaustively generate input data structures upto size satisfy conditions counterexamples produced model checking tools generate test cases analysis viewed form test generation api-level exploits generated test patched versions component implements api ad-hoc techniques prior work security-exploit generators including generators format-string exploits noted section techniques proposed typically ad-hoc provide soundness guarantees search specific attack patterns format-strings fixed conversion width specifier miss kinds attacks addition techniques incapable generating variants exploit paper presents general formal framework generate exploits previous exploit-generation tools find typeand constraint-based analysis static analyzers special classes vulnerabilities buffer overruns format-string vulnerabilities proposed demonstrated section analysis complements tools exploit generated vulnerability identified tools evidence vulnerability real hand exploit generated vulnerability automatically classified false alarm interface synthesis complementary analysis finding api-level exploits problem synthesizing correct usage rules apis techniques proposed synthesize interfaces including techniques mine execution traces techniques based model checking output techniques typically finite-state machine api operations api-automaton formal framework superoptimizers code generator produces code optimized respect criteria number instructions called superoptimizer recent work explored sat solvers theorem-provers technique similar presented section produce superoptimized code space code sequences explored propositional boolean formula theorem prover identify code sequences satisfy optimization criterion superoptimizers model low-level instruction semantics generate intricate compact code sequences conclusions main message paper model low-level details software component implementation order find exploits demonstrated api-level exploits presented framework model analyze apis exploits showed framework real-world apis significant complexity briefly discuss difficulties encountered modeling analyzing apis modeling low-level details demonstrated case studies apis exploited ways main problem identify low-level details model api solution model api operation bit-level bit system affected applying api operation approach solve problem identifying low-details api scale expect case studies domainspecific expertise solution identify lowlevel details api constructing predicate bad figure fact read memory location exploits found tool blueprint covers large class exploits ways read memory tool miss domainspecific expertise needed construct predicate bad covers large class exploits automating model construction models printf ibm cca api constructed manually examining source code studying manuals tedious error-prone process modern software model checkers automatically construct finite-state models predicate abstraction case main obstacles automatic model construction twofold low-level details modeled domain-specific resulting model infinite-state section future work intend investigate techniques set low-level details modeled automatically extract models amenable exploit-analysis alur cerny madhusudan nam synthesis interface specifications java classes proc popl acm ammons bodik larus mining specifications proc popl acm ball rajamani slam project debugging system software static analysis proc popl acm beyer chipala henzinger jhala 
majumdar generating tests counterexamples proc icse ieee biere cimatti clarke zhu symbolic model checking bdds proc tacas lncs springer bond chosen key difference attack control vectors manuscript november http cam mkb research cvdif pdf boyapati khurshid marinov korat automated testing based java predicates proc issta acm bryant lahiri seshia modeling verifying systems logic counter arithmetic lambda expressions uninterpreted functions proc cav lncs springer bultan gerber pugh model-checking concurrent systems unbounded integer variables symbolic representations approximations experimental results acm toplas chen wagner mops infrastructure examining security properties software proc ccs acm clarke kroening lerda tool checking ansi-c programs proc tacas cowan barringer beattie kroah-hartman frantzen lokier formatguard automatic protection printf format-string vulnerabilities proc security symp usenix alfaro henzinger interface automata proc esec fse acm moura rue sorea lazy theorem proving bounded model checking infinite domains proc cade lncs springer dolev yao security public key protocols ieee transactions information theory engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions proc osdi acm usenix ferraiolo kuhn role based access control national computer security conference october foster fahndrich aiken theory type qualifiers proc pldi acm ganapathy seshia jha reps bryant automatic discovery api-level vulnerabilities technical report dept univ wisconsin http wisc wisa papers pdf harrison ruzzo ullmann protection operating systems comm acm henzinger jhala majumdar sutre lazy abstraction proc popl acm hoglund mcgraw exploiting software break code addison wesley boston jackson automating first-order relational logic proc fse acm johnson dolan kelly matyas common cryptographic architecture cryptographic application programming interface ibm systems journal joshi nelson randall denali goal-directed superoptimizer proc pldi acm massalin superoptimizer smallest program proc asplos acm matyas abraham key management scheme based control vectors ibm systems journal meadows nrl protocol analyzer overview journal logic programming moskewicz madigan zhao zhang malik chaff engineering efficient sat solver proc dac acm newsham format string attacks securityfocus guest securityfocus qualcomm qpopper vulnerability securityfocus advisories seshia bryant deciding quantifier-free presburger formulas parameterized solution bounds proc lics ieee shankar talwar foster wagner automated detection format-string vulnerabilities type qualifiers proc security symp usenix siege sat solver http sfu loryan personal stump barrett dill cvc cooperating validity checker proc cav lncs springer sullivan yang coppit khurshid jackson software assurance bounded exhaustive testing proc issta acm thuemmel analysis format string bugs manuscript http downloads securityfocus library format-bug-analysis pdf wagner dean intrusion detection static analysis proc symp security privacy ieee wagner foster brewer aiken step automated detection buffer overrun vulnerabilities proc ndss isoc xie aiken scalable error detection boolean satisfiability proc popl acm 
verification structure simulation immerman rabinovich reps sagiv yorsh dept comp sci univ massachusetts immerman umass school comp sci tel aviv univ frabinoa msagiv gretayg post tau comp sci dept univ wisconsin reps wisc paper shows harness decision procedures automatically verify safety properties imperative programs perform dynamic storage allocation destructive updating structure fields decidable logics express reachability properties state properties linked data structures guaranteeing verification method terminates main technical contribution method structure simulation set original structures model doubly linked lists nested linked lists binary trees mapped set tractable structures reasoned decidable logics decidable logics express reachability limited data structures directly model instance examples logic mso-e model function graphs simulation technique indirect model additional data structures introduction paper explore extent decidable logics check properties programs perform dynamic storage allocation destructive updating structure fields key contributions method structure simulation set original structures model doubly linked lists nested linked lists binary trees mapped set tractable structures reasoned decidable logics motivation automatically proving safety liveness properties sequential concurrent programs permit dynamic storage allocation low-level pointer manipulations challenging dynamic allocation state space infinite abstractdatatype operations implemented loops procedure calls sequences low-level pointer manipulations hard prove data-structure invariant reestablished sequence operations finished reachability crucial reasoning linked data structures verify memory configuration garbage elements show element reachable program variable properties presents challenge requires logic ability quantify unbounded resources express reachability properties simple decidable fragments first-order logic undecidable reachability added reader undecidable logics automatic verification supported nsf grant ccrand guggenheim fellowship supported onr contract von humboldt foundation supported israel science foundation overview approach section illustrate simulation technique showing applicability semi-automatic hoare-style verification technique applied improve precision operations abstract interpretation hoare-style verification recall hoare-style verification programmer expresses partial-correctness requirements form fpregstfpostg pre post logical formulas express preand post-condition statement handle loops loop invariants provided logical formulas annotations formula generated called verification condition program valid program partially correct paper pre-conditions post-conditions loop invariants first-order formulas transitive closure generated verification condition formula logic natural express pointer dereferencing dynamic creation objects threads validity logic undecidable validity program verification condition checked directly restricting set reachable program states perform verification automatically restrict set program states sufficiently make validity problem decidable precisely program class data structures interest choose designated set structuresc problem checking general formula holds structures decidable words work formulas validity problem undecidable general restricting attention class structures change problem decidable simulation invariants defined class data structures program assume set defined priori assume class definable formula exists formula iff called simulation invariant similar datastructure invariant class invariant formula defined data structure model logical perspective restricting attention structures satisfying check property holds structures showing validity first-order reductions implementing decision procedure parametric validity formulas form provide translate formulas automatically decidable logic existing decision procedure define admissibility conditions guarantee formula form valid formula decidable logic valid existing decision procedures determine validity verification conditions paper illustrate method decidable logic mso-e weak monadic second-order logic function graphs formulas restricted set graphs including possibly cyclic graphs graphs nodes in-degree greater translated mso-e formulas function graphs opens possibility apply mso-e larger set graphs handling low-level mutations destructive updates pointer-valued structure fields simulation invariant violated verification condition check simulation invariant maintained change requirement statement fpregstfpostg fpre sigstfpost sig guarantees method miss error detect error specification violation simulation invariant operation correct programs temporarily violate data-structure invariant violation data-structure invariant error rotate acyclic singly-linked list creating cycle breaking cycle complicates task defining simulation invariants user simulation invariant restrictive data-structure invariant data-structure interest approach handle realistic programs manipulate data structures limited number mutated pointer fields limited programmer sufficient flexibility assert data-structure invariant reestablished stable states main results contributions paper summarized state precise requirements method applied verify properties imperative programs written programming language pointers destructive updates section proofs full version paper show programs manipulate commonly data structures singly-linked including cyclic shared lists doubly-linked lists trees unbounded branching satisfy requirements section note structures tractable singly linked lists simple trees methods work trivially section show method hoare-style verification assume programmer specifies loop invariants preand postconditions procedures section show method automatic verification abstract interpretation eliminates provide loop invariants establish weaker safety properties proved hoare-style verification fills missing piece algorithm presented requires decidable logic compute abstract transformer automatically apply algorithm imperative programs perform destructive updates implemented tvla mona simulation section define notation describe simulation methodology detail notation vocabulary denote logic vocabulary examples first-order logic transitive closure arbitrary binary transitive closure operator tcu denotes reflexive transitive closure binary relation omit subscript tcu clear context principle logics secondorder logic struct denote set finite structures vocabulary denote set structures satisfy closed formula struct class original structures fra rakk vocabulary arity relation symbol note arbitrarily rich subset struct structures simulated assume user simulation invariant defines subclass simulated global invariant hold program set forests binary trees represented logical structures binary relations denote pointers left subtree shown column table specifies partial functions forbids structures shared nodes cycles created pointers clear forests binary trees satisfy requirement structure satisfies represents forest binary trees binary trees section demonstrate method notation treefl similar notation section manner data-type programming language specific object tree data-type rep set representation structures decidable logic rep algorithm halts inputs tells formula holds structures rep examples rep set finite function graphs vertex edge leaving rep denote vocabulary rep illustrate method fixing mso-e weak monadic second-order logic function graphs vocabulary rep includes binary relation symbol interpreted relation partial function arbitrary unary relation symbols constant symbols included reachability expressible mso-e second-order quantification mso-e decidable reduction monadic second-order theory unary function addition simulation invariant assume user representation invariant defines subclass rep simulation methodology define first-order mapping struct rep struct definition first-order mapping struct rep structure universe jaj relation symbol arity formula vai rep structure universe relation symbol interpreted eaii jajai flfl eai simplicity make same-universe assumption paper first-order mappings change size universe polynomial function column table lists formulas main original data structures representation treefl rep formula intuitively simulation reverses r-edges recording e-edges marks node target l-edge r-edge first-order mapping structures defines dual first-order translation formulas opposite direction rep definition first-order translation formula rep result replacing occurrence tai formula tai immediately struct 
rep definition follow proposition easily extended handle transitive-closure operator allowed figure sketch mapping rep dual rep guarantee queries original structures struc orgorg repstruc rep fig defines class structures mapped rep precisely answered representation restrictions imposed definition admissibility requirement first-order mapping struct rep struct simulation invariant representation invariant rep rii admissible properties hold well-definedeness rep ontoness exists structure rep fact examples shown table provide explicitly define lemma sufficient condition admissibility lemma exists rep admissible admissibility guarantees query original language translated query representation language answered decision procedure theorem simulation theorem assume rii defines admissible simulation holds iff holds rep corollary assume rii defines admissible simulation iii decidable rep exists algorithm checks holds simpler express condition equation show condition holds examples section definition immediately rep turn contained monadic second-order logic binary relation necessarily interpreted partial function examples ensures partial function mso-e condition holds examples decision procedure mso-e examples check validity formulas implementing decision procedure mso-e implemented translation mso-e formulas simulation method full paper existing decision procedure mona logic remark decidable logic places syntactic restriction formulas case dtc condition corollary satisfied cases replace definition algorithm set heuristics generates formula equivalent rep experience main difficulty ensure ind problem addressed choosing stronger representation invariant simulation invariant stronger original proving admissibility directly definition lemma simulating commonly data structures distinguish families data structures field-pointers intended meaning table shows simulation-specific definitions required family data structures translation invariant vocabulary binary predicates represent field-pointers unary predicates represent pointer variables properties elements names binary predicates specific unary predicates named formula vocabulary rep unary predicates additional simulation-specific unary predicates sllfng singly linked list denotes field-pointer element list rep set function graphs rep translation mapping identity functions represents field-pointer point memory location requires interpreted partial function simulation invariant handle singly-linked list including cyclic shared lists treefl standard tree data-structure explained earlier ubtreefsg tree unbounded branching successor relation successor tree rep set acyclic function graphs rep simulation simply reverses edges data structure translation simulation invariant sllfng func treefl func func uns acyc ubtreefsg uns acyc dllff func func uns dllff points pkg bpi func func uns uns unique dllff defined func func uns uns table commonly data structures simulations formula func field-pointer defined ensures interpreted partial function formula uns formula defined formula acyc formula defined formula unique unary predicate defined dllff doubly linked list denote forward backward field-pointers point refer simulation dll table purpose simulations explained section rep includes simulationspecific unary predicate set function graphs rep graph node labeled shared incoming e-edge simulation invariant ensures backward pointer point predecessor element f-predecessor backward pointer benull translation represents binary relation unary predicate denotes presence absence backward pointer element full version paper complex simulations generalized trees undirected graphs applications section provide motivation potential applications meaning program statements assume meaning atomic program statement expressed formula transformer wpst expresses weakest precondition required produce structures satisfy formula input structure satisfies wpst resultant structure produced satisfies hoare-style verification hoare-style verification programmer expresses partial-correctness requirements form fpregstfpostg pre post logical formulas express preand post-condition statement handle loops required loop invariants provided logical formulas conventional hoare-style verification partial correctness statement ensured validity formula pre wpst post approach partial correctness ensured validity formula pre wpst post presence left-hand side corresponds assumption interested states holds presence right-hand side operator wpst ensures execution yields state holds means verification system report error execution post violated global invariant violated partial correctness sequential composition conditional statements loop invariants expressed similar extensions standard hoare-style approach abstract interpretation abstract-interpretation technique conservative automatic verification partial correctness conducted identifying sound over-approximations loop invariants iterative computation carried determine abstract program point result program point abstract summarizes sets reachable concrete states point abstract interpretation assume set potential abstract values forms lattice concrete states represented logical structures vocabulary introduce non-standard requirement concrete states manipulated correct program satisfy abstract-interpretation system issue warning requirement violated formalize restriction concrete states concretization function yields set concrete states abstract element represents similarly abstraction function yields abstract represents set concrete states partial order denoted satisfies element lower bound set lattice closed meet operator denoted yields greatest lower bound respect set lower bound lower bound concretization abstraction functions form galois connection additional assumption place concretization expressed exists formula denoted represents tightest over-approximation set concrete states formula denoted bfi computed bfi ufaj lemma states bfi tightest over-approximation lemma formula bfi statement abstract denotes set states section ensure global invariant maintained checking validity wpst requirement non-standard abstract interpretation reflects fact states violating abstract-interpretation system issue warning condition violated compute most-precise effect statement abstract input tightest over-approximation strongest post-condition ufa wpst surprisingly formulas abstract interpretation similar formulas hoare-style verification section circumstances validity checkers automatically yield algorithms bfi checking statement maintains abstract interpretation statement precise abstract domain finite lattice eqns brute-force generating validity query elements domain elaborate algorithms handle finite-height lattices infinite cardinality reader referred summary summarize steps user approach carry verification user provide inputs listed inputs standard verification methods inputs interdependent explained scheme encoding program memory configurations logical structures vocabulary description weakest precondition statement decidable logic rep first-order mapping simulation invariant representation invariant user ensure rii admissible initial program state satisfies implemented approach part tvla system parametric system performing abstract interpretation simulation package initialized reading definition rep file provided user tvla binary trees rep easily configured decidable logics package takes formula returns translation computed substitution implemented symbolicchecker interfaces mona tool symbolicchecker takes formula checks formula valid symbolicchecker perform abstract interpretation sample programs simulation invariant supports low-level heap mutations section show program temporarily violates data-structure invariant show gradually generalize simulation invariant cope low-level mutations program dll enum color fred blackg typedef struct nodef struct node enum color dll divide dll dllr dllb void divide dll dll dllb dllr null null red dllr dllr dllb dllb dllr null dllrb null dllr dllr dllrb dllrf dllb null dllbb null dllb dllb dllbb dllbf ggg table data type colored doubly linked lists list node marked red black program divides colored doubly linked list disjoint lists pointed dllr dllb nodes color data-type table defines doubly-linked list additional bit element represented unary predicates red black program divide table takes input doubly-linked list pointed 
red black elements verify program arranges elements reachable disjoint doubly-linked lists pointed dllr dllb elements color automatically verify property verification methods provide simulation invariant basic simulation basic simulation dllff table defines simulation invariant statement dllr divide program weakest precondition dllr basic simulation invariant dllr structure satisfies result applying dllr satisfies structures arises divide statement dllr satisfy means result applying statement structure shown left fig satisfy reason backward pointer element point predecessor element mutations result structure backward pointer null points f-predecessor backward pointer element pointed dllr recorded predicate provided basic simulation k-bounded simulation simulation dllff table defines simulation invariant weakest precondition dllr rep gfed abcred gfed abc black gfed abcred gfed abcred gfed abcred gfed abc black gfed abc red gfed abc red gfed abcred gfed abc black gfed abc red jjbb gfed abcred dllr dllb gfed abcred gfed abc black gfed abc red gfed abc red dllr dllb bdllr gfed abcred gfed abc black gfed abc red gfed abcred dllb dllr gfed abcred gfed abc black gfed abc red gfed abc red dllb dllr gfed abcred gfed abc black gfed abcred gfed abcred dllb dllr gfed abcred gfed abc black gfed abc red gfed abc red dllb dllr fig structures produced divide operation red-black list table shown left representation structures initial structure basic simulation structure iterations loop k-bounded simulation set unary predicates fdllr dllbg symbol edge structure edge deleted dllr structure end loop formula-based simulation defined result divide disjoint doubly linked lists represented correctly basic simulation dllr dllr dllb show structure satisfies remains dllr restrictive mutations redirect backward pointer element pointed variables unique point element translation represents unary predicates bpk addition bpi backward pointer element element pointed divide variables dllr dllb representation structure fig predicate bdllr correctly capture result dllr operation subsequent operation dllr program divide moves dllr forward list weakest precondition dllr hold structure fig statement dllr makes previous bdllr undefined enables mutation structures dllr point element backward pointer directed element pointed dllr backward pointer f-successor captured simulation b-field defined formula simulation dllff table defines simulation invariant defines backward pointer formula mso-e predecessor translation represents unary predicate addition backward pointer element represented points element represented holds defined red black fred blackg defined guarantees element color reachable f-edges simulation capture intermediate structures occur divide shown fig summarize high-level operation divide preserves data-structure invariant input doubly-linked list satisfies basic simulation invariant table result satisfies problem implementation divide performs low-level mutations temporarily violate invariant restore case mutation operation simulated correctly basic invariant related work decidable logics expressing data-structure properties decidable logics successfully define properties linked data structures define properties heap-allocated data structures conduct hoare-style verification programmer-supplied loop invariants pale system decidable logic called logic reachability expressions defined rich express shape descriptors studied path matrices introduced contrast mso-e dtc describe families arbitrary stores trees structures binary predicate expressive power limited properties memory locations instance express families structures captured shape descriptors arise run tvla define doubly linked lists existence cycles starting arbitrary memory locations simulating stores idea simulating low-level mutations related representation simulation milner data-structure refinement hoare simulation invariant defined representation structures denotes set representation structures well-defined method obvious advantage formulas directly translation method requires translation defined formulas logics pale hard-coded mapping linked data-structures mona decision procedures simulation technique extend applicability general sets stores handled cyclic shared singly-linked lists section simulate generalized trees undirected graphs conclusion paper technique increase applicability decision procedures larger classes graph structures graph mutations arbitrary first-order formulas model deterministic programminglanguage statements including destructive updates implemented interface tvla mona simulation apply simulation method section enabling precise abstract interpretation benedikt reps sagiv decidable logic describing linked data structures european symp programming pages march cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press elgaard ller schwartzbach compile-time debugging programs working trees european symp programming pages hendren parallelizing programs recursive data structures phd thesis cornell univ ithaca jan henriksen jensen rgensen klarlund paige rauhe sandholm mona monadic second-order logic practice tacas hoare proof correctness data representations acta inf hoare recursive data structures int comp inf sci immerman descriptive complexity springer-verlag immerman rabinovich reps sagiv yorsh boundery decidability undecidability transitive closure logics submitted ller schwartzbach pointer assertion logic engine sigplan conf prog lang design impl pages rabin decidability second-order theories automata infinite trees trans amer math soc reps sagiv yorsh symbolic implementation transformer proc vmcai sagiv reps wilhelm solving shape-analysis problems languages destructive updating trans prog lang syst january yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tacas pages 
analyzing memory accesses executables gogul balakrishnan thomas reps comp sci dept wisconsin fbgogul repsg wisc abstract paper concerns static-analysis algorithms analyzing executables aim work recover intermediate representations similar created program written high-level language goal perform task programs plugins mobile code worms virus-infected code programs symbol-table debugging information absent relied present technique paper makes symboltable debugging information analysis carried recover information contents memory locations manipulated executable introduction recent years growing tools analyze executables ensure web-plugins java applets perform malicious operations important decipher behavior worms virusinfected code static analysis techniques problems major stumbling block developing binary-analysis tools difficult understand memory operations machine-language instructions explicit memory addresses indirect addressing paper present techniques overcome obstacle developing binary-analysis tools source-code-analysis tools provide information contents program variables variables manipulated binary-analysis tool provide information contents memory locations manipulated existing techniques treat memory accesses extremely conservatively assume presence symbol-table debugging information approach satisfactory produces approximate results information relied analyzing viruses worms mobile code analysis algorithm job previous work tracks pointer-valued integer-valued quantities program data objects hold set abstract data objects called a-locs abstract locations analysis forced give precision load memory encountered idea a-loc abstraction exploit fact accesses variables program written high-level language static addresses globals static stack-frame offsets locals find statically locations stack offsets program define a-loc set locations statically location offset including statically location offset registers malloc sites a-locs discussed data object original source-code program corresponds a-loc scalar struct array variables consist segment scalar struct array variable problem arises analyzing executables indirect-addressing mode memory operands machine-language instruction sets support addressing modes memory operands direct indirect direct addressing supported onr contracts nsf grant ccraddress instruction analysis required determine memory location a-loc referred operand hand instruction indirect addressing address typically register expression form base index scale offset base index registers cases determine memory locations referred operand values registers hold instruction determined present flow-sensitive context-insensitive analysis instruction determines over-approximation set values a-loc hold contributions work summarized describe static-analysis algorithm value-set analysis tracking values data objects hardware registers value-set analysis abstract domain representing over-approximation set values data object hold program point algorithm tracks address-valued integer-valued quantities simultaneously determines overapproximation set addresses data object hold program point time determines over-approximation set integer values data object hold program point value-set analysis obtain killed possibly-killed sets instruction program sets similar sets killed possibly-killed variables obtained compiler source-code analyses perform reaching-definitions analysis construct datadependence edges implemented analysis techniques paper combining analysis facilities provided idapro codesurfer toolkits created codesurfer prototype tool browsing inspecting analyzing executables tool recovers irs executables similar created program written high-level language paper reports preliminary performance data implementation information obtained value-set analysis decompilation tools implementation targeted executables techniques paper applicable machine languages benefits approach illustrated fig shows simple program disassembly procedure main declares integer array ten elements program initializes elements part remaining part returns array element diagram variables laid program address space shown fig understand assembly program fig helps address global variable part part local variables part part program removed optimizer mapped registers eax ebx ecx instruction modifies elements array mov eax edx modifies elements mov ebx edx statements underlined fig show backward slice program respect mov eax edi roughly corresponds return array source code obtained sets killed possibly-killed a-locs identified value-set analysis slice obtained int part int part int main int part part int array int part array part part part part part part part part return array proc main esp adjust esp locals lea eax esp part lea ebx esp part mov esp eax array part mov ecx mov edx mov eax edx part part mov edx mov ebx edx part part add eax part add ebx part ecx cmp ecx loop exit mov edi esp mov eax edi set return add esp retn return array fig program initializes array approach smaller slice obtained source-code slicing tools instance codesurfer distinguish accesses parts array slice obtained codesurfer source code include statements fig underlined part eax array array ebx part esp global global global mem mem main main main main main var ret main var var data layout memory-regions fig data layout memory-regions insights shaped design value-set analysis prevent indirect-addressing operations appearing nonaligned accesses span parts variables possibly forging pointer values important analysis discover information alignments strides memory accesses prevent loops traverse arrays appearing stacksmashing attacks analysis relational information values a-locs assigned loop related values a-locs loop branch condition desirable analysis perform pointer analysis numeric analysis simultaneously information numeric values lead improved tracking pointers pointer information lead improved tracking numeric values appears crucial capability compilers address arithmetic indirect addressing implement features pointer arithmetic pointer dereferencing array indexing accessing structure fields value-set analysis produces information precise obtained conventional numeric analyses compilers including constant propagation range analysis integer-congruence analysis time value-set analysis analog pointer analysis suitable executables debray proposed flow-sensitive context-insensitive algorithm analyzing executable determine address expressions aliases analysis yields precise results program shown fig algorithm unable determine edi analysis edi eax ebx aliases slice obtained alias analysis consist program cifuentes proposed static-slicing algorithm executables programs non-aliased memory locations identify unsafe slice program fig consisting instructions detailed discussion related work remainder paper organized describes value-set analysis fits components codesurfer discusses assumptions underlie work describes abstract domain value-set analysis describes value-set analysis algorithm summarizes auxiliary static analysis results value-set analysis interpreting conditions performing widening discusses indirect jumps indirect function calls presents preliminary performance results discusses soundness issues discusses related work value-set analysis henceforth referred vsa context problem binary executable cfgs affine relations cfgs idapro analysis analysis affine relations cfgs ckill sets codesurfer kill connector plug set fig organization codesurfer codesurfer outcome joint project univ wisconsin grammatech codesurfer makes idapro disassembly toolkit grammatech codesurfer system toolkit building program-analysis inspection tools section describes vsa fits codesurfer implementation executable disassembled idapro addition disassembly listing idapro access information statically memory addresses offsets idapro identifies statically memory addresses stack offsets program renames occurrences quantities consistent database define a-locs information procedure boundaries executables information procedure boundaries idapro identifies boundaries procedures executable idapro identify targets indirect jumps indirect calls call graph control-flow graphs constructs complete discusses techniques calls library functions idapro discovers calls 
library functions algorithm called fast library identification recognition technology flirt information identify calls malloc idapro access internal data structures api users create plug-ins executed idapro grammatech provided plugin idapro called connector augments idapro data structures vsa implemented data structures created connector vsa makes results additional preliminary analysis program point identifies affine relations hold values registers vsa completes value-sets a-locs program point determine point sets killed possibly-killed a-locs emitted format suitable input codesurfer codesurfer tool code understanding code inspection supports gui api accessing program system dependence graph sdg information stored codesurfer intermediate representations irs codesurfer gui supports browsing surfing sdg variety operations making queries sdg slicing chopping api extend codesurfer capabilities writing programs traverse codesurfer irs perform additional program analyses words order goals capabilities assumptions underlying work executable input goal check executable conforms standard compilation model runtime stack maintained activation records ars pushed procedure entry popped procedure exit global variable resides fixed offset memory local variable procedure reside fixed offset ars actual parameters pushed stack caller formal parameters reside fixed offsets ars program instructions occupy fixed area memory self-modifying separate program data executable conform model system create conform violations discovered error reports issued envision codesurfer providing tool security analysis general infrastructure additional analysis executables practice system produces error report choice made accommodate error analysis continue error optimistically treated false positive produced user determine error report false positive valid analyzer care program compiled high-level language hand-written assembly fact pieces program output compiler multiple compilers high-level languages hand-written assembly terms features high-level-language program permitted vsa capable recovering information programs global variables local variables pointers structures arrays heap-allocated storage pointer arithmetic abstract stores computed vsa augment call graph control-flow graphs on-the-fly account indirect jumps indirect calls indirect jumps recursive procedures indirect calls function pointers runtime code generation self-modifying code compiler optimizations make vsa difficult computation critical data resides registers memory register operations easily deciphered memory operations major assumption make idapro disassemble program build adequate collection preliminary irs cfg created idapro incomplete due indirect jumps call-graph created idapro incomplete due indirect calls incomplete irs trigger error reports cfg call-graph fleshed information recovered vsa fact relationship vsa preliminary irs created idapro similar relationship points-to-analysis algorithm compiler preliminary irs created compiler front end cases preliminary irs fleshed analysis abstract domain abstract stores vsa over-approximate sets concrete stores abstract stores based concepts memory-regions a-locs discussed memory-regions memory addresses executable x-bit machine x-bit numbers approach existing numeric static-analysis domain intervals congruences over-approximate set values including addresses data object hold problems approach addresses reused address refer program variables runtime variable runtime addresses addresses determined statically cases memory blocks allocated heap malloc address shared multiple ars distinguish addresses based procedure active time address generated local variable refer local variable vsa analysis-time analog assume address-space process consists non-overlapping regions called memory-regions executable set memory-regions consists region procedure region heap-allocation statement global region assume relative positions memory-regions region procedure represents instances procedure runtime-ar similarly region heap-allocation statement represents memory blocks allocated statement runtime global region represents uninitialized-data initialized-data sections program fig shows memory-regions program fig single procedure regions global data main analysis treats data objects local global heap fashion similar compilers arrange access variables local ars offset adopt notion part concrete semantics concrete memory address represented pair memory-region offset concrete semantics degree abstraction built explained abstract memory address track offsets numeric abstraction program fig address local variable array pair main global variable part global enter node procedure register esp points start enter node procedurepis considered statement initializes esp address call malloc program point considered statement assigns address malloc a-locs indirect addressing instructions involves registers sufficient track values registers registers loaded values memory analysis track approximation values memory locations hold memory operations treated conservatively lead imprecise data dependences call a-loc abstraction track over-approximation values memory locations a-loc roughly equivalent variable program a-loc abstraction based observation data layout program established generating executable compiler assembly-programmer decides place global variables local variables globals accessed direct operands executable similarly locals accessed indirect operands esp orebp base register constant offset examination direct indirect operands rough idea base addresses sizes program variables define a-loc set locations consecutive addresses offsets program fig direct operands a-locs mem addresses mem addresses esp ebp-based indirect operands esp esp esp operands accesses local variables ofmain entry tomain esp main difference esp entry main esp operands memory correspond offsets memory-region main rise a-locs var var var addition a-locs a-loc return address defined offset main note var corresponds source-code variable array contrast var var correspond disjoint segments array var corresponds var corresponds similarly a-loc heap-region addition a-locs registers considered a-locs offsets a-loc a-locs identified relative positions a-locs respective regions recorded offset a-loc region rgn denoted offset rgn program fig offset main var addresses a-loc addresses belong a-loc represented pair rgn offset offset size rgn represents memory region belongs offset offset a-loc region size size a-loc pair form represents set integers fxja program fig addresses a-loc var main size a-loc heap a-locs cases size abstract stores abstract store over-approximate set memory addresses a-loc holds program point memory address pair memory-region offset set memory addresses memory region rgn represented rgn ong offsets numbers represented over-approximated numeric abstract domain intervals congruences reduced interval congruence ric purpose reduced interval congruence reduced cardinal product interval domain congruence domain set numbers over-approximated ric ric represented -tuple tuple stands denotes set integers faz djz instance over-approximated tuple equals abstract store type a-loc memory-region ric conciseness abstract stores represent addresses a-loc memoryregions combined r-tuple rics number memory regions r-tuple referred value-set abstract store map a-locs value-sets a-loc ricr instance program fig statement eax holds addresses elements ofmain local array abstract store maps eax value-set chose rics context important analysis discover alignment stride information interpret indirect-addressing operations implement field-access operations array structs pointer-dereferencing operations contents a-loc aligned boundaries a-locs memory access fetch portions a-locs similarly write overwrite portions a-locs operations forge addresses instance suppose address a-loc address a-loc contents -byte fetch retrieve bytes byte issue motivated rics rics capable representing non-convex sets integers ranges suppose contents set -byte fetch retrieve range includes addresses -byte fetch result 
forged address vsa based rics represented ric vsa based range information rics track segments contents data objects treat dereferences conservatively returning losing track information value-sets form lattice operators defined value-sets operators pointwise applications ric operator returns true value-set subset false returns intersection meet value-sets allowed adjust returns union join value-sets rvs returns value-set obtained widening respect rvs returns value-set obtained adjusting values constant returns pair sets represents set fully accessed locs consists a-locs size starting addresses represents set partially accessed a-locs consists a-locs starting addresses size a-locs addresses starting addresses sizes meet conditions removelowerbounds returns value-set obtained setting lower bound component ric removelowerbounds removeupperbounds similar removelowerbounds sets upper bound component represent abstract store program point efficiently applicative dictionaries provide space-efficient representation collection dictionary values dictionary values contents dictionary values collection value-set analysis vsa section describes value-set analysis algorithm vsa abstract interpretation executable find safe approximation set values data object holds program point domain abstract stores defined present implementation vsa flow-sensitive context-insensitive vsa similarities pointer-analysis problem studied great detail programs written high-level languages variable pointer analysis determines over-approximation set variables addresses hold similarly vsa determines over-approximation set addresses data object hold program point results vsa find a-locs addresses a-loc hand vsa flavor numeric static analyses goal overapproximate integer values variable hold addition information addresses vsa determines over-approximation set integer values data object hold program point intraprocedural analysis subsection describes intraprocedural version vsa time programs single procedure indirect jumps aid explaining algorithm adopt c-like notation program statements discuss kinds instructions registers size explicit integer constants future plan extend implementation degree context-sensitivity call-strings approach interprocedural dataflow analysis label transfer function edge vsr vsr vsr tmp proc procedure statement jfj jpj proc recursive heap objects tmp vsr strong update weak update tmp vsr vsv vsv beforeg vsr vsr jpj vsrhs ffvsvjv vsv beforeg vsrhs vsr vsc vsr vsc vsr vsr vslb removeupperbounds vsr vsr vslb fig transfer functions vsa cases represents size dereference performed instruction conditions forms obtained predecessor conditional jump instructions affect condition codes analysis performed cfg procedure cfg consists node instruction edges labeled instruction source edge source edge conditional edge labeled outcome conditional instance edge labeled ecx edge labeled ecx cfg abstract store obtained program point abstract interpretation sample transformers kinds edges listed fig transformer takes abstract store returns abstract store region procedure called recursively heap region potentially represents concrete data object assignments a-locs modeled weak updates value-set unioned existing replacing case fig unaligned writes modify parts a-locs possibly create forged addresses case fig writes treated safely setting values partially modified a-locs similarly case treats load potentially forged address load abstract store entry node consists information initialized global variables initial stack pointer esp abstract domain infinite ascending chains ensure termination widening performed widening carried node cycle cfg node widening performed affect accuracy analysis choose widening points implementation vsa techniques program fig abstract store entry node main fesp mem mem fixpoint solution vsa instruction fesp mem mem eax ebx var ecx instruction fesp mem mem eax ebx var ecx edi note value-sets obtained analysis discover data dependence exists instructions instruction eax eax returns possibly-killed set fvar var ret maing similarly instruction esp returns set fvar reaching-definitions analysis based information reveals instruction data dependent instruction similarly reaching-definitions analysis reveals instruction data dependent note a-loc ret main included set a-locs accessed eax instruction analysis determine upper bound eax observe eax dependent loop variableecx discuss implemented system finds upper lower bounds variables dependent loop variable interprocedural analysis procedure calls ignore indirect jumps calls interprocedural analysis presents problems formals procedure actuals call identified information directly disassembly parameters typically passed stack architecture instructions push actual parameters stack occur immediately call explain interprocedural case fig shows program procedures main initarray fig procedure main integer array initialized calling initarray initialization main returns element array int part part void initarray int int size int part part int part part size part part part part part part return int main int array array initarray return array proc initarray lea eax esp mov ebx eax add ebx mov ecx mov edx mov eax edx mov edx mov ebx edx add eax add ebx ecx cmp ecx esp retn proc main esp lea eax esp mov esp eax push push eax call initarray add esp mov edi esp mov eax edi add esp retn program disassembly fig interprocedural actual parameters register saves program stack operations push pop implicitly modify locations procedure locations correspond actual parameters call register spilling caller-saved registers locations accessed push pop instructions explicitly found asesp ebprelative addresses algorithm identifies a-locs introduce locs memory locations accessed stack operations introduce additional a-locs call extended a-locs memory locations implicitly accessed stack operations smallest delta determined represents maximum limit stack grow single invocation ofp stack grow deeper due calls made operations relevant concerned identifying size unable find finite minimum analysis issues report finite minimum extended a-locs added -byte boundaries fill space lowest local a-loc minimum delta ret initarray arg arg initarray initarray initarray initarray main main main main main main main var ext ret main var var ext global global global mem mem fig memory-regions formal parameters entry procedure esp points return address parameters procedure bytes return address positive direction offsets formal parameters positive locs positive offsets considered formal parameters call procedure formals extended a-locs represent actual parameters fig shows extended a-locs procedure main formal parameters procedure initarray program handling calls returns interprocedural algorithm similar intraprocedural algorithm analyzes supergraph executable supergraph call site nodes call node end-call node successor call node entry node called procedure predecessor endcall node exit node procedure called call node call entry exit end-call edges refereed linkage edges nodes edges edge-transformers instructions similar intraprocedural cfg transformer call entry edge assigns actuals formals esp reflect change current join abstract stores call-sites computed value-set esp newly computed set occurs slot addition formal parameter formali initialized asc esp offset formali asenter formali callsites callsites asc asc abstract store call-site size formali value-set formal entry join value-sets actuals callers offset actual caller determined offset formal parameter fixpoint solution abstract store enter node initarray fmem mem 
arg arg eax esp ext ext regions value-sets listed order global main initarray transformer exit end-call edge ordinarily restores value-set esp call corresponds normal case callee restores esp call procedures callee restore esp instance alloca allocates memory stack subtracting number bytes esp vsa takes care esp additions subtractions initial determine change constant amount cases esp restored call minus change vsa determine change constant issues error report affine relations recall vsa unable find finite upper bounds foreaxat instruction ebx instruction ret main added possiblykilled sets instructions section describes implementation vsa obtains improved results identifying exploiting integer affine relations hold program registers interprocedural algorithm affine-relation analysis due uller-olm seidl algorithm determine program point affine relations hold registers details algorithm found integer affine relation variables relationship form pni airi integer constants affine relation represented -tuple opportunities incorporating information affine relations interpretation conditional instructions improved widening operation implementation vsa incorporates affine relations instruction program fig eax esp andecxare related affine relation eax esp ecx true branch conditional interpreted ecx bounded upper end value-set ecx value-set rics global region represents set pure numbers set global addresses addition value-set esp value-sets solving eax relation yields eax sharper foreaxat obtained bounds obtained loops controlled condtion based indices analysis safe cases halbwachs introduced widening-up-to operator called limited widening attempts prevent widening operations over-widening abstract store perform limited widening associate set inequalities widening location polyhedral analysis defined prmq standard widening operation prq inequalities satisfy proposed set determined linear relations force control remain loop implementation vsa incorporates limited-widening algorithm adapted reduced interval congruences instance suppose ordinary widening produce limited widening produce cases a-loc vsa perform limited widening register register controls execution loop cases implementation limited widening results affine-relation analysis constraints register values determine constraints hold instance loop back-edge label affine-relation analysis determined holds point constraint limited widening abstract store performance evaluation version affine-relation analysis models restoration callee-save registers calls present technical difficulties preclude similar treatment caller-save registers implemented check determine code obeys calling conventions caller-save callee-save registers indirect jumps indirect calls supergraph program complete presence indirect jumps indirect calls missing jump call edges inserted vsa instance suppose vsa interpreting indirect jump instruction jmp eax current abstract store instruction feax edges added instructions addresses memory locations addresses refer read-only section program addresses successors read header executable addresses successors locations determined current abstract store due imprecision vsa case vsa reports locationsf ghave addresses cases vsa proceeds adding edges lead under-approximation value-sets program points analysis issues report user decisions made refer instructions unsafe instructions issue results vsa address identified successor start instruction addresses situation reported user indirect calls handled similarly additional complications successor instruction identified method outlined middle procedure cases analysis reports user successor instruction part procedure identified idapro due limitations idapro procedure-finding algorithm idapro identify procedures called exclusively indirect calls cases vsa invoke idapro procedure-finding algorithm explicitly force sequence bytes executable decoded sequence instructions spliced program present technique incorporated implementation performance evaluation table shows running times storage requirements prototype implementation analyzing set win linux programs program version shown parentheses temporary expedient calls library functions treated analysis identity transformers analyses performed pentiumwith clock speed ghz equipped physical memory running windows per-process address space limited program procedures instructions mallocsites indirectjumps calls indirectcalls memory usage valueset analysis sec affinerelation analysis sec javac cat cut grep gcc tar awk winhlp table running times storage requirements vsa affine-relation analysis contrast capabilities vsa analysis algorithms treat memory accesses conservatively register assigned memory assumed compared version vsa called crude vsa sets value-sets non-register a-locs table shows number flow-dependence edges obtained methods vsa dependences missed vsa iii crude vsa soundness issues program vsa vsa crude vsa javac cat cut grep gcc tar table comparison variants vsa soundness value-set analysis identify killed possibly-killed sets miss data dependence spurious dependences reported lofty goal clear tool achieves goal practical lofty goals meet standard result practical system care system sound long provide warnings situations arise analysis threaten soundness results path work cases analysis unsound system generates report nature unsoundness program vulnerable buffer-overrun attack detected identifying point write past end memory-region control-flow graph call-graph identify successors indirect jumps indirect calls report generation cases discussed related situation jump code sequence concealed regular instruction stream alternative code sequence decode legal code sequence read out-of-registration instructions concealed analysis detect situation anomalous jump address code segment start instruction self-modifying code control-flow graph call-graph analysis analysis detect possibility program selfmodifying identifying anomalous jump call modifiable location related work extensive body work analyzing executables work closely related vsa alias-analysis algorithm executables proposed debray basic goal algorithm similar vsa find over-approximation set values register hold program point find over-approximation set values abstract data object hold program point data objects include memory locations addition registers analysis set addresses approximated set congruence values track low-order bits addresses unlike algorithm algorithm make effort track values registers lose great deal precision load memory cifuentes fraboulet give algorithm identify intraprocedural slice executable program use-def chains algorithm makes attempt track values registers cuts short slice load memory encountered past work decompiling assembly code high-level language related goals work address problem recovering information memory accesses idea inferring layout program data structures based access patterns program similar idea aggregate structure identification asi algorithm ramalingam asi applied code results vsa hand asi requires points-to range stride information information executable vsa good news asi applied vsa refine program a-locs clients value-set analysis dependence analysis compute precise results plan asi conjunction results value-set analysis future work created system analyzed executables absence symbol-table debugging information goal system establish memory-safety properties held sparc executables initial inputs untrusted program annotated typestate information linear constraints analyses developed based classical theorem-proving techniques typestate-checking algorithm induction-iteration method synthesize loop invariants omega decide presburger formulas contrast goal system present paper recover information executable permits creation intermediate representations similar created program written high-level language vsa abstract-interpretation techniques determine killed possibly-killed sets instruction program people developed techniques analyze executables presence additional information source code symbol-table information debugging information analysis techniques assume access information limited fact relied dealing programs viruses worms mobile code information present dor present static-analysis technique implemented programs written aim 
identify string-manipulation errors potential buffer overruns work flow-insensitive pointer analysis detect pointers base address integer analysis detect relative-offset relationships values pointer variables original program translated integer program tracks string integer manipulations original program integer program analyzed determine relationships integer variables reflect relative-offset relationships values pointer variables original program primarily interested establishing pointer bounds buffer sufficient linear-relation analysis abstract stores convex polyhedra defined linear inequalities form pni aixi integers integer variables work interested discovering fine-grained information structure memory-regions discussed important analysis discover alignment stride information interpret indirectaddressing operations implement field-access operations array structs pointer-dereferencing operations represent non-convex sets numbers linear-relation analysis xfor reason numeric component vsa based reduced interval congruences capable representing non-convex sets integers rugina rinard combination pointer numeric analysis determine information program memory accesses reasons algorithm suitable problem face analysis assumes program local global variables analysis begins set allocation blocks information acquired consists program local global variables dynamic-allocation sites analysis determines range information determine alignment stride information iii pointer numeric analysis performed separately pointer analysis performed numeric analysis obvious pointer analysis intertwined numeric analysis analysis combines pointer analysis numeric analysis analyses rugina rinard dor separate phases pointer analysis numeric analysis advantage combining analyses information numeric values lead improved tracking pointers pointer information lead improved tracking numeric values context kind positive interaction important discovering alignment stride information additional benefits accrue clients vsa instance happen extra precision vsa identify strong update weak update update treated kill kill case fig advantages combining pointer analysis numeric analysis studied context combining analysis improves precision context combined analysis needed ensure safety bergeron debbabi desharnais erhioui lavoie tawbi static detection malicious code executable programs int req eng bergeron debbabi erhioui ktari static analysis binary code isolate malicious behaviors wetice pages bourdoncle efficient chaotic iteration strategies widenings int conf formal methods prog appl lec notes comp sci springer-verlag cifuentes fraboulet interprocedural data flow recovery high-level language code assembly technical report univ queensland cifuentes fraboulet intraprocedural static slicing binary executables int conf softw maint pages cifuentes simon fraboulet assembly high-level language translation int conf softw maint pages codesurfer grammatech http grammatech products codesurfer cousot cousot static determination dynamic properties programs proc int symp programming pages dunod paris france cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixpoints princ prog lang cousot cousot automatic discovery linear restraints variables program princ prog lang pages debray muth weippert alias analysis executable code princ prog lang pages dor rodeh sagiv cssv realistic tool statically detecting buffer overflows prog lang design impl pages fast library identification recognition technology datarescue ege belgium http datarescue idabase flirt htm granger static analysis arithmetic congruences int comp math halbwachs proy roumanoff verification real-time systems linear relation analysis formal methods system design horwitz reps binkley interprocedural slicing dependence graphs trans prog lang syst january idapro disassembler http datarescue idabase larus schnarr eel machine-independent executable editing prog lang design impl pages uller-olm seidl precise interprocedural analysis linear algebra princ prog lang mycroft type-based decompilation european symp programming myers efficient applicative data types princ prog lang pages pioli hind combining interprocedural pointer analysis conditional constant propagation tech rep ibm watson research center march pugh omega test fast practical integer programming algorithm dependence analysis supercomputing pages ramalingam field tip aggregate structure identification application program analysis princ prog lang pages reps rosay precise interprocedural chopping found softw eng reps teitelbaum demers incremental context-dependent analysis language-based editors trans prog lang syst july rival abstract interpretation based certification assembly code int conf verif model checking abs int rugina rinard symbolic bounds analysis pointers array indices accessed memory regions york acm press sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs suzuki ishihata implementation array bound checker princ prog lang pages miller reps safety checking machine code prog lang design impl pages 
numeric domains summarized dimensions denis gopan frank dimaio nurit dor thomas reps mooly sagiv comp sci dept wisconsin fgopan dimaio repsg wisc school comp sci tel-aviv fnurr msagivg post tau abstract introduce systematic approach designing summarizing abstract numeric domains existing numeric domains summarizing domains summary dimensions represent potentially unbounded collections numeric objects domains benefit analyses verify properties systems unbounded number numeric objects shape analysis systems number numeric objects bounded large introduction verifying correctness complex software systems requires reasoning numeric quantities analysis technique discover relationships values numeric objects numeric variables numeric array elements numeric-valued fields heap-allocated structures verify buffer overruns program analysis make index variable exceed length buffer program point buffer accessed numeric analyses research topic decades number numeric domains approximate numeric state system designed years domains exhibit varying precision cost tradeoffs target types numeric properties list existing numeric domains includes non-relational domains intervals congruences weakly relational domains difference constraints octagons relational domains polyhedra trapezoidal congruences existing numeric domains track fixed number numeric objects traditionaly finite set stack-allocated numeric variables deemed important property verified identified analysis remaining numeric objects numeric array elements heap-allocated numeric objects modeled conservatively problems plague existing numeric domains impossible verify numeric properties fixed number numeric objects system programs collections general dynamic memory allocation impossible determine statically set memory locations program resources required higher-precision relational numeric domains polyhedra subject combinatorial explosion due representation elements numeric domain instance number elements frame representation polyhedron grows exponentially number tracked objects typical approach reasoning unbounded number objects simply large number objects employing abstraction set objects divided fixed number groups based criteria group represented summarized single abstract object groups bounded size tvla framework shape analysis nnz nnz nnz fig multiplication sparse matrix vector multiplication code initial constraints imposed csr format constraints represent abstract numeric state line concerns problem determining shape invariants programs perform destructive updating dynamically allocated storage tvla so-called canonical abstraction create bounded-size representations memory states reason numeric properties summarizing framework analysis capture relationships values groups numeric objects relationships values individual numeric objects appears natural applying existing techniques fact unsound paper define systematic approach extending existing numeric domains relational approach interprocedural shape analysis bertrand jeanneta alexey loginova thomas repsa mooly sagiva irisa bertrand jeannet irisa comp sci dept wisconsin alexey reps wisc school comp sci tel aviv msagiv post tau abstract paper addresses verification properties imperative programs recursive procedure calls heap-allocated storage destructive updating pointer-valued fields interprocedural shape analysis presents harness previously approaches interprocedural dataflow analysis past work applied rich settings interprocedural shape analysis introduction paper concerns techniques static analysis recursive programs manipulate heap-allocated storage perform destructive updating pointer-valued fields goal recover shape descriptors provide information characteristics data structures program pointer variables point information programmers understand aspects program behavior verify properties program optimize parallelize program work reported paper builds past work authors static analysis based -valued logic implementation tvla system setting related logics play ordinary -valued logic related -valued logic memory configuration store modeled logicians call logical structure consists predicate relation arity predicate symbol vocabulary store modeled -valued logical structure set stores abstracted finite set bounded-size -valued logical structures individual -valued structure universe models single memory cell case summary individual collection memory cells constraint working limited-size descriptors entails loss information store properties concrete individuals lost due abstraction groups multiple individuals summary individuals property true concrete individuals group false individuals reason -valued logic uncertainty property captured means truth opportunities scaling approach exploit compositional structure programs interprocedural dataflow analysis avenue accomplishing create summary transformer procedure summary transformer call site called summary transformer capture over-approximation net effect call create summary transformers abstract transformers individual transitions composable representation representations abstract transformers represent composition object roughly size carries fixed-point-finding procedure collection equations variable equation set transformer-valued drawn domain transformers dataflow proper number approaches interprocedural dataflow analysis based summary transformers program-analysis problems abstract transformers composable representation problems address issue working pointwise tabulating composed transformers sets pairs input output values interprocedural shape analysis approach fails produce information -valued-logic approach shape analysis storeless individuals model memory cells fixed identities identified distinguishing characteristics values specific set unary predicates distinguishing characteristics change procedure call identify individuals input abstract structure individuals output abstract structure essence pair input output -valued structures loses track correlations input output values individual unary predicates approach based tabulating composed transformers sets pairs -valued structures promising representation weak characterization procedure net effect lost abstracting pairing discussed solution pair abstract observation -valued structures doubled vocabulary denotes disjoint union obtains finite abstraction relates predicate values individual beginning transition predicate values individual end transition abstraction create accurate composable representations transformers accurate summary transformers broad class problems extending abstract domain -valued logical structures operations perform abstract interpretation call return statements losing precision ideas create context-sensitive shape-analysis algorithm recursive programs manipulate heap-allocated storage perform destructive updating context-sensitive interprocedural shape analysis studied major difference augments store include runtime stack explicit data structure idea proposed storage abstraction abstraction store augmented fashion contrast work stack materialized explicit data structure approach based creation summary transformers style contributions work include method create summary transformer procedure call site called analysis obtains general information obtained result analysis exit node procedure approximation reachable memory configurations arise paper result approximation relation input memory configurations start node configurations restricted memory configurations reachable nature information obtained analysis verify reversing list restores original list method show yields list head set memory cells order apply method successfully richer set programs studied perform interprocedural analysis recursive list-manipulation support arbitrary summarization domain extended support extra operations expand fold add drop disccused detail sections extended numeric domain exposes standard numeric-domain interface purposes paper assume client analysis responsibility indicating abstract objects summary extreme analysis summarization extended domain operates original domain presence summarization extended domain produces safe answers minimal loss precision program fig multiplies sparse matrix stored compressed sparse row csr format vector size csr format sparse matrix represented arrays array size nnz stores matrix elements row row nnz number non-zero elements matrix array size nnz stores column indices elements csr format imposes constraint element array array size stores offsets beginning row arrays csr format imposes constraint nnz element array note matrix properly represented csr format array acceses line shown bold bounds existing analyses verify property array indices computed indirection arrays summarizing extension polyhedral numeric domain verify array accesses line bounds constraints imposed csr format hold initially summary dimensions represent elements arrays summarization allowed represent abstract numeric states program -dimensional polyhedra directly constraints shown fig values indices line bounds arrays contributions paper makes extended numeric domains constructed technique support arbitrary summarization makes suitable wide range client analyses hand analysis simple summarizing values elements array hand involved canonical abstraction summarization multiple dynamically changing segments array summarized separately sect requirements place numeric domain extended minimal safe implementation operations provided flexibility numeric domain suitable problem employed client analysis coupled suitable client tvla extended numeric domains operate unbounded collections numeric objects large fixed-size collections numeric objects extended numeric domains trading precision analysis efficiency terms memory usage running time illustrated natural approach performing operations values extended numeric domain unsound formalization sound approach major technical contribution paper remainder paper organized sect discusses concrete semantics sect introduces concept reducing dimensionality summarization sect describes involved extending standard numeric domain long meets assumptions primitive operations sect describes perform safe computations values extended numeric domains sect discusses related work sect sketches application technique situation multiple dynamically changing segments array summarized separately concrete semantics goal perform static analysis systems number numeric objects change system operates bounded statically concrete numeric state system denoted assignment numeric object state number numeric objects finite denoted clear context denote set objects state objs vng traditional numeric analysis approach associate numeric object dimension n-dimensional space encode concrete numeric state system n-dimensional point function dims objs ngto map numeric objects dimensions denote set numeric values number numeric objects number dimensions bounded priori concrete numeric state point space arbitrary finite dimension expression objs evaluate concrete numeric state denote i-th component vector define dims dims program point attach set concrete states define program concrete collecting semantics transformers numeric tests filter set concrete states true assignments change single numeric object concrete state obj objs dim dims dims dims union collects sets control flow merge points determining exact sets concrete states program point general undecidable goal static analysis collect program point overapproximation set concrete states arise framework abstract interpretation formalize analyses existing numeric analyses identify overapproximations sets concrete states arise program points set representation easily stored manipulated computer spaces called numeric domains assumption existing numeric domains make number numeric objects fixed analysis allowing sets concrete states represented subsets space fixed number dimensions semantics formulated concrete numeric states arising program point belong spaces possibly numbers dimensions existing numeric domains directly section show set points spaces dimensionalities abstracted subset space fixed smaller number dimensions summarizing numeric domains section introduce numeric domain subset space fixed number dimensions overapproximate set points spaces dimensionalities idea abstraction dimensions fixeddimensional space represent values potentially unbounded collections numeric objects values individual objects numeric domain differentiate individual objects members collections preserves properties collection lower upper bounds values members call process grouping numeric objects collection summarization paper sake simplifying presentation assume client analysis summarizing numeric domains responsible defining fig abstraction concrete numeric state abstraction fsum fsum numeric objects summarized collections formed simplest case illustrated introduction elements array summarized single dimension ultimately goal implement complicated summarizations including canonical abstraction parts array summarized summarization partition array elements change analysis 
sect combining client analysis canonical abstraction summarizing numeric domain formally assume concrete numeric objects separated groups determined client analysis groups numeric object set objects priori unbounded size abstract numeric state group represented abstract numeric object denote set abstract numeric objects objs umg abstract objects represent groups element called summary objects describing justifying techniques refer conceptual mappings map numeric objects concrete state numeric objects abstract state mapping called summarization function fsum objs objs summarizing abstract numeric domain represents abstract numeric state subset m-dimensional space dimension corresponds abstract numeric object function dims objs maps abstract object dimension abstraction concrete numeric state m-dimensional subset constructed folding summarized dimensions illustrated fig summarization function defined fsum abstraction note abstraction loses distinction values summarized numeric objects summarization function abstraction concrete states concrete numeric state abstraction point constructed taking orthogonal projection dims dims dims objs objs fsum denote set projections fsum shown fig summarization function set fsum projections projects dimensions projects dimensions projects dimensions formally summarization function fsum abstract state represents concrete state denoted vfsum iff fsum fsum important discussion omit notation write easy abstract states form infinite-height lattice ordered set inclusion bottom element empty set join meet operations correspond set union set intersection set concrete states abstract state abstracts element existing numeric domains store manipulate m-dimensional subsets correspond abstract states numeric domains impose restrictions subsets represent impossible represent abstract numeric state precisely cases overapproximation abstract state represented abstract state represented polyhedron directly approximated polyhedron sets conceptually sets occur existing numeric domain extend semantics existing numeric domain order compute safely abstract states extended numeric domain section describe operations numeric domain support abstraction technique extending numeric domains pointed introduction number numeric domains designed undoubtedly proposed future domains target numeric properties exhibit precision cost tradeoffs common compact representation subset multidimensional space define number operations client analysis evaluate kinds numeric conditions transform underlying subset semantics program statement assumption existing numeric domains make point represented subset corresponds concrete numeric state system vice versa assumption relied proving correctness implementations operations transforming set evaluating conditions contrast abstraction concrete state corresponds collection points subset represented numeric domain individual point represented subset belong abstraction multiple concrete states provide sound evaluation conditions set transformations induced program statements numeric domain extended extra operations map subsets spaces dimensionality section give detailed description operations show implemented existing numeric domains standard semantics numeric domain define standard interface numeric domain operations numeric domain exposes abstract state transformers manipulate subsets dimensional space mentioned semantics state transformers defined assumption concrete numeric state corresponds single point abstract state vice versa denote i-th dimension formula dng denote numeric condition numeric computation notation denote standard numeric domain operations numeric tests std assignments std join tstd widening operator ostd detailed definitions abstract state transformers found papers operations defined insert remove arbitrary dimensions multidimensional space operation dimensions indices inserted removed dimension renumbered simplify presentation avoiding recomputation dimension indices operation definitions introduce function maps dimensions original space dimensions resulting space j-th dimension removed operations fold drop similarly introduce dimension mapping inserting dimension operations expand add undefined fold operation fold operation formalizes concept folding dimensions foldi transforms subset programs method paper capable handling programs manipulate binary trees list-manipulation programs implemented tail-recursive fashion converted easily loop programs tree-manipulation programs easily converted non-recursive form remainder paper organized describes features language analysis applies reviews abstract domain -valued logical structures describes abstractions logical structures doubled vocabulary create summary transformers perform interprocedural analysis discusses experimental results discusses related work programs memory configurations typedef struct node struct node int data list list res void main list res rev list rev list list null null rev return fig recursive list-reversal program analysis applies programs written imperative programming language forbidden address local variable global variable parameter parameters passed features prevent direct aliasing variables heap-allocated structures aliased java follow conventions running paper listreversal program fig program syntax smain srev erev call rev return site call rev symbolic return site null implementation emain transformer thomas repsa mooly sagiva greta yorsha comp null sci dept wisconsin reps wisc school comp sci tel-aviv msagiv gretay post tau abstract paper shows ret achieve rev conditions fig interprocedural abstract-interpretation cfg algorithms enjoy precision abstraction key idea simple process successive approximation makes repeated calls decision procedure obtains abstract set concrete stores represented symbolically listreversal program logical program formula introduction defined abstract set interpretation procedures well-established technique automatically proving program properties procedure abstract set interpretation sets local program variables stores represented number conservative formal manner input abstract parameters values output program statement parameters simplify interpretation notation abstract assume values conservative procedure respect input interpretation resp output sets parameter concrete stores local variable result generalization executing multiple statement parameters local variables abstract straightforward describes superset assume concrete input stores parameter arise modified methodology guarantees execution results abstract procedure interpretation overapproximate assumption sets made concrete solely stores convenience arise involves point loss program generality shown copy input parameters reasonable conditions additional local give variables specification procedure most-precise abstract interpretation abstract domain galois connection defined abstraction function concretization function abstract post operator transition denoted expressed terms concrete post operator defines limit precision obtainable abstraction eqn non-constructive provide algorithm finding applying graf showed decision procedures generate abstract defined transformers abstract input domains parameter fixed finite cartesian output parameter products boolean values local variable domains predicate abstraction predicate abstraction intraprocedural control slam flow graph systems cfg work program presented represented paper shows directed graph benefits enjoyed applications predicate-abstraction called approach interprocedural enjoyed cfg applications consists abstract domains collection intraprocedural predicate-abstraction cfgs domains paper results apply arbitrary finite-height abstract domains main cartesian represents products program booleans main procedure applies cfg abstract domains constant start propagation node common-subexpression elimination exit applied node predicate-abstraction domain nodes method cfg represent worst-case individual complexity statements graf-sa branches method procedure understand usual difficulties lie procedure call addressed represented predicate nodes abstraction call node general return-site node proca denotes index procedure addition ordinary intraprocedural edges connect nodes individual flowgraphs procedure call represented call-node return-site node edges call-to-start edge start node called procedure exit-to-return-site edge exit node called procedure functions call ret record matching call return-site nodes calla ret assume start node incoming edges call-to-start edges representing memory configurations logical structures predicate intended meaning denote memory cell pointer variable point memory cell n-field point data-field data-field table core predicates representing stores manipulated programs typelist write predicate names italics code typewriter font static-analysis framework defined concrete memory configurations stores modeled logical structures logical structure vocabulary predicate symbols arities finite set predicate symbols denotes set predicate symbols arity logical structure supplies predicate vocabulary predicate symbols concrete store modeled -valued logical structure fixed vocabulary core predicates core predicates part underlying semantics language analyzed record atomic properties stores instance tab lists predicates represent stores manipulated programs type list fig store shown fig -valued logical structures represent memory configurations individuals set memory cells nullary predicate represents boolean variable program unary predicate represents pointer variable boolean-valued field record binary predicate represents pointer field record null fig store consisting four-node linked list pointed -valued structure shown left-hand side fig encodes store fig individuals represent list cells alternatively nodes represent basic blocks simplify matters examples involve modeling numeric-valued variables numeric-valued fields data introducing predicates 
binary predicate stands data less-than-or-equal-to listed tab captures relative order nodes data values alternatively numericvalued entities handled combining abstractions logical structures previously techniques creating numeric abstractions graphical notation depicting -valued structures individual represented circle inside unary predicatea represented solid arrow froma individual absence -arrow individual whicha predicate individuals shown binary predicate represented solid arrow labeled pair individuals absence -arrow pairs structure pointer variables point individual n-field points individual pointer variable point individual unary preds binary preds indiv gfed abca gfed abca gfed abca gfed abca abstractsto unary preds binary preds indiv onmlhijkgfed abca fig abstraction -valued structure -valued structure -abstraction restricted class logical structures encode stores exclude structures represent admissible stores integrity constraints imposed instance predicate fig captures pointer variable points memory cell attribute unique imposes integrity constraint hold individual structure concrete operational semantics programming language defined structure transformer kind edge control-flow graph formally structure transformer edge defined collection predicate-update formulas core predicate formulas define core predicates logical structure arises source transformed create logical structure target define predicate function edge optionally precondition formula filters structures follow transition fig edges labeled statements conditions programming language collections predicate-update formulas set -valued structures vocabulary denoted abstract domain -valued logical structures create abstractions -valued logical structures stores encode related class -valued logical structures vocabulary -valued logical structures truth denoted introduced denote uncertainty -valued logical structure predicate tuple individuals allowed set -valued structures vocabulary denoted drop clear context definition truth values definite values indefinite information order defined iff symbol denotes least-upper-bound operation respect abstract stores program analysis -valued logical structures construction discussed priori bounded size general -valued logical structure corresponds possibly infinite set -valued logical structures members families structures related canonical abstraction principle canonical abstraction illustrated fig shows -valued structure abstracted -valued structure abstraction function determined subset unary predicates predicates called abstraction predicates act applying abstraction function called -abstraction canonical abstraction illustrated fig -abstraction abstraction driven values vector abstraction predicates individual values equivalence classes formed individuals vector values abstraction predicates equivalence classes boxes table unary predicates show individuals semantics grouped procedure local equivalence heaps classes members abstractions equivalence noam class mapped rinetzky individual bauer thomas -valued structure reps mooly members sagiv reinhard wilhelm tel aviv univ univ mapped des saarlandes individual univ called wisconsin tel similarly aviv members univ univ des saarlandes tel mapped aviv israel individual saarbr called ucken germany madison non-abstraction usa predicate tel aviv -valued israel structure saarbr ucken germany predicatea maon tau joba uni-sb reps wisc msagiv tau wilhelm uni-sb abstract goal -valued structure work formed develop truth-blurring compile-time quotient algorithms tuple automatically verifying properties join imperative programs tuples manipulate dynamically equivalence relation allocated individuals storage maps paper presents instance analysis method characterization equals procedure behavior parts heap relevant procedure paper main parts part equal introduces non-standard concrete semantics lsl called procedures passed parts heap semantics objects equal treated specially separate equals local heap mutated procedure rest heap viewpoint procedure non-accessible equal immutable part concerns abstract interpretation lsl develops static-analysis algorithm canonical abstraction categories subject descriptors programming languages formal definitions theory semantics logics meanings programs verifying reasoning programs assertions invariants semantics programming languages operational semantics program analysis general terms languages theory verification keywords abstract interpretation shape analysis static analysis -valued logic supported part grant israeli academy science supported german research council dfg part transregional collaborative research center automatic verification analysis equal complex systems sfb avacs avacs information supported office naval research contract permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation fig page boxes copy tables republish predicates post servers redistribute lists groupings requires prior -valued specific structure permission fee predicate popl represents equality january relation long beach individuals california usa general copyright canonical acm abstraction individuals lose introduction identity long-time uncertainty research goal arises work develop predicate compiletime instance algorithms automatically verifying properties imperative programs manipulate represents dynamically single allocated storage goal individual verify properties hand absence represents null dereferences individuals absence memory quotient leaks operation preservation data-structure invariants ability reason effects procedure calls individual crucial element called program summary verification program individual analysis -valued logical program structure abstract descriptor set optimization paper -valued presents logical structures approach general modular summary analysis individual imperative models languages set procedures individuals dynamically allocated names storage individuals based completely abstract arbitrary interpretation distinguishes non-standard storeless semantics vector store-based abstraction storeless predicates semantics straightforward -valued logical structures semantics programs represents dynamically graphical allocated notation objects pointers -valued logical store-based structures structure operational semantics semantics natural fig closely derived corresponds concepts machine architecture compute effect procedure large heap effect subheaps semantic basis hearn frame rule assertions disjoint parts heap -valued post condition structures procedure call additions inferred individuals combining assertions hold represented call characterize circles effect procedure call programming languages java addresses explicitly contrast cast statements names represent states abstract fig heaps discussed isomorphic reachable parts indistinguishable garbage cells significance leads place non-a notion -valued unary storeless semantics pioneered states represented aliases pointer access paths step heap-abstractions abstract specific memory addresses storeless concrete semantics step relieves designer abstraction natural base powerful pointer shape analysis algorithms storeless semantics existing storeless semantics associate entire heap procedure invocation class instantiation makes difficult support procedure data abstraction predicates problem storeless correspond semantics pointervalued program hard variables relate inside properties circles memory cells summary individual represented call double result circle hard unary scale binary predicates methods prove properties real-life represented programs dotted arrows scaling concrete cost structure issues represented precision abstract structure procedure call fig pointer information variables calling point context concrete lost node paper present represents step n-field addressing node point aforementioned scaling issues concrete nodes developing storeless represents semantics representation parts summary heap individual relating properties represent call concrete node presenting possibly abstraction n-field concrete nodes points concrete nodes represents ann-field concrete nodes points concrete node represents note -valued structure represents acyclic lists length pointed cyclic lists length pointed backpointer head list element additional memory configurations cyclic acyclic list pointed garbage cells reachable finite representation infinite set possibly cyclic concrete lists accompanied unreachable cells section discuss options fine-tuning abstraction instance canonical abstraction define abstractions acyclic lists cyclic lists mapped -valued structures presence absence unreachable cells readily apparent canonical abstraction ensures -valued structure priori bounded size guarantees fixed-point reached iterative staticanalysis algorithm advantage -valued logic basis static analysis language extracting information concrete world abstract world identical syntactic expression logical formula interpreted -valued world -valued world consistency -valued -valued viewpoints ensured basic theorem relates logics eliminates user write usual proofs required abstract interpretation demonstrate abstract descriptors analyzer manipulates correctly model actual heap-allocated data structures program manipulates single meta-theorem embedding theorem theorem shows information extracted -valued structure evaluating formula sound respect -valued structures represents abstract semantics falls automatically specification concrete semantics provided formulas first-order formulas transitive closure formula vocabulary defined stands reflexive transitive closure formulasa variables case abstract interpretation employed formulas define concrete semantics interpreted -valued logic define sound abstract semantics interpreted -valued logic soundness instantiations analysis framework ensured embedding theorem instrumentation predicates care design analysis danger abstract interpretation proceeds indefinite pervasive destroy ability recover interesting information -valued structures collected soundness maintained key role combating indefiniteness played instrumentation predicates record auxiliary information logical structure provide mechanism user fine-tune abstraction instrumentation predicate arity defined logical formula core predicate symbols captures property -tuple nodes possess general adding additional instrumentation predicates refines abstraction defining precise analysis prepared track finer distinctions stores properties program stores identified analysis folding dimension dimension arbitrary subset foldi defined foldi reachable n-fields multiple dimensions folded construct transformation reachable composing pointer variable fold operations n-fields note fold operation defined closed existing numeric domains two-dimensional polyhedron directed cycle fold n-fields table defining formulas commonly instrumentation predicates typically separate predicate gis symbol polyhedron domains define pointer-valued foldi variable std introduction overapproximation unary instrumentation set foldi predicates representable abstraction domain predicates polyhedral domain fold std control concrete expand individuals operation merged expand operation essentially summary nodes opposite fold control operation amount information lost expandi transforms abstraction subset creating exact copy i-th dimension inserting dimension semantics arbitrary subset expandi operation defined expandi instance sect expand main equal results paper develop method characterize procedure behavior complex expansions constructed ignores parts composing expandi heap operations relevant note procedure expandi constructs end maximal paper subset introduces nonstandard foldi storeless concrete fact semantics fold lsl expand form localized-heap galois store-less insertion expandi semantics foldi called procedure foldi passed expandi part unlike heap fold based expand semantics operation closed static-analysis algorithm existing developed numeric domains experimented canonical abstraction closed prove properties numeric programs domain conviction based automatically verified fact values modular i-th treatment dimension heap implementation original subset abstractions scale precisely represented larger code numeric bases domain approach values insights newly introduced deutsch j-th dimension may-analysis algorithm precisely paper represented main domain parts add drop part operations sec add concerns lsl drop non-standard auxiliary concrete operations storeless add semantics dimensions remove part dimensions sec concerns multidimensional space abstract-interpretation addj embeds semantics inserting lsl dimension based addj ideas objects heap reachable dropj actual parameter computes treated projection differently removing separate dimension local heap dropj accessed procedure rest addj operation heap closed numeric domains viewpoint implemented procedure precisely non-accessible dropj immutable operation call closed objects numeric cutpoints domains object belongs experimented local-heap reachable design precise implementations procedure dropj actual std parameters domains object cutpoint sake minimality reached arguments pointer-access sect path assume numeric domain extended furnish precise implementation drop operation implementation examples section show result instrumentation starts predicates involve variable reachability properties pending call defined traverse transitive closure local-heap play procedure crucial returns role cutpoints definitions update abstractions caller instance local-heap program-analysis applications effect reachability call properties specific goal pointer variables perform static effect analysis keeping lsl disjoint storeless sublists subtrees semantics summarized dynamically separately allocated object represented important set analyzing access program paths reach pointers advanced unreachable disjoint objects sublists tab represented lists lsl instrumentation predicates previous storeless important semantics based analysis pointer-access programs paths type list standpoint represent access concrete paths semantics start instrumentation predicates variables represent pending cached calls information local state current procedure recomputed means reevaluating procedure instrumentation local predicate view defining formula includes objects current store reachable standpoint procedure parameters abstract semantics addition reevaluating objects formula allocates current characterize -valued manner store lead lsl simulates drastic standard loss store-based precision semantics gain maximum identify benefit class observations instrumentation predicates lsl abstract-interpretation equivalent algorithm standard obtain store-based values semantics prove problem properties ranging problem absence solved runtime errors incremental partial computation total correctness instrumentation respect predicate standard store-based semantics transition abstract part state paper transformer lsl state starting point computed static-analysis incrementally algorithms treat heap local modular previous work part paper algorithm present interprocedural shape-analysis defining algorithm formula programs manipulate dynamically allocated storage algorithm based abstraction generate lsl incremental algorithm predicate-maintenance formula prove fora properties presented programs problem automatically automatically verified identifying destructive instrumentation merge predicates singly-linked process lists abstraction refinement recursive addressed procedure fig paper input analysis required program analysis consists scale program analysis characterization benefits inputs fact iii heap query localized formula behavior characterizes procedure intended depends output contents local-heap work analysis results framework reused eliminating previously contexts required outline user inputs remainder tvla paper organized criticized past sec sets scene abstractionrefinement defining mechanism ealgol simple imperative language experiments reported defining standard present store-based paper semantics introduces work equally prog rcdecl applied fndecl rcdecl record tname tname int fndecl tname tname vdecl vdecl tname varid stms null analysis alloc programs recursive procedure calls cnd observed cnd abstractionrefinement mechanism capable generating instrumentation cnd predicates record relationships const null experiments figure syntax involved ealgol -vocabulary running structures similar sec defines cutpoints present describes paper lsl instrumentation sec predicates defines lsl identified relate semantics pairs ealgol predicatesa states properties sec presents shape-analysis operations algorithm logical sec reviews structures closely related fact work sec embedding concludes theorem work applies preliminaries pair section structures introduce simple embedded imperative language called ealgol operations 
define -valued structures constrained manipulate -valued structures images canonical abstraction perform canonical abstraction application abstract structure transformer ensure abstract interpretation terminates canonical abstraction applied widening operator loop target backedge cfg additional operations logical structures prevent analysis losing precision focus operation invoked elaborate -valued structure allowing replaced set precise structures necessarily images canonical abstraction represent set concrete stores coerce clean-up operation sharpen -valued logical structure setting indefinite definite discard structure structure exhibits fundamental inconsistency represent concrete store logical structures interprocedural analysis abstract represents set initial stores goal compute control point procedure overapproximation set values local variables heap arise point precisely goal compute join-over-valid-paths node jovpa implement validpaths applying operations main existing abstract numeric pfa domains infinite set discussion concrete validpathsa standard chosen stores main numeric graf semantics domains denotes operational sidestep set large-step diverse difficulty paths set store-based performing opposed representations main symbolically storeless non-relational expressing interval global result call-tostart domain entire fully heap exit-to-return-site relational edges passed polyhedral path formula procedure domain form refer string family introduce semantics weakly-relational function gsb exit-to-return-site domains edge constructed effect global-heap balanced store-based composition preceding interval syntax call-to-start domain ealgol edge subset programs pfa ealgol multidimensional consist space composition represented collection order applies maintaining functions dataflow upper including transformers lower main bounds function values programmer maps dimension define result back dimensional subset types abstract represented alac domain structs ordered set refer words intervals eqn heap-allocated objects recast addj int types operation functions defined pointer work inserting variables parameters interval symbolic level passed j-th interval formal parameters dropj int assigned operation removes functions j-th return interval assigning edges ida denote identity operation transformer expandi restricted defined inputs expandi provide dataflow int insight transformers opportunities distribute exist move jovp predicate-abstraction solution domains foldi obtained general operation finding class closed finite-height solution lattices interval address domain set simpler equations designated define problem foldi variable ret int main syntax overapproximate ida ealgol resulting defined set fig describes foldi set notation int initial implemented denotes stores sequence main identify tint define most-precise syntactic domains abstract ida varid abstract fieldid polyhedral startnodes domain domain funcid overapproximates subset main set typeid multidimensional concrete space labels stores represented variables represented field intersection names symbolically functions calltostartedges finite employ identifiers set rangea type basic linear names idea constraints program-labels implement polyhedron function version denotes set polyhedral libraries local contributions variables parma paper provide denotes routines summarized set adding formal removing paper parameters dimensions shows assume operation addj benefits poly enjoyed dropj predicate poly variables abstraction implemented extended returnsites direct arbitrary declared invocation finite-height startnodes beginning abstract routines domains function extra care declaration describe running methods maintain ealgol program proper operations calla shown numbering needed fig carry dimensions abstract running note returnsites interpretation program call operation consists logics dropj poly result type calls directly definition applying corresponds element eqns fouriermotzkin linked understood elimination list sll dimension variant set list-manipulating expandi functional concrete functions approach poly create stores sharir crt represented operations destructive symbolically implemented pnueli append app augmenting expressed set expressed destructive symbolically reverse constraints formula reverse fixed-point-finding represent phases main function case phase linear propagates program constraint proceed allocates involving transformer-valued computing dimension values acyclic linked add lists phase similar propagates constraint dataflow destructively logics values dimension proper substituted expressed eqns symbolically dimension combine passing constraints single powerful phase remapped logic propagates instance transformervalued sets values concrete stores foldi appends summary operation transformer represented list pointed-to closed quantifier-free first-order polyhedra partial tails logic function define domain require lists foldi quantified pointed-to poly first-order logic compute overapproximates express result set overapproximation program reachable point set states foldi proc reverse sets foldi invoked concrete poly stores points-to dropj acyclic represented poly reach list tpoly decidable range subset poly elements first-order points-to weakly-relational logic equals acyclic domains list jovpa require subset second-order elements logic represented overapproximates express set set lists share constraints reachable states form elements two-phase common approach tail situations refer sharir procedure invocation dimensions pnueli reverse give compute core simplify running element presentation non-relational destructively base reverses numeric domain assume list passed compute language interval argument domain transformer result support weakly-relational staying domain local reverse maintains variables original return-site parameter logic matrix passing points-to remainder head element extend paper mij reversed-list approach organized encodes note handle constraint local shared sect variables tail motivates mij closure work parameters list operation pointed-to presenting simplified setting propagates procedure local changed constraints variables record specific parameters sll finite-height matrix sll lattice defined sect int eqns introduces sll details interprocedural reverse terminology shape sll analysis notation addj follow sect sll operation presents observation implemented general represent inserting treatment null j-th row procedures transformer j-th finite-height column set lattices sect matrix -vocabulary ret discusses -valued symbolic elements int structures techniques inserted main row implementing sll column transfer suitable functions operations initialized crt -valued element structures crt provide crt non-relational compose app base domain sect transformers app makes composition additional operation null observations null null work sect calla reverse discusses related eqn ret work figure motivating represents examples running step section involves code presents transformers represented functionscrtand examples app sets motivate appears vocabulary app work -valued treatment loc structures intuitively val semi-formal involves loc collecting level null set env formal structures treatment val structure heap sections section assumes natural dropj join operation amount structures background implemented abstract removing interpretation argument j-th set readers row find j-th define helpful column consult operation sect closed matrix reading section operation single expandi pair concerns simple concrete implemented domain inserting fact copies denote i-th set requires row variables i-th vocabularies program column loc matrix original analyzed fieldid predicate concrete val j-th domain row predicatesa j-th column ina loc env elements outa heap mij anda predicate mji figure abstraction tmpa semantic mjj predicate-abstraction domains set -vocabulary domain -valued gsb operation structure semantics foldi based global-heap store-based ina set implemented semantics predicate outa define names recomputing gsb elements values semantics i-th ealgol 
row defining simplicity semantics tracks pointer values assumes pointer-valued field variable assigned null assigned addition assume function terminates assign null pointer variable formal parameter fig defines semantic domains loc unbounded set memory locations memory state function track allocated memory locations environment mapping local variables values mapping fields allocated locations values due simplifying assumptions memory location null meaning statements transition relation squiggleright stms fig shows axioms assignments inference rule function calls fig statements handled usual two-level store semantics pointer languages memory state call-site reverse depicted graphically fig labeled allocated locations depicted rectangles labeled location variable depicted arrow variable special care handling statements variable appears left-side assignment right-side statements require additional source-to-source transformations introduction temporary variables conventions simplify definition gsb semantics lsl principle minor effects capabilities approach clarity programs adhere restrictions null squiggleright mapsto null squiggleright mapsto squiggleright mapsto null squiggleright mapsto null squiggleright mapsto alloc squiggleright mapsto figure axioms atomic statements gsb semantics side-conditions negationslash null negationslash null negationslash initializes pointer fields null body squiggleright squiggleright null mapsto ret figure inference rule function invocation gsb semantics assuming formal variables return pointer memory location points-to field depicted directed edge labeled field invocation reverse starts state heap identical environment maps reverse formal parameter actual parameter execution reverse body ends ret pointing formula head defa reversed list memory state exit point denoted state set possibly invocation negated symbols reverse drawn denoted note symbol heap present positive reverse negative exit-point form environment absent call-site instance return ret assigned defa observable properties defa section introduce access defa paths values means program observe include state note program observe location names definition field paths field path fieldid possibly empty sequence field identifiers diacritic empty sequence symbol denoted operation epsilon definition produces access operates path access symbolic path representation set concrete function stores pair consisting predicate-abstraction domain local variable boolean field predicate path accpath denotes set access eacha paths function accpath denotes distinct union constanta access appears paths program functions instance program program formal definitions notation access paths predicate-abstraction domain syntax based familiar predicate number set programming languages defa denotes sequence field defa dereferences states access paths unique function rest paper omit clear context simplify notation assume work note fixed arbitrary domain program provide exact representation final state arises abstract limited information choice predicate-abstraction domain cpl made cpl solely sake simplicity choice predicates retained greater lesser amount information state program program rise state information lost function predicate-abstraction domains virtues predicate-abstraction method procedure obtain most-precise abstract specification set concrete stores logical formulaa call procedure relies aid decision procedure defined tmpa predicates irrelevant i-th column taking join valid elements j-th row j-th column valid dropj instance operation suppose applied thata resulting formula matrix abstract semantics existing numeric domains point abstract state corresponds captures unique final concrete state state program point abstract state information compute concrete state transformed transformed independently points abstract space finite representations subsets n-dimensional space polyhedra abstract state produce transformer defined answer operation applied points subset simultaneously linear transform produce resulting abstract state case correspondence concrete states individual points abstract 
state concrete state corresponds general subset decision abstract state point procedure abstract state demonstrate belongs formulas abstractions valid possibly infinite set concrete states points abstract state independently applying transformation show making calls expand fold existing numeric domains compute results transformations safely precisely general transformation consists steps point abstract state compute values transformation formula evaluates concrete states point values computed step update point ordinarily standard semantics numeric domain combine steps point abstract state corresponds single concrete state vice versa transformation formula evaluates single point abstract state point original abstract state corresponds single point transformed abstract state situation point abstract state corresponds projections concrete states single concrete state values evaluate transformation formula applying standard semantics numeric domain produce unsound result illustrate situation concrete state predicate numeric abstraction objects show ability implement abstraction function galois connection folded concrete summary numeric abstract object domain limited predicate-abstraction domains transformation formula demonstrate evaluating formula abstract domain binding summary constant-propagation problem dimension treating point independently results abstract represents applying abstract transformation yields concrete numeric state abstractionf gis represents concrete subset stores intuitively program variablesa problem anda occurs mapped point toa procedure failed implement compute set constant-propagation values domain call transformation formula evaluates concrete states instance general procedure projection implementing functions treat applies points family abstract galois state connections independently presented overcome fig problems evaluation instance problem procedure point abstract return state typea compute set values transformation structure formula evaluates line means concrete concrete store states write abstract values abstraction courier includes typeface point problem compute values information points abstract concrete state stores update roman problem typeface set values point abstract state define update formula ans point problem point updated satisfiable differently select structure set single point ans initial ans abstract state produce potentially infinite number points transformed abstract state ansa assume return ans situation fig concrete algorithm numeric obtain object aid represented decision summary procedure numeric object most-precise abstract abstract domain overapproximates set point concrete stores values sect return type aref transforming point structure transformed abstract line state means concrete store easy abstracts concrete states arise result transformation concrete states abstracted discussion refer concrete states abstraction includes point abstract state introduce procedure concise notation simplify presentation suppose permitted make calls abstract state decision procedure point line fig make concrete assumption state abstraction assumed denote predicate abstraction relationship assume general decision overview procedure approach satisfiability checker capable numeric formula returning satisfying denotes assignment concrete equivalently numeric object concrete validity numeric checker object returns formula counterexample corresponds case summary counterexample non-summary obtained abstract numeric calling object provevalid loss generality suitable assume satisfying assignment operations correspond summary numeric objects procedure abstract numeric state concrete point abstract denote domains set related values galois connection defined evaluates representation concrete function numeric states maps concrete store aluesse abstract test assignment transform abstract numeric instance state maps steps concrete store preparation step construct set abstract compute set aluesse point standard semantics join operation numeric domain construct creating exact copies instance dimensions correspond summary abstract numeric objects fsum fsum detailed description construction sect transformation step standard semantics numeric domain perform transformation operation care maps handle abstract assignments summary formula numeric objects objects represent concrete numeric objects represent set changed concrete stores assignment instance assignments introduce extra dimension capture values assigned numeric object combine values values folding extra dimension dimension resulting formula corresponds term object involvinga details covered sects place restrictions clean-up step finally remove operationa permits dimensions introduced concretization abstract preparation store step represented produce m-dimensional symbolically subset logical formula sets concrete stores manipulated symbolically operations formulas works program suppose thata formula corresponds updated abstract state clean-up step returns situation fsum defines mapping concrete states abstract states subsets standard numeric domain join operation tstd combine numeric states control flow merge points standard semantics widening operator ostd safe respect abstraction brevity discuss widening captures paper final evaluation state numeric program formulas sequence operations abstract state performed invocation numeric formula show construct set compute aluesse initialization applying standard numeric domain operations completely determined values iteration standard semantics numeric domain extend adding satisfying extra concrete store dimensions put combinations values dimensions dims compute aluesse points parallel evaluating formula standard semantics dimensional numeric domain simplify set abstraction fsum non-summary abstract numeric object dims dims fsum create extra dimensions correspond nonsummary abstract objects simplified definition iteration dims definition compute set aluesse points satisfying concrete store evaluating formula ddims fsum ddims fsum standard semantics -dimensional numeric domain brevity refer formula remainder paper dimensions constructed creating exact copies dimensions dims fsum composition expand operations denoted expande construct expande std expanddims fsum std expanddims fsum std transformation applied set project transformed set back m-dimensional space define operation drope composition drop operations remove dimensions drope std dropm std dropm std numeric tests abstract state numeric condition construct most-precise abstract state concrete state holds objs objs dims dims define abstract transformer true aluesse drope std std expande std argue transformation sound arbitrary concrete numeric state condition holds definition set aluesse true aluesse points abstraction definition transformation entire abstraction equality line definition justified discussion compute set aluesse sect argue result transformation minimal sense points excluded note construction points set aluesse true exists concrete state condition holds abstraction assignments non-summary objects abstract state assignment fsum non-summary abstract object construct precise abstract state concrete state objs objs dims dims dims fsum define abstract transformer aluesse drope std iteration std expande unsatisfiable std return show transformation sound vfsum arbitrary concrete numeric state denote point concrete loop state terminates transformed returns result abstract assignment points n-dimensional space effect definition concrete semantics automatically discovered equal component-wise abstract world component treatment equal multiplication operator pick arbitrary non-strict projection fsum multiplicative annihilator fsum supersedesa non-summary abstract numeric object general m-th component equal carries components process equal successive components approximation making repeated calls aluesse decision procedure construction initially vfsum set equality toa line definition justified set discussion toa compute set iteration aluesse loop sect transformation minimal sense point approximation desired exists answer concrete state describes smaller set abstraction concrete state construction point exists point equal component-wise exception component aluesse definition set aluesse exists concrete state abstraction point concrete semantics abstraction mechanism abstraction concrete state assignments summary objects abstract state assignment fsum summary abstract object construct precise abstract state concrete state objs objs dims dims dims fsum define abstract transformer aluesse gand drope std folddm std std adddn std expande std soundness minimality arguments sect difference abstract object fsum corresponds collection concrete numeric objects updated point component preserve note line equation due implementation fold std computes overapproximation fold numeric domains related work introduction mentioned numeric domains investigated including non-relational domains intervals congruences break k-a fig insertion sort code insertion sort array partitioning abstract objects represent array segments invariants captured abstract state line weakly relational domains difference constraints octagons relational domains polyhedra trapezoidal congruences work assumption made fixed number numeric objects track number advance contrast work techniques performing static analysis presence unbounded number concrete numeric objects collapsed number summary objects yavuz-kahveci bultan present algorithm shape analysis numeric information attached summary nodes information summary node shape-graph bounds number concrete nodes mapped concrete memory configuration represents represents approach concrete stores stores covered instance line fig iteration update ansa sets describes stores covered time loop selects concrete store perform viewed generalization operation converts concrete store abstract store current augmented instance line fig iteration changed words generalization values constant end program fig presents sequence diagrams illustrate schematically algorithm fig terminology notation concrete stores logical structures advantage adopting outlook potentially infinite sets concrete stores represented formulas definition finite set predicate symbols fixed arity denote set predicate symbols arity ula ret lue str act lue ula ret lue str act lue ula ret lue str act lue ula ret lue str act lue ula ret lue str act lue ula ret lue str act lue fig schematic diagrams illustrate process carried algorithm fig denote values iteration initially set set astructure set set ans astructure note belongs ans set set ans combining collection astructure numeric quantities pursued work isset combined object contributes sum predicate labels summary irrelevant object isset approach objects evaluates combined ans effect tuple create individuals set astructure values future obstacle work reconcile section sketch values techniques developed predicates paper isset -vocabulary applied -valued situation structures multiple solution dynamically changing parts segments array set operation move summarized predicates separately vocabulary goal predicates ans static vocabulary analysis prove notation case correctness portrayed tmp array-sorting outa loop program terminates insertion-sort point denotes program shown simultaneous fig transformation desired structure idea answer held summary outa numeric predicates objects moved represent segments tmpa array obtains thea fig depicts outa most-precise predicates abstract situation occurs set execution insertion erapproximates instance sort perform composition represented afinite set summary numeric constant objects symbols tmp outa sort progresses tmp segments afinite array set words function symbols dimensionalities eac hwith afixed arity spaces structures denote represent set sets vary function individuals symbols carry arity individuals static-analysis logical -valued algorithm structur structures main ver difficulty vocab ulary find dimensions segments merge 
adjust pattern merging identified values analysis fortunately addressed unary canonical abstraction abstraction predicates verification operation sorting algorithms means shape analysis tvla system tvla provide refines facility -valued describe structure numeric values directly set structures member introduce work-around artificial imin binary predicate two-phase dle approach data less-than equal phase record defined eqns element equal right-hand sides eqns element work presented replaced paper permits summary transformers computed modular fashion bottom-up call graph strongly-connected components analysis input possibilities procedure important consideration context eqns written lead modular analysis requires fixed-point iteration entire program age canonical abstraction set describes set concrete structures define meet -valued structures problems addressed set individuals straightforward manner numeric manipulations handled operations sect logical tvla structures normal mechanisms universe summarizing elements vocabulary based canonical interpretations abstraction unsummarizing map elements tvla relation symbol focus operation drive -ary truth-valued summarization function partition array elements change analysis additional issues convenience arise implicitly supporting add operations bottom element delete lattice introduce remove numeric objects mechanisms presented provide meet operator machinery required instance defined abstract semantics operation add dimension abstract state initialized range initial values client analysis added object summarized existing abstract objects dimension folded existing dimension deleting non-summary numeric object drops dimension abstract state space limitation precludes giving full treatment remaining issues involved summarizing abstract numeric domains conjunction canonical abstraction bagnara ricci zaffanella hill possibly closed convex predicate polyhedra irrelevant parma polyhedra library static analysis extend previous definition pair symp -valued volume structures pages cousot halbwachs automatic discovery linear constraints variables program symp princ prog lang dantzig eaves fourier-motzkin elimination dual journal combinatorial theory notation dill composition timing transformers assumptions verification finite-state concurrent systems automatic vocabulary verification -valued methods structures finite state -vocabulary systems -valued structures pages expressed granger analyses semantiques tmp outa tmp tmp effect perform natural join tmp congruence predicates phd thesis create structures ecole predicates predicates common tmp predicates tmp predicates polytechnique eliminated setting composition operation halbwachs extended sets structures usual ssa proy ssa roumanoff verification real-time systems linear relation analysis formal methods system design contrast harrison composition compiler operation analysis ranges variables trans softw eqn represents eng lev-ami step reps heterogeneous sagiv wilhelm putting defined static analysis collection work predicate-update verification formulas case study int symp software testing analysis pages lev-ami sagiv tvla system implementing static analyses static analysis symp pages masdupuy array set indices relational -vocabulary semantic analysis -valued structures rational cosets composition trapezoids operation phd thesis eqn ecole implemented polytechnique mine performing octagon standard abstract tvla domain proc step eighth working conf rev eng predicates pages mine graph-based structures relational numerical abstract domains note static analysis symp operation pages eqn saad union sparsekit sets basic tool -valued kit structures sparse matrix computations operates version elementwise tech rep set comp sci -valued dept structures univ minnesota distributes june sagiv reps practice wilhelm eqns parametric shape solved analysis -valued propagating logic trans values prog lang full values syst verbrugge differential algorithm presented hendren generalized constant propagation view study step int making conf comp construct tmpa predicates volume irrelevant lec corresponds notes comp existentially sci quantifying pages wagner expressed foster means brewer formula aiken operation making step atuple automated tmp detection buffer irrelevant overrun involve vulnerabilities second-order symp quantification network distributed whic tmp systems security ndss possibly infinite operation february set performed yavuz-kahveci directly individuals bultan logical automated structure interpr verification etation concurrent predicate linked problem symbols lists counters static operation predicate analysis symbol symp denotes expressed set means -tuples first-order whic formula local holds variables parameters interpr etation constant 
assumed state pages 
program defined memory configuration relations states represented structures doubled vocabularies things bit complicated state includes values local variables formal input parameters formal output parameters summary transformer relate values formal input parameters node proc state heap values local variables incorporate local variables parameters expand vocabulary loc ina outa tmpa vocabulary loc captures booleanvalued pointer-valued local variables parameters tripled vocabulary assumption formal input parameters modified body procedure makes unnecessary duplicate triplicate predicate symbols parameters loc eqn ida startnodes main calltostartedges call rangea loc denotes transformer generated update formulas correspond assignment subscript eqn reflects binding actual parameter node formal input parameter node relations local variables parameters set irrelevant node call statement formy calla transformer-composition operation eqn implement abstract procedure-return operation expressed tmp outa tmp loc tmp fresh unary core predicates loc impose parameter-passing constraints bound actual input parameter bound formal input parameter bound formal output parameter relation tmp relations common meet operation performed eqn local variables set irrelevant values local variables structures answer set values exception actual output parameter assigned efficient implementation meet operation sources combinatorial explosion eqns number pairs calla quadratic explosion cardinality sets eqn defining meet operator exponential explosion point inherited nature abstract lattice powerset domain fact apply binary operation composition values domain address problem point specific abstract lattice concerns meet operation implement relational composition pair symbols constant symbol -valued structures composition performed eqn core predicates represent variables called procedure irrelevant means operation enumerate definite interpretations predicates number interpretations exponential number predicates similar situation holds generally structure irrelevant unary core predicates cost unary predicates represent pointer-valued variables means predicates evaluate individual interpretations case combinatorial explosion frustrating temporary meet reject evaluating structures obtained enumerating definite interpretations irrelevant predicates resp predicates irrelevant structure relevant definite interpretations implementation approach extended version tvla implement approximation meet operation systems -valued constraints supported base tvla system tvla global set constraints express integrity constraints set -valued structures -valued structure represents instance constraints express fact unary predicate represents pointer-valued variable evaluate individual convenience associate constraint set structure -valued structure triple generally set constraints represents set concrete structures satisfy -valued structure represents set concrete structures embedded canonical abstraction assume operation associates structure set constraints words constraint set overapproximates logical structures define operation operator property equality operation exact summarize approximate meet operator consists adding temporarily performing focus coerce operations transfer information initially contained additional constraints universe interpretation additional constraints removed instance meet operation eqns replace eqn coerce focusa forces definite interpretation constrained set represents summary transformer callee converting -valued structure set constraints achieve adapted result shows characterize -valued logical structure image canonical abstraction means formula first-order logic transitive closure resulting formula easily converted set constraints satisfy restricted syntax constraints generated expensive check algorithmic point 
view constraint dropped induces safe overapproximation roughly constraint captures fact concrete structure represented abstract structure number individuals greater equal number individuals abstract structure implementation experiments perform interprocedural shape analysis method created modified version tvla existing shape-analysis system support features replaced built-in notion intraprocedural cfg general notion equation system designed general language equation systems implemented approximation meet operation -valued structures composition operation const unary predicates list succ succ pred pred list list res res res reverse succ reverse succ const unary predicates list succ pred list succ pred res res list res reverse succ reverse succ const unary predicates list succ pred list succ pred succ succ pred pred res succ pred res succ pred list res reverse succ reverse succ fig list-reversal structure unary predicates non-a individuals displayed box labeled const unary predicates values irrelevant predicates vocabulary shown fig shows summary information obtain captures behavior recursive list-reversal procedure figs descriptor initial summary transformer start node main -valued structure shown fig represents identity transformation linked lists length pointed program-variable list head answer list pointed program-variableres program exit node main summary transformers structures fig represent transformations reverse lists length lists length greater discussed prevent loss essential information families instrumentation predicates introduced unary predicates succa preda outa record information values modes predicate predicate implies defined succa preda fact succa outa succa ina preda outa preda ina holds globally fig captures condition ina outa predicates identical entry node procedure predicates serve indelible record state n-links entry node unary predicates reverse succa outa denotes individual interpr etation function symbols function symbol maps -tuples individual typically subset predicate symbols constant symbols function symbols interpr etation isfixed advance defines afamily intended models denote infinite set structur wher ethe interpr etations fixed advance sect considered concrete stores members acommon define concrete stores ver remainder paper concrete stores identified logical structures store program variables bound inte ger values alogical structure ver vocab ulary amapping program variables inte gers symbols ret cpl ret cpl ret cpl ret cpl ret ret global heap local heap cpl hatwider usual meanings figure instance memory states concrete arise store execution aprogram running gsb semantics left column lsl semantics column show memory states call-site reverse row entry reverse row reverse exit point row return-site reverse fourth row localheap semantics figure henceforth shows abbre viate heap astore sets aliased access paths memory states defined manipulate sets structures hatwider symbolically formulas first-order logic hatwider equality alogical structure aclosed formula access notation path state means denoted satisfies standard defined val val epsilon prime prime loc null note access path traverses tarskian semantics null-valued first-order field logic defined denote set concrete structures satisfy null definition simplifies notion equivalence gsb semantics lsl semantics alternatively definition acomplete join semilattice defined path apartially order semantics set partial fig order checks suc hthat nulldereference subset performed side-conditions listed aleast upper caption bound definition join denoted access-path equality minimal access element paths equal state denoted ashorthand write state access path werset equal null concrete denoted stores null null semantics natural semantics stack activation records acomplete maintained join implicitly semilattice notion access path starts iff variable pending call iii current call small-step definition semantics access path starts variable allocated acomplete join activation record semilattice pending strictly call incr easing term chain pending variable asequence local values variable pending call pending access path suc access path hthat starts pending variable esay emphasize variable resp finite access height path ife current strictly call incr easing term chain current variable finite resp current access define path abstract domain state means arepresentation entry function reverse definition pending variable complete join semilattice pending access path current variable representation current function access path cutpoints section define cutpoints describe lsl assist suc reader provide intuition referring global store-based semantics sec smallstep stack-based operational semantics agalois connection defined extending pointwise lsl storeless semantics memory cells identified locations talk locations sec term objects lsl dynamically allocated object represented set pointer-access paths reach unlike existing itis storeless str semantics aightforwar lsl dto pending show access paths defines agalois represented connection parts local state current monotonic procedure distrib advantage utes approach iii procedure invoked operates part heap objects reachable procedure verappr actual oximates parameters aset downside concr ete approach stor memory state call defined str terms aightforwar dto state show prior call intuitive most-pr reason ecise deficiency abstr description act object change appr due oximates destructive updates examples running abstract determine domain continue pointer-access paths introduced sect aliased invocation reverse list element pointed-to sect maps aconcrete execution store reverse lik begins pointed-to ret execution ends capture kind temporal relationship lsl abstract tracks effect function cutpoints cutpoints objects separate part heap invoked function access rest heap excluding objects pointedto actual parameters definition cutpoints cutpoint invocation function heap-allocated object program state execution body starts reachable formal parameter pointed-to pointedto pending access path pass object reachable formal parameters stack heap zoo bar foo main suppose figure abstract illustration cutpoints invocation store-based small-step stack-based operational semantics figure depicts memory state record entry zoo stack place activation yrestrictions inverse record depicted defined reverse left succa side diagram activation record labeled function heap-allocated objects depicted rectangles labeled location values pointer predicates variable resp field depicted show edge labeled n-link variable resp field shaded cloud marks part entry node heap main symbolic zoo implementation n-link access cutpoints outa function section invocation presents zoo ageneral frame work exit heavily node shaded implementing main note functions words galois procedure cutpoint connections reversed pointed-to procedure n-links pending access addition fig paths composition traverse operation finds additional most-precise shaded constraint abstract part rules heap afinite-height needed lattice giv system aspecification deduce aset relationship concrete pointed-to stores ina zoo alogical formal outa mula parameter defined represents memory sets succa state concrete stores list tmpa symbolically element location formulas reverse inv cutpoint succa tmp adecision pointed-to outa procedure n-field iteration reverse list succa element assumptions location frame work reachable minimal concrete domain actual parameter wer set additional fig technically lsl cutpoint-labels relate post-state function concrete pre-state cutpoint-labels outa mark abstract cutpoints domains reverse succa related invocation agalois tmpa definition connection cutpoint defined labels arepresentation preda cutpoint-label tmp function cpl outa maps astructure function reverse set succa access paths outa start formal notice parameter reverse set succa denoted cplbs predicates abstract function related invocation constraint lsl rules labels itis cutpoints tak list-reversal ethe cutpoint-label join set predicates oabstract access values paths fig start operation previous formal papers maps parameter shape abstract aformula operation permits concretization abstract represented symbolically alogical formula allo sets concrete stores manipulated symbolically operations formulas paper first-order logic general ver logics sect place analysis list-manipulation programs yrestrictions instance lista holds individuals reachable variable list chain outa links definitions instrumentation predicates clear set -valued structures accurately captures fact output list reversal input list result list length method method program time space time space structs exs sec structs kno sec reverse insert delete tree exch experiments performed equipped ghz pentium processor memory time space information obtained time top commands numbers entry columns labeled structs give number structures summary transformer recursive procedure number structures end main procedure fig experimental results experiment involved comparing results examples list reversal discussed non-deterministic insertion deletion cell list results shown fig method eqn performs satisfied list-reversal program worse programs defined considered follo programs cell inserted passed input parameter insert deleted cell received back output parameter delete information cell inserted resp specification deleted alpha versions procedure programs analyzed implement giv method aspecification added aset global variable concrete cell stores plays alogical formula similar role slower computation times property due higher number predicates manipulated note modes alogical cost formula meet represents operation set important concrete stores mind method computes summary transformer procedure most-precise abstract erapproximates set concrete stores represented symbolically summary implementation transformer alpha procedure exit giv node fig partial function trace domain acall constant-propagation overapproximates domain set reachable states proc presented sect reach generalizing range idea sect concrete overapproximates stores set reachable identified states logical structures impact writing results delete method track original position list write deleted cell unlike method insert methods similar kind information theor experiment suppose analyze abstr act procedure domain recursively finite exchanges height left subtrees input binary tree interesting properties difficult implement loop operation lines non-recursive procedur procedure analysis executed establish times procedure finishes subtrees cells reachable root exchanged computes cells most-pr ecise modified abstr act statistics fig approximates information set experiments concr ete stor http repr irisa esented prive symbolically bjeannet symbolic implementation transfer interproctvla functions interproctvla transfer html related functions statements aset predicate constant function symbols denote set symbols attached symbol iff work analysis interpretation paper statements inv -valued olv structures specification doubled transition vocabulary relations similar approach formulas standard formulas concrete transition relations double expressed vocab means ulary formulas instance semantics statement expressed unprimed symbols referred present-state statements symbols primed symbols transformed xt-state composable symbols abstract transformers satisf action programs relation manipulate o-v numeric ocab data ulary formula numeric lattices written polyhedra octagons contrast observation structures create composable vocab abstract ularies transformers analysis programs support dynamically-allocated storage destructive updating pointer-valued fields respecti structures vely key feature approach instrumentation predicates refer called atwo-vocab ina ulary structur outa vocabularies economy instance notation family unary duplicate predicates symbols reverse succa interpretation discussd fix adv ance formula expresses outa semantics assignment records respect inverse stores vocab ulary discussed introduction interprocedural shape analysis studied approach present paper inspired functional approaches contrast approach denoted reminiscent call-strings approach method performing interprocedural shape analysis procedure defa specifications assume-guarantee reasoning presented assumed specification procedure preand post-condition technique parallel presented form assume interpret procedure preand oisomorphic postcondition abstract domains precise abstraction variants procedure invocation checks current abstract potentially violates precondition warning produced point immediately call assume post-condition holds similarly procedure analyzed pre-condition assumed hold entry end procedure formula post-condition checked work formula present paper complementary constant-propagation work domain means modified ane form xt-state sketched abstract footnote produced identify transition procedure specifications form sets -vocabulary -valued structures method connection identified present-state method abstract compute most-precise overapproximation meet abstract transition specification values ven aformula operation astatement needed stransition composing relation transformers result expressed applying sets aset -vocabulary -valued concrete stores structures eqns precise alternative approximate meet operation exists present implementations methods based theorem provers note slower aset method structures vocab ulary involve theorem prover acknowledgments viktor kuncak helpful discussions return approach most-precise abstract paper sagiv reps erapproximates wilhelm parametric shape analysis -valued logic trans implementation prog lang syst reps sagiv loginov finite computed differencing logical procedure formulas presented fig initialized line operates lik abstractions structures accumulated variable ans lines static analysis iteration european symp loop programming lev-ami sagiv tvla system implementing ans static analyses abetter approximation static analysis desired answer symp cousot cousot describes static asmaller determination set dynamic concrete stores properties recursive procedures neuhold formal stores descriptions programming concepts ifip andrews canada august range north-holland projection sharir pnueli xt-state symbols approaches interprocedural data vered flow analysis ans muchnick jones eds program flow analysis two-vocabulary theory formula applications prentice-hall englewood cliffs knoop ans steffen interprocedural coincidence theorem comp construct invoked function reps point-to cutpoint function horwitz execution sagiv starts precise interprocedural dataflow analysis label satisfiable cutpoint select change two-vocabulary structure execution function body heap modified destructive updates fourth list ans element ans inx list cutpoint invocationy reverse label cutpoint graph ans reachability princ return prog lang ans york fig acm algorithm press sagiv implements reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp alternati vely sci reps schwoon jha asingle weighted abstract pushdown domain systems application definitions interprocedural dataflow analysis static analysis symp ball rajamani access bebop path path-sensitive points-to interprocedural dataflow cutpoint engine entry prog analysis function softw good tools analogy role eng rinetzky cutpoint-labels sagiv semantics interprocedural shape analysis auxiliary recursive variables programs formal comp verification construct auxiliary variables volume formula lec notes record variable comp values formula entry sci jones function muchnick cutpoint-label moti vation flexible record approach access interprocedural oabstract paths data domains flow reach analysis eliminate cutpoint apossible programs function source entry recursive confusion data emphasize structures examples princ similarity prog separate notation abstract cqa domains lang deutsch cplbs primed determining symbols cutpoint-labels lifetime aliasing alw ays dynamically allocated data distinguish function higherorder xt-state functional lslis abstract specifications values infer princ effect present-state prog invoked function lang suppose gopan heap dimaio caller dor including reps representation sagiv numeric object domains summarized dimensions tools algs construct anal syst loginov reps sagiv abstraction refinement -valued-logic analysis tech rep comp sci dept univ wisconsin yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tools algs construct anal syst jeannet loginov reps sagiv relational approach interprocedural shape analysis tech rep comp sci dept univ wisconsin yorsh logical characterizations heap abstractions master thesis school computer science tel aviv israel cousot halbwachs automatic discovery linear constraints variables program princ prog lang min octagon abstract domain working conf rev eng 
statement inter preted formula formula fig sho initialization iteration satisfying structure iteration satisfying structure iteration unsatisfiable return fig operations performed acall theor suppose abstr act domain finite height inputs properties loop lines procedur executed times computes most-pr ecise abstr act appr oximates operator implemented aprocedure dual fig transfer functions conditions specification interpretation acondition respect agi ven abstract pass structures represented satisfy most-precise approximation interpretation condition denoted defined implementation computed follo wing method discussion paper sho most-precise versions basic operations needed create abstract interpreter conditions implementable techniques idea afirst-order formula ade vice describing accepting aset concrete structures set structures satisfy ery subset concrete structures afirst-order formula ver straightforw ard generalize approach types logics considered alternati structure-description formalisms possibly werful possibly werful basic approach carry isrequired isthat adecision procedure exist logic automatic theorem pro vers sem finder implement procedures presented paper yreturn countere xamples validity acountere xample validity astructure satisfies tools exist logics first-order logic mon generate countere xamples formulas weak monadic second-order logic tools simplify svc pro vide countere xamples symbolic form aformula formula represents aset countere xamples ystructure satisfies formula acountere xample query line fig returned formula aparticular satisfying structure field paths reach start cutpoint definition cutpoint-anchored paths presents obstacle cutpointanchored path line cpl requires cplbs argument function asingle cutpoint-label structure function case quantifier possibly -free empty first-order sequence logic fields linear arithmetic astructure obtained memory feeding state countere execution xample ofreverse formula body asolv cutpoint-anchored mix path ed-inte ger hatwider programming aliased cplex int access path ret bool information semantics read infer main function state invocation reverse fig aliased program technically correlated branches invocation ith function aid object simplify represented verified access paths constant-propagation cutpoint-anchored examples paths pointto paper definition generalized examples access combine paths constant-propagation generalized domain access path function predicate-abstraction domain access path additional benefit cutpoint-anchored path approach gaccpath denotes generate set access transformer paths function combined gaccpath domains denotes union reduced cardinal access product paths functions created program domain risk constructors confusion abbreviate generalized transformer access path form combined epsilon constantpropagation note predicate-ab straction domain variable determines cutpoint-label variable xmust remark cutpoint-labels isolate information end part program giv heap fig function related access ork sharing paper pattern closely cutpoints related past set work access predicate paths abstraction entry function decision point-to procedures cutpoint implement isolation most-precise achieved versions parametric basic abstractinterpretation cutpoint-label operations expresses predicate fact abstraction object applies pointed-to amily pending access finite-height path abstract domains terms finite invoked cartesian function products formal boolean parameters values results infer generalize meaning ideas cutpoint-label abroader context-independent setting remark note work sho garbage-collecting asmall nature number storeless conditions semantics met non-trivial technical benefits difficulty predicate-abstraction obtaining domains local enjo semantics ycan storeless enjo model yed arbitrary garbage-collection scan abstract domains collect finite heap height possibly procedure infinite local cardinality variables roots elements 
garbage collected accessible global state adding cutpoint-labels set roots prevent potential source ver unsoundness procedure localized-heap storeless fig semantics approach section define lsl fundamentally localized-heap dif store-less ferent semantics semantics natural semantics predicate abstraction tracks pointer approaches values define multiple semantics calls adecision function procedure defined pass fig space infix formulas operator domain application abstract concatenates values sequence field identifiers dir ectly generalized aformula access path abstract prefix generalized fig access mak path denoted domain concr field ete values path acritical time proper prefix loop denoted selects aconcrete negationslash epsilon function lifted handle sets access generalize paths concrete sets sequences field abstract identifiers addition procedure make related flat algorithm functional well-known machine functional learning programming flat called returns find-s set section elements machine-learning terminology ifm set algorithms sets search formally aspace flat hypotheses find most-specific hypothesis root consistent cplbs gaccpath positi root training examples obj concept gaccpath learned objects find-s recei heap ves asequence obj training heaps examples generalizes cplbs current heap hypothesis memory time state figure presented semantic domains positi memory states training function falls syntactic current domains hypothesis problem cplbs settings gaccpath oalgorithms semantic slightly domains dif ferent find-s italics font recei ves denote asequence semantics positi memory gati states examples section concept define representation starts memory states aprecise lsl statement 
traditionally concept hand formula iteration decision procedure generate positi training techniques compare predicate abstraction augmented iterati ve-refinement scheme generates predicates slam blast acomplete answer question ver observ ations made results extend ideas emplo yed setting predicate abstraction amore general setting simple examples illustrati purposes paper iterati refinement obtain suitable predicates constant values iteration techniques achie desired precision roughly logical machinery ailability adecision procedure rely heuristics-based machinery changing abstract domain paper studies problem obtain most-precise results abstract domain iterati refinement addresses adif ferent problem impr oving abstract domain orthogonal questions question impro ving abstract domain studied abstract domains rich techniques applied subject future work speculate ver observ approach pro vide afundamental primiti mapping values abstract domain suppose odif ferent abstract domains meet conditions frame work giv most-precise erapproximates obtained domain-changing primiti opens sev eral possibilities future work countere xample-guided abstraction-refinement strate gies identify shortest inv alid prefix aspurious countere xample trace refine abstract domain eliminate inv alid transitions valid abstract state prefix domain-changing primiti appears pro vide asystematic salv age information countere xample trace instance itcan inv con vert valid abstract state prefix abstract state refined abstract domain moreo ver yields most-precise yconserv ati salv aging operation allo wed produce summary results enable abetter separation concerns issue obtain most-precise results agiven abstract domain impr ove abstract domain ycontrib ute abetter understanding abstraction symbolic approaches abstract interpretation refer ences stanford validity check http erify stanford svc ball majumdar millstein rajamani automatic predicate abstraction programs lang design impl york acm press ball rajamani slam toolkit computer -aided verif lec notes comp sci pages clark gupta kukula strichman tbased abstraction-refinement ilp machine learning techniques computer -aided verif clark grumber jha veith countere xample-guided abstraction refinement computer -aided verif pages july cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fix points princ lang cousot cousot systematic design program analysis frame works princ lang pages york acm press das dill park experience predicate abstraction computer -aided verif pages springer erlag july detlefs nelson sax simplify compaq systems research center alo alto enderton amathematical intr oduction gic academic press graf construction abstract state graphs pvs computer -aided verif pages june henzinger jhala majumdar sutre lazy abstraction princ lang pages york january acm press ilog ilog optimization suite white paper ilog gentilly france kildall unified approach global program optimization princ lang pages york acm press klarlund ller mon ersion user manual brics notes series ns- uni aarhus january mccune user manual guide gonne nat lab mitchell mac hine learning wcb mcgra w-hill boston nielson nielson hankin principles ogr analysis springer erlag slane finder finite domain enumer ator ersion aust nat uni july zhang zhang generating models sem int conf auto deduc olume lec notes art intell pages springer erlag 
storeless semantics represents heap equivalence relation set access paths equivalence classes implicitly represent allocated objects readability equivalence classes directly memory state function pair cpl set cutpoint-labels denoted cpl heap denoted heap finite unbounded set objects object denoted possibly infinite set generalized access paths fig semantic domains lsl memory state function memory state cpl point execution composed labels cutpoints current invocation cpl representation heap point execution exclude states arise program define notion admissible states definition admissible memory states memory state cpl function point execution admissible iff generalized access path points-to object prime negationslash prime prime right-regular iii prefix-closed flat flat root access path description object local variable label cutpoints flat cpl negationslash cpl satisfies requirements cutpoint-labels cpl mutually disjoint cpl rightregular necessarily-prefix closed negationslash cpl conditions standard storeless semantics fourth condition limits set cutpoint-anchored paths tracked invocation rooted cutpoint invocation condition represent objects pointed-to current pending access path sixth requirement captures fact set cutpoints subset objects heap function invoked lsl preserves admissibility states sequel refer lsl state admissible lsl state extract aliasing relationships sets generalized access paths describe objects heap observe heap structure current variable points-to object iff access path epsilon similarly cutpoint-label cpl labels object iff cpl epsilon field object points-to object iff generalized access path generalized access path generalized access path points-to resp passes object resp object reachable variable exists field path heap running state reverse invoked shown row column fig labeled shows sets generalized access paths set represents allocated list-element point-to object set cutpointlabels call site empty case main function fourth element list cutpoint invocation reverse reachable actual parameter representation includes field object passed invoked function n-field object list heap beginning reverse shown fig labeled differs ways objects heap set cutpoint-labels hatwider labels fourth element list iii objects represented terms generalized access paths start hatwider inference rules meaning statements transition relation squiggleright stms give axioms assignments inference rule procedure calls fig fig statements handled standard simplify notation assume index resp prime heap component state index resp prime convention indexed primed versions cpl state cutpoint-labels component helper functions define inference rules functions rem add defined fig metavariable ranging sets generalized access paths necessarily objects stands objects function returns object points-to heap point-to object returns empty set definition describes object pointed-to current pending access path function rem takes arguments heap set generalized access paths removes description object heap access paths prefix rem removes generalized access paths description object object removed description heap function add yields modified version heap object reachable field path generalized access paths added addition make map functional functional programming functional map applies element returns resulting set formally map atomic statements axioms atomic statements fig simplify semantics making assumptions sec assigning null variable modify link structure heap eliminate access paths start rem function semantics assignment ycopies variable adding access path object reached field path points-to accomplished applying add gaccpath gaccpath prime prime gaccpath gaccpath gaccpath gaccpath gaccpath heap obj rem heap gaccpath heap rem map add heap gaccpath gaccpath heap add map figure helper functions null cpl squiggleright cpl rem cpl squiggleright cpl add cpl squiggleright cpl add null cpl squiggleright cpl rem cpl squiggleright cpl add alloc cpl squiggleright cpl figure axioms atomic statements local heap semantics note set cutpoint-labels changed side-conditions flat flat side-condition flat resp flat means resp null heap singleton set access path rule field dereference similar adds access path object reached field continuing field path note rule applied points-to object semantics checks null-dereference performed destructive update null potentially modifies link structure heap generalized access path prefix aliased removed description object heap note returns access paths aliased concatenating returns set prefixes affected access paths rule applied points-to object assignment potential effect access paths aliased assignment object reached field path reachable traversing generalized access path aliased f-field continuing place cycles created add necessarily return right-regular heap apply operator defined set equivalence classes obtained right-regular prefix-closed equivalence relation superset equivalence relation induced note definition add access paths description existing objects deterministic semantics memory allocationx alloc adds object heap note definition implicitly initializes fields object null function calls inference rule function calls defined fig rule defines program state results invocation memory state assuming execution body memory state results memory state heaps sets generalized access paths starting caller variables cutpoint-labels heaps sets generalized access paths start callee formal parameters cutpointlabels return variable rule means reconcile representations rule functions call ret parameterized call statement program call computes memory state results entry invoked memory state caller memory state invocation restored function ret function computes memory state caller return-site memory state call-site memory state exit-site rest section describe rule arbitrary call statement arbitrary function rule utilizes additional helper functions defined fig gradually explain main idea rule utilize fact function modify objects local-heap part heap reachable actual parameter function invoked lsl describes objects terms generalized access paths point-to inaccessible objects description call description objects function local-heap part heap function access possibly updated update carried cutpoints invocation essence semantics freezes initial descriptions cutpoints arranges persist execution called function sets relation values entry values exit return frozen information update description objects called function local-heap operation roughly similar relational join operation pure relational join adjustments needed due representation objects caller callee find objects local-heap called function reachable actual parameters compute set objects pointed-to actual parameters args auxiliary function robjs finds part caller heap reachable objects 
passed description objects call account operator similar rstc operator mechanism compute description objects callee allocates call call cpl circleasterisk args negationslash passed robjs args cpobjs cpl args passed bind args args epsilon bind bind args epsilon bind call args bind args args bind map bind args map bind call passed ret ret cpl cpl circleasterisk bind ret range bind call ret epsilon epsilon ret epsilon bypass passed bind call cpl passed map bind ret body squiggleright squiggleright call ret figure inference rule function calls lsl rule arbitrary call statement arbitrary function assume formal parameters mutations destructive updates heap performed callee invoked function modify objects access modify fields objects passed compute possibly updated description objects passed objects callee allocates sufficient description object passed object allocated callee comprised generalized access paths start objects separate passed rest caller heap function returns replace generalized access paths description object heap callee start separating object prime access paths caller points-to prime pass passed modified technically auxiliary function cpobjs fig determines cutpoints function invocation cutpoints objects separate passed rest caller heap expository reasons objects pointed-to actual parameters cutpoints function cpobjs passed caller memory state previously computed args passed considers objects deep passed args cutpoints intuition cutpoints separating objects object deep robjs heap obj obj robjs prime prime bypass obj obj gaccpath bypass prime prime negationslash flat gaccpath gaccpath obj gaccpath bind flat bind dom bind cpobjs obj obj obj cpobjs cpl args passed deep passed args vars epsilon deep fld deep prime passed fieldid prime cpl cpl epsilon deep cpl cpl vars cpl fld figure helper functions function-call rule function cpobjs parameterized function program recall set local variables qualified cutpoint holds pointed-to local variable caller vars pointed-to object part caller heap passed function fld separates heap caller heap pending calls cutpoint invocation caller cpl back fig define binding mappings bridge gap representations objects terms access paths caller terms access paths callee function bind args maps objects pointed-to actual parameters set trivial access paths made formal parameters function bind maps cutpoint caller representation set access paths start formal parameter caller point-to cutpoint entry function bind maps cutpoint label sec compute label cutpoint apply bind args denotes function replaces access path starts actual parameter representation access path starts formal parameter defined fig bind call combines previous mappings trivially disjoint domains defined mapping functions computing memory state body evaluated description heap function entry straightforward set cutpoint-labels cpl computed applying bind cutpoint heap component constructed applying bind call object passed note resulting description objects set generalized access paths point-to start formal parameter cutpoint object handle return function additional binding bind ret mapping inverse bind call back caller representation object composed function bypass passed filters generalized access paths caller pass part heap access passed addition takes care replacing access paths starting special variable ret access paths starting result variable note applying bind ret defined cpl cpl equal callee modify set objects separate local-heap local-heap pending call cutpoint-labels component state return invocation cpl callee modify set objects separate heap caller heap earlier pending-call heap called derived removing heap call-site passed objects passed plugging heap results evaluating body substituting description objects applying bind ret object applying function-call rule invocation reverse running results sets mappings args passed bind args mapsto bind mapsto hatwider bind ret mapsto hatwider mapsto ret mapsto fourth element list cutpoint invocation reverse sec label hatwider execution reverse body starts cutpoint represented set generalized access paths hatwider execution function body ends cutpoint-anchored paths representation object fig replaced access paths start access path points-to cutpoint call-site bypasses objects passed reverse cutpoint-anchored path hatwider representation element returned list replaced properties semantics means program observe state access paths program refer cutpointlabels component state state theorems preliminary definitions access-path equality observational equivalence simplifying notational conventions sec note semantics access path equal null prefix equal null definition access path equality access paths equal state denoted access path equal null state denoted null negationslash flat note transition squiggleright prime cutpoint-labels component prime definition observational equivalence function states observationally equivalent accpath null null semantic equivalence theorem main theorem paper states lsl equivalent gsb sense behave equivalently termination execution statements preserves observational equivalence proof theorem theorem equivalence function observationally equivalent states arbitrary statement holds squiggleright prime squiggleright prime prime prime observationally equivalent theorem states lsl verify data-structure invariants expressed access-path equalities program point assert absence null-valued pointer dereferences formally property invariant labeled statement satisfied memory-state occurs labeled statement executed corollary program function aprogram point accpath invariant iff invariant theorem states lslcan detect memory leaks investigating reachability roots pending access paths memory leak occur variable field assigned null leaked objects pointed-to suffixes nullified variable field corollary memory leak occur variable field assigned null executing statementx nullin memory state cpl leaks object iff executing statementx nullin memory state cpl leaks object iff epsilon cor cor corollaries define language assertions access paths show lsl preserves partial total correctness assertions expressed language memory leak object pointed-to access path access path current call pending call shape analysis section lsl semantics automatically compute safe approximation set program states iterative abstract-interpretation algorithm main idea abstract state finitely represents potentially infinite number concrete lsl states program interpreted abstract semantics sharp squiggleright over-approximates concrete transition relation squiggleright termination abstractinterpretation algorithm guaranteed finiteness set abstract states algorithm conservative describes memory state arise program point execution means conservatively determine properties program absence null-dereferences absence garbage validity invariants checking properties generated abstract states description conservative algorithm represent concrete states infeasible concrete semantics leads incompleteness sense fail establish assertions hold execution present interprocedural shape-analysis algorithm programs manipulate singly-linked lists algorithm finds finite description memory states arise program execution information program behavior extracted computed descriptors analysis running successfully verifies program null create garbage reverse returns variables point-to acyclic linked lists shared tail algorithm presented terms -valued-logic framework program analysis technically -valued logical structures represent unbounded memory states tracked properties encoded predicates paper focus abstraction lslmemory states due lack space give full details analyses abstract transfer functions defined analysis abstract transformer detailed description shape-analysis algorithm representinglslmemory states -valued logical structures kleene -valued logic extension ordinary 
-valued logic special unknown cases predicates true false definite values indefinite information partial order set defined subsetsqequal supersetsqequal unionsq -valued logical structure comprised set individuals nodes called universe denoted interpretation universe finite set predicate symbols interpretation predicate symbol denoted predicate arity function -valued structure -valued structure interpretation limited set -valued logical structure denoted -struct set -valued logical structures denoted -struct establish galois connection set program states ordered set inclusion -struct suffices show representation function maps program state mostprecise representation -struct define function shape -struct maps local-heap precise representation -valued logical structure shape vls -struct vls cpl cpl islist islabel cpl epsilon ils negationslash lbl cpl epsilon cpl epsilon cpl figure function vls maps states -valued logical structures predicate intended meaning islist list element islabel cutpoint-label pointed-to current variable n-field point-to reachable current variable n-fields ils locally shared pointed-to n-fields objects local-heap reside directed cycle n-fields object cutpoint-label lbl list element labeled cutpoint-label list element cutpoint list element reachable cutpoint n-fields table predicates represent states separate predicates program variable composition functions vls -struct maps local-heap unbounded -valued logical structure canonical abstraction -struct -struct conservatively bounds defined usual representing local-heap -valued logical structure function vls defined fig maps local heap cpl -valued logical structure object cutpoint-label cpl cpl represented unique node tracked properties memory state recorded predicates tab denote set predicates represent memory state -valued logical structures depicted directed graphs directed edge nodes labeled binary predicate symbol unary predicate symbol draw inside node conversely draw explain predicates intended meanings apply vls memory state entry point reverse shown fig resulting -valued logical structure denoted depicted fig universe nodes nodes represent list elements node represents cutpoint-label hatwider predicates islist islabel record node represents list element cutpoint draw nodes represent list elements islist rectangles nodes draw nodes represent cutpoint-labels islabel circles node predicates ils adaptation localheaps standard predicates analysis singly linked lists pointer variable unary predicate variable points-to list element represented h-predicate depicted edge predicate node represents list element points-to pointed-to-by-a-field relation list elements represented binary predicate n-field list element represented points-to list element represented unary predicate holds list elements reachable access path starts local variable current call unary predicate ils captures local-heap sharing information predicate node represents list element pointed-to n-fields list elements local heap note predicate records local sharing ils global-view heap list element represented n-successor list elements local heap represented local heap element list pointed-to unary predicate holds node resides cycle n-fields binary predicate records equality relation drawn pictures predicates lbl record information special abstraction lsl state binary predicate lbl relates node represents cutpointlabel node represents cutpoint lbl represents label cutpoint represented unary predicate records property list element cutpoint represents cutpoint nodes unary predicate records property list element reachable cutpoint-anchored path represent list elements reached cutpoint cutpoint-anchored paths hatwider epsilon hatwider nodes predicates record information cutpoint-anchored paths similar manner record information access-paths unlike local variables number cutpoints unbounded predicate recording reachable list-elements cutpoint individuals represent cutpoint-labels mark cutpoint objects predicate squiggleright sharp shape prime squiggleright prime figure specification abstract inference rules atomic statements canonical abstraction main idea canonical abstraction represent list elements cutpoint-labels single node mapping list elements cutpoint-labels universe -valued logical structure surjective function necessarily injective function node represents list element cutpoint-labels called summary node formally -valued logical structure sharp canonical abstraction -valued logical structure exists surjective function sharp satisfying conditions iff unary predicates predicates pof arity k-tuples sharp sharp sharp sharp sharp sharp sharp sharp sharp node sharp sharp represents node sharp -valued logical structure sharp depicted fig row column conservatively represents memory state represented -valued logical structures drawn directed graphs definite values drawn -valued structures binary indefinite predicate values drawn dotted directed edges summary nodes depicted double frame universe nodes nodes values unary predicates universe sharp nodes mapping sharp induced canonical abstraction sharp sharp sharp sharp sharp summary node sharp memory state represented sharp cutpoint label node sharp summary node cutpoint represented sharp recorded ways predicate lbl sharp sharp sharp sharp represents list element labeled unary predicate sharp sharp abstract interpretation specification abstract interpretation abstract inference rules style natural semantics abstract inference rules operate -valued logical structures fig fig shows specification abstract inference rules atomic statements function-calls rules declarative style abstract transformer abstract inference rule emulates concrete inference rule represented states fig shows application function-call inference rule fig running logical structures sharp arises call-site reverse sharp lbl hatwider hatwider hatwider figure -valued logical structure results applying vls memory state entry point reverse shown fig denote structure sharp sharp sharp ils sharp sharp sharp sharp sharp sharp sharp sharp lbl sharp sharp sharp sharp sharp ils sharp sharp sharp sharp ret sharp ret sharp ret sharp ret ret sharp lbl sharp sharp figure representative -valued logical structures arise analysis running call-site reverse row column entry reverse row column reverse exit point row column return-site reverse row column arises entry reverse sharp arises exit-point reverse sharp structure computed return-site sharp list pointed-to ret reversed result sharp reachable cutpoint exit-site list-element pointed-to byz explicitly represented sharp inference rule conclude sharp returnsite logical structure sharp reachable similarly sharp longer reachable conclude definite values tracked properties established function call returns discussion abstraction program state mapped -valued logical structure information tracked contents labels differentiate cutpoints lead significant loss precision multiple cutpoints arise passing lists shared tails handled conservatively simple abstraction abstract domain precise analyze programs analyzed verify dereference null-valued pointers create garbage create cyclic lists handle programs handled verify recursive function destructively merges acyclic lists returns acyclic list straightforward multiple cutpoints functions multiple formal arguments discriminating cutpoints reachable formal parameters improve precision handling functions passed multiple lists related work storeless semantics storeless semantics introduced jonkers original work handle procedure calls intraprocedural storeless semantics develop logic express regular properties unbounded data structures storeless semantics handles function-calls defined semantics develop may-alias algorithm contrast lsl pending access paths explicitly represented may-alias analysis may-alias algorithms find upper approximation sets aliased access paths program point deutsch interprocedural may-alias algorithm storeless representation heap algorithm polynomial handle function calls dynamic memory allocation destructive updates body squiggleright sharp prime squiggleright sharp prime call 
ret prime compatible prime figure specification abstract inference rules function calls functions call ret defined fig note apply ret compatible pairs memory states memory states compatible sharing pattern results invocation matches description context state exit-site formally compatible cpl cpl prime prime prime null null call ldots lsl insight deutsch work static may-alias analyses based pointer-access paths treatment variables pending calls complicated aspects instance surprising aspect method recursive procedures handled precise loops intuitive reason abstractions values variables current procedure abstraction values variables pending procedures show deutsch algorithm abstraction lsl semantics defining galois connection memory states lsl abstract domain interprocedural shape analysis original motivation work attempt apply interprocedural shape analysis heap-manipulating programs modular fashion chap objective achieved based weaker technique procedure operates part heap reachable actual parameters heap considered undirected graph pending access paths point-to objects passed part heap represented paper heap treated directed graph pending access paths represented addition handle recursive procedures interprocedural shape analysis studied main idea make runtime stack explicit data structure abstract linked list method entire heap run-time stack represented program point result abstraction lose information properties heap parts heap affected procedure procedures considered transformers entire program heap call entire program heap call heap-allocated object represented program point hand values local variables current procedure represented means irrelevant parts heap summarized single summary node analysis invoked procedure modular interprocedural shape-analysis algorithm presented procedure analyzed part heap reachable parameters algorithm relate memory states procedure-entry memory states procedure-exit labeling abstract node mapping determined sharing part heap passed procedure sharing pattern context needed conclusions paper develop lsl storeless semantics languages dynamic memory allocation destructive updating procedure calls storeless semantics unique called procedures passed parts heap main insight side-effects procedure invocation r-values pending access paths delayed procedure return memory cells unique identifiers locations main idea track effect destructive updates access paths start set objects separate part heap procedure reach rest heap objects call cutpoints invocation similar observation uniform effect procedure pending access paths made pointer analysis semantics lsl designed precise efficient abstractions mind information context provided rest heap isolated sharing patterns cutpoints expressible context-independent manner analysis benefits fact heap localized behavior procedure depends part heap reachable actual parameters sharing patterns create cutpoints analysis results reused contexts similar sharing patterns abstraction non-standard concrete semantics present interprocedural shape-analysis algorithm programs manipulate dynamically allocated storage approach markedly previous works analyze function invocation calling context algorithm prove properties programs automatically verified establish recursive destructive merge acyclic singly-linked lists returns acyclic singly-linked list fig establish properties fewer program-specific instrumentation predicates modular treatment heap implementation abstractions scale larger pieces code approach insights existing mayanalysis algorithm design choices made development shape-analysis algorithm storeless semantics concentrate superset program footprint based reachability actual footprint ideas underlying approach apply store-based semantics choice storeless semantics natural make sec semantics equivalence relation pointer access-paths logical structures naming scheme cutpoints cutpoint-labels fits naturally explicit manipulation access paths type semantics decision concentrate superset program footprint inferable static analysis pragmatic choice present study future work plan investigate user-supplied assertions preserved portions heap notion cutpoint important concept storeless semantics store-based semantics instance garbage collection local heaps unsound cutpoints considered part root set storeless semantics takes sets access paths cutpoint-labels contextindependent representation cutpoints invocation sense approach paper spirit local reasoning prove properties procedure independent calling contexts local reasoning frame rule proofs carried local fashion main idea partition heap disjoint parts reason parts separately semantics resembles frame rule sense effect procedure call large heap obtained effect subheap acknowledgments grateful helpful comments yahav yorsh anonymous referees bozga iosif laknech storeless semantics alias logic proceedings acm sigplan workshop partial evaluation semantics-based program manipulation pages acm press chong rugina static analysis accessed regions recursive data structures sas codd relational model data large shared data banks communications acm cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press deutsch operational models programming languages representations relations regular languages application static determination dynamic aliasing properties data phd thesis lix ecole polytechnique palaiseau france deutsch storeless model aliasing abstractions finite representations right-regular equivalence relations ieee international conference computer languages pages washington ieee press deutsch interprocedural may-alias analysis pointers k-limiting sigplan conf prog lang design impl pages york acm press ishtiaq hearn assertion language mutable data structures symposium principles programming languages pages jeannet loginov reps sagiv relational approach interprocedural shape analysis static analysis symposium jonkers abstract storage structures bakker van vllet editors algorithmic languages pages ifip north holland kahn natural semantics annual symposium theoretical aspects computer sciences stacs pages springer-verlag landi ryder safe approximate algorithm interprocedural aliasing proceedings acm sigplan conference programming language design implementation pages acm press lev-ami reps sagiv wilhelm putting static analysis work verification case study proc int symp software testing analysis pages nielson nielson hankin principles program analysis springer reynolds separation logic logic shared mutable data structures logic computer science pages rinetzky interprocedural shape analysis master thesis technion israel institute technology haifa israel rinetzky bauer reps sagiv wilhelm semantics procedure local heaps abstractions tech rep avacs october http avacs typedef struct list struct list int merge null return null return merge return merge return figure recursive procedure merges singly linked lists destructive updates sll crt int sll int ret null alloc sll crt ret sll app sll sll sll null ret app ret figure crt creates list elements app destructively appends list tail list rinetzky sagiv interprocedural shape analysis recursive programs int conf comp construct pages rinetzky sagiv yahav interprocedural functional shape analysis local heaps tech rep tel aviv uni november http math tau maon sagiv reps wilhelm parametric shape analysis -valued logic acm transactions programming languages systems venet automatic analysis pointer aliasing untyped programs science computer programming appendix additional code fig shows code merge function fig shows code functions crt app running 
symbolically computing most-precise abstract operations shape analysis yorsh reps sagiv school comp sci tel-aviv univ fgretay msagivg post tau comp sci dept univ wisconsin reps wisc abstract shape analysis concerns problem determining shape invariants programs perform destructive updating dynamically allocated storage paper presents algorithm takes input abstract -valued logical structure describing set concrete stores precondition computes most-precise abstract stores satisfy algorithm solves open problems shape analysis computing most-precise abstract set concrete stores specifled logical formula computing transformers atomic program statements conditions iii computing transformers loop-free code fragments blocks atomic program statements conditions performing interprocedural shape analysis procedure speciflcations assume-guarantee reasoning computing most-precise overapproximation meet abstract values algorithm employs decision procedure logic express properties data structures decidable logic expressing properties algorithm undecidable logic theorem prover termination assured standard techniques theorem prover return safe answer time-out threshold exceeded cost losing ability guarantee most-precise result obtained prototype implemented tvla spass theorem prover introduction shape-analysis algorithms capable establishing invariants hold imperative programs perform destructive updating dynamically allocated storage establish program preserves treeness properties program satisfles correctness criteria tvla system automatically constructs shape-analysis algorithms description operational semantics programming language shape abstraction methodology abstract interpretation show shape-analysis algorithms generated tvla sound conservative technically program tvla flnite set abstract values forms join semi-lattice adjoined pair functions form galois connection abstraction function maps potentially inflnite sets concrete stores most-precise abstract concretization function maps abstract set concrete stores abstract represents soundness means set concrete stores supported onr contract supported part israel science foundation founded academy sciences humanities represented abstract values computed tvla includes stores arise include super uous stores produce false alarms main results goal work improve precision scalability tvla employing decision procedures show concretization abstract expressed logical formula speciflcally algorithm converts abstract formula characterizes set concrete stores represents paper develop algorithms operations shape abstractions computing most-precise abstract represents potentially inflnite set stores deflned formula call algorithm bfi constructive version algebraic operation computing operation assume returns most-precise abstraction set stores represented precondition holds applied general abstract procedure dassume computes bfi applied abstract dassume reflnes precondition exciting application method paper permit tvla applied large programs procedure speciflcations computing abstract transformers atomic program statements conditions current transformers tvla conservative notnecessarilythebest technically ment transformer amounts assume formula input output states input abstract method compute transformers loop-free code fragments blocks atomic program statements conditions computing most-precise overapproximation meet abstract values operation combining forward backward shape analysis establish temporal properties performing interproceduralanalysisinthesharirandpnuelifunctionalstyle technically meet abstract values computed bfi assume operation perform interprocedural shape analysis procedure speciflcations assume-guarantee reasoning problem interpret procedure preand post-conditions precise abstraction procedure invocation check current abstract potentially violates precondition warning produced point immediately call assume post-condition holds similarly procedure analyzed pre-condition convention operation marked hat denotes algorithm computes operation assumed hold entry end procedure post-condition checked core algorithm dassume presented paper computes assume weprove correctness algorithm dassume assume fig itshowsthetheconcreteand abstract value-spaces rectangle left oval points oval represent abstract values sets concretevalues deflnedby shownasovalsontheleft thealgorithmworksits waydownintherightoval outer oval region labeled algorithm repeatedly reflnes abstract eliminating ability represent concrete stores satisfy produces abstract represents tightest set storesin thatsatisfy ofcourse due abstraction result describe stores hold result precise abstraction tightest overapproximation expressible abstract domain fig dassume algorithm set describes stores represented satisfy dassume algorithm employs decision procedure logic alogicnamed dtc isdescribed whichisboth decidable itsmain features sketched section dassume algorithm undecidable logic theorem prover termination assured standard techniques theorem prover return safe answer time-out threshold exceeded cost losing ability guarantee most-precise result obtained prototype implementation study feasibility method implemented prototype dassume algorithm flrst-order theorem prover spass spass support transitive closure prototype implementation applicable shape-analysis algorithms transitive closure simple examples cases dassume running paper case transformer queries posed examples theorem prover terminated number calls spass running running time approximately seconds overview framework section overview framework results reported paper formal description dassume algorithm appears section precondition expressed notation null abbreviated section program variables linked-list data-type deflned fig precondition deflned closed formula flrst-order logic theoperation assume enforces precondition abstract typically represents set concrete stores arise program point evaluated abstract running depicted graph fig graph abstraction concrete stores non-empty linked list pointed explained -valued structures paper abstract values represent concrete stores sets -valued logical structures vocabulary predicate symbols structure universe individuals mapping k-tuples individuals values k-ary predicate values deflnite values indeflnite meaning consistent denoted denotes upper bound values set -valued structure representation stores individuals abstractionsofheap-allocated objects point stack heap binary predicates represent pointervalued flelds data structures additional predicates describe propertiesoftheheap aspecialpredicate ity locations pair node called summary node represent linked-list element table describes predicates required program pointer variables manipulates linked-list data-type deflned fig -valued structures depicted directed graphs individuals graph nodes predicate represented solid arrow dotted arrow absence arrow fig solid arrow node predicate hasthevalue fortheindividualu inthe -valuedstructures thismeansthat concrete store represented linked-list element pointed program variable additional elements represented predicate intended meaning pointer variable point element pointer variable point element fleld point denote element pointed fleld table set predicates representing stores manipulated programs list data-type fig pointer variables summary node drawn dotted circle reachable head linked-list dotted arrow corresponds predicate linked dotted self-arrow dotted arrows program variable point linked-list element absence arrow means n-pointer head list unary predicate nodes shown graph indicating element concrete store represented structure pointed n-fleld list typedef struct node struct node int data list oocc fig declaration linked-list data-type input abstract fsg represents concrete stores non-empty linked list pointed program variable program variable point element result computing assume abstract represents concrete stores linked-list length pointed element pointed introduce subclass bounded structures end deflne abstraction predicates designated subset unary predicates denoted running unary predicates deflned abstraction predicates bounded structure -valued structure evaluates difierent deflnite values -valued structures paper bounded structures bounded structures shape analysis guarantee analysis carried flnite set abstract structures terminate embedding order -valued structures -valued structures ordered embedding order deflned guarantees set concrete stores represented subset represented -valued structures surjective function maps nodes nodes embeds denoted predicate arity k-tuples uki uki consistent speciflc embedded denoted exists function fact requirement assume rephrased embedding generate most-precise abstract concrete stores embedded embedded satisfy precondition 
result assume shown fig consists structures embedded input structure fig embedding function maps output structure node output structures output structures nodes mapped embedding node mapped concrete elements represented output structures represented single summary node input structure node materialized node node required guarantee most-precise result relative abstraction embedding function consistent thevalueofxonu insi ands structures indeflnite values predicates impose restriction values output structures instance nodes consistent nodes absence n-edge back implies edge output structures values predicate pairs integrity rules -valued structure special case -valued structure predicate valuesareonly becausenotall designated set integrity rules exclude impossible stores integrity rules flxed analysis deflned conjunction closed formulas vocabulary satisfled concrete structures linked-list data-type fig conditions deflne admissible stores program variable point heap node n-fleld element point element iii holds exist distinct elements n-flelds pointing finally interpretation equality holds denote element canonical abstraction abstraction paper canonical abstraction deflned surjective function takes -valued structure returns -valued structure properties maps concrete nodes abstract nodes canonical names nodes constructed values abstraction predicates tight embedding predicate abstract node-tuple exist concrete nodetuples difierent values -valuedstructures isanica ifthereexists -valued structure note ica bounded structure structures fig produced assume operation icas structure fig ica structure fig canonical abstraction concrete structure fig fig gfed abcu gfed abcu gfed abcu gfed abcu gfed abcu fig concrete stores represented structure fig concrete nodes mapped abstract node concrete nodes mapped abstract node concrete structures generated manner adding isolated nodes map summary node abstraction function deflned extending pointwise ffl set -valued structures concretization function takes set -valued structures returns potentially inflnite set -valued structures ifi satisfles integrity rules exists requirement assume produce most-precise abstract amounts producing set concrete structures embed satisfy result assume fig satisfles requirement canonical abstractions structures structure fig canonical abstraction structures fig canonical abstraction fig huy requires concrete structure abstracted pairs nodes canonical names huy difierent values requirement hold pair canonical names result include canonical abstractions concrete structures semantically equivalent embedded version dassume algorithm describe include output straightforward generalize algorithm produce smallest semantically equivalent set structures non-trivial produce most-precise result assume instance back-edge nodes embed node input structure self-loop evaluating consequence integrity rules back-edge exist concrete structure satisfles precondition implies existence n-pointer incoming n-edge predicate determine predicate values output structure concrete structure represents accounted number concrete structures potentially inflnite examined explicitly algorithm paper decision procedure perform task symbolically end algorithm symbolic representation concrete stores logical formula called characteristic formula characteristic formula abstract denoted satisfled -valued structure formula shape analysis deflned bounded structures includes integrity rules addition requirement output dassume set icas imposed formula deflned check predicate nodetuple uki structure intuitively formula satisflable exists concrete structure represented tuples nodes mapped abstract tuple uki evaluates difierent values tuples formula satisflable result canonical abstraction uki precise compared concrete nodes dassume algorithm dassume algorithm shown fig section explains role decision procedure queries posed algorithm algorithm explainedinsection phase andsection phase finally theproperties algorithm discussed section -valued structure canonical abstraction procedure dassume formula set bounded structures set ica structures result phase result bif result phase exists result arity false true satisflable result resultnfsg satisflable result result satisflable result result return result fig dassume procedure takes formula vocabulary computes set ica structures result includes integrity rules order eliminate infeasible concrete structures formula deflned procedure bif result shown fig marks processed q-tuples initially false predicate tuples decision procedure formula guarantees concrete structure tuples nodes mapped abstract tuple uki evaluates difierent values captured formula vki nodesui vki nodesui vki node formula deflned uniquely identifles mapping concrete nodes abstract nodes bounded structure nodesu simply asserts agree abstraction predicates function issatisflable invokes decision procedure returns true satisflable set -valued structures satisfy non-empty function guides reflnement predicate values satisflability checks formula make decisions discard -valued structure represent concrete store taking materialize node node phase taking retain indeflnite predicate node-tuple uki phase taking requires decision procedure logic expresses including integrity rules decidable logic shape analysis describes logic dtc deflned formulas form procedure bif formula set bounded structures set bounded structures satisflable nfsg exists nfsg satisflable satisflable satisflable return fig procedure takes set structures formula vocabulary computes bifurcation structure input set input formula note beginning procedure ensures structure working set represents concrete structure satisfles formula deflned operation performs bifurcation node setting values predicates values quantifler-free formula arbitrary number unary predicates single binary predicate general transitive closure dtc denotes deterministic transitive closure e-paths pass individual successors dtc shown reasoning shape invariants data structures singly doubly linked lists shared trees graph types satisflability dtc formulas decidable nexptime-complete dtc decision procedure candidate implementation issatiflable function sidestep limitations logic introduces notion structure simulation maintained mutation operations commonly occurin proceduresthat manipulate heap-allocated data structures simulation deflned translation fotc formulas equivalent dtc formulas undecidable logic dassume algorithm undecidable logic theorem prover termination function issatisflable assured standard techniques theorem prover return safe answer time-out threshold exceeded cost losing ability guarantee most-precise result obtained timeout occurs flrst call theorem prover made phase structure removed result timeout occurs satisflability call made bif phase structure examined call isaddedtotheoutputset usingthistechnique dassume alwaysterminateswhile producing sound results candidate decision procedure monadic -nd order logic trees mona non-elementary complexity materialization phase algorithm performs node materialization invoking procedure bif bif main purpose structure indeflnite abstraction predicate abstract node supported difierent values concrete nodes node bifurcated nodes set difierent deflnite values nodes bif procedure produces set -valued structures set canonical names concrete stores satisfy embed bif procedure flrst fllters potentially unsatisflable structures iterates structures indeflnite abstraction predicate node replaces structures result phase abstraction predicates deflnite values nodes structures output structures bounded structures number difierent structures produced flnite guarantees bif procedure terminates body loop bif check exists concrete structure representedbys thatsatisfles inwhichq represented query performed formula case structure added created duplicating node instances setting node instance instance predicate values node instances values addition copies created guarantee copy represents concrete structure query posed decision procedure omitting query produce sound potentially overly-conservative result fig shows computation tree algorithm running node tree labeled -valued structure sketched showing nodes children labeled result reflning -valued structure predicate node-tuple values shown outgoing edges order predicate values examined afiects complexity terms number calls decision 
procedure size query formulas call maximal number explored structures afiect result provided calls terminate order fig chosen convenience presentation root tree sketch input structure fig left circle circle fig shows steps performed bif input fsg fig bif examines abstraction predicate indeflnite values nodes algorithm attempts replace shown children fig structures discarded concrete structures represent violate integrity rule section precondition remaining structure modifled setting results structure satisfy discarded fig computation tree dassume shown fig reflning predicate values phase dassume algorithm reflnes structures lowering predicate values throwing structure structure predicate tuple structure represent -valued structure tuples structure indeflnite predicate tuple abstract nodes eliminate structures predicate values tuples concrete structures represented satisfy query performed formula addition copies created values anappropriate query posed decision procedure guarantee predicate tuple processed bulk fig top rows shows reflnement predicate running phase starts structures size produced bif reflnement pointed pointed node names fig predicate tuple set requires existence concrete structure difierent pairs nodes mapped uyi integrity rule section implies node represented node represented intuitively stems fact concrete node represented pointed predicate tuple set violates precondition element pointed representedby mustalsobepointed bythe n-fleld oftheelement pointed toby representedbyu thereader verify structures fig generated dassume flnal answer read leaves properties algorithm determine complexity algorithm terms size structure number nodes deflnite values number structures iii number calls decision procedure size query formula passed decision procedure linear size examined structure linear small size flxed complexity terms iii linear doubly-exponential size exponentially efflcient naive enumerate-and-eliminate algorithm abstract domain reason algorithm paper examines descending chain abstract domain shown fig prove correctness algorithm cient establish properties proofs structures explored algorithm bounded structures result requirement ensures result sound result canonical abstractions concrete structures global invariant algorithm result abstract structures icas concrete store holds termination algorithm computing transformer algorithm manipulates two-store vocabulary includes copies predicate original unprimed primed version predicate original version predicate values best-transformer algorithm takes set bounded structures vocabulary transformer formula two-store vocabulary returns set ica structures two-store vocabulary canonical abstraction pairs concrete structures result applying transformer computed dassume extend operates two-store vocabulary extend extends structure two-store vocabulary setting values primed predicates two-store vocabulary maintain relationship values predicates transformer arbitrary formula two-store vocabulary precondition involves unprimed versions predicates primed predicates update part result transformer obtained primed version predicates output structure related work conclusions presented difierent technique compute transformers general setting flnite-height possibly inflnite-size lattices technique presented handles inflnite domains requiring decision procedure produce concrete counter-example invalid formulas required present paper compared advantage approach present paper iterates holds legitimate logic undecidable timeout terminate computation return current technique starts intermediate result safe approximation desired answer reason procedures discussed based decision procedures potential advantage approach paper size formulas algorithm reported linear size structures counting values depend height domain paper closely related past work predicate abstraction decision procedures implement most-precise versions basic abstract-interpretation operations predicate abstraction special case canonical abstraction nullary predicates interestingly applied vocabulary nullary predicates algorithm fig similar algorithm slam starts nullary predicates repeatedly reflnes instances general setting canonical abstraction requires formula identify values non-nullary predicates flrst phase procedure bif identify node materializations carried operationintvla whichissimilarin spirittothe assume operation theinputoffocusisasetof -valuedstructures formula focus returns semantically equivalent set -valued structures evaluates deflnite kleene semantics -valued logic dassume algorithm reported paper advantages guarantees number resultant structures flnite focus algorithm tvla generates runtime exception achieved make focus partial function criticized tvla user community number structures generated dassume optimal sense returns -valued structure canonical abstraction required store property achieved decision procedure prototype implementation theorem prover makes dassume slower focus future plan develop specialized decision procedure logic dtc hope give beneflts dassume maintaining ciency focus formulas focus deflned russian focus means trick hocus pocus summarize shape-analysis problems methods paper automatic precise tvla modular analysis assume-guarantee reasoning slower work nice abstractinterpretationtechniquescanexploitdecision-procedures theorem-provers methods speed techniques subject ongoing work ball rajamani slam toolkit proc computer-aided verif lec notes comp sci pages cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press henriksen jensen rgensen klarlund paige rauhe sandholm mona monadic second-order logic practice tools algorithms construction analysis systems international workshop tacas lncs immerman descriptive complexity springer-verlag immerman rabinovich reps sagiv yorsh decidable logics expressing heap connectivity preparation jones muchnick flow analysis optimization lisp-like structures muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood clifis klarlund schwartzbach graph types symp princ prog lang york january acm press lev-ami sagiv tvla system implementing static analyses static analysis symp pages reps sagiv yorsh symbolic implementation transformer proc vmcai sagiv reps wilhelm parametric shape analysis -valued logic symp princ prog lang pages york january acm press sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst sharir pnueli approaches interprocedural data analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood clifis wang analysis recursive types imperative language phd thesis univ calif berkeley weidenbach spass automated theorem prover flrst-order logic equality http spass mpi-sb mpg index html yorsh logical characterizations heap abstractions master thesis tel-aviv tel-aviv israel http math tau gretay yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis technical report tau http tau gretay 
framework numeric analysis array operations denis gopan wisconsin gopan wisc thomas reps wisconsin reps wisc mooly sagiv tel-aviv msagiv post tau abstract automatic discovery relationships values array elements challenging problem due unbounded nature arrays present framework analyzing array operations capable capturing numeric properties array elements analysis establish array elements initialized arrayinitialization loop discover numeric constraints values initialized elements analysis based combination canonical abstraction summarizing numeric domains describe prototype implementation analysis discuss experience applying prototype examples including verification correctness insertion-sort procedure categories subject descriptors formal definitions theory semantics semantics programming languages program analysis general terms languages verification keywords program analysis array analysis abstract numeric domains canonical abstraction summarization supported part onr contract supported part cisco systems wisconsin distinguished graduate fellowship supported part nsf grant ccrby onr contract alexander von humboldt foundation supported part grant israeli academy science alexander von humboldt foundation permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee popl january long beach california usa copyright acm introduction array simple efficient data structure heavily cases verify correctness programs arrays analysis discover relationships values array elements relationships scalar variables constants scientific programing sparse matrix represented arrays indirect indexing access matrix elements case verify array accesses bounds analysis discover upper lower bounds elements stored index arrays mutual-exclusion protocols bakery peterson algorithms relationships values stored shared integer array decide processes enter critical section verify correctness protocols analysis capable capturing relationships static reasoning array elements problematic unbounded nature arrays array operations tend implemented fixed array size mind code parametrized scalar variables numeric relationships actual size array proper verification code requires establishing desired property values parameters thecode beinvoked symbolic constraints size array preclude analysis modeling array element independent scalar variable standard numeric analysis techniques verify property alternatively entire array treated single summary numeric quantity case numeric properties established summary quantity represents array shared array elements approach array smashing resolves unboundedness issue problem approach approach aggregation inability perform strong updates assigning individual array elements lead significant precision loss paper present static-analysis framework combines canonical abstraction summarizing numeric domains precise array smashing analysis canonical abstraction partition unbounded set array elements bounded number strong update corresponds kill scalar variable represents definite change concrete objects abstract object represents strong updates generally performed summary objects concrete update affects summarized concrete objects groups partitioning based properties array elements numeric relationships indices values scalar variables elements properties grouped group represented abstract array element abstraction storeless sense static connection concrete array element abstract array element represents properties concrete array element change represented abstract element analysis summarizing numeric domains track values indices array elements indices array elements modeled explicitly numeric quantities array element actual element index intuitively analysis attempts partition array elements groups stronger assertions established maintained array element assigned analysis isolate element separate group strong update performed analyzing array-initialization code analysis attempts array elements initialized separate group uninitialized verification sorting routines analysis separate portions arrays sorted unsorted portions program multiple arrays non-array variables important question partition array verify desired property found simple heuristic partitioning arrays respect variables access effective practice array elements indexed scalar variables individual groups represented non-summary abstract elements array segments indexed elements individual groups groups represented summary abstract elements partitioning heuristic analysis discover constraints values array elements simple initialization loops fully automatically complex properties verifying comparisonbased sorting algorithms require extra care end sect introduce auxiliary predicates thatare attached abstract partition element encompass numeric properties capabilities summarizing numeric domains paper give examples suchauxiliary predicates illustrate establish desired properties challenging examples goal analysis collect overapproximation set reachable states program point abstract-interpretation framework formalize analysis abstract states obtained program point set triples triple consists array partition element summarizing abstract numeric domain valuation auxiliary predicates implement prototype analysis extendedthe tvla tool provide capability reason numeric quantities tvla three-valued logical process identifying auxiliary predicates abstract transformers present performed automatically sect discuses possibilities carrying steps automatically structures describe states program associate element summarizing numeric domain three-valued structure extend tvla internal machinery maintain numeric states correctly extend specification language incorporate predicates include numeric comparisons summarizing numeric domain implemented wrapping parma library polyhedral analysis manner defined set predicates describing partitioning arrays prototype implementation analyze successfully kernel examples including verifying correctness insertion-sort implementation contributions make paper introduce abstract domain suitable analyzing properties complex array operations generally show previously techniques canonical abstraction andsummarizing numeric domains combined work describe working prototype analysis illustrate non-trivial examples related work problem reasoning values stored arrays addressed previous research review related approaches aware masdupuy dissertation numeric domains capture relationships values index positions elements statically initialized arrays contrast framework discover relationships dynamically initialized arrays canonical abstraction lets approach retain precision handling assignments array elements strong updates blanchet building special-purpose static program analyzer recognized handling values array elements proposed practical approaches array expansion introducing abstract element index array array smashing single abstract element represent array elements array expansion precise practice arrays small size handle unbounded arrays array smashing handling arbitrary arrays efficiently suffers precision losses due perform weak updates approach combines benefits array expansion array smashing dynamically expanding elements read written avoid weak updates smashing remaining elements flanagan qadeer predicate abstraction infer universally-quantified loop invariants handle unbounded arrays predicates skolem constants synthetically introduced variables unconstrained values variables quantified inferred invariants approach model values array elements directly summarization handle unbounded arrays approach abstract numeric domains maintain numeric state program obviates calls theorem prover cern introduced technique parametric predicate abstraction special-purpose abstract domains void array copy int int int figure array-copy function designed reason properties array elements domains parametrized numeric quantities designate portion array desired property holds abstract transformers manually defined domain analysis instantiates domains explicitly modeling parameters numeric state approach differs respects approach numeric states directly model array elements analysis automatically synthesize invariants involve values array elements approach separates task array partitioning task establishing properties array elements separation user concentrate directly formulating auxiliary predicates capture properties interest canonical abstraction introduced purpose determining shape invariants programs perform destructive updating dynamically allocated storage lacked 
ability explicitly represent numeric quantities introduced method extending existing numeric domains capability reasoning unbounded collections numeric quantities static partitioning numeric quantities assumed work combines techniques shows combination verifying properties array operations paper organization thepaper isstructuredasfollows sect givesan overview analysis sect discusses concrete semantics sect introduces abstraction sect details analysis running sect outlines prototype analysis implementation sect describes experiences analysis prototype sect concludes presentation running section illustrate technique simple procedure fig copies contents array array arrays size parameter procedure assume analysis determined facts values storedinarray instance assume thatthevalues elements array range exit procedure establish values stored array range establish property reasonable array size values greater equal technique operates partitioning unbounded number concrete array elements bounded number groups group represented abstract array element partitioning introducing relations indices array elements loop variable fig technique group elements arrays indices summary array elements denoted array elements indices greater grouped summary array elements array elements grouped array elements represented non-summary abstract array elements partitioning analysis perform strong update processes assignment statement body loop fig shows elements arrays partitioned iteration loop abstract array elements represents single concrete array element array analysis conclude concrete array element represented ranges assignment variable incremented grouping concrete array elements element represented moves group concrete array elements represented abstract element represents array element extracted group concrete array elements represented elements array treated similarly fig shows arrays partitioned iteration analysis reflects change grouping array elements combining numeric properties numeric properties numeric properties abstract element obtained duplicating numeric properties result beginning iteration analysis establishes concrete array element represented ranges numeric properties abstract elements array treated similarly increases iteration concrete array elements arrays move groups subscripted groups subscripted finally thetwo groups subscripted fig shows arrays partitioned k-th iteration concrete array elements represented elements initialized suppose analysis established values elements represented beginning k-th iteration range interpreting assignment body loop analysis establishes element represented ranges increment variable numeric properties combined properties result analysis establishes values concrete elements represented beginning -st iteration range important thing observe partitions shown fig describe groupings concrete array elements partitions sets abstract array elements point view analysis partitions establish concrete array elements represented abstract element analysis directly models values indices array elements numeric state partition fig shows array elements partitioned iaia ibib figure partitionings array elements points execution array-copy function -st loop iteration -nd iteration k-th iteration iteration exiting loop exiting loop shown iteration analysis established values concrete array elements represented range loop shown fig represents concrete elements array analysis conclude values stored range analysis establish general property element array equal element array index numeric domains analysis capable maintaining numeric relationships kind concrete array elements summarized capture relationships augment abstract array element array extra property holds iii concrete array elements represented abstract element introducing auxiliary three-valued unary logic predicate evaluates values abstract elements array represent cases iii analysis proceeds elements array start evaluating analysis knowledge values stored array iteration property established array element set end iteration concrete array element represented merged group elements represented iteration exists properties directly transfered iterations determined joining current expr expr expr cond expr expr stmt expr expr cond stmt stmt cond stmt stmt stmt scalar array figure array-manipulation language equals result analysis establishes iteration property interest holds initialized array elements concrete semantics goal analyze programs operate fixed finite set scalar variables arrays concrete program state stores scalar variable array element denote set concrete program states sigma denote set scalar variables set arrays program scalar array sets concrete states arise result program execution reason arrays arbitrary size set elements array differ state state notation denote set elements array array state ensure proper sequencing array elements assume concrete state explicitly assigns array element proper index position array denote set numeric values encode concrete state functions alues scalar maps scalar variable sizes array maps array size aluesa maps element array array indexsa maps element array array index position array program operate scalar variables array size suppose point execution program values variables values stored array encode concrete state program scalar array alues imapsto jmapsto sizes bmapsto notation scalar array elem indexsa alues expressions alues valuesa elem expr expr expr expr conditions expr expr expr expr assignments expr vmapsto expr expr umapsto expr elem errors set transformers expr expr assigns expr expr assigna cond cond true cond join figure concrete collecting semantics language shown fig aluesb mapsto mapsto mapsto mapsto indexsb mapsto mapsto mapsto mapsto fig define simple language suitable expressing array operations language consists assignment statements conditional statements loops values assigned scalar variables array elements language arbitrary expressions explicitly access array elements scalar variables allowed index arrays define program concrete collecting semantics program point attach set concrete states set transformers shown fig propagate sets concrete states program set transformers defined assigning scalar variables assigns array elements assigna interpreting numeric conditionals if-statements while-statements cond joining sets concrete states control merge points join goal analysis collect set reachable program states program point determining exact sets concrete states general undecidable framework abstract interpretation collect program point overapproximation set states arise abstract domain section define family abstract domains main contribution paper elements abstract domains sets abstract memory configurations abstract memory configuration triple specifies arrays partitioned represents abstract numeric state stores values auxiliary predicates denote set abstract partitions array partitioning goals array partitioning twofold isolate separate groups array elements assigned analysis perform strong updates assigning elements group elements similar properties minimize precision loss due summarization paper explore array-partitioning scheme based numeric relationships indices array elements values scalar variables set scalar variables partition array element index equal variables set group groups represented non-summary abstract array elements consecutive array segments indexed elements grouped groups represented summary abstract array elements define array partitions fixed set partitioning functions denoted function parametrized array single scalar variable array scalar concrete state function interpreted evaluated indexsa values indexsa values indexsa values choice values completely arbitrary long function evaluates cases denote set partitioning functions parameterized array concrete state partition array array grouping elements partitioning functions evaluate values group represented abstract array element non-summary element partitioning function evaluates array elements group summary element set empty elements array 
grouped single summary element values partitioning functions evaluate array elements group uniquely determine abstract element represent group continue intuitive abstract-element naming introduced sect denotes group array elements indices greater formally array partition maps array array set abstract array elements array partitions equal map arrays array sets array illustrates array partitioning assume situation set partitioning functions elements array partitioned groups represented abstract array element represented represented iii represented represented represented abstract array elements non-summary summary bmapsto note abstract element array corresponds valuation partitioning functions abstract array elements number ways partition array number sets abstract array elements consistently represent array finite combinatorially large observations show small fraction partitions occur practice approach presented section illustrates possibilities partitioning array found partitioning consecutive array elements share similar properties analyzing simple array-initialization loops simple array-sorting algorithms constitutes large portion actual arrays complicated examples double indexing initialize array array store complex data structure tree array partitioning succeed plan address issue improving array partitioning future work numeric states track numeric information array partition attach partition element summarizing numeric domain summarizing numeric domains capable modeling values summary objects automatically constructed extending standard relational numeric domains octagons polyhedra quantity abstract object modeled dimension domain dimensions summary non-summary depending type object array analysis non-summary dimensions represent values scalar variables array sizes values indices non-summary abstract array elements summary dimensions model values indices summary abstract array elements note abstract array element dimensions index position array notation refer dimensions summarizing numeric domain denotes dimension represents values scalar variable size denotes dimension represents size array denote arbitrary abstract element array denotes dimension represents index denotes dimension represents index simplicity assume summarizing numeric domain analysis constructed extending polyhedral numeric domain present numeric states sets linear constraints constraint quantity summary object interpreted hold quantities concrete objects represented abstract object assume situation numeric state set linear constraints size index index index index index definitions partial-order relation join operation summarizing domain depend underlying numeric domain polyhedral domain result join operation computed taking convex hull union arguments numeric states set dimensions compared joined set dimensions determined array partition numeric states similar array partitions compared joined summarizing domains canbeusedto reason collective numeric properties summarized array elements relationships quantities summarized lost precludes summarizing numeric domains express properties interest impossible express fact set array elements summarized sorted order numeric state capture property values concrete array elements represented range elements sorted ascending order capture properties capabilities summarizing numeric domains introduce set auxiliary predicates denoted concrete state predicate maps element array boolean property interest holds element semantics auxiliary predicates supplying formula evaluated concrete states elements array summarized join values -valued logic lattice -valued logic extra denoted added set boolean values order defined iff resulting attachedto thecorresponding abstract array element abstract memory configuration abstract counterpartof predicate denotedby mapabstract array elements values arbitrary abstract array element interpreted property holds array elements represented property hold array elements represented property hold array elements represented hold rest elements assume situation introduce predicate evaluates array elements ascending order elements indexsb indexsb aluesb aluesb concrete state shown evaluates elements remaining elements values abstract array elements constructed part abstract memory configuration stores interpretation auxiliary predicates denoted defined makes sense compare join interpretations defined set abstract array elements interpretations array partition define partial order relation interpretations auxiliary predicates join operation interpretations auxiliary predicates defined abstract states examples illustrate construction abstract memory configuration represents arbitrary concrete state function refer process abstracting single concrete state denotetwo abstract memory configurations wedefineapartialorder relation abstract memory configurations join operation defined abstract memory configurations similar array partitions resulting abstract partition defined index index index index index index bimapsto bimapsto imapsto figure abstract state entrance loop program point fig abstract state abstract memory configurations represents arrays length represents arrays length greater set abstract memory configurations apartition congruence class iffit isa maximalsized subset members partition arrays similarly exists define abstraction function set concrete states partition congruence class abstract state set abstract memory configurations distinct array partitions concretization function defined define partial-order join operation abstract states denote abstract states partial-order relation defined join abstract states performed computing union sets abstract memory configurations configurations similar array partitions joined similar spirit partially disjunctive heap abstraction running revisited section flesh schematic illustration theanalysis givenin sect analysis applied code shown fig depict abstract memory configurations arise analysis partition arrays shown graphically solid boxes represent non-summary abstract array elements dashed boxes represent summary abstract array elements numeric states shown sets linear constraints auxiliary predicates shown maps sets abstract array elements values program fig set scalar variables set arrays defined scalar array analysis theset partitioning functions capabilities ibib ter ion index index index index index index present present bimapsto bimapsto imapsto ite tio index index index index index index index index index imapsto bimapsto imapsto bimapsto imapsto ite tio index index index index index index index index index index imapsto bimapsto imapsto bimapsto imapsto ite tio fte oin index index index index index index index index index index imapsto bimapsto imapsto bimapsto imapsto ite tio fte ide nin index index index index index index index index index index imapsto bimapsto imapsto bimapsto imapsto figure abstract memory configurations begining -st -nd iterations loop fig sets abstract memory configurations row form abstract states rows show weighted pushdown systems application interprocedural dataflow analysisa thomas repsa stefan schwoona somesh jhaa comp sci dept wisconsin reps jha wisc fakult inf universit stuttgart schwoosn informatik uni-stuttgart abstract recently pushdown systems pdss extended weighted pdss transition labeled goal determine meet-over-allpaths paths meet criterion paper shows weighted pdss yield algorithms classes interprocedural dataflow-analysis problems introduction paper explores connection interprocedural dataflow analysis model checking pushdown systems pdss connections dataflow analysis model checking established past work exception past work shed light relationship model checking bit-vector dataflow-analysis problems live-variable analysis partial-redundancy elimination contrast results presented paper apply bit-vector problems non-bit-vector problem addressed iii dataflow-analysis problems expressed bit-vector problems linear constant propagation general approach applied distributive dataflow-analysis problem domain transfer functions infinite descending chains safe solutions obtained problems monotonic distributive paper makes recent result extends pdss weighted pdss transition labeled goal determine meetover-all-paths paths meet criterion paper shows weighted pdss yield algorithms classes interprocedural dataflowanalysis problems ideas illustrated application weighted pdss linear constant propagation contributions paper summarized conventional dataflow-analysis algorithms merge values states program point states calling context dataflow-analysis algorithm obtained weighted pdss dataflow queries posed respect regular language stack configurations conventional merged dataflow information obtained issuing queries approach strictly richer framework interprocedural dataflow analysis provided conventional interprocedural dataflowanalysis algorithms algorithm solving path problems weighted pdss provide witness set paths provide explanation answer dataflow query reported algorithms paper implemented library solves reachability problems weighted pdss library create prototype implementations context-sensitive interprocedural dataflow-analysis algorithms linear constant propagation detection affine relationships supported onr contract library internet parties creation dataflow-analysis tools remainder paper organized section introduces terminology notation paper defines gpr framework section presents algorithm solving gpr problems section presents contribution paper application gpr framework interprocedural dataflow analysis section discusses related work appendix describes enhancement algorithm section generate witness set answer gpr problem terminology notation section introduce terminology notation paper pushdown systems pushdown system transition system states involve stack unbounded length definition pushdown system triple finite sets called control locations stack alphabet configuration pair finite number rules form define transition relation configurations write express exists rule omit index understood reflexive transitive closure denoted set configurations define sets configurations reachable backwards forwards elements transition relation loss generality assume henceforth restrictive pushdown system simulated obeys restriction larger constant factor pushdown systems infinitely configurations symbolic means represent sets configurations finite automata purpose definition pushdown system -automaton quintuple finite set states set transitions final states initial states control locations configuration accepted ifa final state set configurations regular recognized -automaton frequently omit prefix simply refer automata understood convenient property regular sets configurations closed forwards backwards reachability words automaton accepts set construct automata accept general idea algorithm pushdown system automaton accepting set configurations loss generality assume transition leading initial state obtained language automaton derived saturation procedure procedure adds transitions rule current automaton add transition efficient implementation procedure requires time space procedure implementation presented constructing -automaton accepts section develop generalizations procedures present extensions basic idea applies omitted lack space weighted pushdown systems weighted pushdown system pushdown system rules values domain weights weight domains interest bounded idempotent semirings defined definition definition bounded idempotent semiring quintuple set elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring function assigns rule sequence rules associate define configurations denote set rule sequences transform definition weighted pushdown systema wherea regular set generalized pushdown reachability gpr problem find witness set paths notice extender operation calculate path set paths computed combiner operation general fora finite set paths values minimal elements minimal respect partial order defined definition solving generalized pushdown reachability problem section presents algorithm solving gpr problems entire section denote fixed weighted pushdown system denote fixed regular set configurations represented -automaton transition leading initial state gpr problem multi-target meet-over-all-paths problem graph vertices graph configurations edges defined transition relation target vertices vertices graph set target vertices infinite built-in structure regular set gpr problem concerns infinite graphs infinite set paths differs work meet-over-all-paths problems ordinary pushdown-reachability problem infinite nature gpr problem addressed reporting answer indirect fashion form annotated automaton answer automaton annotations identical automaton created algorithm values read annotations accepting paths automaton transformation abstract state iteration joined widened respect abstract state obtained iteration -st iteration -nd iteration -rd iteration final state index index index index index index index index imapsto imapsto imapsto imapsto figure abstract state consisting single abstract memory configuration reaches program point -st -nd iterations loop fig column shows stabilized abstract state summarizing numeric domains express property index equal capture property introduce auxiliary predicate semantics concrete state defined indexsb indexsa aluesb aluesa fig shows abstract state program point abstract state abstract memory configurations configuration represents degenerate case array element array represented single abstract array element indices equal ranges abstract memory configuration represents concrete states arrays length greater equalto inthese situations array represented abstract elements represent elements arrays represent remaining elements numeric state partition indices concrete array elements represented equal indices concrete array elements represented range values concrete elements array range auxiliary predicate evaluates array elements 
abstract memory configurations means concrete states represented values concrete elements array equal values elements array fig shows abstract states analysis encounters beginning iteration entry table represents abstract memory configuration abstract state iteration set abstract memory configurations shown row table table columns correspond distinct array values algorithm presented stages define language characterizes sequences transitions made pushdown system automaton turn weighted pushdown systems gpr problem language characterizations transition sequences previously results kind grammar problem obtain solution gpr problem solution based grammars inefficient improve performance specialize computation case ending algorithm creating annotated automaton similar thea algorithm languages characterize transition sequences section make definitions aid reasoning set paths lead configuration configurations regular set call set reachability witnesses fora respect reachabilitywitnessesa convenient pds anda -automatona combined sequence create combined pds call states rules ofa augmented rule transition transition set configuration accepted path configuration note transitions leading initial states behavior accepting run divided phases transitions mimics transitions mimics reaches state perform sequence pops possibly reaching state run reach state terms features original phase corresponds automaton accepting configuration reached starting configuration words accepts configuration iff language define characterizes pop sequences pop sequence sequence transitions starts configuration ends configuration iii transition sequence stack form non-empty sequence step stack shrinks remains unchanged pop sequence pop sequences canonical form start configuration end configuration pop sequences characterized complete derivation trees derived nonterminal psa grammar shown figure production psa psa psa fig context-free language pop sequences rules correspond production theorem pds pop sequence iff nonterminal psa grammar shown figure complete derivation tree derivation tree root psa preorder listing derivation tree production instances figure defines correspondence productions pds rules sequence rules pop sequence sequence rules derivation tree root psa proof sketch shrink stack removing stack symbol left-hand side rule transition sequence removes symbols stack component rule right-hand side words pop sequence left-hand-side stack symbol involve pop sequence right-hand-side stack symbol left-hand right-hand sides productions figure reflect popsequence obligations incurred rule capture set reachabilitywitnessesa recognized automaton define context-free language set productions acceptinga psa psa psa accepteda acceptinga language captures ways pds accept set reachability witnesses corresponds complete derivation trees derivable nonterminal accepteda subtree rooted psa pop 
sequence performs consume symbol reachability witnesses complete derivation trees root accepteda weighted pdss abstract grammar problems turning weighted pdss weighted version denoted weighted pds combined rule derivation tree complete terminal symbol leaf added due transition transition set assigned weight reason semiring sums weights paths characterized context-free grammars defined concept definition semilattice abstract grammar collection context-free grammar productions productiona form parentheses commas production terminal symbols productiona functiona string terminal symbols derived grammar yield complete derivation tree denotes composition functions corresponds unique ina call simply whena understood leta denote strings terminals derivable nonterminal abstract grammar problem compute nonterminal complete derivation trees root accepteda encode transition sequences accepts cast gpr grammar problem attach production functions productions rule sequence derivation tree yield havea figure note functionsa anda place beginning semiring-product expression corresponds preorder listing derivation tree production instances theorem production accepting fora anda accepted accepting fig abstract grammar problem gpr problem solve gpr problem appeal theorem theorem abstract grammar problem solved iterative computation finds maximum fixed point conditions hold semilattice infinite descending chains production functiona ina distributive arbitrary non-empty finite index sets production functiona ina strict argument abstract grammar problem figure meets conditions theorem definition operator associative commutative idempotent semilattice definition infinite descending chains distributivity production functions arbitrary non-empty finite index sets repeated application definition production functionsa strict argument annihilator respect definition production functionsa anda constants functions arguments meet required condition trivially algorithm solving gpr problem weighted pds initial configuration regular set represented automaton create combined weighted pds define abstract grammar problem schema shown figure solve abstract grammar problem finding maximum fixed point chaotic iteration nonterminal fixed-point-finding algorithm maintains current estimate maximum fixed-point solution initially values set updated right-hand side production left-hand-side nonterminal efficient algorithm gpr problem approach previous section efficient configuration takes time space create grammar productions figure left-hand-side nonterminal acceptinga improve algorithm previous section instantiations productions listed figure relevant final solution prevent algorithm exploring useless nonterminals grammar shown figure gpr questions respect target-configuration set involve subgrammar nonterminals ordinary pushdownreachability problem information complete derivation tree root nonterminal psa exists psa productive nonterminal precomputed returned form annotated automaton size exploring subgrammar lazily saves construct entire subgrammar productive nonterminals represent automaton transitions productions involve transition constructed on-the-fly algorithm shown figure straightforward algorithm solves grammar problem subgrammar figure set transitions algorithm input weighted pushdown system -automaton accepts transitions states output -automaton accepts function maps ofa psa abstract grammar problem defined figure procedure update begin changed end select remove transition return fig on-the-fly algorithm solving grammar problem subgrammar figure nonterminals updated considered line values set function call updatea computes transition created rule transitions ordered list lines process rules types lines represent fixed-point-finding loop line simulate processing rules types involve transitiona right-hand side line corresponds invocations production functionsa anda note line change smaller iterations continue values transitions stabilize empty fact algorithm simply expressing grammar problem subgrammar algorithm terminates computes desired result operations algorithm remarkably similar algorithm major difference transitions stored workset processed multiple times transition processed time complexity increases complexity unweighted case factor length maximal-length descending chain semiring annotated automaton configuration read automaton paths accepted accumulating path taking meet resulting set value-accumulation step performed straightforward extension standard algorithm simulating nfa algorithm algorithm determininga appendix describes extend algorithm additional annotations transitions path set obtained applications interprocedural dataflow analysis section describes application weighted pdss interprocedural dataflow analysis shows algorithm section generalize previously frameworks interprocedural dataflow analysis running section illustrates application approach linear constant propagation balakrishnan approach implement interprocedural dataflow-analysis algorithm due uller-olm seidl determines program point set affine relations hold program variables executed interprocedural dataflow analysis supergraphs exploded supergraphs interprocedural dataflow-analysis problems defined terms program supergraph shown figure supergraph consists int void main return void return emain call ret xmain call ret call ret fig program fragment supergraph environment transformer unlabeled edges collection control-flow graphs procedure represents program main procedure flowgraph procedure unique enter node denoted unique exit node denoted nodes flowgraph represent statements conditions program usual procedure call program represented supergraph nodes call node return-site node node-pairs figure addition ordinary intraprocedural edges connect nodes individual control-flow graphs procedure call represented call node return-site node supergraph edges intraprocedural call-to-return-site edge interprocedural call-to-enter edge enter node called procedure interprocedural exit-to-return-site edge exit node called procedure definition path length nodea node possibly empty sequence edges denoted source isa target target edge source edge path concatenation denoted notion interprocedurally valid path capture idea paths supergraph represent potential execution paths valid path respects fact procedure returns site recent call distinguish same-level valid path path starts ends procedure call return vice versa valid path path include unmatched calls definition sets same-level valid paths valid paths supergraph defined inductively empty path same-level valid path valid path path valid path exit-to-return-site edge valid path exit-to-return-site edge same-level valid path valid path source node call node matches return-site node target path same-level valid path ifa same-level valid path supergraph shown figure path same-level valid path path non-same-level valid path call-to-start edge matching exit-to-return-site edge path valid path exit-to-return-site edge correspond preceding call-to-start edge context-sensitive interprocedural dataflow analysis analysis called procedure sensitive context called context-sensitive nodes flowgraph represent individual statements conditions alternatively represent basic blocks analysis captures fact calls procedure arrive calling contexts sets execution states arise entry procedure precisely goal context-sensitive analysis find nodes supergraph remainder section considers interprocedural distributive environment ide framework context-sensitive interprocedural dataflow analysis applies problems dataflow information program point represented finite environment mapping finite set symbols finite-height domain values effect program operation captured environmenttransformer function supergraph edge transformer functions assumed distribute meet operation environments ide problems decidable variants constant-propagation problem copy-constant propagation linear-constant propagation interprets assignment statements form interprets statements form means explosion transformation ide problem transformed path problem program supergraph path problem graph larger edge labeled simpler edge function so-called micro-function micro-function edge captures effect symbol argument environment symbol result environment figure shows exploded representations environment-transformer functions linear constant propagation figure fig exploded representations environment-transformer functions linear constant propagation shows identity function represented figure figure show representations functions dataflow functions assignment statements vertices represent effects function independent argument environment graph includes edge form 
labeled edges needed capture function composition properly figure shows exploded supergraph corresponds program figure linear constant-propagation problem exploded supergraphs weighted pdss show solve linear constant-propagation problems context-sensitive fashion defining generalized pushdown reachability problem paths infinite-state transition system correspond valid paths exploded supergraph encode exploded supergraph weighted pds weights drawn semiring set set functions anda emain call xmain ret ret ret call call fig exploded supergraph program figure linear constantpropagation problem micro-functions function represented triple component needed meet functions represented details semiring semiring identity function representation denote identity function convention constant function represented operations defined assumed case combiner operator obtained equating terms taking solution provided integral control locations correspond program variables stack symbols correspond nodes supergraph exception edge exploded supergraph corresponds rule weighted pds encoding terms kinds edges occur supergraph weighted pds rules exploded intraprocedural edges intraprocedural edges main intraprocedural edges rule component tuple implies active procedure rest stack changed call site pds rule encodes edge exploded representation call-to-enter edge stack symbols right-hand side symbol return-site node pushed stack transitions call site transitions call site transitions call site process returning encoded popping topmost stack symbols stack transitions return obtaining dataflow information exploded supergraph weighted pds linear constant propagation interested generalized reachability problem configuration obtain dataflow information exploded supergraph weighted pds perform steps define regular language configurations interest creating automaton giving edge automaton weight apply algorithm create weighted automaton inspect -automaton find transition return weight transition answer write regular expression set configurations language stack contents defined bya query semiring configuration means program variable entered stack form main called called recursively arbitrary number times alternating recursive call sites witness-path set configuration singleton set consisting path semiring configuration rule rule weight configuration accepted query automaton situation stack form main calls calls finally calls case stack expected query semiring configuration case witness-path set configuration singleton set consisting path semiring configuration rule rule weight configuration accepted query automaton notice witness-path set configuration complicated case query case query involves regular operator conventional dataflow-analysis algorithms merge meet values program point calling context machinery paper strict generalization conventional dataflow analysis merged information obtained issuing query instance algorithms obtain tuple obtained query perform query semiring configuration means program variable entered stack form situation witnesspath set configuration consists paths share configurations semiring semiring configuration rule rule weight configuration accepted query automaton partitions arise analysis fig shows evolution successive iterations analysis single abstract memory configuration reaches exit loop analysis proceeds satisfy loop condition propagated body loop abstract state beginning iteration abstract memory configurations similar configuration assignment accepted query automaton complexity happen abstract memory dataflow-analysis algorithm configurations denote constraint number edges added supergraph numeric states denote number symbols auxiliary predicate domain environment changed encoding end exploded supergraph iteration pds leads variable pds incremented abstract memory control locations configuration transformed configuration loop rules condition hold regular language configurations memory interest configuration assume propagated encoded program point weighted automaton exit loop abstract memory configuration states transformed transitions abstract memory denote configurations maximal length descending chain memory semiring configurations formed micro-functions form cost abstract state beginning query obtain iteration dataflow information end worse time iteration abstract memory configuration transformed configuration space violates loop results condition section propagated clients program dataflow analysis point abstract advantage memory machinery configuration algorithm transformed construction abstract provide memory algorithm configurations interprocedural dataflow analysis loop demonstrated condition holds examples abstract state weighted-pds accumulated machinery dataflow head queries loop posed respect memory configurations regular language similar initial array stack partitions configurations numeric states strict generalization values kind auxiliary queries predicates abstract posed memory ordinary configurations interprocedural joined dataflow-analysis algorithms abstract memory clients configuration interprocedural joined dataflow analysis produce program similarly optimizers joined tools program resulting understanding offers widening applied ability provide widened features respect previously producing abstract unavailable memory program configuration optimizer make widened query respect dataflow values resulting pattern inline expansions optimizer determine performing explicit expansion inline expansion produce favorable dataflow values code optimized tool program understanding iteration users abstract pose memory queries configuration dataflow information transformed respect propagated program regular point language abstract initial memory stack configuration configurations transformed intomemory possibilities configurationss illustrated ands figure shows previously transformed encountered version program analysis figure stage transformed abstract program state takes advantage head information loop obtained stabilizes analysis terminates figure entered abstract stack memory configurations form reach program point partition arrays similarly analysis joins transformed program memory configurations calls produce mimic abstract state calling pattern single abstract memory configuration shown column original fig program easy replaced calls configuration represents concrete states values stored array range constraint numeric state element array equal element array index fact evaluates definite abstract semantics make abstraction previous sections usable define abstract counterparts concrete state copy transformers shown fig inlined shown simplified galois recursive connection call defined site abstraction calling function pattern concretization fails function mimic abstract transformer concrete transformer original denoted procedure expressed defines limit precision obtainable abstract domain non-constructive definition provide algorithm finding called applying implemented related work prototype connections analysis dataflow analysis tvla tool model checking defined overapproximations established past abstract state work transformers present tvla paper continues mechanisms space line considerations inquiry preclude makes giving full contributions account previous work modifications addressed neededto relationship applied model tvla checking bit-vector exact dataflow-analysis definitions problems predicates needed live-variable support analysis array partial-redundancy operations elimination rest paper section show give technique overview inspired tvla developed sketch model-checking techniques community modeling arrays generalized defining original abstract form transformers extension applied tvla tvla dataflow-analysis models problems concrete states first-order expressed logical bit-vector structures problems previous elements work structure universe temporal-logic represent expressions concrete objects dataflow-analysis predicates problems encode paper relationships results concrete based objects abstract basic states model-checking represented primitive three-valued logical structures constructed approach applying extends canonical ideas abstraction illustrated sets applying concrete states linear constant abstraction propagation performed identifying expressible set bit-vector abstraction problem predicates int representing void main concrete objects return abstraction void predicates evaluate values single element universe three-valued structure rest return paper refer abstract elements void inlined call nodes node represents single concrete object called end non-summary inlined node call node represent multiple concrete objects called return summary fig node tvla transformed distinguishes version types program predicates figure core takes predicates advantage instrumentation predicates fact core predicates figure predicates model entered concrete stack states instrumentation form predicates defined terms core predicates introduced bouajjani capture esparza properties toulli independently lost developed due similar abstraction framework abstract state transformer defined tvla queries sequence pushdown optional systems steps weights focus drawn step replaces semiring three-valued structure solve set overapproximations precise reachability questions three-valued structures concurrent communicating represent pushdown systems set method concrete obtaining states weights automaton original transitions structure significantly differs focus deriving materialize weights non-summary directly node summary obtained node fixpoint structures computation resulting matrix focus entries necessarily images transitions canonical abstraction sense automaton multiple obtain nodes weights abstraction semiring predicates evaluate infinite descending chains values provided precondition extender step operator filters commutative structures leads efficient property solution hold finite-chain case set case terms section algorithm time structures complexity produced focus generally preconditions model conditional statements update proportional step transforms semirings structures satisfy finite descending chains algorithm applies cases efficient solution closely related papers dataflow-analysis literature address demand-driven interprocedural dataflow analysis reps presented algorithms solve precondition demand versions interprocedural analysis problems obtained automatically reflect effect exhaustive counterparts assignment expressed statement logic programs changing making interpretation magicsets core transformation instrumentation predicates general transformation developed structure coerce step logicprogramming cleanup deductive-database operation communities sharpens creating updated efficient three-valued demand structures versions making bottom-up logic comply programs set globally tabulation defined integrity method constraints efficiently blur evaluating step recursive restores queries canonicity deductive databases coerced threevalued approach structures applying obtain canonical demand abstraction algorithms merging interprocedural nodes bit-vector problems abstraction subsequent predicates work evaluate reps horwitz values sagiv weextendedtvlawith extended thecapability logic-programming toexplicitly model approach numeric quantities class ifds added problems facilities gave associate explicit demand set numeric algorithm quantities ifds problems concrete object rely equipped magic-sets three-valued transformation logical structure exhaustive demand element algorithms summarizing solving numeric domain class represent ide problems values presented quantities abstract relationship states node algorithms three-valued paper structure similar relationship dimension summarizing exhaustive numeric domain demand tvla algorithms specification ifds language problems extended fourth permit approach obtaining numeric demand comparisons versions logical formulas interprocedural dataflowanalysis numeric algorithms updates investigated operations duesterwald affect gupta numeric states soffa approach performing numeric query updates collection evaluating dataflow numeric equations comparisons set flow creating graph removing merging edges duplicating nodes structure handled abstract transformers summarizing numeric domain focus andcoerce operations assume operation provided reversed domain flow augment functions numeric state reverse graph extra constraints approximate modeling inverses arrays forward encode flow concrete functions states equations program solved scalar demand-driven variable fixed-point-finding array procedure element corresponds demand algorithms element support universe ability first-order answer logical structure query define respect core user-supplied unary language predicate stack configurations scalar variable previous work dataflow array analysis predicates algorithms evaluate merge elements meet first-order values structure represent program point calling context addition past work demanddriven dataflow analysis examined issue providing witness set paths show answer dataflow query configuration reported ifds framework extended ability answer query respect language stack configurations applying reachability algorithms unweighted pdss graphs approach scalar variable work element general ide array framework paper shown rest extend elements ide element framework answer universe query respect numeric language quantity stack represents configurations recent array generalization element pds reachability extra algorithms numeric weighted quantity pdss represents noted index position algorithms array model algorithm array structure solving gpr tvla problems correctly extra section predicates required guaranteed model terminate adjacency ide relation problems array elements algorithms introducing binary terminate instrumentation predicate problems array predicate problems evaluates general evaluated problems adjacent elements set micro-functions array model infinite descending property chains indices array asymptotic elements cost contiguous algorithm paper repeat introduce cost unary demand instrumentation algorithm predicate solving ide array problems encodes transitive closure algorithm strictly adjacency relation general partitioning functions algorithm presented defined unary instrumentation application predicates theory partitioning pdss function interprocedural dataflow evaluate analysis values proposed esparza predicate knoop evaluate considered bit-vector problems predicates encode faint-variables problem ifds problem appendix problems solved certaina anda queries respect work extension pdss weighted pdss approach solve 
general class dataflow-analysis problems esparza knoop techniques handle witness-set generation algorithm extend algorithms esparza knoop bit-vector problems flow-graph systems parallelism addressed uller-olm seidl interprocedural dataflow-analysis algorithm determines program point set affine relations hold program variables executed method re-cast solving logic-programming terminology exhaustive algorithm straightforward implementation logic program demand algorithm obtained applying magic-sets transformation gpr problem asymptotic complexity balakrishnan created prototype implementation method wpds library model checking pdss previously verifying security properties programs methods paper permit powerful security-verification algorithms developed weighted pdss obtain broader class interprocedural dataflow information verification process acknowledgments seidl making aho sethi ullman compilers principles techniques tools addisonwesley bancilhon maier sagiv ullman magic sets strange ways implement logic programs proceedings acm symposium principles database systems york acm press bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur volume lec notes comp sci pages springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures proc symp princ prog lang pages chen wagner mops infrastructure examining security properties software conf comp commun sec november cousot cousot temporal abstract interpretation symp princ prog lang pages duesterwald gupta soffa demand-driven computation interprocedural data flow symp princ prog lang pages york acm press esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proc computer-aided verif volume lec notes comp sci pages july esparza knoop automata-theoretic approach interprocedural data-flow analysis proceedings fossacs volume lncs pages springer esparza cera schwoon model-checking ltl regular valuations pushdown systems proceedings tacas volume lncs pages springer horwitz reps sagiv demand interprocedural dataflow analysis proceedings acm sigsoft symposium foundations software engineering pages york october acm press jensen metayer thorn verification control flow based security properties ieee symposium security privacy jha reps analysis spki sdsi certificates model checking ieee comp sec found workshop csfw ieee computer society press knoop steffen interprocedural coincidence theorem int conf comp construct pages moencke wilhelm grammar flow analysis alblas melichar editors attribute grammars applications systems volume lec notes comp sci pages prague czechoslovakia june springer-verlag uller-olm seidl computing interprocedurally valid relations affine programs tech rep comp sci dept univ trier trier ger january ramalingam bounded incremental computation volume lec notes comp sci springer-verlag reps demand interprocedural program analysis logic databases ramakrishnan editor applications logic databases kluwer academic publishers reps solving demand versions interprocedural analysis problems fritzson editor proceedings international conference compiler construction volume lec notes comp sci pages edinburgh scotland april springer-verlag reps horwitz sagiv precise interprocedural dataflow analysis graph reachability symp princ prog lang pages york acm press reps sagiv horwitz interprocedural dataflow analysis graph reachability tech rep datalogisk institut univ copenhagen http wisc wpis papers diku-tr sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci schmidt data-flow analysis model checking abstract interpretations symp princ prog lang pages york january acm press schwoon wpds library weighted pushdown systems http tum schwoon moped wpds schwoon jha reps stubblebine generalized authorization problems comp sec found workshop wash ieee comp soc sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs steffen data flow analysis model checking int conf theor aspects comp softw volume lec notes comp sci pages springer-verlag steffen generating data flow analysis algorithms modal specifications sci comp prog warren memoing logic programs communications acm march generation witness sets section efficient algorithm determining section addresses question obtaina problem examining infinite graph nodes pairs configuration edge labeled configuration finding means identifying set paths path leads words proves computed algorithm note properties general larger situation paths values single path small witness set paths set witness set indirectly form annotation called transitions data structures called wnode wstruc transition holds wnode denote entity wnode set wstruc items wstruc item form back rule algorithm procedure update begin return create create end fig modified update procedure sequence wnodes indicating missing extend algorithm idea execution partitioning function auxiliary predicates directly correspond unary instrumentation predicates perform abstraction select set abstraction predicates predicates scalar variables arrays predicates encode transitive closure adjacency relations array predicates implement partitioning functions auxiliary predicates non-abstraction predicates resulting three-valued structures directly correspond abstract memory configurations defined sect transformers statements require array repartitioning conditional statements assignments array elements scalar variables index array elements modeled trivially transformers statements change array partitioning updates scalar variables index array elements defined focus applied structure materialize array element indexed variable update scalar variable interpretation partitioning predicates updated finally blur merge array element indexed variable previously summary node update interpretation auxiliary predicates programmer supply predicate-maintenance formulas statement change values predicates reflect numeric properties encoded auxiliary predicates numeric state grouping concrete array elements set integrity constraints implied auxiliary predicates supplied integrity constraints update formulas auxiliary predicates conversion arbitrary program tvla specification performed fully automatically future plan extend technique differencing logical formulas capability handle numeric formulas extension automatically compute safe abstract transformers auxiliary predicates technique fully automate analysis involves decision procedures symbolically computebest abstract transformers experiments section describe application analysis prototype simple examples simple heuristic obtain set partitioning functions array analyzed examples array access program added partitioning function set approach worked examples insertion-sort implementation required addition extra partitioning function array initialization fig shows piece code initializes array size array element assigned equal index position array purpose illustrate analysis automatically discover numeric constraints values array elements array-partitioning heuristic produces single partitioning function analysis establishes code executed values stored array range human intervention form introducing auxiliary predicates required int figure array-initialization loop int figure partial array initialization contrast approaches capable handling require predicate specifies expected bounds values array elements supplied explicitly user automatic 
abstraction-refinement technique partial array initialization fig complex array-initialization code repeatedly compares elements arrays case equal writes index position array portion array initialized depends values stored arrays scenarios elements initialized initial segment initialized iii initialized purpose illustrate handling multiple arrays partial array initialization array-partitioning heuristic derives set partitioning functions array analysis establishes loop elements array indices initialized values ranging auxiliary predicates abstract state reaches exit loop abstract memory configurations configuration represents concrete states array elements initialized domain element equal array partition abstract element memory configurations represent concrete states initial segment array initialized memory configurations required represent case analysis distinguishes case variable indexing element middle array case indexing element array abstract memory configuration represents concrete states elements array initialized concrete states represented memory configuration variable equal variable elements array represented abstract array element void sort int int int break figure insertion-sort procedure initialized array elements represented abstract array element array partition memory configuration element elements initialized numeric states abstract memory configurations capture property values initialized array elements range insertion sort fig shows procedure sorts array insertion sort parameter specifies size array invariant outer loop array sorted i-th element loop inserts i-th element sorted portion array interesting detail implementation elements inserted sorted portion array reverse order purpose demonstrate application analysis challenging problem application array-partitioning heuristic yields partitioning sufficient variable partition array sorted segment array separate unsorted segment explicitly index array elements array-partitioning heuristic fails add set partitioning functions successfully analyze manually add summarizing numeric domains preserve order summarized array elements auxiliary predicate defined similarly predicate introduced prototype implementation requires user involvement explicit update formulas predicate program statements fortunately majority program statements affect predicate update formula statements identity function non-trivial case assignment array element human involvement necessitated analysis minor problem-specific auxiliary predicate introduced predicate specific implementation sorting algorithm reused analysis implementations analysis sorting algorithms identifies directions future research designing techniques automatic array partitioning automatically discovering maintaining auxiliary predicates results ran analysis prototype intel-based linux machine equipped ghz pentium processor memory fig shows measurements collected analyzing examples discussed measurements severely affected decision implement analysis prototype tvla tvla general framework structure array modeled explicitly introducing number instrumentation predicates integrity constraints majority analysis time spent executing focus coerce operations ensure array structure preserved measurements fig average focus coerce account analysis time building dedicated analysis implementation knowledge linear structure arrays built abstract state transformers recover majority time shortcoming analysis prototype number nodes represent array tvla larger number abstract objects created array partitioning sect extra nonsummary nodes represent elements array result reported number abstract objects abstract memory configuration number memory configurations abstract state greater dedicated analyzer encounter factor slows analysis polyhedral numeric domain offering superior precision polyhedral numeric domain scale number dimensions grow property apparent polyhedron represents abstract state multidimensional hypercube array copy constraints values elements arrays form -dimensional hypercube explanation analysis takes minutes constraints values array excluded initial abstract state analysis takes seconds observation numeric constraints arise analysis led precise efficient weakly-relational domains speed analysis examples sacrificing precision reran analysis array copy summarizing extension weakly-relational domain analysis verify desired properties seconds significant improvement time takes perform analysis polyhedral domain conclusions canonical abstraction powerful technique static analysis represent potentially unbounded set concrete objects bounded number abstract objects partitioning imposed set concrete objects dynamic sense abstract object represent groups concrete objects abstract state net result ability avoid perexample abstract memory configurations amcs time time max amcs state max nodes amc coerce focus sec array initialization partial initialization array copy insertion sort figure analysis measurements maximal number abstract memory configurations abstract state maximal number abstract objects abstract memory configuration percentage analysis time spent focus coerce operations analysis time forming weak updates greatly improves precision analysis paper explore possibilities combining canonical abstraction existing numeric analyses applications combined analysis problem analyzing array operations analysis define paper capable automatically establishing interesting array properties show capture numeric constraints values array elements array-initialization loop sophisticated properties verifying implementation comparison-based sorting algorithms require human intervention define auxiliary predicates abstract transformers auxiliary predicates introduced problem-specific program-specific reused analysis programs prototype implementation analysis efficient analyze interesting array operations reasonable times bagnara ricci zaffanella hill possibly closed convex polyhedra parma polyhedra library static analysis symp volume pages blanchet cousot cousot feret mauborgne min monniaux rival design implementation special-purpose static program analyzer safety-critical real-time embedded software essence computation complexity analysis transformation pages springer-verlag cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points symp princ prog lang pages york acm press cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press cousot halbwachs automatic discovery linear constraints variables program symp princ prog lang flanagan qadeer predicate abstraction software verification symp princ prog lang pages gopan dimaio dor reps sagiv numeric domains summarized dimensions tools algorithms construction analysis systems pages halbwachs proy roumanoff verification real-time systems linear relation analysis formal methods system design lahiri bryant indexed predicate discovery unbounded system verification int conf computer aided verification pages lamport approach proving correctness multiprocess programs trans prog lang syst july lev-ami sagiv tvla system implementing static analyses static analysis symp pages manevich sagiv ramalingam field partially disjunctive heap abstraction static analysis symp pages masdupuy array indices relational semantic analysis rational cosets trapezoids phd thesis ecole polytechnique mine octagon abstract domain proc eighth working conf rev eng pages mine graph-based relational numerical abstract domains static analysis symp pages peterson myths mutual exclusion problem information processing letters june reps sagiv loginov finite differencing logical formulas static analysis european symp programming pages reps sagiv yorsh symbolic implementation transformer verification model checking abstract interpretation pages sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst cern erification par interpr etation abstraite edicats param etriques report univ paris vii ecole normale erieure september yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis tools algorithms construction analysis systems pages 
item ina denotes suppose accepting path starting witha configuration accepted path pushdown system path family paths path starts accepting path successor configuration constructed replacing transitions wnodes concrete modifications algorithm line set line create wnode set figure shows revised update procedure line figure computes newly discovered transition line records path discovered line update change line addition strictly smaller path path incomparable line creates set consisting previous paths path incomparable approximate elements procedure minimize shown removes fairly straightforward information contained reconstruction witness set involving wnode created execution wnodes created earlier process reconstructing witness set decoding wnode wstruc information eventually terminate configuration execution modified algorithm wnodes transitiona created referenced moment wnodes referenced transitions garbage collector track remove nodes longer chain transition 
start success abort send wait failnack ack timeout send fail failsend calls calls nack send wait ack timeout fail nack send wait ack timeout fail start abort success send analysis spki sdsi certificates model checking jha reps computer sciences department wisconsin dayton street madison e-mail fjha repsg wisc abstract spki sdsi framework expressing naming authorization issues arise distributed-computing environment paper establish connection spki sdsi formalism pushdown systems pdss show spki sdsi-to-pds connection framework formalizing variety certificate-analysis problems connection computational significance analysis problems solved efficiently time polynomial size certificate set existing algorithms model checking pushdown systems keywords spki sdsi model checking pushdown system naming authorization certificate-chain discovery certificate-set analysis introduction systems shared resources access-control mechanisms protection fundamental problems access control authorization enforcement authorization addresses problem request specific principal allowed enforcement addresses problem enforcing authorization execution centralized system authorization based closed-world assumption parties trusted distributed system work supported part national science foundation grant ccrby office naval research contracts alexander von humboldt foundation government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government closed-world assumption valid trust management systems solve authorization problem distributed systems defining formal language expressing authorization access-control policies rely algorithm determine specific request allowable survey trust management systems formal framework understanding presented prominent trust management systems keynote spki sdsi spki sdsi framework expressing naming authorization issues kind arise distributedcomputing environment spki sdsi certificates define names issuer local space spki sdsi authorization certificates grant authorizations delegate ability grant authorizations clarke considered problem discovering certificate chain authorization respect set spki sdsi certificates certificate chain proof client public key keys authorized access resource directly transitively name-definition authorizationdelegation steps paper studies problem certificate analysis context spki sdsi establish connection spki sdsi formalism pushdown systems pdss work stems simple observation set spki sdsi authorization certificates defines pds significance connection contributions made paper summarized spki sdsi-to-pds connection framework formalizing variety certificate-set analysis problems certificate-set analysis problem model checking pushdown systems analysis flavors model checking henceforth otherproblems stated precisely standard formalisms posing model-checking queries problems include authorization problem addressed clarke authorized access resource principal authorized access questions interested respect certificate set authorized access resource necessarily principal authorized access authorized access resource names necessarily principals authorized access shared access resources principals access shared access principals resources accessed compromisation assessment resources principal gained access solely due presence maliciously accidentally issued certificate set compromisation assessment principals gained access resource solely due presence maliciously accidentally issued certificate set expiration vulnerability resources principal prevented accessing certificate set expires expiration vulnerability principals excluded accessing resource certificate set expires universally guarded access case authorizations issued resource involve certificate signed principal universally guarded access case authorizations grant principal access resource involve certificate signed wise noted term model checking refers model checking pushdown systems background problem section general infinite set shown answer form finite-state automaton accepts names authorized access analysis problems listed solved efficiently time polynomial size certificate set existing model-checking algorithms pdss case certificate-chain discovery show operation subroutine algorithms model checking pdss algorithm problem special-purpose algorithm certificate-chain discovery developed clarke worst-case asymptotic running time algorithm clarke improved handling tabulated data lead asymptotic improvement family examples clarke illustrate worst-case upper bound tight constant factor family examples algorithm exhibit worst-case behavior section addition annotating data-structures labels lattice enables answer additional questions section specific authorization expire section show algorithm adapted answer authorization questions distributed manner distributed algorithm framework provided clarke remainder paper organized section introduction spki sdsi describes algorithm certificate-chain discovery section appendix provide background model checking pushdown systems section discusses applications formal machinery certificate-set analysis problems section discusses related work appendix details certificate-chain reconstruction appendix presents definitions pertaining lattices section paper structured self-contained deals problem domains kinds arrows denote relationships kinds objects summarized table readers familiar skip sections minor notational differences papers footnotes background spki sdsi spki sdsi principals represented public keys principal individual process host active entity spki sdsi make distinction principal public key principal public key denotes set public keys specific keys denoted data-structure issues rek spki sdsi cert spki sdsi auth cert delegation bit spki sdsi auth cert delegation bit transition rule pds immediate-successor relation pds transitive closure immediate-successor relation pds reflexive transitive closure immediate-successor relation pds reachability relation states configuration automaton relation configuration automaton table kinds arrows paper lated representation keys found identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys locals names extended names local form identifier bob local local names important spki sdsi create decentralized space set local names denoted local space local names form denoted extended form sequence identifiers length greater faculty extended set extended names denote set extended names beginning key set names space key set terms certificates spki sdsi types certificates certs type certificate called certs definitions local names authorizations authorization certs auth certs short certificates cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification information validity certificate validity specification takes form interval cert valid time inclusive validity specification form on-line check performed complete explanation validity specifications context authorization problem generally ignore validity specification assume working exclusively valid certificates extensions handle types validity specifications discussed section authorization certificates auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert issuer granting specific authorization subject term delegation bit turned key receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert treat certs rewrite rules cert written auth cert written delegation bit turned written faculty faculty bob bob alice alice figure complete set certs pair auth cert refers resource primarily interested questions resources questions individually generally write auth cert general resources denoted authorization section describe authorization illustrative purposes paper traditional discretionary access control protected resource access-control list acl describing principals permissions access resource auth cert viewed acl entry keys principals represented subject permission access resource instance suppose alice login host resource initially monitor denies access reports acl entry written auth cert alice faculty set certs shown figure alice prove authorized access name-reduction closure describe algorithm 
reader referred additional details define concept closure set certificates term appearing rules viewed string alphabet elements beginning uniformity refer strings form terms assume rewrite rule cert term case rewrite rule applied term denoted yields term rule viewed function terms terms bob bob myfriends myfriends term rule called compatible form give set certificates term define set compatible define composition rewrite rules rules assume prefix exists composition rules rule rules friends bob myfriends bob composition previous rules rule friends myfriends rules called compatible composition defined set certificates closure denoted smallest set certificates includes closed composition general infinite computed directly set certificates closure set set certificatesc defined words set keys obtained rewrite rules set certs applications granted authorization key indirectly granted authorization instance authorization section shown faculty alice authorized login host closure set certs infinite concept name-reduction closure introduced rule application write composition write finally faculty faculty faculty figure additional rules added namereduction closure reducing cert form reduction composition compatible rules reducing cert name-reduction closure set certificates defined smallest set certificates closed reduction set certs equality proved words safe inspect name-reduction closure order find set keys correspond return authorization describe four-step procedure determining principal authorized access resource set certificates remove useless certificates auth certificates removed set auth certs authorization tag refer resource removed reduction compute name-reduction closure set name-reduction closure set shown figure yields additional certs shown figure depth-first search remove rules form rules remain step remove rules form construct graph vertex key edge rule form edges fourth perform depthfirst search determine path path alice key alice granted permission login host reconstruct certificate chain information previous steps create certificate chain proves principal authorized access desired resource certificate chain proves alice authorized login host certificate-chain reconstruction requires additional information stored algorithm perform name-reduction closure smallest size certificate chain exponential number certs desirable report certificate chains factored form chapter discuss time space complexity namereduction closure set certificates number keys occurring typical certificate form reduction obtain rule form reductions obtain rules form kiai reductions obtain rule form possibilities keys nkm possibilities rules generated jcj sum lengths right-hand sides rules occur maximum number rules produced nkjcj rule compatible reducing certs rule result work time complexity name-reduction closure kjcj number nodes edges graph constructed depth-first-search step bounded time complexity depthfirst search authorization procedure time complexity name-reduction closure step dominates running time procedure number rules produced bounded nkjcj space complexity procedure nkjcj term appears depth-first search data structures representing certs discussed detail elien thesis background model checking pushdown systems section background model checking pushdown systems pdss material paper largely based paper esparza detailed treatment model checking pdss including computational complexity problems found pushdown system triple finite set control locations finite stack alphabet finite set transition rules write pushdown systems similar pushdown automata unlike pushdown automata input alphabet pdss viewed language recognizers mechanisms possibly infinite-state transition systems configuration pair control location represents stack contents set configurations denoted surface configuration pair configuration predecessor wvi wvi successor denoted wvi reflexive transitive closure reachability relation transitive closure immediate-successor relation denoted run sequence configurations predecessor set configurations set predecessors denoted pre reflexive transitive closure pre denoted pre pre set successors post set configurations defined similarly reflexive transitive closure post denoted post understood write pre pre post post computing pre assume pushdown system regular set configurations ofp represented finite-state automaton called configuration automaton ofp input alphabet isp stack alphabet symbol denotes reflexive transitive closure predecessor relation predecessor relation reflexive transitive closure figure automaton accepts fhp formally configuration automaton automaton finite set states set locations subset set transitions set initial states set final states configuration automaton reachability relation denoted defined smallest relation satisfying henceforth refer configuration automaton simply automaton automaton accepts recognizes configuration set configurations recognized automaton denoted conf pds consists transition rules automaton shown figure recognizes set configurations fhp assume regular set configurations accepted automaton shown set configurations pre regular automaton recognizing pre constructed adding transitions saturation rule add transitions automaton added current automaton add transition ppp ppp ppp ppp pppq figure automaton accepts pre fhp fhp theorem pds configuration automaton exists automatonapre recognizes pre conf apre constructed time nqn space jqj sum lengths right-hand sides transition rules length right-hand side transition rule maxf jwjg pds recall automaton figure recognizes set configurations fhp automaton recognizes pre shown figure transition rule self-loop added transition rule fact holds transition added transition rule fact holds transition added automaton shown figure accepts set configurations fhp fhp computing post pds regular set configurations represented automaton assume transition rulehp satisfies jwj assumption involves loss generality pds satisfy constraint converted suppose general pds transition rule add control locations replace original rule transition rules hpi hpi hpk assume regular set configurations automaton construct automaton apost accepts post automaton apost obtained phases phase transition rule form add state transition phase saturation phase phase transitions added automaton rules added symbol denotes relation rules adding transitions current automaton add transition ifhp current automaton add transition current automaton add transition theorem pushdown system configuration automaton exists automaton apost recognizing post conf apost constructed time space jpj jqj note complexities mentioned theorems refer improved versions algorithms presented pds transition rules figure automaton accepts fhp figure automaton accepts post fhp automaton shown figure accepts set configurations fhp automaton post shown figure states labeled correspond transition rules label automaton shown figure accepts set configurations fhp model checking linear-time logics finite set atomic propositions ltl formula atomic propositions reader consult chapter syntax semantics ltl pds labeling function associates set atomic propositions surface configurationhp extension set atomic propositions hold configuration interested model-checking problem configuration ltl formula determine satisfies summary ltl model-checking procedure found appendix spki sdsi pdss section explores connection spki sdsi pdss demonstrates authorization problem variety certificate-set analysis problems viewed model-checking problems pdss assume set certs set keys identifiers resources denoted construct pds set locations key resource represents control location stack alphabet stack alphabet set identifiers filled unfilled squares encode delegation bits set transition rules rule iff certs correspond transition rules assume set certs term term corresponds configuration ami pds lemma establishes correspondence closure set certs reachability relation pds lemma assume 
set certs pds term terms words equality post set certificates suppose interested determining principal authorized access resource options solve authorization problem pre post proof authorization run pds starts configurationhr ends configurations set fhkp hkp terms pre post condition formalized pre fhkp hkp post fhr fhkp hkp algorithms based conditions referred apre apost spki sdsi algorithm section referred aspki sdsi based lemma theorem easy prove theorem principal granted authorization access resource algorithm aspki sdsi iff algorithm apre grants authorization access principal granted authorization access resource algorithm aspki sdsi iff algorithm apost grants authorization access algorithm apre works construct pds set certs set configurations fhkp hkp construct automaton fsg fsg conf algorithm section create automaton pre grant authorization iffhr iis accepted automaton pre complexity algorithm apre analyzed case single resource number states automaton one-to-one correspondence transition rules certs set equal jcj number transitions automaton invoking theorem obtain time space complexity apre kjcj nkjcj notice asymptotic complexity clarke obtain algorithm aspki sdsi section set configurations shown figure pds case control locations stack alphabet sets frh kag fuw faculty bob alice hrh faculty uwi csi facultyi bobi bobi hkb hkb alice alicei hka figure set transition rules transition rules shown figure interested authorization alice key set configurations fhka hka configuration automaton accepts defined fsg fsg automaton constructed pre shown figure note configuration hrh accepted automaton principal alice authorized login host describe detail algorithm apost construction post suppose interested determining principal authorized access resource set certificates algorithm solving authorization problem construct pds set certs set configurations fhr construct automaton fsg fsg conf computing post transform pds transition rules satisfy jwj add state transition rule form add transition automaton finally complete construction automaton post repeatedly applying saturation rule grant authorization iff hkp hkp accepted automaton post analyze complexity algorithm case single resource number states automaton theorem obtain time space complexity apost jcj ppp ppp ppp ppp ppppq faculty alicebob figure automaton accepts set configurations pre fhka hka set certs shown figure pds set certs explicitly constructed recall post algorithm assumes transition rule satisfies jwj rule satisfy constraint hrh faculty transform pds adding locations adding rules iii deleting rule hrh faculty facultyi facultyi csi csi original transition rules pds stack symbols right-hand side hkb alice configuration automaton accepts set fhrh defined fsg fsg phase construction section automaton components fsg set shown figure automaton constructed post shown figure note configuration hka accepted automaton principal alice authorized login host certificate-chain reconstruction threshold subjects describe augment automaton constructed algorithm apre extra information purpose certificate-chain reconstruction apost augmented similarly faculty alice figure set transitions automaton pre created adding transitions saturation rule transitions added current automaton add transition transition automaton associate set identifiers transition rules initially set empty transitions automaton intuitively set represents transition rules caused transition added transition rule fact holds automaton transition added automaton identifier transition rule added set identifiers transition completion pre construction certificate chain reconstructed starting identifier transition tracing back tracing-back procedure conceptually simple details provided appendix threshold subjects handled framework introducing extra keys section certificate-set analysis problems section discusses applications model checking specific certificate-set analysis problems sso faculty faculty bob alice figure automaton accepts set configurations post show model checking furnishes algorithms analysis problems listed introduction term model checking problem checking pds satisfies ltl formula problem answering simple forward backward reachability queries stated terms set-former expressions basic automaton-building operations pre post set certs set configurations write pre pre similarly post written post authorized access resource principal authorized access pre fhk alternatively fhk post fhr authorized access resource authorized access pre alternatively post fhr authorized access resource names authorized access post fhr shared access resources principals access post fhr post fhr shared access principals resources accessed pre fhk pre fhk compromisation assessment resources principal gained access solely due presence maliciously accidentally issued certificate set pre fhk pre fhk compromisation assessment principals gained access resource solely due presence maliciously accidentally issued certificate set post fhr post fhr expiration vulnerability resources principal prevented accessing certificate set expires compromisation assessment expiration vulnerability principals excluded accessing resource certificate set expires compromisation assessment universally guarded access case authorizations issued resource involve certificate signed principal ltl model checking labeling defined surface configurations involve location labeled atomic proposition surface configurations labeled atomic proposition configurationhr satisfies ltl formula universally guarded access case authorizations grant principal access resource involve certificate signed ltl formula generalized authorization problems schwoony jhaz repsz stubblebinex abstract paper defines framework formalize variety authorization policy issues arise access control shared computing resources instantiations framework address issues privacy recency validity trust paper presents efficient algorithm solving authorization problems framework approach yields algorithms number specific authorization problems introduction main issues access control shared computing resources authentication authorization enforcement identification principals handled authentication authorization addresses question request specific principal allowed enforcement addresses problem implementing authorization execution centralized system authorization based closed-world assumption authorized parties trusted distributed system parties priori closed-world assumption applicable trust management systems address authorization problem context distributed systems requiring authorization access-control policies defined explicthis work supported part national science foundation grant ccrby office naval research contracts alexander von humboldt foundation stuart stubblebine supported nsf contracts ccr government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon views conclusions contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government yinstitutsverbund informatik universit stuttgart breitwiesenstr stuttgart germany e-mail schwoosn informatik unistuttgart zcomp sci dept univ wisconsin dayton madison e-mail fjha repsg wisc xstubblebine research labs llc wayne blvd madison e-mail stuart stubblebine itly specification language relying algorithm determine specific request allowable survey trust management systems formal framework understanding presented trust management systems binder keynote referee spki sdsi proposed work presented context spki sdsi aspects approach carry trust management systems authorization frameworks spki sdsi principals public keys identity principal established checking validity public key spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations fundamental problem spki sdsi trust management system authorization problem defined security policy spki sdsi represented set authorization certificates principal access resource certificate-chain discovery refers problem finding proof access resource case spki sdsi proof chain certificates found proof presented checks validity proof proof valid allowed access algorithms certificate-chain discovery frameworks proof-carrying authorization efficient algorithm spki sdsi presented clarke improved algorithm presented jha reps algorithm based translating spki sdsi certificates rules pushdown system demonstrated translation enables questions answered security policy expressed set certificates paper generalize pushdown-systems approach enable address important security-policy issues privacy recency validity trust instance authorization suppose company additional insurance cover prescription-drug expenses covered patient health-maintenance organization hmo hmo high deductible drugs covered additional insurance company provide service patients hospital alice buy insurance prove patient suppose certificate chains prove alice patient reveals alice patient internal-medicine clinic reveals alice patient aids clinic obvious reasons alice prefer chain words alice prefers certificate chain reveals amount information privacy-related issues addressed generalized framework context spki sdsi assume metric certificate chains proofs authorization details metric depend specific issue addressed generalized authorization problem gap principal set authorization certificates resource metric certificate chains question gap addresses authorized access resource authorization proof solves gap minimizes maximizes metric depending application demonstrate security-policy issues trust management systems cast gaps metrics demonstrate extension pushdown systems called weighted pushdown systems solve generalized authorization problems algorithm solving gaps thought generalization algorithm general strategy set labeled spki sdsi certificates translated weighted pushdown system translation answer obtained solving generalized shortest-path problem main contributions work reported paper gap framework define generalized authorization problem show versions types security issues related authorization handled gap framework efficient algorithm solving gaps present efficient algorithm solving gaps yields algorithms number specific authorization problems prototype implementation algorithms paper implemented library gap certificate labeled label depend global property recency policies certificate represents time certificate issued current functionality solving gaps library made internet parties remainder paper organized section background spki sdsi section defines gap framework discusses applications section case background labeling defined pushdown systems pdss surface section configurations reviews involve connection location spki sdsi labeled pdss atomic section proposition defines weighted surface pdss configurations shows analysis transition labeled system atomic defined proposition weighted pds solve surface gaps configuration section returns discussion satisfies ltl applications formula gap efficiency framework section automaton discusses related representation clarke give work worst appendix case describes enhancement name-reduction-closure algorithm algorithm section generate witnesses proofs illustrate efficiency authorization background automaton spki representation sdsi principals set names configurations spki sdsi set principals certificates represented public keys principal public key principal individual process host active entity denotes set public keys specific keys denoted identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates mod spki sdsi types rule certificates certs represents string certificates length name-reduction closure yields certs cert rules definition local pds set certificates true post fhk cig equal set issuer configurations local fhki akbji space key issue sign cert defines local size space set cert post signed fhk cig fourtuple issuer automaton public representation key post fhk cig certificate size signed basic idea identifier subject pair keys stack term intuitively configuration hki post additional fhk meaning cig iff hkj local automaton representation validity commonalities specification certificate captured means takes sharing form interval automaton accepting cert set valid configurations time post fhk inclusive cig validity states specification represent stack form configurations on-line akbj check locations performed representing authorization certificates keys auth certs -edges auth cert a-edges grants pointing delegates specific authorization shared issuer states lattice subject labellings specifically auth section cert describes five-tuple annotating pds issuer public configuration key automaton labels sign cert lattice subject answer term questions delegation bit turned long subject specific receiving authorization authorization delegate trust authorization level principals authorization authorization specification definitions specifies related permission lattices granted found appendix permission cert read specific set file annotated permission login label host lattice validity specification pds auth cert transition rule case pds cert label request cert triple recall consisting algorithm apre principals constructs automaton pre resource access set authorization configurations specification fhkp hkp start exercise automaton goal accepts certificate-chain set discovery configurations prove transition request valid automaton clarke labeled remove element useless certificates lattice denoted remove auth initially cert transitions invalid validity automaton specification labeled expired add validity transitions specification remove automaton auth cert saturation rule imply authorization specification current request automaton add rest transition paper assume label request transition set certificates computed useless certificates treat certs rewrite transition rules cert written auth cert labelings individual written transitions extended labelings delegation bit paths turned taking meet written labels transitions authorization path problems labeling valid composite certificates transitions validity specification obtained certificate join part labels rewrite rule paths generalized authorization interval problems lattice derive weights lattice intervals rules authorization form problem spki sdsi non-negative traditional integers discretionary access control current time protected resource represent access-control interval list acl describing top principals bottom elements permissions intervals access resource auth meet cert join viewed intervals acl entry keys minfi principals represented maxfi subject label permission cert access resource interval term representing appearing rules validity viewed period string alphabetk label elements ofk transition beginning uniformity automaton refer produced strings algorithm form apre terms authorization assume valid rewrite rule time cert case alice term authorized case rewrite rule login applied host term denoted monitor yields term information rule log-off alice viewed function time terms units terms lattice trust bob levels bob myfriends lattice myfriends ordered rules addition bottom top elements assume lattice prefix intuitively lattice exists represents trust levels low composition medium high rule trust levels denoted rules friends meet bob myfriends join elements bob composition friends myfriends rules assume called cert compatible labeled composition element defined lattice problem solved assigned label authorization question principal set certs assigns request high level trust allowed cert exercise authorization case algorithm label simple transition answer authorization question automaton constructed case 
algorithm apre represents trust level alice authorization label exists certificate chain labels label justifies granting authorization alice trust level monitor making authorization decisions distributed authorization computer sciences department uwmadison college letters sciences departments biology assume resource accessible faculty department belongs system administrator issue set certs cls kls faculty kls faculty kcs faculty kls faculty kbio faculty certs departments system administrator issue set certs ccs kcs faculty certs faculty members kcs students certs students determine principal authorized access resource clarke setting compute name-reduction closure set certs cls ccs proceed realistic setting sizes sets ccs cls large computing closure union require significant time space algorithms presented authorization question determined distributed manner work partitioned compute sets post cls fhr pre ccs fhkb hkb intersection non-empty standard operation automata granted authorization similar operation answer authorization questions departments bio notice name-reduction closure cls ccs yield certificates procedure proposed clarke provide basis distributed authorization-resolution procedure related work clarke considered problem discovering certificate chains spki sdsi algorithm based idea computing name-reduction closure certificate set problem model checking pushdown systems addressed present paper shown techniques papers solve problem discovering certificate chains provide answers broad array questions pose set spki sdsi certificates pds-based authorization algorithms compute actual closure certificate set namereduction closure fair amount research exists formal semantics spki sdsi research geared giving formal semantics local spaces tuple-reduction rules spki sdsi spki sdsi-to-pds connection presented paper alternative semantics spki sdsi names spki sdsi space identified configurations transition system defined pds compared existing work spki sdsi-to-pds connection advantages invent logic semantic account number aspects spki sdsi leverages substantial body research exists subject model-checking pdss parin general technical conditions hold approach correct principal refer local domain certs organized hierarchically ticular immediately obtains polynomial-time algorithms number certificate-set analysis problems benedikt showed pushdown systems equivalent unrestricted version hierarchical state machines hsms introduced restricted form alur yannakakis hierarchical means system consists state machines call unrestricted hsms recursive calls machines submitted icalp reviews contained remark submission contributions conceptual identifies unrestricted hierarchical state machines pushdown systems valuable pushdown systems existence fact class infinite-state systems model checking decidable knew potential practical present paper demonstrates pushdown systems clear practical set spki sdsi certificates pushdown system note construction section transliteration spki sdsi terminology pds terminology keys resources locations identifiers stack symbols certificates answer identifies chain certificates prove result formally transition certificate-chain rules discovery attempts find gave removing correspondence useless theorems certificates demonstrated certificate pdss chain indirect exist present paper intuitively represents shows path pdss resource direct exist model-checking representing problem permission context-free access processes delegation addressed elimination context-free processes viewed pushdown systems single control location benedikt addressed problem ltl useless certs ctl ensures model checking chain represents authorization specification clarke 
presented algorithm certificatechain discovery spki sdsi kjcj time complexity number keys jcj sum lengths right-hand sides rules jha reps presented algorithm based theory pushdown systems note general composition operator associative compatible compatible exist exist exists expressions equal defined omit parentheses assume associative generalized authorization problem section formally define generalized authorization problem gap section show issues privacy validity recency trust formulated gap framework unrestricted framework hsms certificates similar labeled algorithms weights ltl drawn model bounded checking idempotent developed semiring independently definition bounded contemporaneously idempotent alur semiring quintuple abadi set sdsi linked elements local spaces combine journal operation computer extend security operation binary operators alur etessami commutative yannakakis monoid analysis recursive neutral state element machines idempotent proc computer-aided verif july alur monoid yannakakis neutral model checking element distributes hierarchical state machines volume softw eng notes annihilator pages respect york nov acm press benedikt godefroid partial order reps defined model checking unrestricted iff hierarchical state machines infinite descending chains icalp weighted spki blaze sdsi system feigenbaum wss ioannidis -tuple keromytis set keynote certs trust-management system bounded version idempotent rfc semiring sept blaze assigns weights feigenbaum ioannidis keromytis certs role extend trust management function distributed systems certificate security chains vitek natural jensen editors secure internet certificate programming chain security issues mobile distributed objects pages lncs defined bouajjani esparza maler reachability definition analysis weighted pushdown spki automata sdsi application system model wss checking proc concur request volume lec proof notes comp denotes sci set pages certificate chains springer-verlag prove burkart request steffen model checking fulfilled formally context-free proof processes proc concur set volume certificate lec chains notes comp sci useless pages certificates clarke elien ellison fredette morcos generalized authorization rivest problem certificate gap chain asks discovery spki sdsi questions jcs proof clarke non-empty elien proof ellison non-empty fredette find morcos rivest certficate quantities chain lff discovery spki sdsi proof http theory witness lcs set mit certificate rivest chains nov proof clarke grumberg peled model certificates checking mit weights press patient elien certificate patient discovery aids spki sdsi certificates patient master patient thesis massachusetts patient institute technology aids patient kalice ellison frantz patient kalice figure set weighted certificates notice extender operation calculate certificate chain set certificate chains computed combiner operation general finite set minimal elements minimal lampson respect rivest partial order thomas intuitively gap attempts find ylonen set spki certificate certificate chains theory proving rfc access resource sept esparza hansel combination rossmanith operator schwoon weights efficient minimal algorithms definition model defines checking general pushdown machinery systems required proc spki computer-aided sdsi verif problem volume discussed lec sections notes comp problem sci defined pages july gerth peled vardi witness set wolper certificate simple chains onthe-fly automatic identified verification linear temporal logic demonstrate protocol specification authorization-related problems testing cast verification framework pages warsaw privacy-preserving poland certificate chapman chains hall return halpern meyden logical introduction reconstruction spki company offers proceedings additional insurance ieee patients computer security hospital foundations workshop certificates pages relevant ieee computer society problem shown press figure howell represents service kotz offered formal semantics additional spki insurance offered technical company report filled square department represents computer fact science authorization dartmouth college delegated hanover eligible patient mar delegate knoop permission demand-driven buy model checking insurance context-free processes friends principals thiagarajan aids yap internalmedicine editors clinics proc asian hospital comp sci denoted conf volume aids lec notes alice comp sci patient pages clinics dec suppose local alice names spki buy sdsi insurance proceedings case ieee computer security foundations workshop equal july weeks kalice understanding trust management systems certificate proceedings chain ieee reveals symposium alice research security aids privacy research information security alice privacy oakland reveal ieee computer company society technical committee security privacy ieee computer society alice press prefer offer certificate details chain model checking company pdss proves head transition rule authorized buy additional insurance surface configuration suppose set pre reveals fhp vig amount equivalently information privacy case modeled gap path framework semiring transition system defined defined pds stand head insensitive sensitive repeating elements operators defined denotes vii identifying repeating heads crucial ltl model checking pdss easy check generalize slightly conditions concept illustrated definition satisfied definition assume condition trivially satisfied pds finite weights set locations certificates shown figure configurations path passes configuration location set certificate transition aids rule patient head kalice called labeled g-repeating reveals exists alice patient aids clinic set heads certificates g-repeating labeled heads weights pds certificate set locations chain denoted theorem assume alice pds prefers certificate chain set weight locations section set show repeating alice heads discover certificate computed time space jpj uchi automata -tuple alphabet set states transition chain relation maximally-valid certificate chain initial state expiration set cert final states cert set expire infinite time words tcurrent alphabet tcurrent denoted current time expiration infinite word certificate chain alphabet minki suppose accepted alice exists login host sequence states alice state appears certificate infinitely chain sequence valid minutes sequence states logged host called minutes accepting run alice find certificate chain language authorizes accepted login uchi maximum automata expiration assume certificate chains most-recent configuration certificate chain ltl time relative current time formula cert issued ltl formula on-line check atomic propositions performed cert exists uchi tcurrent automaton alphabet actual accepts time issue regular language on-line check efficient call algorithms translate recency ltl formula cert uchi recency automaton certificate chain uchi automaton equal maxki ltl formula suppose product alice pds login host produces uchi riskreduction pushdown purposes system host mandate certificate chain recency ten minutes case alice wishes find ltl certificate model-checking chain problem reduces authorizes accepting-run login problem configuration minimum satisfies recency iff exist accepting run chains starting configurationh certificate chain minimum recency run maxki visits infinitely equal ten configurations minutes control alice locations certificate chain login g-repeating certificate heads chains maximal proved trust assume certificate assigned trust configuration level issuer accepting run starting certificate intuitively denotes set confidence non-empty issuer post relationship pre expressed set certificate configurations trust level reachable certificate fromh chain nki post defined table set suppose pre alice denotes server set configurations requires certificate chain run leading trust level configuration case alice find repeating certificate head chain authorizes details certificate-chain maximal reconstruction trust level transition chains configuration certificate chain automaton trust associate level structure alice components validity integer identifier max min list recency transitions min suppose transition added due pds transition rule fact composite transition holds automaton composite transition comprised sequence transitions structure transition identifier pds transition rule denoted explain construction structures transitions shown figure empty structure empty list represented null tracing back structure transition obtain certificate chain proves authorization alice idempotent commutative associative absorption figure properties operators transition structure alice null bob null null null faculty figure structures transitions automaton shown figure background lattices lattice set binary meet join operators idempotent commutative associative figure elements form 
partially ordered set ordered defined ways iff iff write assume lattices bottom element top element chain sequence elements height length longest chain 
max trust table semirings validity recency trust formalization semirings semirings cases discussed shown table case maximal-trust trust levels drawn totally ordered set elements elements denote low medium high levels trust element stands link join meet operator totally ordered set defined arbitrary elements pushdown systems pushdown system transition system states involve stack unbounded length definition pushdown system triple finite sets called control locations stack alphabet configuration pair finite number rules formhp define transition relation configurations hri write express rule hri omit index understood reflexive transitive closure written set configurations define pre post sets configurations backwards forwards reachable elements loss generality assume henceforth jwj restrictive pushdown system simulated note highest level trust denoted element lowest total order obeys restriction larger constant factor pushdown systems infinitely configurations symbolic means represent sets configurations finite automata purpose definition pushdown system p-automaton quintuple finite set states set transitions final states initial states control locations configuration accepted final state set configurations regular recognized automaton understood omit prefix refer automaton convenient property regular sets configurations closed forward backward reachability words automaton accepts set construct automataapre andapost accept pre post general idea algorithm pre pushdown system p-automaton accepting set configurations loss generality assume transition leading initial state pre obtained language automaton apre derived saturation procedure procedure adds transitions rule current automaton add transition efficient implementation procedure requires jqj time jqjj space procedure implementation presented constructing p-automaton accepts post show extensions procedures provide efficient algorithms discovering certificate chains needed generalized authorization problems discussed section present extensions pre basic ideas apply post omitted lack space connection spki sdsi pushdown systems correspondence spki sdsi pushdown systems presented finite set certificates keys identifiers associate pushdown system keys control locations identifiers form stack alphabet rule set defined hkx hkh patient hkh patienti hkh aids patienti hkh patienti hkh patienti hkh aids patienti hkalice hkh patienti hkalice figure pds rules correspond figure cert sequence identifiers rule auth cert rule instance set certificates figure pushdown system control locations fkx aids kaliceg stack alphabet fpatient set rules listed figure usefulness correspondence stems simple observation configuration reach configuration chain certificates applied yield instance alice prove buy additional insurance hkx hkalice authorization problem set certs request terms pds certificate set authorization problem stated granted access iff condition pre fhk holds medical determine hkx pre fhkalice hkalice automaton shown figure accepts set set pre shown figure transition symbol state accepting state hkx pre words alice authorized buy additional insurance extra annotations insensitive sensitive transitions transitions involve sensitive information algorithm deriving labels presented section solving generalized authorization problem types problems treated characterized qualitative nature answer questions principal allowed access resource section show answer questions additional quantitative component kaliceh aids kaliceh aids patient patient patient figure automaton representing configurations fhkalice hkalice automaton representing configurations pre long principal allowed access resource pushdown systems rules carry weights weighted pushdown systems pushdown system rules values domain weights weight domains interest bounded idempotent semirings definition definition 
weighted pushdown system triple pushdown system bounded idempotent semiring function assigns rule sequence rules associate define configurations path denote set rule sequences transform hrki definition weighted pushdown system regular set configurations generalized pushdown reachability gpr problem find lfv path witness set paths path general finite set paths values minimal elements path minimal respect partial order defined definition remainder section denote fixed weighted pushdown system denote fixed regular set configurations represented p-automaton transition leading initial state gpr problem multi-target meet-over-all-paths problem graph vertices graph configurations edges defined transition relation target vertices vertices graph set target vertices infinite built-in structure regular set gpr problem concerns infinite graphs infinite set paths differs work meet-over-all-paths problems ordinary pushdown-reachability problem infinite nature problem addressed reporting answer indirect fashion form annotated automaton answer automaton annotations identical apre automaton created algorithm pre values read annotations accepting paths automaton pre values solution gpr problem presented stages define language characterizes sequences transitions made pushdown system automaton turn weighted pushdown systems gpr problem language characterizations transition sequences previously results kind grammar problem obtain solution gpr problem solution based grammars inefficient improve performance specialize computation case ending algorithm creating annotated automaton similar pre algorithm languages characterize transition sequences section make definitions aid reasoning set paths lead configuration configurations regular set call set reachability witnesses respect reachabilitywitnesses path convenient pds automaton combined sequence create combined pds call states rules ofp augmented rule transition transition set configuration accepted path configuration hqf note transitions leading initial states behavior accepting run divided phases transitions mimics transitions mimics reaches state perform sequence pops possibly reaching state run reach state terms features original phase corresponds automaton accepting configuration reached starting configuration words accepts configuration iff pre language define characterizes pop sequences pop sequence sequence transitions starts configuration ends configuration family pop sequences characterized complete derivation trees derived nonterminal grammar shown figure theorem pds pop sequence iff nonterminal grammar shown figure complete derivation tree derivation tree root preorder listing derivation tree production instances figure defines correspondence productions pds rules sequence rules pop sequence sequence rules derivation tree root derivation tree complete terminal symbol leaf proof sketch shrink stack removing stack symbol left-hand side rule transition sequence removes symbols stack component rule right-hand side words pop sequence left-hand-side stack symbol involve pop sequence righthand-side stack symbol left-hand right-hand sides productions figure reflect pop-sequence obligations incurred rule capture set reachabilitywitnesses recognized automaton define context-free language set productions shown figure language captures ways pds accept set reachability witnesses corresponds complete derivation trees derivable nonterminal accepted subtree rooted pop sequence performs consume symbol reachability witnesses complete derivation trees root accepted weighted pdss abstract grammar problems turning weighted pdss weighted version denoted weighted pds combined rule added due transition transition set assigned weight reason semiring sums weights paths characterized contextfree grammars defined concept definition semilattice abstract grammar collection context-free grammar productions production form parentheses commas production terminal symbols production function string terminal symbols derived grammar yield complete derivation tree denotes composition functions corresponds unique call valg simply val understood denote strings terminals derivable nonterminal abstract grammar problem compute nonterminal valg production figure context-free language pop sequences rules correspond production production accepting accepted accepting figure set productions complete derivation trees root accepted encode transition sequences accepts cast gpr grammar problem attach production functions productions rule sequence derivation tree yield valg figure note functions place beginning semiring-product expression corresponds preorder listing derivation tree production instances theorem solve gpr problem appeal theorem theorem abstract grammar problem solved iterative computation finds maximum fixed point conditions hold semilattice infinite descending chains production function distributive xik xik arbitrary non-empty finite index sets production function strict argument abstract grammar problem figure meets conditions theorem definition operator associative commutative idempotent semilattice definition infinite descending chains distributivity production functions arbitrary non-empty finite index sets repeated application definition production functions strict argument annihilator respect definition production functions constants functions arguments meet required condition trivially algorithm solving gpr problem weighted pds initial configuration regular set represented automaton create combined weighted pds define abstract grammar problem schema shown figure solve abstract grammar problem finding maximum fixed point chaotic iteration nonterminal fixed-point-finding algorithm maintains current estimate maximum fixed-point solution initially values set updated right-hand side production left-hand-side nonterminal efficient algorithm gpr problem approach previous section efficient configuration takes jqjn jfj time space create grammar productions figure left-hand-side nonterminal accepting improve production accepting accepted accepting figure abstract grammar problem gpr problem algorithm previous section instantiations productions listed figure relevant final solution prevent algorithm exploring useless nonterminals grammar shown figure gpr questions respect target-configuration set involve subgrammar nonterminals ordinary pushdownreachability problem information complete derivation tree root nonterminal exists productive nonterminal precomputed returned form annotated automaton size jqjj exploring subgrammar lazily saves construct entire subgrammar productive nonterminals represent automaton transitions productions involve transition constructed on-thefly algorithm shown figure straightforward algorithm solves grammar problem subgrammar figure workset set transitions nonterminals updated considered line values set function call update computes transition created rule transitions ordered list lines process rules types lines represent fixed-pointfinding loop lines simulate processing rules types involve transition right-hand side line corresponds invocations production functions note line change smaller iterations continue values transitions stabilize workset empty fact algorithm simply expressing grammar problem subgrammar algorithm terminates computes desired result operations algorithm remarkably similar pre algorithm major difference transitions stored workset processed multiple times transition processed length maximal-length descending chain semiring maximal cost extender combiner operation time complexity increases complexity unweighted case factor gpr problem solved time jqj efficient techniques apply semirings total orders discussed section annotated pre automaton configuration read automaton paths accepted accumulating path taking meet resulting set value-accumulation step performed straightforward extension standard algorithm simulating nfa algorithm algorithm dynamic-programming algorithm determining appendix describes extend algorithm additional annotations transitions path set obtained total orderings examples section semirings properties ordering total ordering element respect iii lub lub denotes upper bound maximum total order cases efficient algorithm gpr problem based ideas knuth generalization algorithm input weighted pushdown system p-automaton accepts transitions states output p-automaton apre accepts pre function maps abstract grammar problem defined figure procedure update begin ftg jtj changed 
workset workset ftg end workset update workset select remove transition workset update update update return figure on-the-fly algorithm solving grammar problem subgrammar figure dijkstra algorithm shortest-path problem algorithm workset implemented priority queue transition selected line minimum line changed adjustpriorityqueue worklist adjustpriorityqueue inserts item priority queue key key item approach transitions processed form nondecreasing sequence transition selected workset general case label transition change transition selected causing added workset compared pds-reachability problem unweighted case costs compute maximum fixed-point values cost approach describe applies slightly larger class totally ordered abstract grammar problems studied ramalingam examples fall class defined studied knuth maintaining priority queue time complexity jqj log jqjj set path discussion discuss issues arise applying gap framework recency policies recency metric presented section simplistic compared studied recency policies based number factors financial risk authentication authorization decision semantics invalidity rate certificate contents security system generate certificate realistic setting recency values certificates normalized possibility base normalization remaining lifetime certificate assuming times validity specification appropriately chosen lifetime certificate tnot tcurrent provided certificate valid tcurrent tnot recency certificate defined tcurrent tissuel case semiring recency min max multiple security policies authorization policies subject multiple security policies satisfy simultaneously most-recent certificate-chain policy privacy-preserving policy approach policy-priority approach user declares order security-policy priorities instance privacy priority recency priority problems addressed gap framework component policies involve total orders pairs values semiring values privacy recency values defining lexicographic minimum section gap framework handle partially ordered component policies situation clear preference component policies section trust policies trust policies metrics proposed literature trust metrics efficiently modeled gap framework proposed bounded disjoint paths bdp bounded connective paths metric np-hard conp-hard hope finding efficient solution problems investigated approximation algorithms developed problems applicable setting similarly minimum-capacity-cut metric easily formulated framework bdp weighted shortest paths interesting metrics certificate-chain context metric paths certificatechain evaluation paths problem shown np-complete length bounds greater approximation algorithms np-hard related work algorithm spki sdsi proposed clarke credential-chaindiscovery algorithm role-based trust management language presented proofcarrying-authorization pca framework appel fela infinite descending chains operations performed min max finite number values arise execution gap framework applies ten client theorem prover twelf construct proof authorization client presents server knowledge previously considered issues privacy trust context algorithms trust management systems algorithms pca algorithm based algorithm generalized shortest-path problem weights edges drawn semiring approach general approach applies formalisms spki sdsi pushdown systems related unrestricted hierarchical state machines collections finite-state transition systems connected call return transitions related interprocedural controlflow graphs exploded supergraphs interprocedural dataflow analysis dataflow analysis application weighted pdss algorithm solving gpr problems developed section related existing dataflow-analysis algorithms sagiv showed compute meet-over-all -valid -paths values multientry multi-exit hierarchically structured graphs respect previous work interprocedural dataflow analysis section makes contributions conventional dataflow-analysis algorithms merge values configurations top-of-stack symbol weighted pdss dataflow queries posed respect regular language initial stack configurations strict generalization kind answers obtainable ordinary interprocedural dataflow-analysis algorithms algorithm solving gpr problems provide witness set paths provide client analysis algorithm explanation answer dataflow query reported application weighted pdss interprocedural dataflow analysis examined greater detail model checking pushdown systems verifying security properties programs application weighted pushdown systems verifying security properties programs verification process requires knowing interprocedural dataflow information bouajjani esparza toulli independently developed similar framework pre post queries pushdown systems weights drawn semiring solve overapproximations reachability questions concurrent communicating pushdown systems method obtaining weights automaton transitions significantly differs deriving weights directly obtained fixpoint computation matrix entries transitions pre automaton obtain weights semiring infinite descending chains provided extender operator commutative leads efficient solution finitechain case case algorithm time complexity jqjj jqjj proportional jqj semirings finite descending chains algorithm applies cases efficient solution number trust policies metrics proposed obtain assurance certificate binding well-known notions stem pgp user acts certificate authority creating certificates entities trust transitive manner certificate authorities recommendors introduce certificate authorities trust creating certificates assurance certificate-chaining process provided part independent certificate paths subsequent work studies network connectivity trust metric work studies metrics based confidence valuations minimum-capacity cuts certificated edges represent financial liabilities algebra assessing trust certificate chains private sensitive information reside certificates include names roles identifying information chains authorization certificates tend mirror organization structures business processes personal relations sensitive principal making authorization request follow privacy policy control information disclosed leaked part authorization process flexibility exist requester choose alternative set credentials supplied part proof authorization certificate privacy problem related long history work information flow based lattice model attempts model controls flow information traditional information-flow policies stemming military concerned information-disclosure policies access data requires proper clearance mandatory access control discretionary access control draw work sense willingness provide credentials categories information subject current discretionary access request policies based chinese-wall security policy access data constrained attributes data question data subject holds access rights objective current paper demonstrate simple privacy metric quantifies information flow certificate chain validity time periods included certificate formats early certificate standards validity certificate contents suspect current time certificate-validity period certificaterevocation lists directories queried determine credentials invalid stubblebine formalizes notion recent-secure authentication means authenticating channel subject freshness constraints work means reasoning recent-secure authentication extending calculus authentication rivest develops case flexible mechanisms support authentication subject recency constraints additional recency policies methods analysis recent-secure authentication developed work monotonic logic reasoning synchronization revocation recency monotonic logics reasoning validity intervals spki context studied aho sethi ullman compilers principles techniques tools addison-wesley alur etessami yannakakis analysis recursive state machines proc computer-aided verif july appel felten proof-carrying authentication conf comp commun sec nov aura ellison privacy accountability certificate systems res rep helsinki univ tech espoo finland apr bell lapadula secure computer system unified exposition multics interpretation technical report esd-tr- mitre corp mtrbedford ntis ad-a benedikt godefroid reps model checking unrestricted hierarchical state machines icalp beth borcherding klein valuation trust open networks computer security esorics volume lec notes comp sci pages springerverlag blaze feigenbaum ioannidis keromytis keynote trust-management system version rfc sept blaze feigenbaum ioannidis keromytis role trust management distributed systems security vitek jensen editors secure internet programming security issues mobile distributed objects pages lncs bley complexity vertex-disjoint length restricted path problems tech rep sc- konrad-zusezentrum informationstechnik berlin ger bouajjani esparza maler reachability analysis pushdown automata application model checking proc concur 
volume lec notes comp sci pages springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures pages brewer nash chinese wall security policy symp sec privacy pages chen wagner mops infrastructure examining security properties software conf comp commun sec november chu feigenbaum lamacchia resnick strauss referee trust management web applications computer networks isdn systems sept clarke elien ellison fredette morcos rivest certificate chain discovery spki sdsi jcs denning lattice model secure information flow communications acm detreville binder logic-based security language symp res sec privacy oakland ieee computer society press ellison frantz lampson rivest thomas ylonen spki certificate theory rfc sept esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems proc computer-aided verif volume lec notes comp sci pages july esparza cera schwoon model-checking ltl regular valuations pushdown systems proceedings tacas volume lncs pages springer halpern van der meyden logical reconstruction spki comp sec found workshop pages jensen metayer thorn verification control flow based security properties ieee symposium security privacy jha reps analysis spki sdsi certificates model checking ieee comp sec found workshop csfw ieee computer society press jsang algebra assessing trust certification chains kochmar editor proceedings network distributed systems security symposium ndss knoop steffen interprocedural coincidence theorem int conf comp construct pages knuth generalization dijkstra algorithm inf proc kohlas maurer confidence valuation publickey infrastructure based uncertain evidence public key cryptography pages lampson abadi burrows wobber authentication distributed systems theory practice trans comp syst winsborough mitchell distributed credential chain discovery trust management comp sec maurer modeling public-key infrastructure computer security esorics volume lec notes comp sci springer-verlag perl ronen heuristics finding maximum number disjoint bounded paths networks pfenning sch urmann system description twelf meta-logical framework deductive systems ganzinger editor int conf auto deduc pages springer-verlag lnai july ramalingam bounded incremental computation volume lec notes comp sci springer-verlag reiter stubblebine resilient authentication path independence trans computers dec reiter stubblebine authentication metric analysis design trans inf syst sec reps horwitz sagiv precise interprocedural dataflow analysis graph reachability symp princ prog lang pages york acm press reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis international static analysis symposium sas rivest eliminate certificate revocation lists hirschfeld editor financial cryptography pages feb rote path problems graphs tinhofer mayr noltemeier syslo eds cooperation albrecht computational graphs theory springer-verlag computing supplementum sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation theor comp sci schwoon wpds library weighted pushdown systems http tum schwoon moped sharir pnueli approaches interprocedural data flow analysis muchnick jones editors program flow analysis theory applications chapter pages prentice-hall englewood cliffs stubblebine recent-secure authentication enforcing revocation distributed systems symp research sec privacy pages stubblebine wright authentication logic formal semantics supporting synchronization revocation recency trans softw eng mar oencke wilhelm grammar flow analysis alblas melichar editors attribute grammars applications systems volume lec notes comp sci pages prague czechoslovakia june springer-verlag union itu-t recommendation information technology open systems interconnection directory authentication framework aug department defense dod trusted computer system evaluation criteria dod -std weeks understanding trust management systems symp res sec privacy oakland ieee computer society press zimmermann official pgp user guide mit press cambridge appendix generation witness sets section efficient algorithm determining section addresses question obtain problem examining infinite graph nodes pairs configuration edge labeled hri configuration finding means identifying set paths path leads andl words proves computed algorithm note properties general larger situation paths values single path small witness set paths set witness set indirectly form annotation called transitions apre data structures called wnode wstruc transition holds wnode denote entity wnode set wstruc items wstruc item form back rule sequence wnodes nil indicating missing extend algorithm idea execution item denotes suppose apre accepting path starting configuration accepted path pushdown system path family paths path starts accepting path apre successor configuration algorithm procedure update begin ftg jtj return nil create fsg create minimize fsg workset workset ftg end figure modified update procedure constructed replacing transitions wnodes concrete modifications algorithm line set nil line create wnode nil set figure shows revised update procedure line figure computes newly discovered transition line records path discovered line update change line addition strictly smaller path path incomparable line creates set consisting previous paths path incomparable approximate elements procedure minimize shown removes fairly straightforward information contained reconstruction witness set involving wnode created execution wnodes created earlier process reconstructing witness set decoding wnode wstruc information eventually terminate configuration execution modified algorithm wnodes transition created referenced moment wnodes referenced transitions garbage collector track remove nodes longer chain transition totally ordered case section wnode wstruc 

page october typestate checking machine code abstract check statically safe untrusted foreign machine code loaded trusted host system safety means program abides memory-access policy supplied host side technique works ordinary machine code mechanically synthesizes verifies safety proof earlier work lines based c-like type system suffice machine code origin source code present paper address limitation improved typestate system introduce techniques including summarizing effects function calls analysis stop trusted boundaries inferring information sizes types stack-allocated arrays symbolic range analysis propagating information array bounds techniques make approach safety checking precise efficient handle larger collection real-life code sequences previously case allowing subtyping structures pointers allowed implementation analyze code originating object-oriented source code symbolic range analysis eliminated total attempts synthesize loop invariants programs test suite array accesses programs eliminated synthesize loop invariants altogether resulting speedup globalverification phase system ranges median introduction goal check statically safe piece untrusted foreign machine code loaded trusted host system start ordinary machine code mechanically synthesize verify safety proof earlier paper reported initial results approach chief advantage opens possibility certify code produced general-purpose off-the-shelf compiler programs written languages fortran work limit safety policy fixed set memory-access conditions avoided perform safety checking respect safety policy supplied host side earlier work based c-like type system suffice machine code origin source code present paper address limitation introduce techniques make safety-checking analysis precise scalable proof-synthesis techniques employed host side approach viewed alternative proof-carrying code pcc approach pcc requires code producer create machine code proof code safe host perform proof-validation step proof-synthesis techniques employed code producer foreign side untrusted trusted boundary approach viewed ally pcc helps lift current limitations certifying compilers produce pcc automatically programs written safe source languages paper present improved techniques proof synthesis improved typestate-checking system perform safety-checking untrusted machine code implements inheritance polymorphism physical subtyping work introduces method coping subtyping presence mutable pointers section mechanism summarizing effects function calls safety preand post-conditions summaries analysis stop trusted boundaries form step checking untrusted code modular fashion makes safety-checking technique scalable section technique infer information sizes types stack-allocated arrays local arrays left open problem previous paper section zhichen thomas reps barton miller wisconsin madison zhichen reps bart wisc page october symbolic range analysis suitable propagating information array bounds analysis makes safety-checking algorithm dependent expensive program-verification techniques section section review safety-checking technique earlier work section illustrates benefits techniques case studies section compares techniques related work result improvements handle broader class real-life code sequences precision efficiency allowing subtyping structures pointers analyze code originating object-oriented source code symbolic range analysis eliminated total attempts synthesize loop invariants programs test suite array accesses programs eliminated synthesize loop invariants altogether resulting speedup global verification ranges median improvements made global-verification phase range analysis verify untrusted code handle previously safety checking machine code section briefly review safety-checking technique earlier work safety-checking analysis enforces default collection safety conditions prevent type violations array out-of-bounds violations address-alignment violations uninitialized variables null-pointer dereferences addition host side precise flexible access policy access policy specifies host data accessed untrusted code host functions methods called means host privilege untrusted code accomplish task approach based annotating global data host type information untrusted code inferred analysis starts information initial memory state entry untrusted code abstractly interprets untrusted code produce safe approximation memory state program point annotates instruction safety conditions instruction obey checks conditions memory states entry program points untrusted code terms abstract storage model abstract store total map abstract locations typestates abstract location summarizes physical locations analysis finite domain work typestate describes type state access permissions values stored abstract location initial memory state entry untrusted code host-typestate specification invocation specification host typestate specification describes type state host data invocation untrusted code safety preand post-conditions calling host functions methods invocation specification binding information host resources registers memory locations represent initial inputs untrusted code safety-checking analysis consists phases phase preparation combines information provided host-typestate specification invocation specification access policy produce initial annotation form abstract store program entry point produces interprocedural controlflow graph untrusted code phase typestate-propagation takes control-flow graph initial annotation inputs abstractly interprets untrusted code produce safe approximation memory contents typestate abstract location program point phase annotation takes input typestate information discovered typestate-propagation phase annotates instruction local global safety conditions assertions local safety preconditions conditions checked typestate information assertions restatements logical formulas facts implicit page october typestate information fourth phase local verification checks local safety conditions phase global verification verifies global safety conditions program-verification techniques present implementation handles non-recursive programs improved typestate system past work analysis made assumption register memory location stored values single type program point register memory location store types values program points approach drawbacks programs written languages support subtyping inheritance programs written languages programmers ability simulate subtyping inheritance section describe extended typestate system incorporate notion subtyping pointers approach register memory location occurrence instruction resolved polymorphic type super type acceptable values rest section describe improved type component typestate system type expressions figure shows language type expressions typestate system compared previous work typestate system includes bit-level representations integer types top bottom types parameterized size parameter type int represents signed integer bits highest bits middle bits represent sign result sign extension lowest bits represent -bit signed integer represented int -bit signed integer char -bit sign extension represented int type uint represents unsigned integer middle bits zeros type denotes pointer points middle array type size ground ground types pointer base array type size pointer middle array type size ptr pointer struct union function top type bits bottom type bits type bits member labeled type offset ground int uint figure simple language type expressions stands type stands struct union member language chosen express type system bit assume untrusted code necessarily written page october bit-level representation integers express effect instructions load store partial words code fragment sparc machine language copies character pointed register location pointed register ldub stb points signed character c-like type system typestate checking lose precision checking code fragment loss precision instruction ldub loads register byte memory zero-fills highest bits type system treats unsigned integer contrast bit-level integer types figure assign type int execution load instruction preserves fact lowest bits store signed character int subtyping 
relation introduce notion subtyping type expressions adopted physical-subtyping system takes account layout aggregate fields memory figure lists rules define type physical subtype denoted figure rules top bottom ground pointer array additions physical-subtyping system integer type subtype type range represented subrange range represented sign-extension bits rule member states structure subtype scalar type type member structure subtype scalar type consequence rule valid program pass structure place supertype member expected rules structures members state structure subtype prefix member supertype member rule members constraints members structures rule pointer states subtype ptr subtype ptr rule array states pointer base array subtype pointer middle array system assignment legal type right-hand-side expression physical subtype type receiving location receiving location space rule array valid describes larger set states global-verification phase analysis check array bounds figure inference rules define subtyping relation note subtype ordering conventional typestate checking ordering flipped type lattice iff structures top sizeof bottom sizeof ground int int member members reflexivity array pointer ptr ptrt uint uint uint int page october allowing subtyping integer types structures pointers analysis handle code implements inheritance polymorphism physical subtyping function accepts -bit integer legal invoke function actual parameter signed character int provided actual parameter stored register memory instruction handles sign extension properly figure shows involves subtyping structures pointers subtyping inference rules structures pointers type colorpointptr subtype pointptr function polymorphic legal pass actual parameter type colorpointptr function object-oriented languages additional complication arises virtual functions virtual function implemented subclasses long full information class hierarchy simply assume callee call virtual function functions implement virtual function check state access component typestate system briefly review state access components typestate system state lattice bottom element denotes undefined type scalar type state denote uninitialized initialized values define state lattice pointer type state non-empty set abstract locations referenced define elements null sets define iff aggregate type state states fields access permission subset tuple access permissions access permission introduced pointer-typed values pointer dereferenced access permission applies values type pointer function values hold address function function pointed called untrusted code access permission includes rights examine copy perform operations covered meet access-permission sets intersection meet tuples access permissions meet respective elements type checking subtyping typestate checking subtyping readers familiar problems encountered subtyping presence mutable pointers suspicious rule pointer fact rule pointer unsound traditional flow-insensitive type systems absence alias information flow-insensitive analysis account aliasing unable determine indirect modifications shared data structure indirect modifications disastrous effects figure concrete statement line clrptr point object type point indirectly variable clrptr longer fulfill obligation supply color field line static technique handle problem detect disastrous indirect modifications happen approaches problem found literature linear type system avoids aliases altogether indirect modifications consuming pointer struct point int int struct colorpoint int int uint color void point y-figure subtyping pointer types page october smith singleton types track pointers alias constraints model shape store goal tracks non-aliasing facilitate memory reuse safe deallocation objects approach involves introducing notions immutable fields objects idea subtype type type ptr subtype ptr field subtype field immutable field pointer object pointed immutable rule applies transitively approach work correctly mechanism needed enforce immutability restrictions work represents fourth technique system performs typestate checking flow-sensitive analysis tracks aliasing relationships abstract locations state descriptors resemble storageshape graphs chase similar diagrams shown right-hand column figure inspecting storage-shape graphs program points access heap-allocated storage safely detect illegal field access occur instance shape graph arises statement figure analysis determine access color statement represents memory-access error programs accesses rejected safety checker summarizing function calls summarizing function calls safety-checking analysis stop boundaries trusted code tracing body trusted callee analysis check call obeys safety pre-condition post-condition rest analysis describe method summarizing trusted calls safety preand post-conditions terms abstract locations typestates linear constraints safety pre-conditions describe obligations actual parameters meet post-conditions provide guarantee resulting state produce safety preand post-conditions hand process error-prone desirable automate generation function summaries recent work interprocedural pointer analysis shown pointer analysis performed modular fashion techniques analyze function assuming unknown initial values parameters globals function entry point obtain summary function dataflow effect function future work investigate techniques create safety preand postconditions automatically typedef point pointptr typedef colorpoint colorpointptr colorpoint clr point void void pointptr bwptr colorpointptr clrptr clr colorpointptr clrptr pointptr bwptr clrptrcolor figure rule pointer unsound flow-insensitive type checking absence aliasing information assume type declarations shown figure bwptr clrptr clr clrptr clr clrptr clr clrptr bwptr bwptr bwptr bwptr page october represent obligation provided actual parameter placeholder abstract location placeholder size access permissions typestate provide detailed requirements actual parameter satisfy formal parameter pointer state descriptor include placeholders represent obligations provided locations pointed actual parameter model state descriptor pointer-typed placeholder refer null placeholder placeholder null refers null actual parameter point null refers placeholder locations pointed actual parameter satisfy obligation denoted placeholder state descriptor refers null placeholder actual parameter point null locations satisfy obligation represent pre-conditions list form placeholder typestate safety post-conditions provide safety-checking analysis compute resulting state call summarized function represented list post-conditions form alias context placeholder typestate alias context set potential aliases potential non-aliases neq placeholders alias contexts capture aliasing actual parameters affect resulting state safety preand post-conditions include linear constraints safety pre-conditions represent additional safety requirements post-conditions provide additional information resulting memory state call make idea concrete figure shows summarizes library function gettimeofday specifies call safe null address writable location size sufficient storing type structtimeval safety post-conditions execution call fields location initialized initialized integer sparc actual parameters passed registers return function stored register figure alias contexts empty ambiguity aliasing alias contexts summarize function calls precision opposed make fixed assumptions aliasing figure shows alias contexts provide precision function returns null object pointed parameter depending aliases checking call trusted function involves binding process update process binding process matches placeholders actual abstract locations checks meet obligation update process updates typestates actual locations represented placeholders safety postconditions int gettimeofday struct timeval safety pre-condition struct timeval ptr null struct timeval safety post-condition struct timeval int int int figure safety preand postconditions typestate aggregate typestates components enclosed component labeled offset bits closest enclosing aggregate page october goal summarize library functions generally complicated things pointers present focused obligations represented tree placeholders 
obligations represented fall back letting typestate-propagation phase trace body function tree-shaped placeholders binding process carried simple algorithm binding algorithm iterates formal parameters obtains respective actual parameters typestate descriptors call site traverses obligation tree checks actual parameter meets obligation establishes mapping placeholders set abstract locations represent store callsite binding process distinguishes information information intuitively placeholder represent location binding algorithm establish represent unique concrete location algorithm updating process interprets post-condition distinguishes strong update weak update depending placeholder represent unique location represent multiple locations alias context evaluates true false strong update placeholder represents unique location alias context evaluates true weak update placeholder represent multiple locations alias context determined true false case typestate location receives meet typestate call typestate post-condition alias context determined true false update post-condition place make safest assumption weak update inferring information stack-allocated arrays determining information arrays reside stack difficult figure types bounds previous work required manual annotations procedures made local arrays section describe method inferring subrange stack frame holds array illustrate method simple figure shows program updates local array column shows sparc machine code produced compiling program gcc version infer local array present examine live pointers time typestate-propagation algorithm reaches entry loop discussion abstract location denotes stack frame allocated add instruction line denotes point offset denotes subrange starts offset ends offset abstractly interpreting add instructions lines find points points time typestate-checking algorithm visits loop entry point column figure abstractly interpreting instructions line line reveals stores integer time typestate-checking algorithm visits loop entry points pointptr pointptr pointptr null return safety pre-condition pointptr ptr pointptr ptr pointptr safety post-condition neq pointptr pointptr null figure safety preand post-conditions alias contexts page october candidate local array reasoning runs create fictitious components shown right-most column figure point component instruction polymorphic usage program point pointer pointer compatible types choice type system pointer array letting denote type array element compute general type steps compute size compute greatest common divisor gcd sizes slots delimited pointer consideration slot size size compute limits array assume array ends location closest live pointer stack pointer consideration compute type assuming size computed create fictitious location size give initial type slide area identified step bytes time bytes time perform meet operation covered area covered sub-area type assume type find struct int refinement needed general make refinements findings iterations typestate-checking algorithm refinement bring element type array type lattice address consideration register general form registers integer method heuristics compute limits array affect soundness approach reasons typestate-propagation algorithm make program type correct ensure element type inferred correct global-verification phase verify local array inferred bounds program sparc machine language time time typedef struct int int int main int main add add mov add cmp bgeu mov add cmp blu add retl figure inferring type size local array label represents entry loop int page october note matter analysis original program written terms n-dimensional array terms -dimensional array analysis treats arrays -dimensional arrays approach works original code written terms n-dimensional array layout scheme compilers n-dimensional array involves linear indexing scheme reflected linear relationships analysis infers values registers range analysis technique array bounds checking earlier work techniques cousot halbwachs precise higher cost describe simple range analysis determines safe estimates range values register program point information determining accesses arrays bounds advantage synergy efficient range analysis expensive powerful technique applied demand apply program-verification technique conditions proven range analysis range-analysis algorithm standard worklist-based forward dataflow algorithm finds symbolic range register program point analysis range denoted lower upper bounds form integer constants symbolic names serve placeholders base address length array reason restrict bounds form array-bounds checks involves checking range array index subrange lengthor range pointer points array subrange base base lengthwhere base length base address length array analysis symbolic names stand unknown values quantities base length ranges form meet semi-lattice respect meet operation ranges meet defined min max top element empty range bottom element largest range function min returns smaller comparable determine relative order instance min returns function max defined similarly returns greater parameters parameters comparable give dataflow transfer function machine instruction define dataflow transfer functions strict respect top element introduce basic abstract operations describing dataflow transfer functions abstract operations summarized integer operations figure binary operations symbolic expressions page october arithmetic operations bounds figure non-zero integers arithmetic operations ensure bounds form comparison instructions major source bounds information analysis works machine code tests forms program variables figure summarizes dataflow transfer functions forms assume ranges tests function min max defined upper bound range smaller lower bound range equivalent empty range dataflow functions variables false branch test improve precision slightly returning empty range equal ensure convergence range-analysis algorithm presence loops perform widening operation node loop dominates source loop backedge range arbitrary variable previous iteration dataflow current iteration resulting range widening operator defined sharpen basic range analysis enhancements enhancement deals selecting suitable spot loop perform widening key observation do-while loop kind dominates binary code effective perform widening test exit loop case loop iterates array loop test length strategy minimizes imprecision crude widening operation range widened loop test immediately sharpened transfer function loop test range propagated loop backedge lengthconsequently analysis quiesces iterations enhancement utitest true branch max min max min false branch true branch min max false branch max min uwfigure dataflow functions tests loops common source code compilers typically transform do-while then-part transformation compiler exploit fact code body do-while executed loop executes perform code-motion fear slowing execution program compiler hoist expressions body loop point then-part loop guarded min min comparable max max comparable page october lize correlations register values test consideration establish program point constant incorporate information range analysis assuming branch tests n-c case studies techniques exception technique section infer sizes local arrays implemented safety-checker sparc machine programs illustrate benefits improvements programs examples include array sum start-timer stop-timer code paradyn suite versions btree traversal version compares keys function call hash-table lookup kernel extension implements page-replacement policy bubble sort versions heap sort manually inlined version interprocedural version stack-smashing update message-digest algorithm functions jpvm cases case includes functions module device driver dev kerninst reads kernel symbol table experiments find safety violation implements page-replacement policy attempts dereference pointer null identified array out-of-bounds 
violations stack-smashing array out-of-bounds violations dev kerninst figure summarizes time needed verify examples mhz sun ultra machine times divided times perform typestate propagation create annotations perform local verification perform range analysis perform global verification figure characterizes examples terms number machine instructions number branches number loops total versus number loops number calls total versus sum aging olicy start imer hash bub ble sort stop imer btr btr heap sort heap sort jpvm stacksmashing jpvm ninst number eatur instructions branches loops loops procedure calls trusted calls global conditions bounds checks source language typestate propagation annotation range analysis global verification total seconds figure characteristics examples performance results test cases written compiled gcc version dev kerninst written compiled sun workshop comipler page october number calls trusted functions number global safety conditions number bounds checks source language test case written note checking lower upper bounds regarded separate safety conditions times verify examples range seconds seconds extensions typestate system handle broader class real-life examples bit-level representations integers analysis deal instructions load store partial word update stack-smashing examples technique summarize trusted functions analysis summaries host library functions hash startand stop-timer btree jpvm examples dev kerninst examples simply summarize library functions checking implies examples safe library functions safe principle check library code summaries subtyping structures pointers summaries jni methods polymorphic jni function jsizegetarraylength jnienv env jarray array takes type jarray parameter applicable types jintarray jobjectarray subtypes jarray java objects manipulated jni interface model types jintarray jobjectarray physical subtypes jarray summarizing jni interface functions symbolic range analysis system identify boundaries array field structure typestate-propagation algorithm information range register run intraprocedural version range analysis demand intraprocedural range analysis run function test cases array accesses range analysis eliminated total attempts synthesize loop invariants test cases eliminated synthesize loop invariants altogether resulting speedup global verification ranges median conjunction improvements made global-verification phase range analysis verify dev kerninst handle previously figure shows times performing global verification times performing range analysis normalized respect times performing global verification range analysis reason analysis stack-smashing figure times perform global verification range analysis normalized respect times perform global verification range analysis sum jpvmhash sor bub btree btree heap sor heap sor ratio jpvm stac smashing time range analysis normalized time global verification normalized page october slowed array accesses bounds array accesses fact bounds range analysis speed analysis analysis apply program-verification technique conclude array out-of-bounds violations similarly reason hash slowed conditions array-bounds checks range analysis prove array accesses bounds related work papers investigated topics related typestate-checking system symbolic range analysis morrisett introduced notion typed assembly language tal type system model language features instance tal models language features address exceptions existential types hand system models size alignment constraints tal tal type system support general pointers stack stack heap pointers distinguished declare function receives tuple argument accept heap-allocated tuple call site stack-allocated call site finally talx introduces special macros array subscripting updating prevent optimizer rescheduling macros expand code sequences perform array-bounds checks impose restrictions idioms compiler employ implement array subscripting tal achieves flow-sensitivity system tal blocks code labeled functions types assigned registers function system achieves flow-sensitivity typestate instruction mycroft technique reverse engineers programs target machine code typeinference techniques type-reconstruction algorithm based milner algorithm associates type constraints instruction ssa representation program type reconstruction unification mycroft technique infers recursive data-types loops recursive procedures start annotations initial inputs untrusted code technique requires annotation abstract interpretation unification note technique detect local arrays based principle unification technique mycroft technique recovers types registers memory locations technique handle stackand heap-allocated objects technique recovers type information propagates type state access information analysis flow-sensitive mycroft flow-insensitive recovers degree flow sensitivity ssa form variables live ranges ramalingam describe efficient algorithm decomposing aggregates records arrays simpler components based access patterns specific program technique infer local arrays identifies aggregates arrays based access pattern specific loop people techniques statically check out-of-bounds array accesses cousot halbwachs method based abstract interpretation convex hulls polyhedra technique precise simply verify assertions discover assertions deduced semantics program range analysis regarded simple form cousot halbwachs analysis eye efficiency goal advantage synergy efficient range analysis expensive powerful program-verification technique applied demand apply program-verification technique conditions proven range analysis page october verbrugge range-analysis technique called generalized constant propagation gcp symbolic range analysis differs gcp respects gcp domain intervals scalars symbolic ranges gcp attempts balance convergence precision analysis stepping ranges variables failed converge fixed number iterations perform widening operation quicker convergence sharpen analysis selecting suitable spots loops performing widening operation incorporating correlations register values gcp technique points-to information discovered earlier analysis phase current implementation range analysis context-insensitive gcp context-sensitive rugina rinard symbolic bounds analysis analysis gains context sensitivity representing symbolic bounds variable functions polynomials rational coefficients initial values formal parameters analysis proceeds basic block generates bounds variable entry abstractly interprets statements block compute bounds variable program point inside exit basic block based bounds build symbolic constraint system solve constraints reducing linear program coefficient variables symbolic bound polynomials solve symbolic constraint system goal minimizing upper bounds maximizing lower bounds bodik describe method eliminate array bounds checks java programs method restricted form linear constraints called difference constraints solved efficient graph-traversal algorithm demand goal apply analysis array bounds checks selectively based profile information fall back run-time checks cold code blocks wagner formulated buffer-overrundetection problem integer constraint problem solved linear time practice analysis flowand context-insensitive goal finding errors abadi cardelli theory objects monographs computer science gries schneider springer-verlag york bodik gupta sarkar abcd eliminating array bounds checks demand sigplan conference programming language design implementation vancouver canada june chandra reps physical type checking paste sigplan-sigsoft workshop program analysis software tools engineering toulouse france september chase wegman zadeck analysis pointers structures sigplan conference programming language design implementation york chatterjee ryder landi relevant context inference acm symposium principles programming languages san antonio january cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation sigplan conference programming language design implementation vancouver canada june colby lee necula blau plesko cline certifying compiler java sigplan conference programming language design implementation vancouver canada june cousot halbwachs automatic discovery linear restraints variables program annual acm symposium principles programming languages tucson january javasoft java native 
interface specification release jpvm native methods interface pvm java platform http chmsr gatech jpvm mycroft type-based decompilation program reconstruction type reconstruction european symposium programming esop amsterdam netherlands march miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november milner theory type polymorphism programming journal computer system sciences page october morrisett tarditi cheng stone harper lee til compiler performance safety types workshop compiler support systems software tucson february morrisett walker crary glew system typed assembly language annual acm symposium principles programming languages san diego january morrisett crary glew walker stack-based typed assembly language workshop types compilation published xavier leroy atsushi ohori editors lecture notes computer science springerverlag morrisett crary glew grossman samuels smith walker weirich zdancewic talx realistic typed assembly language acm workshop compiler support system software atlanda necula compiling proofs dissertation carnegie mellon september necula lee design implementation certifying compiler acm sigplan conference programming language design implementation montreal canada june necula proof-carrying code annual acm symposium principles programming languages paris france january ramalingam john field frank tip aggregate structure identification application program analysis acm symposium principles programming languages san antonio january rivest message-digest algorithm request comments mit laboratory computer science rsa data security april rugina rinard symbolic bounds analysis pointers array indices accessed memory regions sigplan conference programming language design implementation vancouver canada june siff chandra ball kunchithapadam reps coping type casts seventh european software engineering conference seventh acm sigsoft symposium foundations software engineering toulouse france september smith stack smashing vulnerabilities unix operating system http destroy net machines security strom yellin extending typestate checking conditional liveness analysis ieee transactions software engineering strom yemini typestate programming language concept enhancing software reliability ieee transactions software engineering january small seltzer comparison extension technologies usenix annual technical conference san diego january smith walker morrisett alias types european symposium programming berlin germany march susuki ishihata implementation array bound checker acm symposium principles programming languages los angeles january tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating system design implementation orleans february verbrugge hendren generalized constant propagation study international conference compiler construction link ping sweden april wadler taste linear logic mathematical foundations computer science lecture notes computer science springer-verlag gdansk poland august wegner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed systems security conference san diego february miller reps safety checking machine code sigplan conference programming language design implementation vancouver canada june 
semantic minimization -valued propositional formulaea thomas repsa alexey loginova mooly sagiva abstract paper presents algorithm non-standard logicminimization problem arises -valued propositional logic problem motivated potential obtaining answers applications -valued logic answer precise definite information answer imprecise indefinite information replacing formula formula improve precision answers obtained paper give algorithm produces formula well-defined sense introduction number recent approaches verifying properties hardware software systems -valued logics sort instance -valued propositional logic symbolic trajectory evaluation ste verifying properties hardware systems program analysis dataflow analyses simultaneously track information viewed working -valued propositional logic -valued logic truth introduced denote uncertainty expressed denote truth-value gap paper concerns non-standard logic-minimization problem arises -valued propositional logic illustrate issue trivial denote formula respect assignment truth values propositional variables -valued logic formula equivalent formula -valued logic assignments assign truth contrast equivalent -valued logic values -valued assignments formula definite answer indefinite answer work supported part nsf grant ccrby onr contracts alexander von humboldt foundation comp sci dept univ wisconsin dayton madison usa e-mail reps alexeya wisc school comp sci tel-aviv univ tel-aviv israel e-mail sagiv math tau demonstrates -valued logic notion formula formulae equivalent -valued logic evaluate definite -valued assignments interest phenomenon motivated possibility exploiting obtain answers applications -valued logic answer precise definite information answer imprecise indefinite information replacing formula formula improve precision answers obtained approach problem improving simplifying subterms rewriting rules left question approach produces formula good paper give algorithm approach algorithm produces formula well-defined sense paper makes contributions provide formalization semanticminimization problem formula goal find formula sect show find formula present methods creating formula remainder paper organized sect introduces terminology notation sect defines problem semantic minimization -valued propositional logic sect presents couple methods performing semantic minimization sect defines semantic-minimization algorithm efficiency binary decision diagrams stages sect discusses related work proofs app terminology notation section define standard -valued propositional logic related -valued propositional logic semantics due kleene -valued propositional logic write propositional formulae set propositional variables propositional constants unary connective binary connectives make conditional expressions adopt c-like syntax brevity juxtaposition place overbar denote negation written propositional variables negations propositional variables referred collectively literals -valued truth-functional semantics propositional logic defined standard definition assignment finite function formula propositional variables assignment defined -valued truth-functional meaning respect denoted truth defined inductively satisfies denoted iff semantically equivalent formulae syntactically related ways denote syntactic equality formulae rearrangements conjuncts disjuncts denote extended applications morgan laws introductions cancellations double negations instance formulae -valued truth-functional meaning reserve semantic equality -valued propositional logic moving -valued logic language formulae work identical defined sect additional propositional constant shorthand defn technical reasons shorthand defn table -valued truth tables propositional operators semantic level truth introduced denote uncertainty values definite values indefinite define partial order truth values reflect degree definiteness information content denotes definite definition information order define information order truth values iff symbol denotes least-upper-bound operation respect generalize defn define meaning formula respect -valued assignment convention lower-case letters -valued assignments upper-case letters -valued assignments definition -valued assignment finite function formula propositional variables assignment defined -valued truthfunctional meaning respect denoted yields truth meaning defined inductively defn potentially satisfies denoted iff -valued truth tables propositional operators shown tab -valued logic yield equivalent definitions information order logical order figure semi-bilattice -valued logic -valued truth-functional meaning -valued logic yields precise semantics truth table sub-table obtained evaluating identical truth table defn yields definite assignment yields indefinite yields vantage point binary connective constructing formulae shorthand noted remainder paper symbol means potential-satisfaction relation defn talking -valued assignment instance shown fig values form mathematical structure semi-bilattice semi-bilattice orderings information order logical order information order defined defn captures certainty logical order tab meet join logical order logical order potential truth called designated designated values assignment potentially satisfies formula formula truth-functional meaning respect designated values information ordering values extended pointwise information ordering assignments denoted bindings propositional variable definite write lower-case kleene -valued semantics monotonic information order tab defn lemma formula assignments kleene semantics retains number properties familiar -valued logic including morgan laws ability introduce cancel double negations reason relate formulae semantically equivalent -valued logic lem relate -valued valued truth-functional meanings formulae obtained evaluating formula respect valued assignment safe greater equal information order compared obtained evaluating respect -valued assignment yields definite yield definite yields -valued assignment represents valued assignments outlook -valued -valued assignments related stems corollary immediately lem corollary suppose represents propositional formula -valued logic device accepting set -valued assignments considered formula -valued logic potential-satisfaction relation corresponds implicit condition accepting rejecting entire set -valued assignments represented valued assignment acceptance potentialsatisfaction relation safe respect actual set -valued assignments accepted assignments rep point view -valued assignments space abstract values abstract interpretation chou account ste abstractinterpretation terms adopt viewpoint sect order justify definition semanticminimization problem semantic minimization problem sect observed formula equivalent -valued logic -valued logic raises question formula turn raises question properties formula possess definition minimization problem concept formula formalized concept formula supervaluational meaning definition formula assignment valued supervaluational meaning respect denoted truth defined rep definition propositional formula formula semantically minimal variant iff -valued assignments semantic-minimization problem propositional logic propositional formula find formula semantically minimal variant instance semantically minimal variant similarly semantically minimal variant justification problem definition worthwhile spend moments defn definition semanticminimization problem contrast defn alternative definition strawman definition propositional formula semantically minimal variant iff -valued assignments motivation definition place obtain answers strictly definite obtain answers strictly definite question obtain acceptable answers strawman defn note defn semantically minimal variant contrast strawman defn formulae semantically minimal variants situation trouble meanings conflict strawman defn admissible semantically equivalent valued logic contrast defn admissible semantically equivalent -valued logic definition meaning supervaluational meaning strawman defn unsatisfactory concepts semantically minimal variant relate view formula device accepting set assignments discussion cor desideratum acceptance device view formula device accepting set assignments correspond acceptance device applied assignment -valued -valued yield precise acceptance condition circumstances waffles waffle accept reject safe respect -valued assignments accepts assignments rep similarly safe respect valued assignments accepts assignments rep instance suppose formula strawman defn formula admissible eqn hold assignments assignments rep similarly strawman defn formula admissible eqn hold assignments assignments rep defn admissible eqns hold notion acceptance device expressed nicely parallels statement 
cor consequent properties desideratum parallel property stated cor property stated cor replaced desideratum acceptance device semantically minimal variant valued assignment -valued assignment represents hold contrast unsatisfactory results obtained strawman defn lemma semantically minimal variant means concept defined defn desideratum holds proof desired properties restated proved rep rep rep rep henceforth term semantically minimal variant means concept defined defn strawman defn motivated desire obtain precise answers place fact defn property lemma semantically minimal variant -valued assignments proof semantically minimal variant monotonicity lem rep term semantically minimal variant lemma semantically minimal variant formula agrees -valued assignments -valued assignments proof semantically minimal variant monotonicity lem rep rep algorithm semantic minimization return question formula answer affirmative precisely formula equivalence class formulae solution relies result due blamey relates boolean functions -valued propositional formulae result stated couple forms yield methods creating formula sect focus special case blamey result variant define efficient minimization algorithm realization monotonic boolean functions formulae section review theorem due blamey relates monotonic boolean functions -valued propositional formulae formula realizes function iff blamey theorem states -valued function monotonic information order formula built propositional variables realizes blamey proof result explicit method constructing formula realizes givena slight abuse notation refer boolean function member make applications -valued assignment confusion result thinks function formal parameters assignment supplying values fora convention statements asa type definition monotonic function valued assignment defined define onea zeroa onea zeroa formulaa onea defa zeroa defa onea defa onea zeroa defa zeroa formulaa defa onea zeroa theorem realization theorem monotonic function formulaa realizes formulaa proof formula defa truth-functional semantics shown truth table twenty-seven disjuncts onea twenty-seven conjuncts zeroa formula created eqn formulaa reader verify eqn realizes truth table defn subtle instance assignment evaluates contributes conjunction onea formula onea necessarily onea necessarily due contributions terms capture behaves assignments onea effects blamey shown realization theorem holds applying morgan laws derive variants eqn zeroa onea onea zeroa lead variant forms eqn formulaa defa onea onea formulaa defa zeroa zeroa formulaa zeroa onea eqn formula constructed form sum-of-products product-of-sums eqn form sum-of-products sum-of-products instance eqn place eqn eqn formulaa creating semantically minimal variant defn eqns give tools needed construct semantically minimal variant formula theorem minimization theorem formulaa semantically minimal variant proof immediately defn supervaluational semantics monotonic function meets conditions thm formulaa thm semantically minimal variant formula defa table shows -valued assignments supervaluational semantics formula created semanticminimization algorithm eqn formulaa comparing eqn note additional disjuncts part eqn correspond entries truth table truth table improved construction formula blamey thesis improved construction formulaa results formula fewer complicated constituents definition monotonic function valued assignment defined formulaa defined eqns onea zeroa redefined onea defa onea zeroa defa zeroa empty disjunction empty conjunction differences eqns eqns outer connectives indexed leads fewer terms generated indices connectives range values definite onea zeroa generate literals leaving unnecessary occurrences formula defa discussed exs suppose formulaa defined eqn onea zeroa defined defn formula created formulaa formulaa eqn semantically minimal variant created formulaa formulaa eqn theorem monotonic function formulaa formula onea zeroa onea zeroa defined eqns formulaa realizes formulaa proof henceforth onea zeroa operations defined defn eqns bdd-based minimization algorithm section presents improved algorithm semantic minimization worst-case running time algorithm exponential size operations implemented bdds issues face material presented sects efficiently represent function eqns efficiently implement indexing operations needed outermost connectives approach issue bdds approach issue based observation observation realization theorem construct -valued propositional formula realizes monotonic boolean function realization problem arises semantic-minimization problem require general method semantic-minimization problem monotonic boolean functions arise range concerned realization problems form formulaa focusing special case realization problem sidestep issue implementing onea zeroa differently stated eqns approach takes advantage bdd-based representation address issue representing supervaluational semantics goal find semantically minimal variant truth-valuational semantics equal supervaluational semantics rep order capture concern truth-functional semantics definite assignments portion truth-functional semantics words functions functions functions type called boolean functions don cares incompletely boolean functions incompletely boolean functiona represented pair total boolean functions functions denoted conflates conflates types boolean functions play role paper -valued boolean functions incompletely boolean functions total boolean functions introduce special notation distinguish functions represented ordinary bdds proposed minato capture function represented pair functions formula propositional variables accomplished traversing applying translation rules bottom-up operations total boolean functions required right-hand sides rules standard repertoire bdd operations creation bdds application boolean operations existing bdds ite realization semantic minimization definition superscripted propositional variable stands literal total boolean function propositional variables conjunction literals propositional variable appears negated unnegated implicant ofa -valued assignment havea conjunction literals form shown thought set literals implicant prime implicant proper subsets implicant corresponds conjunction literals implicant types terms form denote total boolean functions occurrences denote incompletely boolean functions total boolean functions denote -valued boolean functions clear context intended implicants implicants prime implicants concern realization problems form formulaa show case realization implemented formulaa primesa primesa primesa operation total boolean function creates disjunction prime implicants primesa defa prime implicant lemma -valued assignment formula onea prime implicant proof app lemma prime implicant -valued assignment iii onea proof app results yield procedure semantic minimization theorem primesa primesa semantically minimal variant proof defn eqn lemmas onea primesa represented translation method equals implies zeroa dma onea primesa primesa claim thms formula minimizeformula formula transform translation method return primesa primesa figure minimization algorithm thm justification function minimizeformula shown fig propositional formula input minimizeformula creates returns semantically minimal variant minimizeformula auxiliary procedure primesa creates sum-of-primeimplicants formula formula methods efficiently generating prime implicants step methods start bdd representation ofa line implemented bdds kind input structure hand return formula defa exs minimizeformula create formula eqn minimizeformula arrive answer efficient method formulaa drawback minimizeformula generate prime implicants substitute sum-of-products expressions represent function -valued logic irredundant prime cover approach tenable instance formula defa substitute irredundant-prime-cover algorithm calls primesa line minimizeformula formula formula semantically minimal variant assignment eqn evaluates formula evaluates formula worse eqn assignment eqn evaluate formula evaluates semantically minimal formulae section derive forms subject thm express semantically minimal formula proof theorem found app theorem total boolean function primesa primesa proof thm showed onea primesa zeroa dma primesa imply onea primesa zeroa primesa applying thm results relationships onea primesa 
zeroa primesa mix match eqns create expressions yield semantically minimal formulae thm function minimizeformula fig creates semantically minimal variant expressions line sum-of-products sum-of-products sum-of-products primes primes primesa primes sum-of-products primes primes primes primes term sum-of-products form put product-of-sums form blow-up size applying morgan laws create semantically minimal formula combination sum-of-products product-of-sums terms desire final result condition generate semantically minimal variant occurrence corollary suppose formula total boolean function defa primesa primesa semantically minimal variants proof total boolean function result eqns elimination duplicate terms diagonal entries table formula explicit occurrence semantically minimal variant occurrence formula defa valued logic treated syntactic shorthand sect discussed suitable syntactic shorthand extension -valued logic suitable shorthand derive means results semantic minimization explicit occurrence total boolean function primesa semantically minimal variant related work substantial body work addresses methods syntactic minimization propositional formula previous work addressed finding minimal-size sum-ofproducts formulae minimal-size formulae forms contrast paper concerns semantic minimization -valued propositional logic minimization criterion semantic syntactic formula results necessarily smaller realization problem versions realization theorem due blamey blamey work address semanticminimization problem defined sect sect focused special case realization problem allowed define semantic-minimization algorithm minimizeformula efficient general realization constructions blamey motivation investigating semanticminimization problem propositional logic heuristic creating formulae -valued first-order logic transitive-closure operator logic basis system shape analysis determination information heap-allocated data structures program manipulates broadly variety static analyses programs manipulate heap-allocated data structures replacing formula formula improve precision answers system obtains implemented minimizeformula subroutine heuristic method minimizing first-order formulae method works formula bottom-up applying minimizeformula body non-propositional operator quantifier transitive-closure operator acknowledgments blamey providing copy preliminary version blamey partial logic gabbay guenthner editors handbook philosophical logic volume kluwer acad preparation blamey partial-valued logic phd thesis oxford oxford england blamey partial logic gabbay guenthner editors handbook philosophical logic volume alternatives classical logic pages bodik gupta soffa complete removal redundant computations sigplan conf prog lang design impl pages brace rudell bryant efficient implementation bdd package proc acm ieee design automation conf pages bryant graph-based algorithms boolean function manipulation ieee trans comp aug chou mathematical foundation symbolic trajectory evaluation proc computer-aided verif springerverlag july coudert two-level logic minimization overview integration vlsi journal oct coudert madre graph based prime computation technique sasao editor logic synthesis optimization pages kluwer acad norwell coudert madre fraisse touati implicit prime cover computation overview proc workshop synth syst int mixed tech oct ginsberg multivalued logics uniform approach inference artificial intelligence comp intell jain formal verification symbolic trajectory evaluation phd thesis carnegie mellon univ pittsburgh july kleene introduction metamathematics north-holland edition lev-ami sagiv tvla system implementing static analyses static analysis symp pages minato fast generation irredundant sum-of-products forms binary decision diagrams proc workshop synth syst int mixed tech pages apr minato ishiura yajima shared binary decision diagram attributed edges efficient boolean function manipulation design automation conf pages york acm quine problem simplifying truth functions amer math monthly oct sagiv reps wilhelm parametric shape analysis -valued logic symp princ prog lang pages york jan acm press sagiv reps wilhelm parametric shape analysis debugging -valued logic run-time trans type prog checking lang alexey loginov suan syst hsi yong susan horwitz sagiv thomas francez reps computer rodeh sciences department wilhelm logicbased approach data flow analysis wisconsin-madison problems west acta dayton street inf madison june usa falexey sasao suan ternary decision diagrams horwitz repsg applications wisc sasao fujita pages sasao abstract fujita paper editors describes representations discrete design functions implementation kluwer acad tool norwell programs seger run-time checks bryant based formal type verification information symbolic tool evaluation instruments partially-ordered program trajectories monitor formal type methods stored system memory design location mar van fraassen singular terms truth-value gaps free logic phil sept proofs lemma -valued assignment written location location run-time formula type tag updated match type location static type onea compared type mismatch warning prime message implicant issued location proof run-time defn type tag checked type eqn inappropriate presence context guard error message issued tool index pinpoint bugs solaris conjunction utilities olden benchmarks conjunction providing literals information form succinct shown precise introduction conjunction java programmers security knowing errors out-of-bounds array indexes attempts dereference null pointer detected reported assumption runtime java security strong type system union types java program write defn eld implies type access eld monotonic function erent type restricted kinds casting allowed treat pointer rep integer vice versa object down-cast subtype run-time check performed ensure actual type object consistent cast definition programmers implies lucky languages liberal java programmers express static type system weaker run-time system protection errors caused misuse casts bad pointer dereferences array out-of-bounds errors programmers purify safe-c shadow processing detect bad memory accesses implicant tools provide additional kinds errors prime implicant introduced programs due righthand weak side type eqn systems set paper describes literals design implementation tool programs performs run-time checks based type information tool instruments program strict monitor type stored memory location static type location due unions pointers casting written location location runtime type tag updated match type location static type compared type mismatch warning message issued location run-time type tag checked type inappropriate context error message issued tool run-time storage violations found purify uninitialized variable out-of-bounds array access cases tool error messages roughly equivalent reported purify run faulty program warning messages provide information occurred prior error great identify statements caused error addition tool potential errors purify detect write member union read member erent type preliminary tests tool bugs solaris utilities olden benchmarks information provided tool succinct precise showing location error remainder paper organized section examples illustrate tool works kinds errors detect section describes preliminary implementation tool section discusses results experiments section concerns related work motivating examples section provide motivating examples illustrate potential bene providing run-time type checking case describe kind error made tool detect error run-time interesting issues raised bad union access simple logical error manifests bad run-time type writing eld union reading eld erent type illustrated code fragment union int int int write read warning subset bad pointer deref set error literals integer written variable line subsequently read pointer line assignment read stored variable assumption dereferenced line symptom error attempt means defn address line actual point error rep line type read -valued assignment type run-time type static type tool purify means report error precisely line executed point line source error recall tool instruments program track run-time types memory locations single location corresponds run-time type type set int assignment line line location read assigned pointer type mismatch tool produce warning message line executed error message reporting run-time type violation line heterogeneous arrays programmers avoid overhead malloc free functions writing dynamic memory-management functions programmer allocate large chunk memory single call malloc assignment char mymemory char malloc blocksize blocksize large integer subsequently memory needed call user-de ned function mymalloc made call malloc mymalloc function returns pointer part mymemory chunk similarly calls free replaced calls myfree updates data structures track parts mymemory mymemory chunk heterogeneous array erent parts array values erent types programmer code include declarations calls struct node int data struct node tmp int int mymalloc sizeof int struct node mymalloc sizeof struct node call line allocates array integers call line allocates node linked list suppose bug programmer memory-allocation code return overlapping chunks memory assume assigned variable line address addition assume pointers integers bytes padding elds struct node case call mymalloc line address data address address address statements executed struct node mymalloc sizeof struct node tmp refer location assignment line overwrites assigned line essentially replacing link node list list-terminating null future accesses list node assignments lines erent parts code unrelated functions source error cult track tool purify bad pointer dereferences array-access errors assignment line set future accesses list bad pointer dereference detected tool purify bad union access purify locate source error tool tag elements mymemory run-time types assignment line location corresponds tagged type pointer assignment line change tag int finally line warning message reported location tagged run-time type int assigned pointer tmp structures simulate inheritance object-oriented language classes programmers simulate features classes structures declarations simulate declaration superclass subclass struct int int struct int int char function written perform operation objects superclass void struct function called actual arguments type struct struct struct struct ansi standard guarantees rst eld structure stored set structures common initial sequence initial sequence elds compatible types elds initial sequence stored sets elds guaranteed set elds guaranteed set call compile-time warning averted type cast compile-time error runtime error assignments function correctly set values programmer forget convention struct supposed subtype struct change type common elds add eld struct adding eld struct add eld struct eld suppose declaration struct changed struct int float int char call executed assignment write eld eld fact eld correctly set call fact eld overwritten garbage lead run-time error execution program produce incorrect output run-time types assignment tagged type int context requires float result error message due mismatch required type float current run-time type int note tool purify report errors bad pointer array accesses function writing bounds structure parameter wrong part structure programmer point view implementation debugging tool implemented ansi major components compiler front-end instruments program run-time system tracks dynamic type memory location tracking type information run-time types tracked unallocated uninitialized integral real pointer aggregate objects structures arrays eld element tag pragmatic reasons typedefs erent pointer types distinguished distinguish erent user-de ned types erent kinds pointers priori upper bound number types program upper bound number bits required represent type greatly complicate run-time type checking run-time component tool implemented storing type information mirror memory program byte memory maps four-bit nibble mirror bits continuation bit encodes extent object denotes start object denotes continuation nibble data bits encode information rst nibble object tag data bits encode object current type nibble object larger byte size data bits encode log size object scheme quick comparisons objects comparing rst bits nibbles tags objects 
larger bytes remaining data bits unused potentially encode information future enhancements optimizations tags common scalar types sizes illustrated unused unused unused unused unused unused int int bytes int char byte log uninitialized short bytes pointer bytes double bytes ptr log uninit log real log uninitialized char byte uninit mirror allocated segments user memory amount memory program increases pointers mirror pages stored table indexed signi bits user-space address accesses object tag fast interface run-time system consists primarily procedures implemented macros cut overhead function calls set tag setuninittag setscalartag copy tag copytag verify tag agrees expected type verifytag procedure verifyptr verify pointer points allocated memory dereferenced set procedures handle passing function parameters return values processargtag processreturn source-level instrumentation instrument program tool performs source-to-source transformation source les ckit front end written working source level tool access source-level type information exibility comma operator makes preserve ansi semantics original program retaining portability instrumented principle compiled multiple platforms handling language non-trivial number features make correct instrumentation cult summary instrumentation actions tool performs highlights issues main occurrence main renamed prog main run-time system nes main function performs initialization calling prog main lter command-line arguments run-time system initialize tags argv arrays recursive calls main problems statements expressions program statement component expressions instrumented set syntax-directed transformations code setting copying verifying tags added expressions instrumented code makes extensive comma operator section locals local variables initially tagged uninitialized local variable initialized processed initialization expression assigned variable instrumentation code address variables register variables demoted auto variables tags bit elds initialized address bit eld bit elds remain tagged uninitialized triggers type-violation warnings errors bit eld type-unsafe manner globals tags global variables initialized special init function function created source main function calls init functions calling prog main list init functions erent source les collected link time externs extern variables ned instrumented source implicant les treated specially instrumented source les linked prime implicant uninstrumented object code commonly library modules assume lemma extern variables prime well-behaved implicant initialize tags declared types tool -valued limited assignment visible initialize tags incomplete array types extern int size array visible calls handle function calls iii tags function parameters communicated caller callee callsite onea code added store tags actual parameters array proof address product global pointer globalargtags head function nition code note ckit front end support c-preprocessor directives assignment present instrument preprocessed code limits portability extent fundamental limitation approach added extract prime implicant tags parameters passed function mechanism represented pass tag return back callsite mix instrumented uninstrumented functions work properly including instrumented functions invoked callbacks uninstrumented functions instrumented caller stores address callee global pointer globalcalltarget instrumented callee compares address definition globalcalltarget addresses match means caller instrumented tags defn function arguments return processed addresses defn match means caller uninstrumented tags function parameters extracted globalargtags return return formula statement end property holds function vacuously mirror assume entire stack frame binds cleared definite assignment agree possibly empty set assumptions implicant -valued assignment unallocated processreturn procedure run-time system start stack frame assumed greatest addresses definition formal parameters rst local variable declared pick variable specially added represented instrumentation process call prime processreturn implicant advanced stack-frame pointer end stack frame lower bound end stack frame obtained defn taking address local variable declared processreturn instrumentation definition program instrumented transforming statements contained bodies program defn functions expressions statement replaced represented result call instrumentation function instr-expr takes arguments exp rep expression instrumented boolean enforce optional pointer argument tagptr enforce speci expression run-time type match static iii type rewritten expression context sensitive type expression data ect respective showed static types enforce true instrumenting formula turn hand expressed expression type data relevant type-safety onea instrumented enforce false presence optional pointer argument lemma tagptr total instrumenting boolean function expression primesa enclosing expression access primesa type proof case tagptr -valued convey assignment defn information output monotonicity applying instr-expr lem common expressions shown table assuming stack primesa grows memory high low addresses stacks grow upwards lowest addresses formal parameters rst local variable omit details complicate instance perform slightly erent actions instrumenting lvalues rvalues table examples instrumentation rules exp instr-expr exp enforce instr-expr exp enforce tagptr verifytag typeof tagptr verifytag typeof tmpptr instr-expr true verifytag tmpptr typeof tmpptr yields tagptr definite instr-expr true verifytag tagptr primesa typeof tagptr tmpassign instr-expr yield false tmpptr instr-expr enforce case tmpptr copytag primesa tmpptr tmpptr typeof tmpassign tmpassign instr-expr false show tagptr instr-expr enforce tmpptr copytag primesa tagptr tmpptr typeof tmpassign omit enforce false call verifyptr show enforce false exist tmp definite variables assignments rep rules table temporaries primesa type introduced instrumentation code instrumented expression rep shown columns primesa column shows instrumentation carried optional pick argument disjunct absent primesa column shows evaluates instrumentation strategy assignment argument tagptr defa present run-time tagptr variable set point object mirror tagged expression dynamic type variables instrumentation code enclosing expression rules create enforce true replacing verifytag procedure binding verify tag object agrees declared type case check enforce true verify dynamic type agrees primesa declared type dereference case subexpression suppose rst instrumented sake passing enforce argument true instr-expr rep dereferenced primesa pointer enforce true verify dynamic defn type implies agrees declared type represented enforce false require dynamic means formula implicant type match declared primesa type disjunct make considered set literals unallocated subset points considered valid set memory literals performed verifyptr procedure tool means output error primesa message invalid pointer dereference occurs assignment contradicts case assumption expression instrumented subsequent assumption enforce false assumption incorrect care total type boolean function data definite assignment overwritten instrumented primesa enforce true assignment expression fact instrumented assumption enforce incorrect true implies copytag exist procedure copies rep tag primesa right-hand-side expression mirror lemma left-hand-side expression total boolean expression function lvalue definite rvalue assignments primesa primesa proof primesa defn larger primesa context avoid preserving instrumented expression issues defn warning message type primesa right-hand-side expression compatible static theorem type total left-hand-side boolean expression function primesa cases instrumented code primesa form ptr proof instrumented expression -valued assignment valid lvalue primesa assignment expression lvalue primesa instrumented lem rep assignment rvalue primesa larger context make defn rep instrumented expression preserves primesa correct rvalue purpose lem tmpassign rep instrumenting statement primesa assignment occur context rep type primesa veri assignment instrumented enforce false enclosing expression access assignment type optional tagptr argument needed assuming type int type int result instr-expr false shown figure notice tmp variable outermost level assignment expression omitted case assignment rvalue preserved tmp tmp verifytag pointer type verifyptr tmp sizeof int tmp copytag tmp tmp int type fig output instr-expr false features order perform proper type checking tool handle memorymanagement functions specially replace call malloc relatives version successfully allocating block memory initializes mirror memory block uninitialized tag similarly free function resets mirror unallocated type versions functions bookkeeping bytes freed call free run-time version malloc adds padding allocated blocks decrease likelihood stray pointer jumping block approach purify stack allocation function alloca instrument callsites additionally invoke procedures initialize newly allocated stack space routine handled specially variable argument routine arg implemented macro portable solution assumes argument obtained properly typed instrument invocation primesa defn primesa lem primesa 
arg return tag expression static type mentioned section approach link instrumented modules uninstrumented requirement program main function renamed prog 
main exibility programmer debug small component large program instrument les interest link uninstrumented object modules caveat lead reporting spurious warning error messages uninstrumented parts code maintain type information valid object uninstrumented portion program passed instrumented function tool object unallocated output spurious errors warnings problem extends general library modules values function memcpy initialization values input function fgets types data static returned function ctime captured handle created collection instrumented versions common library functions ect type wrappers original functions hand-written perform tag-update operations capture type behavior finally tool lends naturally interactive debugging warning error message issued signal sigusr intercepted interactive debugger gdb user examine memory locations including mirror make gdb features track error experiments test ectiveness debugging tool fuzz solaris utilities crash inputs instrumented programs testing nroff plot units col tracked bugs programs olden benchmark suite health voronoi summary tool revealed runs nro array pointers accessed negative index retrieved word dereferenced segmentation fault instrumented program crashing warns retrieved word dereferenced array characters plot rogue pointer passing bounds local array walks stack writing bytes eventually attempts write invalid memory point program crashes instrumented program outputs long list warning messages signaling writes unallocated memory accurately identifying line code occurs original program crashes call fgetwc instrumented program crashes call fprintf instrumentation code attempting write warning message crash original program cult diagnose accessing unallocated memory error messages generated instrumented program led crash pointer passing bounds array walks bss section eventually overwrites part global iob array information stdin stdout stderr subsequent call fgetwc original code fprintf instrumented code crash units original program errant pointer manages corrupt save area call stack resulting bizarre behavior cult track tool instrumented program issues type-violation error message character pointer set point subsequently write character dereference generates error message program crashes col original program crashes dereference bad pointer instrumented program crash fails terminate hours stopped waiting terminate rst error messages generated instrumented program signals dereference unallocated memory points line program crash occurs uninstrumented code point error message generated close pointer rst stepped bounds global array pointed health semantics memory allocated malloc unlike calloc required zero-initialized programmers assume program pointer elds recursive data structures initialized allocation malloc traversing structures original program counts pointer elds null absence substructure instrumented program warns access uninitialized memory time program checks pointer elds null testing platform memory allocated malloc program happen zero-initialized program crash erroneous assumption malloc program crash erent execution program run erent platform voronoi bit-level manipulations performed pointer struct yielding pointer eld belong struct assumptions made voronoi size struct hold test machine subsequent assignment pointer function argument generates warning message stating unallocated object passed pointer null dereferenced instrumented program accessing unallocated memory error message crashing cases crashes test programs found caused pointer array index astray case tool detect out-of-bounds memory accesses type pointedto memory erent expected type results encouraging kinds errors detected purify easily create examples section tool detect errors detected purify found examples kinds bugs real programs suspect bugs occur larger complicated programs due limitations current version ckit front end table performance benchmarks lines code reports number unpreprocessed lines source code comments blank lines removed running time secs lines uninstruinstru- slowsource program code mented mented olden benchbisort marks health mst perimeter power treeadd tsp spec compress benchgcc marks ksim vortex solaris col utilities nro plot units successfully compile large programs code date testing technique cases robust code time result likelihood nding errors lower tool applied code software-development cycle surprisingly extensive checking performed tool performance cost cost due execution type-tracking procedures transformation original program expressions complicated order type tracking preserving original expressions values types side-e ects measure executiontime overhead introduced tool instrumented solaris utilities programs spec olden benchmarks benchmarks optimized gcc option executed legitimate non-crashing inputs mhz sun ultra workstation ram virtual memory sizes gcc optimized instrumented version behaved erently original version unknown reasons benchmarks execution times user system time seconds slowdowns reported table slowdowns observe benchmarks range times times median point comparison slowdown factor purify range exorbitant slowdown due program making assignments structures tag-copying procedure copytag performs ine cient nibble-bynibble copy spec benchmarks nroff performance degradation largely due overhead writing spurious warning error messages result tool inability cleanly capture type behavior calloc-initialized memory incomplete array types ctype array ctype macros programs performing masking operations treat integers arrays characters technically type violation future work includes results static analysis reduce amount instrumentation introduced tool reducing overhead location multiple times possibility type modi rst checked related work run-time type-checking idea implemented functionalstyle languages lisp scheme object-oriented languages java smalltalk objective-c designing dynamic type-checking language includes unions structures arrays bounds checking casting pointer arithmetic large undertaking additionally subtle erence approach traditional dynamic type-checking attaches tags data approach separates tag space data space approaches attain good spatial locality accesses case separated tags data locality tag accesses mirrors locality data accesses checking tags eliminated based static analysis locality accesses data case co-located tags data signi advantage fact tags protected erroneous accesses user code user code simply make erroneous accesses separated tag space guarantees required memory-protecting hardware shield tag space execution user code concept soft typing introduced ort combine bene static dynamic typing functional-style languages approach static typing employed identify program statements statically type check statements subsequently instrumented dynamically type-checked earlier work concentrates presenting framework soft typing restricted class programming languages work extends work handle realistic languages scheme addressing traditionally dynamically typed language emphasis put application soft typing lowering run-time overhead type-checking body work similar approach type-checking erences languages handled approaches signi approaches detection errors programs means executing program instrumented perform run-time checks developed past safe-c run-time detection array access pointer dereference errors array out-of-bounds errors stale-pointer accesses accesses resulting erroneous pointer arithmetic keeping track attributes referent pointer transforming code code taking advantage operator overloading perform checks operators applied purify detects errors similar found safe-c addition identi uninitialized memory reads memory leaks purify performs checks instrumenting object les modifying layout heap-allocated memory order catch access errors approach catches errors addition run-time type violations covered purify safe-c warning messages provided tool provide history suspicious type propagation aid pinpointing true error realm security tools developed prevent 
stack smashing return address activation record modi malicious agent obtain control program tool detects attacks fall general category type errors detected tool technique enable cient checking array-access pointer-dereference errors multiprocessor environment presented achieve lowcost checking creating version program computations ect pointer array accesses instrumenting version running parallel original program technique improve tool performance number orts address problem identifying errors programs due out-of-bounds array indexes misuses type casts based static analysis work static analysis applied checking out-of-bounds array accesses includes algorithms points-to analysis distinguish elds structures so-called physical type checking perform static safety checks work based static analysis cited ow-insensitive techniques enormous number warnings misuses generated applied safety checking real-life programs advantage dynamic type-checking tool reported paper ability obtain accurate information type misuses access errors albeit occur run program hasting joyce purify fast detection memory leaks access errors proceedings winter usenix conference austin breach sohi cient detection pointer array access errors acm sigplan conference programming language design implementation patil fischer low-cost concurrent checking pointer array accesses programs software practice experience chandra ball kunchithapadam reps coping type casts proc esec fse seventh european softw eng conf seventh acm sigsoft symp found softw eng pages september ckit http bell-labs smlnj doc ckit stallman pesch gdb guide gnu source-level debugger july miller koski lee maganty murthy natarajan steidl fuzz revisited re-examination reliability unix utilities services technical report wisconsin-madison fagan soft typing approach type checking dynamically typed languages technical report department comp sci rice univ houston usa march wright practical soft typing technical report department comp sci rice univ houston usa april immunix stack guard http immunix stackguard html stack shield http angel stackshield info html cousot halbwachs automatic discovery linear restraints variables program conf rec annual acm symp princ prog lang pages acm january verbrugge hendren generalized constant propagation study int conf compiler construction volume lec notes comp sci pages springer april rugina rinard symbolic bounds analysis pointers array indices accessed memory regions sigplan conf prog lang design impl pages york acm press bodik gupta sarkar abcd eliminating array bounds checks demand sigplan conf prog lang design impl pages york acm press wagner foster brewer aiken rst step automated detection overrun vulnerabilities symposium network distributed systems security ndss pages san diego february steensgaard points-to analysis type inference programs structures unions int conf compiler construction volume lec notes comp sci pages springer april yong horwitz reps pointer analysis programs structures casting acm sigplan conference programming language design implementation pages chandra reps physical type checking proc paste sigplan-sigsoft workshop program analysis softw tools eng pages york acm 
verifying temporal heap properties evolution logic eran yahav thomas reps mooly sagiv reinhard wilhelm school comp sci tel-aviv univ tel-aviv israel fyahave msagivg post tau comp sci dept univ wisconsin madison usa reps wisc informatik univ des saarlandes saarbr ucken germany wilhelm uni-sb abstract paper addresses problem establishing temporal properties programs written languages java make extensive heap allocate deallocate objects threads establishing liveness properties hard challenge crucial obstacles heap locations static names number heap locations unbounded paper presents framework verification java-like programs unlike classical model checking propositional temporal logic first-order temporal logic temporal properties heap evolutions logic domain expressed permits allocation deallocation modelled naturally paper presents abstract-interpretation algorithm automatically verifies temporal properties expressed logic introduction modern programming languages java make extensive heap contents heap evolve program execution due dynamic allocation deallocation objects java threads first-class objects dynamically allocated statically reasoning temporal properties programs challenging priori bounds number allocated objects restrictions heap evolve proving liveness properties programs thread eventually created response request made web server difficult task contributions paper summarized introduce first-order modal temporal logic specifications temporal properties programs dynamically evolving heaps stated natural manner develop abstract interpretation verifying program satisfies specification implemented prototype analysis tvla system applied verify temporal properties including liveness properties java programs evolving heaps framework verify general heap-evolution properties framework general manner properties heap evolution properties garbagecollection algorithms verify termination sequential heap-manipulating programs termination shown providing ranking function based set items reachable variable iterating linked data structure verified termination programs research supported grant ministry science israel grant academy science israel rtd project ist- daedalus european programme onr contract von humboldt foundation verify temporal properties concurrent heap-manipulating programs framework verify temporal properties concurrent heap-manipulating programs liveness properties absence starvation programs mutual exclusion response properties applied analysis programs unbounded number threads due space limitations prototype implementation discussed remainder paper organized section overview verification method contrasts previous work section introduces trace semantics based first-order modal logic discusses state trace properties language evolution logic section defines implementation trace semantics first-order logic section shows abstract traces conservatively represent sets concrete traces section summarizes related work finally section concludes paper overview temporal logic supporting evolution specification language evolution temporal logic etl first-order linear temporal logic properties program execution dynamically allocated memory heap evolve natural concrete semantics program set execution traces trace infinite sequence worlds first-order logical structures provide natural representation worlds unbounded number objects individual structure domain universe corresponds anonymous unique store location predicates represent properties store locations representation properties heap contents maintained abstracting information actual physical locations store rise traces worlds trace domains traces models first-order modal logic varying-domain semantics equivalently naturally modelled constantdomain semantics framework generalizes specification methods address dynamic allocation deallocation objects threads descriptive power propositional ltl finite-state machines program properties verified showing hold traces technically evaluating first-order modal-logic formulae traces variant lewis counterpart theory cast modal models formula evaluation terms classical predicate logic transitive closure fotc program verification concrete semantics non-computable general represent potentially infinite sets infinite concrete traces abstract trace infinite parts concrete traces folded cycles abstract traces termination abstract interpretation arbitrary program guaranteed bounding size abstract trace abstractions employed representing multiple concrete worlds single abstract world creating cycles abstract world reoccurs trace abstractions fail show correctness programs correct fortunately reduction arguments progress monitors employed program-verification techniques finite-state model checking specification formula affect abstraction making abstract traces fulfill formula distinguished abstraction fold history trace single state idea specification affect precision analysis handle safety properties overview verification procedure property etl formula translated straightforward manner fotc logical formula translation procedure appendix abstract-interpretation procedure applied explore finite representations set traces kleene -valued logic conservatively interpret formulae abstract-interpretation procedure essentially computes greatest fixed point set traces starting abstract trace represents infinite traces initial state gradually increasing set abstract traces reducing set represented concrete traces finally formula evaluated abstract traces fixed point satisfied original etl formula satisfied infinite traces program case programs satisfy etl specification analysis yields running web server thread dynamically allocated handle http request received thread handles single request terminates subject garbage collection assume worker threads compete exclusively shared resource exclusive access data file figure shows fragments java program implements naive web server public class worker implements runnable request request resource resource public void run synchronized resource resource processrequest request lwc fig java fragment worker thread web server explicit scheduling number properties naive web-server implementation shown tab properties ignore formulae column clear etl syntax introduced sec due unbounded arrival requests web server fact thread dynamically created request absence starvation hold naive implementation guarantee absence starvation introduce scheduler thread web server web server consists listener thread queue worker threads managed scheduler thread listener thread receives http request creates worker thread places thread scheduling queue scheduler thread picks worker thread queue starts execution naive implementation web server scheduler number additional properties interest exist labeled additional properties interest figure shows fragments web-server program threads explicit fifo scheduler ability framework model explicit scheduling queues mechanism addressing issues fairness presence dynamic allocation threads discussion fairness scope paper public class scheduler implements runnable protected queue schedq protected resource resource public void run true synchronized resource resource isacquired resource wait block queue empty worker schedq dequeue worker start public class listener implements runnable protected queue schedq public void run true req rqstream readobject worker thread worker req schedq enqueue worker public class worker implements runnable request req resource resource public void run synchronized resource resource processrequest req lwc resource notifyall fig java code fragment web server explicit scheduler description formula mutual exclusion shared resource thread lwc absence starvation worker threads thread lwc thread created whena request received thread thread request request thread creation request thread mutual exclusion listener schedulerover scheduling queue thread created thread eventuallyinserted scheduling queue thread queue rval head scheduled worker thread wasremoved scheduling queue thread queue rval head worker thread waiting queueeventually leaves queue queue thread rval head rval head table web server etl specification predicates tab trace-based evolution semantics section define trace-based semantic domain programs manipulate unbounded amounts dynamically allocated storage temporal properties programs employ first-order modal logic logics defined general constant-domain semantics domain 
worlds fixed varying-domain semantics domains worlds vary domains worlds overlap general setting types semantics object exist single world equality relation predefined express global equality individuals model semantics languages java hide implementation details dynamic memory allocation semantics varying domains semantics deliberately restricted intended application program analysis design evolution semantics notion equality presence dynamic allocation deallocation update predefined global-equality relation evolution semantics adapted lewis counterpart semantics evolution counterpoint semantics individual exist single world world domain domains worlds non-intersecting model equality defined single world boundary individuals worlds unequal definition relate individuals worlds evolution mapping defined unlike lewis interested evolution mapping reflexive transitive symmetric models fact computation allocated memory cell change identity deallocated sec show track statically presence abstraction equivalence relation induced evolution mapping add skip action exit program terminating traces embedded infinite traces semantics program set infinite traces rest paper work fixed set predicates vocabulary feq pkg denote set predicates arity definition world program configuration represented first-order logical structure huw domain universe structure interpretation function mapping predicates truth values ukw distinct individuals definition trace infinite sequence worlds world represents global state program initial state successor world derived applying single program action set individuals deallocated set individuals newly allocated iii pair consecutive worlds related stepwise evolution function bijective renaming function extracting trace properties extract trace properties language relate information worlds trace define language evolution logic etl first-order linear temporal logic transitive closure definition etl syntax etl formula defined tcv logical variables set free variables formula denoted defined usual transitive closure formula nfv operators specification refer exact moments birth death individual shorthand formulae convenience formulae shorthand notations shorthand tcv binary predicate examples predicates record information single world include predicates tab additional predicates defined sections set predicates fat lab lab labelsg parameterized set program labels similarly set predicates frval fld fld fieldsg parameterized set selector fields shorthand notation rval fld rval rval fld transitive closure properties relating unbounded length heap-allocated data structures inrval fld unary predicates thread represent type information expressed many-sorted logic decided avoid expository purposes convenience define shorthands type type type type predicates intended meaning thread thread fat lab lab labelsg thread label lab frval fld fld fieldsg field fld object points object heldby lock held thread blocked thread blocked lock waiting thread waiting lock table predicates record information single world property tab specifies absence starvation worker threads fig formula thread lwc states thread eventually enters critical section formula thread lwc expresses fact globally thread eventually enters critical section property states globally individual allocated program execution eventually deallocated note universal quantifier quantifies individuals world evaluated property instance commonly response structure allocation world deallocation response future world properties thread llh rval llh rval thread llh rval llh rval establish ranking function linked data structures based transitive reachability properties state loop head llh set individuals transitively reachable program variable decreases iteration loop typically pointer traverses linked data structure loop note properties relate unbounded number individuals world operators extended handle allocation deallocation possibly unbounded set individuals property thread fld ields rval fld desired property garbage collector non-reachable items eventually collected evolution semantics definitions head denotes world trace tail denotes suffix world denotes suffix starting i-th world denote world finite trace prefix definition evolution mapping finite prefix length trace individual uhead evolves individual ulast trace steps write sequence individuals successive worlds definition assignment evolution finite prefix length trace formula assignment mapping free variables individuals domain uhead evolves steps free variable fvi fvi fvi fvi uhead fvi ulast definition etl evolution semantics define inductively etl formula satisfied trace assignment denoted head exists uhead exists uhead ahead tail dhead exists tail exists write assignment worth noting first-order quantifiers definition range individuals single world effect achieved evolution mapping ability reason individuals worlds relate essence assignment binds evolution individual domain world quantifier evaluated semantics combination first-order quantifiers modal operators creates complications occur propositional temporal logics quantification domain quantifier vary domain underlying worlds varies verification etl properties requires mechanism recording domain related currworld succ succx currworld succ succx fig interaction first-order quantifiers temporal operators quantifier relating members quantification domains individuals future worlds etl mechanism provided evolution-mappings relate individuals world individuals successor world transitively composing evolution-mappings captures evolution individuals trace formula states pointer variable remains constant program execution points object existed program initial world hand formula states null allowed point objects times program execution point objects exist initial world examples illustrating situations shown fig points object worlds points objects worlds definition program satisfies etl formula infinite traces program satisfy evolution semantics world domain conceptually representing varying-domain semantics dynamic allocation deallocation objects threads section give implementation semantics terms evolving first-order logical structures separable specifications interesting subclasses etl verification problem easier classes spatially separable specifications place requirements relationships individuals world individual considered separately verification problem handled set propositional verification problems temporally separable specifications relate individuals worlds essentially corresponds extraction propositional information world temporal specifications extracted propositions class addressed expressing trace semantics first-order logic section first-order logic express trace semantics encode temporal operators standard first-order quantifiers automatically derive abstract semantics section approach extends kinds temporal logic -calculus initial experience demonstrate temporal properties including liveness properties hold programs dynamically allocated storage representing infinite traces first-order structures encode trace infinite first-order logical structure set designated predicates tab successive worlds connected thesuccpredicate world trace arbitrary number individuals predicate exists relates individual world exists individual exists single world evolution predicate relates individual counterpart successor world predicates isnew isfreed hold newly created deallocated individuals model allocation deallocation operators definition concrete trace trace encoded infinite first-order logical structure hut domain trace interpretation function mapping predicates truth logical structure ukt exclude structures represent valid traces impose integrity constraints require world successor predecessor equality reflexive predicate intended meaning world world currworld current world initialworld initial world succ successor predicate intended meaning exists object world evolution object evolves isnew object isfreed object freed table trace predicates rval rval rval succsucc rval rval rval heldby rval rval rval heldby blocked currworld rval rval rval heldby blocked blocked succ initialworld succ fig concrete trace figure shows worlds trace world depicted large node nodes worlds trace related successor edges 
information single world represented first-order logical structure shown directed graph node graph corresponds heapallocated object hexagon nodes correspond thread objects small round nodes types heap-allocated objects predicates holding object shown inside object node binary predicates shown edges brevity label rval stand rval resource grey edges crossing world boundaries evolution edges relate objects worlds note edges cross world boundaries exact extraction trace properties traces represented first-order logical structures trace properties extracted evaluating formulae first-order logic transitive closure translate etl formula fotc formula making underlying trace structure explicit translating temporal operators fotc claims worlds trace translation procedure straightforward appendix property thread lwc translated world thread initialworld exists thread succ exists evolution lwc evaluates trace prefix fig definition meaning formula concrete trace respect assignment denoted yields truth meaning defined inductively max maxu tcv maxn minni thatt andz satisfy denoted byt writet correctness translation established theorem theorem closed etl formula trace rep rep first-order representation first-order structure corresponds world mapped world rep succ predicate holding consecutive worlds semantics actions informally program actionacconsists precondition acpre action enabled expressed logical formula set formulae updating values predicates effect action enabled action specifies world trace interpretations predicate arity determined evaluating formula predicates exploring finite abstract traces abstract interpretation section give algorithm conservatively determining validity program respect etl property key difficulty proving liveness properties fact liveness property violated infinite trace procedure verifying liveness properties greatest fixed-point computation works initial approximation represents infinite traces section present abstract-interpretation algorithm procedure explore figure approach finite representations infinite traces finite representations obtained abstraction three-valued logical structures logical represents unknown result abstraction abstract semantics conservatively models effect actions abstract representations finite representation infinite traces step making algorithm figure feasible define finite representation sets infinite traces technically -valued logical structures finitely represent sets infinite traces definition abstract trace -valued first-order logical structuret hut domain abstract trace interpretation mapping predicates truth values ukt refer values definite values definite individual called summary individual summary individual represent concrete individual meaning formula -valued abstract trace respect assignment denoted defined interpreted trace assignment potentially satisfies formula denote define concrete traces represented abstract traces idea individual concrete trace mapped abstraction individual abstract trace definitions permit abstract concrete trace related less-precise abstract trace abstraction special case trace concrete trace definition imposes order truth values -valued logic definition forl define information order truth values embedding ordering abstract traces defined definition abstract traces encoded firstorder structures function surjective embed predicate represents exists embedding creating embedding function canonical abstraction canonical abstraction maps individuals abstract individual based values individuals unary predicates individuals values unary predicate symbols mapped abstract individual denote canonical abstraction trace embed canonical abstraction guarantees abstract trace larger fixed size priori figure shows abstract trace abstract worlds represents concrete trace fig individual double-line boundaries summary individual representing possibly single concrete individual similarly worlds double-line boundaries summary worlds possibly represent single world dashed edges edges represent relations hold successor edge worlds represents note rval succ succ rval heldby currworld rval rval heldby blocked rval rval succ initialworld rval succ succ fig abstract trace represents concrete trace succession worlds summary world initial world represents concrete worlds initial current world values unary predicates similarly summary node labeled represents thread individuals worlds reside label note abstract trace represents concrete traces concrete traces current world threads blocked lock blocked abstract interpretation abstract semantics represents abstract traces -valued structures intuitively applying action abstract trace unravels set successor worlds trace abstract action elaborates abstract trace materializing world summary world tail trace definite successor current world currworld indefinite successor summary world tail trace currworld advanced currworld merged predecessor trace extended evaluate formula precondition update formulae -valued logic figures illustrate application action releases lock figure shows materialization successor world trace figure successor world thread label lwc longer holds lock advanced label currworld predicate advanced currworld merged predecessor resulting abstract trace shown figure abstract-interpretation procedure explore shown figure computes greatest fixed point starting set abstract traces represent concrete infinite traces start initial state worlds initial world represents initial program configuration connected -valued successor edge summary world represents unknown suffixes summary world summary individual related summary individual values predicates including exists meaning future worlds trace necessarily individuals summary world oft summary individual related represents suffixes future worlds empty figure shows initial abstract trace representing traces starting arbitrary number worker threads label sharing single lock rval succ succ rval heldby currworld rval rval heldby blocked rval rval succ initialworld rval succ succ rval rval blocked succ fig intermediate abstract trace represents stage applying action rval succ succ rval heldby currworld rval rval blockedat rval rval succ initialworld rval succ succ fig resulting abstract trace applying action advancing currworld procedure explore accumulates abstract traces settracesuntil fixed point reached process set concrete traces represented abstract traces traces decreasing sense explore computing greatest fixed point fixed point reached property interest evaluated abstract traces fixed point formula evaluation abstract trace exploits values instrumentation predicates explained secexplore traces occur select remove traces action enabled traces tracessfac traces report error fig computing set abstract traces evaluating property rval succ initialworld succ currworld fig initial abstract trace tion recorded definite values re-evaluation yielded show soundness approach extend mappings individuals operate assignments function var assignment denotes assignment var nice features -valued logic soundness analysis established theorem generalizes infinite case theorem embedding theorem hut hut traces encoded first-order structures function formula complete assignment algorithm figure terminate report error program satisfies original etl formula approach verifying temporal properties yields due overly conservative approximation section present machinery refining abstraction successful verification interesting cases space precludes showing real application web server artificial section figure shows abstract trace property holds concrete traces represented abstract trace formula evaluates successor evolution edges initialworld succ succ succ succ succ fig holds concrete traces abstract trace represents evaluates property-guided instrumentation refine abstraction maintain precise information correctness temporal formulae traces constructed principle referred instrumentation principle work mentioned showing obtain instrumentation predicates temporal specification trace instrumentation predicates tab required preserving properties interest abstraction instrumentation predicate current denotes member current world distinguished individuals predecessor worlds predicate required due limitations canonical embedding predicate twe records equality worlds 
required due loss information concrete locations caused abstraction transworld equality evolution semantics individuals considered incarnations individual transitively evolve predicate intended meaning formula twe object equal object possibly worlds evolution evolution current object member current world world currworld table trace instrumentation predicates refer notion equality transworld equality introduce instrumentation predicate twe capture notion abstraction operates traces single worlds individuals worlds abstracted transworld equality crucial distinguishing summary node represents incarnations individual worlds summary node represent number individuals transworld equality illustrated fig -valued twe self-loop summary thread-node label lwc records fact summary node represents multiple incarnations single thread number threads rval succ succ rval heldby currworld rval rval heldby blocked rval rval succ initialworld rval twe twe twe twe twe twe twe twe twe twe succ succ twe fig abstract trace transworld equality instrumentation -valued transworld equality edges shown temporal instrumentation etl specification formula construct set instrumentation predicates refining abstraction trace property interest set instrumentation predicates corresponds sub-formulae original specification property evaluated satisfied concrete traces thatt represents add temporal instrumentation predicatesip andiq record values temporal subformulaep predicates updated previous worlds note transworld equality instrumentation precisely record transitive evolution objects information summary node world abstraction incarnations single object shown fig related work bandera specification language bsl writing specifications common high-level patterns bsl impossible relate individuals worlds impossible refer exact moments allocation deallocation object initialworld succ succ succ twetwe twe twe twe succ succ fig abstract trace evaluates special case abstraction named counter abstraction abstract infinite-state parametric system finite-state static abstraction preceding model-extraction phase contrast work abstraction applied dynamically step state-space exploration enables handle dynamic allocation deallocation objects threads observing-propositions defined first-order configuration extract propositional kripke structure first-order extracted structure subject pltl model-checking techniques approach limited individuals worlds specifically related conclusion work foundation verifying properties programs manipulating heap dynamic allocation deallocation objects threads future plan develop scalable approaches abstract-interpretation algorithms tailored etl acknowledgments patrick cousot nissim francez amir pnueli helpful discussions insightful comments anonymous referees providing comments paper clarke grumberg peled model checking mit press corbett dwyer hatcliff robby language framework expressing checkable properties dynamic software spin courcelle expression graph properties fragments monadic secondorder logic immerman kolaitis editors descriptive complexity finite models proceedings diamcs workshop chapter pages american mathematical society cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixed points popl cousot cousot temporal abstract interpretation proc popl pages january dor rodeh sagiv checking cleanness linked lists sas springer dwyer avrunin corbett patterns property specifications finitestate verification proc int conf software engineering pages fitting mendelsohn first-order modal logic volume synthese library kluwer academic publishers dordrecht hughes creswel introduction modal logic methuen london kesten pnueli vardi verification augmented abstraction automatatheoretic view jcss comp sys sci lev-ami sagiv tvla framework kleene based static analysis static analysis symposium springer lewis counterpart theory quantified modal logic journal philosophy lxv manna pnueli temporal verification reactive systems safety springer pnueli zuck liveness infinity -counter abstraction cav sagiv reps wilhelm parametric shape analysis -valued logic acm transactions programming languages systems vardi pierre wolper reasoning infinite computations information computation november yahav http tau yahave yahav verifying safety properties concurrent java programs -valued logic proc popl pages march yahav reps sagiv ltl model checking systems unbounded number dynamically created threads objects technical report trcs dept univ wisconsin madison march yahav reps sagiv wilhelm automatic verification temporal properties concurrent heap-manipulating programs evolution logic technical report school tel aviv israel july translation etl etl sub-formula temporally-bound appears temporal operator translations temporally-bound non-temporally-bound formulae nontemporally-bound formulae bound initial world trace definition etl translation fot denote bounded translation formula world non-bounded translation world initialworld atomic formula isnew isfreed exists tcx tcx exists exists world succ evolution world succ succ evolution world succ evolution exists note necessarily distinct simplified translations temporal operators 
finite differencing logical formulas static analysisa thomas repsa mooly sagiva alexey loginov comp sci dept wisconsin reps alexey wisc school comp sci tel-aviv msagiv post tau abstract paper concerns mechanisms maintaining instrumentation predicate derived predicate view defined logical formula core predicates response values core predicates presents algorithm transforming instrumentation predicate defining formula predicate-maintenance formula captures instrumentation predicate technique applies program-analysis problems semantics statements expressed logical formulas describe core-predicate values reflect values instrumentation predicates introduction paper addresses fundamental challenge applying abstract interpretation concrete semantics language desired abstraction create abstract transformers problem address arises program-analysis problems semantics statements expressed logical formulas describe corepredicate values instrumentation predicates defined logical formulas core predicates introduced refine abstraction challenge reflect core-predicate values values instrumentation predicates algorithm presented paper create formulas maintain correct values instrumentation predicates generate completely automatically part transfer functions abstract semantics deals instrumentation predicates algorithm runs time linear size instrumentation predicate defining formula research motivated work static analysis based -valued logic analysis method relies logic -valued -valued express program semantics benefit techniques setting related logics ordinary -valued logic related -valued logic memory configuration store modeled logicians call logical structure individual structure universe models single memory element case summary individual models collection memory elements run analyzer carries abstract interpretation collect set structures program point involves finding fixed point set equations fixed point reached structures collected program point describe superset execution states occur determine property holds checks holds structures collected instantiations framework capable establishing nontrivial properties programs perform complex pointerbased manipulations priori unbounded-size heap-allocated data structures tvla system three-valued-logic analyzer implements approach summary individuals play crucial role ensure abstract descriptors priori bounded size guarantees fixed-point reached constraint working limited-size descriptors implies loss supported onr contract von humboldt foundation information store intuitively concrete individuals lose identity grouped individuals summary individual property true concrete individuals group false individuals reason -valued logic uncertainty property captured means truth advantage -valued logic basis static analysis language extracting information concrete world abstract world identical syntactic expression logical formula interpreted -valued world -valued world consistency -valued -valued viewpoints ensured basic theorem relates logics partial answer fundamental challenge posed formulas define concrete semantics interpreted -valued logic define sound abstract semantics interpreted -valued logic care design analysis danger abstract interpretation proceeds indefinite pervasive destroy ability recover interesting information -valued structures collected soundness maintained key role combating indefiniteness played instrumentation predicates record auxiliary information logical structure provide mechanism user fine-tune abstraction instrumentation predicate defined logical formula core predicate symbols captures property individual memory cell possess general adding additional instrumentation predicates refines abstraction defining precise analysis prepared track finer distinctions stores properties program stores identified standpoint concrete semantics instrumentation predicates represent cached information recomputed reevaluating instrumentation predicate defining formula local state standpoint abstract semantics reevaluating formula local -valued state lead drastic loss precision gain maximum benefit instrumentation predicates abstract-interpretation algorithm obtain values problem problem solved incremental computation instrumentation predicate transition abstract state transformer state computed incrementally contributions work reported paper include give algorithm predicate-maintenance problem creates predicatemaintenance formula applying finite-differencing transformation defining formula algorithm runs time linear size defining formula present experimental evidence technique effective analysis programs manipulate acyclic singly-linked lists doubly-linked lists binary trees sorting programs predicatemaintenance formulas produced automatically approach effective maintaining precision hand-crafted work related view-maintenance problem databases compared work novelty ability create predicate-maintenance formulas suitable abstraction performed remainder paper organized sect introduces terminology notation sect defines predicate-maintenance problem sect presents method generating maintenance formulas instrumentation predicates sect discusses extensions handle instrumentation predicates transitive closure sect presents experimental results sect discusses related work background -valued first-order logic transitive closure syntax first-order formulas equality reflexive transitive closure defined definition formula vocabulary eqa defined formulas variables rtc set free variables formula defined usual rtc stands reflexive transitive closure rtc free-variable set require free variables shorthand notations defa eqa defa eqa binary predicatea defa rtc c-like syntax conditional expressions order precedence connectives highest lowest drop parentheses emphasis definition -valued interpretation -valued logical structure set individuals maps predicate symbol arity truth-valued function addition eqa distinct individuals eqa assignment function maps variables individuals functionality defined free variables formula complete generally assume assignment arises connection discussion formula complete -valued meaning formula denoted yields truth defined inductively rtc satisfy set -valued structures denoted -structa -valued logic embedding -valued logic formulas work identical -valued logic semantic level truth introduced denote uncertainty -valued logic shorthand -valued logic shorthand definition truth values definite values indefinite information order defined iff symbol denotes least-upper-bound operation respect definition -valued interpretation -valued logical structure set individuals maps predicate symbol arity truth-valued function addition eqa distinct individuals eqa assignment -valued meaning formula denoted yields truth meaning defined defn interpreted potentially satisfy set -valued structures denoted -structa defn requires individual eqa individual eqa called summary individual abstract-interpretation context summary individual abstract individual represent concrete individual treated shorthand -valued logic equals definition structures surjective function embeds denoted predicate symbol arity embedded denoted exists function embedding theorem piece information extracted formula conservative approximation information extracted formalize extend mappings individuals operate assignments function assignment denotes assignment theorem embedding theorem theorem structures function formula complete assignment program analysis -valued logic remainder section summarizes program-analysis framework stores encoded logical structures terms fixed collection core predicates core predicates part underlying semantics language analyzed record atomic properties stores instance tab definition linked-list datatype lists predicates represent stores manipulated programs type list core predicates fixed language general languages require collections core predicates restricted class structures encode stores exclude structures represent admissible stores integrity constraints imposed instance program-analysis applications predicate tab captures pointer variable points memory cell attribute typedef struct node struct node int data list predicate intended meaning denote memory cell pointer variable point memory cell field point table declaration linked-list datatype core predicates representing stores manipulated programs type list unique imposes integrity constraint hold individual structure concrete operational semantics defined kind statement programming language structure transformer outgoing controlflow graph cfg edge structure transformer providing collection predicate-transfer formulas core predicate define core predicates logical structure arises transformed create logical structure abstract stores -valued logical structures concrete stores abstracted abstract stores means embedding functions functions map individuals -valued structure 
-valued structure embedding theorem ensures piece information extracted evaluating formula conservative approximation information extracted evaluating finiteness abstract domain assured canonical abstraction individual -valued logical structure representing concrete memory cell mapped individual -valued logical structure vector values concrete individual user-chosen collection unary abstraction predicates mechanism ensures -valued structure larger fixed size priori abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation predicates record derived properties varying unary core unary instrumentation predicates set abstraction predicates set instrumentation predicates denoted arity-a predicate symbola defined definition formula instrumentation predicates defining formulas instrumentation predicates long circular dependences instrumentation predicates involve reachability properties defined rtc play crucial role definitions abstractions instance program-analysis applications reachability properties specific pointer variables effect keeping disjoint sublists summarized separately important analyzing program pointers advanced disjoint sublists kind statement programming language abstract semantics defined collection formulas predicate-transfer formula defines concrete semantics case core predicate case instrumentation predicate predicate-maintenance formula predicate-transfer formulas predicate-maintenance formulas called predicate-update formulas separate terms refer easily predicate-maintenance formulas main subject paper abstract interpretation collects set -valued structures program point implemented iterative procedure finds fixed point set equations important understand analysis framework based logic model theoretic proof theoretic abstract interpretation collects sets -valued logical structures abstracted models actions rely deduction theorem proving fig illustrates abstract execution statement -valued logical structure represents concrete lists length structure unary preds binary preds indiv gfed abca statement predicate-transfer formulas predicate-maintenance formula structure unary preds binary preds indiv gfed abca fig predicate-transfer formulas express transformation logical structures corresponds semantics predicate discussed graphical notation depicting -valued logical structures individuals represented circles names inside summary individual eqa represented double circle unary predicate represented solid arrow individual absence -arrow node individuals predicate shown binary predicate represented solid arrow labeled pair individuals absence -arrow pairs unary binary predicates represented dotted arrows problem maintaining instrumentation predicates execution statement transforms logical structure represents store arises structure represents store executes structure consists core predicates called proto-structure denoted creation denoted expressed general compare predicates tuples added deleted crux matter suppose defines instrumentation predicate static-analysis engine obtain instrumentation predicate defining formula expressed solely terms core predicates core normal form circular dependences instrumentation predicate defining formula put core normal form repeated substitution core predicates remain core normal form converted core normal form determine instrumentation predicate evaluating structure principle maintain values instrumentation predicates eqn practice approach work observed working -valued logic retain precision defining special maintenance formula evaluating structure advantage predicate-maintenance approach results program analysis accurate -valued logic defined appropriately predicate-maintenance strategy generate definite evaluation generates indefinite ensure analysis conservative show property holds definition suppose instrumentation predicate defined formula predicate-maintenance formula maintains correctly statement -structa fig store shared instrumentation predicate core normal form provide predicate-maintenance formula satisfies defn defining denotes formula obtained replacing predicate occurrence denotes formula obtained replacing free occurrence variable formula defined eqn maintains correctly statement -valued version eqn eqn evaluated structure place equivalent evaluated precisely drawback eqn obtain steps evaluating mimic evaluating pass -valued logic yields evaluating eqn satisfy defn obtained automatically eqn approach provide satisfactory solution predicate-maintenance problem eqn shows defining formula instrumentation predicate is-shared fields captures memory cell pointed pointer fields memory cells fig fig illustrates execution statement lose precision predicate-maintenance formula created eqn initial -valued structure represents singly linked lists length memory cells unshared execution change core predicate formula created eqn shown fig structure created maintenance formula precise means represent shared cell final -valued structure represents cyclic linked lists gfed abca gfed abca gfed abca gfed abca gfed abca sort imprecision avoided devising predicatemaintenance formulas instance defined formula meaning change imprecision illustrated fig avoided fig hand-crafted predicate-maintenance formulas variety instrumentation predicates formulas created hoc methods structure unary preds binary preds indiv gfed abca statement predicate-transfer formulas predicate-maintenance formula structure unary preds binary preds indiv gfed abca fig showing imprecision illustrated fig avoided predicate-maintenance formula shows generated automatically sum past incarnations work user supply formula instrumentation predicate statement effect user write separate characterizations instrumentation predicate defines directly specifies execution kind statement language affects user responsibility ensure characterizations mutually consistent contrast method automatically creating predicate-maintenance formulas presented sects user responsibility define finite-differencing scheme -valued logic section presents finite-differencing scheme creating predicate-maintenance formulas predicate-maintenance formula defined terms finite-differencing operators denoted capture negative positive execution statement induces instrumentation predicate formula created combining evaluate retrievestored execute statement sts evaluate stevaluate proto fig maintain -valued logic response values core predicates caused execution statement fig depicts static-analysis engine evaluates combines values obtain desired operators defined recursively shown fig definitions fig make operator defa maintenance formula expressed form form fig finite-difference formulas first-order formulas eqn fig define syntax-directed translation scheme implemented recursive walk formula operators mutually recursive instance occurrence additional occurrences note exhibit convolution pattern characteristic differentiation finite-differencing divided-differencing continuing analogy differentiation helps bear mind independent variables core predicates changed formulas dependent variable formal justification fig stated thm explain informally cases fig atomic formula depend core predicates unaffected tuples individuals removed tuples individuals removed holds tuples individuals removed holds change individual holds hold holds similar previous case term ensure hold replaced formula evaluated stored obtained reevaluating characterize positive apply defining formula special case worth noting atomic formula shorthand eqa depend core predicates unaffected instrumentation predicate is-shared fields defined eqn fig shows formulas obtained fig finite-difference formulas instrumentation predicate statement formulas fig simplified instance predicate-transfer formula fig fig formulas simplifies implementation simplifications performed greedily formula-construction time constructor rewrites formulas fig simplify shown fig definition avoids imprecision illustrated -structs correctness finite-differencing transformation fig ensured theorem theorem structure -struct proto-structure statement obtained structure obtained approximation filling instrumentation predicates topological ordering dependences arity-a predicate obtained evaluating tuples formula complete assignment -structs soundness finite-differencing transformation fig thm embedding theorem thm malloc free modeling storage-allocation deallocation operations carried two-stage statement transformer stage number individuals structure creates problems finitedifferencing approach establishing mutually consistent values predicate tuples involve newly allocated individual predicate values needed stage predicate-transfer formulas core predicates predicate-maintenance formulas instrumentation predicates applied usual fashion eqns simple sidestep problem model free-storage list explicitly making substructure part -valued structure gfed abc malloc modeled advancing pointerfreelist list returning memory cell pointed free 
modeled inserting head freelist list cell deallocated true structure model storage-allocation deallocation operations number individuals -valued structure change individual materialized usual mechanisms operations values predicate tuples involve newly materialized individual safe mutually consistent values reachability transitive closure instrumentation predicates depend rtc shown tab reachable fields reachable pointer variable fields directed cycle fields table defining formulas instrumentation predicates depend rtc recall shorthand rtc finding good maintain instrumentation predicates defined rtc challenging general write first-order formula transitive-closure operator specifies maintain closure directed graph response edge insertions deletions strategy investigate special cases classes instrumentation predicates first-order maintenance formulas exist apply system falls back safe maintenance formulas rtc paper confine important special case techniques maintain instrumentation predicates rtc binary formula defines acyclic graph special cases rtc binary formulas define possibly-cyclic graphs subject future paper binary instrumentation predicate defined rtc graph defined acyclic give first-order formula maintains addition deletion single -edge method minor modification method maintaining non-reflexive transitive closure acyclic graph due dong case insertion single -edge maintenance formula tuples represent paths connected -edge maintenance formula handle deletion single -edge bit complicated identify tuples represent paths rely edge deleted removed stands suspicious collect set -tuples remain stands trusted finally maintenance formula single -edge deletion fig edge deleted node path reachable maintenance formulas maintaina conditions hold graph defined acyclic change graph single edge addition deletion assumptions maintenance formula -edge deletion correct suppose suspicious tuple -path deleted -edge show suppose -edge deleted graph defined acyclic node path reachable fig hold reachable acyclicity tuple suspicious edge graph defined means yielding eqn fig extends method generating predicate-maintenance formulas handle instrumentation predicates rtc binary formula defines acyclic graph fig makes operator eqn recasts eqns finite-difference expressions rtc rtc fig extension finite-differencing method fig cover rtc formulas unit-sized acyclic graph defined special-case maintenance strategy applied statement analysis-generation time change performed graph defined results single edge addition deletion admissible -structa unique satisfying assignment free variables assignment satisfies pair defines change adds edge graph similarly admissible -structa unique satisfying assignment free variables assignment satisfies change deletion edge graph answering questions general undecidable employ conservative approximation based syntactic analysis logical formulas analysis heuristic determine set variables admissible structure variables single binding formula satisfying assignments refer variables anchored variables instance predicate attribute unique admissible structure single binding variable assignment satisfies formula occurrence anchored variable free variables anchored change adds edge graph defined similarly free variables anchored change removes edge graph cases reflexive transitive closure updated method discussed experimental evaluation evaluate techniques presented paper extended tvla generate predicate-maintenance formulas applied test suite existing analysis specifications involving programs fig non-id performance category test program maintenance-formula schemas instances analysis time sec total non-tc increase search nullderef getlast sll deleteall shape reverse analysis create swap delete merge insert dll append shape delete analysis splice binary non-tree tree insertsorted shape deutsch-schorr-waite analysis deletesorted reversesorted bubble sll bubblebug sorting insertsortbug insertsort insertsortbug mergesorted information good flow flow bad flow fig results hand-crafted automatically generated maintenance formulas instrumentation predicates test programs consisted operations acyclic singly-linked lists doubly-linked lists binary trees binary-search trees sorting programs system verify partial-correctness properties test programs instance reverse in-situ list-reversal program preserve list properties lose elements insertsorted deletesorted preserve binarysearch-tree properties insertsort return sorted list good flow high-security input data flow low-security output channel programs contained bugs instance insertsortbug insert-sort program ignores element list bubblebug bubble-sort program incorrect condition swapping elements infinite loop input list duplicate data values non-tree creates node left-child right-child pointers point subtree tvla operational semantics programming language defined kind statement action schema outgoing cfg edges action schemas instantiated program statement instances create cfg combination action schema instrumentation predicate maintenance-formula schema provided number non-identity maintenance-formula schemas reported columns fig broken columns defining formula occurrence rtc predicate-maintenance formulas produced finite differencing generally larger hand-crafted affects analysis time number instances non-identity maintenance-formula schemas meaningful size measure experiments numbers column program test suite ran analysis hand-crafted maintenance formulas obtain answer cfg nodes annotated final sets logical structures ran analysis automatically generated maintenance formulas compared result answer test programs analysis automatically generated formulas yielded answers identical answers columns show performance data collected ghz amd athlona workstation running red hat linux version case runs made longest shortest times discarded set remaining averaged figures report time spent loading initialization affected technique exclude overhead formula differencing analysis-time cost geometric slowdowns automatically generated formulas approximately median due fact automatically generated formulas larger hand-crafted maximum slowdown analyses faster automatically generated formulas speedups due random variation accidental benefits subformula orderings advantageous short-circuit evaluation results encouraging abstractions common data structures suggest algorithm generating predicate-maintenance formulas sect capable automatically generating formulas precise hand-crafted tolerable effect runtime performance extended version tvla uncovered bugs hand-crafted formulas maintenance formula form called identity predicate-maintenance formula identity predicate-maintenance formula hand-crafted specification checked simplification generated predicate-maintenance formula identity formula inconsistency turned error hand-crafted specification found instance incorrect non-identity hand-crafted maintenance formula measurements reported fig based corrected hand-crafted specifications related work weakness past incarnations tvla user define predicate-maintenance formulas statement affects instrumentation predicate recent criticisms tvla based deficiency longer valid analyses defined formulas define acyclic relations classes formulas define cyclic relations techniques discussed paper algorithm presented sects user responsibility write formulas predicatemaintenance formulas created automatically graf showed theorem provers generate abstract transformers abstract domains fixed finite cartesian products boolean values domains predicate abstraction predicate abstraction slam systems contrast abstract transformers created algorithm sects expect simple optimizations caching results evaluating subformulas significantly reduce slowdown transformers algorithm simple linear-time recursive treetraversal procedures theorem provers predicate abstraction guaranteed terminate setting makes richer abstract domains offered predicate abstraction experience date precision lost good abstract transformers instrumentation predicates identified paige studied finite-differencing transformations applicative set-former expressions exploited optimize loops very-high-level languages setl liu related program-transformation methods setting functional programming language derive incremental algorithms problems specifications exhaustive algorithms work goal maintain function input undergoes small methods sects address similar kind incremental-computation problem language exhaustive incremental versions problem expressed first-order logic reflexive transitive closure finite-differencing operators defined sects closely related number previous papers logic databases finite-difference operators propositional case studied akers sharir previous work incrementally maintaining materialized views databases first-order incremental 
evaluation schemes foies dynamic descriptive complexity addressed problem maintaining auxiliary predicates tuples inserted deleted base predicates databases view maintenance solely optimization correct information obtained reevaluating formula abstract-interpretation context abstraction performed longer true reevaluating formula local -valued state lead drastic loss precision aspect sets work previous work goal developing finite-differencing transformation suitable abstraction performed finite-differencing transformations correct -valued logic satisfy thm -valued logic instance fig presents alternative finite-differencing scheme first-order formulas scheme captures negative positive fig maintenance formula instrumentation predicate denotes exclusive-or -valued logic eqn unfortunate property evaluates pinned indefinite successor structures successors eqn reacquire definite fig alternative finite-differencing scheme first-order formulas contrast maintenance formulas created finite-differencing scheme fig trouble form if-then-else reacquire definite set evaluates definite vice versa acknowledgments hesse immerman lev-ami wilhelm comments suggestions work manevich provided invaluable tvla tvla system http math tau rumster tvla akers theory boolean functions soc indust appl math december ball majumdar millstein rajamani automatic predicate abstraction programs conf prog lang design impl york acm press cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press das dill interprocedural express-lane transformation david melskia thomas repsa grammatech melski grammatech comp sci dept univ wisconsin reps wisc abstract express-lane transformation isolates duplicates frequently executed program paths aiming data-flow facts duplicated paths express-lane copy frequently executed program path entry point beginning branches back original code original code branches classical data-flow analysis find sharper data-flow facts express-lane join points paper describes variants interprocedural express-lane transformations duplicate hot interprocedural paths paths cross procedure boundaries paper reports results experimental study effects express-lane transformation interprocedural range analysis introduction path profiling program instrumented code counts number times finite-length path fragments program control-flow graph observable paths executed application path profiling transform profiled program isolating optimizing frequently executed hot paths call transformation express-lane transformation express-lane copy hot path entry point beginning branches back original code original code branches classical data-flow analysis find sharper data-flow facts express lanes join points create opportunities program optimization interprocedural express-lane transformation range analysis perform program optimization approach differs literature profiledriven optimization aspects duplicate interprocedural paths expose correlations branches procedures lead optimization opportunities perform code transformation performing data-flow analysis classic data-flow analyses guide path duplication interprocedural path profiles point sound redundant edge profiles duplicate intraprocedural paths advantage interprocedural path profiles accuracy terms paths important perform interprocedural range analysis transformed graph attempt eliminate duplicated code benefit range analysis eliminate code growth paper describes algorithms presents experimental results approach profile-driven optimization specifically work makes contributions elegant solution duplicating intraprocedural paths based intraprocedural path profile paper generalizes work providing algorithms program supergraph interprocedural control-flow graph interprocedural path profile produce express-lane supergraph show interprocedural express-lane transformations yield benefits range analysis programs optimized interprocedural express-lane transformation range analysis resolve dynamic branches programs optimized intraprocedural express-lane transformation range analysis dynamic branches programs optimized range analysis show range analysis constant propagation intraprocedural express-lane transformation lead greater benefit previously reported show code growth due intraprocedural express-lane transformation detrimental program performance experiments show optimization based interprocedural express-lane transformation benefit performance overcome costs transformation results suggest software hardware support entry exit splitting profitable research direction entry exit splitting section remainder paper organized section describes relevant details interprocedural path-profiling techniques section describes interprocedural express-lane transformations section presents experimental results section describes related work path profiling overview understand interprocedural express-lane transformation helpful understand interprocedural paths duplicated section summarizes relevant parts works ball-larus technique extended directions interprocedural intraprocedural presents interprocedural path-profiling techniques observable paths cross procedure boundaries interprocedural paths tend longer capture correlations execution behavior procedures context piecewise piecewise path profiling observable path corresponds path occur subpath piece execution sequence context path profiling observable path corresponds pair active-suffix corresponds subpath execution function sequence add context-prefix return corresponds function context main sequence pending calls sum add sum occur context path-profiling add technique generally print longer sum print observable paths sum maintains finer distinctions piecewise technique paper kinds path profiles ball-larus path profiles intraprocedural piecewise path profiles interprocedural piecewise context path profiles techniques applied types path profiles interprocedural path profiling works interprocedural control-flow graph called supergraph program supergraph consists unique entry vertex unique exit vertex collection control-flow graphs fig interprocedural context path active-suffix shown bold surrogate edges shown dashed-lines flowgraph procedure unique entry vertex unique exit vertex vertices flowgraph represent statements predicates usual procedure call program represented call vertex return-site vertex procedure call procedure represented call vertex return-site vertex call-edge return-edge supergraph edges ball-larus technique observable paths interprocedural path-profiling techniques allowed backedges observable path call-edge return-edge recursive call-site recursive call-sites source backedge call graph observable path interprocedural context path profile surrogate edges surrogate edges required observable paths allowed backedges unlike edges observable path surrogate edge edge supergraph surrogate edge observable path represents unknown path fragment starts entry vertex procedure ends backedge vertex procedure observable path interprocedural path profiling technique summary edges summary edge connects call vertex return-site vertex context path-profiling technique context-prefix sequence path fragments supergraph fragment connected surrogate edge context-prefix summarizes sequence pending call-sites information path pending call-site fig shows schematic observable path interprocedural context path profile fig shows average number suif instructions observable path spec benchmarks technical reasons discussed situations interprocedural piecewise path considered contextprefix ksim perl vortex interprocedural express-lane transformation intraprocedural express-lane transformation takes control-flow graph intraprocedural piecewise path profile creates express-lane graph section describe extend algorithm input program supergraph interprocedural path profile produce output express-lane supergraph issues addressed definition express-lane extended context path profile path consist non-empty contextfig graph average number suif instructions observable path interprocedural context interprocedural piecewise intraprocedural piecewise path profiles spec benchmarks run inputs observable path weighted execution frequency prefix active-suffix observable path gaps represented surrogate edges express-lane version observable path context-prefix active-suffix gaps observable path technical issues resolved interprocedural expresslane transformation requires mechanism duplicating call-edges return-edges straightforward approach duplicates call edge creating copies duplicates return edge creating copies modifications intraprocedural algorithm required obtain algorithm performing interprocedural express-lane transformation ammonslarus express-lane transformation hot-path automaton deterministic finite automaton dfa recognizing hot-paths takes cross product automaton control-flow graph cfg dfa create automaton recognizes set interprocedural hot-paths require pushdown automaton pda supergraph pda mimic approach combine pushdown automata problem uncomputable general create collection deterministic finite automata procedure automaton procedure recognizes hot-paths start entry exit splitting algorithm performing interprocedural express-lane transformation entry splitting duplicate call-edges exit splitting duplicate return-edges entry splitting procedure entry exit splitting procedure multiple exits assigned number procedure call made caller return address case procedure multiple exits caller vector return addresses callee reaches exit vertex branches return address implementation semantically equivalent inferior method entry exit splitting call vertex sets entry number making normal procedure call called procedure calling procedure executes switch entry exit number jump proper entry return point defining interprocedural express-lane entrymain exitmain entryfoo exitfoo main foo fig supergraph section give definition interprocedural express-lane simple develop intuition happen duplicate observable path interprocedural context path profile supergraph shown fig suppose create express-lane version observable path context-prefix path main call-site foo active-suffix principal difficulty duplicating edge surrogate-edge appears middle observable path supergraph duplicate edge peeking ahead fig shows express-lane graph express-lane version create express-lane version create copies path contextprefix active-suffix copy context-prefix ends copy vertex copy active-suffix begins copy vertex desire time execution reaches path make duplicated active-suffix executes context duplicated context-prefix give technical definition interprocedural express-lane 
supergraph observable path supergraph vertex copy vertex express-lane version sequence vertices properties satisfied duplication property copy vertex minimal predecessor property vertex multiple predecessors edge surrogate edge copy return-site vertex predecessor copy return-site vertex call vertex copy call vertex copy call vertices copy exit vertex targeted returnedge copy call vertex targeted multiple return-edges context property vertex procedure copy park experience predicate abstraction proc computeraided verif pages springer-verlag july dong incremental decremental evaluation transitive closure firstorder queries inf comp dong incremental maintenance recursive views relational calculus sql sigmod record graf construction abstract state graphs pvs proc computeraided verif pages june gupta mumick editors materialized views techniques implementations applications press cambridge lev-ami reps sagiv wilhelm putting static analysis work verification case study int symp software testing analysis pages lev-ami sagiv tvla system implementing static analyses static analysis symp pages liu stoller teitelbaum discovering auxiliary information incremental computation symp princ prog lang pages january liu teitelbaum systematic derivation incremental programs sci comp program mcmillan verification infinite state systems compositional model checking charme pages ller schwartzbach pointer assertion logic engine conf prog lang design impl pages paige koenig finite differencing computable expressions trans prog lang syst july patnaik immerman dyn-fo parallel dynamic complexity class comput syst sci october sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst sharir observations formal differentiation set theoretic expressions trans prog lang syst april 
reached intraprocedural path copy copy properties vertex express-lane multiple predecessors branches middle express-lane surrogate edge direct predecessor vertex supergraph return-site vertex intraprocedural predecessor call site vertex interprocedural predecessor performing interprocedural express-lane transformation present algorithms performing interprocedural express-lane transformation interprocedural piecewise path profiles interprocedural context path profiles approach constructing express-lane supergraph consists phases construct family automata automaton procedure automaton dfa recognizes prefixes hot-paths begin interprocedural hot-path tracing algorithm combine supergraph generate initial express-lane supergraph make pass generated express-lane supergraph add return-edges summary-edges stage finishes connecting intraprocedural paths created previous step algorithms performing interprocedural express-lane transformation differ slightly step hot-path tracing algorithm treats automata dfas technically interprocedural hot path gaps represented surrogateor summary-edges gaps filled same-level valid paths slvps slvp path return-edge matched previous call-edge vice versa automaton recognizes hot-path requires ability skip slvps input string requires pda treat hot-path automata dfas reasons automata transitions labeled summary-edges transition labeled summary-edge considered oracle transition capable skipping slvp input string oracle required skip slvp supergraph-as-pda combine hot-path automaton supergraph oracle transition combined summary-edge supergraph create vertices summary-edge express-lane supergraph justification set slvps oracle transition skip precisely set slvps drive supergraph-as-pda sections examples program shown fig fig path trie interprocedural piecewise path profile supergraph fig backedge foo nonbackedge foo edge main fig path trie interprocedural context path profile supergraph fig edge main backedge foo non-backedge foo edge foo hot-path automata interprocedural piecewise paths section show construct set hot-path automata recognizing hot interprocedural piecewise paths expand definition automaton transition automata accurate describe large automaton sub-automata build hot-path automaton recognizing set hot paths building trie paths defining failure function maps vertex trie supergraph edge vertex trie dfa transition function edges trie failure function procedure create trie hot paths start hot paths reached backedge prefixed special symbol put trie transition labeled match backedge targets fig shows path supergraph fig paths hot-path prefix corresponds unique state path trie hot-path prefix ends vertexa drives automaton state represents root path trie procedure represent fact represents vertexa important vertex express-lane supergraph express-lane represents entry vertex represents define failure function state trie intraprocedural summary-edge failure function defined interprocedural edges represents vertex procedure backedge root trie hot paths beginning backedge target state transition transition phases express-lane transformation make functions lastactivecaller lastentry map trie states trie states state represents vertex procedure maps recent ancestor represents call vertex makes non-recursive call maps recent ancestor represents undefined ancestor trie hot-path automata interprocedural context paths principal difference previous section failure function defined path trie created procedure path put trie surrogate edge replaced edge labeled matches backedge targets fig shows path supergraph fig paths state represents entry vertex corresponds hot-path prefix describes calling context procedure reason states trie represent entry vertices special importance section map lastentry important maps lastactivecaller lastentry defined section failure function defined backedge backedge state reached transition labeled state give intuition hot-path tracing algorithm interacts automaton interprocedural context paths context-prefix leads procedure interprocedural hot-path tracing algorithm clone parts required make context property guaranteed expresslanes begin accomplish hot-path tracing algorithm generate vertices automaton state hot-path automaton corresponds context-prefix hot-path automaton state scanning path procedure cold context automaton stay state interprocedural hot-path tracing algorithm generates path tracing algorithm begins tracing path hot context hot-path automaton move state phase hot-path tracing intraprocedural path pieces section describes hot-path tracing algorithm combines family hot-path automata supergraph state reset state non-backedge reset states important reasons context-prefix drives hotpath automaton reset-state vertex express-lane supergraph part express-lane part residual cold code reset state reset state express-lane supergraph vertex entry vertex represented cold vertex facts determine express-lane supergraph vertex part express-lane fig show interprocedural hot-path tracing algorithm bulk work interprocedural hot-path tracing algorithm lines fig process express-lane supergraph vertex call exit vertex part algorithm similar express-lane supergraph vertex supergraph edge represents transition supergraph-as-pda transition lines trace edge express-lane supergraph vertex added express-lane supergraph worklist interprocedural hot-path tracing algorithm differs intraprocedural counterpart processing call exit vertices fig shows function process call-vertex responsibilities creates call-edges creates returnsite vertices connected summary-edge phase construction phase create summary-edge unnecessary removed graph phase phase connecting intraprocedural path pieces phase interprocedural express-lane transformation responsible completing express-lane supergraph add summary-edges return-edges formally phase interprocedural express-lane transformation ensures call vertex call-edge exit vertex reachable slvp return-site vertex summary-edge return-edge algorithm phase section input supergraph family hot-path automata automaton procedure denotes automaton procedure denotes transition relation disjoint union start state worklist express-lane supergraph vertices express-lane supergraph create vertices begin hot-path foreach procedure figure transition return-site vertex hot-paths begin return-sites start express-lane select remove element call vertex exit vertex foreachedge return-edge transition figure foreachedge unique state foreach vertex end main fig interprocedural hot-path tracing algorithm experimental results section broken parts section discusses effects express-lane transformations interprocedural range analysis section presents experimental results express-lane transformation range analysis perform program optimization effects express-lane transformation range analysis written tool suif called interprocedural path weasel ipw performs interprocedural express-lane transformation program takes input set source files program path profile ipw identifies smallest subset covers suif instructions exethe tool named based glenn ammons tool path weasel performs intraprocedural express-lane transformation end createvertex call vertex leta return-site vertex create call edges entry vertices foreachedge callees indirect call-site hot path continuing froma edgea label hook cold copy label call-edge create return-site vertex needed phase leta unique state end processcallvertex fig procedures createvertex processcallvertex fig cuted ipw performs express-lane transformation creating express-lane version path finally ipw performs interprocedural range analysis express-lane super graph experiments ipw run mhz pentium iii ram running solaris ipw compiled gcc test run times run times averaged cols table compare code growth increase range-analysis time express-lane transformations evaluate results range analysis program weighted dataflow fact vertex execution frequency columns table compare results range analysis express-lane transformations performed comparisons made percentage instruction operands constant 
percentage instructions constant result percentage decided branches conditional branch instructions determined outcome cases interprocedural express-lane transformations intraprocedural express-lane transformation range analysis upper bound range increased widens upper bound lower bounds treated similarly range analysis similar wegman zadeck conditional constant propagation simultaneously performs dead code analysis conditional branches refine data-flow facts arrived experimentally duplicating paths greater benefit range analysis significant increase code growth entrymain exitmain entryfoo exitfoo entryfoo exitmain exitfoo main foo fig express-lane supergraph supergraph fig hot-path automaton fig graph constructed phase construction edges added phase shaded vertex state reset state cold vertices express-lane transformation program optimization mentioned introduction reduce express-lane graph preserving valuable data-flow facts reduction strategies strategy preserves data-flow facts determine outcome conditional branch strategy based coarsest partitioning algorithm strategy preserves data-flow facts strategy based coarsest partitioning algorithm edge redirection algorithm strategy similar strategy preserves data-flow facts decide conditional branches strategy details discussion trade-offs strategies fig compares amount reduction achieved strategies tables show results forms express-lane transformation range analysis optimize spec int benchmarks specifically steps perform express-lane transformation perform interprocedural range analysis express-lane super graph reduce express-lane super graph eliminate decided branches replace constant expressions emit source code transformed program compile source code gcc entrymain exitmain entryfoo exitfoo entryfoo exitfoo exitmain exitfoo main foo fig express-lane supergraph hot-path automaton fig supergraph fig graph constructed phase edges added phase shaded vertex state reset state cold vertices fig comparison strategies reducing express-lane supergraph benchmark e-lanetransform transform time sec vertices ine-lane graph range prop time sec const operands const results decidedbranches ksim inter context inter piecewise intra piecewise compress inter context inter piecewise intra piecewise inter context inter piecewise intra piecewise ijpeg inter context inter piecewise intra piecewise perl inter context inter piecewise intra piecewise table columns show comparison compile-time cost performing express-lane transformations compile-time cost performing interprocedural range analysis express-lane transformation performed times measured seconds columns show comparison results range analysis express-lane transformations performed reduction strategy benchmark base run time sec strategy strategy nostep strategy strategy ksim compress ijpeg perl table program speedups due interprocedural context express-lane transformation range propagation base run times shown col benchmarks optimized removing decided branches constant expressions express-lane transformation compiled gcc reduction strategy benchmark base run time sec strategy strategy nostep strategy strategy ksim compress ijpeg perl table program speedups due interproc piecewise express-lane trans range prop reduction strategy benchmark base run time sec strategy strategy nostep strategy strategy ksim compress ijpeg perl table program speedups due intraproc piecewise express-lane trans range prop compare runtime program runtime original program base case performed range analysis express-lane transformation repeated col tables ran experiments express-lane transformations transformations reduction strategies listed ran experiments performed expresslane transformation strategy reduce express-lane super graph skipped step reported run time average runs results intraprocedural express-lane transformation tables intraprocedural express-lane transformation range analysis optimizations benefit performance reduction strategy limit code growth fact aggressive reduction strategies destroy performance gains reasons gcc advantage express-lane transformation perform optimizations code layout reduction hot path graphs result poorer code layout requires unconditional jumps critical paths aggressive reduction strategies seek preserve decided branches destroy data-flow facts show expression constant code layout reduced graph interact poorly i-cache results shown tables negative reasons difficult modify code generator hardware simulator support entry exit splitting straightforward implementation software incurred overhead procedure entry exit significant increase code growth col tables show performance overhead incurred transformations fig shows reasonable code growth interprocedural express-lane transformation assume performance degredation due entry exit splitting reduction strategies interprocedural express-lane transformations helps performance graph reduction eliminate entry exit splitting aggressive reduction interprocedural piecewise express-lane transformation leads performance gains col table noted interprocedural express-lane transformations combined range-analysis optimizations strong positive impact program performance great costs incurred transformations experiments eliminate branches replace constants columns tables cases performance showed slight improvement assume change code layout instruction cache effects suggests software hardware support entry exit splitting profitable research direction related work conclusions work paper interprocedural extension work paper related work focuses improving performance program paths partial list works includes detailed discussion related work found stated introduction interprocedural express-lane transformation differs techniques literature points duplicate interprocedural paths performing analysis guide path duplication interprocedural path profiles perform interprocedural range analysis transformed graph eliminate duplicated code benefit range analysis shown interprocedural express-lane transformations beneficial effect interprocedural range analysis performance gains interprocedural express-lane transformation slight negative shown potential specifically shown greater percentage dynamic branches decided statically performance improvements hardware software implementation entry exit splitting aho hopcroft ullman design analysis computer algorithms addison-wesley alfred aho algorithms finding patterns strings chapter pages mit press ammons larus improving data-flow analysis path profiles pldi ball larus efficient path profiling micro bodik gupta soffa interprocedural conditional branch elimination pldi rastislav bodik path-sensitive value-flow optimizations programs phd thesis pittsburg chang mahlke hwu profile information assist classic code optimizations software practice experience dec fisher trace scheduling technique global microcode compaction ieee trans computers volume pages hank region-based compilation phd thesis uiuc melski reps interprocedural path kill exit process begin wait end end process region region region wait wait wait end profiling melski interprocedural path profiling interprocedural express-lane transformation phd thesis wisconsion mueller whalley avoiding unconditional jumps code replication pldi poletto path splitting technique improving data flow analysis wegman zadeck constant propagation conditional branches popl reginald clifford young path-based compilation phd thesis harvard 
cfg extractor vhdl program cfgs database slicer core sdg builder sdg scheme scripts putting static analysis work veri cation case study tal lev-ami thomas repsy mooly sagivz reinhard wilhelmx abstract study program analysis automatically prove partial correctness correct programs discover locate diagnose bugs incorrect programs speci cally present algorithm analyzes sorting programs manipulate linked lists prototype algorithm implemented show algorithm ciently precise discover correct versions bubble-sort insertion-sort procedures fact produce correctly sorted lists outputs invariant is-sorted maintained listmanipulation operations element-insertion elementdeletion destructive list reversal merging sorted lists run algorithm erroneous versions bubble-sort insertion-sort procedures discover locate diagnose error introduction paper shows static analysis employed automatically prove partial correctness correct programs discover locate diagnose bugs incorrect programs static analysis previously potential bugs program anomalies demonstrate absence bugs programs manipulate scalar variables arrays present paper concerns programs manipulate pointers heap-allocated storage paper demonstrates create analysis algorithms cient precision program partial correctness established information contained state-descriptors obtained static analysis approach veri cation method creating program-analysis algorithms section illustrate veri cation method works extended version shape dept comp sci tel-aviv univ tel-aviv israel ftla sagivg math tau ycomp sci dept univ wisconsin madison usa reps wisc supported part nsf grant ccrand -israel bsf grant zsupported part -israel bsf grant xinformatik univ des saarlandes saarbr ucken germany wilhelm uni-sb analysis determines information shapes heap-allocated data structures pointer variable point present paper shape descriptors extended information track relative order values data elds neighboring list elements carrying static analysis family shape descriptors verify correctness versions sorting program operates linked lists important characteristics method stand contrast conventional approaches program veri cation ordinarily program veri cation involves establishing program satis user-supplied speci cation standard approach proving correctness user supplies pre-condition post-condition procedure loop-invariant loop program break program collection nite-length path fragments correctness established prove correctness program veri cation system traverses program gather collection veri cation conditions path fragment system calls theorem prover establish veri cation condition theorem paper make erent machinery order establish program works correctly user supplies descriptor acceptable inputs program abstract interpretation program performed descriptor program exit point checked make acceptable outputs produced method speci cation takes form input descriptor acceptability criterion output descriptors loop invariants completely omitted feature highly desirable characteristic precise statement desired inputoutput relationship veri cation method require experience thirty years loop invariants impose burden programmer method requires limited market adoption characterization work doubt raises questions reader mind swept rug phrase abstract interpretation program performed veri cation method possibly avoid loop invariants answers questions abstract interpretation important abstract interpretation performed applies descriptors ciently expressive maintain distinctions needed enterprise succeed speci cation analysis skills needed apply veri cation methodology present signi obstacle adoption methodology abstract interpretation typically easy task obtain abstract state-transformation functions show correct contrary papers program analysis exhaustive exhausting proofs demonstrate abstract semantics answers safe respect concrete semantics overcome obstacle method creating program-analysis algorithms set previous paper technique developer program-analysis algorithm freed proof obligations abstract interpretation advantage approach parametric framework program analysis method generating program-analysis tool high-level usersupplied description desired loop invariants conventional approach program veri cation loop invariants serve break program nite number nite-length path fragments contrast approach abstraction entire program executed nite representations nity runtime stores sense approach performs kind state-space exploration related model checking limiting abstract execution program priori nite set store descriptors convergence xed-point guaranteed descriptors arise head loop considered loop invariants automatically inferred system provided user domain descriptors nite invariant-synthesis problem erent character work invariants generated performing iterative xed-point computation special program points heads loops treated program point treated analysis technical level approach paper erent conventional approaches program veri cation assertions formulae pushed backwards statements justi cation propagating information backwards direction avoids existential quanti ers arise assertions pushed forwards direction generate strongest postconditions ordinarily strongest postconditions present culties quanti ers accumulate forcing work larger larger formulae abstract-interpretation method pushes information forwards direction discussed sections works semantic level operates directly explicit representations logical structures implicit representations logical formulae analysis carried respect domain state descriptors priori abstract interpretation designed speci program datatype designed proving correctness multiple programs manipulate data type list typedef struct node int struct node figure type declaration singly linked lists bounded size forwards propagation generate shape descriptors unbounded size analysis guaranteed terminate notion instrumentation predicate plays key role work instrumentation predicate captures property individual storage element possess general adding additional instrumentation predicates nes abstraction program analysis yields precise analysis algorithm maintains ner distinctions questions program data structures answered perspective interested verifying program approach adopt local elementwise view data structure approach markedly erent avor conventional approaches program veri cation emphasis developing invariants instance notion instrumentation predicate contrasted datatype invariant datatype invariant states global property abstract datatype instances holds entry exit datatype operations instrumentation predicate captures local property distinguish datatype components discussed sections approach local properties interest ected execution kind statement programming language illustrate program analysis veri cation means extended analysis versions sorting program operates linked lists show veri cation method ciently precise discover correct versions bubble-sort insertion-sort procedures fact produce correctly sorted lists outputs invariant is-sorted maintained listmanipulation operations element-insertion elementdeletion destructive list reversal merging sorted lists run algorithm erroneous versions bubble-sort insertion-sort procedures discover locate diagnose error figure shows declaration linked-list type figure shows implementation insertion-sort algorithm figure main program analyzed algorithm code procedures create merge reverse appendix remainder paper organized sections section summarizes program-analysis framework shows -valued logic serve basis program analysis section describes approach show sorting procedure partially correct procedure terminates resulting list sorted increasing order section discusses behavior analysis algorithm incorrect procedures section reports implementation method tvla sysinsertion include list insert sort null null null data data prn null pln break return figure correct version insertion sort main include list int main create insert sort merge reverse create insert sort create insert sort merge reverse figure program performs operations sorted lists tem section discusses limitations approach related work future directions -valued logic program analysis section summarize framework presented showed -valued logic serve basis program analysis generalized version analysis framework implemented system called tvla three-valued-logic analyzer tvla implement veri cation method paper generate gures presented relevant features speci tvla noted kleene -valued logic extension ordinary -valued logic special 
unknown cases predicates true false kleene interpretation propositional operators table values nite values inde nite representing memory states logical structures -valued logical structure comprised set individuals nodes called universe denoted interpretation universe set predicate symbols interpretation predicate symbol denoted predicate arity function -valued structures represent memory states operational semantics program -valued logical structures depicted directed graphs paper directed edge nodes labeled binary predicate symbol unary predicate symbol write inside node conversely write inside node set predicate symbols partitioned disjoint sets core instrumentation predicate symbols core predicates part pointer semantics record atomic properties memory state instrumentation predicates record derived properties ning formula terms core predicates evaluating formula instrumentation predicate structure yields operational semantics statement speci predicate-update formulae values predicates change statement executed paper -valued structure represents memory state called store individual corresponds list element intended meaning core predicates table intended meaning instrumentation predicates table moment ignore column store figure represented -valued structure shown figure structure nodes represent list elements representation intentionally ignores speci values n-components int memory address records relationships hold list elements binary relation captures list element successor binary relation dle track relative order list elements elds pointer variable unary predicate variable points list element represented figure unary predicate make gures intuitive x-predicate depicted edge box labeled node points absence edges predicates arity predicate intended meaning ning formula reachable program variable component reside directed cycle n-components pointed n-component inorder dle rst pair neighbors non-decreasing elds dle inrorder dle rst pair neighbors non-increasing elds dle table instrumentation predicates paper meaning separate predicate program variable ning formulae explained section predicate intended meaning pointed variable n-component point dle d-component less-than-or-equal-to d-component table core predicates analysis separate predicate program variable table kleene -valued interpretation propositional operators box nodes point placing inside node pointer components list elements represented binary predicates n-component points inequalities list elements represented binary predicate dle dles d-component equal d-component unary instrumentation predicate holds list elements reachable program variable possibly sequence accesses n-components structure figure nodes reachable important aspect explicitly storing instrumentation predicates compute ect program statement predicates values reevaluating instrumentation predicates ning formulae instance statement nodes reachable statement executes nodes reachable reevaluate formula ing means reachable generate predicate state statement executes predicate-update formula instrumentation predicate holds nodes shared n-components node shared n-components pointed list elements n-component figure elements list unshared fact execution programs paper nodes instrumentation predicate holds nodes cycle n-components cyclicity instrumentation avoid performing transitive-closure operation updating reachability information figure list nulln figure store linked list acyclic nodes express sortedness lists instrumentation predicates inorder dle inrorder dle predicate inorder dle holds nodes d-components equal n-successor similarly inrorder dle holds nodes d-components greater equal n-predecessors tvla makes explicit assumption set predicate symbols analysis xed number individuals structures vary analysis conservative representation sets memory states -valued structures -valued structures -valued logical structure comprised universe interpretation predicate symbols predicate arity function explicitly captures unknown predicate values -valued logical structures drawn directed graphs nite values drawn -valued structures binary inde nite predicate values drawn dotted directed edges write inside node -valued structure -valued structure surjective function embeds predicate arity conservatively represents -valued structures embedded function compactly represent structures -valued structure shown figure represents -valued structure fact structure shown figure represents lists elements unary predicate symbol indicating program variable point list element represented indicating point list elements represented unary predicates inorder dle inrorder dle relative order values elds neighboring elements list inorder dle inrorder dle inorder dle dle inrorder dle dle dle inorder dle dle dle dle ndle dle dle inorder dle inrorder dle dle figure logical structure representing store shown figure graphical tabular representations inrorder dle inorder dle dle inrorder dle inorder dle dle dle inorder dle inrorder dle dle figure -valued structure representing arbitrary lists length pointed program variable n-edges dotted indicating entries binary predicate symbol inde nite values indicating list element represented point list element represented list element figure indicating list element represented point list element represented figure points element point summary nodes nodes -valued structure represent individual -valued structure called summary nodes structure shown figure nodes represented summary node figure designated unary predicate maintain summarynode information summary node sms indicating represent node -valued structure nodes depicted graphically dotted ellipses contrast sms represent unique node node sms multiple nodes mapped embedding function sorted lists -valued structure shown figure contrast structure figure fact inorder dle inorder dle means represents lists elements sorted non-decreasing order values elements d-components illustrates instrumentation predicates purely local viewpoint provide ingredients global properties discussed section global properties stated quanti formulae instrumentation predicates fact dleso expected rst list element holds minimum values list exact choice nodes summarized crucial precision analysis discussed section formulae properties structures extracted evaluating formulae rst-order logic transitive closure equality function symbols constant symbols formula extracts reachability information denotes exive transitive closure predicate inorder dle inrorder dle dle inorder dle inrorder dle dle dle dle inorder dle inrorder dle dle figure -valued structure shown represents lists length pointed program variable elements sorted non-decreasing order values d-components structure evaluates node pointed evaluates exists path n-edges column table displays ning formulae instrumentation predicates paper formula potentially satis structure exists assignment evaluates embedding theorem embedding theorem theorem states formula evaluates nite -valued structure evaluates -valued structures embedded structure embedding theorem foundation -valued logic static-analysis ensures formulae interpreted -valued logic operational semantics reinterpret -valued structures formulae operational semantics programs manipulate linked lists evaluating formula -valued structure shown figure yields list element represented reachable variable list elements represented reachable program variable notice precise general principle instrumentation predicates referred instrumentation principle -valued structures stored information instrumentation predicate precise result evaluating predicate ning formula proving partial correctness sorting list-manipulation procedures section describe -valued-logic analysis framework prove implementation abstract datatype adt partially correct concerned adt sorted linked lists subset full set data structures allowed typedef shown figure consisting structures meet is-sorted datatype invariant case sorted linked lists interested correctness sorting operations create sorted linked lists establishing is-sorted maintained listmanipulation operations element-insertion elementdeletion destructive list reversal merging lists sorting procedure partially correct procedure terminates output list produces sorted non-decreasing order approach veri cation capable establishing instance 
speci analysis discuss establishes program point figure program variable points list sorted non-decreasing order figure establishes program point program variable holds reversal merge sorted lists points list sorted non-increasing order figure veri cation fail analysis conservative analysis reports program point variable point sorted list fact point sorted list limited experience small intricate programs happen embedding theorem usage abstract-interpretation methodology guarantees converse impossible analysis program point variable points sorted list input leads store list sorted analysis exit vertex variable points sorted list point sorted list procedure nishes execution capability contrasted run-time testing show presence errors absence mentioned introduction artifact approach work involved veri cation takes place level adt nition level individual program individual statements program section discusses required suitable analysis observing adt properties section describes analysis check partial correctness adt operations analysis observing adt properties set stores arise statement represented logical structure interpretation core instrumentation predicates operational semantics describe interpretation changed execution work operational semantics speci set predicate-update formulae statement type condition formulae core instrumentation predicate instance suppose structure represents set stores arise statement structure represents set stores arise obtained evaluating predicate-update formulae evaluation formulae -valued logic captures transfer function concrete semantics evaluation formulae -valued logic captures transfer function abstract semantics suppose binary predicate predicate-update formula statement table predicate obtained evaluating binding individuals logical variables precondition formulae operation allowed applied ect conditions predicate-update formulae core predicates program variables nitions predicate-update formulae instrumentation predicates found analysis suitable verifying procedures operate sorted linked lists provide predicate-update formulae core predicate dle instrumentation predicates inorder dle inrorder dle statements manipulate pointer variables updating core-predicate dle easy statement kinds malloc statements non-malloc statements create individuals predicate-update formula dle dle malloc statements predicate-update formula sets dle newly created individuals dle dle predicate holds newly allocated list element trivial obtain safe predicate-update formulae instrumentation predicates revaluate ning formulae resultant structure core-predicates updated solution overly conservative yield instrumentation predicate changed statement precise solution require adt designer provide change-formulae cstp instrumentation predicate identifying individuals execution case inorder dle inrorder dle turns simple statement form exp change structure heap cstinorder dle cstinrorder dle statement form null eld node pointed changed cstinorder dle cstinrorder dle predicate-update formulae instrumentation predicates change formulae recompute instrumentation predicate individuals predicate change formally predicateupdate formula cstp stc corepredicatesg condition precondition formula true-branch null null dle dle dle dle uninterpreted table precondition formulae true-branch part atomic program conditions manipulate linked lists ning formula instrumentation predicate stc predicate-update formula core-predicate formula evaluates evaluates evaluates iii evaluates evaluate formula safe ning formula recomputed individuals execution adt designer obliged show change formulae safe formula evaluate structure individual execution sorting task easy inorder dle inrorder dle local properties global properties reachability approach result overly conservative analysis developed predicate-update formulae reachability properties statement execution terms reachability properties hold statement executes conditions side ects write precondition formulae true-branches conditions table precondition formulae false-branches negations formulae transformers ned iterative algorithm compute program point controlow graph node nite set -valued structures conservatively represent set stores possibly occur point abstraction function static analysis ned subset unary predicates call abstraction properties principle abstraction list elements values abstraction predicates mapped abstract element view set abstraction predicates means observing contents heap heap cells summarized summary node observable erences note xed set abstraction properties constant number nodes observable differences guarantee analysis terminates procedures loops iterative xed-point nding procedure collapsing structures arise merging nodes structure observable erences means number nodes -valued structure bounded analysis eventually terminate summary glosses important details needed boosting precision technique details found checking partial correctness adt operations static-analysis algorithm ned preceding section demonstrate partial correctness adt operations user supply program-speci information procedure controlow graph set -valued structures characterize acceptable inputs procedure formulae characterize acceptable outputs correctly working procedure initial -valued structures supplied analysis algorithm abstract procedure entry point analysis algorithm run nally formulae characterize acceptable outputs evaluated structures generated analysis procedure exit point problem establishing version insert sort shown figure partially correct figure shows structures characterize set stores program variable points acyclic unshared linked list running analysis insert sort check structures arise procedure exit node formula evaluates inorder dle formula evaluates nodes reachable non-decreasing order point reader smell rat sorting procedure returns null satisfy formula exit point formula part speci cation post-condition correct sorting procedure property required correct sorting procedure procedures manipulate sorted linked lists output list permutation input list establish permutation property holds output insert sort extending program-analysis speci cation predicate orig set entry point record elements reachable statement predicate-update formula orig orig orig words orig serves indelible mark elements initially reachable end procedure check formula evaluates orig formula evaluate elements reachable procedure executes reachable beginning procedure procedure performs permutation case predicate orig introduced make observe output list permutation input list general predicate kind similar auxiliary variable kind conventional program veri cation denote initial program variable section -valued structures analysis discovers outputs create inorder dle inrorder dle inorder dle inrorder dle dle dle dle dle figure structure arises inrorder dle inorder dle inrorder dle inorder dle dle dle dle dle figure structure arises figure shows -valued structures arise end insert sort structures shown figure input structures structures figure describe stores variable points acyclic unshared sorted linked list structures formulas evaluate insert sort guaranteed work correctly acceptable inputs figure shows structures arise program point main figure figure substructure consisting x-box upper nodes represents sorted list length y-box lower nodes represents sorted list length figure shows produced analysis structure shown figure supplied input structure analysis merge output structure represents acyclic unshared sorted linked lists length words merge preserves sortedness figure shows produced structure shown figure supplied input structure analysis reverse output structure represents acyclic unshared linked lists length sorted reverse order method establish program point main figure program variable computed reversing list created merging sorted lists points list sorted nonincreasing order compile-time debugging programs observed earlier technique report lists produced sorting program sorted fact input leads unsorted output section demonstrate output algorithm applied incorrect programs information catching bugs compile time assuming case formula instrumentation predicate orig added analysis empty list -element lists lists elements inrorder dle inorder dle dle 
inrorder dle inorder dle dle inrorder dle inorder dle dle dle figure structures arise empty list -element lists sorted lists elements inrorder dle inorder dle dle inorder dle inrorder dle dle inorder dle inrorder dle dle dle dle figure structures arise inorder dle inrorder dle dle inorder dle inrorder dle dle inorder dle inrorder dle dle dle inorder dle inrorder dle dle dle dle dle dle dle dle dle figure structure arises common error sorting programs forget make comparisons boundary elements input data error reported output list sorted speci order veri cation method fails con program correct sorting procedure bugs diagnosed inspecting -valued structures produced analysis figure shows incorrect version insertion sort ignores rst element structure arises program exit point shown figure structure clues nature bug inorder dle summary node elements list arranged nondecreasing order inorder dle rst node proper place respect rest list elements figure shows bubble-sort procedure analysis procedure added instrumentation predicate dataisnequal dle ned formula dle dle subtle bug bubble-sort arises change condition swapping elements data yndata data yndata change procedure terminate input list elements elds identical values reason pass list elements swapped sort terminate bug manifests inputs testing overlook veri cation method applied erroneous bubble-sort program supplied input structures figure arbitrary acyclic unshared linked lists include list insert sort null return null null prn pln break return figure incorrect version insertion sort ignores rst element inorder dle inrorder dle inorder dle inrorder dle dle dle dle figure structure arises exit point insert sort analysis discovers lists arise end procedure data elds erent values shows nal -valued structure dataisnequal dle list elements figure shows incorrect version insertion sort method formula fails evaluate -valued structures arise exit point fails con program performs permutation list elements lost additional information program obtained checking memory-cleanness violations lines applying cleanness-checking formulae -valued structures arise analysis program detect memory leak occurs program point method presented paper avoid false alarms reported method bubble sort include bool include list void bubble sort change true change null change false null data yndata ynn change true ynn null figure correct version bubble sort prototype implementation section reviewed method creating program-analysis algorithms approach parametric framework program analysis method generating erent program-analysis tools high-level user-supplied descriptions desired ideal fully automatic method yacc program analysis speak prototype version system called tvla recently implemented java tvla spares user possess deep knowledge program analysis yacc generating parser context-free grammar spares yacc user understand details lalr parsing theory current implementation tvla capable handling programs pointers including allocation statements deallocation statements destructive updates pointers casting pointer arithmetic supported tvla supports intraprocedural analysis analysis paper implemented tvla tvla support interprocedural analysis conducted unit tests analyzing procedure time relevant input structures performance information analysis algorithm running pentium mhz linux jdk presented table note gure reported number structures total number structures creour experience system runs faster jvm windows include list insert sort null null null data data prn null pln break creates leak return figure incorrect version insertion sort memory leak occurs program point procedure number time structures seconds create insert sort merge reverse insert insert bubble sort bubble sort table running time total number structures arise analysis procedures analyzed ated program points number structures individual controlow-graph node tvla implement version analysis works dynamic arrays simpler cyclicity sharing instrumentation predicates needed limitations related work future directions implementation analyze small programs friendly subset extend larger subset scale programs realistic size involves rst running cheap imprecise pointer-analysis algorithm ow-insensitive points-to analysis proceeding precise expensive analysis reducing storage requirements method representing predicate tables bdds veri cation systems advantage method compute weakest preconditions information propagated backwards lead signi storage savings noted introduction veri cation systems require loop invariants supplied user erroneous programs veri cation systems weakest preconditions produce counterexamples feedback programmer system establish correctness sorting algorithms signi cantly slower tvla proving memory-cleanness properties explanation propagating formulae expensive propagating structures conceivable method combined demand data analysis propagate information backwards presence destructive updates greatly complicates problem intraprocedural analysis supported tvla analysis recursive version quicksort extension perform interprocedural analysis development general analysis establish liveness properties invocation function terminates cases establish negation liveness property checking safety property analysis show change set bubble sort program terminates section discussed interesting analysis detected buggy version bubble sort terminate list elements equal values safety properties technique overly imprecise set instrumentation predicates discussed section conclude sorting program stable reorders elements eld abstract-interpretation algorithms veri cation instance shown intervals precisely analyze mccarthy -function shown propagate information backwards direction intervals provide cient information handle dynamically allocated data structures destructive updates sortedness properties arrays abstract interpretation veri cation cecil cesar flavers kind veri cation performed work erent character present paper cecil cesar flavers address problem checking events execution program meet speci sequencing constraint contrast goal work verify partial correctness sense hoare work addresses dynamically allocated heap-allocated storage characterize unbounded number storage elements concerns situation running algorithm version quicksort explicit stack algorithm ran space overcome extra instrumentation predicates track relationships stack list elements plausible approach inductive strategy assertion recursive call returns sorted list emphasis date purely automatic analyses user-supplied assertion required characterizes input procedure considered cult veri cation community surprising fact work shows cases problem addressed means static program analysis work addresses pointer indirections aliases cult handle heap-allocated elements considered model checking program analysis erent techniques establish safety properties programs ways tvla system feels similar smv systems operational semantics speci transition relation hand rst-order logic tvla enables handle dynamically allocated objects scope current model-checking techniques -valued logic abstraction respect subset unary predicates tvla automatically obtain transition relation operates bounded-size representations ensures analysis terminates model-checking techniques based propositional logics nite automata optimization techniques bdds represent sets propositions original problem motivated -valued logic program analysis shape analysis goal determine program point set shape descriptors characterize shapes structures constructed dynamically allocated storage paper machinery performing static program analysis -valued logic applied erent problem characterizing intermediate nal states sorting algorithms shape analysis veri cation erent shape analysis corbett corbett results shape analysis improve performance model checker concurrent java programs shape analysis identify heap-allocated variables purely local thread shared 
variables protected locks information turn avoid explore interleavings threads fact veri cation method proposed paper based method creating programanalysis algorithms advantages disadvantages developer program-analysis algorithm freed proof obligations abstract interpretation left responsibility showing predicate-update formulae correctly ect predicates ected execution kinds statements programming language reasons believing burden imposed standard approaches abstract interpretation pointed introduction formulae proofs speci program datatype designed proving correctness multiple programs manipulate data type instance paper adopt unchanged predicates shape analysis linked-list programs experience gained approach libraries predicate-update formulae standard proofs correctness developed section approach creating families predicate-update formulae terms changecorbett version shape-analysis algorithm formulae factoring predicate-update formulae makes easier provide correctness proofs ideas automatically generate correct predicate-update formulae instrumentation predicates bourdoncle abstract debugging higher-order imperative languages sigplan conf prog lang design impl york acm press bryant graph-based algorithms boolean function manipulation ieee trans computers august chase wegman zadeck analysis pointers structures sigplan conf prog lang design impl pages york acm press cheatham holloway townley symbolic evaluation analysis programs ieee trans softw eng clarke grumberg peled model checking press corbett shape analysis reduce nite-state models concurrent java programs trans softw eng method cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press deutsch interactive program veri phd thesis univ california berkeley dijkstra discipline programming prenticehall dor rodeh sagiv checking cleanness linked lists static analysis symp dwyer clarke data analysis verifying properties concurrent programs proc acm sigsoft symp found softw eng pages york acm press gillett iterative global flow techniques detecting program anomalies phd thesis univ illinois gries science programming springer-verlag hoare axiomatic basis computer programming commun acm october hoare recursive data structures int comp inf sci jensen joergensen klarlund schwartzbach automatic veri cation pointer programs monadic second-order logic sigplan conf prog lang design impl king program veri phd thesis carnegiemellon univ pittsburgh lev-ami tvla framework kleene based static analysis master thesis tel-aviv http math tau tla lev-ami sagiv tvla system implementing static analyses static analysis symp mcmillan symbolic model checking kluwer academic publishers morris assignment linked data structures broy schmidt editors theoretical foundations programming methodology pages reidel publishing boston myers art software testing john wiley sons olender osterweil cecil sequencing constraint language automatic static analysis generation ieee trans softw eng olender osterweil interprocedural static analysis sequencing constraints trans softw eng method january sagiv reps wilhelm parametric shape analysis -valued logic tech rep trcomp sci dept univ wisconsin madison august revised march http wisc wpis papers parametric sagiv reps wilhelm parametric shape analysis -valued logic symp princ prog lang steensgaard points-to analysis almost-linear time symp princ prog lang pages suzuki ishihata implementation array bound checker symp princ prog lang pages york acm press tamir adi automatic derivation invariants ieee trans softw eng wegbreit synthesis loop predicates commun acm auxiliary procedures analyzed procedures reverse create merge figures include list list reverse list list null null null return figure procedure reverses list destructive updating include list create int rand void temp char malloc int rand null temp malloc sizeof struct node tempd rand tempn temp i-g return figure procedure creates random list positive integers include list merge head list tail list null return null return head list head list tail list head list null null tail listn tail listn tail list tail listn null tail listn null tail listn return head list figure procedure merges sorted lists 

integerdesctype enumdesctype typedesctype chunkdesctype fieldstructype typebasetype ptr xyrect ptr refrect ptr nameddrawobj ptr varrayrect ptr vchunkrect ptr dblptrrect ptr intchunkrect ptr drawobj ptr rectangle ptr namedxyrect ptr arrayrect 

gfed abc gfed abc 
pow main entryglobal exitglobal entrypow exitpow entrymain exitmain pow main entryglobal exitglobal pow main entryglobal exitglobal entry main result call pow etn pow res call pow etn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow pow entry main result call pow retn pow res call pow retn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow powpow entry pow power exp power base exp-u return power gexit pow exit pow powpow precise interprocedural dataflow analysis graph reachability thomas reps susan horwitz mooly sagiv wisconsin abstract paper shows large class interprocedural dataflow-analysis problems solved precisely polynomial time transforming special kind graph-reachability problem restrictions set dataflow facts finite set dataflow functions distribute confluence operator union intersection class problems includes limited classical separable problems gen kill bit-vector problems reaching definitions expressions live variables addition class problems techniques handle includes non-separable problems including truly-live variables copy constant propagation possibly-uninitialized variables results reported preliminary experimental study programs problem finding possiblyuninitialized variables introduction paper shows find precise solutions large class interprocedural dataflow-analysis problems polynomial time contrast intraprocedural dataflow analysis precise means meet-over-all-paths precise interprocedural dataflow-analysis algorithm provide solution path valid respects fact procedure finishes returns site recent call section relevant previous work precise interprocedural dataflow analysis categorized polynomial-time algorithms specific individual problems constant propagation flowsensitive summary information pointer analysis polynomial-time algorithm limited class problems locally separable problems interprocedural versions classical bit-vector gena work performed visiting datalogisk institut copenhagen universitetsparken dkcopenhagen east denmark leave ibm scientific center haifa israel work supported part david lucile packard fellowship science engineering national science foundation grants ccrand ccrby defense advanced research projects agency arpa order monitored office naval research contract -jby air force office scientific research grant afosr- grant xerox corporate research authors address computer sciences department univ wisconsin west dayton street madison usa electronic mail reps horwitz sagiv wisc kill problems include reaching definitions expressions live variables algorithms general class problems work cited category concentrated generality provide polynomial-time algorithms contrast previous work present paper polynomial-time algorithm finding precise solutions general class interprocedural dataflow-analysis problems class consists problems set dataflow facts finite set dataflow functions distribute meet operator union intersection depending problem call class interprocedural finite distributive subset problems ifds problems short locally separable problems ifds problems addition non-separable problems practical importance ifds problems truly-live variables copy constant propagation possibly-uninitialized variables results based insights restricting domains powersets atomic dataflow facts dataflow functions distributive efficiently create simple representations functions summarize effects procedures supporting efficient lookup operations input facts output facts locally separable problems representations summary functions sparse permits algorithm efficient efficient previous algorithm problems losing generality calculating worst-case cost algorithm determining cost-per-iteration main loop multiplying number iterations break cost algorithm contributing aspects bound total cost operations performed aspect appendix important aspects work summarized section show ifds problems solved precisely transforming special kind graph-reachability problem reachability interprocedurally realizable paths contrast ordinary reachability problems directed graphs transitive closure realizable-path reachability problems involve constraints paths considered realizable path mimics call-return structure program execution paths returns matched calls considered section present polynomial-time algorithm realizable-path reachability problem algorithm runs time asymptotically faster previously algorithm problem runs time callpep callp discussed section realizable-path reachability algorithm adaptive asymptotically performance applied common kinds problem instances restricted form asymptotic improvement algorithm performance common case locally separable problems work generalizes knoop steffen sense algorithm handles larger class problems locally separable problems algorithm runs time knoop-steffen algorithm imprecise overly conservative answers interprocedural dataflow-analysis problems obtained treating interprocedural dataflow-analysis problem essentially large intraprocedural problem graph-reachability terminology amounts paths interprocedurally realizable paths ifds problems bound extra cost needed obtain precise realizable-path answers important special case locally separable problems penalty kinds solutions obtained time distributive case penalty factor running time realizable-path reachability algorithm all-paths reachability solutions found time preliminary experiments reported section involve examples range penalty observed factor callahan algorithms interprocedural flow-sensitive side-effect problems problems technical standpoint slightly character ifds dataflow-analysis problems small adaptations algorithm section applied problems asymptotically faster algorithm callahan addition algorithm handles natural generalization callahan problems locally separable problems class distributive flow-sensitive side-effect problems related work section realizable-path reachability problem heart problem interprocedural program slicing fastest previously algorithm problem horwitz reps binkley realizable-path reachability algorithm paper yields improved interprocedural-slicing algorithm running time asymptotically faster horwitz-repsbinkley algorithm algorithm found run times fast horwitz-reps-binkley algorithm dataflow-analysis algorithm implemented analyze programs preliminary experimental results reported section space constraints forced treat material abbreviated form full details including proofs theorems stated paper great deal additional material found ifds framework distributive interprocedural dataflow-analysis problems ifds framework variant sharir pnueli functional approach interprocedural dataflow analysis extension similar knoop steffen order handle programs recursive procedures local variables parameters frameworks generalize kildall concept meet-over-all-paths solution intraprocedural dataflow-analysis problem meet-over-allvalid-paths solution interprocedural dataflowanalysis problem ifds framework designed general support languages procedure calls parameters global local variables problem framework solved efficiently algorithms semantic correctness orthogonal issue problem designer wishes advantage results obligations encode problem meets conditions framework show encoding consistent programming language semantics encoding problem ifds framework involve loss precision languages parameters passed loss precision problem instances aliasing process finding solution resulting ifds problem introduces loss precision ifds framework definitions definition ifds framework program represented directed graph called supergraph consists collection flow graphs procedure gmain represents program main procedure flowgraph unique start node unique exit node nodes flowgraph represent statements predicates procedure usual procedure call represented nodes call node return-site node sets call returnsite nodes procedure denoted callp retp sets call return-site nodes supergraph denoted call ret addition ordinary intraprocedural edges connect nodes individual flowgraphs procedure call represented call-node return-site node edges intraprocedural call-to-return-site edge interprocedural call-to-start edge start node called procedure interprocedural exit-to-return-site edge exit node called procedure call-to-return-site edges included ifds framework handle programs local variables parameters dataflow functions call-to-returnsite exit-to-return-site edges permit information local variables holds call site combined information global variables holds end called procedure discussing time space requirements set denote set size declare integer program main begin declare integer read call end procedure integer begin read call print end enter enter main main read call return exit main main return exit call read print program supergraph figure program supergraph supergraph annotated dataflow functions possiblyuninitialized variables problem notation denotes set renamed call call denote number call nodes graph make small deviations convention stand figure shows program supergraph definition path length node node possibly empty sequence edges denoted target edge source edge notion interprocedurally valid path captures idea paths represent potential execution paths definition call node unique index indexed call node label outgoing call-to-start edge symbol label incoming exit-to-return-site edge return-site node 
symbol pair nodes procedure path same-level valid path iff sequence labeled edges path string language balanced parentheses generated nonterminal matched context-free grammar matched matched matched call pair nodes supergraph path valid path iff sequence labeled edges path string language generated nonterminal valid grammar matched defined valid valid matched call matched denote set valid paths ivp formulation ifds dataflow-analysis framework definitions same-level valid paths capture transmission effects procedure sequences execution steps call stack temporarily grow deeper calls shallower original depth eventually returning original depth valid paths smain capture transmission effects smain program start node sequence execution steps note general execution sequence end number activation records call stack correspond unmatched string language valid supergraph shown figure path smain same-level valid path path smain valid path return edge correspond preceding call edge define notion instance ifds problem definition instance interprocedural finite distributive subset problem ifds problem short five-tuple supergraph defined definition finite set iii set distributive functions map edges dataflow functions meet operator union intersection remainder paper ifds problems meet operator union hard show ifds problems meet operator intersection handled dualizing transforming problem complementary union problem informally must-be-x problem intersection ifds problem may-not-be-x problem union ifds problem node solution must-be-x problem complement respect solution may-not-be-x problem figure supergraph annotated dataflow functions possibly-uninitialized variables problem possibly-uninitialized variables problem determine node set program variables uninitialized execution reaches variable possibly uninitialized x-definition-free valid path valid path definition variable possibly uninitialized dataflow function edge shown figure adds set possiblyuninitialized variables set possibly-uninitialized variables node simplify presentation assume definition single global space dataflow facts assumption made strictly expository purposes general setting procedure possibly space dataflow facts presents additional difficulties implementation ifds framework discussed section supports general setting definition ifds problem instance nonempty path path function corresponds denoted pfq function pfq path function empty path identity function definition ifds problem instance solution consists collection values mvpn defined mvpn ivp smain interprocedural dataflow analysis graphreachability problem representing distributive functions section show represent distributive functions compact fashion function represented graph edges equivalently adjacency matrix entries section assume denote functions distribute definition representation relation binary relation graph defined thought graph nodes node represents element nodes roughly stand table shows functions representation relations note consequence definition edge form consequence definition edges representation relations obey kind subsumption property edge edge constant-function edge subsumes edges representation relations fact relations interpreted functions definition relation interpretation function defined theorem task show relational composition representation relations relates function composition definition relations composition defined theorem definition theorem imply composition distributive functions represented graph relation edges words distributive functions compressible bound size graph needed represent function composition functions enter enter main main read call return exit main main return exit call read print figure exploded supergraph corresponds instance possibly-uninitialized variables problem shown figure closed circles represent nodes gip reachable realizable paths smain open circles represent nodes reachable paths corollary collection functions rfj dataflow-analysis problems realizablepath reachability problems section show convert ifds problems realizable-path graph-reachability problems instance ifds problem construct graph gip instance realizable-path reachability problem gip edges gip correspond representation relations dataflow functions edges relationship function composition paths composed representation-relation graphs corollary path problem shown equivalent dataflow-fact holds supergraph node iff realizable path distinguished node gip represents fact holds start procedure main node gip represents fact node theorem definition ifds problem instance define exploded supergraph denoted gip gip nodes gip pairs form node exploded nodes gip edge dataflow function exploded number edges gip representation relation dataflow-problem corresponds single-source realizable-path reachability problem gip source node smain exploded supergraph corresponds instance possibly-uninitialized variables problem shown figure shown figure remainder paper terms same-level realizable path same-level valid path refer related concepts exploded supergraph supergraph realizable paths valid paths idea path corresponds potential execution path constraints imposed paths mimic call-return structure program execution paths returns matched calls permitted term realizable paths connection paths exploded supergraph term valid paths connection paths supergraph state main theorem section theorem shows ifds problem instance equivalent realizable-path reachability problem graph gip theorem gip exploded supergraph ifds problem instance program point mvpn iff realizable path graph gip node smain node practical consequence theorem find solution solving realizable-path reachability problem graph gip exploded supergraph shown figure corresponds instance possiblyuninitialized variables problem shown figure closed circles represent nodes reachable realizable paths smain open circles represent nodes reachable realizable paths note nodes reachable nonrealizable paths smain information nodes values solution dataflow-analysis problem instance solution mvpep variable possibly-uninitialized variable execution reaches exit node procedure figure information obtained determining realizable path smain smain efficient algorithm realizable-path reachability problem section present algorithm realizablepath reachability problem algorithm dynamicprogramming algorithm tabulates kinds same-level realizable paths discussed section appendix algorithm running time polynomial parameters problem asymptotically faster previously algorithm problem algorithm call tabulation algorithm presented figure algorithm functions returnsite maps call node return-site node procof maps node enclosing procedure calledproc maps call node called procedure callers maps procedure set call nodes represent calls procedure tabulation algorithm set named pathedge record existence path edges represent subset same-level realizable paths graph gip source path edge node form realizable path exists node smain words path edge represents suffix realizable path node smain tabulation algorithm set named summaryedge record existence summary edges represent same-level realizable paths run nodes form call returnsite terms dataflow problem solved summary edges represent partial information dataflow call depends dataflow call tabulation algorithm worklist algorithm accumulates sets path edges summary edges initial set path edges represents -length same-level realizable path smain smain line iteration main loop procedure forwardtabulateslrps lines algorithm deduces existence additional path edges summary edges configurations tabulation algorithm deduce existence additional path edges depicted figure realizable path smain path edge inserted worklist lines case path edge represents -length suffix realizable path smain idea inserting relevant edges worklist similar idea avoiding unnecessary function applications abstract interpretation variously chaotic iteration needed information minimal function-graph approach important note role lines figure executed summary edge discovered declare pathedge worklist summaryedge global edge set algorithm tabulate gip begin gip pathedge smain smain worklist smain smain summaryedge forwardtabulateslrps sprocof pathedge end procedure propagate begin pathedge insert pathedge insert worklist end procedure forwardtabulateslrps begin 
worklist select remove edge worklist switch case callp scalledproc propagate scalledproc scalledproc returnsite summaryedge propagate returnsite end case case callers returnsite returnsite summaryedge insert returnsite summaryedge sprocof pathedge propagate sprocof returnsite end case case callp propagate end case end switch end figure tabulation algorithm determines solution determining same-level realizable paths exist gip sprocof pathedge propagate sprocof returnsite unlike edges edges inserted summaryedge on-the-fly purpose line restart processing finds same-level realizable paths sprocof summary edge returnsite place final step tabulation algorithm lines create values gathering set nodes gip targets path edges discovered procedure forwardtabulateslrps sprocof pathedge mentioned fact edge sprocof pathedge implies realizable path smain theorem tabulation algorithm terminates node calledproc calledproc returnsite lines lines returnsite returnsite line lines key path edge possibly path edge possibly summary edge ordinary edge summary edge call-to-return-site edge call-to-start exit-to-return-site edge lines figure diagrams show situations handled lines tabulation algorithm solution theorem correctness tabulation algorithm tabulation algorithm terminates termination mvpn cost tabulation algorithm running time tabulation algorithm varies depending class dataflow-analysis problems applied mentioned locally separable problems define class sparse problems definition problem h-sparse problem instances property function ordinary intraprocedural edge call-to-return-site edge total number edges function representation relation emanate nonnodes general nodes control-flow graph represent individual statements predicates basic blocks aliasing expect distributive problems h-sparse statement small portion execution state accesses small portion state dataflow functions abstractions statements semantics close identity function representation relations roughly edges problems practical interest nodes control-flow graph represent individual statements predicates aliasing instance possibly-uninitializedvariables problem -sparse non-identity dataflow functions assignment statements outdegree nonnode representation relation function variable initialization status affect variable variable assigned analyzing tabulation algorithm assume primitive set operations unit-cost achieved instance representation table summarizes tabulation algorithm behaves terms worst-case asymptotic running time classes problems asymptotic running time class dataflow functions characterization functions properties intraprocedural problems interprocedural problems distributive edges rep -relation h-sparse hed edges rep -relation call hed locally separable component-wise dependences table asymptotic running time tabulation algorithm classes dataflow-analysis problems details analysis running time tabulation algorithm distributive problems appendix bounds classes problems follow simplifications argument storage requirements tabulation algorithm consist storage graph gip sets worklist pathedge summaryedge bounded call preliminary experimental results carried preliminary study determine feasibility tabulation algorithm study compared algorithm accuracy time requirements safe naive reachability algorithm considers paths exploded supergraph realizable paths algorithms implemented front end analyzes program generates exploded supergraph problem current implementation front end account aliases due pointers study programs struct-beauty beautification phase unix struct program twig code-generator generator ratfor preprocessor converts structured fortran dialect standard fortran c-parser lex yacc-generated parser tests carried sun sparcstation model ram table information source code lines lex yacc parameters characterize size control-flow graphs exploded supergraph cfg statistics statistics call lines source code struct-beauty c-parser ratfor twig practice edges form implementation takes advantage represent edges compact table compares cost accuracy tabulation algorithm naive algorithm running times user cpu-time system cpu-time case time reported average ten executions tabulation algorithm naive algorithm realizable paths path time sec reporteduses possibly uninitialized variables time sec reported possibly uninitialized variables struct-beauty c-parser ratfor twig number possibly-uninitialized variables reported tabulation algorithm ranges reported naive algorithm problem -sparse asymptotic costs tabulation algorithm naive algorithm call examples ranges penalty obtaining precise solutions ranges preliminary experiment suggests extra precision meet-over-all-validpaths solutions interprocedural dataflow-analysis problems obtained tabulation algorithm acceptable cost related work previous interprocedural dataflow-analysis frameworks ifds framework based earlier interprocedural dataflow-analysis frameworks defined sharir pnueli knoop steffen basically sharir-pnueli framework modifications dataflow domain restricted subset domain finite set dataflow functions restricted distributive functions iii edge call node return-site node dataflow function conditions restrictions make ifds framework general full sharir-pnueli framework condition iii generalizes sharirpnueli framework permits cover programming languages recursive procedures local variables parameters sharir-pnueli framework generalization handle recursive procedures local variables parameters proposed knoop steffen ifds problems solved number previous algorithms including elimination iterative call-strings algorithms sharir pnueli algorithm cousot cousot general ifds problems iterative callstrings algorithms exponential time worst case knoop steffen give algorithm similar sharir pnueli elimination algorithm efficiencies sharir-pnueli knoop-steffen elimination algorithms depend things functions represented representations discussed representation relations defined section sharirpnueli knoop-steffen algorithms manipulate functions pointwise distributive sparse problems efficient tabulation algorithm holley rosen investigated qualified dataflow analysis problems qualifications device paths flow graph considered employ expansion phase similarities creation exploded supergraph holley rosen advantage distributivity expansion pointwise ifds problems create points flowgraph node opposed points approach interprocedural problems holley-rosen approach equivalent impractical sharir-pnueli call-strings approach reps investigated deductive databases logic programs bottom-up evaluation engine implement locally separable interprocedural dataflowanalysis problems approach viewed pointwise tabulation method present paper make logic-programming terminology tabulation algorithm straightforward implementation logic program contribution present paper shows extend logicprogramming approach class locally separable problems class ifds problems dataflow analysis graph reachability pointwise computation fixed points work shows large subclass problems sharir-pnueli knoop-steffen frameworks posed graph-reachability problems work solving dataflow-analysis problems reducing reachability problems kou cooper kennedy case dataflow-analysis problem solved building graph derived program flow graph dataflow functions solved performing reachability analysis graph propagating simple marks contrasts standard iterative techniques propagate sets values flow graph kou paper addresses intraprocedural problems discusses live-variable problem ideas immediately carry separable intraprocedural problems cooper kennedy show flow-insensitive interprocedural dataflow-analysis problems converted reachability problems deal flow-insensitive problems solution method involves ordinary reachability difficult question reachability realizable paths zadeck developed intraprocedural dataflow analysis algorithms based idea partitioning problem independent problems per-bit basis case separable problems technique exploding problem exploded supergraph transforms locally separable problems number independent per-fact subproblems technique yield independent subproblems h-sparse general distributive ifds problems -sparse possibly-uninitialized variables problem variable transitively affected variables problems solved efficiently tabulation algorithm graph reachability thought implementation pointwise computation fixed points studied cai paige nielson nielson theorem basis convert dataflow-analysis problems reachability problems similar lemma cai paige relation cai paige define representing distributive functions subsumption property change asymptotic complexity tabulation algorithm relations subsumption property decreases number edges exploded supergraph reduces running time tabulation algorithm cai paige show pointwise computation fixed points compile programs written veryhigh-level language efficient executable code suggests express problem finding solutions ifds problems fixed-point program automatically compile implementation achieves bounds established 
paper tabulation algorithm nielson nielson investigated bounds cost general fixed-point-finding algorithm computing cost iterations cost iteration main contribution give formulas bounding number iterations based properties functional domain fixed-point computed formula strict additive functions adapted context non-strict distributive functions show number iterations tabulation algorithm cost single iteration call maximum outdegree node control-flow graph approach bound total cost tabulation algorithm call call knd compares unfavorably bound contrast bound presented cost tabulation algorithm obtained breaking cost algorithm contributing aspects bounding total cost operations performed aspect appendix pointwise tabulation landi ryder algorithm interprocedural alias analysis single-level pointers algorithm give similar tabulation algorithm limitation ifds framework information return-site node expressed meet information call node exit node single-level-pointer problem combining function return-site nodes meet problem fit ifds framework flow-sensitive side-effect analysis callahan investigated flow-sensitive side-effect problems must-modify may-use must-modify problem identify procedure variables modified call may-use problem identify procedure variables modified call callahan method involves building program summary graph consists collection graphs represent intraprocedural reaching-definitions information start exit call return-site nodes interprocedural linkage information must-modify may-use problems ifds problems defined definition viewed problems closely related ifds problems basic difference ifds problems summarize true program point calling contexts must-modify may-use problems summarize effects procedure isolated calling contexts callahan problems involve valid paths individual procedures start nodes start node main procedure must-modify problem same-level-valid-path problem valid-path problem must-modify procedure involves same-level valid paths procedure start node exit node callahan problems thought examples problems general classes problems class distributive valid-path problems class distributive same-level valid-path problems method utilized present paper convert distributive valid-path dataflow-analysis problems realizable-path reachability problems exploded supergraph transformations analogous section distributive valid-path problems posed realizable-path problems distributive same-level valid-path problems posed same-level realizable-path problems may-use problem locally separable problem class must-modify problem locally separable problem class payoff adopting generalized viewpoint slight modifications tabulation algorithm solve problems classes distributive h-sparse problems locally separable modified algorithms equations callahan operators problems kind heterogeneous meet join problems callahan flow-sensitive kill problem reformulated sharir-pnueli framework corresponds meet corresponds composition edge functions asymptotic running time tabulation algorithm locally separable problems must-modify may-use running time bounded asymptotic improvement algorithms callahan worst-case cost building program summary graph callpep program summary graph worst-case cost computing must-modify may-use callp demand algorithms interprocedural dataflow analysis goal demand dataflow analysis determine dataflow fact holds point minimizing amount auxiliary dataflow information computed program points benefits ifds framework permits simple implementation demand algorithm interprocedural dataflow analysis work demand interprocedural dataflow analysis includes ide framework recently generalized ifds framework larger class problems called ide framework ide framework dataflow facts maps environments finite set symbols possibly infinite set values dataflow functions distributive environment transformers ide stands interprocedural distributive environment problems ide problems proper superset ifds problems ide problems including variants interprocedural constant propagation encoded ifds problems transformation apply ide problems similar ifds problem transformed problem results realizable-path summary problem realizable-path reachability problem transformed graph longer concerned pure reachability problem values obtained applying functions realizable paths relationship transformed ifds problems transformed ide problems similar relationship ordinary graph-reachability problems generalized problems compute summaries paths shortest-path problems closed-semiring path problems algorithm solving ide problems dynamic-programming algorithm similar tabulation algorithm appendix running time tabulation algorithm section present derivation bound table cost tabulation algorithm distributive problems calculating worst-case cost-per-iteration loop lines figure multiplying number iterations break cost algorithm contributing aspects bound total cost operations performed aspect cost tabulation algorithm broken cost worklist manipulations cost installing summary edges call sites lines figure iii cost closure steps lines figure path edge inserted worklist cost worklist-manipulation operation charged step closure step provide separate accounting worklist-manipulation costs tabulation algorithm understood simultaneous semi-dynamic multi-source reachability problems procedure program procedure sources call anchor sites nodes form edges multi-source reachability problem intraprocedural edge call-to-return-site edge summaryedge callp words graph procedure exploded flow graph procedure augmented summary edges call sites reachability problems semi-dynamic insertions algorithm summary edges added summary edges edges removed turn question computing bound cost installing summary edges call sites lines figure express bound introduce quantity represents bandwidth transmission dataflow information procedures maximum callto-start edges exit-to-return-site edges maximum outdegree nonnode call-to-start edge representation relation maximum indegree nonnode exit-to-return-site edge representation relation worst case typically small constant problems summary edge returnsite conditional statement lines executed number times iterations loop lines line executed time tabulation algorithm finds three-edge path form returnsite shown diagram marked line figure set summary edges call site returnsite executions line categories choices pair pair three-edge paths form choices choice three-edge paths form three-edge path form total cost executions line bounded call test line code lines executed summary edge summary edge cost loop lines bounded total number summary edges bounded call total cost lines call total cost installing summary edges tabulation algorithm bounded call call bound total cost closure steps essential observation number attempts tabulation algorithm makes acquire path edge attempt successful inserted pathedge remaining attempts redundant unavoidable case node ret tabulation algorithm obtain path edge twoedge paths form pathedge depicted anchor site cost closure steps involved acquiring path edge bounded indegree distributive problems representation relation function ordinary intraprocedural edge call-toreturn-site edge edges anchor site total cost acquiring outgoing path edges bounded ret indegree epd accounting case node ret similar tabulation algorithm obtain path edge edge pathedge form edge edge summaryedge cost accounting pessimistically assume node ret maximum number incoming summary edges callpd nodes form ret anchor site total cost acquiring path edges form ret indegree summary-indegree equals callpd bound total cost closure steps performed tabulation algorithm cost closure steps anchor sites callpd epd callp call total running time tabulation algorithm bounded call improve bound call treating procedure linkages b-sparse procedures introducing linkages linkage procedures bandwidth call simplifies bound reported table aho hopcroft ullman design analysis computer algorithms addison-wesley reading aho ganapathi tjiang code generation tree matching dynamic programming acm trans program lang syst october baker algorithm structuring flowgraphs acm january cai paige program derivation fixed point computation science computer programming callahan cooper kennedy torczon interprocedural constant propagation proceedings sigplan symposium compiler construction palo alto june acm sigplan notices july callahan program summary graph flow-sensitive interprocedural data flow analysis proceedings acm sigplan 
conference programming language design implementation atlanta june acm sigplan notices july cooper kennedy interprocedural side-effect analysis linear time proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july cooper kennedy fast interprocedural alias analysis conference record sixteenth acm symposium principles programming languages austin jan acm york cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixpoints conference record fourth acm symposium principles programming languages los angeles january acm york cousot cousot static determination dynamic properties recursive procedures formal descriptions programming concepts ifip andrews canada august neuhold north-holland york duesterwald gupta soffa demand-driven computation interprocedural data flow conference record twenty-second acm symposium principles programming languages san francisco jan acm york fischer leblanc crafting compiler benjamin cummings publishing company menlo park giegerich moncke wilhelm invariance approximative semantics respect program transformation informatik-fachberichte springer-verlag york grove torczon interprocedural constant propagation study jump function implementation proceedings acm sigplan conference programming language design implementation albuquerque june acm york holley rosen qualified data flow problems ieee transactions software engineering sepp january horwitz reps binkley interprocedural slicing dependence graphs acm trans program lang syst january horwitz reps sagiv demand interprocedural dataflow analysis unpublished report computer sciences department wisconsin madison preparation jones mycroft data flow analysis applicative programs minimal function graphs conference record thirteenth acm symposium principles programming languages petersburg jan acm york kernighan ratfor preprocessor rational fortran software practice experience kildall unified approach global program optimization conference record acm symposium principles programming languages acm york knoop steffen interprocedural coincidence theorem proceedings fourth international conference compiler construction paderborn frg october lecture notes computer science vol kastens pfahler springer-verlag york knoop steffen efficient optimal bit-vector data flow analyses uniform interprocedural framework bericht institut fuer informatik und praktische mathematik christianalbrechts-universitaet kiel kiel germany april kou live-dead analysis global data flow problems journal acm july landi ryder pointer-induced aliasing problem classification conference record eighteenth acm symposium principles programming languages orlando january acm york nielson nielson finiteness conditions fixed point iteration conference record acm symposium lisp functional programming san francisco june acm york nielson nielson bounded fixed point iteration conference record nineteenth acm symposium principles programming languages albuquerque january acm york reps sagiv horwitz interprocedural dataflow analysis graph reachability datalogisk institut copenhagen copenhagen denmark april world wide web ftp ftp diku diku semantics papers reps horwitz sagiv rosay speeding slicing sigsoft proceedings acm sigsoft symposium foundations software engineering orleans december acm sigsoft software engineering notes december reps solving demand versions interprocedural analysis problems proceedings international conference compiler construction edinburgh scotland april lecture notes computer science vol fritzson springer-verlag york sagiv reps horwitz precise interprocedural dataflow analysis applications constant propagation unpublished report comp sci dept univ wisconsin madison oct submitted conference sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications muchnick jones prentice-hall englewood cliffs zadeck incremental data flow analysis structured program editor proceedings sigplan symposium compiler construction montreal june acm sigplan notices incremental algorithm june maintaining 
dominator tree reducible flowgraph ramalingam ibm watson research center yorktown heights rama watson ibm thomas reps wisconsin-madison dayton street madison reps wisc abstract present incremental algorithm problem maintaining dominator tree reducible flowgraph flowgraph undergoes insertion deletion edges algorithm applications incremental dataflow analysis incremental compilation introduction contribution paper incremental algorithm problem maintaining dominator tree reducible flowgraph flowgraph undergoes insertion deletion edges dominator tree plays important role algorithms 
program analysis program optimization updating dominator tree flowgraph arises contexts instance carroll ryder car present incremental dataflow analysis algorithm makes dominator trees part algorithm update dominator tree flowgraph update dominator tree arise context batch compilation instance dominator trees construction static single assignment ssa representation programs cyt cyt optimizing compiler repeatedly applies optimizing transformations update ssa representation program transformation algorithm presented paper works reducible flowgraphs identify edge insertions introduce irreducibility idea algorithm formulate problem constructing dominator tree reducible flowgraph pseudo circuit problem circuit problem essentially problem computing fixed point collection nonrecursive equations alp lets borrow work author wisconsin supported part david lucile packard fellowship science engineering national science foundation grant ccrand defense advanced research projects agency arpa order monitored office naval research contract -jideas previous incremental algorithms circuit problem show section problem constructing dominator tree differs considerably circuit problem directly incremental circuit evaluation algorithm dominator-tree update problem incremental algorithm due alpern alp maintaining priorities dag induced forward edges flowgraph key aspect algorithm dominator tree maintained link-cut-tree data structure due sleator tarjan sle dynamic data structure permits number operations performed efficiently previous algorithm problem maintaining dominator tree reducible flowgraph due carroll ryder car algorithm paper worst-case complexity carrollryder algorithm good reasons algorithm efficient practice comparison algorithms section remainder paper organized section review relevant terminology notation section present incremental algorithm conclude section comparison previous work discussion extensions terminology notation flowgraph directed graph source vertex initially flowgraphs vertex reachable source vertex vertex dominate vertex flowgraph source iff path passes dominates proper dominator domination special kind relation concisely represented tree dominator tree vertex ancestor vertex iff dominates parent vertex dominator tree referred dominator denoted idom edge flowgraph back edge vertex dominates vertex forward edge flowgraph reducible flowgraph set forward edges induces acyclic graph irreducible equivalent characterizations reducibility aho usual definition reducible flowgraph assumes vertices reachable source vertex relax restriction flowgraph reducible flowgraph set vertices reachable source reducible flowgraph definition relaxation context incremental computation changing reducible flowgraph reducible flowgraph inserting deleting edges temporarily introduce unreachable vertices concept domination applies reachable vertices algorithm outline paper maintain dominator tree subgraph induced reachable vertices classification edge back edge forward edge meaningful endpoints edge reachable status edge status back edge forward edge recall edge back edge iff dominates path source vertex back edge cyclic path occurrences vertex implies set reachable vertices change back edge removed graph vertex reachable iff exists acyclic path source vertex vertex similarly domination relation flowgraph change back edge removed graph domination defined terms acyclic paths problems maintaining reachability information dominator tree reducible flowgraph closely related problems maintaining reachability information dominator tree dag dag forward edges provided identifying forward edges back edges graph show status edge forward edge back edge change edges inserted deleted graph long graph remains reducible sequence modifications talking edges endpoints remain reachable flowgraph proposition reducible flowgraphs status edge reachable graphs proof easily definition domination insertion edge shrink domination relation dominates graph dominate graph back edge graph back edge graph assuming edge consideration equivalently forward edge forward edge back edge back edge reason back edge path consisting forward edges exists path forward edges forward edge set forward edges induce cycle contradicting assumption reducible status newly inserted edge domination defined terms acyclic paths insertion edge change set dominators vertex back edge iff dominates graph iff dominates graph determine status newly inserted edge domination information original graph dynamic dominator tree problem reducible flowgraphs section present incremental algorithm maintaining dominator tree subgraph reachable vertices flowgraph assumption subgraph remains reducible flowgraph undergoes modifications outline method checking graph irreducible sequence modifications dominator tree directed acyclic graph section dominator tree reducible flowgraph dag forward edges flowgraph present simple batch algorithm constructing dominator tree dag linear time algorithms construct dominator tree dag har och reason presentation suggests incrementally maintaining dominator tree dag idea maintaining dominator tree reducible flowgraph dag source vertex vertex dag predecessors vertex properly dominate iff dominates vertices words dom dom dom denotes set dominators vertex identified set dominators set proper dominators obtained intersecting sets dominator common ancestor dominator tree previous paragraph suggests scheme constructing dominator tree dag incremental fashion vertices dag visited topological order added dominator tree initially dominator tree consists source vertex vertex visited common ancestor predecessors partially constructed tree identified made child construction dominator tree dag bce dominator tree obtained inserting edge dominator tree figure show problem constructing dominator tree dag differs circuit problem edge inserted dag affected vertices resulting dag shaded region form connected region considered pseudo circuit problem vertex source vertex equation parent lca lca abbreviation common ancestor computed vertex source parent dominator tree note problem true circuit problem right-hand side equation pure function values predecessors vertex output vertex dominator change output predecessors changed dag shown figure dag modified dag insertion edge vertex affected vertex affected dominator successor affected dominator vertex affected predecessors affected problem prevents incremental circuit evaluation algorithm directly circuit problem input consists dag vertex equation specifies output computed vertex function output values predecessor vertices conservative approximation set affected vertices ideas circuit problem update dominator tree visit vertices possibly affected topological order determine dominators equation priorityordering visit vertices topological sort order incremental algorithm alpern alp updating priority-ordering graph undergoes priority-ordering associates priority vertex dag path vertex vertex priority priority represent dominator tree link-cut tree data structure link-cut tree data structure due sleator tarjan sle representation dynamic forest collection trees number operations performed efficiently operations interest maketree operation creates tree consisting single newly inserted vertex link operation adds edge vertex tree root tree making subtree cut operation removes edge tree breaking trees operation returns common ancestor vertices check ancestor-descendant relationship vertices operations runs log time number vertices forest dynamic dominator tree problem reducible flowgraphs 
return problem maintaining dominator tree reducible flowgraph denote reducible flowgraph dominator tree maintained algorithm maintain data structures information reachability status vertex maintained denote subgraph induced reachable vertices status edge forward edge back edge maintained denote acyclic subgraph induced forward edges correct prioritization maintained dominator tree dominator tree maintained link-cut tree insertion edge problem updating information edge inserted graph assume vertex originally reachable source vertex simpler case vertex reachable means change reachability status vertices special case change reachability case set vertices remains added set edges proposition insertion change status edge maintaining edge statuses requires determine status newly inserted edge vertex dominates vertex original graph edge inserted back edge forward edge check dominates original graph log time representation dominator tree link-cut tree enables check ancestordescendant relation vertices log time edge back edge edge forward edge insert update prioritization algorithm presented alp algorithm determines insertion edge dag introduces cycle determine point insertion edge makes graph irreducible updating priorities takes log time measure size change priorities dag number valid priority-orderings dag modified priority-ordering updated number ways require updating priorities set vertices size smallest set vertices updating priorities yields valid priority-ordering size set vertices sum number vertices number edges incident vertices problem updating dominator tree change insertion forward edge flowgraph proposition figure insertion edge flowgraph reachable vertex affected insertion edge idom properly dominate idom properly dominated lca dominator affected vertex lca proof assumed vertex reachable flowgraph occur dominator tree original flowgraph denote idom common ancestor affected vertex vertex dominator denote idom original graph noted earlier insertion edge shrink domination relation dominator dominator original graph dominator ancestor original dominator tree infer fact longer dominates insertion edge created path avoids original graph path path avoid vertex implies dominator original graph required path existed implies proper dominator original graph exist path original graph avoids concatenating paths yields path original graph avoids contradicting assumption dominates original graph proper ancestor ancestor words proper ancestor proper descendant lca lie shaded region shown figure establishes claim proposition claim assume affected vertex note lca dominates graph exists path avoids lca hand ancestor original dominator tree proper descendant lca dominate graph exists path avoids assumed affected vertex exists path avoids dominator affected vertex lca vertices define possiblyaffected set idom proper ancestor proper descendant lca proposition shows possibleaffected lca idom idom lca edge inserted flowgraph path flowgraph figure change dominator tree flowgraph edge inserted solid wavy lines figure paths dominator tree solid straight lines edges dominator tree dashed lines edges paths flowgraph affected vertex idom lie shaded region original dominator tree dominator affected vertex lca conservative approximation set affected vertices edge inserted provided reachable original graph re-evaluate vertices increasing order priority determine set affected vertices update dominator tree re-evaluation vertices possibleaffected determine vertices affected proposition shows dominator affected vertex lca step takes time possibleaffected log set denotes sum number vertices number edges coming vertices general case insertion edge reachable reachable processed easily worklist algorithm repeatedly invokes special-case updating algorithm create worklist initially consists edge worklist processed marked reachable process edge special-case algorithm previously outlined case edge newly inserted edge edge graph previously processed vertex previously unreachable processed marked unreachable marked reachable edge marked forward edge assigned priority greater made child vertex dominator tree finally edges added worklist update efficiently general case observe edges processed worklist algorithm types edges form reachable edges form previously reachable algorithm presented identifies edges vertices processed partitions classes processes separately algorithm presented figure major steps involved algorithm determining set vertices reachable processing subgraph induced determining set edge set previously reachable vertices newly reachable vertices original dominator tree dominator tree subgraph induced edge set flow graph dominator tree figure change dominator tree flowgraph edge inserted reachable flowgraph shown left side tree side shows dominator tree edge newly reachable vertex previously reachable vertex set empty empty dominator tree obtained dominator tree processing insertion edges edges form processing set edges set vertices reachable obtained easily simple graph traversal starting processing subgraph batch algorithm dominator tree source vertex computed batch algorithm status edges computed simple traversal dominator tree tree made subtree original dominator tree making child priorities assigned vertices simple batch algorithm ensure priorities greater priority steps sufficient long edge vertex previously reachable vertices edge identify set edges vertices vertices process insertion edges special-case algorithm outlined previously process edges possibleaffected approximation set affected vertices approximation affected vertices processed order increasing priorities complexity algorithm consists components time spent updating priorities log time spent remaining steps visited log visited approximation affected identified algorithm deletion edge collapse problem collapse updating cast dominator tree common auxiliary initial information sequence offsets football deletion twig edge rep sim ulator ispellli special case gzipbison- lessfle edge-deletion change ksim anag ram ansitape compress triangle yacr football twig rep sim ulator ispellli gzipbison- lessfle reachability status ksim vertex min vertex hrs unreachable deletion iff collapse collapse cast common initial sequence offsets alpern algorithm time log update priorities insertion number edges dag situation arises algorithm special processed log time collapse collapse cast common initial sequence offsets football twig rep sim ulator ispellli gzipbison- lessfle ksim procedure insertedgedominatortree declare directed graph edge inserted begin insert edge reachable reachable compute set newly reachable vertices mark reachable compute dominator tree subgraph induced source vertex make subtree performing link determine status edges correctly prioritize dag induced forward edges ensuring priorities assigned greater priority insert forward edges compute set edges vertices vertices determine status edges insert forward edges update prioritization possibleaffected increasing order priority common ancestor predecessors idom cut idom link end figure outline algorithm updating dominator tree reducible flowgraph insertion edge graph forward edge coming special case change reachability change reachability status incoming forward edge case remove edge edge forward edge previous prioritization continues correct prioritization updating priorities required non-trivial work updating dominator tree easily determine good approximation set affected vertices deletion edge proposition deletion edge flowgraph remain reachable graph vertex affected deletion edge sibling original dominator tree idom idom original dominator tree proof assume obtain graph graph deleting edge insertion deleted edge back restore dominator tree original form words set affected vertices inserted set affected vertices deleted proposition vertex affected insertion edge sibling dominator tree general case general-case updating algorithm processing deletion edge similar general-case updating algorithm processing edge insertion algorithm performs steps determine set vertices unreachable determine set edges form process set edges essena procedure deleteedgedominatortree declare directed graph edge deleted begin remove edge forward edge remove edge incoming forward edges descendants dominator 
tree mark vertices unreachable set forward edges vertices vertices remove forward edges siblings increasing order priority common ancestor predecessors idom cut idom link end figure outline algorithm updating dominator tree reducible flowgraph deletion edge graph tially working edges deleted graph note set vertices unreachable precisely set vertices dominated set vertices subtree rooted original dominator shape tree analysis set edges generalized path essentially problem set thomas reps edges wisconsin abstract subtree paper concerns method set edges approximating obtained easily traversing subtree deletion shapes edges heap-allocated processed structures program siblings present approximation set approach affected finding vertices solutions shape-analysis problems processed involves previously formulating explained techniques generalized graph-reachability complexity problems edge-deletion reachability procedure problem arises visited log ordinary visited reachability problem approximation transitive set closure affected vertices path considered algorithm connect conclusion vertices paper presented concatenation incremental labels algorithm edges problem maintaining dominator path tree word reducible flowgraph context-free language graph-reachability algorithm approach aware give polynomial problem bounds due carroll running ryder time car algorithm car shape briefly analysis compare permits algorithms obtain argue demand algorithm algorithm shape efficient carroll-ryder analysis algorithm demand algorithm algorithm goal worst-case determine time shape complexity information selectively carroll-ryder algorithm variables worst points case program algorithm presented variable paper point log program time introduction paper number concerns edges method approximating shapes number heap-allocated vertices structures flowgraph program note context typical partial flowgraphs carroll evaluation ryder variations describe method worstcase complexity algorithm variety terms purposes notably carroll mogensen thesis binding-time analysis partially static complexity structures carroll-ryder incremental binding-time algorithm analysis program terms bifurcation rotations shape-analysis problem algorithm originally formulated perform rotations reynolds reynolds worst treated case problem sparse simplifying flowgraphs collection cost set equations rotation worst-case algorithm solving shape-analysis problem maximum repeatedly number applies children reduction step vertex eliminate selection dominator tree operations maximum set degree equations vertex shape-analysis problem control-flow graph augmented formulated representative independently edges years jones height muchnick dominator tree treated problem worst case solving finding fixed-point collection equations regular small tree constant typical flowgraphs grammars obvious regarded worst case dataflow equation number rotations production parameters kind extended regular tree simultaneously achieved grammar showed demonstrates grammars algorithm transformed ordinary worst-case regular tree complexity grammars goal worst-case analysis transformation complexity eliminate expressed productions function represent applicaa current input size characterize complexity incremental algorithms accurately relative merits incremental algorithms established directly work comparing supported worst-case part david lucile complexity packard measures fellowship science linear-time engineering batch algorithm national science constructing foundation dominator grant tree ccrand complexity defense advanced research incremental projects agency algorithm carroll-ryder arpa order incremental monitored algorithm office naval research non-linear contract worst-case complexity -jauthor address incremental computer algorithms sciences arguably batch algorithm thesis carroll presents department experimental results showing wisconsin-madison carroll-ryder dayton algorithm street madison faster almost-linear telephone batch algorithm electronic due mail lengauer reps wisc tarjan tions len selection operations reasons jones-muchnick algorithm algorithm essentially perform equivalent practice algorithm carroll-ryder reynolds algorithm paper present approach carroll-ryder finding algorithm utilizes solution formulate representative edges shape-analysis problem auxiliary information generalized maintaining graph-reachability problem auxiliary information reachability expensive problem time arises space ordinary edge reachability problem flowgraph transitive closure vertex dominates path considered connect vertices representative edge concatenation labels maintained edges terms path dominator word tree flowgraph context-free edge language requires technique representative present edge precise vertex reynolds path lca excluding end-points single edge-deletion sparse flowgraph processed log time algorithm result jones-muchnick introduction techniques reason representative difference precision edges forcing variable carroll-ryder algorithm point program time approximate reason shapes variable carroll-ryder algorithm single restructures shape dominator descriptor tree local reynolds rotation jones-muchnick operations techniques move subtree collection shape descriptors level techniques time dominator tree upward rotation makes vertex child original grandparent downward rotation makes vertex child original siblings contrast algorithm determines dominator vertices imprecise employed mogensen binding-time analysis program bifurcation heintze work set-based analysis problems compared previous work novelty work stems formulation shape-analysis problem generalized graph-reachability problem treating problem gain important benefits general result context-free-language reachability problems solved time cubic number vertices graph cubic bounds cost shape analysis follow immediately lisp-like imperative languages rplaca rplacd jones muchnick paper recursive procedures graph-reachability problem solved time var number vertices program control-flow graph var maximum number variables visible scope lisp-like functional languages reynolds paper graph-reachability problem solved time prog prog size expression tree represents program obtain demand algorithm shapeanalysis problem demand algorithm goal determine shape information selectively variables points program variable point program demand algorithms potential compilers conventional approach compute information program functional languages bound achieved setbased analysis problems generalization shape-analysis problem set-based analysis problems involve solving set constraint equations heintze shown solved time prog nil read cons read nil nil temp car cons temp cdr nil nil temp car cons temp exit start nil read cons read atom temp temp empty cdr figure program control-flow graph equation dependence graph edges equation dependence graph shown labels label points optimization information typically needed program points innermost loops demand algorithms interactive setting context partial evaluation setting tool aid user introduce binding-time improvements selectively restructuring parts program remainder paper organized section discusses shape-analysis problem imperative programs formulated generalized path problem section briefly outlines shapeanalysis problem functional programs formulated generalized path problem section describes so-called magic-sets transformation transformation developed logicprogramming logic-database communities optimizing evaluation recursive horn-clause programs obtain demand algorithm shapeanalysis problem section discusses related work readers familiar magic-sets transformation appendix presents examples illustrate capabilities formulating shape-analysis problem path problem imperative languages section address shape analysis imperative languages support non-destructive manipulation heap-allocated objects assume working imperative language meets general description programs consist assignment statements conditional statements loops repeat read statements write statements goto statements procedure calls parameter-passing mechanism value-result recursion direct indirect permitted language atomic data integer real boolean identifiers lisp-like constructor selector operations nil cons car cdr predicates equal atom null rplaca rplacd operations restriction circular structures created dag structures trees created assume read statement reads atom entire tree dag convenience assume constructor selector performed statement cons car broken statements temp car cons temp assumption essential simplifies presentation small effect state bound time solve shape-analysis problems program shown figure program reads atoms forms list traverses assign reversal remainder form source-vertex equations edge atom read nil nil car car moves subtree move log time link cut operations easily create input modifications processed log time algorithm carroll-ryder algorithm performs rotations rotation requiring time differences approach approach carroll ryder handle graphs unreachable vertices extend definition dominator tree dominator forest cdr decomposition cdr graph collection flowgraphs source vertex vertex reachable source flowgraph belongs collection dominator trees flowgraphs constitute dominator forest graph unique minimal decomposition approach meaningful graph unique minimal decomposition general cons dominator forest cons uniquely defined advantages maintaining dominator forest unclear restricted attention problem maintaining dominator tree reachable vertices finally mention algorithm carroll thesis capable handling simultaneous insertion deletion edges flowgraph algorithm presented paper adapted handle deletion multiple edges insertion multiple edges arbitrary change handled processing deleted edges step processing inserted edges step work required explore algorithm adapted handle insertion deletion edges simultaneously interesting direction future research suggested generalization link-cut tree data structure due cohen tamassia coh coh tree vertex attributes defined terms attributes adjacent vertices cohen tamassia show efficiently maintain attributed tree dynamically attribute equations linear expressions involving operators form semiring algorithm performs link cut operations log time attribute values maintained computed demand logarithmic time carroll ryder show monotonic dataflow analysis problems reduced attribute evaluation problem dominator tree reps rep rep incremental attribute updating algorithm perform incremental dataflow analysis figure dataflow-equation function schemas spaces shape distributive analysis dataflow analysis paper frameworks illustrate form semiring techniques respect function composition collection meet dataflow equations worthwhile introduced exploring capture possibility shapes cohen superset tamassia algorithm terms conjunction points incremental dominator program tree algorithm domain perform shape incremental dataflow descriptors analysis similar aho domain aho trees sethi ullman atoms compilers replaced principles special techniques tools formally addison-wesley domain reading shape set alp selector alpern sequences hoover terminated rosen nil sweeney shape zadeck nil incremental sequence evaluation computational circuits nil represents proceedings root-to-leaf path annual strictly acm-siam speaking symposium shape descriptor discrete algorithms shape san francisco tree jan society industrial selector applied sequences mathematics philadelphia car occur carroll tree ryder jones incremental muchnick data dataflow flow variables update correspond attribute program-point dominator program-variable updates pairs conference record program variable fifteenth acm point symposium principles program programming languages san dataflow diego variable january dataflow equations acm york control-flow car graph carroll edges data flow dataflow update equations dominator attribute edge updates program dissertation variable rutgers equations edge brunswick reflect coh execution actions cohen performed vertex combine conquer dataflow variable dissertation technical approximates report shape cs- department executes computer dataflow-equation science schemas brown shown providence figure procedure calls october coh parameters cohen handled tamassia introducing equations combine dataflow conquer variables technical report actual cs- parameters department dataflow computer variables science brown formal parameters providence reflect april binding cyt cytron occur ferrante procedure rosen called wegman introducing equations zadeck dataflow variables efficient method formal computing out-parameters static single dataflow assignment variables form conference actuals record return site sixteenth acm call-by-valueresult symposium principles handled programming solved languages austin suitable domain jan equations define acm abstract york interpretation cyt program cytron question ferrante domain rosen wegman solved zadeck reynolds jones-muchnick efficiently approach computing static single assignment dataflow form variable control dependence graph acm set trans shapes program lang set syst sets root-to-leaf paths october har join harel operation linear union time functions algorithm cons car finding dominators cdr flow graphs functions related problems shape sets shape proceedings sets symposium cons theory defined cons computing len lengauer tarjan fast algorithm work finding follow dominators mogensen flowgraph acm transactions dataflow programming variable languages single systems shape set july root-to-leaf och paths ochranova finding join operation dominators union functions proceedings cons car foundations cdr computation functions theory shape rep reps shape optimal-time incremental semantic analysis cons syntaxdirected defined editors cons conference record ninth acm symposium principles approaches solutions programming shape-analysis equations languages albuquerque general infinite january practice acm york report rep reps shape teitelbaum information demers characterizes incremental values contextdependent analysis program language-based variable editors acm program trans point program lang syst july sle indirectly sleator terms tarjan values data structure program dynamic variables trees journal program computer system points sciences indirect 
information viewed simplified set equations reynolds paper equivalently regular tree grammar satisfies equations jones muchnick mogensen papers section show desired indirect shape information viewed reachability information obtained solving generalized path problem domain shape place shape involve loss precision feeling kind information lost obtained program fragment cons cons information program-point approaches represented tree grammars cons cons jones muchnick cons mogensen grammar multiple cons right-hand sides nonterminal grammar link branches cons alternatives broken single cons right-hand side formed union set nonterminals arm shape descriptions sharper grammars type grammar nonterminals occur simultaneously children grammar associates nonterminal trees form cons retaining sharper information achieved cost shape analysis context-free-language reachability show shape-analysis information obtained solving path problem path considered connect vertices concatenation labels 
edges path word context-free language definition context-free language alphabet graph edges labeled members path defines word word obtained concatenating order labels edges path path l-path word member define varieties context-free-language reachability problems cflreachability problems all-pairs l-path problem l-transitive closure problem determine pairs vertices exists l-path single-source l-path problem determine vertices exists l-path source iii single-sink l-path problem determine vertices exists l-path target source-target l-path problem determine exists l-path source target determine shape-analysis information solve cfl-reachability problems graph obtained program dataflow equations slight abuse terminology term equation dependence graph defined definition eqng set equations shape-analysis problem control-flow-graph equation dependence graph special vertices atom empty vertex variable eqng edges graph labeled defined shown table form equation labeledge equation dependence graph atom nil empty hdv cons car cdr equation dependence graph running shown figure shape-analysis information determined solving cfl-reachability problems equation dependence graph context-free languages defined context-free grammars path path path path path path path pathl path path path path path path path path nonterminal defined grammar language represents paths balanced matching paths correspond values transmitted execution paths cons operation rise label edge path eventually car cdr operation rules grammar grammar-theoretic analogs mccarthy rules car cons cdr cons language represents paths slightly unbalanced unmatched paths correspond values accessed performing additional car operation extend path additional language represents paths slightly unbalanced case unmatched paths correspond values accessed performing additional cdr operation extending path suppose interested shape program-variable exit statement program shown figure determine information balanced paths speeding slicing thomas reps susan vertex horwitz mooly information sagiv genevieve origin rosay root constituent wisconsin solving single-sink madison problem abstract vertices path lead program vertex slicing fundamental operation manysoftware empty engineering information tools efficient nil algorithm allocated interprocedural slicing execution loop program similarly representation called vertices system path dependence lead graph paper solution single-sink defines newalgorithm -path problem temp atom information atom car originally read finally vertices path lead solution single-sink -path problem empty information tail nil allocated execution loop show information relates information reported shape-analysis methods relationship simple reachability information obtained interpreted regular tree grammar production essentially type mogensen empty cons temp atom slicing system empty putting results dependence -path graphs problems reachability asymptotically information faster interpreted previous type apreliminary experimental information study furnished newalgorithm shape-analysis methods complete picture shapes values program built significantly faster solving practice providing roughly path -fold problems speedup vertices examples equation dependence graph lines instance obtain categories information subject descriptors point software program engineering tools equivalent techniques information programmer gathered workbench mogensen analysis softwareengineering solve programming environments problems softwareengineering vertices distribution equation maintenance dependence enhancement graph restructuring results data structures graphs equivalent general mogensen terms analysis algorithms modulo performance fact additional key words analysis phrases carries dynamic binding-time programming dynamic annotations transitive closure cases flow-sensitive summary desirable solve information program related debugging cfl-reachability program problems dependence graph program context-free grammar determine approximation origin components slicing realizable structure path subordinate introduction program program variable slicing fundamental point operation program manysoftware engineering tools including tools program understanding debugging maintenance testing integration slicing wasfirst defined mark weiser work performed visiting datalogisk institut copenhagen universitetsparken dkcopenhagen east denmark unmatched leave path path ibm israel unmatched path haifaresearch unmatched laboratory path work path unmatched pathl unmatched path path supported part david lucile packard fellowship science engineering national science foundation grants ccrand ccrby defense advanced research projects agencyunder arpaorder monitored office navalresearch contract -jby air force office scientific research grant afosr- grant xerox corporate research authors address computer sciences department univ ofwisconsin west dayton street madison usa electronic mail language represents paths unbalanced unbounded degree arbitrary number unmatched suppose find origin components structure subordinate exit statement program shown figure obtained solving single-sink -path problem vertex reps horwitz sagiv rosay empty wisc gav algorithms temp computing intraand atom things interprocedural slices structure aspects subordinate weiser built interprocedural-slicing constituents algorithm include extra program root components constituent slice variable procedure call program treated likeamultiple assignment cost statement solving cfl-reachability problems general result cfl-reachability problems solved time cubic number vertices graph bound set variables cost shape analysis modified call number set vertices variables equation dependence graph call bounded var call number assumed vertices depend program control-flow graph var maximum number call variables visible lead overly scope conservative shape-analysis slice problem solved includes extra time components var illustrated algorithms figure solving wheneveraprocedure kinds included cflreachability slice problems calls dynamic-programming computations algorithms actual parameters thought included generalizations slice cyk algorithm produces context-free recognition instance recognition problem context-free language formulated overly conservative source-target slice l-path problem giveninfigure linear interprocedural-slicing graph algorithms edges solvethe labeled twoproblems illustrated letters input givenbyhorwitz reps binkley string delay hwang discussion chou solution hwang methods chou section give noanalysis give horn-clause algorithm program scomplexity viewed asweshowinappendix rules worst evaluated case bottom-up time specifies dynamic-programming algorithm algorithm exponential sixteen size program contrast -path problems formulating shape-analysis problem path problem functional languages lisp-like functional languages version shape-analysis problem formulated cflreachability problem rithm languages equation dependence graph essentially expression tree abstract-syntax tree represents program polynomial-time child-to-parent algorithm pointers edges summarized bodies section called operates functions program call representation sites called actual system parameters dependence graph formal sdg parameters algorithm involves twosteps size sdg graph augmented prog summary prog edges number represent transitive vertices dependences due expression tree procedure calls represents program slices computed cfl-reachability problems augmented sdg solved twosteps time algorithm prog contextfree grammars construction graphs arise sdg require time functional polynomial size languages program cost step computing desired summary demand edges algorithm dominates shape cost analysis step section describe obtain demand algorithm version shape-analysis problem demand algorithm goal determine shape information selectively variables points program variable point program cfl-reachability problem solved dynamic-programming algorithm section express algorithm paper horn-clause define program specifically newalgorithm program interprocedural written slicing coral sdgs language asymptotically approach faster important benefit givenbyhorwitz reps trivial binkley obtain inparticular demand present algorithm improvedalgorithm shape-analysis computing problem apply so-called magic-sets transformation general transformation creating efficient summary demand edges versions logic leads programs faster remark interprocedural-slicing approach algorithm presents important challenge applications communicating system results dependence graphs augmented programming-languages community summary edges reasons newalgorithm presented people section programming-languages discusses community asymptotic unfamiliar complexity bottom-up complexity approach newalgorithm evaluating logic compared programs apply horwitz-repsbinkleyalgorithm intuitions section prolog section programs describes experimental evaluated results top-down strategy howmuch programs program precise slice important differences output slice bottom-up weiser top-down salgorithm evaluation procedure strategies main top-down sum goal-directed evaluation strategy call exponential time examples bottom-up sum output sum output end procedure return procedure main call output end procedure return procedure main sum call sum output end procedure return figure program slice respect output slice computed weiser salgorithm program precise slice output slice weiser salgorithm procedure start nil edge main sum edge call add sum edge call add output edge sum output temp end temp procedure add nil return read procedure edge main empty edge call add output edge end procedure add edge return temp procedure temp main sum read call add edge sum call add edge output end procedure add edge atom return edge figure temp program slice respect output slice computed weiser salgorithm slicing algorithm implementations twoalgorithms compute slices programs temp cons edge edge edge edge temp temp cons read edge edge edge ranged size edge lines edge newalgorithm exhibited temp roughly -fold temp speedup read background interprocedural slicing edge system dependence graphs system edge dependence graphs system edge atom dependence graphs edge defined temp due space temp nil edge edge edge limitations give detailed definition edge important temp ideas temp clear examples nil program system nil dependence edge graph sdg collection edge procedure empty dependence graphs edge pdgs edge procedure temp vertices pdg temp represent individual statements nil predicates temp car procedure edge acall statement represented edge call vertexand collection edge actual-in actual-out vertices actual-in edge vertexfor actual temp parameter temp actual-out temp vertexfor car actual parameter cons temp modified edge call similarly procedure edge entry represented edge entry vertex collection formal-in formal-out vertices global variables treated extra parameters give rise additional actual-in actual-out formal-in formal-out vertices edges pdg represent control flowdependences procedure sstatements predicates edge pdgs connected temp form inv sdg call edges represent procedure cons temp calls run cdr call edge vertextoanentry vertex parameterin edge edge temp edge edge temp temp cdr nil edge inv edge edge edge parameter-out temp edges temp represent parameter passing nil exit edge run actual-in vertextothe edge formal-in vertex edge formal-out vertexto defined edge procedure temp dependence graphs temp include kinds dependence edges control loop-independent flow loop-carried flow def-order howev slicing distinction loop-independent loop-carried flowedges irrelevant def-order edges paper assume pdgs include control edges single kind flowedge actual-out vertices figure shows figure base-relation tuples represent equation dependence graph figure evaluation strategy handles polynomial time problems cfl-reachability problem bottom-up evaluation strategy complete prolog top-down evaluation strategy trapped infinite sdg loop program people figure programming-languages point community sdgs unfamiliar magic-sets class transformation program representations represent reasons short tutorial bottom-up evaluation programs magic-sets transformation programming languages kinds provided appendix programming-languages people leery space time conceptual overheads involved similar situation functional programs recursive fibonacci program executed non-memoizing implementation language exponential time iterative program computes fib fib fib bottom-up fashion takes linear time logic databases question logicprogramming approach obtaining demand algorithms static-analysis problems produce implementations efficient real-world programanalysis tools jury issue waiting improved logic-database implementations sense issue irrelevant reasons horn clauses viewed rules evaluated bottom-up thought concise notation expressing dynamic-programming algorithms appendix discussion basic ideas magic-sets transformation propagation queries caching results fairly easy transfer notions demand algorithms written imperative programming language successful application approach found author recent work demand algorithms interprocedural dataflow-analysis problems showed classes interprocedural dataflow-analysis problems posed cflreachability problems magic-sets transformation obtain demand algorithms class interprocedural dataflow-analysis problems subsequently demand algorithm developed implemented easily imperative programming language algorithm viewed analog program results applying magic-sets transformation exhaustive dataflow-analysis algorithm written hornclause program algorithm low-overhead implementation imperative programming language implementation based array indexing linked lists involves term-unification term-matching approach ideas presented paper 
shape-analysis problem equation dependence graph represented base relation consisting facts form edge source target annotation base relation edge module path export path export path export path export path export path export path export path export path export path export path export path export path export unmatched path export unmatched path export unmatched path export unmatched path path edge path edge inv path path edge path edge inv path path edge path path path path edge path path path edge path unmatched path path edge unmatched path unmatched path path edge unmatched path unmatched path path end module figure coral program solve shape-analysis problems problem instance stems imperative program functional program source target represent vertices equation dependence graph coral implementation structure annotation identifiers inv inv figure shows facts represent equation dependence graph figure program figure encodes grammars discussed section viewed rules evaluated bottom-up program specifies dynamic-programming algorithm sixteen cfl-reachability problems involving bottom-up evaluation deduction engine applies immediate-consequence operator fixed point found facts derived case immediate-consequence operator derive additional path facts instance facts indicating presence longer paths graph meet conditions derived facts graph edges previously acquired facts shorter paths fixed-point-finding loop deduction engine serves iterative loop dynamic-programming process export declarations binding patterns queries permitted direct system transform program magic-sets transformation form specialized answering queries binding patterns export declaration export path permits path queries processed argument free argument bound path providing binding patterns relations solve pdgs cflreachability problems sixteen kinds show program results applying magic-sets transformation figure transformed program complicated presenting aid reader understanding table shown figure presents results coral reports shape-information queries program-variable exit statement program shown figure times reported column time answer queries magic-sets transformation depending applied features times constructs column language time running magic-setstransformed experiments version reported tests section carried simple release programming language coral logic-database reader system mind term sun sdg sparcstation model generic sense ram remark results practice thought coral tied system obtain restricted language efficient program examples binding superiority algorithm giveninsection overprevious interprocedural slicing algorithms hold matter features constructs language applied interprocedural slicing ottenstein ottenstein showed intraprocedural slices obtained solving reachability problem edge key control edge flow edge call parameter parameter edge enter main output sumsum output sumin iin sum add call enter add xout yin add call iin xout figure sdg program figure issue howtocreate pdgs sdgs orthogonal issue howtoslice previous work investigated howtobuild dependence graphs features constructs found real-world programming languages forexample previous work addressed arrays parameters pointers nonstructured control flow pdg compute slice respect pdg vertex find pdg vertices path control flowedges interprocedural slices obtained solving reachability problem sdg slices obtained approach include extra components illustrated column figure paths sdg correspond execution paths forexample path sdg shown figure vertexof procedure main labeled sum vertexofmain labeled output howev path corresponds execution procedure add called call site main time user-time returns system-time call seconds site main legalcall return sequence final main independent sum vertexlabeled sum included slice respect vertexlabeled output query result paths exhaustive version sdg demand version computation slice realizable paths paths reflect fact procedure call finishes execution returns site recently executed call definition realizable paths call vertexinsdg givenaunique indexfrom call site label outgoing parameter-in edges incoming parameter-out edges symbols label outgoing call edge apath same-level realizable path iffthe sequence symbols labeling parameter-in parameterout call edges path string language balanced parentheses generated nonterminal matched context-free grammar matched matched matched apath realizable path iffthe sequence symbols labeling parameter-in parameter-out call edges path string language generated nonterminal realizable context-free grammar matched defined realizable realizable matched matched infigure path yin enter add enter main iin xout output sumsum output sumin iin sum add call xout add call key vertex visited pass edge traversed pass vertex visited pass edge traversed pass figure sdg figure augmented summary edges sliced respect path output asimilar goal paths correspond legal empty call return sequences arises context interprocedural dataflow analysis terms paths including valid paths feasible paths realizable paths sum xin sum xin xout sum xout output sum same-level realizable path path sum xin sum xin xout xout output interprocedural-slicing algorithm precise realizable paths 
path givenvertex itdetermines set temp vertices lie realizable path atom entry vertexofthe main procedure toachieve precision augments sdg summary edges asummary edge added actual-in vertex representing actual parameter call actual-out vertex representing actual parameter call wheneverthere asame-levelrealizable path summary edge represents fact call depend call note summary edge computed simply determining path sdg bytaking transitive path closure sdg sedges approach imprecise reason transitive closure leads empty imprecise interprocedural slicing paths sdg realizable paths adding summary edges horwitz-reps-binkley slicing algorithm twopasses overthe augmented sdg pass traverses kinds edges slice sdg respect vertex traversal pass starts backwards target source flowedges control edges call edges summary edges parameter-in edges parameter-out edges traversal pass starts actual-out vertices reached pass backwards flowedges control edges summary edges parameter-out edges call parameter-in edges result interprocedural slice consists set vertices encountered pass pass edges induced vertices figure givesthe sdg figure augmented summary edges shows vertices edges traversed twopasses slicing respect vertexlabeled output unmatched improved path algorithm computing summaryedges section main result paper empty algorithm temp computing summary edges asymptotically faster defined atom horwitz reps binkley henceforth refer hrbsummary algorithm newalgorithm computing summary edges giveninfigure function computesummaryedges computesummaryedges auxiliary access functions function proc returns procedure givensdg vertex function callers returns set procedures call givenone function correspondingactualin correspondingactualout returns actualin actual-out vertexassociated givencall site corresponds givenformal-in formal-out vertex figure illustrates schematically key steps algorithm basic idea find procedure same-levelrealizable paths end formalout vertices paths start formalin vertices induce summary edges actual-in actual-out vertices call sites represent calls forexample algorithm applied sdg shown figure path found formal-in vertexofprocedure add labeled xin tothe formal-out vertexlabeled xout path induce summary edges xin sum sum xout xin xout main asshown figure augmented sdg compute forward interprocedural slice twoedge-traversal passes pass traverses kinds edges inaforward slice edges traversed source target pass forward slice ignores parameterin call edges pass ignores parameter-out edges algorithm same-levelrealizable paths represented path edges edges inserted set called pathedge algorithm starts asserting same-levelrealizable path formalout vertextoitself path edges inserted pathedge worklist algorithm finds newpath edges repeatedly choosing edge worklist extending backwards path represents depending type source vertex illustrated figure path edge processed source formal-in vertex summary edges inserted summaryedge set lines newsummary edges turn induce newpath edges summary edge same-levelrealizable path formal-out vertex same-levelrealizable path procedure propagate called edges lines cost algorithm expressed terms parameters number procedures program sites number call sites procedure sites maximum number call sites anyprocedure totalsites total number call sites program bounded sites maximum number control flowedges anyprocedure spdg params maximum number formal-in vertices anyprocedure spdg algorithm finds same-levelrealizable paths end formal-out vertex anewpath found extending backwards previously discovered path worklist edge vertex out-degree greater path figure discovered results shape-information queries put program-variable worklist due exit test statement propagate program worst shown case figure algorithm pattern extend path pdg rewrite edge recursive lines rules slightly summary reorder edge literals lines non-recursive rules applying formalout vertex magic-sets cost transformation computing summary concerns edges asingle procedure scope equal paper number formal-out point vertices bounded results params reported times figure number pdg variant summary edges rules procedure presented worst figure case appropriately modified asummary edge magic-sets actual-in vertextoevery transformation actualout produce vertexassociated efficient program call site path number path summary path edges procedure unmatched path bounded queries sites params argument free cost computing summary argument edges bound procedure practice bounded params provide coral sites params sets rules equal params relations sites path path params summing path unmatched procedures path program rules total define cost path algorithm bounded path function path computesummaryedges path sdg returns set relation edges previous declare work pathedge summaryedge version worklist set shape-analysis edges problem procedure studied propagate paper edge begin originally introduced pathedge mogensen insert version pathedge insert simpler worklist precise end begin addressed pathedge reynolds summaryedge jones worklist muchnick formaloutvertices terminology insert simpler version pathedge insert problem worklist independent attribute method worklist shape select remove anedge worklist switch case actualoutvertices summaryedge controledges propagate analysis end case reynolds case jones-muchnick formalinvertices version problem callers proc flavor relational method correspondingactualin independent attribute correspondingactualout method dataflow insert variable summaryedge function describes pathedge characteristics propagate values dataflow variable end end relational case method default program point flowedges relation controledges describes relationships propagate hold collection end dataflow case end variables switch return regular summaryedge tree end grammar figure production function cons cons virtual dataflow variables right-hand-side alternatives production express relationship computesummaryedges hold computes returns tuple set summary edges givensystem b-value dependence graph paired figure c-value params totalsites e-value params comparison version previous work shape-analysis cost problem interprocedural slicing relationships algorithm horwitz reps binkleyisdominated cost computing summary edges hrb-summary algorithm totalsites params totalsites sites params main result paper newalgorithm computing summary edges cost bounded params totalsites params reasonable assumption total number call sites program greater number procedures term cost newalgorithm asymptotically smaller term cost hrb-summary algorithm family examples hrb-summary algorithm lost performs totalsites c-e pairing params permitted totalsites sites version params steps shape-analysis problem newalgorithm addressed asymptotically paper faster related twomain differences heintze calls approaches set-based analysis twoalgorithms set-based-analysis lead problems differences generalization costs shape-analysis hrb-summary problem algorithm incorporate creates data compressed form heap-allocated storage sdg functional languages formal-in heintze formal-out shown actual-in actual-out problems vertices solved edges time compressed graph prog represent prog intraprocedural paths size original graph program cost compressing plausible sdg case totalsites imperative params languages term bound cost increase givenabove var newalgorithm bound uncompressed shape-analysis sdg compression number cost vertices compressing program sdg control-flow hrb-summary graph algorithm var repeatedly finds maximum installs number summary edges variables closes visible edge set scope pdg grammars install-andclose steps nonterminals similar path path extend-a-path path steps performed place reduction newalgorithm step difference reynolds eliminating close selections step grammars hrb-summary algorithm similar essentially relation replaces jones -part path muchnick define form order path edge eliminate path productions single path edge selectors algorithm approach replaces -part precise path form edge formulating path shape analysis single path edge cfl-reachability problem approach gain benefits reason bound superiority amount work newalgorithm total cost series install-and-close steps performed hrb-summary algorithm totalsites sites params term cost givenabove term dominant term practice worse factor sites params term newalgorithm scost summarize cost hrb-summary algorithm cost newalgorithm twoterms case term represents cost compression term represents cost finding summary edges compressed graph case terms represent cost finding summary edges uncompressed graph cost newalgorithm asymptotically cost hrb-summary algorithm experimental results section describes results preliminary performance study carried measure howmuch faster interprocedural slicing function computesummaryedges place hrb-summary algorithm slicing algorithms implemented tested asun sparcstation model ram tests carried programs written small language includes scalar variables array variables assignment statements conditional statements output statements loops loops procedures value-result parameter passing recdes recursivedescent parser lists assignment statements calc simple arithmetic calculator format text-formatting program kernighan plauger sbook software tools table givessome statistics sdgs test programs sdg performed statistics falls psites totalsites immediately eparamsprog linesof fact source vertices cfl-reachability control problems flow edges solved time cubic recdes number vertices calc graph format obtain comparison demand section algorithm asymptotic problem worst-case running automatically time encoding hrb-summary algorithm path newalgorithm problems suggests horn-clause newalgorithm programs lead applying significantly magic-sets transformation slicing algorithm cfl-reachability formulas approach asymptotic opens worst-case running possibilities time gathering good shape-related predictors information actual performance making forexample modest formula running shape-analysis time specification computesummaryedges unmatched wasderivedunder path -path worst-case assumptions information gathered asummary edge illustrates actual-in vertextoevery actualout ways vertexassociated flexibility call exploited site related work call pointer site analysis number dataflow-analysis actual-in community actual-out vertices includes work bounded params general yields techniques totalsites reported params asthe bound papers total number method summary edges handle shown destructive-update table operations overestimates actual couple number aspects summary edges work twoorders compared magnitude previous work totalsites make params actual unique number summary edges techniques recdes hendren calc nicolau larus hilfinger based regular languages approach makes context-free languages aspect approach dataflow equations converted graph sense approach builds format single graph asymptotic represent worst-case store analysis equation helpful dependence graph guiding algorithm equation design dependence tests graph indirectly represents needed store determine howwell points slicing algorithm program performs grammars practice forour study weimplemented permit slicing information algorithms individual points algorithm program extracted slicing algorithm equation improvedmethod dependence graph computing summary approaches edges collection section graphs algorithm created essentially point dual algorithm program algorithm likealgorithm previous work computation summary edges 
dataflowanalysis involves problems finding same-level expressed realizable horn paths clauses formal-in instance vertices examples formal-out ullman vertices book paths database theory extended shows forwards logic database backwards table solve intraprocedural reaching-definitions problem assmann shown examined figure variety givesstatistics intraprocedural dataflow-analysis performance problems algorithms assmann expresses representative problems slice kind graph programs grammar points case reported formalism running equivalent time datalog average reps presented fiveexecutions quantity demand time algorithms slice solve user interprocedural cpu-time versions system cpu-time classical gen-kill time dataflow-analysis problems final step live computing variables slices expressions two-pass reaching traversal definitions augmented obtained sdg automatically shown exhaustive separate counterparts entry expressed table horn-clause programs step making small portion magic-sets time transformation reps slice sagiv seconds horwitz total applied cpu-time cfl-reachability techniques recdes interprocedural calc dataflow-analysis seconds problems format shown case columns context-free grammars describe fact execution paths interest table algorithms return edge superior algorithm matching exhibiting call edge -fold -fold call site speedup papers make algorithm appears logic-programming terminology lines exhaustive lines algorithms lines straightforward implementations logic programs demand control algorithms flow edge obtained key applying possibly magic-sets path edge transformation summary edge summary discussed edge section parameter-in low-overhead parameter-out implementation edge path demand edgeo cflreachability lines algorithm problems based magic-sets suitable figure implementation diagrams imperative showhow programming language algorithm figure extends same-levelrealizable paths installs summary developed edges preliminary experimental results implementation reported appendix examples magic-sets transformation appendix present examples illustrate capabilities magic-sets transformation magic-sets transformation attempts algorithm combine algorithm advantages algorithm top-down vertices goal-directed slice hrb evaluation slicingalgorithm strategy summary edges computedby bottom-up algorithm evaluation strategy section summary edges disadvantage computed top-down dual goal-directed algorithm search section time depth-first slice time employed slice speedup prolog time slice speedup incomplete seconds seconds loop overhrb endlessly seconds failing overhrb find number answer percent total answers exist disadvantage recdes top-down goal-directed search calc exponential time examples bottom-up format evaluation figure strategy performance scan handles grammars polynomial algorithms parallel time attribute bottom-up representative evaluation strategy data-parallelism thomas slice starts reps base wisconsin relations abstract programs iteratively marginally paper applies concerns algorithm problem immediate-consequence operator exploit fixed parallelism point procedures phases reached fewer compilation formal-out advantage involving vertices bottomup syntaxdirected formal-in evaluation analysis vertices strategy translation bound complete derivedfor address series problem thought install-andclose essentially exploit steps parallelism dynamic-programming algorithms strategy evaluation values attributes bound smaller derivation subproblems tree hrb-summary algorithm tabulated non-circular attribute factor answer grammar sites params distinguishes item speedup ideas interest factor presented selected greater paper bottom-up larger earlier evaluation programs work strategies parallel preliminary attribute test main evaluation drawbacks hypothesis dynamic gathered data-parallel programming statistics model versions define effort variant programs attribute expended grammars solve called number scan subproblems parameters grammars artificially completely incorporates inflated irrelevant data-parallel adding final attribution additional answer global construct variables introduction great deal examples symbolic space algorithm non-numeric computations exhibited -fold storing involve speedup overthe solutions algorithm irregular subproblems algorithm structures magic-sets exhibited task -fold approach devising -fold based parallel speedup bottom-up algorithms summary evaluation conclusion problems generally program algorithm difficult evaluated presented attempts transformed paper version significantly unsuccessful original paper program addresses specialized answering horwitz-repsbinkleyinterprocedural-slicing class queries algorithm symbolic form supported computational problems transformed comparison program shows asymptotic transformed worst-case rule problems running attached speedups times additional order section literal -fold represents preliminary condition experimental processors characterizing results -fold appendix rule processors demonstration relevant answering queries algorithm topic hwang form concerned chou additional exponential literal narrows exploit hwang-du-chou parallelism range algorithm constructs applicability phases sequence compilation rule slices involving syntax-directed program analysis fire slice translation sequence tasks essentially gains arise permits additional phases obtained levelofrecursion symbol-table magic-sets construction fixed transformation point analysis reached type illustrated checking code elements answering generation reachability included translation queries slice intermediate directed essence representation graphs subsequent processing compute slice edge techniques respect present point base paper relation procedure itisasifthe represents restricted algorithm edges performs programming-language directed sequence translation graph tasks steps listed dynamic-programming replace algorithm call apply procedure reachability problem body computes called transitive closure procedure compute entire slice graph newversion information answers assume reachability flowdependences queries selects unexpanded calls repeat edges steps transitively newvertices closed graph included slice purposes determining emanate newvertexisincluded point slice interest vertexinstance problems expanded posed program translation identified derivation tree originating vertex context-free language original multi-procedure pretty-printing program text logic-programming formatting generation system verification conditions fact bottom-up actual evaluation in-line program strategy expansions annotated performed dynamic-programming assertions algorithm theyare verifying simulated correctness writing stack proofs kth program slice kinds computing mathematical sequence transitive programming closure bound logics depth results edge contribute stack development stack edge parallelized implementations track coral tools system calling context supports domains called magic-sets procedure question transformation addressed realizable additional paths exploit declaration considered export parallelism appendix directs evaluation present system family attributes transform examples derivation program tree form 
hwang-du-chou specialized answering queries argument bound free queries form transformed program results magic edge magic edge query additional fact magic adjoined set transformed rules evaluated bottom-up produce answers query tuples relation magic fact magic read assertion problem finding tuples form arises answering query rules form magic evaluation additional facts added magic relation magic fact generated initial magic illustrate general situation rules transformed program guarded literal magic bottom-up evaluation transformed program visits vertices reachable vertex effect original dynamicprogramming algorithm perform transitive closure entire graph select tuples interest transformed reachability algorithm searches vertices reachable vertex suppose base relation records parenthood relationships tuple parent means parent find cousins person generation person considered same-generation cousin logic-programming system bottom-up evaluation strategy dynamic-programming algorithm writing program generation generation parent generation parent directive export generation directs coral system transform program form specialized answering queries form generation program transformed magic generation magic generation parent generation magic generation generation magic generation parent generation parent query generation additional fact magic generation adjoined set rules evaluated bottom-up unlike previous transformed program produced rule magic generation head magic generation magic generation parent presence rule magic facts original generated evaluation note members relation magic generation ancestors so-called cone bottom-up evaluation transformed rules effect magic generation predicate attention restricted same-generation cousins ancestors note bottom-up evaluation transformed program demand algorithm perform work untransformed program exhaustive algorithm modulo small amount overhead computing magic facts reported small fraction generated facts practice demand algorithm performs work exhaustive algorithm acknowledgements grateful comments helpful suggestions susan horwitz mooly sagiv provided work assmann edge addition rewrite systems relevance program analysis unpublished report gmd forschungsstelle karlsruhe karlsruhe germany bancilhon maier sagiv ullman magic sets strange ways implement logic programs proceedings acm symposium principles database systems cambridge march bancilhon ramakrishnan performance evaluation data intensive logic programs foundations deductive databases logic programming minker morgankaufmann beeri ramakrishnan power magic proceedings sixth acm symposium principles database systems san diego march ceri gottlob tanca wanted datalog dared ieee transactions knowledge data engineering march chase wegman zadeck analysis pointers structures proceedings acm sigplan conference programming language design implementation white plains june acm sigplan notices june cousot cousot abstract interpretation unified lattice model static analysis programs construction approximation fixpoints conference record fourth acm symposium principles programming languages los angeles january acm york duesterwald gupta soffa demand-driven computation interprocedural data flow conference record twenty-second acm symposium principles programming languages san francisco jan acm york heintze set based analysis programs technical report cmu-cs- school computer science carnegie mellon pittsburgh july hendren nicolau parallelizing programs recursive data structures ieee transactions parallel distributed systems january horwitz pfeiffer reps dependence analysis pointer variables proceedings acm sigplan conference programming language design implementation portland june acm sigplan notices july horwitz reps sagiv demand interprocedural dataflow analysis unpublished report comp sci dept univ wisconsin madison march jones muchnick complexity flow analysis inductive assertion synthesis language due dijkstra program flow analysis theory applications muchnick jones prentice-hall englewood cliffs jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications muchnick jones prentice-hall englewood cliffs kasami efficient recognition syntax analysis algorithm context-free languages scientific report afcrl- air force cambridge research laboratory bedford larus hilfinger detecting conflicts structure accesses proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july mccarthy basis mathematical theory computation computer programming formal systems braffort hershberg non-circular north-holland attribute grammar problem addressed distinguishes ideas presented paper earlier work parallel attribute evaluation data-parallelism basic operation work supported part david lucile packard fellowship science engineering national science foundation grant ccrand defense advanced research projects agency arpa order monitored office naval research contract -jauthors address computer sciences department univ wisconsin dayton madison reps wisc data-parallel model scan sequence respect associative operator scan operation called parallel-prefix parallel-suffix scan computes sequence elements partial sums original sequence general sequence associative binary operator left-to-right scan parallel-prefix operation goal compute sequence result applying left-to-right scan operation sequence sequence paper defines variant attribute grammars called scan grammars attributes defined data-parallel fashion scan grammars include scanattribution construct defines scan attribute values located derivation tree leaves scanattribution computes partial sums respect associative operator left-to-right right-to-left pass derivation tree leaves partial sum computed scan left leaf argument attribute equations scan-attribution operation scan-attribution data-parallel construct scan grammars suitable simd machine contrary discussed section good reasons expect parallel scan-grammar evaluator perform mimd machine scan-attribution construct simulated conventional attribute grammar attribute equations threaded left-to-right right-to-left derivation tree create partial sums number sequential attribute evaluators provide sequential implementation scan-grammar evaluator scan-attributions defined terms associative operators scan grammars evaluated efficiently parallel simple left-to-right flow information parallel-evaluation strategy pattern information flow based employed algorithms carrylookahead addition efficient parallel evaluation scan operations section processor production instance derivation tree scan-attribution evaluated parallel steps depth derivation tree fewer processors production instance substantial speedups obtained actual processor simulate actions carried number production instances theorem brent scan-attribution evaluated steps number production instances derivation tree number processors sequential evaluation left-to-right-threaded equations implement scan-attribution requires steps parallel-evaluation bounds steps steps suggest parallel evaluation scan grammars substantially faster sequential evaluation measuring size abstract syntax trees uncontrived pascal programs found ratio -line pascal program -line pascal program ratio programs suggests obtain speedups pascal programs order -fold processors -fold processors -fold processors table presented section quantities increase larger programs previous work parallel attribute evaluation speedups reported pascal attribute grammars modest range tailed rapidly processors numbers suggestive potential approach parallel syntax-directed analysis translation achieving substantial speedups require careful attention number implementation issues issues discussed sections expository purposes paper presents core ideas related scan-attribution simplest form presented paper limitations terms kinds analysis translation problems easily expressed scan-attribution represents important advance creating general attribute-grammar system exploits parallelism section discusses approach creating system combining scan-attributions kinds ordinary attribute equations retaining ability perform attribute evaluation efficiently parallel remainder paper organized section introduces scan grammars means section discusses parallel evaluation algorithm scan grammars based ideas carrylookahead addition algorithm algorithms computing scans quickly parallel section discusses representation lists derived list nonterminals typically context-free grammars section considers important syntax-directed computations arises attribute-grammar specifications construction symbol table shows express computation scanattribution section sketches create general system based scan-attribution paradigm section describes ideas presented paper relate previous work parallel attribute evaluation scan grammars section introduce components scan grammars means simple computation binary numeral attribution rules defined respect set grammar rules define abstract syntax binary numerals giving collection operator operand declarations speedup figures established measuring implemented system simulations notation variant context-free grammars operator names numeral pair bit serve identify productions uniquely declaration numeral numeral bits analogue production numeral bits general notation paper examples adapted notation synthesizer generator widely distributed system based attribute grammars numeral numeral bits bits pair bits bits bit bit bit giving scan grammar attribution rules binary-numeral problem give rules conventional attribute grammar solves problem conventional attribute grammar integer-valued attributes position position define right-to-left pattern information flow derivation tree so-called right-to-left threading bits bit inherited int position synthesized int position attributes determine bit position numeral precisely goal bit position bit position respect end numeral rightmost bit considered position arranged attribute declarations numeral numeral bits position bits pair bits position bits position bits position bits position bits position bits position bit bit position bits position bits position bit position bit bit position bit position bit position bit position position bit numeral bit position bit contribution numeral determined bit synthesized int val bit bit val bit val bit position entire numeral determined summing contributions subtree numeral bits synthesized int val numeral numeral numeral val bits val bits pair bits val bits val bits val bit bits val bit val derivation tree consistently attributed rules attribute numeral val occurs derivation tree root holds corresponds numeral end attribute equations production bits pair bits bits distinguish occurrences nonterminal bits notation bits bits bits bits denotes algorithm leftmost occurrence takes exponential case time order leftmost occurrence simplify presentation left-hand-side occurrence family programs show streamline binary-numeral problem diagrams sdgs scan grammar including solution vertices involves related procedure scan-attributions calls called enter position formal-in formal-out call actual-in directed actual-out right-to-left vertices scan-attribution intraprocedural amsterdam declared transitive dependences mogensen partially static structures self-applicable partial evaluator partial evaluation mixed computation proceedings ifip workshop partial evaluation mixed computation gammel avernaes denmark october bjo rner ershov jones northholland york mogensen separating binding times language specifications fourth international conference functional programming computer architecture london sept acm press york ramakrishnan seshadri srivastava sudarshan coral user manual tutorial introduction coral unpublished documentation computer sciences department wisconsin madison ftp ftp wisc ramakrishnan seshadri srivastava sudarshan coral release software system computer sciences department wisconsin madison ftp ftp wisc reps sagiv horwitz interprocedural dataflow analysis graph reachability datalogisk institut copenhagen copenhagen denmark april world wide web ftp ftp diku diku semantics papers reps demand interprocedural program analysis logic databases applications logic databases ramakrishnan kluwer academic publishers boston reps solving demand versions interprocedural analysis problems proceedings international conference compiler construction edinburgh scotland april lecture notes computer science vol fritzson springer-verlag york reps horwitz sagiv precise interprocedural dataflow analysis graph reachability conference record twenty-second acm symposium principles programming languages san francisco jan acm york reynolds automatic computation data set definitions information processing proceedings ifip congress north-holland york rohmer lescoeur kersit alexander method technique processing recursive axioms deductive databases generation computing ullman principles database knowledge-base systems volume technologies computer science press rockville yannakakis graph-theoretic methods database theory proceedings symposium principles database systems younger recognition parsing context-free languages time information control 

streamlining affect argument showing complete sdgs makeour diagrams unreadable theorem thereisafamily programs whichthe hwang-du-chou algorithm time exponential size program proof weconstruct family programs grows linearly size butcauses hwang-du-chou algorithm time exponential size algorithm srunning time agiv enprogram family consists single recursive procedure named defined procedure call call end present idea construction discuss case sdg program depicted shown labels denote formal-in formal-out actual-in actual-out vertices toenhance readability formal-in actual-in vertices shown ordered right-to-left left-to-right nowconsider slice program respect formal-out vertexfor parameter tocompute slice hwang-du-chou method performs actions equivalent carrying traversal exponentially long path complete binary tree height path traversed shown bold figure examine tree figure closely apparent original slicing problem spawns twoadditional slicing problems similar form twosubsidiary problems involveperforming slices program respect twochildren root tree subsidiary slicing problems equivalent taking slice respect formal-out vertex program general hwang-du-chou algorithm takes exponential time family programs toperform slice respect formal-out vertex algorithm performs actions equivalent traversing exponentially long path apath length complete binary tree height toperform slice respect formal-out vertex algorithm spawns twosubsidiary slicing problems equivalent performing slices respect formal-out vertex program addition twosubsidiary slices additional edges traversed time complexity hwang-du-chou algorithm recurrence relation direction type acknowledgement associative recdes operation calc programs seed supplied tommy hoffner declaration linko scan ping position int int defines scan-attribution named position agrawal right-to-left slicing programs scan-attribution jump maps statements sequence int proceedings acm sequence sigplan int conference programming language design implementation orlando june acm sigplan notices june ball horwitz slicing programs arbitrary control flow proceedings international workshop automated algorithmic debugging linko ping sweden addition function seed declaration creates attributes leaf denoted position input position output leaf derivation tree position output partial sum right-to-left scan respect addition function sequence formed position input attributes lecturenotes derivation computer tree science leaves springer-verlag stress newyork input output bannerjee sequences speedup conceptual ordinary objects programs dissertation distributed leaves tech rep derivation tree dept computer science materialized illinois urbana explicit data october structure bates horwitz goal incremental program testing bit position output program dependence bit graphs position respect conference recordofthe twentieth acm symposium end principles numeral programming bit languages position output charleston attributes january serve acm function newyork bit position binkley attributes multi-procedure program conventional attribute integration grammar dissertation earlier tech rep instance trcomputer bit sciences nonterminal department wisconsin bit position input madison august easily binkley arranged 
attribution equations bit bit position input bit position input entire numeral defined declaring right-to-left scan forms partial sums individual bits contributions scan int int bit bit input bit input bit position output rules illustrate results scanattribution values bit position output attributes creating input scan-attribution role bit output bit val conventional attribute grammar earlier bit output attribute defined rules represents numeral left prefix numeral leaf discarded remark tempting simplify rules left-to-right scan-attribution declaration scan int int bit bit input bit input scan-attribution declaration function associative operation clear discussion scan operations section associativity property crucial importance scans evaluated efficiently parallel associativity freedom re-group operations freedom makes scan-attribution amenable parallel processing scan-attributions non-associative operators well-defined evaluator work left-to-right right-to-left sequential order require steps number production instances derivation tree steps end remark returning closer inspection reveals scan grammar equivalent conventional attribute grammar earlier scan grammar numeral found leftmost leaf derivation tree derivation tree root case conventional attribute grammar easily rectified permitting interior nodes play role scan-attributions directly conceptually interior node arity-k leaves left leftmost child rightmost child pair consecutive children declaration numeral numeral bits numeral node semantic differencing reduce cost regression testing proceedings conference softwaremaintenance orlando flori november binkley interprocedural constant propagation dependence graphs data-flowmodel proceedings international conference compiler construction edinburgh april lecturenotes computer science figure compute same-levelslice respect hwang-du-chou algorithm traverses path highlighted bold fritzson springer-verlag newyork chase wegman zadeck analysis pointers structures proceedings acm sigplan conference programming language design implementation white plains june acm sigplan notices june choi ferrante static slicing presence goto statements acmlettersonpro graming languagesand systems gallagher lyle program slicing software maintenance ieee transactions softwareengineering august goff kennedy tseng practical dependence testing proceedings acm sigplan conference programming language design implementation toronto ontario june acm sigplan notices june horwitz pfeiffer reps dependence analysis pointer variables proceedings acm sigplan conference programming language design implementation portland june acm sigplan notices july horwitz prins reps integrating non-interfering versions programs acmtrans program lang syst july horwitz reps binkley interprocedural slicing dependence graphs acmtrans program lang syst january horwitz identifying semantic textual differences twoversions program proceedings acm sigplan conference programming language design implementation white plains june acm sigplan notices june hwang chou finding program slices recursive procedures inproceedings ieee compsac chicago oct ieee computer society washington kernighan plauger softwaretools pascal addisonwesley reading lakhotia constructing call multigraphs dependence graphs conference recordofthe twentieth acm symposium principles programming languages charleston jan acm newyork landi ryder pointer-induced aliasing problem classification conference recordofthe eighteenth acm symposium principles programming languages orlando january acm newyork larus hilfinger detecting conflicts structure accesses proceedings acm sigplan conference programming language design implementation atlanta june acm sigplan notices july maydan hennessy lam efficient exact data dependence analysis proceedings acm sigplan conference programming language design implementation toronto ontario june acm sigplan notices june ottenstein ottenstein program dependence graph software development environment proceedings acmsigsoft sigplan softwareengineering symposium practical softwaredevelopment environments pittsburgh apr acm sigplan notices pugh omega test fast pratical integer programming algorithm dependence analysis insupercomputing november pugh wonnacott eliminating false data dependences omega test proceedings acm sigplan conference programming language design implementation san francisco june acm sigplan notices july sharir pnueli approaches interprocedural data flowanalysis programflow analysis theory applications muchnick jones prentice-hall englewood cliffs weiser program slicing ieee transactions softwareengineering sepp july wolfe optimizing supercompilers supercomputers dissertation tech rep dept computer science illinois urbana october 
conceptual leaves denoted numeral left numeral notation rules attribute numeral val receives corresponds numeral numeral synthesized int val numeral numeral bits numeral position input numeral input numeral val numeral output make notation examples section important note makes integer data type operation wide variety data types operations scan-attributions including booleans integers max min floating-point numbers max min sequences lists append sets finite functions section evaluation scan grammars sequential implementation scan-attribution straightforward compile scan-attributions conventional attribute-grammar specifications evaluated number sequential evaluators scan-attribution construct translated left-to-right right-to-left attribute threading creates partial sums instance binary-numeral position scan compile essentially set right-to-left-threaded attribute equations attributes position position description binary-numeral handled conventional attribute grammar scan translated right-toleft threading bits bit inherited int synthesized int numeral synthesized int val numeral numeral bits numeral val bits bits pair bits bits bits bits bits bits bit bit bits bits bit bit bit bit bit bit position bit parallel implementation scan-attribution scan-attributions defined terms associative operators evaluated efficiently parallel pattern information flow parallel evaluation algorithm based employed algorithm efficient parallel evaluation scan operations carry-lookahead addition scan operation respect associative operator performed sequence length log steps decomposing problem subproblems arranging subproblems balanced binary tree depth log processing element assigned leaf interior node decomposition tree blelloch explanation pattern information flow parallel implementation left-to-right scan technique consists sweeps tree sweep sweep values scanned start leaves tree sweep unit executes children units passes sum parent unit copy left child memory sweep unit passes left child parent passes child applied parent stored memory originally left child sweep values leaves results scan problem-decomposition tree balanced binary tree scan computation carried parallel fixed-arity tree represents decomposition problem steps depth decomposition tree information flow sweeps expressed attribution decomposition tree rules attribute grammar scan-evaluation algorithm evaluate scanattribution parallel step translate scanattribution construct set attribute equations special form illustrate translation means slight technical difference defined scan sequence blelloch defines add leaf retain copy original apply received parent original suppose associative operation type left-to-right scan-attribution form scan foo root root pair singleton leaf foo input scan-attribution translated automatically equations sweep synthesized foo pair foo foo foo singleton foo foo leaf foo sweep inherited foo root root foo pair foo foo foo foo foo singleton foo foo foo dependences attributes production pair depicted foo foo foo foo foo foo equations scan form show translation scan form produces right-to-left scans binarynumeral position scan translated attribute equations scan form sweep bits bit synthesized int position bits pair bits position bits position bits position bit bits position bit position bit bit position bit position sweep bits bit inherited int position numeral numeral bits position bits pair bits position bits position bits position bits position bits position bit bit position bit position bits position scan translated sweep bits bit synthesized int bits pair bits bits bits bit bits bit bit bit bit bit position sweep bits bit inherited int numeral numeral bits bits pair bits bits bits bits bits bit bit bit bits equations scan form obvious parallel algorithm evaluating processor production instance processor evaluate tree attributes accordance method quoted means scan-attribution evaluated parallel steps depth derivation tree processors number production instances derivation tree actual processor simulate actions carried number production instances scheduling technique simulation theorem brent scan-attribution evaluated steps feel means abstract syntax trees actual programs measured uncontrived pascal programs format simple text-formatting program kernighan plauger book gradestats grading program obtained colleague figure presents figures steps speedup efficiency function number processors programs figure shows obtain speedups pascal programs order -fold processors -fold processors -fold processors measurements reported figure trees defined pascal attribute grammar distributed synthesizer generator system generating language-sensitive editors numbers figure reflect adjustments raw figures synthesizer generator right-recursive productions represent lists derived list nonterminals figure depth adjusted reflect tree depths lists represented balanced binary trees section atomic leaves synthesizer generator trees generally attributes formula calculating steps number atomic leaves subtracted nodes formula calculating steps depth decreased level atomic leaves root production define parallel scangrammar evaluation algorithm based underlying idea evaluation attributes sweep pipelined evaluation carried differentially suppose operation respect scan performed identity element allocate processor production instance attribute scan scan-form equations initially assigned sweep carried normal fashion sweep processor charge evaluating attribute instances child foo child foo information parent foo form change parent foo received processor parent node derivation tree current values child foo child foo updated making assignments child foo child foo child foo child foo passed derivation tree processors child nodes left-to-right scan pipelining process initiated setting values tree collection child foo attributes making assignments child foo child foo method information passed neighboring processor attribute steadily accumulates information flows parent foo attribute passing information derivation tree pipelined attribute final determined received information collection attributes path attribute tree node root tree remark pipelined version evaluation algorithm attribute steadily accumulates information flows sweep attribute parent node derivation tree unusual feature attribute-evaluation algorithm examples algorithms previous work final attribute accumulates previous values differential algorithm hoover teitelbaum incremental updating aggregate-valued attributes languagesensitive editors attribute 
times updating compensate evaluator imprecise information ordering dependences attributes algorithm sequential processor multiple evaluation attribute instances desirable characteristic algorithm hurt algorithm performance practice examples evaluation algorithms final attribute accumulated previous values algorithms proposed evaluating circular attribute grammars end remark program format program gradestats lines lines nodes nodes atomic leaves atomic leaves depth depth steps speedup efficiency steps speedup efficiency 
steps nodes atomic leaves depth speedup steps steps efficiency speedup figure steps speedup efficiency function number processors pascal programs representation lists derived list nonterminals section discuss representation lists derived list nonterminals typically context-free grammars programminglanguage grammar number list nonterminals stmtlist explist idlist abstract syntax trees programming languages ways represent lists derived list nonterminals nodes fixed-arity recall algorithm efficient parallel evaluation scan operations calls fixed-arity problem-decomposition tree right-recursive productions stmtlist stmt stmtlist stmtlist stmt stmt case processors parallel scan-grammar evaluation algorithm requires steps depth tree lists represented right-recursive productions list length depth representation detrimental performance evaluation algorithm standpoint replace rightrecursive productions ambiguous binary productions represent lists balanced binary trees stmtlist stmtlist stmtlist stmtlist stmt stmt representation lists reduce depth tree list length depth log determine gained balanced binary trees represent lists gathered statistics depths pascal abstract syntax trees measurements trees defined pascal attribute grammar distributed synthesizer generator synthesizer generator right-recursive productions represent lists depth counts adjusted reflect depth tree balanced binary trees figure presents statistics obtained column labeled depth tree depth adjustment adjusted depth adjusted figure algorithm efficient parallel evaluation scan operations requires steps larger examples show balanced-binary-tree representation factor processors factor increase larger programs figure figures reflect balanced-binary-tree representation symbol-table construction scan-attribution important syntax-directed computations arises attribute-grammar specifications symboltable construction attribute grammars static semantics programming languages build symbol tables map identifiers descriptor scope binding information starting point analysis detection undeclared multiply declared variables type checking node derivation tree annotated pointer data structure records identifiers current scope properties program description lines nodes atomic leaves depth adjusted depth empty empty template program primes sieve eratosthenes queens eight-queens problem format kernighan plauger gradestats grading program nodes number production instances tree atomic leaves number leaves consisting primitive types int char str depth right-recursive combs represent lists xlist xlist adjusted depth balanced binary trees represent lists xlist xlist figure sizes representative pascal abstract syntax trees column labeled adjusted depth upper bound depth tree obtained replacing list balanced binary tree paper term symbol table broader sense purposes symbol table finite function function defined finite set argument values text-formatting grammar make symbol table consisting current formatting properties ideas apply finite function section show symbol-table processing expressed scan-attribution construct scan-attribution respect associative operator key observation basic operation building symbol tables implementation associative associativity freedom re-group symbol-table construction operations make symbol-table construction amenable parallel processing section examples deal simple imperative language abstract syntax defined program program decllist stmtlist decllist decllistpair decllist decllist decllistsingleton decl decl decl type type undefined boolean integer stmtlist stmtlistpair stmtlist stmtlist stmtlistsingleton stmt stmt assignment exp conditional exp stmtlist stmtlist whileloop exp stmtlist exp idexp symbol tables language finite functions identifiers types env type domain types distinguished undefined env undefined undefined presentation initially address case single global scope extend approach cover case nested scopes finally address important performance issue symbol-table attributes unit-sized objects afford overhead shipping copies values processor processor methods avoid potential overhead presented section scan-attribution single global scope single global scope straightforward scan-attribution annotation derivation tree symbol-table values section fix representation symbol tables domain env treat abstract fashion define operations env denoted creates symbol table defined single point denoted combines symbol tables precisely operations behave undefined undefined denote everywhere-undefined environment undefined easy associative identity element notation express symbol-table construction scan-attribution construct symbol-table construction simple programming language expressed left-to-right scan declaration contributing symbol table defined single point scan symbol table env env decl decl decl symbol table input type stmt assignment stmt symbol table input exp idexp exp symbol table input note identifier statement expression contributes symbol table consequence symbol table output point tree employed access symbol-table information identifier point program stmt assignment stmt lhs info stmt symbol table output exp idexp exp info exp symbol table output similarly detect duplicate declarations change specification decl contributes symbol tables type decl decl decl symbol table input decl symbol table input type decl info decl symbol table output decl symbol table output equal undefined occurrence duplicate declaration scan-attribution nested scopes nested scopes scan-attribution annotation derivation tree symbol-table values section convenient fix concrete representation symbol tables lisp-like lists elements form cons type cons cons integer cons cons boolean nil symbol table representation concrete representation operation append append function appends lists identity element nil note express symbol-table construction case single global scope slightly scan symbol table env env append nil decl decl decl symbol table input cons cons type nil stmt assignment stmt symbol table input nil exp idexp exp symbol table input nil model nested scopes extend abstract-syntax declarations language block construct stmt block decllist stmtlist introduce markers denoted block entry block exit symbol-table lists bracket scopes exited lookup function ignores symbol-table entries block entry encountered matching block exit found block entry block exit scan-attribution equations block stmt block stmt symbol table input cons block exit nil stmt symbol table input cons block entry nil drawback approach symbol table node derivation tree symbol-table entries declarations left node including declarations scopes active application lookup function identifier efficient find symbol-table entry local scope symbol-table list include entries declarations enclosing scopes arranged filtering symbol-table lists removing symbol-table information matching block entry block exit pair permissible information matching block entry block exit pair lookup function attribute grammar language filtering sweep equations symbol-table scan remark technically change meaning scan operation slightly sequence associative binary operator goal compute sequence means equal observable case symbol-table lists means equal observable lookup function end remark pragmatic performance considerations symbol-table attributes unit-sized objects performance parallel scan-grammar evaluator degrade theoretical speedup substantial amounts symboltable information passed processor processor amount symbol-table information passed processors important pragmatic issue solve problem manner symbol-table data accessed note symbol-table construction carried evaluation symbol table scan-attribution symbol-table attributes accessed order perform lookups semantics attribute grammars 
side effects permitted attribute equations symbol-table construction phase involves memory write-once fashion lookup operations carried virtual processor node derivation tree accesses symbol table read-only fashion key aspects reducing cost communicating symbol-table values processor processor multiprocessor provide shared-memory abstraction handle symbol table represented small pointer location shared memory access symbol-table entry accesses shared memory approaches provide shared memory multiprocessors software shared virtual memory loosely coupled multiprocessors hardware snooping caches directory protocols case single global scope implement symbol table satisfies conditions balanced tree tree b-tree avl tree updated applicatively spine tree copied insertion structures information passed explicitly processor processor symbol-table construction scan pointer root tree symbol-table entry symbol table size accessed log shared memory handle nested scopes list balanced trees information passed explicitly processor processor symbol-table construction scan pointer case root list combining scan-attribution processing patterns examples previous sections show syntax-directed analyses conveniently scan-attributions scan-attributions constrained associative operators limitations kinds analysis translation problems easily expressed scan-attribution represents important advance creating general attribute-grammar system exploits parallelism approach creating general system based scan-attribution paradigm exploit fact sets ordinary attribute equations dependence patterns evaluated parallel steps sufficient number processors attributes combined scanattributions efficient parallel attribute evaluation examples dependence patterns include purely local attribution phases attribute instances production instance values purely bottom-up attribution phases information flows leaves root purely top-down attribution phases information flows root leaves represent lists derived list nonterminals balanced binary trees impose restrictions right-hand-side functions attribute equations productions rules bottom-up pass right-hand-side functions associative rules top-down pass right-hand-side functions idempotent addition function pass information left child function pass information child commute reasons restrictions imposed suppose attribute grammar definitions xlist synthesized foo inherited bar xlist xlist xlist xlist foo xlist foo xlist foo xlist bar xlist bar xlist bar xlist bar operation associative guarantee xlist foo attribute root equal xlist foo attribute associativity attribution lists represented balanced binary trees uniquely defined similarly functions idempotent commute guarantee xlist bar attributes leaves equal xlist bar attributes leaves effect restrictions values xlist bar attribute xlist xlist bar root list xlist bar leftmost member list rightmost member list values members list dependence patterns listed evaluation carried parallel steps assuming processors number production instances derivation tree processors evaluated steps attribute equations dependence patterns combined scan-attributions evaluation carried sequence parallel-evaluation passes tree pass requires steps steps total cost parallel evaluation question efficient parallel evaluator handles combination scanattributions ordinary attribute equations dependence patterns classes listed left future work pragmatic standpoint conjecture problems arise practice scan-attributions patterns suffice relation previous work work parallel attribute evaluation includes kaplan kaiser present distributed evaluator problem incremental attribute updating language-sensitive editors boehm zwaenepoel describe implemented parallel attribute-grammar evaluator runs network multiprocessor sunworkstations connected ethernet network zaring presents parallel algorithms ordered attribute grammars zaring algorithms tightly coupled loosely coupled multiprocessor architectures approach presented paper previous approaches respects focus attribute specifications employ data-parallel construct essence technique exploit associativity freedom re-group computation making amenable parallel processing kuiper work closer spirit makes attribute-grammar transformation restructure computations transformation applicable attribute equations transformed attribute grammar computation equivalent original attribute equations derivation tree dependence chains shorter increases amount potential parallelism kuiper transformation modifies attribute equations leaving underlying context-free grammar derivation trees unchanged kuiper transformation applies types threadings lists defined right-recursive combs production form xlist xlist list length transforms dependence graph threading chain length chains length case construction symbol-table attribute thread running list declarations kuiper transformation applies due fact listconcatenation operation construction symbol table associative operator key difference work kuiper important kind attribute computation kuiper transformation exploit associativity property fullest transformation powerful idea introduced paper calls transforming derivation tree attribute equations technique right-recursive comb transformed balanced binary tree original dependence chain length replaced dependence graph length longest path log klaiber gokhale make attributegrammar transformation restructure computations case list-flattening transformation work spirit zaring work deals parallel evaluation plans kastens class ordered attribute grammars klaiber gokhale work similar goals couched terms katayama translation attribute grammars mututally recursive procedures klaiber gokhale address problem determining calls evaluation procedures scheduled parallel list-flattening transformation normalization step uncover additional parallelization opportunities scheduling algorithm acknowledgements susan horwitz provided comments helpful suggestions paper prepared agarwal simoni horowitz hennessy evaluation directory schemes cache coherence proceedings fifteenth annual international symposium computer architecture honolulu hawaii june june aho sethi ullman compilers principles techniques tools addison-wesley reading archibald baer cache coherence protocols evaluation multiprocessor simulation model acm trans computer systems november babich jazayeri method attributes data flow analysis part exhaustive analysis acta informatica october blelloch vector models data-parallel computing press cambridge boehm zwaenepoel parallel attribute grammar evaluation proceedings seventh international conference distributed computing systems berlin germany popescu-zeletin lelann kim ieee computer society washington september brent parallel evaluation general arithmetic expressions acm cormen leiserson rivest introduction algorithms press cambridge farrow automatic generation fixed-point-finding evaluators circular well-defined attribute grammars proceedings sigplan symposium compiler construction palo alto june acm sigplan notices july hoover teitelbaum efficient incremental evaluation aggregate values attribute grammars proceedings sigplan symposium compiler construction palo alto june acm sigplan notices july jones simon hierarchical vlsi design systems based attribute grammars conference record thirteenth acm symposium principles programming languages petersburg jan acm york jones efficient evaluation circular attribute grammars acm trans program lang syst july kaplan kaiser incremental attribute evaluation distributed language-based editors proceedings acm symposium principles distributed computing kastens ordered attribute grammars acta informatica katayama translation attribute grammars procedures acm trans program lang syst july kernighan plauger software tools pascal addison-wesley reading klaiber gokhale parallel evaluation attribute grammars ieee transactions parallel distributed systems march knuth semantics context-free languages math syst theory june kuiper parallel attribute evaluation dissertation dept computer science utrecht utrecht netherlands leighton introduction parallel algorithms architectures arrays trees hypercubes morgan kaufmann publishers san mateo hudak memory coherence shared virtual memory systems acm transactions computer systems november myers efficient applicative data types conference record eleventh acm symposium principles programming languages salt lake city jan acm york ofman algorithmic complexity discrete functions soviet physics doklady english translation reps teitelbaum demers incremental context-dependent analysis language-based editors acm trans program lang syst july reps teitelbaum synthesizer generator system constructing language-based editors springerverlag york skedzeleski definition attribute reevaluation attributed grammars dissertation 
tech rep trcomputer sciences department wisconsin madison october waite goos compiler construction springer-verlag york zaring parallel evaluation attribute grammar based systems dissertation tech rep dept computer science cornell ithaca august 
gfed abc gfed abc gfed abc gfed abc gfed abc gfed abc cactcrctd crddb btcqd cpcrd cxd cud ctcpd btd crcpd ctcs cbd cpcvct bzd cvd bucpd cpczd cxd cwd cpd cpd cccwd cpd cactd bvd cbcrcxba bwctd bab cdd cxdactd cxd cfcxd crd cxd cucqcvd cvd ctd cvbscrd badbcxd crbactcsd btcqd cpcrd cwcxd cpd ctd dbct ctd ctd cpd cpcqd cpcrd cxd cud cwctcpd cpd crcpd ctcs cpcvctb crcpd ctcs cwct ctcrctd crddb cpcqd cpcrd cxd cwcpd cpd dbd cpcqd cpcrd cxd ctd ctd cpd cxd cpd cvd cxd cwd ctcrd dactd cxdacxcpd cxd cud cpd cxd cud cwctcpd cpd crcpd ctcs cscpd cqcyctcrd btd cpd cpd cxcrcpd cxd cwct ctcrctd crddb cpcqd cpcrd cxd dbct cwd cwd cxd crcpd ctd dact dacxd cpd cud crd cxd crcpd cxd cxd ctcs ctdcctcrd cpcqd ctd cxbactbab ctdcctcrd cpcqd ctd cud dbcwcxcrcw csctcqd cvcvcxd cxd cud cpd cxd cwcpd cqctctd ctd dactcsb csd crd cxd cvd ctcpd csctcpd dbd cwcpd cqctctd csd cpd cvd cxd cwd cud add dbb cxd ctd cxd cxdact cxd cpd cpd ddd cxd cjbdb bebgb bjcl cxd crd cscxd cpd cvd cxd cwd cwcpd ctdccwcxcqcxd dacpd ddcxd csctcvd ctctd crd ctdcd ctd cxd cxdacxd cjblb bib bdbcb bebhclb dbctdactd cpd cwct cpcud ctd ctd cxd ctcs dbd ctd dactd cxd cpcqd cpcrd cxd cwctcpd cpd crcpd ctcs cpcvctb dbcwcxcrcw dbct crcpd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cjbdbjb bgclbm btd cwct csctd cpd crcpd ctcs cpd cvcxdactd cpd crcpd cxd cxd cpd cud csctcs cvctd cwctd cxd cxd cvd cpd csct ctd ctcrcxd cxd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd crcpd cud ctd csd crct cpd cxd cxd cud cpd cxd cqctcrcpd cxd csd ctd cpd cscpd ctd cqct ctd cud ctcsba cscpd dactd dbd cxd ctd cwct crd ctd cpd cpcqd cpcrd cqcyctcrd cpd ctd ctd ctd csctacd cxd crcwcpd cvct cxd dacpd cpd crd crd ctd cqcyctcrd cwcpd cwct cpcqd cpcrd cqcyctcrd ctd ctb ctd cjbgb bebeclba cbd cscpd ctd crcpd cvctd ctd cpd cqct ctd cud ctcs cpd cqcyctcrd cqctcrcpd crd crd ctd ctb cscpd cpd cpabctcrd cwct cpd cxdectcs crd crd ctd cqcyctcrd cpd crcpd cxd cxd cxd cxd cxd cud crd cxd cwcpd cxd crcpd ctcs cwcpd crctb cwctd crcpd cpd crcpd cxd csctd dbcxd cscxabctd ctd cpcscsd ctd ctd cxd cucpcrd ckd cxd ctcpd cwcpd cvd cpd dacpd cxcpcqd cpdd cxd cwct csctd cwcpd ctd ctd ctd byd cpd cpd cxcvd ctd cwct cud bqd ctd ctcrd cxd cpd cpd ddd cxd cpd cvd cxd cwd cpd cscxd cpd cxd cud crctcs ctd cud dbctcpcz cscpd ctbm cwcpd cxd ctd ctcrd ctcscvctd ctd cpd cpd cxd cud cwct csctd cwcpd cxd cpd cpcrcrd cpd ctcsbn cwct cpcqd cpcrd ctdcctcrd cxd cpd cpd cxcvd ctd acctd cpd csct crcpd czcxd cwct ctabctcrd ctdacxd cpd cxcvd ctd cqctcrcpd ctb cxd cvctd ctd cpd cwct csctd cwcpd ctd ctd ctd cxd cscpd ctcs ctcpcrcw crd crd ctd ctdcctcrd cxd cwct cpd cxcvd ctd cpd ctd ctd buctcrcpd cxd ctcrcxd cxd dbcqcpd cpd cpcscscxd cxd cpd dbctcpcz cscpd ctd cpd ctd cud ctcs ctbacvbab cud cpd cxcvd ctd cwct cud bqd ctd ctcrd bqd ctd ctcrd beb cwct dbctcpcz cscpd ctd cwcpd cpcsdactd ctctabctcrd dbcwcpd cxd cpd cpd ddd cxd cpd cvd cxd cwd crcpd csctd ctd cxd cpcqd cwct ctd cxctd cwctcpd cpd crcpd ctcs cscpd crd ctd ccd cxd cxcvcpd cwct ctabctcrd dbctcpcz cscpd ctd cpd cxd ctd cpd cpd ddd cxd cpd cvd cxd cwd cxd cwct cxd ctd cpd cxcsctb ctd cwct cxd csd ctd byd cxd cpd crctb dbcwctd ctd cud cxd add dbb ctd cxd cxdact cxd ctd cpd cpd ddd cxd cwct cxd cxd cxcpd cxd ctd cud ctcpcrcw cxd ctd dacpd cxcpcqd cxd cpd ctcs cqct cpd cwctd cwcpd bqb byd crcpd dacpd cxcpcqd ctd cpd cpd crb cxd dacpd cxb cpcqd ctd cwct cpd cxd cwcpd cwct cxd cxd cxcpd dacpd cxd cxd cpcuct ctdgcxd csd ctd dactd cpd dccxd cpd cpd cwct cvd cpd cqctcwcpdacxd cccwct cvd cpd cwd dbd cxd bycxcvba cxd cpd ctd cwcxd cxd ctba bycxcvba bdb cpb cxd cxd cxd cxcpd cxdectcs cpd cpd cwd ctcpcscxd dad cxcs cud cxd cpbn dbcwcxd ctb bababab cxd cpd crb cxdectd cub cxd cxcub bababab cpbn ctd bbbb cxd cxd cxcpd cxdecpd cxd bdbcbn dad cxcs cud cxd cpbn dbcwcxd ctb bababab cxd cpd crb cxdectd cub cxd cxcub bababab cpbn ctd cqbn bdbcbn cpb cqb bycxcvbabdba cfctcpcz cscpd cqd ctd cud cpd cqd crczd ckb bdbcayb dbcwctd ctcpd cxd bycxcvba bdb cqb cxd cxd cxd cxcpd cxdectcs cpd cpd cwd ctcpcscxd ckb bdbcayba cxd ctd cpd cpd ddd cxd cpd cvd cxd cwd cwcpd cpczctd cwct cpcuct cpd cxd ctd cxd ctcs cpcqd dact dbcxd cqct cpcqd csctd ctcrd cwcpd cwct cpd crb cqd crcz cxd ctcs cqdd cxd cxb cqd cxd cxd cxcpd cxdectcs cpd cwct csctd ctcuctd ctd crct byd bycxcvba bdb cqb cwct cpd cvd cxd cwd crd crd csctd crd ctcrd cwcpd ckb bdbcay cscxacctd ctcxd cwctd cqba bud cud bycxcvba bdb cpb cwct cpd cvd cxd cwd crd crd csctd cxd crd ctcrd cwcpd ckb bdbcay cscxacctd cpb dbcwcxcrcw cxd csba cwct cwctd cwcpd csb cpd cxd cwcpd cwct cpd crb cqd crcz crcpd cxd cpd dacpd cxcpcqd cxd ctcscxcpd ctd cpcud ctd cwct crcpd cpd ctcpcsd cqd cxd ctcrcxd cxd ctd cxd cqd dactd cxd cwct cvd cpd cxd bycxcvba bdba cccwct cqd ctd cxd cpd cud dbd cfcwctd cwct cxd ctd cpd cpd ddd cxd cpd cvd cxd cwd cxd ctd ctd cpd ctd ctd ckb cpay cpd ckb cqayb cxd ctd cud dbctcpcz cscpd ctba buctcrcpd cxd cpd ctcs cxd cpd dacpd cxcpcqd ctb csd cxd dbctcpcz cscpd csd ctd cxd dact cwct cxd ctd cud cccwctd ctcud ctb cwct cpd cvd cxd cwd crd crd csctd cwcpd ckb bdbcay cpdd cscxcudd cpd dacpd cxcpcqd cxd cwct cvd cpd bxdactd cwct cxd cpd csctd ctd cpd crcpd cxd cxd ctb dbcwctd ctcpcrcw cpd csct cxd cpd cxacctcs cqdd cpd crcpd cxd crd ctdcd cpd cxd cjbdblb bdbfclb csd ctd dactd crd cwct 
cqd ctd cwcpd cxd cpd cvd cxd cwd crcw cpd cjbdblb bdbfcl cxd ctd cud dbctcpcz cscpd ctd btd cwct cwctd ctdcd ctd cxd cucpd cxd cwctcpd cpcqd cpcrd cxd cwcpd cwcpdact cqctctd cxd csd crctcs cscxd crd dactd cxd cud cpd cxd cpcqd cwct cxcqd cwcpd ctd cwct cwctcpd cpd crcpd ctcs cscpd crd ctd dbcwcxcrcw cvd cpd cxd ctd dacpd cxcpcqd ctd crcpd cxd cjbebeclba cccwd cpcqd cpcrd cxd cvctd ctd cpd cpd cscpd ctd cqct ctd cud ctcsb cpd cpd crcpd cpcqd dacxcscxd dactd ctcrcxd crcwcpd cpcrd ctd cxdecpd cxd cvd cpd cwcpd cpd cxd cpd cxd czctcs cscpd crd ctd cwd dbctdactd cwct ctd cwd csd cpd cpd dactd crd cxd cpcrct cpd cxd ctba cccwct cxd cpcqcxd cxd ctd cud cscpd ctd crcpd ctd ctd ctcrcxd cxd cxd cud cpd cxd cqct cqd cpcxd ctcs cud cxd ctd dacpd ctcs acctd csd cxd cpd crcpd ctd ctd ctcrcxd ctd cxcr cxd cud cpd cxd cqct cqd cpcxd ctcs cud cxd dacpd ctcs acctd csd byd cxd cpd crctb dbcxd cxd ctd dacpd cpd cpd ddd cxd cpd cpcqd cpcrd cxd ctd ctd cpd cxd cwcpd csctd ctd cxd ctd cpd cxd ctd dacpd cud ctcpcrcw dacpd cxcpcqd cwcpd dactd cpd dccxd cpd ctd cwct dacpd cxcpcqd ctb ctd dacpd ctd dbcwctd dbctcpcz cscpd ctd cqct cpd cxctcs cxd dacpd ctcs acctd csd dbcxcsctd cxd ctd dacpd cpd cqd cpcxd ctcsba cwcxd cpd ctd dbctd ctd ctd cpd cpcqd cpcrd cxd cud cwctcpd cpd crcpd ctcsd cpcvctb ctcuctd ctcsd cpd cwct ctcrctd crddb cpcqd cpcrd cxd cwcpd cxd ctdbcwctd cxd cwct cxcscsd cqctd dbctctd cwct ctdcd ctd ctd cpd csct ctd cpd cxd cjbdb bebgb bjcl cpd crd ctdc cwcpd cpcqd cpcrd cxd cjbebeclba cccwct ctcrctd crddb cpcqd cpcrd cxd ctd cpcqd ctd cscpd ctd cqct ctd cud ctcs cxd cpd crcpd ctd cccwct ctcrcxaccr ctcrcwd cxcrcpd crd cxcqd cxd cwct cpd ctd cpd cpd cud dbd cfct cpd cxd ctdcd ctd cxdact cpcqd cpcrd cxd cud cwctcpd cpd crcpd ctcs cscpd crd ctd cwcpd cpd dbd cqd cpcxd ctcud ctd cud cqcyctcrd cpd crcpd ctcs cxd cwct cwctcpd cfct cwd cwct ctabctcrd cxdactd ctd cwct cpcqd cpcrd cxd cxd cpd cxcrd cpd crcwcpd ctd cvcxd crd ctdcd cfct ctcpd cwd dbctd cxd ctd dactd dacxd cpd cud crd cxd crcpd cxd dcbkbi ctdcctb crd cpcqd ctd cqd cpcxd ctcscud bvb crd csctbac cpd cxcrd cpd cud cpd crcpd cxd cxd ctd cwcpd cpd cxd cqctcrcpd cwct crct crd csct crd cpcxd crcpd ctdb bvb dbcwctd cxd crd cpd cwcpd cwcpd dacxd cpd ctd cwd csd cwct ctcrctd crddb cpcqd cpcrd cxd cvctd ctd cpd ctd cxd ctcrd dactd cxd cud cpd cxd cpcqd dacxd cpd cud crd cxd cpcqd ctd cdd cxd cwct ctcrctd crddb cpcqd cpcrd cxd dbcpd cpcqd ctd dact cpd cvct cud cpcrd cxd dacxd cpd cud crd cxd crcpd cpcrcrd cpd ctd ddba bxdccxd cxd crcw cpd bwbtc cjbdbhcl ctd dactcs cwct dacxd cpd cud crd cxd crcpd cxd ctd ctdccpd ctd cccwct ctd cpcxd csctd cwct cpd ctd cxd cvcpd cxdectcs cpd cud dbd dcbe dacxcsctd cqcpcrczcvd cwct cxd ctd cwcpd cpd cxd dbcwctd ctd dacxd dacxd cpd cud crd cxd crcpd cxd ctdcctcrd cpcqd ctd dcbf csctd crd cxcqctd ctcrctd crddb cpcqd cpcrd cxd cud cwctcpd cpd crcpd ctcs cscpd crd ctd dcbg dacxcsctd ctdcd ctd cxd ctd cpd ctd ctdacpd cpd cxd cwctd ctcrcwd cxd ctd dcbh cscxd crd ctd ctd cpd ctcs dbd czba cactd dacxd cecxd cpd byd crd cxd bvcpd cxd bxdcctcrd cpcqd ctd ctcrctd ddctcpd cwctd cxd cpd cxd crd ctcpd cxd ctctcs cud cwctd cvd cpd ctd cpd ctcrd cxd cpd cpd ddd csctd cpd ctdcctcrd cpcqd ctd byd cxd cpd crctb crd ctd crcxcpd crd cpd cxctd cpd cwct cxd cxd cpd cxd crd ctcpd cxd cvd bvd ctd crcxcpd abb cccwct cbcwctd bvc cccbb crd ctd ctcsd crct cwct crd cud dbcpd csctdactd ctd cccwctdd cpd cxd ctd ctd ctcs cxd ctd cxd cwcpd bvc cccb crd ctd csd ctd cud cpd cxcrcxd cpcrd cxd crcpd cqct cud crctcs ctd cud cpd cxcrcxd cpcrd cxd cccwctd ctcud ctb ctd dacxd dacxd cpd cud crd cxd crcpd cxd ctdcctb crd cpcqd ctd cxd cxd cpd bdb cpd crd csctb csctd cpd cscxd cpcxcs cpd cpd ddd dbcwd ctdccpd cxd ctdcctcrd cpcqd ctd cpd beb cud ctcrd dactd cxd ctd ctcscxcpd cactd ctd ctd cpd cxd cab cwcpd cpcscscxd cxd cpd cpd cpd ddd ctd crcpd cqct ctd cud ctcs cwct ctcrd dactd ctcs aicp bxd cvd ctd ctd cpd cjbkclb bvcwctd cpd cfcpcvd ctd cjbhclb ctd crbab cxd cud cpd cxd cpcqd dacxd cpd cud crd cxd crcpd crcpd ctcpcs cxd cwct cvd cpd cpd cpcrct cqctcxd ctdcd ctcsb dbcwcxcrcw cxd crct cucpd cxd cxdactd cwcxd ctcrd cxd dbct cscxd crd cwct cxd ctd cwcpd cpd cxd dbcwctd ddcxd ctd dact dacxd cpd cud crd cxd crcpd cxd ctdcctcrd cpcqd ctd bvd cxcsctd cpd ctdcctcrd cpcqd crd cxd ctcs cud bvb cvd cpd cwcpd ctd cxd cwctd cxd cpd crct cpd dacxd cpd cud crd cxd cccwct acd cqddd ctd cpd cqcyctcrd crd cpcxd cwct cpcscsd ctd cwct dacxd cpd cud crd cxd cpcqd ctba cfct dbcxd ctcuctd cwctd cqddd ctd cpd cwct dacxd cpd cud crd cxd cxd ctd cpd ctdcctcrd cpcqd ctb crcpd ctdb ctd cxd dbd ctd cpd cxd bdb crcpd cpd cpd crcpd ctd ddb cpd beb crcpd cwct crd crd cxd cxd cxcpd cxdect cpd cwctd cwcxd cvd cwct dacxd cpd cud crd cxd cxd ctd dacxd cpd cud crd cxd crcpd cxd crct crd csct cvctd cpd cpd ctcs cpd cxd cscxd ctcrd crcpd cwd cvcw cwct dacxd cpd cud crd cxd cxd ctd ctct bycxcvba beb malloc mallocblock virtualtable bycxcvbabeba cactd dacxd dacxd cpd cud crd cxd crcpd cxd ctdcctcrd cpcqd ctd cfcwctd crct crd csct cxd cpdacpcxd cpcqd ctb dbcpdd ctd dacxd dacxd cpd cud crd cxd crcpd cxd cpd crcxcpd ddd cxd cud cpd cxd dbcxd cwct cxd ctd ctd ctcs cqdd cwct 
crcpd ctdb cpd cwctd cpcvcpd ctd cwcpd cxd cud cpd cxd cwctd cxd ctd cpd cpd cxcvd ctd cpd ctd ctd dbctdactd ddd cxd cud cpd cxd cxd cpd cpdacpcxd cpcqd cxd ctdcctcrd cpcqd ctd cccwctd ctcud ctb ctd dact dacxd cpd cud crd cxd crcpd cxd cud cpd cxd cpcqd cwct crd ctd cwct dacxd cpd cud crd cxd cxd ctd ctctcsd cqct cpdacpcxd cpcqd ctba byd cpd cxcrb cpd cpd ddd cxd cpd cvd cxd cwd csctd ctd cxd crcw cxd cud cpd cxd cxd cwcpd cpcrczd cwct add dbd cucxd cud cpd cxd cwd cvcwd cwct cxd crd cxd cxd cwct crd crd bycxcvba cxd cpd ctd cwct ctd cxcu cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cxd ctcsba cdd cxd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cpd ctb cxd dbd cqct cxcqd ctd cpcqd cxd cwct cxd cqctd dbctctd cwct cqcyctcrd cpd cwct dacxd cpd cud crd cxd cpcqd ctbm cqctcrcpd cwct cpd csct ctd ctd ctd cwcpd cqd crczb cwct cxd ctd ctd cpd cxd cwct cxd crd cxd cwcpd ctd cwct dacxd cpd cud crd cxd cxd ctd crcpd ctd cud dbctcpcz cscpd ctb cxbactbab cxd crcpd cyd cxd cwct dacxd cpd cud crd cxd cpcqd cpcscsd ctd dbcxd cwct ctdccxd cxd cpcscsd ctd ctd cpd dactd dbd cxd cwct dacxd cpd cud crd cxd cxd ctd cxd cwct cqcyctcrd dbcxd cwct cpcscsd ctd cwct dacxd cpd cud crd cxd cpcqd ctba btcud ctd cwct crcpd cpd crb cwct acctd csd cwct cqcyctcrd crcpd cwcpdact cpd dacpd cwd dbd cpd brb crd cxd cwct cyd cxd dbcxd cpd dacpd ctd cxd brb dbcwcxcrcw ctcpd cwcpd cwct dacxd cpd cud crd cxd cxd ctd crcpd cxd cpd dddbcwctd cxd ctd cwd dbd cpd cscpd cwctcs cpd dbd cccwctd ctcud ctb csctacd cxd cxd cqctd dbctctd cwct cqcyctcrd cpd cwct dacxd cpd cud crd cxd cpcqd cxd ctdactd ctd cpcqd cxd cwctcsb cpd crd cxctd cwct cpd cpd ddd cxd crcpd crd crd csct cwcpd cwct dacxd cpd cud crd cxd crcpd cpdd ctd dact cpd cxcqd cud crd cxd cccwct czctdd ctd dacxd dacxd cpd cud crd cxd crcpd cxd ctdcctcrd cpcqd ctd cxd cqct cpcqd ctd cpcqd cxd cwcpd cwct dacxd cpd cud crd cxd cxd ctd csctacd cxd ctd cxd crctd cpcxd dacxd cpd cud crd cxd cpcqd ctba dcbebabd csctd crd cxcqctd cwct cpcqd cpcrd csd cpcxd ctcs cxd cecpd ctb cbctd btd cpd ddd cxd cecbbtb cjbeclb crd cqcxd ctcs cxd ctd cpd cpd ddd cxd cpd ctd cxcrb cpd cpd ddd cxd cpd cvd cxd cwd cwcpd crcpd cpcrcz cwct add cscpd cxd cpd ctdcctcrd cpcqd ctba cccwct dactd cxd cwct cecbbt csd cpcxd csctd crd cxcqctcs cxd dcbebabd cwct dactd cxd ctcs cxd cjbeclb cwcpd cwct cxd cxd cpd cxd cscxd crd ctcs cpcqd dact cxbactbab cwct ctctcs ctd cud dbctcpcz cscpd ctd dcbf csctd crd cxcqctd cpd ctdcd ctd cxd cwct cecbbt csd cpcxd cwcpd ctd cwct ctcrctd crddb cpcqd cpcrd cxd cpd cwd dbd cwd cxd cxd cpcqd ctd cpcqd cxd csctacd cxd cxd cqctd dbctctd cpd cqcyctcrd dacxd cpd cud crd cxd cxd ctd cpd cwct cpd cxcpd ctdacxd cpd cud crd cxd cpcqd cxd cpd crcxd crd cpd crctd bebabd cecpd ctb cbctd btd cpd ddd cxd cecbbt cxd crd cqcxd ctcs ctd cxcrb cpd cpd ddd cxd cpd cxd ctd cpd cpd ddd cxd cpd cvd cxd cwd cwcpd csctb ctd cxd ctd cpd dactd cpd dccxd cpd cxd cwct ctd ctd cxcr dacpd ctd cpcscsd ctd ctd cwcpd ctcpcrcw dacpd cxcpcqd cwd csd cpd ctcpcrcw cvd cpd cxd czctdd cuctcpd cecbbt cxd cwcpd cxd cpczctd cxd cpcrcrd cxd ctd cpd cxd cwd ctd cxcr ctd cpd cxd cpd cpcrczd cxd ctcvctd dacpd ctcs cpd cpcscsd ctd dacpd ctcs cpd cxd cxctd cxd cpd ctd ddba cccwcxd cxd crd crcxcpd cud cpd cpd dddecxd ctdcctcrd cpb cqd ctd cqctcrcpd ctd cxcr dacpd ctd cpd cpcscsd ctd ctd cpd cxd cscxd cxd cvd cxd cwcpcqd cpd cxd cpd cxd ctd cpd cxd cwd ctd cxcr cxd ctcs ctdcd ctd cxdactd cxd ctdcctcrd cpcqd ctd bwd cxd cecbbtb ctd cpcsb csd ctd ctd cpd ctd cxcr dacpd ctd cxd ctd ctd ctd ctcs cqdd cpcuct cpd dccxd cpd cxd dbcwcxcrcw dbct ctcuctd cpd dacpd ctb ctd ctd ddb cactcvcxd cwct cxd cpcscsd ctd cpcrctb cwctd cxd ctd cpd cpd cxd cwct cpcrd cxb dacpd cxd ctcrd csd dacpd cxd crctcsd ctd cwct cwctcpd cpd cwct ctd cud cvd cqcpd cscpd cpba dbctdactd csd cxd cwct cpd cpd ddd cxd cpd ctdcctcrd cpcqd ctb dbct cqd ctcpcz cwct cpcscsd ctd cpcrct cxd ctd cscxd cyd cxd ctd cpd ctcpd dbcwcxcrcw cpd ctcuctd ctcs cpd ctd ddb ctcvcxd bxcpcrcw ctd ddb ctcvcxd ctd ctd ctd cvd crcpd cxd cwcpd cwcpdact cxd cxd cpd cxd ctd cxctd byd ctdccpd ctb cwct cxd crcpd cxd cwcpd cqctd cwct cpcrd cxdacpd cxd ctcrd cwct cpd crctcsd cqctd ctd ddb ctcvcxd byd cvcxdactd cvd cpd cwctd cpd cwd ctct czcxd csd ctcvcxd bdb cwct cvd cqcpd ctcvcxd cwcpd crd cpcxd cxd cud cpd cxd cpcqd crcpd cxd cwcpd crd ctd cvd cqcpd cscpd cpb beb cwct btcab ctcvcxd cwcpd crd cpcxd cxd cud cpd cxd cpcqd crcpd cxd cwcpd crd ctd csd cwct cpcrd cxdacpd cxd ctcrd cpd cxcrd cpd crctcsd ctb cpd bfb cwct cpd crb ctcvcxd cwcpd crd cpcxd cxd cud cpd cxd cpcqd crcpd cxd cwcpd cpd cpd crcpd ctcs cpd cpd cxcrd cpd cpd cxd ctba cfct cpd cwcpd cwct crd ctcpcrcw ctcvcxd cxd cpdacpcxd cpcqd ctcxd cwctd cud csctcqd cvcvcxd cxd cud cpd cxd cwct crd ctb cscxd crd dactd ctcrcwcpd cxd csctd crd cxcqctcs cxd cjbfclba cfct cpd ctcpd ctcpcrcw acctd crd cpd ctd cpd cpd dacpd cxcpcqd ctba cccwcpd cxd crctcsd dbcxd crcpd dacpd cxcpcqd ctd cxd cpbn crd cxd cqbn cxd crbn csbn dbd cqct ctcpd ctcs cpd cwcpdacxd cwd ctct cxd dacpd ctcs dacpd cxcpcqd ctd cpb csbacqb cpd csbacrba cccwcxd cpd dbd ctcpd acctd csd cpd crb ctcvcxd cwcpd 
cwd crd dacpd ctcs cpd cxd cxd cwct cpd dbcpdd cpd dacpd cxcpcqd ctd cxd btcab ctcvcxd bab byd cwcxd ctcpd dbct cwct ctd ckdacpd cxcpcqd ctaydbcwctd ctcuctd cxd crd ctd cpd crb ctcvcxd cpd cwcxd cxd dbcwdd cwct crd ctd cpd btcqd bxd ctct cqctd dbb cwcpd cwd csd cxd cud cpd cxd cpcqd cpd crb ctcvcxd cxd ddd btd crc ctd cacvd cecpd bxd cecpd ctb cbctd dacpd ctb ctd cxd cpcuct cpd dccxd cpd cxd cud ctd cpcscsd ctd ctd cpd ctd cxcr dacpd ctd cbd cwcpd cxd cwct cqctd ctcvcxd cxd cwct ctdcctcrd cpcqd ctba dacpd ctb ctd cxd cpd cxcsctcs cxd ctd dacpd cwct cud cjd bnd clb dbcxd ctcpcrcw crd ctd cwct ctd ctd ctd cxd cwct ctd cpcscsd ctd ctd cxd cwct crd ctd cscxd ctcvcxd byd bfbeb cqcxd cpcrcwcxd ctb cxcsctcsb cxd ctd dacpd cjd bnd ctd ctd ctd cwct ctd cxd ctcvctd cucx cja bfbd bnbe bfbd bdclcyd bncx cvba cxd crcpd ctcs cwct cxcsctba cjd bnd cxd crcpd ctcs cwct cxd ctd dacpd bccjd bnd ctd ctd ctd cwct cxd cvd ctd ctd cud cvba cecbbt cxd add dbb ctd cxd cxdactb crd ctdcd ctd cxd cxdactb cpcqd cpcrd cxd ctd ctd cpd cxd cpd cvd cxd cwd cpd cpd ctd ctd cxdectcs cqdd crcpd cxd ctd cvd cjbebfclb cwcpd cxd cqcpd ctcs cpd cxd csctd ctd csctd cpd cxcqd csd cpcxd csctd crd cxcqctcs cqctd dbba ccd cxd cxcudd cwct ctd ctd cpd cxd cwct cscxd crd cxd cxd cwcxd ctcrd cxd ctd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cud cwctcpd cpd crcpd ctcs cpcvctba ctd csctd cwct ctd ctd ddb ctcvcxd cpd crcxcpd ctcs dbcxd crctcsd ctd cxd cwct cvd cpd btd crc ctd cacvd csctd ctd cwct ctd ctd ctcvcxd cpd crcxcpd ctcs dbcxd cwctcpd cpd crcpd cxd cxd ctd cpd bzd cqcpd csctd cwct ctd ddb ctcvcxd cpd crcxcpd ctcs dbcxd cwct cvd cqcpd cscpd cpd ctcpba cfct dbd dbcxd cwct cud dbcxd cqcpd cxcr csd cpcxd ctd cacvd bpcubzd cqcpd cvcjc crcjbtd crc ctd cacvd cecpd ctcbctd bpc ctd cacvd cbd cxcsctcsc ctd dacpd cecpd bxd dabpcecpd cecpd ctcbctd btcqd bxd cpd ctcpcrcw ctcvcxd cxd crd ctd cscxd cecpd bxd cpd ctcpcrcw ctcvcxd ctd cecpd ctcbctd btcqd bxd dabp ctcvcxd ctd cecpd ctcbctd cubzd cqcpd cecpd bxd cecpd bxd btd crc ctd cacvd cecpd bxd cecbbt cpd crcxcpd ctd ctcpcrcw cvd cpd cxd dbcxd cpd btcqd ctd bvd accvbm btcqd ctd bvd accvbpb bvcpd cbd cxd btcqd bxd bxdccpd bdba cfct dbcxd cxd cpd cecbbt cxd cwct cvd cpd cwd dbd cxd bycxcvba bfb cpb cxd ctd ctd cpd cxd cecbbt cxd cpd cxctcs ctdcctcrd cpcqd ctd cfct crd csct cud ctcpd csctd cpd cscxd cvbab byd cwcxd ctdccpd ctb cwctd ctdbd cqctd cwd ctct ctcvcxd bmbzd cqcpd btca cpcxd cpd cpd bdba crd cxd cxd cpbn crd cxd ctdcd cvbn cxd cpcxd cxd cxbn cxd cwctcpcs cdc cud bcbn bhbn cxb bdbm cxd ctd ctd cxd cpd crb cxdectd cub cxd ctd ctd bqcp cxbn ctd ctd bqd ctdcd cwctcpcsbn cwctcpcs ctd ctd ctd bcbn cjb bzd cqcpd bjax bdcjbcb bgclb cwctcpcs cjb cpd bjax bccjbcb bcclb ctd ctd cjb cpd bjax bccjbcb bcclb ctd ctd bqcp axbq ctd ctd bqd ctdcd axbq cqb elem head cpb crb bycxcvbabfba cecpd ctb cbctd btd cpd ddd cxd cecbbtb ctdccpd ctbm cpb cvd cpd cqb cecpd ctb ctd cpd bdb cpd crb cxd cxd cud cpd cxd ctcrd dactd ctcs cqdd cecbbt dbcwctd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cxd ctcsb cpd cwct ctd cwct cxbactbab cyd cpcud ctd ckcwctcpcs ctd ctd bnayb cccwct dacpd ctb ctd cwcpd cpd cqd cpcxd ctcs cud cecbbt cpd cwct cqd cwct cqd csdd cpd cwd dbd cxd bycxcvba bfb cqb ckcx cjb bzd cqcpd bjax bdcjbcb bgclb clay cxd cscxcrcpd ctd cwcpd cwcpd dacpd cvd cqcpd cpcscsd ctd cxd cwct cpd cvct cjbcbnbgclba ckctd ctd cjb cpd bjax bccjbcb bcclb clay cxd cscxcrcpd ctd cwcpd ctd ctd crd cpcxd abd ctd cxd cwct cpd crb ctcvcxd cpd crcxcpd ctcs dbcxd cpd crb cxd bdba ckcwctcpcs cjb cpd bjax bccjbcb bcclb clay cxd cscxcrcpd ctd cwcpd cwctcpcs crd cpcxd abd ctd cxd cwct cpd crb ctcvcxd cpd crcxcpd ctcs dbcxd cpd crb cxd bdba ckctd ctd bqcp bqay cpd ckctd ctd bqd ctdcd bqay cxd cscxcrcpd cwcpd ctd ctd bqcp cpd ctd ctd bqd ctdcd cpdd crd cpcxd cpd cxcqd dacpd ctba cecbbt crd csctd ctd cxd cqctd ctd dacpd ctb ctd cud cwctd dacpd cxcpcqd ctd cqctcrcpd cwct dbctcpczb cscpd cqd ctd ctd cxd ctcs ctcpd cxctd buctcrcpd cpd csd ctd cxd cxd cxcpd cxdect cwct cqd crcz ctd cxd ctd cecbbt cpd ctd cpcuctd ddb cwcpd ctd ctd bqcp cpd ctd ctd bqd ctdcd cpdd crd cpcxd cpd cxb cqd dacpd cpcud ctd cwct crcpd cpd crba buctcrcpd cpd cxd cpd ctd ddb ctcvcxd dbctcpcz cscpd ctd crcpd cqct ctd cud ctcs cpd cwct cxd crd cxd cwcpd cxd cxd cxcpd cxdect cwct acctd csd ctd ctd cccwctd ctcud ctb cwct dacpd ctb ctd cpd crcxcpd ctcs dbcxd cwct acctd csd ctd ctd ctd cpcxd bqba bycxcvba bfb crb cwd dbd cwct cxd cud cpd cxd cxcrd cxcpd ddba cccwct csd cqd cqd csctd ctd cpd cqcyctcrd bwcpd cwctcs ctcscvctd csctd cpddb cxd cxd cud cpd cxd ctdccpd ctb cecbbt cwcpd ctcrd dactd ctcs cwct cud dbcxd cvbm bdb cwctcpcs cpd ctd ctd cpdd cxd cpd ctcpd cwct cqcyctcrd ctd ctd ctd ctcs cqdd cwct cpd cqcyctcrd beb ckctd ctd bqd ctdcd cpdd cxd cpd cxcqd crcpd cxd cpd bfb ckctd ctd bqcpay cpdd crd cpcxd cpd cxcqd dacpd ctba btd btcqd cpcrd cxd cud ctcpd btd crcpd ctcs cbd cpcvct cccwcxd ctcrd cxd csctd crd cxcqctd cwct ctcrctd crddb cpcqd cpcrd cxd cccwct ctcrctd crddb cpcqd cpcrd cxd cxd cxd cxd cpd cxd ctd ctcrd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cxd cwcpd ctcpcrcw cpcqd cpcrd csct cxd cpd crcxcpd ctcs dbcxd cpd cxcrd cpd cpd crcpd cxd cxd ctbn cwd 
dbctdactd cwct ctcrctd crddb cpcqd cpcrd cxd ctd dbd ctd ddb ctcvcxd ctd cpd crcpd cxd cxd btd crc ctd cacvd bpcuc cabtbucjd clbnc cabtbucjd cpd cpd crcpd cxd cxd ctcv cabtbucjd ctd ctd ctd cwct ctcrctd ddb cpd crcpd ctcs cqd crcz cwcpd dbcpd cpd crcpd ctcs cpd buctcrcpd cwctd cxd cpd crcw cqd crcz cxd cpd crd crd ctd crd accvd cpd cxd cabtbucjd cxd ctdactd cpd ctd ddb ctcvcxd cabtbucjd ctd ctd ctd cwct ctcrctd ddb cpd crcpd ctcs cqd crczd cwcpd dbctd cpd crcpd ctcs cpd buctcrcpd cwctd crcpd cqct cpd crcw cqd crczd cxd cvcxdactd crd crd ctd crd accvd cpd cxd cabtbucjd cxd cvctd ctd cpd cpd ctd ddb ctcvcxd cpcscscxd cxd ctcpcrcw cabtbucjd clbnc cabtbucjd btd crc ctd cacvd cxd cpd crcxcpd ctcs dbcxd ckcrd dacpd ctb csctd ctcs cqdd cabtbucjd clbmcrd cpd cabtbucjd clbmcrd ctd ctcrd cxdactd ddb dbcwcxcrcw cxd dacpd ddd cbd cpd cacpd cvct cucjbcbnbcclb cjbcbnbdclb cjbdbnbdclb cjbcbnbdclb cjbdbnbdclb cjbebnbdclcvba cccwct crd dacpd ctcrd csd cpd cvct cud cwd cpd crd crd ctd cqd crczd cwct ctd ddb ctcvcxd ctd ctd ctd cfcwcxd cabtbucjd clbmcrd crcpd cwcpdact cpd cbd cpd cacpd cvct dacpd ctb cabtbucjd clbmcrd dbcxd cqct ctd cxcrd ctcs cpczct dacpd ctd cxd dbcwcxcrcw ctd ctd ctd crd cud cpd ctcvcxd bvd ctd ctd ddb cpd cpcqd cpcrd cpd cud ctd crcpd ctd cud cscpd acctd cabtbucjd clba cpcscscxd cxd cwct crd ctcpcrcw cabtbucjd clbnc cabtbucjd btd crc ctd cacvd cxd cpd cpd crcxcpd ctcs dbcxd ckd cxdectay dacpd ctb csctd ctcs cqdd cabtbucjd clbmd cxdect cpd cabtbucjd clbmd cxdectb ctd ctcrd cxdactd ddb dbcwcxcrcw cxd dacpd ddd cbd cxcsctcsc ctd dacpd cccwct cxdect dacpd ctd ctd ctd cpd dactd cpd dccxd cpd cxd cwct ctd cxdectd cwct crd crd ctd cqd crczd cwcpd cwct ctd ddb ctcvcxd ctd ctd ctd cccwcxd cxd cud cpd cxd crcpd cqct ctcs ctd ctd cxcpd ctd ddb cpcrcrctd dacxd cpd cxd cwcpd cxd dad dact cwctcpd cpd crcpd ctcs cscpd cpba mrab mrab malloc mrab nmrab nmrab mrab malloc cpb cqb mrab nmrab nmrab mrab malloc mrab nmrab nmrab mrab malloc crb csb bycxcvbabgba cpcrct cwct ctdad cxd cpd cwct btcqd bxd dad cud cwd ctct cxd crd cxd cxd bxdccpd beba bycxcvba cwd dbd cpcrctd cwct ctdad cxd cpd cwct btcqd bxd dad cud cwd ctct cxd crd cxd cxd csd cxd cecbbtba cxd cpd ctcs cwcpd cwctd cpd cwd ctct acctd csd cxd cwct ctd ddb ctcvcxd cabtbu cpd cabtbu cwd dbd cpd cwct cwd ctct ctcrd cpd cvd ctd dbcxd cwcxd cabtbu cpd cabtbub bwd cqd cqd dcctd cpd cabtbu cqcyctcrd cxd bycxcvba bgb crb cpd csb cpd ctcs cxd cscxcrcpd cwcpd cwctdd cpd cpd ctd ddb ctcvcxd byd cqd ctdacxd ddb cxd bycxcvba cwct ctabctcrd ctcpcrcw cxd crd cxd cxd csctd ctcs cxd ddd cpdcbn cwct cxcvcxd cpd crct crd csct cxd cwct cqd csdd crd cpcxd bvb cpd ctd ctd ckd ctdb bvayb dbcwctd cxd crd cpd cwcpd cwcpd dacxd cpd ctd cwd csd cpd cvba cccwct ddd cqd cpd cwcpd cpd ctcpd cxd bycxcvba ctd ctd ctd cwct cpcscsd ctd ctd ctd cwd csd cpd cvba cccwct ddd cqd cpd cwct dbd acctd csd cecc ctd ctd ctd dacpd cxcpcqd ctd cwct bzd cqcpd ctcvcxd cccwct csd ctcs cxd ctd cxd bycxcvba bgb cqb dfb csb cxd cscxcrcpd cwd cwct dacpd cabtbu cpcud ctd cwct cpd cpd ctd ctd csctd ctd csd cwct dacpd cabtbu cpd cabtbu cqctcud cwct cpd cpd ctd ctd cccwct btcqd bxd dad cpcqcxd cxdect cpcud ctd cud cxd ctd cpd cxd cwcpd cxd ctcpcrcw bycxcvba bgb cpb csb cxd crcpd cqct ctd cpcqd cxd cwctcs cwcpd cwct cxd crd cxd ckd bqdad ceccay cscxacctd ctdccpcrd acctd cxd cpd ctd ddb ctcvcxd cpd cwctd crct cscpd crcpd cqct ctd cud ctcs bqdad cccwcxd ctd cpcqd cxd cwctd csctacd cxd cxd cqctd dbctctd cabtbu cpd ceccdg cpd cwctd crct cqctd dbctctd cabtbu cpd ceccba bxdccpd bfba bycxcvba cwd dbd cwct cxd dactcs cecbbt cxd cud cpd cxd ctcrd dactd ctcs cud cwct cvd cpd cud bycxcvba cpd cwct ctd cwct dbcwctd cwct ctcrctd crddb cpcqd cpcrd cxd cxd ctcsba cpd cxcrd cpd dbct cwcpdact cwct cud dbcxd cxd cud cpd cxd mrab nmrab head elem bycxcvbabhba dactcs cecbbt cxd cud cpd cxd cud cwct cvd cpd cud bycxcvba cpd cwct ctd cwct cxbactbab cyd cpcud ctd ckcwctcpcs ctd ctd bnayb dbcwctd cwct ctcrctd crddb cpcqd cpcrd cxd cxd ctcsba cccwct csd cqd cqd csctd cpd ctcvcxd bwcpd cwctcs ctcscvctd csctd cpddb cxd cxd cud cpd cxd bab ctd ctd cpd cwctcpcs csctacd cxd ctd cxd cwct cqctcvcxd cxd cwct cabtbu ctcvcxd ctd ctd bqcp crd cpcxd cwct dacpd ctd cvd cqcpd cpcscsd ctd ctd cubcbnbdbnbebnbfbnbgcvba ctd ctd bqd ctdcd cpdd cqct cdc cpdd cxd cwct cqctcvcxd cxd cwct cabtbu ctcvcxd cabtbubacp crd cpcxd cwct dacpd ctd cvd cqcpd cpcscsd ctd ctd cubcbnbdbnbebnbfbnbgcvba cabtbubad ctdcd cpdd cqct cdc cpdd cxd cwct cqctcvcxd cxd cwct cabtbu ctcvcxd cccwcxd cxcsctcp cxd cud cpd cxdectcs dbcxd cwct cud dbcxd cqcpd cxcr csd cpcxd dbcwctd csctd cxd cxd cxd cscxcrcpd ctd cscxabctd ctd crctd cud cwct csd cpcxd cvcxdactd cxd dcbeb ctd cacvd bpcubzd cqcpd cvcjc crcjbtd crc ctd cacvd cecpd ctcbctd bpc ctd cacvd cbd cxcsctcsc ctd dacpd cecpd bxd dabpcecpd cecpd ctcbctd cbd cpd cacpd btd crbtcqd bxd dabpb cbd cpd cacpd cvcta cbd cxcsctcsc ctd dacpd cecpd bxd dab cccwct cpd cpd ddd cxd cpd crcxcpd ctd ctcpcrcw cvd cpd cxd dbcxd cpd btcqd ctd bvd accvbm btcqd bxd dabp ctcvcxd ctd cecpd ctcbctd cubzd cqcpd cecpd bxd cecpd bxd btd crc ctd cacvd btd crbtcqd bxd dab btcqd ctd bvd accvbpb bvcpd cbd cxd btcqd bxd ctd crd cxdectb cpd dacpd bxd dab ctd ctcrd cxdactd ddb csctd cwct cbd cpd cacpd cvctb cbd cxcsctcsc ctd dacpd cpd cecpd bxd cpd crcxcpd ctcs dbcxd cvcxdactd btd crc ctd cacvd cvcxdactd cpcqd bxd btcqd bxd cpd cpd crcpd cxd ctd ddb ctcvcxd crcw cpd cabtbucjd cabtbucjd clb cwcrd bnd cxdectbndacpd bxd dacx cxd ctd 
cccwct cpd cud ctd cud dacpd cxd ctd cpd cxd cpd csctacd ctcs cpd cud dbd btd cwct ctd cxd cwct cvd cpd cwct btcqd ctd bvd accv cwcpd csctd crd cxcqctd cwct cxd cxd cxcpd cpd ctcrd csd cwcpd cud ctcpcrcw cpd crcpd cxd cxd cwct cecpd bxd dad cud cqd cabtbucjd cpd cabtbucjd cpd brba cccwct cpd cud ctd cud cpd crcpd cxd cxd cpd cud cpcqd bxd cpcqd bxd dbcwctd cpcqd bxd cxd cxcsctd cxcrcpd cpcqd bxd dab ctdccrctd cwcpd cpd cecpd ctcbctd cpcqd bxd cwcpd crd cpcxd cjbmbmbmbnc cabtbucjd bjax bnc cabtbucjd bjax bnbmbmbmcl cqctcrd cjbmbmbmbnbnbnc cabtbucjd bjax bnbmbmbmcl cxd cpcqd bxd dcbkbi crd csctb ctd dacpd ctd cpd cpd ctcs cqcpcrcz cxd ctcvcxd ctd ctcpdcba ctd cxdect csctd cwct cxdect cwct cqd crcz cpd crcpd ctcs cpd cwct cpd crcpd cxd cxd ctba cccwct dacpd cxdect cxd cqd cpcxd ctcs cud cwct dacpd ctb ctd cpd crcxcpd ctcs dbcxd cwct cpd cpd ctd ctd cwct cpd crcpd cxd ctd cwd csba cpcscscxd cxd cpcqd bxd cxd cscpd ctcs cwct cud dbcxd cpd cvd ctd cpcqd bxd cabtbucjd clb bpcwcjbcbnbdclbnd cxdectbnaldacpd bmbq cecpd ctcbctd cpcqd bxd cabtbucjd clb bmcrd cpcqd bxd dab cabtbucjd clb bmcrd cpcqd bxd dab cabtbucjd clb bmcrd cpcqd bxd cabtbucjd clb bmd cxdectbp cpcqd bxd dab cabtbucjd clb bmd cxdect cpcqd bxd dab cabtbucjd clb bmd cxdect cpcqd bxd cabtbucjd clb bmdacpd bxd dabp cpcqd bxd dab cabtbucjd clb bmdacpd bxd cpcqd bxd dab cabtbucjd clb bmdacpd bxd cpcqd bxd ctcpdcb bpcjb cabtbucjd bjax bccjbcbnbcclb bnb bzd cqcpd bjax bccjbcbnbcclb cwct ctd ctd cxd ctd ctd cpd cxd dbctcpd ctd cwcpd cpd cpd crcpd cxd cpd dbcpddd crcrctctcsd cwctd crctb cxd cpcrct cwct acd cpd cpd cxd ctd cpcqd dactb dbct cpcqd bxd cabtbucjd clb cwcjbdbnbdclbnd cxdectbnaldacpd bmbq cecpd ctcbctd cxbm cpcqd bxd ctcpdcb cjb cabtbucjd bjax bccjbcbnbcclb bvd ctd ctd ddb cwct cpd cpd ddd cxd ctdcd ctd cwct cqctcwcpdacxd cwct ddd ctd ctdcctb crd cxd cxd dbcwcxcrcw cpd crcpd cxd cpd dbcpddd crcrctctcsba cccwct cyd cxd cpcqd bxd cpcqd bxd cpcqd bxd bncpcqd bxd btcqd bxd cxd ctd cud ctcs cxd dbcxd ctbn cxd cpd cxcrd cpd cpcqd bxd cabtbucjd clb cpcqd bxd cabtbucjd clb cpcqd bxd cabtbucjd clb cpcqd bxd cabtbucjd clb cpcqd bxd cabtbucjd clb cpcqd bxd cabtbucjd clb cpd cwctd cpcqd cpcrd cpd cud ctd ctbacvbab cpd cxcvd ctd cscpd dactd ctd cxd ctd ctb cpd cxd crd cscxd cxd ctd crbab cabtbucjd cpd cabtbucjd cpd ctcpd ctcs cyd cxczct cwctd ctd ctcvcxd dgcxbactbab bzd cqcpd cpd cwct btcab ctcvcxd dgdbcxd ctdccrctd cxd bwd cxd cecbbtb cpd cpcqd cpcrd cpd cud ctd cpd cpd ctcs ctd ddb ctcvcxd cpd cpd cwcpd cxd cscxcrcpd ctd dbcwcxcrcw ctd ddb ctcvcxd cxd cwct crd ctdcd cvcxdactd crcpd cxd crd cpd cpd ctd ddb ctcvcxd cfcwctd ctcpd cwct bzd cqcpd ctcvcxd cxd cpd dbcpddd cpd ddb csctcrcxcsct dbcwctd cwctd crctcsd ctd ddb ctcvcxd cxd cpd ctd ddb ctcvcxd acd crcpd cxd crd cxd cpdactd ctcsb cpd cwctd cwct crcpd cvd cpd cxd cpdactd ctcsb ctct dbcwctd cwctd cwct cxd cpcrcz crd crd cpcxd cxd ctd cscxd cpcrd cxdacpd cxd ctcrd csd cud cccwct cpd ddb cpd cxd cud cpd cxd cud cabtbucjd cpd cabtbucjd cxd cqb cpcxd ctcs cscxabctd ctd dddgcud cwct dacpd ctd btcqd ctd bvd accvb crd cabtbucjd clb bmcrd cpd btcqd ctd bvd accvb crd cabtbucjd clb bmcrd ctd ctcrd cxdactd ddba cccwct ctd ddb ctcvcxd cpd cpd dacxcsctd dbd cxctcrctd cxd cud cpd cxd ctcs cxcsctd cxcudd dbcwctd cscpd crcpd cqct ctd cud ctcsba cpd cxcrd cpd cpd cpcqd cpcrd cpd cud ctd crcpd ctd cud cscpd cxcu cwct ctd cpd cxd cscxacctd cpb ctdccpcrd ctcvcxd ctd cqb ctdccpcrd dacpd cxcpcqd cxd cpd ctd ddb ctcvcxd bxdcd ctd cxd ctd cccwcxd ctcrd cxd csctd crd cxcqctd cwct ctd ctd cxd cxd cpd ctdcd ctd cxd ctd cccpcqba cwd dbd cwct crcwcpd cpcrd ctd cxd cxcrd cwct ctd ctdccpd ctd cwcpd dbct ctcs cxd ctdacpd cpd cxd cccwctd cvd cpd dbctd cxcvcxd cpd ctcs cqdd cpd csct cpd caddcsctd cxd cjbebccl ctdacpd cpd cwctcxd cpd cvd cxd cwd cud ctd dacxd dacxd cpd cud crd cxd crcpd cxd bvb cvd cpd cccwct cvd cpd bdbc cxd bvb dbctd crd cxd ctcs dbcxd cwd cxd cxdecpd cxd cxd cwct cxcrd cud cecxd cpd cbd cscxd bibabc crd cxd ctd cpd cwct bad cqcy acd ctd cqd cpcxd ctcs cud cwct crd cxd ctd dbctd cpd cpd dddectcsba cccwct crd cpcqctd ctcs ckbvd dactd cpcvctay cxd cscxd crd ctcs cqctd dbba dcbkbi crd cscxd ctcrd bvcpd bvd dactd cpcvct cccxd bebhbe blbkbablbl cxd ctd beblbg bjbhbabjbl bobd cucpd cxd bfbhbd blbkbabjbd dacrcxd bgbcbj bdbg bjbkbabebf bobd cud bhbcbe bdbf bkbjbabhbj crct bhblbe bebe bibcbabfbg bobd ctctd bdbeblbl bebl bibkbabcbk csctd cxdabd bdbfbibl bfbk bdbk bhbibabdbd crcwctd bdbibibe bgbd bkbgbabebd bdbi cqcyctcrd bdbjbfbl bgbj bebf bfbjbabdbe cxd bdblbebc bibc bebebabkbg cvd ctctcs bdblbgbh bgbj bdbj bjbebabkbj bdbc cwcpd ctd bdblbhbh bfbl bdbe bibgbabfbk bdbc crctcpd bebhbhbe bibd bgbgbabibh bdbj csctd cxdabe bebibfbl bgbd bhbi bfbebabebi cccpcqd bdba bvcwcpd cpcrd ctd cxd cxcrd cwct ctdccpd cvd cpd ckbvd dactd cpcvctay csctd ctd cwct cpd cwct cvd cpd cwcpd cxd ctcpcrcwcpcqd csd cxd cpd cpd ddd cxd ctct dcbgb cccpcqba cwd dbd cwct ctd cpd ddcxd cecbbt ctd dact dacxd cpd cud crd cxd crcpd cccwct crd cpcqctd ctcs cwd dbd cwct cqctd ctcpcrcwcpcqd cxd cscxd ctcrd crcpd cxd ctd cccwct crd cpcqctd ctcs csctd ctd cwct cqctd ctcpcrcwcpcqd cxd cscxd ctcrd crcpd cxd ctd cpd dbcwcxcrcw cecbbt crd csctd ctd cxd cwct cpd cvctd cccwct cwctd crd cwd dbd cwct cscxd cxcqd cxd cwct cqctd cpd cvctd cpd cwct cxd cscxd ctcrd crcpd cxd ctd byd ctdccpd ctb cwct crd cpcqctd ctcs csctd ctd cwct cqctd cxd cscxd ctcrd crcpd cxd ctd cwcpd cwcpcs cxd cvd cpd cvctd dectd dacpd cxd cwct bqb crd ctcpd cwcpd cpd cxd cscxd ctcrd crcpd cecbbt crd csctd ctd cxd cwcpd cwct dacxd cpd cud crd cxd crcpd crd ctd dact cpd crctb csd ctba cecbbt 
ctd crcw crcpd cxd ctd cwct ctd cqd csd ctd ctdcd cpd ddd crctcsd ctd cud cwcpd crcpd cxd ctba cccwct crd dactd cpcvct crd cxd cccpcqba cwd dbd cwct cud cpcrd cxd cwct ctdcb ctcrd cpcqd crd csct cwcpd dbcpd cpd cpd dddectcs csd cxd cecbbtba cwcpd cud cvd cpd cud dbcwcxcrcw cwct bqb crd cxd bcb cwct crd dactd cpcvct ctd ctcs cxd cccpcqba cxd cpd dactd cpd dccxd cpd cxd cwct cpcrd cpd cxd crd dactd cpcvct cud cpd cxcqd cwct ctdcctcrd cpcqd ctba dbctdactd cud cvd cpd dbcxd dectd dacpd ctd cxd cwct bqb crd cpd cwct cvd cpd cpdd cwcpdact cqctctd ctdcd ctcsba byd cvd cpd dbcxd dacpd cxd cwct bqb crd cwct cqctd crcpd ctd ctcs cpd ctcpcrcwcpcqd cpd ctd cwcpd cpd csctacd cxd ctd ctcpcrcwcpcqd ctba byd cxd cpd crctb cwct ctcxcvcwd crcpd cwcpd cpd adcpcvcvctcs cpd ctcpcrcwcpcqd cxd csctd cxdabd cpd csctacd cxd ctd ctcpcrcwcpcqd ctct cwct brb crd cfct ctct cwcpd cpd cvd cxd cwd ctd dactd dacxd cpd cud crd cxd crcpd cud cwct crcpd cxd ctd cxd cxd cpd ctcpd cxdect cwcpd cpd cwctd dacxd cpd cud crd cxd crcpd cpd ctd dactcs ctd cqdd cpcrczcxd cwct add cscpd cwd cvcw ctd cxd crd cscxd cwct cwctcpd cccwct cwcpd cxd cxdectcs cvd cpd cvctd ctd cpd cwcpdact ctd cpcrcrctd ctd cwcpd cxb cxdectcs cvd cpd cxd cxdectcs cvd cpd cpczct ctcvcxd ctd dbcwcxcrcw cpd ctcpd cxctd cpd cpd dddect cwcpd ctd cpcrcrctd ctd cccwd cud cpd cxcr cpd cpd ddd cxd cxd ctcs ctdcctcrd cpcqd ctd cxd cxdectcs cvd cpd ctd ctd ctd cvd ctcpd ctd crcwcpd ctd cvct cwcpd cxd cxdectcs cvd cpd bdbd albf cxd ctd cucpd cxd dacrcxd cud crct ctctd csctd cxdabd crcwctd cqcyctcrd bdbk cxd cvd ctctcs bdbc cwcpd ctd crctcpd csctd cxdabe bfbf bebe cccpcqd beba bwcxd cxcqd cxd cwct cqctd crcpd ctctd cpd ctcpcrcw cxd cscxd ctcrd crcpd cpd cpd ddd cxd cpd cvd cxd cwd csd ctd ctd ddd cqd cpcqd csctcqd cvcvcxd cxd cud cpd cxd cxd ctcpcs cxd ctd cwct crd ctb cscxd crd dactd ctcrcwcpd cxd csctd crd cxcqctcs cxd cjbfclba bxdccxd cxd cud cpd cpd dddecxd ctdcctcrd cpcqd ctd crcw cpd bwbtc ctd dact cwct dacxd cpd cud crd cxd crcpd cecbbt crd ctd dact cwctd cxd cscxd ctcrd crcpd cxd ctd cqctcrcpd cxd crd ctd cpcqd cxd cwcpd cpd cwct ctd ctd ctd cpd cpd cpdd cpd csctacd cxd ctd cxd cxd cxcpd cxdectcs cxd cccwct cqd ctd cxd cpd cud dbd cwct ctdccpd cvd cpd cpd cpd cpdd cxd ctd cqcyctcrd cxd cxd cxd cxcpd cxdectcs dacxcp cccwctd cxd ctd cpd cpd ctd ctcs cxd dad czct dacxd cpd cud crd cxd crcpd bxdactd cxcu cecbbt dbctd crcrctd cud cxd ctd cpcqd cxd cwcxd cwct cxd cqctd dbctctd cwct dacxd cpd cud crd cxd cxd ctd cpd dacxd cpd cud crd cxd cpcqd ctb cecbbt crd ctd cpcqd cxd cwcpd cpd ctd ctd ctd cwct cpd cpdd cpd csctacd cxd ctd cxd cxd cxcpd cxdectcs cqdd cwct cxd crd cxd cxd cwct ctd crctb cwct dacpd ctd cwct cxd ctd cxd cwct cpd cpdd ctd cpcxd bqba cwcpd cwcxd cxd cxd cwd cvd cpd cwct cqd ctd cpd cwcpd csba bxdactd cxcu dbctd cwctd ctcrcwcpd cxd crcw cpd cwct csctd crd cxcqctcs cxd cjbdbeclb ctd cpcqd cxd cwcpd cpd cwct ctd ctd ctd cpd cpd cpdd cpd cxd cxd cxcpd cxdectcsb cwct cqd ctd ctd cpcqd cxd cwcxd cwct cxd cqctd dbctctd cwct dacxd cpd cud crd cxd cxd ctd cpd cwct dacxd cpd cud crd cxd cpcqd cxd ctd cxd ctd ctcrcwcpd cxd cxd cxd cpd cwct ctcrctd crddb cpcqd cpcrd cxd cfct csd cscxd ctcrd crd cpd cpcvcpcxd cwct ctd cud cjbebcclb cqctcrcpd cxd dbd cqct cucpcxd crd cpd cxd cjbebccl cpczctd cpd cpcuct cpd cxd cwcpd ctd ctd ctd cxd cpd cpdd cxd ctd cpddb crcpd cpd crcpd ctcs cwctcpd cpd crcpd ctcsb cxd cxd cxcpd cxd cwcxd bnb cpd cwctd cwcpd cpd ddd cwcxd bqb cbd cwcpd cjcl cxd crcw cpd cpd cpdd cxd ctd cpd cwcpd cxd cxd cxcpd cxdectd ctdactd cwctd ctd ctd ctd dbcxd cpba ctd dbd cqct cwcpd ctd ctd ctd crcpd cxd cpd ddd cwcxd cvba dbctdactd cqctcrcpd cxd cwct cpd cvd cxd cwd ctcs cxd cjbebccl cwct cxd ctd cxd cxd cxd cxcpd bnb cjbebccl dbd csctd ctd cxd cwcpd ctd ctd ctd cxd cpb dbcwcxcrcw cxd csba cactd cpd ctcs cfd cwctd dbd cxd ctd cpd cpd ddd ctd cccwct ctcrctd crddb cpcqd cpcrd cxd cxd cxd cxd cpd cxd adcpdad cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cjbdbjb bgclb cxd cwcpd ctcpcrcw cpcqd cpcrd csct cxd cpd crcxcpd ctcs bdbe dbcxd cpd cxcrd cpd cpd crcpd cxd cxd ctbn cwd dbctdactd cwct ctcrctd crddb cpcqd cpcrd cxd cxd csctd cxcvd ctcs cpczct cpcsdacpd cpcvct cwct cucpcrd cwcpd cecbbt cxd add dbb ctd cxd cxdactb crd ctdcd ctd cxd cxdact cpd cvd cxd cwd cwcpd cxcu cwct ctcrctd crddb cpcqd cpcrd cxd dbctd ctcs dbcxd add dbb cxd ctd cxd cxdact cpd cvd cxd cwd cxd dbd dacxcsct cxd cpcscscxd cxd cpd ctcrcxd cxd dactd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cqctcrcpd add dbb cxd ctd cxd cxdact cpd cvd cxd cwd cwcpd cyd cpcqd cpcrd ctd crd accvd cpd cxd cwcpd ctdcd ctd ctd cvd cpd dbcxcsct cxd dacpd cxcpd cwct cpd cvd cxd cwd dbd cwcpdact ctd cud dbctcpcz cscpd ctd cud cpd cxcvd ctd cabtbu csctd cpd dbctd cpd cud cpd cxcvd ctd cabtbu csctd cwcpd cxd ctcscvctd ctd cpd cpd cxd cud cpd cabtbu csct dbd cpd cwcpdact cqct cpcrcrd cpd ctcsba cfcxd add dbb ctd cxd cxdact cpd cvd cxd cwd cwct ctcrctd crddb cpcqd cpcrd cxd ctd dbcxcrct cpd cpd cpcqd cpcrd csctd cpd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd cqd csctd crctd cpcxd crd cscxd cxd cxd cxd cud cwct cpd cvd cxd cwd ctd cud cscpd ctd cud cpd cxcvd ctd cabtbu csctd dbcwcxcrcw cxd crd crcxcpd cqctcxd cpcqd ctd cpcqd 
cxd csctacd cxd cxd cqctd dbctctd cwct ctd cqcyctcrd cpd crcpd ctcs cpd crctd cpcxd cxd cpd cpd cxcrd cpd dacxd cpd cud crd cxd cpcqd ctba cxcvd ctd cpcrd cpd cpcscsd ctd ctd cpd crcpd ctcs cqcyctcrd cpd cpcsd cwct accrd cxd cwcpd ctcpcrcw cpd crcpd cxd cxd cvctd ctd cpd ctd cqcyctcrd cwcpd cpd cxd csctd ctd csctd cwd csd crctcs cpd cpd cwctd cpd crcpd cxd cxd ctb cpd cwctd cscxabctd ctd crct cqctd dbctctd cwct ctcrctd crddb cpcqd cpcrd cxd cpd cwct cpd crcpd cxd cxd cpcqd cpcrd cxd crd ctd cxcvcwd cccwct cpd crcpd cxd cxd cpcqd cpcrd cxd cxd ctd acdcctcs cpd cxd cxd cwct ctd cpd crcpd ctcs csctd cccwct ctcrctd crddb cpcqd cpcrd cxd cwcpd ctd cwct ckd cxd ctb cpd cxd cxd ctd cwcpd ctctd cxd cwct cwcpd ctb cpd cpd ddd cxd cpcqd cpcrd cxd cjbebeclba btd cabtbu csct ctd ctd ctd cxd csct cxd cpd cvcxdactd crd crd ctd ctd crd accvd cpd cxd dgd cpd ctd ddb cwct ctcrctd cpd crcpd ctcsd csct cpd cwct cpd crcpd cxd cxd ctba cvctd ctd cpd cwd dbctdactd cpd cpcqd cpcrd ctd crd accvd cpd cxd ctd ctd ctd cxd crd crd ctd ctd crd accvd cpd cxd cpd cvcxdactd cabtbu csct cvctd ctd cpd ctd ctd ctd cscxabctd ctd crd crd ctd csctd cxd cwct cscxabctd ctd crd crd ctd ctd crd accvd cpd cxd cpcrczctd cpd cscad cvcxd cjbdbgclcsctd crd cxcqctcp ctd cwd cwcpd ctd crcpd ctcpd cxd cvcpcqd cxd cscxdacxcsd cpd cwctcpd crcpd cxd cpd cwctd cwcpd cvd cqcpd ctcpd cxd cpcqd ctd cxd cwctcpd cpcqd cpcrb cxd ctd ctd crctb cwctdd cpd cxd csctd ctd csctd cpd cxcqd cpcqd cpcrd cxd ctcpcrcw ckd cpcrczctcs crcpd cxd aycxd cpcrczctcscxd csctd ctd csctd cwctd crcpd cxd cxd crd crd ctd ctd ctd crd accvd cpd cxd cccwct ctcrctd crddb cpcqd cpcrd cxd cxd cscxabctd ctd cxd csctd ctd csctd cpd cxcqd cpcqd cpcrd cxd cccwct crd cxd cud cpd cxd cabtbu csctd dbcpd cxd cxd ctcs cqdd cwct cwctcpd cpcqd cpcrd cxd chcpdad deb cpcwdactcrcx cpd bud cpd cjbebiclb dbcwcxcrcw cpd cpd cpcrcwctd ctd cxcr cxd cud cpd cxd cpd csctd crcwcpd cpcrd ctd cxdect cwct cqctd crd crd ctd csctd ctd ctd ctd ctcsba cccwct cxd cud cpd cxd cpd csct cpcqd cpcrd ctd crd accvd cpd cxd csctd crd cxcqctd cwct cqctd crd crd ctd csctd cwcpd cpd cpd ctcs cxd cpd crd crd ctd ctd crd accvd cpd cxd cwcpd ctd ctd ctd bzd cpd ctd cpd cjbdbdcl cpd cpd cpcrcw ctd cxcr cxd cud cpd cxd cpd csctd cwd dbctdactd crcw cxd cud cpd cxd csd ctd dacxcsct crcwcpd cpcrd ctd cxdecpd cxd cwct cqctd crd crd ctd csctd ctd ctd ctd ctcsbm cxd cqd cwct ctd ctd cpd ctd cpd cjbebiclb ctcpcrcw crd crd ctd csct cwcpd cxd crd cqcxd ctcs cxd cpd csct crd cxcqd ctd cwcpd cpcqctd cwct cpd csctbn cxd crd cpd dbcwctd crd crd ctd csctd cpd crd cqcxd ctcs cvctd cwctd cxd cwct cpd cpcrcw ctd ctd ctcs cxd cjbdbdclb cwct ctabctcrd cxd crd ctcpd ctd dacpd ctd dbcwcxcrcw cpd cpcscscxd cxd cpd ctd cxcr cpcqd cpcrd cxd cpdd cwctd cqct cpd cxctcsb bdbf cccwct cxdect cxd cud cpd cxd cabtbu csctd crcpd cqct cwd cvcwd cpd cpd cpcqd cpcrd cxd cpd dccxd cxcpd cxdect cxd cud cpd cxd cpd cpcrcwctcs ctcpcrcw crd crd ctd csctb dbcwctd cwct crd crd ctd cxdect cxd cud cpd cxd cxd cpcqd cpcrd ctcs cxd cwct ddd cjbdbdclba cbd cxcrd ctcpczcxd cvb cwct crd cpcqd cpcrd cwctcpd csctd cxctd cxcsct cwct cud cpd ctdbd czd cjbebecl cud cvd cpd cpd cpd ddd cxd cxd cvbfb dacpd ctcs cvcxcrb ctd cwct cud cpd ctdbd dbctd cqct ctdcd ctd csctcs dbcxd crd cxd cpd cxacctd cjbdbib cbctcrd bdbebabfclb dbctdactd cwct crd cxd cpd ctd cpd ctcs cwct cxd cpcrd cxdactbbcxd cpcrd cxdact cxd cscxdacxcsd cpd cxd cvcxcrcpd crd ctd cjbebdclb dbcwcxcrcw cwcpd cqctctd ctcs cxd cwct bfb dacpd ctcs cvcxcr cud cpd ctdbd cvcxdact crd cpcrd ctd ctd ctd cpd cxd cvcxcrcpd crd ctd cjbdbkb bvcwcpd bjclba cvctd ctd cpd cwct cpd cxd csctd ctd csctd cpd cxcqd ctd cwd cxd cwct cwctcpd cpcqd cpcrd cxd csctd crd cxcqctcs cxd dcbf dacxcsctd dbcpdd cpdad cxcs cwct crd cqcxd cpd cxcpd ctdcd cxd cwcpd cwct bfb dacpd ctcs cvcxcr cud cpd ctdbd abctd cud cwct bfb dacpd ctcs cvcxcr cud cpd ctdbd ctd cpcxd cwct ctd cpd cpd cvcxcrcpd crd ctd cud cscxabctd ctd crd cqcxd cpd cxd ctd ctd bbcpcqd ctd csctd dbcwctd ctcpd crd ctd cxd cwctd cqct crd cqcxd ctcsba cactcuctd ctd crctd bdba btd csctd ctd bucxd cscxd cvb cxd cpd cpd ddd cxd cpd cwct cpd cxd cxd ctd cpd bxdacpd cpd cbctd cpd cxcrd bucpd ctcs cvba cpd cxd bab cpcvctd bgbjdfbhbkb bdblblbfba beba bzba bucpd cpczd cxd cwd cpd cpd ccba cactd btd cpd dddecxd ctd cpcrcrctd ctd cxd dcbkbi ctdcctcrd cpcqd ctd bvd bvd crd bab cpcvctd bhdfbebfb bebcbcbgba bfba bzba bucpd cpczd cxd cwd cpd cpd ccba cactd cactcrd dactd dacpd cxcpcqd ctd cpd cwctcpd crd cxd dcbkbi ctdcctcrd cpcqd ctd ccctcrcwba cactd bdbhbfbfb bvd cbcrcxba bwctd bab cdd cxdaba cfcxd crd cxd cpcscxd cdcbbab cbctd ctd cqctd bebcbcbhba bgba bwbacaba bvcwcpd ctb cfctcvd cpd cpd byba cicpcsctcrczba btd cpd ddd cxd cxd ctd cpd crd ctd bwc cpcvctd beblbidfbfbdbcb bdblblbcba bhba bvcwctd cpd bwba cfcpcvd ctd cbbm btd cxd cud cpd crd cud ctdccpd cxd cxd ctcrd cxd ctd cxctd cud dbcpd ctba bvd cuba bvd cpd bvd cbctcrbab cpcvctd bebfbhdfbebgbgb dactd cqctd bebcbcbeba biba bubab bvba bvcwctd cpd cfbacfba dbd csd cpd cxd ctd crctcsd cpd cxd ctd cpd cpd ddd cxd cxd cpcrcrctd cpd cwd bwctd cxcvd cxd ctd ctd cpd cxd cpd ctdacpd cpd cxd bwc cpcvctd bhbjdfbiblb bebcbcbcba bjba bwcpd cdd cxaccrcpd cxd cqcpd ctcs cxd ctd cpd cpd ddd cxd dbcxd cscxd ctcrd cxd cpd cpd cxcvd ctd bwc cpcvctd bfbhdfbgbib bebcbcbcba bkba bwbacaba bxd cvd ctd buba bvcwctd cub btba 
bvcwd cpd cbba cpd ctd bvcwctcrczcxd ddd ctd ctd cxd ddd ctd ctcrcxaccrb cvd cpd ctd dbd cxd ctd crd cxd ctd ctdcd ctd cxd cbddd bwctd cxcvd cpd bab cpcvctd bddfbdbib bebcbcbcba blba bydjcpcwd csd cxcrcwb cactcwd cub cpd bwcpd cbcrcpd cpcqd crd ctdcd ctd cxd cxdact add cpd cpd ddd cxd cxd cxd cpd cxcpd cxd crd cpcxd bwc bebcbcbcba bdbcba bacbba byd ctd bydjcpcwd csd cxcrcwb cpd btba btcxczctd ddd cwcxcr dactd cwcxcr add dbb cxd ctd cxd cxdact cxd cpd cpd ddd cxd cud bvba cbbtcbb bebcbcbcba bdbdba bwba bzd cpd byba bwcxc cpcxd babwd ccba cactd cpd cbcpcvcxdaba ctd cxcr csd cpcxd dbcxd cpd cxdectcs cscxd ctd cxd ccd cpd btd cvd cud cwct bvd crd cpd btd cpd cbddd bab cpcvctd bhbdbedfbhbeblb bebcbcbgba bdbeba bwba bzd cpd ccba cactd cpd cbcpcvcxdaba cud cpd ctdbd cud ctd cxcr cpd cpd ddd cxd cpd cpdd ctd cpd cxd cpcvctd bfbfbkdfbfbhbcb bebcbcbhba bdbfba buba bzd bac bud cxcscvctd cbba ccd cxcpd cpcuddd cxd bzba cxb bxba cacpd cpd cpd bwbac btd cvd cpcrd cxcrcpd cpd cpcrcrd cpd dbb ctdactd cxd ctd cpd cpd ddd cxd bfd bxbxbxbbbtbvc cbddd bvd csct bzctd cpd bab cpcvctd beblbddfbfbcbeb bebcbcbhba bdbgba buba cpcrczctd cpd caba cad cvcxd cpba cactcvcxd cqcpd ctcs cwcpd cpd cpd ddd cxd dbcxd cpcrczctcs crcpd cxd cpcvctd bfbdbcdfbfbebfb bebcbcbhba bdbg bdbhba bwbtc cscxd cpd ctd cqd ctd cwd bmbbbbdbdbdbbacscpd cpd ctd crd ctbacrd bbcxcscpcqcpd ctbbba bdbiba ctd cpd bwctd crd cxd cxdact bvd ctdccxd ddba cbd cxd cvctd cectd cpcvb bdblblblba bdbjba babwba ctd cpd cbbacbba crcwd cxcrczba adctdccxcqd cpd cpcrcw cxd ctd crctcsd cpd cscpd add cpd cpd ddd cxd cpd cvd cpd dbcxd ctcrd cxdact cscpd crd ctd cpcvctd bibidfbjbgb bdblbkbeba bdbkba ccba ctdab btd cxba cccec btbm cud cpd ctdbd cud ctctd cqcpd ctcs cpd cxcr cpd cpd ddd cxd cpd ctd cwctd cxd ccctd btdacxda cdd cxdactd cxd ddb ccctd btdacxdab cpctd bebcbcbcba bdblba btba cxd cpd dacpb btba cad ctdab cpd bubabzba caddcsctd cpd cpd ctd ctd cxdectcs cqcyctcrd ctd cxd cxdacxd cud cxd cpd cpd ddd cxd cud cpdacpba ccc cbbxc bebcbcbhba bebcba cpd csct cpd buba caddcsctd bwcpd cpb add dbb cqcpd ctcs dacxd cpd cud crd cxd ctd cxd cbbtcbb cpcvctd bebfbkdfbebhbgb bdblblbiba bebdba cbba cpd cpcxcz cpd ctd cpd bwddd byc cpd cpd ctd csddd cpd cxcr crd ctdccxd crd cpd cbddd cxd crba bwcpd cpcqcpd cbddd bab bdblblbgba bebeba cbcpcvcxdab ccba cactd cpd caba cfcxd cwctd cpd cpd ctd cxcr cwcpd cpd cpd ddd cxd dacxcp bfb dacpd ctcs cvcxcrba ccd cpd cvba cpd cvba cpd cbddd bab bebgb bfb bmbebdbjdfbeblbkb bebcbcbeba bebfba cbcwcpd cxd cpd btba ctd cxba ccdbd cpd cpcrcwctd cxd ctd crctcsd cpd cscpd add cpd cpd ddd cxd cvd cpd byd btd cpd ddd cxd cccwctd cpd btd cxcrcpd cxd crcwcpd ctd bjb cpcvctd bdbkbldfbebfbgba ctd cxcrctb cpd bdblbkbdba bebgba buba cbd ctctd cvcpcpd csba cxd cpd cpd ddd cxd cxd cpd cxd ctcpd cxd ctba bdblblbiba bebhba cfcwcpd ctdd cpd cpd bvd cxd cvb cqcpd ctcs crd ctdcd ctd cxd cxdact cxd ctd cpd cxcpd cpd cpd ddd ctd cxd cqcxd cpd csctcrcxd cxd cscxcpcvd cpd bwc bebcbcbgba bebiba ccba chcpdad deb cpcwdactcrcx cpd ccba bud cpd btd cpd ctcs dactd cxaccrcpd cxd crd crd ctd cxd czctcs cxd dbcxd crd ctd cbbtcbb bebcbcbeba bdbh 

recovery variables heap structure executables gogul balakrishnan univ wisconsin bgogul wisc thomas reps univ wisconsin reps wisc abstract paper addresses problems arise analyzing executables recovering variable-like quantities absence symbol-table debugging information recovering information objects allocated heap introduction increasing tools programmers security analysts understand executables instance commercial companies military increasingly commercial off-the shelf cots components reduce cost software development interested ensuring cots components perform malicious actions forced perform malicious actions viruses worms ubiquitous tool aids understanding behavior ensure early dissemination signatures control extent damage caused domains questions answered answered perfectly problems undecidable static analysis answer conservatively past years considerable amount research activity develop analysis tools find bugs security vulnerabilities effort analysis source code issue analyzing executables largely security context unfortunate performing analysis source code fail detect vulnerabilities wysinwyx phenomenon execute mismatch programmer intends executed processor source-code fragment login program mismatch memset password len free password login program temporarily stores user password clear text dynamically allocated buffer pointed pointer variable password minimize lifetime password sensitive information code fragment shown zeroes-out buffer pointed password returning heap compiler performs uselesscode elimination reason program values written call memset call memset removed leaving sensitive information exposed heap hypothetical similar vulnerability discovered windows security push vulnerability invisible source code detected examining low-level code emitted optimizing compiler wysinwyx phenomenon restricted presence absence procedure calls contrary pervasive security vulnerabilities exist myriad platformspecific details due features idiosyncrasies compiler optimizer include memory-layout details offsets variables run-time stack activation records padding fields struct register usage iii execution order optimizations artifacts compiler bugs information hidden tools work intermediate representations irs built directly source code goal work advance state art recovering executables irs similar started source code expose platform-specific details discussed irs hand position leverage substantial body work analysis solve ir-recovery problem numerous obstacles overcome stem fact program data objects easily identifiable kinds potentially malicious programs symboltable debugging information absent case present relied reason designed techniques rely symbol-table debugging information present paper term executable means stripped executable understand memory-access operations executable determine set addresses accessed memory-access operation difficult memory operations explicit memory addresses instruction easy indirect addressing address expressions difficult arithmetic addresses pervasive instance local variable loaded slot activation record address arithmetic performed notion type hardware level address values distinguished integer values memory accesses aligned word-sized address values potentially cobbled misaligned reads writes difficult track flow data memory large address spaces today machines infeasible track statically contents memory address analysis source-code-analysis tools track flow data variables provide finite abstraction address space program observation suggests recover variable-like entities executable symbol-table debugging information set variablelike entities inferred words order scope ambitions assume executable analyzed standard compilation model executable procedures activation records global data region heap virtual functions dynamically linked libraries analysis check assumptions hold violations detected reported analysis proceeds generally making optimistic choice instance analysis finds return address modified procedure reports violation user proceeds modifying control flow program challenging obtain reasonable information heap simple abstractions heap assuming summary node malloc site provide information heap applied executables complex shape abstractions applied executables due scalability reasons presented combined pointer-analysis numericanalysis algorithm called value-set analysis vsa takes account pointer-arithmetic operations determines overapproximation set addresses accessed memory operand program version vsa presented partially meets challenges listed work idapro commercial dissassembler infer variable-like entities based statically-known addresses stack-frame offsets executable referred variable-like entities a-locs a-loc recovered idapro represent set contiguous locations represent non-contiguous memory locations locations instances specific field array structures inability idapro represent sets non-contiguous locations affects accuracy vsa clients vsa paper present algorithm combines vsa aggregate structure identification asi recover a-locs strictly idapro a-locs tracking flow data memory asi algorithm determines structure aggregates program based program accesses aggregates asi assumes data-access patterns readily apparent syntax program true instructions executables paper show information recovered vsa communicate data-access patterns asi combination vsa asi recover a-locs based indirect accesses memory explicit addresses offsets occur program identify structures arrays nestings structures arrays addition present abstraction heap middle extremes summary node malloc site complex shape abstractions context executables heap abstraction makes circumstances establish definite link set objects allocated site virtual-function table specific technical contributions paper show apply asi programming languages data-access patterns readily apparent syntax program present results applying approach executables replace idapro a-locs vsa refined notion a-loc provide algorithm interpret indirect memory refined notion develop abstraction-refinement algorithm based vsa asi infer executable variable-like entities granularity initial experiments show algorithm successful cases local variables cases variables allocated heap propose inexpensive abstraction heap-allocated data structures obtain results objects allocated heap show effectiveness abstraction measuring resolves virtual-function calls executables obtained code remainder paper organized detailed explanation fundamental challenges arise analyzing executables background vsa asi describes abstraction-refinement algorithm recover variable-like entities describes abstraction heapallocated data structures experimental results evaluating techniques app discuss related work challenges challenge recovering variable-like entities performing source-code analysis programmer-defined variables provide convenient handle program manipulates data data dependence statement statement represents fact defines variable x-def-free path captured fact statements access variable executables memory accessed absolute addresses directly indirectly address expressions form base index scale offset base index registers scale offset integer constants executables intrinsic entities analogous variables analysis step executable analysis recover variable-like entities crude variable-recovery algorithm provided idapro disassembler tool intuition idapro approach layout memory compile time assembly time compiler programmer decides priori locations local variables global variables direct accesses program variables absolute addresses offsets relative frame pointer absolute addresses offsets provide starting addresses program variables set addresses explicitly occurring addresses offsets considered variable-like entity referred a-loc abstract location disadvantage idapro variable-recovery algorithm considers addresses offsets occur explicitly program program disassembly shown void main int return proc main mov ebp esp esp mov ebpmov eax ebp mov eaxadd esp retn note laid offset located offset activation record main accessed relative frame pointer ebp buty accessed indirectly register eax idapro recovers a-loc eight-bytes offset explicit executable recover variable set values eax holds determined explicitly addresses stack-frame offsets determine variable-like entities challenge granularity recovered variable-like entities granularity variable-like entities recovered executable affects complexity accuracy subsequent analyses based recovered variable-like entities program shown follow convention esp beginning procedure marks start activation record typedef struct int 
point void main point ppx ppy return ppx proc main mov ebp esp esp lea eax ebpmov eax mov eax add esp mov eax ebpadd esp retn program initializes fields local struct pointer returns field observe executable eax plays role pointer instruction lea eax ebpis equivalent assignment eax ebpinstructions update fields statically offset program starting address idapro variable-recovery algorithm identifies a-loc eight-bytes covers fields flow-dependence analysis based a-loc create spurious flow-dependence instruction hand flow-dependence analysis performed a-locs correspond fields flow-dependence challenge structure heap-allocated objects performing source-code analysis structure heapallocated objects determined extent types pointers point block memory allocated heap executables symbol-table debugging information size allocated block knowing structure heap-allocated block information obtained heap desirable recover information structure heap-allocated data abstraction-refinement algorithm presented recover information structure heap-allocated objects summary object allocation site presents improved heap abstraction abstraction-refinement algorithm job challenge resolving virtual-function calls structure heap-allocated memory blocks abstraction summarize heap analysis strong updates illustrate problem programs inheritance virtual functions bytes object address virtual-function table source-code-analysis algorithms heap abstracted associating variable malloc site variable summarizes blocks memory allocated malloc site abstraction sufficient statically resolving virtual function calls illustrated fig instruction allocates block memory heap instruction sets virtual function pointer address virtual-function table constructor abstraction establish link object virtualfunction table heap variable represents block interpretation instruction sets virtual function pointer weak update join strong update overwrites contents abstract object represents definite change concrete objects abstract object represents strong updates generally performed summary objects concrete update affects summarized concrete objects virtual-function table address existing addresses overwrite virtual function pointer object address virtual-function table call malloc fields object shown computing join results definite link object virtual function table established figure weak update problem executables background previous work developed static-analysis algorithm called value-set analysis vsa recover information contents memory locations manipulated executable section describes vsa sets context techniques paper applied specifically section describes concepts abstract locations a-locs value-set analysis vsa aggregate structure identification asi material related core paper show information gathered vsa harness asi problem identifying a-locs richer class a-locs subsequent runs vsa typedef struct int point int main int point return proc main mov ebp esp esp mov ecx lea eax ebpl mov eax mov eax add eax ecx cmp ecx jll mov eax ebpadd esp retn figure program array structures program shown fig program initializes elements array x-members element initialized y-members initialized disassembly shown instruction updates x-members array elements instruction updates y-members fig shows variables laid activation record main square abstract locations a-locs analyzing programs source code associates information variables explicit notion figure layout activation record main a-locs identified idapro variable executable executable accesses memory addresses directly indirectly registers step analyzing executable recover set variable-like quantities section variablerecovery algorithm defined abstraction concrete runtime address space runtime address space separation activation records procedures heap memory global data analysis executable break address space set disjoint memory areas referred memory-regions memory-region represents group locations similar runtime properties runtime locations belong activation record procedure belong memory-region memory-regions global-region locations correspond global data ar-region locations belong activation record main recovered set variable-like entities memory-region method outlined challenge absolute addresses offsets provide starting addresses variable-like entities operand ebpin instruction lea eax ebprefers offset respect start activation record main similarly instruction mov eax ebprefers offset activation record main algorithm marks statically determined addresses offsets respective regions considers set locations static addresses offsets analog variable-like entity executable refers variable-like quantities a-locs terminology paper a-locs paper richer structure fig shows a-locs main ar-region value-set analysis vsa pointer-analysis algorithm important component program-analysis tool programs pointers pointer-analysis algorithms developed sourcecode analysis applicable analyzing executables algorithms typically ignore pointer arithmetic pointer arithmetic extensively executable instance direct access local variable performed dereferencing address calculated offset relative stack pointer frame pointer mov eax ebploads register eax local variable offset activation record procedure frame pointer ebp refers vsa algorithm pointer-analysis algorithm suitable executables vsa combined numericanalysis pointer-analysis algorithm determines overapproximation set numeric values addresses a-loc holds program point set addresses numeric values referred value-set key feature vsa tracks integer-valued address-valued quantities simultaneously crucial analyzing executables numeric values addresses indistinguishable executable suppose number regions executable valueset n-tuple strided intervals form component tuple representing set addresses region strided-interval represents set integers mod called stride called interval represents singleton set value-sets -tuples follow convention component refers set addresses numbers global region denotes empty set instance tuple represents set numbers tuple represents set offsets ar-region main vsa determines value-set eax program point means eax holds offsets ar-region procedure main note offsets starting addresses field elements array vsa flow-sensitive context-sensitive abstract-interpretation algorithm parameterized call-string length based independent-attribute domain proc denote set memory-regions procedures program allocmemrgn denotes set memory regions heap-allocation sites global denote memory-region global data area work basic domains memrgn global proc allocmemrgn valueset memrgn stridedinterval alocenv a-loc valueset vsa associates program point absmemconfig absenv register valueset global alocenv proc alocenv allocmemrgn alocenv absmemconfig callstring absenv aggregate structure identification asi ramalingam observed loss precision results computed static-analysis algorithm distinguish accesses parts aggregate cobol programs developed aggregate structure identification asi algorithm distinguish accesses showed results asi improve results dataflow analysis section briefly describes asi algorithm asi unification-based flow-insensitive algorithm identify structure aggregates program algorithm ignores type declarations aggregates considers aggregate sequence bytes length aggregate broken smaller parts depending accessed program smaller parts referred atoms data-access patterns program asi algorithm data-access constraint language dac syntax dac programs shown fig kinds constructs dac program dataref set sequences bytes means aspect abstract domain augmented data accessed program unifyconstraint means flow data program note direction data flow unifyconstraint considered unifyconstraint establishes flow data sequences bytes structure asi constraints dac program find coarsest refinement aggregates pgm epsilon unifyconstraint pgm unifyconstraint dataref dataref dataref progvars dataref int int dataref int figure data-access constraint dac language syntax int set non-negative integers int set positive integers progvars set program variables kinds data variable progvar refers bytes variable dataref refers bytes dataref refers bytes variable dataref interpreted dataref array elements dataref refers bytes statically indeterminate array element refers sequences bytes orp details asi algorithm provide intuition algorithm source-code program shown fig data-access constraints 
program shown const const return main constraints assume size point bytes laid constraint encodes initialization members dataref refers bytes correspond members array constraint corresponds return statement represents fact return main return procedure main assigned bytes corresponds result asi dag shows structure aggregate relationship atoms aggregate dag shown fig asi dag properties node represents set sequences bytes aggregate sequence bytes accessed array program represented array node array nodes labeled number array node represents number elements array array node child dag rooted child represents structure array element fig sequence bytes represented identified array -byte elements array element struct fields four-bytes sequence bytes accessed structure program represented struct node number struct node represents length structure children struct node represent fields structure fig sequence bytes identified struct fields scalars array nodes shared flow data program involving sequence bytes directly indirectly fig nodes sequence bytes return main shared return statement main similarly sequence figure asi dag program fig bytes correspond members array share node assigned constant instruction alternative results asi struct declaration shown struct int int struct int int main recovering a-locs iteration a-loc abstraction powerful represent arrays structs precisely sets field-instances array structs a-loc represent contiguous sequence memory locations memory-region internal substructure limitation idapro a-locs affect accuracy vsa clients vsa suppose procedure program local variables laid suppose compiler generates explicit accesses indirect accesses terms addresses case idapro identify -byte a-locs spans spans vsa update considered weak update value-set computed accurate desired atoms discovered asi algorithm similar locs expressive atoms represent non-contiguous sequences memory locations sets fieldinstances array structs atoms obtained a-locs value-set analysis a-locs defined instruction main main a-locs main sets overlap intermediate dependences connect transitively abstraction determines data dependent hope apply asi executable treating memory-region aggregate determining structure memory-region applying asi executables problematic requirements applying asi extract data-access constraints program applying asi cobol data-access patterns apparent syntax constructs consideration generating data-access constraints case executables instance memory operand eax represent access single variable elements array evident assembly programs shown earlier fortunately valuesets provide information generate data-access constraints recall value-set over-approximation set offsets memory-region information generate data-access constraints executable section show atoms asi trees obtained asi place idapro a-locs vsa asi trees initially a-locs identified idapro round vsa trivial represent structure induced idapro a-locs memory region asi tree fig shows asi tree memory-region assumed sequence bytes length -bit machine negative offsets memory-region correspond offsets aggregate non-negative offsets memory-region correspond offsets aggregate ret addr offset var offset var offset aggregate main nodes labeled localguard formalguard represent out-of-bounds areas activation record main access symbols flagged vsa memory-access violation figure asi tree constructed idapro a-locs round value-set analysis carried results value-set analysis basis running asi results asi refine set a-locs vsa run carried rounds desired occur process illustrated fig asi heuristic find a-locs vsa generate data-access constraints memory accesses program asi unification-based algorithm generating data-access constraints kinds instructions leads undesirable results discusses cases abstraction-refinement principles summarized vsa obtain memory-access patterns executable asi heuristic determine set a-locs memory-access patterns obtained information recovered vsa important understand vsa generates sound results data-access patterns account previous round asi asi replacement value-set analysis asi applied executables information obtained value-set analysis value-sets propagating types parameters library calls asi obtain source-level types a-locs rest section describe interplay vsa asi show value-sets generate data-access constraints input asi atoms asi trees round vsa a-locs generating data-access constraints value-sets section describes algorithm generates asi datareferences memory operands indirect operands form indirect operands form base index asi trees obtained dag duplicating shared nodes figure iterating asi vsa identify a-locs scale offset gain intuition algorithm operand eax instruction value-set eax stride interval activation record main evidence eax access elements array -byte elements range activation record main array access generated operand recall value-set n-tuple strided intervals strided interval component represents offsets memory-region alg shows pseudocode convert offsets memory-region asi asi takes memory-region strided interval number bytes accessed length arguments length parameter obtained instruction length eax instruction four-byte data transfer algorithm returns pair component asi component boolean significance boolean component algorithm works singleton asi accesses offsets length aggregate memory-region ifs singleton offsets represented treated array size array element stride length length overlapping set locations accessed indirect memory-operand overlapping set locations represented asi algorithm chooses length size array element problem soundness subsequent rounds vsa refinement principle boolean component pair denotes algorithm generated exact asi number elements array length interval divided size operands form set asi generated invoking alg non-empty memory-region value-set value-set eax set asi main memory-region global set offsets region empty typical indirect operands form base index scale offset access two-dimensional arrays note scale offset statically-known constants abstract values strided intervals absorb scale offset base index loss generality discuss memory operands form base index assuming twodimensional array stored row-major format registers base holds starting addresses rows register index holds indices elements row base index refers elements two-dimensional array alg shows algorithm generate asi set offsets memory-region expressed sum strided intervals base index note alg computing abstract sum strided intervals results loss precision strided intervals represent single stride offsets dataref negative negative offsets paper ease understanding negative offsets mapped range non-negative offsets mapped range alg works determines strided intervals base apparent representation operand strided interval base stride greater length interval strided interval roles strided intervals established algorithm generates asi base asi index indirect memory operand eax ecx suppose value-set ecx value-set eax length eax index ecx base asi generated cases algorithm establish strided intervals base cases algorithm computes abstract sum strided intervals invokes asi algorithm asi algorithm convert strided interval asi input memory-region strided interval number bytes accessed length output pair component asi sequence length bytes starting offsets memory-region component boolean represents asi exact true approximate false singleton return length true size max length ceilingleft size sizeceilingright ref size size return ref size end algorithm algorithm convert set offsets represented sum strided intervals asi input memory-region strided intervals number bytes accessed length output asi sequence length bytes starting offsets memory region singleton return asi length end length basesi indexsi length basesi indexsi return asi size end baseref exactref asi basesi stride basesi exactref 
false return asi length return concat baseref asi indexsi length end interpreting indirect memory-references section describes lookup algorithm finds set locs accessed memory operand lookup algorithm interpret pointer-dereference operations vsa instance assembly instruction mov eax vsa lookup algorithm determine a-locs accessed eax value-sets a-locs updated algorithm determine set a-locs value-set trivial memory-region consists linear list idapro a-locs asi performed structure memory-region asi tree ramalingam present lookup algorithm retrieve set atoms asi expression lookup algorithm vsa algorithm assumes asi expressions arise lookup atomization phase case vsa reasons asi heuristic discussed data-access patterns arise vsa atomization phase executable possibly access fields structures broken atoms initial round asi based idapro information include accesses fields structures round vsa access structure fields tree obtained fig describe lookup algorithm tree shown fig node tree unique shown parentheses terms describing lookup algorithm nodedesc descriptor part asi tree node denoted pair length asi tree node length length nodedesclist ordered list nodedesc descriptors nodedesclist represented nodedesclist represents contiguous set offsets aggregate nodedesclist represents offsets node offsets offsets lookup algorithm traversal asi tree guided asi memory operand memory operand converted asi algorithm resulting asi parsed list asi operations kinds asi operations getchildren aloc getrange start end getarrayelements list asi operations getchildren getrange getarrayelements getrange operation takes nodedesclist argument returns set nodedesclist values operations performed left argument operation results operation immediately left a-locs accessed a-locs final set nodedesc descriptors getchildren aloc operation returns nodedesclist nodedesc descriptors children root node tree aggregate aloc getrange start end returns nodedesclist nodedesc descriptors representing nodes offsets range start end getarrayelements treats nodedesclist array elements returns set nodedesclist lists nodedesclist list represents array element nodedesclist array elements array split atomization phase parts array represented nodes examples discuss traces lookups figure asi tree fig node shown parenthesis lookup getchildren getrange getchildren returns nodedesclist applying getrange returns describes offsets nodedesclist loc accessed square lookup getchildren getrange getarrayelements getrange concentrate getarrayelements operations similar getarrayelements applied total length nodedesclist number required array elements size array element intuitively getarrayelements unrolls nodedesclist creates nodedesclist unique n-bytes starting left length array element unrolled nodedesclist set unique -byte nodedesclist lists square lookup getchildren getrange getarrayelements getrange shows slightly complicated case getarrayelements operation unrolling results distinct representations -byte array elements square pragmatics asi takes account accesses data transfers involving memory finds partition memory-regions consistent transfers standpoint accuracy vsa clients beneficial account accesses reasons vsa obtain conservative estimate valueset register cases value-set latticetop meaning register possibly hold addresses numbers memory operand generate asi refer memory-region array -byte elements compilers initialize local stack frame aid debugging uninitialized variables runtime instance versions microsoft visual studio compiler initialize bytes local stack frame compiler initialization memcpy generating asi mimic memcpy memory-region procedure broken array -byte elements desirable deal cases provide options user tune analysis user supply integer threshold cardinality value-set register threshold asi generated memory operand involving user supply set instructions asi generated user supply explicit asi convergence round vsa uncovers memory accesses explicit program results refinement a-locs round vsa round vsa produces precise value-sets based set a-locs similarly subsequent rounds vsa uncover memory accesses refine a-locs round vsa produces precise value-sets process stabilizes iterations vsa results change round cases value-sets obtained vsa worse value-sets obtained previous round cases iteration indefinitely ensure termination limiting iteration number rounds user asi heuristic vsa number iteration rounds affect soundness results vsa abstraction heap-allocated storage great deal work algorithms flowinsensitive points-to analysis including algorithms exhibit varying degrees context-sensitivity aforementioned work simple abstraction heap-allocated storage call allocation-site abstraction nodes allocated allocation site folded single summary node terms precision allocation-site abstraction produce poor-quality information allocation site loop function called allocate multiple nodes addresses points-to fact points means program variable point nodes represents assignment form selector points-to-analysis algorithms ordinarily forced perform weak update selector edges emanating nodes points accumulated imprecisions snowball additional weak updates performed assignments form selector selector weak updates adverse effects points-to-analysis algorithm determine properties heap-allocated data structures multiple summary nodes allocation site summary node qualified amount calling context overcome problem algorithms perform weak updates extreme family heap abstractions introduced discover information shapes heap-allocated data structures program pointer variables point abstractions generally strong updates performed capable providing precise characterizations programs manipulate linked data structures methods costly space time remainder section describes abstraction heapallocated storage called recency abstraction lies extremes allocation sites arise source code call class virtual methods recency abstraction generally permits vsa asi recover information virtual-function tables recency abstraction similar respects allocation-site abstraction abstract node allocation site recency abstraction memory-regions allocation site allocmemrgn mrab nmrab allocation site mrab represents most-recently-allocated block allocated block concrete configuration mrab summary memory-region nmrab represents blocks allocated blocks concrete configuration nmrab generally summary memory-region addition mrab nmrab allocmemrgn count denoted mrab count nmrab count type smallrange count records range concrete blocks memory-region represents nmrab count smallrange mrab count restricted values conditions abstract transformer perform strong update a-loc mrab addition count mrab nmrab allocmemrgn size denoted mrab size nmrab size type stridedinterval size represents over-approximation size block information report memory-access violations involve heap-allocated data work basic domains memrgn global proc allocmemrgn valueset memrgn stridedinterval alocenv a-loc valueset smallrange analysis associates program point absmemconfig allocabsenv smallrange stridedinterval alocenv absenv register valueset global alocenv proc alocenv allocmemrgn allocabsenv absmemconfig callstring absenv memory-regions mrab nmrab set a-locs refined asi count size alocenv denote smallrange stridedinterval alocenv allocmemrgn absenv absenv maps allocation memory-regions mrab nmrab count size alocenv triples transformers operations defined entry point program absmemconfig describes initial state records allocation site alocenvs mrab nmrab code return values passed back register eax size denote size block allocated allocation site size obtained value-set parameter allocation method transformer allocation site transforms absenv absenv prime absenv prime identical absenv valuesets absenv mrab mapsto nmrab mapsto nmrab mapsto unionsq absenv prime addition absenv prime updated arguments absenv prime mrab size a-loc latticetop valueset absenv prime nmrab count absenv nmrab count absenv mrab count absenv prime nmrab size absenv nmrab size unionsq absenv mrab size absenv prime nmrab alocenv absenv nmrab alocenv unionsq absenv mrab alocenv absenv prime eax mrab mapsto present implementation assume allocation succeeds place line absenv 
prime mrab size a-loc latticetop valueset analysis explores behavior system executions allocations succeed join absenv unionsqabsenv absenv absenv absenv performed pointwise absenv prime mrab absenv mrab unionsq absenv mrab absenv prime nmrab absenv nmrab unionsq absenv nmrab abstract transformers assignments data movements interpretation conditions asi mrab nmrab treated memory regions global ar-regions exceptions phase generates data-access constraints executable asi instruction generated equate mrab nmrab end set a-locs structure vsa abstract transformers passed memoryregion status map memory-regions context call-string suffix summary memoryregions global region non-summary decide procedure memory-region summary memory-region call-string traversed call graph traversed runtime stack multiple pending activation records summary-status information mrab nmrab obtained differently values absmemconfig mrab count absmemconfig nmrab count memory-region status map pieces information identify strong update performed abstract transformer perform strong update operation modifies register a-loc non-summary memory-region mrab mrab fgfgfg malloc ile mrab nmrab nmrab fgfgfg mrab malloc ile mrab nmrab nmrab fgfgfg mrab malloc ile mrab nmrab nmrab fgfgfg mrab malloc ile figur trace olution parts absen instructions loop xample fig sho trace olution parts absen instructions loop round vsa asi identified a-locs memory-re gions mrab nmrab sho rectangles mrab nmrab double box nmrab objects fig summary memory-re gions bre vity fig fect instruction denoted syntax original source code loop body statement class virtual methods symbols fig represent addresses methods symbol fields represent a-locs global gion dotted lines fig alue nmrab malloc statement depends alue mrab nmrab malloc statement absen stabilize iterations note fig established instruction modifies xactly a-loc non-summary memoryre gion strong update performed establishes definite link mrab nmrab square experiments section describes results preliminary xperiments sho characteristics set xamples aluation programs originally ande ryder aluate algorithm resolving virtualfunction calls programs programs compiled optimization microsoft isual studio compiler obj files obtained compiler ananote unoptimized programs generally memory accesses represent greater challenge optimized programs lyzed numbers column labeled rounds number asi-vsa iterations alue-sets obtained vsa stabilized started deteriorate column labeled erage discussed belo results virtual-function call esolution sho results applying vsa resolv virtual-function calls column labeled sho number unreachable indirect call-sites column labeled latticetop denotes number reachable indirect call-sites vsa determine tar columns sho distrib ution number tar indirect call-sites non-zero alue latticetop -column means vsa resolv indirect calls ecutables vsa reports call-sites user xplore procedures call-site erage column sho fraction ecutable code analyzed vsa note programs latticetop -column erage reported -approximation actual runtime erage runs ecutable programs non-zero alues latticetop -column erage metric reported -approximation programs alue latticetop -column number unreachable calls approximation instance calls flagged unreachable -column deriv unreachable algorithm resolv virtual-function calls call-sites xamined indirect call-sites vsa resolv found vsa correctly resolv tar calls important realize virtual-function calls resolv solely tracking flo data memory including heap analysis algorithm rely symbol-table deb ugging information vsa resolve indirect call-sites establish elements array initialized loop problem programs array pointers objects initialized loop pointers invoke virtual-function call vsa successful determining addresses elements array establish elements array initialized instruction loop values pointers array remain latticetop cfgs icalls coverrounds time insts age primes family vcirc fsm office trees deriv chess objects simul greed shapes ocean deriv table characteristics programs coverage denotes part program reachable analysis rounds denotes number asi-vsa rounds results stabilized results a-loc identification evaluate results abstraction-refinement algorithm compared results algorithm debugging information constructed asi tree activation record program debugging information determined number leaves similar structure asi tree obtained debugging information obtained abstraction-refinement algorithm results shown fig average abstraction-refinement algorithm determines structure local variables correctly similar evaluation structure heap-allocated data objects results shown fig heap abstraction-refinement algorithm determines structure objects correctly compared structure memory blocks summarized reachable allocation-sites debugging information abstraction-refinement algorithm information blocks related work work analyzing memory accesses executables previous techniques deal memory accesses conservatively generally register assigned memory assumed instance basic goal algorithm proposed debray similar vsa goal find over-approximation set values register hold program point find over-approximation set values abstract data object hold program point data objects include global stack-allocated heap-allocated memory locations addition registers analysis proposed latticetop primes family vcirc fsm office trees deriv chess objects simul greed shapes ocean deriv table distribution number callees indirect call figure percentage locals results asi matched debugging information figure percentage heap-allocated structure results asi matched debugging information debray set addresses approximated set congruence values track low-order bits addresses unlike vsa algorithm make effort track values registers loses great deal precision load memory cifuentes fraboulet give algorithm identify intraprocedural slice executable program use-def chains algorithm makes attempt track values registers cuts short slice load memory encountered pieces work closely related vsa algorithm data-dependence analysis assembly code amme algorithm pointer analysis lowlevel intermediate representation guo algorithm amme performs intraprocedural analysis clear algorithm fully accounts dependences memory locations algorithm guo partially flow-sensitive tracks registers flow-sensitive manner treats memory locations flow-insensitive manner algorithm partial transfer functions achieve contextsensitivity transfer functions parameterized unknown initial values uivs clear algorithm accounts possibility called procedures corrupting memory locations uivs represent identification structures aggregate structure identification devised ramalingam partition aggregates cobol program memory-access patterns similar algorithm devised eidorff incorporated annodomani system original motivation algorithms year problem provided identify date-valued quantities flow program mycroft gave unification-based algorithm performing type reconstruction instance register dereferenced offset perform -byte access algorithm infers register holds pointer object -byte field offset type system disjunctive constraints multiple type reconstructions single usage pattern work pointer analyses recency abstraction similar flavor allocation-site abstraction abstract node allocation site recency abstraction designed advantage fact vsa flow-sensitive context-sensitive algorithm note recency abstraction flowinsensitive algorithm provide additional precision allocation-site abstraction flow-insensitive algorithm abstract memory configuration expresses program-wide invariant algorithm perform weak updates assignments mrab nodes assignments nmrab nodes edges emanating mrab node accumulated flow-sensitive algorithm recency abstraction abstract nodes allocation-site abstraction conditions sound algorithm perform strong updates assignments mrab nodes crucial establish definite link set objects allocated site virtual-function table hackett rugina describe method local reasoning individual heap locations global reasoning entire heap abstractions essence independentattribute abstraction tracked location tracked independently locations concrete memory configurations recency abstraction independent-attribute abstraction count information mrab nodes inspired heap abstraction yavuz-kahveci bultan attaches numeric information summary nodes characterize number 
concrete nodes represented amme braun zehendner thomasset data dependence analysis assembly code int parallel proc andersen binding-time analysis taming pointers part eval semantics-based prog manip pages balakrishnan reps analyzing memory accesses executables comp construct pages bergeron debbabi desharnais erhioui lavoie tawbi static detection malicious code executable programs drawbacks mentioned acknowledged conversations authors papers int req eng chase wegman zadeck analysis pointers structures pldi pages cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation pldi pages cifuentes fraboulet intraprocedural static slicing binary executables int conf softw maint pages cifuentes simon fraboulet assembly high-level language translation int conf softw maint cooper kennedy interprocedural side-effect analysis linear time pldi pages das unification-based pointer analysis directional assignments pldi pages debray muth weippert alias analysis executable code popl pages eidorff henglein mossin niss rensen tofte annodomini type theory year conversion tool popl pages ahndrich rehof das scalable context-sensitive flow analysis instantiation constraints pldi foster ahndrich aiken polymorphic versus monomorphic flow-insensitive points-to analysis sas guo bridges triantafyllis ottoni raman august practical accurate low-level pointer analysis ieee acm int symp code gen opt pages hackett rugina region-based shape analysis tracked locations popl pages howard bad news good news msdn october http msdn microsoft library default asp url library enus dncode html secure asp idapro disassembler http datarescue idabase jones muchnick flexible approach interprocedural data flow analysis programs recursive data structures popl pages lal reps balakrishnan extended weighted pushdown systems computer aided verif larus schnarr eel machine-independent executable editing pldi pages milanova rountev ryder parameterized object sensitivity points-to analysis java tosem uller-olm seidl analysis modular arithmetic esop mycroft type-based decompilation esop pande ryder data-flow-based virtual function resolution sas pages ramalingam field tip aggregate structure identification application program analysis popl rival abstract interpretation based certification assembly code int conf verif model checking abs int sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst sharir pnueli approaches interprocedural data flow analysis program flow analysis theory applications chapter pages prentice-hall srivastava eustace atom system building customized program analysis tools pldi steensgaard points-to analysis almost-linear time popl whaley lam cloning-based context-sensitive pointer alias analyses binary decision diagrams pldi wilson lam efficient context-sensitive pointer analysis programs pldi yavuz-kahveci bultan automated verification concurrent linked lists counters sas additional related work work analyzing executables platforms created manipulating executables presence additional information source code symbol-table information debugging information including atom eel bergeron present static-analysis technique check executable debugging information adheres userspecified security policy rival presents analysis abstract interpretation check assembly code program produced compiler possesses safety properties source code analysis assumes source code debugging information source code assembly code program analyzed debugging information map results assembly-code analysis back source code results program points source assembly code compatible assembly code possesses safety properties source code identification structures mycroft algorithm type-based decompilation weaknesses due absence kinds information addressed information obtained techniques paper mycroft explains simplifications triggered interprocedural side-effect information information computed methods presented paper hand interprocedural side-effect information computed standard techniques mycroft algorithm unable recover information sizes arrays identified paper implementation incorporates analysis phase called affine-relation analysis ara program point identifies affine relations hold values registers essence information induction-variable relationships loops turn vsa recover information array sizes register sweep array control loop-index register mycroft stride information basic abstract domain vsa based strided intervals mycroft excludes consideration programs addresses local variables unclear address-taken object ends struct size bytes coincidentally contiguously allocated int hard distinguish struct bytes problematic restriction decompiler common idiom programs addresses local variables frequently explicit arguments called procedures programmers simulate call-by-reference parameter passing java compilers addresses local variables implement call-by-reference parameter passing methods presented paper provide information usage patterns pointers stack mycroft techniques applied presence pointers stack interesting make mycroft techniques conjunction techniques paper decompilation past work decompiling assembly code high-level language related work decompilers reported literature limited translating assembly code high-level code instance cifuentes work primarily concentrates recovery expressions instruction sequences control flow shortcomings previous decompilers caused fact incorporate methods recover information memory accesses memory-accessanalysis methods paper performed prior decompilation proper recover information numeric values address values physical types definite links objects virtual-function tables 
abstract error projection akash lal nicholas kidd thomas reps tayssir touili wisconsin madison wisconsin usa akash kidd reps wisc liafa cnrs paris paris france touili liafa jussieu abstract improve reporting results model checking programanalysis systems introduce notion error projection annotated error projection error projection set program nodes node exists abstract error path program entry target node annotated error projection associates node error projection abstract counterexample validates error abstract store presence induces error present algorithms computing annotated error projections discuss additional applications algorithms experiments show error projections computed efficiently introduction model checking popular technique program verification feet model checker extracts program model finite abstraction performs reachability model reports back results user form counterexample failed run technique shown finding program errors verifying properties programs implemented number model checkers including slam blast magic goal extend capabilities model checkers return relevant information found reachability check accomplish reporting error projections error projection set original program nodes node exists abstract error path program model entry point passes abstract node error projection sound respect program abstract model important feature error projections error projection describes nodes members paths lead error point model automated program-analysis tool human debugger focus efforts nodes error projection node error projection correct respect property verified view error projection dividing program parts correct incorrect respect verification property annotated error projections extension error projections annotated error projection adds node error projection annotations counterexample passes set abstract stores describes conditions program fail goal give back user automated tool human debugger information discovered model-checking process note counterexamples useless abstract debugging cases user information provided counterexamples programmer debug large piece software unfamiliar code counterexamples parts code considered fixing bug algorithms present provide programmer ability counterexample passes specific program node annotated error projections forced counterexamples chosen arbitrarily tool theoretical standpoint error projection solves combination forward backward analyses forward analysis computes set program nodes program states reachable program entry backward analysis computes set program nodes states reach error pre-specified nodes error projection intersection sets computed analyses paper give algorithm computing interprocedural error projections automata-theoretic construction algorithm based weighted pushdown systems wpdss contributions paper summarized define notions error projection annotated error projection prove sound respect program abstraction model checking give combination forward backward analyses multiprocedural programs computing error projections show algorithm applicable settings specifically model checking concurrent programs restricted conditions experiments show efficiently compute error projections remainder paper organized motivates difficulty computing annotated error projections presents definitions weighted pushdown systems weighted automata give algorithms computing error projections annotated error projections presents initial experiments covers applications algorithms discusses related work correlation problem motivate work discussion correlation problem fig nodes labeled source target nodes set nodes labeled represents reachable configurations defined program node program counter labeled edges represent abstract transformers summarize paths assume program abstraction rule invalid paths due correlated branches path non-executable purpose discussion assume included error projection configurations lie executable path naive approach computing error projection compute joinover-all-paths jop unionsq composed jop unionsq approach fig yield unionsq unionsq counterexample error projection program slice int foo int assert complex return int bar int len int arr int switch len arr case foo arr case foo arr case foo arr return int main bar int foo int assert complex return int bar int len int arr int switch len arr case foo arr case foo arr case foo arr return int main bar int foo int assert complex return int bar int len int arr int switch len arr case foo arr case foo arr case foo arr return int main bar table bar called abstract array column highlights counterexample returned model checker column highlights error projection column highlights program statements obtained backward slice assert statement error projection compared program slicing unionsq unionsq unionsq includes cross terms abstract domain approach erroneously concludes error projection precise solution correlation problem over-approximate transformers computes transformers pass program node intraprocedural case correlation problem program node single configuration interprocedural case number configurations infinite enumeration provide solution solving correlation problem requires symbolic techniques cns fig correlation problem key technical contribution work symbolic approach solves correlation problem standard techniques starting point program control flow modeled pushdown system possibly-infinite sets configurations represented finite automata incorporate dataflow information augmenting pushdown system weight domain automata weighted desired result kind intersection weighted automata represent forward backward reachability relations knowledge previously algorithm solving problem solve problem construction automaton preliminary definitions compute error projections weighted pushdown systems wpdss section presents background material wpdss pushdown systems definition pushdown system pds triple finite set states finite stack alphabet finite set rules configuration pair pushdown rules define transition relation configurations arrowhookleft pprime prime pprime primeu reflexive transitive closure denoted set configurations define pre cprime cprime post cprime cprime loss generality restrict pds rules stack symbols right-hand side pds capable encoding control flow program procedures stack pds simulates run-time stack program stores return addresses unfinished procedure calls current program location top stack procedure call modeled pds rule stack symbols right-hand side pushes return address stack giving control called procedure procedure return modeled pds rule stack symbols right-hand side pops top stack returns control address top stack pds transition relation captures paths program matched calls returns details encoding programs pdss found number configurations pds unbounded finite automata describe infinite sets configurations definition pushdown system p-automaton finite automaton finite set states transition relation set initial states set final states automaton configuration accepted p-automaton automaton accept started state written set configurations regular p-automaton accepts important result regular set configurationsc bothpost pre regular sets configurations algorithms computing post pre p-automaton input set existing literature weighted automata assumes extend operation composition commutative restriction satisfied program abstractions configurations accepted produce automata apost apre accept set configurations post pre rest paper configuration sets regular weighted pushdown systems weighted pushdown system wpds pds augmented weight domain bounded idempotent semiring weight domain describes abstraction algebraic properties definition bounded idempotent semiring quintuple set elements called weights elements combine operator extend operator binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order subsetsqequal defined subsetsqequal infinite ascending chains abstract-interpretation terminology weights thought abstract transformers transformer composition join 
wpds program pds augmented abstraction weights thought abstract model program definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule sequence rules associate pval configurations cprime rule sequence transitions cprime cprime reachability problems pdss generalized wpdss definition wpds regular sets configurations join-over-all-paths jop defined circleplustext pval pds wpds boolean weight domain rules jop iff configuration reach configuration important weight domain set binary relations finite set definition finite set relational weight domain defined semiring set binary relations union relational composition empty set identity relation domains describing finite abstractions predicate abstraction abstraction boolean programs finite-state safety properties short discussion found predicate abstraction fixed valuation predicates turn represents memory configurations valuation holds weights transformations states represent abstract effect executing program statement readers aware wpdss weight domain represented pdss expanding pds state space elements advantage wpdss weights symbolically encode transition relations predicate abstraction predicates set elements impractical explicit pds rules transitions relations sets represented succinctly bdds represent weights rules essence schwoon moped system solving jop wpdss algorithms finding jop called poststar prestar based forward backward reachability algorithms operate weighted automata defined definition weighted pushdown system automaton p-automaton transition automaton labeled weight weight path automaton obtained taking extend weights transitions path forward backward direction depending context automaton automaton accept configuration weight written combine weights accepting paths starting state automaton call automaton backward w-automaton weight path read backwards forward w-automaton simplicity call w-automaton weighted automaton poststar algorithm takes backward weighted automaton input produces backward weighted automaton apost apost circleplustext cprime pval cprime similarly prestar algorithm takes forward weighted automaton input produces apre apre circleplustext pval cprime cprime important algorithm reading weights weighted automata called path summary defined path summary briefly outline algorithm forward weighted automaton based standard fixpoint-finding algorithm associates weight state initialize weight non-initial state initial state add initial state worklist repeatedly prestar poststar algorithms originally defined unweighted automata input configuration accepted algorithms work weighted automata defined remove state worklist propagate weight forwards transition qprime weight update weight state qprime qprime qprime weight qprime add worklist repeated worklist empty path summary combine final state path summary calculate circleplustext unweighted automaton accepts intersect obtain weighted automaton aprime easy path summary aprime solve jop unweighted automata accept setss andt jop poststar prestar computing error projection define error projection wpdss model programs wpds created program single pds state case states pushed inside weights singlestate wpds simplify discussion pds configurations represented stacks concern assertion checking assume target set control configurations program model exhibits error reach configuration set accomplishing convert assertion form assert condition goto error assuming expressible current abstraction instantiate set configurations error error assume weight abstraction constructed path pds infeasible weight pval model program error reach configuration path nonweight formally define error projection definition set starting configurations program target set configurations program node error projection exists path pval negationslash calculate error projection computing constrained form join-over-all-paths call weighted chopping query definition regular sets configurations source target chop weighted chopping query compute weight circleplustext easy negationslash short call weighted chopping query simply chopping query show solve queries intersection weighted automaton unweighted carried unweighted automata weights weighted automaton copied resultant automaton note negationslash jop jop correlation problem attempt solving weighted chopping identity circleplustext jop jop works finite set configurations case compute error projection solve problem automata-theoretic constructions previous section unweighted automaton represents set similarly algorithms columns valid ways solving weighted chopping query poststar poststar path summary prestar prestar path summary running time proportional size size set represented proof correctness appendix error projection computed separate weighted chopping query node program means source set target set remain fixed chop set changing algorithms major shortcoming respective steps carried chopping query rest steps recomputed node shown approach slow algorithm discussed orders magnitude faster derive algorithm weighted chopping suited computing error projections unweighted case weighted case weight domain weights post pre negationslash procedure requires single intersection operation chop sets computation post pre main difficulty extending approach case general weights algorithm intersecting weighted automata address issue introduce key theoretical contribution paper define intersecting weighted automata weighted automata define intersection function configurations weights compute form weighted automaton define circleplustext based definition apost poststar apre prestar apost apre give intuition intersecting weighted automata hard intersection defined read weight notethattheoperatora notcommutativeisgeneral butwestillcallit intersection construction resembles intersection unweighted automata extend weight naive approach construct weighted automaton concatenation epsilon transitions final states initial states computing regular set requires computing join-over-all-paths set paths accept language path language regular context-free method computes join-over-all-paths non-context-free set paths trick recognize weighted automata direction weights read intersect apost apre apost backward automaton apre forward automaton concatenate reverse reverse transitions switch initial final states purely backward weighted automaton solve join-over-all-paths language written reverse order language defined context-free grammar production rules form non-terminals section intuition derive algorithm intersecting weighted automata intersecting weighted automata backward weighted automaton forward weighted automaton proceed standard automaton-intersection algorithm construct automaton abf identify state p-states abf states form transitions automaton computed matching stack symbols transition weight transition weight add transition tbf abf weight call type weights functional weights capital letter possibly subscripted distinguish normal weights functional weights special functions weights weight functional weight automaton abf called functional automaton define extend functional weights reversed function composition functional weight natural combine operator defined preserve form functional weights functional weights form semiring show handicap compute required abf product automaton path form one-to-one correspondence paths inab easy weight path abf function form weights paths sense abf constructed based intuition previous section functional weights resemble grammar productions language weights replacing occurrences composition resembles derivation string language note letter letter general letters weights formally configuration weighted automaton define predicate accpath true accepting path weight false note extend operation compute weight path similarly accpath true iff accpath true circleplustext accpath accpath circleplustext accpath abf circleplustext accpath abf circleplustext accpath abf similarly circleplustext accpath abf circleplustext accpath abf unweighted automaton accepts set obtained procedure similar path summary advantage defined abf intersect ordinary intersection run path summary show functional weights distribute ordinary weights path summary abf obtained solving intraprocedural join-over-all-paths distributive transformers starting weight completely standard initialize initial 
states set states fixpoint reached transition qprime weight update weight state qprime qprime qprime path summary abf combine weight final states termination guaranteed weights states functional weights monotonic properties satisfied abf abf representation function solve apost apre preparation step create apost apre solve chop sets intersection path summary shown noted technique applies intersection forward weighted automaton backward case problem computing join-over-all-paths noncontext-free set paths aware algorithms intersecting forward backward automata problems remain open computing annotated error projection annotated error projection adds information error projection associating node error projection counterexample node set abstract stores memory descriptors arise path doomed fail future consistent wpds terminology term witness synonym counterexample finding witnesses helps accelerating computation error projection computing witnesses source set target set previous work wpdss computation finite set paths called witnesses pval jop result holds path summary weighted functional automata find finite set paths automaton justifies weight returned path summary set paths justifies weight combine weights equal make technology section calculating error projection find error projection negationslash unweighted automaton represents apost apre path summary witness generation find path weight path automaton corresponds configuration negationslash turn implies path wpds nonweight standard witness generation find set witness jop set witnesses jop concatenation witnesses justifies jop jop negationslash concatenation constant-time operation witness set represented dag witnesses path nonweight serves desired witness node procedure repeated node error projection finding witnesses expensive operation adds fair amount overhead execution poststar prestar worst-case running times change optimization witnesses obtain witness node error projection node prime configuration prime occurs prime error projection computing error projection find error projection find witness immediately include error projection prime computing abstract stores defining computing abstract stores nodes error projection restrict relational abstractions finite set compute precise set abstract stores assumption cases approximate desired set abstract stores overand underapproximation algorithms work weight domain finite set abstract stores relational weight domain defined defn weights define rng range dom domain rng dom abstract stores node compute non-empty subset pval pval pval negationslash path program model leads error abstract store arises node section give symbolic algorithms based weights over-approximate under-approximate set verifying membership set show check conceptually place bottleneck node special weight feasible path pass bottleneck abstract store continue error configuration note iff negationslash apost poststar apre prestar intersection iff configuration jop jop negationslash equivalently apost apre negationslash check functional automaton hard check holds weight apost apre circleplustext accpath circleplustext accpath negationslash computable path summary initialize weight initial states algorithm computing running time proportional large compute symbolic underand over-approximations envision membership tested on-demand user asks information abstract store occurring node error slice algorithm check set prime prime weight prime prime bottleneck fast check predicate hold node error projection choose prime abstract stores predicate holds under-approximation obtained set witnesses calculated error projection suppose witness node error projection passes node prefix node suffix starting definition pval pval repeated witness nodes passes under-approximation over-approximation turn functional automaton setup join-over-all-paths problem solved path summary functional automata time state automaton triple weights component responsible computing weight intermediate configuration component compute weight weight tracks weight path accordance definition drop weight components set component path tracked infeasible accomplish replace functional weight defined transformer triple weights braceleftbigg negationslash combine triples defined component-wise easy verify join-over-all-paths automaton intersected transformers defined unlike functionals transformers distributive distribute triples weights component-wise combine monotonic jop safely over-approximated termination guaranteed triples weights bounded height component-wise combine experiments test algorithm computing error projection moped program-analysis tool encodes boolean programs wpdss answers reachability queries checking assertions program boolean programs obtained performing predicate abstraction integer programs limited number bits represent bounded integers finite abstraction weights encode abstract transformers bdds crucial scalability compute error projection extend combine full advantage bdd encoding additional experiments app measured time needed solve program nodes algorithms functional automata based running prestar queries called double-pre method report size error projection validate model source code results shown tab table read columns give program names number nodes basic blocks program error-projection size relative program size times compute post pre columns give running time solving nodes functionals doublepre initial computation post pre completed double-pre method slow run examples completion report time solving weighted chop query blocks multiply resulting number columns compare running time functionals column time compute post pre time doublepre method running times seconds experiments run ghz machine ram table functionals orders magnitude faster double-pre method shown column computation error projection compares fairly running single forward backward analysis smaller programs extent implies error-projection computation incorporated model checkers adding significant overhead investigate optimizations witnesses future work functionalvs prog nodeserrorproj post pre functionaldoublepre reach doublepre iscsiprt pnpmem iscsiprt pnpmem iscsi bugs table moped results programs boolean programs provided schwoon entry point program error configuration set obtained mentioned beginning error projection size means program correct additional applications optimizing cegar loop idea counterexample guided abstraction refinement cegar starting initial abstract model perform verification procedure model property satisfied conclude satisfied real program counterexample computed counterexample correspond execution program refine model eliminate spurious trace back step return counterexample refinement step adding predicates cegar approach successfully applied programverification tools including slam blast magic kiss zing techniques cegar loops optimized ways techniques model checker smaller models step error projection sound error projection includes nodes occur error paths paths error projection violate property checked re-check paths refinement step error projection refinement step eliminate single counterexample current tools speculate ability focus effort model checker work programs violate property interest applications multi-threaded programs kiss system detect errors concurrent programs arise context switches two-context-switch bound enables verification sequential model checker convert concurrent program suitable sequential model checker qadeer add nondeterministic function calls main method process statement process likewise add nondeterministic function returns statement process ensure function call process process performed technique essentially results sequential program mimics behavior concurrent program paths form squiggleright squiggleright squiggleright techniques extend kiss approach return counterexample determine nodes process context switch occur leads error process nondeterministic calls returns qadeer apply model checker compute error projection due automata-theoretic techniques employ omit additions algorithm shows create apost apre process result poststar query main process path summary represents state transformation caused execution steps spent process 
program node process compute path summary path summary augmented assign initial states weight bottleneck negationslash error occur program context switch occurs node process algorithm determine nodes context switch occur error eventually arise related work combination forward backward analysis long history abstract interpretation back cousot thesis model checking interprocedural analysis present paper show forward backward approaches combined context interprocedural analysis performed wpdss introduce automata-theoretic construction experiments show approach significantly faster straightforward goal program slicing work error projection compute set nodes exhibit property work property interest membership error path case program slicing property interest membership path data control dependences slicing chopping advantages instance chopping filters statements transmit effects source target tab techniques generalized hong show perform precise versions slicing chopping predicate-abstraction model checking methods intraprocedural work addresses interprocedural analysis goal error projections extend functionality software model checkers verify safety properties predicate abstraction examples include slam blast kiss magic zing respect blast lazy abstraction soundness guarantee error projection enables model checker focus refinement step nodes error projection viewed alternative form lazy abstraction appears promising avenue future work kremenek statistical analysis rank counterexamples found xgcc compiler goal present user ordered list counterexamples sorted confidence rank mohri investigated intersection weighted automata work natural-language recognition weight domains extend operation commutative require restriction ball rajamani automatically validating temporal safety properties interfaces spin bouajjani esparza maler reachability analysis pushdown automata application model checking concur springer-verlag bouajjani esparza touili generic approach static analysis concurrent programs procedures popl chaki clarke groce jha veith modular verification software components icse clarke grumberg jha veith counterexample-guided abstraction refinement cav cousot ethodes eratives construction approximation point fixes erateurs monotones sur treillis analyse emantique des programmes ese sciences math ematiques univ grenoble engler chelf chou hallem checking system rules system-specific programmer-written compiler extensions osdi finkel willems wolper direct symbolic approach model checking pushdown systems elec notes theoretical comp sci henzinger jhala majumdar sutre lazy abstraction popl hong lee sokolsky abstract slicing approach program slicing based abstract interpretation model checking scam jeannet serwe abstracting call-stacks interprocedural verification imperative programs amast kremenek ashcraft yang engler correlation exploitation error ranking sigsoft fse kurshan computer-aided verification coordinating processes automata-theoretic approach princeton press lal lim polishchuk liblit path optimization programs application debugging esop lal reps improving pushdown system model checking technical report wisconsin-madison jan mass combining forward backward analyses temporal properties pado mohri pereira riley weighted automata text speech processing ecai mohri pereira riley design principles weighted finite-state transducer library theoretical computer science qadeer rajamani rehof summarizing procedures concurrent programs popl qadeer kiss simple sequential pldi reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis scp schwoon model-checking pushdown systems phd thesis technical univ munich july weiser program slicing ieee trans software eng proofs weighted chopping prove correctness algorithm solving poststar poststar path summary proof definition poststar braceleftbigg negationslash circleplustext pval circleplustext pval circleplustext circleplustext pval pval circleplustext pval pval circleplustext pval circleplustext pval additional experiments application experiments isbtrace program-debugging tool performs search program paths wpdss find shortest program entry crash site passes set program nodes give details weight domain noted finite abstraction notion error projection case btrace benchmark running time computing multiple weighted chops results shown tab moped functionals faster double-pre solve multiple weighted chopping queries unlike themopedexperiments solving weighted-chop queries nodes slower forward backward analysis optimizations bring overhead functionalvs prog blockserrorproj post pre functionaldoublepre reach doublepre wget gawk table btrace results programs common unix utilities 
verifying concurrent message-passing programs recursive calls sagar chaki edmund clarke carnegie mellon pittsburgh usa nicholas kidd thomas reps wisconsin madison usa tayssir touili liafa cnrs paris paris france abstract model-checking problem programs data ranging large domains recursive procedure calls concurrent parallel components communicate synchronizing actions model programs communicating pushdown systems reduce reachability problem model deciding emptiness intersection context-free languages tackle undecidable problem counterexample guided abstraction refinement cegar scheme based computing over-approximations checking intersection non-empty non-empty intersection represents infeasible trace refining over-approximations present fully automatic predicateabstraction refinement techniques obtain communicating pushdown systems source code implemented techniques model-checker magic report experimental results non-trivial benchmarks introduction analysis concurrent software represents major challenge model-checking community concurrent programs include complex features manipulation data ranging unbounded domains integers reals large domains -bit ints oats presence recursive procedure calls lead unbounded number calls concurrency existence synchronization statements checking control point reachable undecidable program includes recursive procedures synchronisation statements ram method solving reachability problem systems incomplete hope approxithis research sponsored office naval research onr naval research laboratory nrl contract views conclusions contained document authors interpreted representing official policies expressed implied onr nrl government entity copyright notice mate technique semi-decision procedure termination guaranteed years authors addressed issue pushown systems proposed adequate formalism describe pure sequential recursive programs represent potentially infinite configurations recursive programs symbolic manner regular languages bem fww recently compositions pushown systems called communicating pushown systems model concurrent recursive programs bet bet cases data assumed small finite domain hand abstract-interpretation techniques deal data ranging unbounded large domains recently automated predicate-abstraction techniques proposed deal issue idea predicate abstraction abstract infinite data domain finite defined set predicates precision abstraction model-checking algorithm depend number form predicates size model increases number predicates central problem predicate abstraction discovery small set predicates sufficient prove desired property counterexample guided abstaction refinement cegar techniques kur cgj find small set idea start empty set predicates perform verification procedure obtained model property satisfied model conclude satisfied real program program fewer behaviors model obtain counterexample counterexample corresponds execution program conclude program satisfy property compute set predicates eliminate future exploration spurious trace back step schema successfully applied handle pure non-concurrent sequential recursive programs tool slam concurrent nonrecursive programs tools blast hjms magic ccg work step combine cegar predicate-abstraction techniques pushdown-system modeling handle concurrency recursion large data domains time approach consists communicating pushdown systems cpdss model concurrent programs define cegar predicate-abstraction techniques obtain successively precise cpdss source code parallel program define model-checking algorithms cpdss main contributions paper defining automatic cegar predicate-abstraction techniques create cpds source code concurrent recursive program manipulates variables range large domains refine cpds abstractions eliminate counterexample techniques defined component-wise makes compositional scalable large programs defining model-checking techniques cpdss restrict work solving reachability queries reduce reachability problem cpdss undecidable problem checking emptiness intersection context-free languages tackle problem apply cegar scheme consists computing over-approximations conclude check intersection spurious case refine over-approximations return step semi-decision procedure guaranteed terminate intersection empty implementing technique model-checker magic carrying number non-trivial experiments implementation handle non-trivial bluetooth driver windows handled previous version magic implementation improved performance non-recursive examples previous version magic handle inlining shows technique represents advance recursive non-recursive concurrent programs features work applies cegar scheme levels predicate-abstraction level deal unbounded domain variables modelchecking level solve reachability queries cpdss cpds model checker cegar scheme semi-decision procedure testing emptiness intersection contextfree languages time cegar model-checker compute successively precise abstractions system related work bet bet reachability problem cpdss reduced computing over-approximations context-free languages cegar techniques presented precisely works compute overapproximations context-free languages concludes approach bet bet conclusion made automatically bet bet conclude contrast cegar-based semi-decision procedure guaranteed terminate case correct answer cegar-based predicate-abstraction techniques c-programs model-checking tools slam blast hjms zing qrr kiss mentioned previously slam deal concurrency blast handle recursion kiss discover errors number interleavings parallel components greater zing extension slam concurrent programs slam zing based procedure summarization zing terminate cases technique concurrent case track calling stack unbounded presence recursive calls contents stack explicitely represented zing contrast framework symbolically represented regular languages pushdown system modeling hand slam zing predicate-abstraction techniques extract boolean program program recursion schwoon sch implemented tool moped translation boolean programs pushdown systems moped handle concurrent programs cpds predicate-abstractionrefinement techniques component-wise amount performing successive sequential pds predicate-abstractions refinements argue successive steps slam moped paper propose predicate-abstraction techniques produce directly efficently pushdown system source code sequential component boolean program give section details difference predicate-abstraction techniques slam zing readers familiar techniques skip approach translating code pdss concentrate sections focus concurrency-related aspects work finally techniques presented kig multiple pushdown systems model concurrent recursive programs kig restricted programs communicate finite number locks assumes nesting condition locks shared-variables communication threads synchronizing actions models simulate technique presented sidesteps undecidability reachability multiple pushdown systems putting bound number interleavings threads handle undecidable problem computing abstractions context-free languages bounding number interleavings threads cases technique powerful presented target configurations reachable technique guaranteed terminate correct answer technique apply incrementing automatically bound target configurations found reachable circumstances find infer target configurations reachable technique establish property finally technique implemented automatic techniques translate code pushdown systems provided contrast method implemented applied non-trivial examples effort reported section remainder paper organized section define cpds model section describes generate cpds program predicate abstraction section give semi-decision procedure model-checking cpds section presents predicate-abstraction refinement techniques section reports experimental results preliminary definitions pushdown system pds four-tuple act finite set states act finite set actions finite stack alphabet finite set transition rules form act assume loss generality rules jwj restrictive pds transformed pds form sch subsection transition rules obtained programs form configuration pair state content stack set configurations regular language regular act define transition relation configurations wvi act relation defined obvious set configurations post set successors defined post act communicating pushdown system cpds bet tuple pushdown systems set actions act act lab lab set synchronization actions represents internal actions lab reduce reachability problem cpdss checking emptiness intersection context-free languages global configuration tuple configurations relation extended global configurations index distinct indices set global configurations define successors post component-wise predicate abstraction model concurrent recursive programs cpdss section show predicate abstraction extract cpds parallel program suppose concurrent recursive 
components extract pds recursive component parallel composition components represented cpds tuple pdss show extract pds sequential component predicate abstraction extend approach originally magic ccg automatically extracts finitestate automaton code extract pds loss generality assume kinds statements programs assignments procedure calls if-then-else branches gotos synchronization statements returns magic cil tool nmw transform arbitrary programs format pds defined terms current set seed predicates initially set seed predicates empty predicate set augmented refinement techniques section predicate represents set assignments variables program predicate sets variables resp set local resp global variables ploc resp pglob projection local variables resp global variables predicate represents set values local variable global ploc denotes predicate pglob predicate extend notations sets predicates obvious manner describe set seed predicates generate larger set predicates compute abstraction program process called predicate inference describe set predicates obtain pds sequential component explained cpds corresponds parallel program tuple pdss sequential components predicate inference weakest precondition set predicates defined assignment form weakest precondition respect denoted obtained replacing occurrence assignments pointers statements form handled approach morris mor set seed predicates magic require seed set subset conditions program statements create pds abstraction sequential component relative predicates seed set repeatedly compute weakest preconditions control point compute set predicates initially point repeat longer modified statement corresponds control point assignment successor add wsn statement successor add condition add goto synchronisation statement successor add call procedure successor initial control point procedure add locn globe note procedure terminate presence loops recursive procedure calls case impose termination bounding number predicates control point explain intuition items meant set predicates needed characterize values variables point active respect predicates assignment successor item adds wsn true wsn true holds avoid loss precision wsn holds fourth item easy understand procedure control point procedure called global variables values motivates inclusion globe procedure terminates control back point procedure values local variables procedure point values change call add locn note procedure reason backward manner compute equivalent approach forward reasoning case compute strongest postconditions weakest preconditions finally union control points sequential component set generated predicates predicate valuation recall goal compute pds abstraction sequential component section states pds correspond valuations global predicates symbol stack pair consists control point query point emulated introducing statement branch condition valuation local predicates point associate location sets formulas globn locn called global local valuations fglob locg set formulas pxkx vkx fpx pxkxg ftrue falseg kxg femptyg valuation form denote predicate true false empty ftrueg creating pds corresponds sequential component ready describe create pds corresponds sequential component set seed predicates assign sequential possibly recursive component pds act defined set valuations correspond global variables globn union control points sequential component act action synchronization actions program set pairs control point sequential component valuation locn corresponds set valuations local variables location define rules notion goto statement point intuitively represent statement rules form hglob loc hglob loc glob globn glob globn loc locn loc locn formulas glob glob loc loc satisfiable means program point variables satisfy global local valuations glob loc performing goto statement point variables satisfy valuations glob globn loc locn glob glob loc loc satisfiable condition ensures pds creating behaviors concrete program determining satisfiable general undecidable first-order formulas integers sidestep problem sound validity checker nel terminates answers true false unkown question formula valid denote answer provided validity checker question valid false unkown ensure pds creating safe abstraction add pds-transition holds ready define set rules statement control point goto statement represented rules form hglob loc hglob loc unique successor glob globn glob globn loc locn loc locn glob glob loc loc synchronizing statement labeled action represented rules form hglob loc hglob loc unique successor glob globn glob globn loc locn loc locn glob glob loc loc assignment translated set rules form hglob loc hglob loc unique successor glob globn glob globn loc locn loc locn glob glob loc loc words glob glob loc loc valuations correspond values global local variables assignment global variable local assignment rule stands true statement represented rules form hglob loc hglob loc control point resp statement glob loc satisfy condition resp satisfy condition glob globn glob globn loc locn loc locn glob glob loc loc call procedure represented rules form hglob loc hglob loc loc unique successor initial control point procedure glob globn loc locn glob globe loc loce loc locn glob glob loc loc loc loc role loc save values local variables caller procedure finally return statement translated rules form glob globn loc locn hglob loc hglob remark note predicate abstraction techniques sound programs assignments pointers hold addresses local variables callers difficult extend techniques interprocedural modification-analysis algorithm detect account cases note observe internal actions represented needed reduce reachability problem cpdss computing abstractions path languages pushdown systems discussed section comparision predicate-abstraction technique slam mentioned section slam tool predicateabstraction techniques extract boolean program source code schwoon translation sch obtain pds boolean program compared techniques slam techniques section exhibit main differences translation efficient produces directly step pds code intermediate boolean program technically approach section slam approach method close set seed predicates computing weakest preconditions paths program obtain larger set predicates compute abstract model contrast slam seed set predicates computing closure weakest precondition computes largest disjunctions predicates imply weakest preconditions abstract model obtain precise slam predicates sequential components running parallel synchronization action main int proc return void proc fproc return main return case set seed predicates empty model component pds local variables stack alphabet set control points set seed predicates empty unique state corresponds valuation empty rules similarly represent component pds unique state rules case model component pds points computing find predicate ignore predicates trivially true false states false true empty rules reachability analysis cpdss suppose program consists sequential components magic query suppose system starts configuration component initial control point component reach error point show section tackle reachability analysis systems remainder paper restrict systems consist parallel sequential components technique extended straightforward manner general case bet details implementation reported section supports arbitrary number components reduce reachability problem cpdss deciding emptiness question intersection context-free languages cpds sets global configurations system internal actions represented neutral element concatenation reachable exists sequence synchronization actions simultaneously leads configuration configuration 
configuration configuration holds iff context-free language consisting sequences actions equivalently synchronization actions internal actions represented lead deciding emptiness context-free languages undecidable propose semi-decision procedure case termination answers intersection empty semi-decision procedure guaranteed terminate return sequence intersection semi-decision procedure based counterexample guided abstraction refinement cegar scheme abstraction compute over-approximation path language verification check conclude unreachable compute counterexample counterexample validation check sequence case spurious conclude reachable proceed step refinement spurious refine over-approximations compute over-approximations continue step remainder section discuss steps detail fix sets global configurations sake simplicity denote computing over-approximations path languages compute over-approximations pushdown-system path languages technique based approach presented bet summarize approach abstract lattice idempotent semiring associative commutative idempotent operation associative operation neutral elements annihilator distributes finally related concrete domain lab element letter lab abstraction function lab concretization function lab defined van lab van easy language lab words overapproximation finitely represented abstract domain element intuitively abstract operations correspond concatenation union correspond inclusion intersection abstract elements correspond empty language compute over-approximations compute representative abstract domain finite-chain abstraction abstraction infinite ascending chain maximal height chain theorem bet rsj act pds regular sets configurations finite-chain abstraction defined abstract domain effectively computed jjqj time algorithms provide basis theorem bet bet rsj rsjm implemented tool called wpds krml tool compute abstractions path languages check emptiness intersection overapproximations suffices check fact show lab defining refinable finite-chain abstractions apply cegar scheme define refinable finite-chain abstractions series precise language lab define ith-prefix abstraction set words lab length equal abstract lattice equal lab prefix length abstraction concretization functions domain easy set words length union set prefixes length jwj jwj lab jwj fwv jwj lab observe decide lab finite set words easy precise defined series refinable finite-chain abstractions remark ith-prefix abstraction abstraction instantiate framework ith-suffix ith-subword abstractions defined analogous checking counterexample spurious remains check element amounts deciding problem undecidable regular language lab regular sidestep problem check common word length amounts checking decidable finite set semi-decision procedure summarizing previous discussion obtain semi-decision procedure initially compute common words length common prefixes length conclude unreachable determine spurious check holds conclude common word length equal reachable increment proceed step easy theorem semi-decision procedure terminates exact solution proof length remark theorem step computing necessitates jlabjij jjqj time jlabji words length jlabji elements worst case complexity algorithm practice tool behaves section pds rules pds rules easy fakbbk kdbk straightforward illustrate approach fag refine abstraction fabg refine abstraction infer component-wise refinement construction cpds model program involves predicate abstraction parametrized set predicates main issue predicate abstraction find small set predicates prove property interest case property question system reach error initial configuration component hglobi loci initial control point component globi loci initial valuations global local variables similarly error configuration component configuration form hglob nie loc nie correponds error point glob loc arbitrary valuations variables magic finds minimal set predicates applying cegar approach start model involving empty set seed predicates perform model-checking step section model checker answers error state unreachable cpds model case concrete program program fewer behaviors model model checker finds cpds reach error state performing sequence synchronization actions verify behavior corresponds real executions program case shown program correct erroneous-looking behavior introduced abstraction case refine cpds model precisely model checker returns sequences rules cpds reaches error state performs sequence rimi case sequence synchronization actions sequences rules sequence rimi counterexample component check counterexample spurious check component perform sequence statements correspond sequence rules rimi component fails perform sequence refine pds eliminate spurious sequence rules observe steps component-wise makes technique compositional scalable large programs section show check sequence rules returned model checker spurious show add seed predicates create precise cpds model eliminates spurious trace counterexample validation present subsection algorithm takes input counterexample sequence rules pds models sequential component answers spurious sequence statements correspond intuitively algorithm simulates steps determine concrete component possibly perform algorithm starts initial point valuations glob loc variables applies successively statements updates values variables checks if-thenelse conditions satisfied sequence instructions precisely algorithm works initially glob loc assignment compute strongest postcondition respect assignment valuation true updated valuation true statement condition corresponds successor corresponds successor satisfiable program execute sequence statements counterexample valid counterexample spurious eliminating counterexample counterexample spurious component refine pds model component adding seed predicates predicates add subsets set conditions if-then-else branches program intuitively works cases counterexample spurious abstract model modeled condition sufficient precision allowed branches moment abstract execution concrete execution run branch counterexample corresponds trace takes wrong branch eliminate trace add condition statement seed predicate precisely ckg set conditions statements program current set seed predicates computed section set predicates proceed increment step fcig create pds corresponds predicates section model eliminates counterexample seed set increment step predicates succeeds eliminating counterexample add predicates step possibilities counterexample eliminated add predicates step parallel program section query reach point system starts case component synchronizes action component perform model concurrent program seed predicates model section model checker answers reachable sequences method check spurious satisfiable refine pds obtain pds section easy cpds reach experimental results implemented method paper comfort cisw model checker built top magic ccg experimented set non-trivial benchmarks implementation supports kinds abstractions section ith-prefix ith-suffix abstractions application concurrent recursive programs windows bluetooth driver applied technique nontrivial recursive concurrent program handled original non-recursive version magic windows bluetooth driver tool found bug program reported bug detected ith-prefix ith-suffix abstractions experiments performed linux smp ghz machine memory results summarized figure abstraction execution time seconds memory ith-prefix ith-suffix figure results bluetooth driver note suffix abstraction efficient case due fact backward paths erroneous configurations forward paths initial configurations describe program source code found cpds model show apply technique find error driver consists number processes running parallel process stop-d process counter process stopping-flag process stopping-event arbitrary number processes request request driver role process counter count number requests driver receives number set initially incremented driver receives request decremented request exits driver process stop-d issue request stop driver time wait requests finished work stopping driver process stopping-flag control points s-f false-stop-flag t-s-f true-stop-flag depending process stop-d stop driver initially state f-s-f moves state t-s-f receives message stop-d thread enter driver process t-s-f process stopping-event control points f-s-e false-stop-event t-s-e true-stop-event enters state t-s-e 
driver stops number running requests reaches finally request enters driver increment number stored counter perform work asked request decrement number stored counter exiting driver functions increment decrement processes modeled pds techniques automatically performed tool process counter global variables unique state number threads represented stack stack alphabet initially stack word meaning number requests word number stack corresponds number running requests minus increment decrement operations invoked incr decr messages request processes counter represented pds rules incr incr rules increment counter decr rule decrements counter rules test counter process stopping-flag global variables unique state f-s-fi stop t-s-fi process receives stop request stop-d t-s-fi stop t-s-fi process communicates request process stop message f-s-fi stop f-s-fi sends non-stop request incoming requests process stopping-event previous processes process global variables unique state f-s-ei stop driver t-s-ei t-s-ei stopped t-s-ei process messages is-stopped stop-driver driver stopped f-s-ei stopped f-s-ei sends nonstopped message driver running process stop-d process global variables unique state stop edecrement stop-d sends stop request stopping-flag calls decrement stopped releasei driver stopped allocated resources released process copy function decrement process request process global variable set initially global states pds correspond cases equal process request starts calling function increment function set stopping-flag set true increment counter set increment returns request performs work asserts stopping-event state f-s-e driver running calls function decrement decrements counter counter reached sends message inform stopping-event driver stopped requests running process request modeled pds rules hgx hgx einc increment called nworki increment returns request performs work nworki nend worki work ends nend worki stopped edecrementi work finished make driver running stopping-event f-s-e nend worki stopped aborti case reached error program aborts hgx hgx edecrementi decrement called function increment represented hgx einci stop stopping-flag t-s-f function returns hgx einci stop hgx increments counter returns hgx incr function decrement represented fgx function shared request stop-d edecrementi dec counter decremented reached function terminates communicates stopping-event message stop-driver stop driver erroneous trace error arises running request processes stop-d counter stopping-flag stopping-event instance request running parallel show program reach bad point abort configuration represented -tuple represent configurations processes stop-d counter stopping-flag stopping-event request initial configuration f-s-fi f-s-ei action configuration move f-s-fi f-s-ei einc exchanging non-stop message request stopping-flag f-s-fi f-s-ei stop-d send stop request stopping-flag t-s-fi f-s-ei edecrement counter decremented t-s-fi f-s-ei counter tested exchanging message is-zero t-s-fi f-s-ei decrements confirms driver stopped sending message stop-driver t-s-fi t-s-ei resources released t-s-fi t-s-ei releasei point request point decides resume execution increments counter t-s-fi t-s-ei releasei request executes work t-s-fi t-s-ei releasei nworki work finishes t-s-fi t-s-ei releasei nend worki request realises driver stopped communicating stopping-event message isstopped aborts t-s-fi t-s-ei releasei aborti easy trace found technique prefixes length synchronisation actions achieved suffix abstraction application non-recursive examples applied implementation examples recursion magic applied previous version magic handles non-recursive procedure calls in-line expansion goal experiments determine method paper improve magic performance inlining produces huge finite-state models procedure control points calls procedure control points system modeled finite automaton states pds states results encouraging improved efficient implementation shows addition utility verification concurrent recursive programs technique represents advance recursive non-recursive concurrent programs experiments carried dual-athlon-xp machine ram running redhat ithprefix abstraction experiments results summarized figure columns explained table row corresponds benchmark precisely srvr series single openssl server lines code clnt series single openssl client lines code ssl series server client execute concurrently lines code element series corresponds property verified source code ucos benchmark lines code refers single process running micro-c operating system ucoslines code ucoslines code refer micro-c processes finally casting lines code refers actual controller deployed metal-casting plant cases properties checked found valid program previous version technique abs verif mem abs verif mem srvrsrvr- srvrsrvr- srvrsrvr- srvrsrvr- clntclnt- clntclnt- clntclnt- clntclnt- sslssl- sslssl- sslssl- sslucos ucosucos- casting figure abs predicate-abstraction time sec verif modelchecking time sec mem memory consumtion exceeded memory limit observe predicate-abstraction times comparable series benchmarks essentially inlining cases cpds approach leads faster predicate abstraction factor ucosin cases dramatically reduces memory consumption order magnitude case ucosin terms time cpds approach ssl series ucosand ucosin case orders magnitude conclusion future work paper extended tool magic handle concurrent programs recursive procedure calls model programs communicating pushdown systems extend cegar scheme implemented magic manipulate cpdss define predicate-abstractionrefinement techniques compute refine cpdss source code propose semi-decision procedure solves reachability queries cpdss finally report encouraging non-trivial experimental results semi-decision procedure based computing series refinable finite-chain abstractions pushdown-system path languages work ith-prefix ith-suffix abstractions interesting kinds finite-chain abstractions ith-subword abstraction ith-occurrence ordering abstraction considers order ith occurences letter alpahbet time magic handle reachability properties programs concurrency recursion future plan extend handle general properties define approximate techniques model checking cpdss ltl ctl formulas acknowledgment mihaela sighireanu helpful discussions bluetooth driver program bem bouajjani esparza maler reachability analysis pushdown automata application model checking concur lncs bet bouajjani esparza touili generic approach static analysis concurrent programs procedures proceedings acm sipgplan-sigact principles programming languages popl bet bouajjani esparza touili generic approach static analysis concurrent programs procedures international journal foundations computer science ball rajamani automatically validating temporal safety properties interfaces lecture notes computer science cousot cousot static determination dynamic properties recursive procedures ifip conf formal description programming concepts north-holland pub ccg chaki clarke groce jha veith modular verification software components international conference software engineering icse pages cgj clarke grumberg jha veith counterexample-guided abstraction refinement computer aided verification pages cisw chaki ivers sharygina wallnau comfort reasoning framework computer aided verification cooper kennedy interprocedural side-effect analysis linear time pldi pages esparza knoop automata-theoretic approach interprocedural data-flow analysis fossacs volume lncs esparza schwoon bdd-based model checker recursive programs proc cav number lecture notes computer science pages springer-verlag fww finkel willems wolper direct symbolic approach model checking pushdown systems infinity graf saidi construction abstract state graphs pvs grumberg editor proc international conference computer aided verification cav volume pages springer verlag hjms henzinger jhala majumdar sutre lazy abstraction symposium principles programming languages pages kig kahlon ivancic gupta reasoning threads communicating locks computer aided verification krml kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds kur kurshan computer-aided verification coordinating processes automata-theoretic approach princeton press 
mor morris assignment linked data structures broy schmidt editors theoretical foundations programming methodology pages reidel publishing boston nel nelson techniques program verification phd thesis stanford nmw necula mcpeak weimer liblit bhargava intermediate language http manju berkeley cil qadeer rehof context-bounded model checking concurrent software tacas qrr qadeer rajamani rehof summarizing procedures concurrent programs popl acm principles programming languages pages qadeer kiss simple sequential pldi programming language design implementation pages ram ramalingam context-sensitive synchronizationsensitive analysis undecidable acm transactions programming languages systems toplas rsj reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis sas pages rsjm reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis sci comp prog sch schwoon model-checking pushdown systems phd thesis technische universit unchen 
reducing dependence trust-management systems pki hao wang somesh jha thomas reps computer science department wisconsin hbwang jha reps wisc stefan schwoon institut formale methoden der informatik universit stuttgart schwoosn fmi uni-stuttgart stuart stubblebine stubblebine research labs stuart stubblebine august abstract trust-management systems address authorization problem distributed systems defining formal language expressing authorization access-control policies relying algorithm determine specific request granted authorization distributed systems trustmanagement systems offer advantages approaches support delegation making authorization decisions decentralized manner paper focuses popular trustmanagement system spki sdsi spki sdsi attractive system authorization distributed systems limited deployment major hurdles deploying spki sdsi pki-based principal required public-private key pair present approach combines spki sdsi widely-deployed authentication system kerberos reduce reliance spki sdsi pki approach sites public-private key pairs reducing reliance spki sdsi pki facilitate wider deployment implemented prototype technique introduction systems shared resources access-control mechanisms protection fundamental problems access control authentication authorization enforcement authentication deals verifying identity principal authorization addresses problem request specific principal allowed enforcement addresses problem implementing authorization execution centralized system authorization based closed-world assumption parties identity established authentication system distributed system closed-world assumption valid trust-management systems solve authorization problem distributed systems defining formal language expressing authorization access-control policies relying algorithm determine specific request allowable trust-management systems decouple specification security policy enforcement context authorization distributed systems trust-management systems offer advantages support delegation conceptual requirement central authority ability make authorization decisions distributed fashion survey trust-management systems formal framework understanding presented prominent trust-management systems keynote spki sdsi paper focus trust-management system spki sdsi basic ideas introduced paper applicable trust-management systems spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations spki sdsi investigated researchers authorization decisions spki sdsi based certificate chains proofs client public key keys authorized access resource directly transitively name-definition authorization-delegation steps advantages spki sdsi limited deployment major hurdles deploying spki sdsi distributed certificate-chain discovery algorithm principal public-private key pair hurdle partially addressed work distributed certificate-chain discovery algorithms trust-management systems paper focus hurdle goal paper reduce dependence spki sdsi public-key infrastructure pki reducing reliance spki sdsi pki lead wider deployment main approach leverage existing widely deployed authentication system kerberos specifically demonstrate spki sdsi conjunction kerberos reduces reliance pki requiring public-private key pair site vanilla spki sdsi requires principal public-private key pair approach maintains advantages spki sdsi support delegation ability make authorization decisions distributed fashion approach levels certificates level resembles vanilla spki sdsi call spki sdsi spki sdsi kerberos e-spki sdsi extended spki sdsi users work k-spki sdsi level e-spki sdsi implementation level distinction levels discussed section solution authenticated kerberos users issue k-spki sdsi certificates eliminate requirement user possess public private key pair k-spki sdsi server accepts certificates authenticated kerberos users generates e-spki sdsi certificates behalf users certificates k-spki sdsi server answering authorization queries invoking certificate-chain discovery e-spki sdsi level providing solution built top kerberos authentication system widely deployed organizations ranging research institutes corporations hope approach easier adopt contributions paper show reduce dependence spki sdsi pki leveraging kerberos insight work user authenticates kerberos acquire session key serves evidence property substitute signing actions vanilla spki sdsi requires ability participate spki sdsi-like scheme requirement public-private key pair created prototype implements technique measurements show performance depends k-spki sdsi certificates distributed sites background spki sdsi section method combining spki sdsi kerberos section applications system discussed section section discusses prior work addressed systems similar identical spki sdsi work distributed certificate-chain discovery algorithm generalizes non-distributed algorithm jha reps deployment performance issues prototype section discusses related work background spki sdsi spki sdsi principals represented public keys principal public key principal individual process host entity denotes set public keys specific keys denoted identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates spki sdsi types certificates certs certificates certs cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification certificate takes form interval cert valid time inclusive authorization certificates auth certs auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert subject term delegation bit turned subject receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert labeled rewrite rule pair component rewrite rule component authorization specification notational convenience write labeled rewrite rule treat certs labeled rewrite rules cert written labeled rewrite rule authorization specification authorization specifications write simply rewrite rule form implicit label auth cert written square square delegation bit turned written square squaresolid authorization problems valid certificates validity specification certificate included rule issue intersection union authorization specifications discussed detail authorization labeled rewrite rules paper refer rewrite rules simply rules term appearing rule viewed string alphabet elements beginning uniformity refer strings form square squaresolid terms assume labeled rewrite rule cert term case labeled rewrite rule applied term denoted yields term rule viewed function terms terms rewrites left prefix argument bob bob myfriends myfriends rules addition assume prefix exists composition rule rules friends bob myfriends bob composition friends myfriends rules called compatible composition defined authorization problem spki sdsi assume set certs principal access authorization specification authorization question granted access resource certificate chain sequence certificates label certificate chain denoted label obtained denoted compose assume authorization specification unique principal kowner resource refers set certificates authorization specification principal algorithm finite set certificate chains prove principal allowed access formally certificate-chain discovery attempts find finite set chm certificate chains compose chi kowner square square squaresolid uniontextmi chi clarke presented algorithm certificate-chain discovery spki sdsi time complexity number keys sum lengths right-hand sides rules algorithm solved restricted version certificate-chain discovery general composition operator associative compatible compatible exist exist exists expressions equal defined omit parentheses assume associative solution consist single certificate chain instance certificate set dir read dir write suppose alice makes request dir set read write case 
chain authorizes alice read directory separate chain authorizes write set proves read write privileges certificates removed certificate set prior running certificate-chain discovery algorithm clarke read negationslash set read write write negationslash set read write proof authorization alice request found schwoon presented algorithms full problem based solving reachability problems weighted pushdown systems wpdss formalization proof authorization consist set certificate chains paper wpds-based algorithm introduced spki sdsi kerberos describe authorization scenario spki sdsi section describe reliance spki sdsi pki reduced kerberos introduce small section imagine sites bio correspond biology computer science department professor bob biology department provide access server students students professor alice computer science department assume sites spki sdsi servers sst sst context sites bio spki sdsi servers scs sbio components spki sdsi authorization scenario certificate issuance user sends signed auth certs spki sdsi server site spki sdsi server verifies signatures certs signature verification fails cert rejected stored spki sdsi server alice sends scs certs signed alice kalice students kalice students kalice students certs essentially state students alice bob sends sbio signed auth certs signed bob kbob square kbob studentssquaresolid kbob square kalice studentssquaresolid auth certs state students kalice kbio access server denoted authorization specification students delegate certificate-chain discovery suppose user public key site access resource site authorization specification user sends request denoted ccdrequest spki sdsi server scs spki sdsi server scs executes distributed algorithm returns finite set certificate chains chm suppose user sends certificate-chain discovery request ccdrequest server scs server scs executes distributed certificate-chain discovery algorithm returns set chains shown kbob square kalice studentssquaresolid kalice students requesting resource assume user access resource authorization specification requests certificate-chain discovery carried sending request ccdrequest spki sdsi server site obtains back set certificate chains sch chm user presents set certificate chains sch principal recall owner resource refers principal authorizes iff uniontextmi chi step called compliance checking label chi chain chi section user access server authorization specification making certificate-chain discovery request obtains set compose kbobsquare square squaresolid presents server checks true grants access spki sdsi kerberos notice spki sdsi user public private key pair section describe authorization protocol distributed authentication system kerberos requires public private key pair site authorization system called k-spki sdsi assume reader familiar kerberos detailed description kerberos make assumptions site kerberos realm kdc site denoted kdcst k-spki sdsi server site kerberoized kdc k-spki sdsi server site share public private key pair public key site denoted kst describe components authorization scenario context certificate issuance issue k-spki sdsi certificates kerberos user authenticates local kdc standard kerberos authentication protocol receives ticket granting ticket tgt kdc tgt client requests service granting ticket sgt accessing kerberoized spki sdsi k-spki sdsi server rest section assume user obtained sgt k-spki sdsi server site sgt client issues requests generating spki sdsi certs auth certs communication channel requests encrypted session key provided sgt issue cert user site sends encrypted cert request spki sdsi server eks user identifier subject validity specification write cert eks receiving encrypted cert eks local k-spki sdsi server ascertains validity cert valid creates cert form kst kst signs private key stores database certificates notice cert public key kst site added alice sends certs encrypted session key k-spki sdsi server site alice students alice students alice students k-spki sdsi server verifies encrypted certs shown creates spki sdsi certs signs kcs alice students kcs kcs alice students kcs kcs alice students kcsz user site sends auth cert eks encrypted session key tgt k-spki sdsi server receiving encrypted auth cert eks k-spki sdsi server ascertains validity auth cert valid creates e-spki sdsi auth cert form kst kst signs private key stores database certificates bob sends auth certs encrypted session key tgt spki sdsi server sbio bob square bob studentssquaresolid bob square alice students squaresolid auth certs state students bob current site alice site access server denoted authorization specification students delegate k-spki sdsi server sbio verifies encrypted auth certs shown creates e-spki sdsi auth certs signs kbio bob square kbio bob studentssquaresolid kbio bob square kbio alice studentssquaresolid k-spki sdsi servers adds certs k-spki sdsi servers sites scs signs adds cert kcs bio kbio states public key site bio kbio similarly sbio signs adds cert kbio kcs note k-spki sdsi servers support extended version spki sdsi left-hand sides extended auth certs symbols left-hand side extended auth cert form usquare usquaresolid public key site user left-hand side extended cert form identifiers spki sdsi left-hand sides auth certs symbols spki sdsi algorithms extended implement e-spki sdsi e-spki sdsi special case left-prefix rewriting primitives generalize arbitrary left-prefix rewriting systems requesting resource sgt user site sends request local k-spki sdsi server access remote server located site request encrypted session key provided sgt eks k-spki sdsi server sst site initiates distributed certificate-chain discovery request ccdrequest kst behalf process involves k-spki sdsi servers local remote related spki sdsi certificates request ccdrequest kst successful returns set certificate chains sch user receives token sst tokenu eks ticketu ticketu ekst sch lifetime user receives token set certificate chains sch certificate chain certificates shown kbio bob square kbio alice studentssquaresolid kbio kcs kcs alice students kcs notice compose kbiobob square kcs square kcs squaresolid receiving tokenu user decrypts eks retrieves key recall session key tgt k-spki sdsi server site user constructs authenticator authenticatoru idubardbladubardblts bardbllifetime user sends message server site ticketu authenticatoru server requests local k-spki sdsi server verify message k-spki sdsi server site performs steps decrypts message ekst private key retrieves improving session key pushdown system decrypts model checking message akash lal thomas sch reps lifetime wisconsin ascertains madison freshness wisconsin akash time-stamp reps wisc abstract server verifies paper reduce lifetime pushdown system token pds model checking expired k-spki graphtheoretic sdsi problem server apply performs fast graph algorithm compliance-checking step improve running set time certificate chains model sch checking similarly weighted k-spki pdss sdsi server generalized ascertains setting validity pds model authenticator checking show idubardbladubardblts bardbllifetime pds notice model checkers server encoded session weighted key pdss ticketu give algorithms steps witness tracing differential successful propagation incremental k-spki sdsi analysis server sends message indicating granted benefits access threat fast analysis graph-based message algorithm exchange introduction requesting pushdown systems resource pdss earlier served similar important formalism exchange program messages analysis client verification kdc kerberos essence ability authenticator concisely authenticatoru capture states interprocedural control flow notice program token tools tokenu session pushdown key systems encrypted abstract model program user reachability analysis sgt models verify program properties pdss infinite-state abstraction control state program tools verify properties finitestate data abstraction tools based issued generalized setting assuming weighted pushdown authentication systems kerberos wpdss correct capable verifying infinite-state data adversary abstractions replay heart message ticketu tools authenticatoru pds server reachability-analysis algorithm chaotic-iteration strategy explore reachable states work address worst-case running time algorithm knowledge addressed issue giving direction chaotic-iteration scheme improve running time algorithm practice paper improve worst-case running time running-time observed practice provide common setting discuss pds model checkers wpdss describe improvements pds reachability interprocedural control flow graph icfg set graphs procedure connected special call return edges wpds initial query decomposed set graphs structure similar underlying pds obtained standard encoding icfg pds program analysis decompositions coincide fast graph algorithm tarjan path-expression algorithm represent graph regular expression wpds reachability reduced solving set regular equations underlying pds obtained structured reducible control flow graph regular expressions found solved efficiently control flow structured regular expressions provide fast iteration strategy improves standard chaotic-iteration strategy work inspired previous work dataflow analysis single-procedure programs shown class dataflow analysis problems advantage fact single-procedure cfg represented regular expression generalize observation multi-procedure programs wpdss contributions paper summarized present reachability algorithm wpdss improves previously algorithms pds reachability algorithm asymptotically faster pds regular decomposes single graph offers substantial improvement general case algorithm completely demand driven computes information needed answering user query algorithm easily parallelized unlike chaotic-iteration strategy advantage multiple processors making attractive run coming generations cmps show pds analysis questions techniques carry approach describe perform witness tracing differential propagation incremental masquerade analysis authenticator intended short lifetime risk replay attack minimal applications work step building practical distributed authorization system section discuss existing applications benefit k-spki sdsi approach authorization 
distributed file systems afs popular distributed file system active users consistent space users physical location authorization afs important issue afs users share view entire afs afs relies kerberos authentication access control lists acls user names group names control access data inside afs directory acl system works managing permissions site users sites plan share files acl system efficient difficult maintain afs authorization performed locally afs cell illustrate concrete show afs acls work cross-site environment explain approach simplify cross-site authorization afs cross-site acls afs assume professor bob site bio plans grant access directory data students professor alice site existing afs alice bob follow steps accomplish goal initial authentication site bio bob authenticates afs system kerberos obtain afs token access afs create acls alice creates list students site alice creates list students shown figure bob sets group alice students bob creates afs group called alice students alice students bio populates group alice students shown figure bob grants access alice students bob grants access directory data group created previous step shown figure problem approach group alice students maintained bob redundant sync alice list result approach efficient scale scenarios alice adds removes student list bob update list professors sites plan grant access permissions alice students professors create maintain copy alice student list addition afs server set special group called system authuser work concerned list created maintained relevant issue create maintain list alice students alice students studentx studenty studentz alice list students alice students acl list data studentx system administrators rlidwka studenty system anyuser studentz alice students bob rlidwka bob acl group bob grants access figure afs acls cross-site access control alice maintains list students site site bio bob creates group alice students adds alice students group bob grants access directory data group alice students entry acl entries managed afs afs authorization k-spki sdsi contrast k-spki sdsi approach greatly simplifies cross-site authorization steps initial authentication alice bob authenticate kdcs obtain sgts respective k-spki sdsi servers alice issues certs site k-spki sdsi server alice issues cert students kcs alice students kcs studentx essentially creates group called kcs alice students site bob grants access alice students site bio k-spki sdsi server bob issues auth cert granting access alice students group created kbio bobsquare data kbio alice studentssquaresolid alice manages list students bob refers symbolic alice students bob longer create copy alice list students result approach simpler scalable cross-site environments alice adds removes student list bob make side professors sites grant access permissions alice students issue auth certs sites duplicate lists students created accessing kerberos services web services web services traditionally built top public-key cryptography ssl kerberos services hand rely secret-key cryptography result challenge integrate systems users access kerberos services web services case user alice access data web service running inside web server compare approaches based k-pki project based approach previous approach k-pki project addresses integration problem providing mechanism translates kerberos credentials certificates vice versa figure illustrates kerberos servicekca kctalice web figure accessing kerberos service k-pki kerberos servicespki sdsi alice web figure accessing kerberos service k-spki sdsi client alice accesses kerberos service web service remainder assumed alice tgt communications secure alice requests certificate alice generates public private key pair obtains sgt kerberos certification authority kca authenticates kca part authentication process sends public key kca signed kca generates certificate kca authenticating alice signs alice public key returns signed certificate back alice alice authenticates web service alice newly generated certificate authenticate web service web service matches request kerberos ticket web service authenticates kerberos credential translator kct kct evidence properly authenticated alice kct generates kerberos ticket kct validating identity request web service generates kerberos ticket alice identity web service returns ticket web service accessing kerberos service web service kerberos ticket returned kct access kerberos service behalf alice drawback approach translate kerberos credentials pki certificates vice versa achieve objective simpler k-spki sdsi approach k-spki sdsi approach k-spki sdsi alice grant access permission web service directly avoiding credential conversions required k-pki approach figure shows setup system system alice steps access kerberos service web alice grants access web service alice obtains sgt k-spki sdsi server sgt issues auth cert k-spki sdsi server granting rights web service validity information kcs alicesquare kcswebsquaresolid alice authenticates web service web service requests access token authenticating alice web service queries spki sdsi server token accessing data behalf alice k-spki sdsi server checks permission k-spki sdsi server performs distributed certificatechain discovery check requested access permission check successful k-spki sdsi server returns access token web service accessing kerberos service web service token returned k-spki sdsi server access kerberos service approach flexible alice issuing auth certs directly limit access privileges granted web service security objectives short validity period limit time window web service access data specifies restrict web service access rights granting specific access privileges implementation evaluation built prototype system evaluate approach implementation mit kerberos distribution version distributed spki sdsi library based model checker pushdown systems evaluated approach criteria ease deployment performance implementation prototype deployed system realworld environment evaluated prototype simulated environment synthetic data experimental results demonstrate approach achieve goal reducing spki sdsi dependence public-key infrastructure easy implement deploy system summarize results based criteria ease deployment steps required deploy system assuming kerberos installed install public private key pair approach public private key pair needed kerberos site comparison pki systems require user key pair addition sites exchange public keys reasonable requirement exchange install k-spki sdsi server kerberos site logical k-spki sdsi server k-spki sdsi server implemented kerberos service require kerberos setting secret key kdc k-spki sdsi server update kerberos clients kerberos clients updated advantage k-spki sdsi server clients library call access k-spki sdsi server performance experimental results demonstrate performance distributed authorization highly dependent e-spki sdsi certificates distributed sites distributed certs sites needed resolve authorization queries longer takes process authorization query rest study distributed authorization performed test environment paper organized certificates background kerberos sites pdss wpdss presents process previously complex authorization algorithm request algorithm half long solving process simple prototype implementation plenty room optimizations improve performance ease deployment objective work make spki sdsi potentially trust-management reachability queries wpdss systems describe reliant algorithms pki witness tracing easier differential propagation deploy incremental real analysis world presents achieve experimental results goal describes related means work pds model reduce checking spki sdsi section review reliance existing pki pushdown system relying model checkers authentication provided weighted pushdown existing systems infrastructures show model kerberos 
checkers encoded proven wpdss pushdown systems approach definition make pushdown spki system sdsi fit triple existing systems seamlessly set introducing states drastic control locations hard set stack accepted symbols deploying system environments set kerberos pushdown rules installed configuration requires small pair terms implementation rule make written approach introduce kerberos rules define transition result relation complications configurations deployment achieved goal implementing k-spki sdsi server independent unit subscript changing kdc transition clients relation simply omitted interact clear k-spki sdsi context server reflexive standard transitive request closure reply denoted model result set implementation configurations requires define pre kdc minor modification post kerberos library approach backward forward drawbacks reachability transition separate relation server restrict clients pushdown modified rules provided stack features symbols right-hand change side means simple alternative rule provide form functionalities inside kdc kerberos restriction client requests sgt service kdc automatically performs authorization query behalf decrease client power stores pushdown systems authorization token increasing part number sgt stack approach symbols makes constant authorization factor process arbitrary transparent pushdown system clients converted satisfies restriction standard approach modeling program control flow icfg call node split nodes require interprocedural edge kdc entry technique node procedure called adding authorization support incoming inside edge exit kerberos node procedure evaluating set approaches nodes addition graph deploying set control-flow system edges site fig install shows public private key icfg pair fig shows site pushdown send system public models key pds sites single plans state collaborate stack symbol node reasonable requirement rule setting edge collaboration rules administrative task stack symbol right-hand side model collaborator intraprocedural edges rules kerberos stack cross-site symbols authentication requires right-hand participating side sites call exchange edges secret rules keys stack advance symbols performance right-hand side evaluated return edges performance easy system valid simulated path distributed program corresponds path environment pushdown system transition considered system performance vice versa distributed pdss authorization encode issuing ordinary control certificates flow graphs infrequent administrative provide task convenient mechanism simulated test modeling environment kinds consists non-local control flow kerberos sites model shown setjmp longjmp figure programs node setjmp push graph special represents symbol kerberos stack site nodes longjmp symbol environment represent variable resource identified service kerberos preprocessing users pop access stack illustrate symbol reached longjmp certificates passed experiments state shown pds emain site null loc false distributed flag environment false call kerberos foo site ret stores foo exitmain certificates distributed efoo authorization loc true involve flag sites depending loc e-spki false sdsi exitfoo certificates distributed instance figure manager site gov attempts access resource nsf sites involved distributed authorization denoted solid arrow contrast alice access resource multiple sites fig dashed arrows interprocedural control participate flow graph distributed authorization exit nodes represent expect entry number exit points sites involved procedures distributed flag authorization global variable important loc factor loc performance local variables reason main tested foo distributed authorization dashed edges represent interprocedural scenarios control shown flow pushdown types system arrows models figure control flow populated graph test shown environment rule certs auth certs called distributed pop rule sites push site rule runs separate machine number local configurations area pushdown network system test unbounded machines identical finite changed automata describe function kuserok infinite sets called configurations evaluates definition kerberos principal pushdown allowed system login p-automaton host finite change automaton option callers finite set function states k-spki sdsi transition server relation check set authorization nsf initial states knsf set square final states knsf automaton programssquaresolid knsf kedu configuration knsf square accepted kgovsquare p-automaton automaton accept kedu started programs kedu state schools written faculty kedu schools kwisc schools set configurations called regular gov p-automaton kgov accepts square important result govprogramssquaresolid kgov regular programs set kgovmanager configurations wisc post pre kwisc schools regular kuw sets kuw faculty configurations kuwchancellor verifying finite-state properties kuw section faculty kls describe faculty common approaches verifying finite-state kls properties faculty kcs pushdown faculty systems kls faculty approach kbio faculty verify cskcs safety faculty properties kcsalice bio programs figure test property setup supplied grants finite-state funda automaton apply performs transitions nsf icfg nodes programs automaton delegates designated error fundb state apply runs nsf icfg paths gov drive programs type error state arrows reported represent potentially test erroneous program scenario executions table automaton distributed shown authorization performance results fig scenario sites verify request time absence manager null-pointer gov dereferences fundb pointerp apply chancellor program funda matching automaton apply edge alice labels funda icfg nodes apply configurations mhz associate pentium iii null node ram running node tao linux version null table error shows null results null experiments fig expected finite-state number machine sites checking involved null-pointer distributed dereferences authorization program direct initial impact state performance machine system label complex stands case alice assignment non-null kerberos address sites pointer assume machine stays state transition undefined label actual program executions modeled pds constructed previous section icfg safety property verified cross-product automaton pds constructed rule pds transition automaton add rule pds reach configuration pds automaton error state appears component stack program invalid executions pds model-checking approach assertion checking boolean programs approach pds state stack alphabet expanded encode valuations boolean variables state space expanded include valuations global variables stack alphabet expanded include valuations local variables illustrate approach program shown fig boolean variables flag global variable andloci local variables valuation variables pair bits standing flag loci procedure valuation chosen icfg edge transformer transformer simply relation valuations encodes over-approximation effect icfg edge edge flag relation pds program constructed describing control flow intraprocedural rule describes control flow transformer edge add rules pds push rule add rules assuming local variables initialized procedure entry pop rules add rules pds obtained construction serves faithful model boolean program reachability analysis pds verifying assertions program node reached program execution configuration reachable pds values note approaches complementary verify safety properties boolean programs weighted pushdown systems weighted pushdown system obtained supplementing pushdown system weight domain bounded idempotent semiring semirings powerful encode infinite-state data abstractions copy-constant propagation affine-relation analysis definition bounded idempotent semiring quintuple set elements called weights elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight pushdown rule sequence rules associate define configurations path 
denote set rule sequences transform reachability problems pushdown systems generalized weighted pushdown systems definition letw weighted pushdown system wherep regular set configurations generalized pushdown predecessor gpp problem find circleplustext path generalized pushdown successor gps problem find circleplustext path construction ignore single state original pds single state provide information weighted pushdown systems perform finite-state verification designing weight domain verification safety properties set states property automaton define weight domain weight binary relation combine union extend composition relations empty relation identity relation wpds constructed pds rule describes control flow associate weight solve gps wpds singleton set consistings program starting configuration initial wpds configuration safety guaranteed checking sinit error configuration sinit starting state boolean programs encoded wpdss assume program global variables defer discussion local variables transformer icfg node simply relation valuations global variables set valuations global variables weight domain pds rule associate transformer icfg edge assertion checking performed configuration set configurations reached non-zero weight negationslash solving reachability problems section review existing algorithm solving generalized reachability problems wpdss based chaotic iteration present algorithm tarjan path-expression algorithm limit discussion gpp gps similar slightly tedious solving gpp chaotic iteration wpds pushdown system weight domain regular set configurations recognized p-automaton assume loss generality transitions lead initial state -transitions gpp solved saturating automaton weighted transitions transition weight label create automaton involved distributed authorization long takes simplest case manager gov sites involved prototype expect improve performance future optimizing code test setup extreme case kerberos site physical kdc practice logical kerberos sites share physical kdc improve real-world performance bio logical sites inside feasible reasonable physical kdc reduce network overhead considerably related work leveraging advantages kerberos public-key infrastructure pki explored pkinit ietf proposal extends kerberos public-key cryptography initial authentication clients kdc successful authentication kdc returns standard kerberos tgt client tgt access kerberos services pkinit addresses pki kerberos realm pkcross extends idea pki kerberos cross-realm authentication kdcs realms exchange public keys public-key cryptography authentication ticket exchange pkda kerberos eliminating kdc initial tgt exchange pkda kerberos client directly authenticates application server public-key cryptography receives service granting ticket sgt generated application server tgt needed pkda medvinsky pointed pkda implemented pkinit albeit required aforementioned work differs objective extend kerberos public-key infrastructures authentication purposes work goal kerberos reduce dependence spki sdsi pki approaches require modifications kerberos infrastructure approach k-pki addresses problem accessing kerberos services pki-based systems web applications k-pki special kerberos server kca generate short-term certificates authenticated kerberos clients client access kerberos services web applications authenticates web services generated certificate web services turn obtain kerberos credentials access kerberos services behalf client k-pki glue kerberos pki world complexity pki systems reduced clients certificates work hand reduce reliance trust-management systems pki result approach clients longer public private key pairs aspect work bring trust management spki sdsi kerberos-based infrastructures previous work extending kerberos authentication framework authorization services work generally assumes centralized authority address crossrealm authorization neuman work restricted proxy closest restricted proxy model building authorization services authorization servers capabilities access control spki sdsi superset restricted proxy offers features distributed trust management dce privilege service ecma sesame microsoft kerberos extension provide authorization capability optional field called authorization data provided kerberos authenticated kerberos client dce privilege service generates ticket called privilege attribute certificate pac membership information principal client presents kerberos ticket pac kerberos services client access sesame system ecma defines pac assert principal access rights microsoft kdc extension stores authorization information security identifiers group membership information inside tgts issued kdc authorization data application servers check users access privileges works common drawback unlike spki sdsi rely centralized authority granting access privileges authorization authority user contrast approach spki sdsi require central authority authorization decisions made decentralized manner spki sdsi based designed address centralized authority issue conventional pki-based apre systems spki sdsi read-off framework efficiently managing apre trust form combine certificates weights accepting decentralized paths approach starting spki sdsi central weight authority path needed extend principal weight-labels issue transitions certificates path order previous work present spki algorithm sdsi focuses building apre theoretic based aspects spki abstract sdsi grammar clarke problem definition proposed original meet semilattice algorithm abstract answering grammar authorization queries spki collection sdsi jha context-free grammar reps productions made improvement production clarke form algorithm applying pushdown-system theory construction due david melski problem algorithms require experimental certificates version centralized path inspector presented add system called loop error state certificate-chain discovery matches action distributed icfg manner node work spki check sdsi exit node adopted real program world similar primarily encoding due difficulty parentheses key-management issues commas pki-based systems work production addresses terminal problem symbols reducing spki production sdsi reliance function pki making kerberos string essentially terminal unchanged symbols derived relying kerberos grammar system denotes composition proven functions importantly corresponds widely unique approach make spki call sdsi valg easier simply adopted val real world understood blaze denote feigenbaum strings ioannidis terminals derivable keromytis nonterminal keynote trust-management abstract grammar system problem version rfc compute september nonterminal blaze modg feigenbaum ioannidis valg keromytis modg role called trust management distributed nonterminal systems define security abstract vitek grammars jensen meet editors secure semilattice internet programming security set issues weights mobile distributed shown fig non-terminal derive string val fig simple abstract grammar productions production popseq popseq popseq popseq popseq popseq popseq fig abstract grammar problem solving gpp abstract grammar objects solving gpp pages shown fig lncs john grammar brezak utilizing non-terminal popseqt windows authorization data transition kerberos tickets apre access control productions resources describe february weights http msdn microsoft transitions library computed default asp url library weight label enus dnkerb transition html msdn pac asp mod circa popseqt didier meet-overall-derivation caucal regular obtained structure prefix initialize rewriting theoretical computer transitions popseqt science popseqt citi popseqt projects kerberos production leveraged pki grammar http citi possibly umich fewer non-terminals projects right-hand side update weight label kerb pki circa dwaine existing clarke algorithm solving jean-emile gpp worklist-based algorithm elien carl chaotic ellison iteration matt choose fredette alexander transition morcos worklist ronald rivest certficate productions chain discovery transition spki sdsi journal side computer updates weight security european computer manufacturers transitions association ecma left secure european system side applications multi-vendor environment productions sesame https earlier cosic esat weight kuleuven transition sesame html sesame 
added documents worklist html circa defn guarantees carl convergence ellison chaotic bill iteration frantz scheme butler lampson ron efficient rivest brian abstract thomas grammar tatu fig onen rfc efficient spki certificate theory internet society september open group dce authentication security services http opengroup onlinepubs circa howell kotz formal semantics spki technical report department computer science dartmouth college hanover march matthew hur brian tung tatyana ryutov clifford neuman ari medvinsky gene tsudik bill sommerfeld public key cryptography cross-realm authentication kerberos november internet-draft txt jha reps model checking spki sdsi journal computer security somesh jha thomas reps analysis spki sdsi certificates model checking proceedings ieee computer security foundations workshop csfw pages ieee computer society june somesh jha thomas reps model checking spki sdsi journal computer security jim trust management system certified evaluation proceedings ieee symposium security privacy oakland olga kornievskaia peter honeyman bill doster kevin coffman kerberized credential translation solution web access control usenix security symposium pages ninghui william winsborough john mitchell distributed credential chain discovery trust management journal computer security february ari medvinsky matthew hur public key utilizing tickets application servers pktapp january internet-draft clifford neuman proxy-based authorization accounting distributed systems international conference distributed computing systems pages neuman kerberos authentication service computer networks ieee communications magazine pages september openafs http openafs circa stefan schwoon somesh jha thomas reps stuart stubblebine generalized authorization problems proceedings ieee computer security foundations workshop csfw pages ieee computer society june sirbu chuang distributed authentication kerberos public key cryptography february brian tung clifford neuman matthew hur ari medivinsky sasha medvinsky john wray jonathan trostle public key cryptography initial authentication kerberos internet-draft txt weeks understanding trust management systems proceedings ieee symposium research security privacy research security privacy oakland ieee computer society technical committee security privacy ieee computer society press 
saturating weights transitions start production alternating productions converge choosing production strategy choose production multiple times important identify loops transitions stay loop exiting solving gpp path expressions find iteration scheme gpp convert gpp hypergraph problem definition directed hypergraph generalization directed graph generalized edges called hyperedges multiple sources source edge ordered set vertices transition dependence graph tdg grammar hypergraph vertices non-terminals hyperedge production appearing lefthand side non-terminals order right-hand side construct tdg grammar shown fig underlying pds obtained icfg initial set configurations tdg identical icfg edges reversed fig shows observed fact pds states fig transition dependences identical dependences encoded pushdown rules turn icfg edges icfg edge corresponds transition dependence fig call-return pair icfg corresponds hyperedge pushdown systems constructing tdgs unnecessary choose initial set configurations defines region interest program pdss encode stronger properties icfg setjmp longjmp programs convenient tdg icfg rest paper illustrate issues tdg grammar fig reduce meet-over-all-derivation problem grammar meet-over-all-paths problem tdg intraprocedural iteration tdgs special form intraprocedural case hyperedges tdg correspondingly push rules pds assume tdg fig part procedurefoo hyperedges tdg edge inserted production weight label edge insert special node tdg production form insert edge label weight called source node graph weights edge define weight path graph standard reversed weight path extend weights constituent edges reverse order easy mod circleplustext path path set paths tdg weight path solve mod chaotic iteration make tarjan path-expression algorithm fig tdg pds shown fig wpds obtained pds supplementing rule number weight stand node thick bold arrows form hyperedge nodes source nodes dashed arrow summary edge edge labels explained problem directed graph fixed vertex single-source path expression sspe problem compute regular expression represents path vertices graph syntax regular expressions stands edge graph regular expression represents set paths language set paths sspe algorithm compute regular expressions path compact description set paths kleene-star operator identifies loops graphs reverse compute mod regular expression path replace edge weight solve expression weight computed bounded-height property semiring iteration converges main advantages regular expressions compute mod loops identified expression evaluation strategy saturates loop exiting compute faster normal iteration observe exponentiation defined computed repeatedly squaring converges computed logn operations chaotic-iteration strategy steps compute words closed representation loops exponential speedup assumes semiring operation takes amount time graph edges grammar productions case nodes non-terminals regular expressions path computed nodes time mlogn graph reducible evaluating expressions mlognlogh semiring operations height semiring high-level languages well-structured cfgs reducible programs assembly code found cfgs reducible graph reducible running time gradually degrades mlogn logh semiring operations sum cubes sizes dominator-strong components graph worst case experiments seldom found irreducibility problem small constant pure chaotic-iteration strategy semiring operations worst case comparing complexities expect faster chaotic iteration benefit greater height semiring increases interprocedural iteration generalize algorithm tdg hyperedge delete graph replace edge edge called summary edge node called out-node fig delete hyperedge replace edge called summary edge crosses call-site return node call node summarize effect procedure call node out-node supply procedure summary weight resultant tdg collection connected graphs graph roughly procedure fig transitions correspond procedures main foo split connected graph called intragraph intragraph introduce source node add edges source node nodes -productions weight labels added summary edge obtained hyperedge production function label collection intragraphs edges labeled weight simple expression out-node solve mod construct set regular equations intragraph unique source node out-node construct regular expression paths path expression replace edge label resulting expression out-nodes add equation set equations repeating intragraphs set equations variables correspond out-nodes resulting equations describe hyperpaths tdg out-node collection source nodes mod out-nodes greatest fixpoint equations tdg shown fig assuming out-node obtain set equations respect partial order iff equations depending 
sspe algorithm implemented equations solution shorthand solve equations chaotic iteration start initializing out-node greatest element semiring update values out-nodes repeatedly solving equations converge give direction chaotic iteration regular expressions equation rise dependences construct dependence graph equations time label edge equation assume out-node source node construct regular expression nodes sspe expressions give order equations evaluated set equations out-nodes regular expression paths suggests solve evaluation strategy evaluate update evaluate update repeating solution converges implementation simpler strategy strongly connected component scc decomposition dependence graph solve equations component moving equations component topological order chose strategy sccs tend small practice regular expression equations summarizes paths intragraph large avoid evaluating repeatedly solving equations end incrementally evaluate regular expressions part expression reevaluated modified out-node regular expression represented abstract-syntax tree ast leaves weights out-nodes internal nodes correspond ast regular expression out-node fig shown fig out-node updated reevaluate weight subtrees update out-node weight fig ast internal nodes converted nodes reversing order children internal nodes ast names optimization regular expressions share common subtrees represented dags trees incremental algorithm takes care sharing identifies modified out-nodes expression automatically dag node maintain integers change weight weight subdag rooted node assume regular expressions share leaves out-nodes global counter update count incremented time weight out-node updated node counter change records update count weight subdag changed counter records update count subdag reevaluated stand evaluation algorithm shown fig weight out-node changed leaf node updated weight update count incremented out-node counters set update count procedure evaluate begin update count return case return case evaluate change negationslash weight weight negationslash change change weight update count case evaluate evaluate max change change negationslash weight weight weight negationslash change weight update count end fig incremental evaluation algorithm regular expressions solve values out-nodes change out-node labels summary edges intragraphs replace weight mod values nodes tdg obtained intraprocedural version intragraph isolation time required solving system equations depends reducibility intragraphs time required solve sspe intragraph mlogn worst-case ignorable practice equations mutual dependences recursion running time summationtextg logh sum ranges intragraphs equation solved presence recursion observation weight subdag regular expression change times equations solved decrease monotonically size regular expression obtained intragraph bounded worst-case time solving equations summationtextg bound pessimistic worse chaotic iteration make fact incrementally computing regular expressions faster reevaluating regular expression modified out-node perform semiring operations node out-node leaf root expression balanced regular expression tree path root small logsg empirically found incrementally computing expression required fewer operations recomputing expression unlike chaotic-iteration scheme weights tdg nodes computed compute weights out-nodes weights rest nodes computed lazily applications require weight tdg nodes additional savings algorithm executed multi-processor machines assigning intragraph processor communication required processors weights out-nodes saturated handling local variables wpdss recently extended extended-wpdss ewpdss provide convenient mechanism handling local variables ewpdss similar wpdss special merge function push rule addition weight merge functions binary functions weights merge weight returned procedure weight call site procedure compute required weight return site giving formal definition ewpdss merge functions describe encode boolean programs local variables ewpds note gave encoding boolean programs local variables set global variable valuations set local-variable valuations assume procedures number local variables icfg edge transformer binary relation weight domain pds rule transformer icfg edge addition push rule merge function argument weight accumulated call-site argument summary called function merge function forgets local variables argument composes global information arguments reachability problems ewpds solved abstract grammar abstract grammar gpp ewpdss shown fig differs wpds case solve gpp require change hyperedges tdg case fig out-node label summary edge application merge functions amounts passing global information intragraphs production popseq popseq popseq popseq popseq popseq popseq popseq popseq popseq fig abstract grammar problem gpp ewpds merge function rule solving pds problems witness tracing program-analysis tools program satisfy property provide justification property satisfied terms wpdss amounts reporting set paths rule sequences justify reported weight configuration formally notation defn witness tracing problem gpp find configuration set uniontext path circleplustext definition witness tracing impose restrictions size reported witness set compact representation set suffices applications defn create finite witness set shown witness set found recording weight transition gpp saturation procedure weight transition updated differs recorded transition weight created transition weight transitions weights iii production function corresponds wpds rule witness set configuration obtained individual transitions running time covered gpp saturation procedure requires memory large gpp algorithm head start regular expressions describe paths intragraph intragraphs label edge weight rule justifies edge push rules summary edges pop rules edges originate source node edges source node inserted production fig rule empty rule sequence solving sspe intragraphs replace edge rule label out-node regular expression terms out-nodes captures set rule sequences create out-node solving regular equations record weights out-nodes solve equation record weights weight set rule sequences create transition weight expression replace tdg edges rule labels replacing out-node regular expression rule sequences create weight obtained recursively regular expression witness set out-node witness sets transitions obtained solving sspe intragraphs replacing out-node labels witness-set expression require space recording witnesses number out-nodes pdss obtained icfgs empty initial automaton number procedures icfg small compared differential propagation general framework wpdss inefficient analysis executing gpp weight transition weight propagated transitions weight propagated extra work propagating part propagated simple observation incorporated wpdss semiring weight domain special subtraction operation called diff denoted diff operator satisfy properties weight domains presented finite-state property verification set difference relations considered sets tuples satisfies required properties make diff operation solving set regular equations addition incrementally computing regular expressions incrementally compute weights weight out-node associate leaf node change change propagated nodes weight expressions change weights kinds expressions change computing change kleene-star chaotic iteration suffers problem diff operator compute kleene-star closure weight begin wstar del del negationslash temp del del temp wstar wstar wstar temp end incremental analysis incremental algorithm verifying finite-state properties icfgs conway methods presented paper generalize algorithm wpdss incremental approach model checking advantage amortizing verification time program development debugging time cases addition rules deletion existing case work granularity intragraphs rule added fixpoint solution regular equations monotonically decreases reuse existing computation identify intragraphs changed edges rule recompute regular expression out-nodes intragraphs solve regular expressions set initial weights out-nodes existing out-nodes added set initial deletion rule requires work 
identify changed intragraphs recompute regular expression out-nodes intragraphs outnodes called modified out-nodes dependence graph outnodes constructed perform scc decomposition graph topologically sort sccs weights out-nodes scc modified out-node changed recompute solution out-nodes topological order stop values agree previous values start out-nodes scc modified out-node solve weights weight out-node previously computed weight out-nodes sccs dependent marked modified repeat procedure modified out-nodes advantage incremental analysis framework information stored analysis runs store weights out-nodes algorithm demand-driven compute required user experiments implemented algorithm back-end wpds implementation wpdss interface presented wpds clients unchanged refer implementation fwpds compare fwpds optimized version wpds version called bfs-wpds supplied user priorityordering stack symbols chaotic iteration choose transition priority application breadth-first ordering icfg obtained treating graph bfs-wpds performed wpds experiments compute witnesses experiments basic saturation algorithm tested algorithm applications application btrace debugging performs path optimization programs set icfg nodes incremental algorithms sspe solving sspe single intragraph fast stands fast called critical nodes find shortest icfg path touches maximum number nodes path starts entry point program stops failure point program perform gps entry point program initial configuration compute weight failure site measure endto-end performance advantage lazy nature algorithm compute weight failure site shown table fwpds performs bfs-wpds application prog icfg nodes procs bfs-wpds fwpds improvement gawk indent make patch wget table comparison btrace results running times reported seconds improvement ratio running time fwpds versus bfs-wpds critical nodes chosen random icfg nodes failure site set exit point program programs common unix utilities experiments run ghz machine ram application nmoped model checker boolean programs wpds library performing reachability queries weights binary relations variable valuations represented bdds measure performance fwpds library results shown table inconclusive attribute big differences running times bdd-variable ordering fwpds performs sequence weight operations turn bdd operations variable ordering crucial operations prog icfg nodes procs nmoped fwpds improvement blast rem qsort rem simplinv rem qsortirrel rem intint rem files rem table comparison nmoped results experiments run ghz machine ram programs provided schwoon incremental analysis measure advantage incremental analysis btrace similar experiments performed delete procedure program solve gps reinsert procedure time takes solve gps incrementally compare time time takes compute solution scratch repeated procedures program discarded runs affect procedure results shown table shows average speed factor prog procs recomputed time sec improvement table results incremental analysis btrace column average number procedures solution recomputed column compares time required compute solution incrementally versus time required compute solution scratch reported table related work basic strategy regular expression describe set paths previously dataflow analysis dataflow analysis single-procedure programs generalized approach multi-procedure programs pushdown systems related work discussed body paper lengthy discussion pds model checking finite-state property verification found host previous work incremental model checking interprocedural automaton-based analysis incremental algorithm presented similar algorithm generalizes wpdss applicable domains finite-state property verification key difference algorithm explore property automaton on-the-fly program explored encoding wpds requires automaton program explored difference significant automaton large small part automaton generated esparza schwoon bdd-based model checker recursive programs cav schwoon moped http fmi uni-stuttgart szs tools moped lal reps balakrishnan extended weighted pushdown systems cav grammatech codesurfer path inspector http grammatech products codesurfer overview html lal lim polishchuk liblit path optimization programs application debugging esop conway namjoshi dams edwards incremental algorithms interprocedural analysis safety properties cav reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis scp volume bouajjani esparza maler reachability analysis pushdown automata application model checking concur finkel willems wolper direct symbolic approach model checking pushdown systems electronic notes theoretical computer science schwoon model-checking pushdown systems phd thesis technical univ munich munich germany esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems cav myers precise interprocedural data flow algorithm popl tarjan fast algorithms solving path problems acm tarjan unified approach path problems acm jha reps analysis spki sdsi certificates model checking ieee comp sec found workshop csfw ieee computer society press schwoon jha reps stubblebine generalized authorization problems comp sec found workshop wash ieee comp soc reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis sas bouajjani esparza touili generic approach static analysis concurrent programs procedures popl kidd reps melski lal wpds library weighted pushdown systems http wisc wpis wpds kiefer schwoon suwimonteerabuth nmoped http informatik unistuttgart fmi szs tools moped nmoped sokolsky smolka incremental model checking modal mu-calculus cav henzinger jhala majumdar sanvido extreme model checking verification theory practice 
weighted pushdown systems weighted transducers akash lal tayssir touili nicholas kidd thomas reps wisconsin madison wisconsin usa akash kidd reps wisc liafa cnrs paris paris france touili liafa jussieu abstract pushdown systems pdss important formalism modeling programs reachability analysis pdss extensively program verification key result made pdss popular model-checking community set reachable stack configurations starting regular set configurations regular general result caucal showed pds reachability relation maps stack configurations reachable set stack configurations encoded finite-state transducer paper generalize result weighted pushdown systems haveproven bevery model checking dataflow analysis algorithm efficient construction transducers ordinary unweighted pdss give direct saturation algorithm constructing transducers single-state pdss introduction pushdown systems pdss important formalism modeling programs generalization finite-graph control models programs ability simulate program control stack stack pds describe faithfully paths matched procedure calls returns program stack unbounded size pds represents infinite graph nodes correspond stack configurations pds edges valid transitions configurations defined rules pds program verification common reduce safety-property verification problem reachability graph program model program violates property node target reachable node source graph multiple source target pairs precompute summarize reachability information graph performing separate reachability query pair finite-graph models summarization performed taking transitive closure graph source-target reachability answered constant time natural summarization set infinite graphs definable pdss caucal answered question showing reachability relation infinite graph defined pds encoded finite-state transducer node stack configuration reach node pair input-output relation transducer paper extend result weighted pushdown systems wpdss pdss encode infinite control abstraction stack model infinite data abstraction unweighted pdss encode finite abstractions data predicate abstraction boolean programs wpdss address issue associating weight pds rule weights encode abstract transformers infinite lattice additional properties wpdss model program effectively pds weights goal longer compute reachability compute meet-over-allpaths values pds transition relation path problems wpdss solved creating weighted transducer applying simple transducer-automaton composition operation considerable work forward backward reachability algorithms pdss wpdss algorithms based saturation procedures add transitions possibly weights automaton represents set configurations fixpoint reached point resulting automaton represents desired answer started working constructing transducers attempt generalize algorithms work transducers automata succeeded extending algorithm single-state pdss algorithm work general pdss wpdss general algorithm highlights difficulties extending existing algorithms work transducers obtain general transducer construction pdss wpdss principle multiple calls existing saturation procedures construct parts transducer combined obtain desired transducer algorithm presented wpdss techniques algorithm resemble caucal make recent developments wpds technology provide bounds complexity construction algorithm specialized pdss efficient construction transducers pdss show single-source single-target path problems wpdss st-path problems short solved efficiently transducers constructed existing algorithms based saturation contributions paper summarized present algorithm constructing transducer represents reachability relation pds wpds algorithm constructing transducers unweighted pdss transducer construction attempted wpdss show transducers solve st-path problems wpdss efficiently existing algorithms similar current saturation algorithms forward backward reachability pdss deal finite-state automata give direct saturation procedure constructing transducers single-state pdss construction work general pdss wpdss illustrates difficulty extending existing algorithms produce transducer similarly finite weighted graphs transitive closure generalizes problems all-pairs shortest-path problem meet-over-all-paths problem summary history reachability algorithms pdss rest paper organized discuss pdss give background modeling programs show transducers solving reachability problems pdss give direct saturation-based algorithm constructing transducer single-state pdss discuss wpdss give weighted-transducer construction show efficiently solving st-path problems discusses related work short proofs non-trivial lemmas theorems appendix pushdown systems definition pushdown system triple set states control locations set stack symbols set pushdown rules configuration pair rule written rules define transition relation configurations reflexive transitive closure denoted set configurations define pre post backward forward reachability transition relation restrict pushdown rules stack symbols right-hand side restriction decrease power pushdown systems increasing number stack symbols constant factor arbitrary pushdown system converted satisfies restriction standard approach modeling program control flow pushdown system single state corresponds program locations corresponds transitions interprocedural control-flow graph icfg fig state space expanded encode finite abstraction global state stack space expanded encode local variables rule control flow modeled intraprocedural cfg edge genter call returns gexit return procedure fig encoding icfg edges pds rules number configurations pushdown system unbounded finite automata describe regular sets configurations definition pushdown system p-automaton finite automaton finite set states transition relation set initial states set final states configuration accepted p-automaton automaton accept started state written set configurations called regular p-automaton accepts loss generality restrict p-automata transitions leading initial state animportantresult thatfor regularsetof configurationsc post pre regular sets configurations algorithms computing post pre called poststar prestar p-automaton input set configurations accepted produce p-automata apost apre accept set configurations post pre algorithms prestar poststar called saturation procedures involve adding additional transitions automaton long criteria met transducers expressing reachability pushdown systems section define st-reachability problem pdss show solved transducers section fix pds definition configurations st-reachability problem determine problem solved prestar poststar checking post pre show problem solved transducers definition finite-state transducer tuple finite set states input output alphabets transition relation set initial states set final states written transducer state input outputs symbol state transducer accept string output path state final state takes input outputs language transducer defined subset transducer output string input pds construct transducer single initial state accepts input output transducer effect captures transitiveclosureofthe pds transitionrelation fornow assume exists method constructing actual algorithm wpdss wpdss generalization pdss algorithm applies pdss derive theorem thm theorem pds transducer constructed accepts input outputs transducer constructed time states st-reachability problem reduces membership query language transducer general reachability problems solved prestar poststar solved transducer define application transducer automaton simplify discussion loss generality assume input output alphabets transducer definition transducer defines language automaton accepts language transducerautomaton application defined automaton accepts image language application computed manner similar automaton intersection transition transition add transition application computed quadratic explosion state space transducer input output labels transitions swapped corollary definition thm corollary pds transducer thm configuration set represented automaton post pre corollary computing forward backward reachable sets transducer-automaton applications lead faster algorithms previous saturation-based algorithms approach solving problem combine recent advances automata-theoretic algorithms regular model checking section give construction transducer single-state pds construction direct saturation algorithm applies transducer unlike construction wpdss saturation steps compute transducer construction generalize multiplestate pdss strictly powerful single-state pdss wpdss transducer construction single-state pdss pds single state restricting 
single-state pdss transducers section include input output alphabet describe relations stacks transducer transitions form slightly modified p-automaton alphabet extended states stack symbols pds accepts pds state symbol initialize starting state required p-automaton minor change representation mention explicitly rest paper transducer represents subset identity relation starting create transducer iff transition relation represents identity relation configurations capture reachability relation preceding section idea algorithm parts part transitions form allowed part transitions allowed transducer constructed move part part direction -transitions beginning accepting run intuitively part obtained making kind copy part rewrites letters allowed rules pds state introduce state intended satisfy condition transition iff transition create transducer states correspond extra states added poststar saturation algorithm defined squiggleright denotes rule transition form add path form squiggleright add transition rule transition form add path form squiggleright add transition rule transition form add path form squiggleright add rules extensions standard saturation procedures pdss transducers path pds rule ensured rules definition inductive computed limit finite sequence increasing sets transitions transitions termination guaranteed bounded number states bounded number transitions proofs lemmas appendix lemma configuration final state lemma theorem transducer language identity relation single-state pds transducer constructed steps states transitions set states running time construction construction transducers wpdss section specialized multiple-state pdss efficient algorithm presented algorithm shows non-trivial extend existing saturation algorithms transducers key difficulty saturation rules paths transducer unlike saturation algorithms automata transitions leaving initial state arises due fact -closure automata performed easily -closure transducers removing transitions form section principle construct transducers wpdss calls saturation-based procedures construct parts transducer weighted pushdown systems weighted pushdown system obtained augmenting pushdown system weight domain bounded idempotent semiring semirings powerful encode finite-state data abstractions required boolean program verification infinite-state data abstractions copy-constant propagation affine-relation analysis small survey safety-property boolean program verification pdss respective encoding wpds basic idea weights encode effect rule data state program definition quintuple set elements called weights elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains height weight domain defined length longest descending chain domain definition weighted pushdown system triple pushdown system bounded idempotent semiring map assigns weight rule sequence rules associate define configurations path denote set rule sequences transform path reachability problems pdss generalized wpdss definition weighted pushdown system regular sets configurations meetover-all-paths mop defined circleplustext pds simply wpds boolean weight domain weight assignment rules case mop iff path configuration configuration important weight domain wpdss set binary relations finite set finite set atoms valid weight domain weights binary relations combine union sets pairs extend relational composition empty relation identity relation weight domain encoding boolean programs programs boolean variables wpdss set instantiated set valuations boolean variables weight associatedwith pds ruleis effect executing correspondingicfgedge program variables weight domain tool moped includes local variables assertion checking boolean programs performed checking configuration set assertions reachable nonweight mop negationslash starting set configurations program details pdss model checking encoding wpdss found wpds weight domain finite number weights encoded pds wpdss deal infinite weight domains affine-relation analysis finite weight domains weights symbolically encoded tool moped scale large number variables bdds encode binary relations represented weights algorithms solving mop values called prestar poststar analogy reachability algorithms pdss input automaton accepts set initial configurations output produce weighted automaton defined definition weighted pushdown system automaton p-automaton transition automaton labeled weight weight path automaton obtained taking extend weights transitions path forward backward direction depending context automaton automaton accept configuration weight combine weights accepting paths starting state call automaton backward w-automaton weight path read backwards forward w-automaton unweighted automaton set configurations accepted prestar produces forward weighted automaton apre output apre mop poststar produces backward weighted automaton apost output apost mop standard automata-theoretic techniques compute forward backward weighted automaton regular set configurations circleplustext solve meet-over-all-paths mop configuration sets poststar prestar lemma states complexity solving poststar algorithm reps comparison algorithms presented paper notation denote time bound gst upper bound time semiring operation lemma wpds pds p-automaton accepting input set configuration poststar produces backward weighted automaton states time set transitions leading states height weight domain rest section fix pds wpds height transducers solving path problems wpdss wpdss create weighted transducer accept input output weight combine values paths wpds mop defer definition weighted transducer section defn set solving st-path problems make observation paths pds transition relation suppose configuration pds path transition relation starting configuration written shown fig figure shows path starts initially popping stack symbols symbols figure possibly multiple steps touch rest stack top symbol note path pop stack symbols stop pds rule fire empty stack fig path pds transition relation make observation formal decompose path phases pop-phase path pops top stack symbol rest stack sequence rules takes configuration growth-phase path top stack possibly rewrites pop sequence rules takes configuration path pds transition relation pop-phases single growth-phase construct transducer st-reachability essentially pre-computing phases wpds defined defn define procedures pop defined pop circleplustext grow defined grow circleplustext simple inefficient computing function solve poststar produce weighted automaton represents function right-hand side lemmas give efficient algorithms computing procedures proofs appendix lemma p-automaton represents set configurations apop forward weighted-automaton obtained running prestar pop weight transition apop generate apop time states lemma p-automaton represents configuration automaton leave set final states undefined agrow backward weighted-automaton obtained running poststar restrict final states agrow remove states accepting path final state obtain backward weighted-automaton represents grow automaton started state accepts input weight grow call automaton compute agrow time states advantage construction presented lemma requires single poststar query compute query standard poststar automaton construction builds automaton larger input automaton lemma agrow fewer states put fig shows automata simple wpds constructed minpath semiring semiring defined min rules weight semiring weight numeric mop weight configurations length shortest path fig simple wpds minpath semiring apop automaton edges labeled stack symbol weight agrow automaton automaton obtained agrow automaton obtained agrow unnamed state extra state added post algorithm lemma idea approach apop simulate phase pds pops stack symbols transducer non-deterministically decides switch growth phase state apop symbol input passes control start generating output moves accept phase copies untouched part input stack output agrow avoid introducing 
separate copy agrow final states restricted unreachable states appropriately pruned essence transducer non-deterministically guess stack symbol pass control verify guess correct reaches final state result copies agrow note apop forward weightedautomaton agrow backward weighted-automaton mix transducer transducer switch directions computing weight path back fig pds rule sequence consumes input configuration left pop phase produces output stack configuration left pushes symbols stack transducer produce output left switch directions computing weight path define partitioned transducers definition partitioned weighted finite-state transducer tuple finite set states partition bounded idempotent semiring input output alphabets transition relation set initial states set final states impose restriction transition relation state transducer accept string output path state final state takes input outputs computing weight path requires care path states weight ith transition states weight path odd statespace partition determines direction perform extend path crosses multiple partitions path inside restrict weighted finite-state transducer final states partition set initial states partition set paper refer partitioned weighted transducers weighted transducers simply transducers possibility confusion note extend operator commutative case boolean semiring encoding pdss wpdss partitioning unnecessary denote set states automaton apop subset set states distinguish referring state apop qpop wpds construct weighted transducer steps states apop uniontextp input alphabet output alphabet weight domain initial state final state pair configurations operates shown fig simplicity stack configurations shown consumes prefix apop step produces prefix agrow steps copies suffix output step state add transition ppop weight transition pop pop weight apop add transition pop pop weight copy apop transition automaton add transition weight copy add transition ppop weight transition permits switch pop phase growth phase point growth phase begins state ends state guess stack symbol growth phase starts step verifies guess correct final state add transition weight transition verifies input tape computed growth phase starting add transition weight transition skip growth phase add transition weight part transducer copies untouched part input tape output tape fig phases operation input-output pair state-partition apop uniontextp transducer wpds fig shown fig theorem transducer constructed input combine values paths output string precisely mop transducer constructed time states transitions wpdss derived programs case constructing transducer similar complexity size running single poststar query short proof thm appendix constructing transducer forward backward reachability solved transducer-automaton application unweighted case difference weight labels preserved performing application weighted automata partitioned transducer computing mop values required unweighted automaton represents set configurations compute poststar computing requires time number transitions note apop fig weighted transducer wpds shown fig boxes represent copies apop required steps transducer paths accept input output weight highlighted bold require semiring operations independent fact transducer-automaton application simple algorithm imply poststar solved faster transducers disadvantage approach weighted automaton obtained result transducer-automaton application larger obtained previous saturation algorithms transducer applications advantageous leave study future work section shows transducer efficiently solve stpath problems restricted single source single target configuration solving st-path problems configurations section show mop solved efficiently transducer constructed previous section thm compute combine values paths input produce output call weight carried weights read weighted automaton based standard nfa simulation algorithm back intuition fig common suffix paths length form part composed rules pop-phase part composed rules growth-phase define weights xpu circleplustext ypu circleplustext circleplustextp xpu ypu circleplustext common suffix abbbbb bbb wpds fig choose suffix choose suffix bbb wbbb length shortest path apop agrow final states restricted xpu meet-over-all-paths weight state started state input requires time compute length weight ypu meet-over-all-paths weight state started state input requires time compute length putting results calculate combine weights paths time faster existing prestar poststar algorithms independent height weight domain big improvement height weight domains boolean programs beginning predicate abstraction exponential number boolean variables predicates simulating give weight time complexity part accepts untouched part stack simply copy apop copies agrow related work mentioned introduction transducer construction solving reachability pdss earlier caucal construction prefix-rewriting systems general accompanied complexity result fact runs polynomial time construction pdss obtained special case construction simple efficient technique related caucal constructed transducer exploiting fact language transducer union relations pre post identity relation appended accept untouched part stack similar decomposition pds paths fig extension result wpdss solve st-path problems efficiently existing algorithms large body work weighted automata weighted transducers speech-recognition community weights applications satisfy properties semiring including existence inverse commutativity extend refrain making assumptions weight domains dataflow analysis properties balakrishnan reps kidd lal lim melski gruian yong chen teitelbaum model checking executables codesurfer wpds cav bouajjani languages rewriting systems verification infinte-state systems icalp bouajjani esparza finkel maler rossmanith willems wolper efficient automata approach problems context-free grammars inf proc bouajjani esparza maler reachability analysis pushdown automata application model checking concur bouajjani esparza touili generic approach static analysis concurrent programs procedures popl bouajjani jonsson nilsson touili regular model checking cav caucal regular structure prefix rewriting tcs caucal monfort transition graphs automata grammars graph-theoretic concepts computer science pages esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems cav finkel willems wolper direct symbolic approach model checking pushdown systems electronic notes theoretical computer science grammatech codesurfer path inspector http grammatech products codesurfer overview html jha reps analysis spki sdsi certificates model checking csfw kesten maler marcus pnueli shahar symbolic model checking rich assertional languages tcs kiefer schwoon suwimonteerabuth moped http informatik uni-stuttgart fmi szs tools moped nmoped kildall unified approach global program optimization popl lal lim polishchuk liblit path optimization programs application debugging esop lal reps improving pushdown system model checking cav pages lal reps improving pushdown system model checking technical report wisconsin-madison jan lal reps balakrishnan extended weighted pushdown systems cav mohri finite-state transducers language speech processing computational linguistics mohri pereira riley weighted automata text speech processing ecai mohri pereira riley design principles weighted finite-state transducer library tcs uller-olm seidl precise interprocedural analysis linear algebra popl reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis sas reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis scp schwoon model-checking pushdown systems phd thesis technical univ munich munich germany july schwoon jha reps stubblebine generalized authorization problems csfw wolper boigelot verifying systems infinite regular state spaces cav proofs lemma transition system sequence transitions state state input output denote derived steps proceed 
induction property holds configuration induction cases depending length case similar cases derivation form case rule implies derivation form squiggleright case rule implies cases lemma proceed induction number occurrences states form derivation proof case lines proof schwoon shows saturation procedure poststar computes automaton recognizes post derivation form squiggleright rule transition added squiggleright aretwo cases depending formof derivationq squiggleright derivation form derivation holds squiggleright derivation occurrences states form induction rule pds property holds case derivation form transition added sequence pds rules initially derivation transitions added transition rule pds transition rule pds transition rule pds derivation holds show nlw property holds case lemma formal proof lemma follow characterization rule sequences automaton transition represents based abstract grammar formulation prestar give slightly informal intuitive proof fact saturation-based implementation prestar correct lemma runs prestar empty automaton represents configuration set stack symbol automaton states negationslash single transition final state automaton negationslash running prestar return automaton returned running prestar empty automaton extra transition rule match represents configuration set pop definition pop weight transition path accepts starting state transitions results repeating argument lemma proof similar lemma negationslash stack symbol automaton extra state extra transition final state automaton represents configuration set automaton returned poststar represent configuration set grow appended end stack proof fact running poststar running exception extra -transition theorem proof based observation made fig suppose path pds transition relation broken shown fig fig path pds transition relation weights step transducer path starting takes transition ppop step construction moves state apop successively takes transitions step time staying inside apop weight ith transition iff lemma transducer transition step move apk path outputs move state qpk path apk accept starting state representing configuration final state qpk lemma combine weights paths transducer transducer transition qpk step copy stack output tape final state step path input output required combine weights paths weight path shown fig note path transducer transitions inserted step path shown fig growth phase arguetheother direction reasoningis similar path inthe transducer start state move apop move state keeping track input output required path build wpds path fig lemmas weight path transducer combine weights paths configurations pds transition relation 
distributed certificate-chain discovery spki sdsi stefan schwoon hao wang somesh jha thomas reps institut formale methoden der informatik universit stuttgart schwoosn fmi uni-stuttgart computer science department wisconsin hbwang jha reps wisc abstract authorization problem decide security policy principal allowed access resource trust-management system spki sdsi security policy set certificates proofs authorization form certificate chains problem discover proof authorization request algorithms spki sdsi investigated researchers previous work address perform certificatechain discovery distributed environments address problem certificates distributed number sites cooperate identify proof authorization request propose protocols purpose protocols handle cases certificates labeled weights multiple certificate chains combined form proof authorization implemented protocols prototype report preliminary results evaluation introduction access control shared computing resources authorization problem addresses question security policy principal allowed access specific resource trust-management systems spki sdsi security policy set signed certificates proof authorization consists set certificate chains spki sdsi principals public keys identity principal established checking validity public key spki sdsi certificates define names issuer local space authorization certificates grant authorizations delegate ability grant authorizations problem discover certificate chain proof authorization request access resource principal schwoon introduced algorithm certificate-chain discovery translates spki sdsi certificates rules weighted pushdown system wpds algorithm presented discover proofs authorization consist multiple certificate chains approach translate spki sdsi certificates rules wpds authorization specifications certificates translated weights rules translation wpds yields complete algorithm section spki sdsi designed provide trust management distributed environments original proposal address authorization form certificate chains performed distributed environments issue neglected previous work certificate-chain discovery instance algorithms assume set certificates relevant request single site compute answer authorization problem principal resource practice central authority certificates held number sites subset certificate set principal site access resource site certificate chain authorizing involve certificates possibly number sites instance computer sciences department wisconsin part college letters sciences department college sites sense grant access resource faculty members issuing authorization certificate actual principals authorized access certificates declare faculty members declare faculty members list faculty members members access chain certificates sites certificates involved paper makes contributions describe distributed algorithm certificates distributed sites distributed algorithm section algorithms presented paper automaton-based compared limited amount previous work exists authorization problem distributed setting automaton-based approach enjoys advantages approaches fragments automata computed separate sites information shipped sites form fragments automata implemented prototype system incorporates algorithm experimental results presented section demonstrate distributed algorithm efficient scalable approach benefits wpds underlying technology previous work wpds pointed weighted domains enable address issues privacy recency validity trust weighted domains handle authorization specifications semantically correct manner additionally wpds-based reachability-analysis algorithms answer certificate-analysis questions case authorizations resource involve certificate signed principal types certificate-analysis questions discussed orthogonal work presented discuss paper related work algorithm spki sdsi proposed clarke improved certificatechain-discovery based theory pushdown systems presented jha reps algorithms centralized assume proof authorization consists single certificate chain general proof authorization spki sdsi requires set certificate chains proves part required authorization algorithms presented incomplete observation basis observation mitchell -tuple reduction rule incomplete algorithm suffer problem due translation wpds semantics spki sdsi studied pca framework appel felten client theorem prover twelf construct proof authorization client presents server assume logical facts theorem prover reside single server presented distributed credentialchain-discovery algorithm trust management system algorithm credentials distributed proof authorization constructed site algorithms fetches credentials sites needed spki sdsi subset spki sdsi equivalent role intersection distributed algorithm sites summarize part proof authorization sending sites proof authorization distributed summarizing intermediate results privacy implemented algorithm trust-management server knowledge implement algorithm work jim suciu successor qcm related trustmanagement system based datalog algorithms distributed evaluation authorization queries author claims express roughly policies sdsi claim substantiated true differences set work describes generic evaluation algorithm instantiation corresponds strategy distributing computation propose concrete evaluation strategies argue strategies advantages respect efficiency privacy provide concrete encoding spki sdsi comparison relative merits encoding bound speculative site-safety requirement limit evaluation forward mode algorithms search forward backward explained section unlike framework certificates weights pointed solution situations proofs authorization require multiple certificate chains prove part authorization solves problem semantic incompleteness pointed mitchell pointed weights address issues privacy recency validity trust background spki sdsi spki sdsi principals represented public keys principal public key principal individual process host entity denotes set public keys specific keys denoted identifier word alphabet set identifiers denoted identifiers written typewriter font bob term key identifiers terms keys local names extended names local form bob local local names important spki sdsi create decentralized space local space set local names form extended form sequence identifiers length greater faculty extended certificates spki sdsi types certificates certs certificates certs cert definition local issuer local space key issue sign cert defines local space cert signed four-tuple issuer public key certificate signed identifier subject term intuitively additional meaning local validity specification certificate takes form interval cert valid time inclusive authorization certificates auth certs auth cert grants delegates specific authorization issuer subject specifically auth cert five-tuple issuer public key sign cert subject term delegation bit turned subject receiving authorization delegate authorization keys authorization specification specifies permission granted permission read specific file permission login host validity specification auth cert case cert labeled rewrite rule pair component rewrite rule component authorization specification notational convenience write labeled rewrite rule treat certs labeled rewrite rules cert written labeled rewrite rule authorization specification authorization specifications write simply rewrite rule form implicit label auth cert written square square delegation bit turned written square squaresolid authorization labeled rewrite rules paper refer rewrite rules simply rules term appearing rule viewed string alphabet elements beginning uniformity refer strings form square squaresolid terms assume labeled rewrite rule cert term case labeled rewrite rule applied term denoted yields term rule viewed function terms terms rewrites left prefix argument bob bob myfriends myfriends authorization problems valid certificates validity specification certificate included rule issue intersection union authorization specifications discussed detail rules addition assume prefix exists composition rule rules friends bob myfriends bob composition friends myfriends rules called compatible composition defined authorization problem spki sdsi assume set certs principal owns set resources identified authorization specifications assume principal access authorization specification call resource owner client authorization question granted access resource certificate chain form certificates label certificate chain denoted algorithm finite set certificate 
chains proving allowed access formally certificate-chain discovery attempts find finite set chm certificate chains chi square square squaresolid muniondisplay chi clarke presented algorithm certificate-chain discovery spki sdsi time complexity number keys sum lengths right-hand sides rules algorithm solved restricted version certificate-chain discovery solution consist single certificate chain instance certificate set dir read dir write suppose alice makes request dir set read write case chain authorizes alice read directory separate chain authorizes write prove read write privileges certificates removed certificate set prior running certificate-chain discovery algorithm clarke read negationslash set read write write negationslash set read write proof authorization alice request found schwoon presented algorithms full certificate-chain discovery based solving reachability problems weighted pushdown systems formalization proof authorization consist set certificate chains paper wpds-based algorithm certificate-chain discovery introduced weighted pushdown systems spki sdsi section introduce weighted pushdown systems briefly review algorithms proposed show tool solving problems related certificate-chain discovery spki sdsi definitions largely general composition operator associative compatible exist exist exists expressions equal defined omit parentheses assume associative weighted pushdown systems weighted pushdown systems introduced short pushdown system defines infinite-state transition system states involve stack unbounded length weighted pushdown system rules values domain weights weight domains interest bounded idempotent semirings defined defn definition bounded idempotent semiring quintuple set elements combine operation extend operation binary operators commutative monoid neutral element idempotent monoid neutral element distributes annihilator respect partial order defined iff infinite descending chains definition pushdown system triple finite sets called control locations stack alphabet elements conf called configurations finite number rules form define transition relation configurations write express exists rule omit subscript understood reflexive transitive closure denoted set configurations define pre post sets configurations reachable backwards forwards elements transition relation called regular language regular definition weighted pushdown system triple pushdown system bounded idempotent semiring function assigns rule sequence rules associate define configurations path denote set rule sequences transform definition set configurations forwards resp backwards -dag edge-labeled directed acyclic graph conf vertex incoming edges incoming edges circleplustextki forwards -dag circleplustextki backwards -dag call forwards backwards -dag witness dag finite vertex outgoing edges notice extender operation calculate path set paths computed combiner operation existence witness dag considered proof exists set paths vice versa combined defn identify finite witness dag set paths exists results briefly review results weighted pushdown systems pushdown system regular subset conf sets pre post regular effectively computable form finite automaton results show result extended generalized pushdown reachability gpr problems weighted pushdown systems definition weighted pushdown system regular set configurations generalized pushdown predecessor gpp problem find pre circleplustext path backwards witness dag generalized pushdown successor gps problem find post circleplustext path forwards witness dag solutions gps gpp computed form annotated finite automata briefly review solutions section connection spki sdsi weighted pushdown systems correspondence spki sdsi pushdown systems presented finite set certificates keys identifiers set auth specs drawn union intersection auth specs discussed forms semiring domain associate weighted pushdown system square squaresolid keys control locations identifiers form stack alphabet rule set defined set labeled rewrite rules derived specs auth specs shown section maps rule auth spec usefulness correspondence stems simple observation configuration reach configuration chain certificates label certificate chain precisely solving gpp gps problem amounts finding set certificate chains prove principal allowed access resource principal solution problem identifies set certificate chains union labels maximal conclude generalized authorization problem pose question set certificates resource owner authorization specification client certificate chains proving grants authorization equivalent problems wpds setting gpp problem square squaresolid square compute backwards witness dag gps problem square square squaresolid compute forwards witness dags authorization granted algorithms gpr briefly review solutions gpr problems concentrating gpp case gps case analogous details input weighted pushdown system regular set configurations output witness dag pre general infinitely configurations pre post finite hope compute solution symbolically annotated finite automata purpose definition p-automaton quintuplea finite set states set transitions final states initial states control locations sequence transitions reads configuration arbitrary states sequence accepting iff final state configuration denote acca set accepting paths accepted acca non-empty note set configurations regular accepted p-automaton fixed omit prefix speak simply automata convenient property regular sets configurations closed forwards backwards reachability words automaton accepts set construct automata accept sets configurations forward backwards reachable additional labellings transitions computed solve gpp gps problems assigns weight automaton transition compute compute function presentation omit labeling sake simplicity detailed presentation method straightforward transfer distributed case loss generality assume henceforth rule restrictive pushdown system simulated obeys restriction larger constant factor present abstract version procedure designed centralized computation section describes implementation distributed case abstract algorithm p-automaton accepting set configurations loss generality assume transition leading initial state initially set transition updated action add set update gpp add transitions saturation rule rule sequence reads ends state update algorithm stops applications saturation rule pseudocode algorithm reproduced figure iteration loop starting line executes applications saturation rule assume pushdown system rules meaning explained greater detail subsection case square kuw facultysquaresolid kuw faculty kls faculty kls faculty kcs faculty kls faculty kbio faculty kcs faculty kbob auth cert grants permission certs change permissions suppose bob permission resource owner determine bob authorized solving gpp problem kbob square kbob squaresolid algorithm input weighted pushdown system automaton accepting transitions states output automaton pre annotation function procedure update begin newvalue newvalue negationslash workset workset newvalue end workset update workset negationslash remove transition workset update update update return fig algorithm creating weighted automaton gpp problem kbob kbob kcs kls kuw kls kuwkcs faculty faculty faculty fig initial automaton final pre automaton created algorithm figure weights transitions shown parentheses kbob kuw kcs faculty faculty kls faculty fig partial automaton computed query pre square weights transitions shown parentheses upper part figure shows automaton accepts automaton pre produced algorithm shown lower part square accepted weight bob authorization granted extra annotations witness dags shown deduce relevant certificate chain distributed certificate-chain discovery algorithms gpr problems discussed section work assumption pushdown rules certificates resp stored single site real-world setting certificates issued principals forcing stored shipped single site permitted propose versions algorithms solve gpr problems distributed environment remark connection spki sdsi wpds explained section safe pushdown spki sdsi 
terminology interchangeably section proceed section introduces definitions notation section high-level descriptions protocols communication client resource servers co-operate solve distributed problem propose protocols based gpp formulation gps formulation protocols consist phases core search phase algorithms phase detail section relative merits protocols security privacy-related issues discussed section preliminaries rest section fix weighted pushdown system authorization problem client requests permission resource owner assume certificates distributed set sites servers exists mapping sites maps principal site responsible principals certificate crosses site boundary negationslash cross-boundary certificate exists call sites responsible neighbouring sites denote configurations begin keys site responsible basic idea distributed algorithms site computes automaton representation set pre post annotates automaton information recovering part witness dags notion made precise definition definition -dag sites s-slice subgraph induced vertices informally s-slice part consists configurations responsible successor vertices reached cross-boundary certificates edge labeled cross-boundary certificate henceforth called boundary edge called boundary node target boundary edge responsible subject rule edge labeled protocols distributed solutions authorization problem make assumptions storage certificates gpp protocol assume certificate rule stored site responsible subject gps protocol assume certificate rule stored site responsible issuer assumptions make algorithms efficient site sites contact information principal assumptions realistic basically certificate mentions principal subject issuer site general realistic assume certificate sites issuer subject stated conditions required algorithms distributed setting multiple access requests happen time unique request ids distinguish protocols consist phases initialization search verification gpp protocol distributed certificate-chain discovery setting search started site responsible client search works site responsible resource owner client requesting permission initialization initialization consists steps client sends request resource owner resource owner generates unique request identifier reqid distinguish request requests progress future request reqid resolved resource owner sends pair reqid site called resource site denote notify incoming search acknowledged receipt message reqid client client sends message site called client site denoted message key request reqid iii so-called client certificate request signed client client site checks contents signature client certificate match expectations check successful begins search search client site initiates gpp query set squaresolid square reqid distinguish query servers work multiple requests simultaneously query resolved sites details search algorithm section point sufficient understand starts local gpp computation transitively request sites participate computation site constructs set pre maintains information constructing s-slice required witness dags communications sites tagged reqid client certificate verification earlier communication resource owner resource site square target search resource site determine reachable set post computed complete algorithm result reported resource owner propose alternative methods alternative resource site starts constructing sr-slice witness dag reaches boundary node slice requests sub-dag node neighbouring site node neighboring site computes information possibly involves recursive queries sites downstream returns constructed full witness dag sends resource owner client certificate resource owner verifies result checks integrity dag signatures certificates dags client certificate matches reqid signature matches client depending outcome access allowed denied client alternative constructing witness graph reports certificates issued owner resource combined values paths start client certificate case communication sites alternative resource owner complete witness set certificate chains give owner higher degree confidence control authorization process hand verification complete dag place great workload resource owner reduced alternative alternative drastically reduce amount network traffic exchanged sites gps protocol distributed certificate-chain discovery setting search initialized resource site search works client initialization client sends request resource owner resource owner responds sending unique request identifier reqid client sends message client site register search message sends reqid client certificate gpp protocol client site checks correctness client certificate check successful client site tells client certificate-chain discovery begin client asks resource owner initiate search resource owner sends message resource site public key request reqid request initiate certificate discovery search search stage analogous gpp protocol initiated resource site singleton set square details search algorithm section site involved search post intersects maintains information constructing s-slice required witness dags verification steps initialization phase client site square squaresolid targets search determine reachable set post computed complete algorithm result reported resource owner phase direction flow information contrary search phase gpp protocol alternatives stage analogues provided gpp discussion relative merits remarks gpp protocol alternative client site starts constructing sc-slice witness dags sends sub-dags starting boundary nodes upstream neighboring sites neighboring sites supplement information sub-dags send upstream full witness dags result reported resource owner communications phase accompanied client certificate mentioned earlier resource owner verify result grant deny access client alternative sites report sum paths inside slices witness dags result resource owner consists certificates issued combined values paths distributed search algorithms section give details search phase protocols abstract level description site computes set pre post site involved search discovered intersection non-empty gpp protocol client site starts set square squaresolid gps protocol resource site starts set square cross-boundary cert site discover terms belonging site send terms continues computation terms terms communicated sites tagged request sites distinguish working multiple queries concrete level description resource client site starts building automaton accepting carries algorithm figure post counterpart certificates derives automaton transition begins state key site responsible part automaton reachable shipped site site computes partial automaton fragment full automaton section assume rules distributed sites called bio shown figure section suppose gpp protocol decide bob site granted permission site starts search kbob square kbob squaresolid discovers pre intersects site involved notices site part search partial automata computed shown figure notice site bio involved end computation site sees square accepted partial automaton weight result reported resource owner bidirectional search approaches discussed unidirectional search forward resource client backwards client resource taking leaf envisage hybrid algorithm works directions case resource site initiate gps query client site initiate gpp query request sites maintain automata direction intersection automata performed efficiently site middle notice searches intersect investigated approach prototype present interesting direction future work discussion discuss privacy security-related topics compare protocols discuss improvements privacy search phase parties involved learn resource owner client client asked access resource resource owner client give information communicate sites sites determine outcome search request generated independently key resource site request resource made resource site receives request resource owner resource site maintains partial automaton slice witness graph determine principals site client site client made request holds reasons analogous previous argument sites request made surmise nature request judging identifiers 
transitions direction query direction confirmation observe communication neighbor sites privacy access request ensured search phase witness dag constructed construction phase sites learn identity client avoided alternative method values paths dag transmitted sites alternative solution prevents unnecessary spread certificates sites sensitive information security attacks spoofing eavesdropping protect protocol-related communication attacks spoofed messages eavesdropping messages exchanged protocols encrypted digitally signed well-established public-key cryptography systems trusting sites main part computation carried sites protocols potentially susceptible malicious behavior sites malicious site invent ignore certificates ignoring certificates detriment users site responsible concern inventing certificates problem verification stage constructs full witness dag case certificates signed issuers supplied alternative solution values reported problematic essence reporting paths sub-dag rooted node amounts issuing confirmation principal certificate chain client alternative solution requires trust site certificates truthfully note cross-boundary certificates subjects direct control respective site operator problem client certificate resource verify reported result valid client initiated request verification stage constructs full witness dags straightforward maximal minimal resp nodes dags refer client alternative solution verification client certificate serves purpose provided resource client site verify correctness comparison protocols gpp-based protocol search starts client site gps-based protocol starts resource site site responsible popular resource gps-based protocol put workload denial-of-service attacks conceivable malicious client large number gps computations identities doomed fail gpp-based protocol happen workload fall client site assumed relationship client client company isp social safeguard denial-of-service attacks gpp-based solution require separate verification stage construction complete witness dags omitted reasons gpp-based solution advantages gpsbased solution carry precise analysis topic improvements caching results notice methods describe carried time client access resource contact client resource outcome successful resource remember grant access full search time caching sites site client site resource site request result local search independent request identifier sites cache recent results reuse identical request modulo reqid spki sdsi certificates annotated validity information specifies long certificate valid section certificate chain valid long certificates valid situations caching validity information account requires straightforward additions algorithms omitted guided search protocols sets pre post intersect domains sites request involve sites relevant search increases length computation amount network traffic protocol improved limiting scope search client idea allowed access resource possibility client client site suggest set sites suitable certificates termination distributed gpp gps computation standard termination-detection algorithm applied determine search terminated entails additional time communication overhead search terminated relevant certificate chains found resource site gpp case client site gps case discovered paths tentative larger respect ordering goal search establish ltl model checking systems unbounded number dynamically created threads objects eran yahav thomas reps mooly sagiv school comp sci tel-aviv univ tel-aviv fyahave sagivg math tau cnr-iei pisa italy comp sci dept univ wisconsin madison usa reps wisc abstract stumbling blocks applying model checking concurrent language java program data structures number threads grow shrink dynamically flxed upper bound size number paper presents method verifying ltl properties programs written language powerful abstraction mechanism based -valued logic handles dynamic allocation objects including thread objects objects verify programs dynamically allocate thread objects programs create unbounded number threads introduction goal apply temporal-logic model checking languages java dynamic creation destruction unbounded number threads dynamic allocation freeing unbounded number storage cells heap iii destructive updating structure flelds combination features creates considerable culties method check program properties dynamic storage allocation dynamic thread creation priori upper bound size program data structures number threads arise system execution time obtaining information linked data structures destructively updated generally cult situation challenge obtain model abstracts details system checked retains information relevant properties checked paper shows obtain model concurrent java program perform ltl model checking model primary technical tools paper program conflgurations represented flrst-order logical structures semantics program expressed terms transitions operate flrst-order logical structures program behavior modeled potentially inflnite transition system flrstorder formulae semantics pointer manipulations dynamic allocation deallocation threads objects natural powerful abstraction mechanism based -valued logic methods performing model checking -valued kripke structures iii description property checked ltl formula description abstraction applied automatically construct flnite conservative -valued transition system approximates program behavior construction abstraction augmented tunes analysis algorithm property checked high-level terms abstraction principles obtain model concurrent java program unbounded numbers dynamically created threads objects characterized observation model-extraction principles abstraction system conflgurations atomic propositions standard model checking path properties checked formulated propositional temporal logic vocabulary atomic propositions temporal-logic formulae formulated deflned turn formulae flrst-order logic values atomic propositions obtained evaluating flrst-order formulae individual system conflgurations flrst-order formulae provide formal deflnitions distinctions system conflgurations talk temporal-logic formulae vocabulary state desired path properties transition system abstraction conflgurations finite albeit -valued abstractions system conflguration obtained partitioning set individuals storage cells threads values individuals unary predicates conflguration represented conservatively condensed -valued conflguration abstract individual represents equivalence class concrete individuals abstraction ofsystemtransitions flnite albeit -valued abstraction system transition system obtained partitioning set system conflgurations values nullary predicates transition system represented conservatively condensed valued transition system abstract conflguration represents equivalence class concrete conflgurations obs related notion predicate abstraction introduced graf saidi subsequently ways models obtained obs closely resemble standard temporal-logic model checking case flnite-state systems predicate abstraction inflnite-state systems models obtain truth-value atomic propositions transitions indeflnite truth unknown make observation ties obs make model extraction property-guided observation property-guidedness arrange abstraction steps obs uenced characteristics algorithm applied check property interest extracted models maintain distinctions needed precision obtaining deflnite answer true false unknown performing model checking -valued structures case properties stated ltl characteristics algorithm exploit states uchi automaton built check property interest contributions work summarized present method model-checking ltl properties concurrent java programs method abstraction technique based -valued logic previous work addressed safety properties abstraction mechanisms guided vocabulary properties provided user iii method applies abstraction product-automaton constructed program property checked enables abstraction uenced property checked implemented prototype framework supports veriflcation ltl properties directly buchi automata system applications subject subsequent paper system property wwnnnnn nnnnn nnnn sfo absvoc sfo spp absvoc spfo spp vvm ddfs ddfs fig model checking abstraction related work model-checking techniques number threads flxed global state system flxed-size tuple program counters individual threads assignments shared variables contrast approach number heap-allocated objects threads unbounded vary dynamically related works address model-checking java programs abstraction impose priori bound number allocated objects threads popular ltl model-checker spin imposes priori bound number allocated objects threads support dynamic allocation objects variant spin named dspin support dynamic allocation objects handle bounded data structures bounded number threads approaches proposed veriflcation inflnite-state systems systems unbounded number threads approaches address dynamic allocation objects previous work based predicate abstraction address languages support dynamic allocation deallocation objects threads exception work das predicate abstraction verify properties concurrent garbage-collection algorithm state space reduced exploiting symmetries process indices representation imposes priori bound number threads handle dynamic allocation objects threads contrast approach threads named so-called canonical names collection thread properties hold thread obs section naming scheme automatically discovers commonalities state space relying explicitly supplied symmetry properties deflne process-naming scheme incorporates permutation-equivalences destroyed presence dynamic process creation construction product program program property previously introduced addresses safety properties sequential programs work paper outgrowth previous work shape analysis speciflcally approach sagiv reps wilhelm based -valued logical structures work abstraction techniques handle unbounded number thread objects manner similar handles unbounded number heap-allocated objects approach pioneered present paper addresses full ltl addressed safety properties express static thread naming framework unary predicates denote thread names corbett applied results shape analysis concurrent programs reduce size flnite-state models concurrent java programs corbett work number threads bounded model-checking multi-valued logics addressed order reason partial inconsistent systems put priori bound number objects threads support dynamic allocation deallocation theoretical aspects many-valued modal logics investigated past fitting presents family manyvalued modal logics formulae values many-valued logic accessibility relation worlds values manyvalued logic paper flrst-order -valued models propositional models discussed model checking abstraction figure overview families kripke structures arise work inter-relationships boxes labeled stand kripke structures system boxes labeled stand product-automaton system property box diagram labeled kind logical structures label nodes kripke structure number truth values difierent types generalized kripke structures spp standard kripke structures state labeled set -valued propositions spp state labeled set -valued propositions sfo spfo kfo state labeled -valued flrst-order structures sfo spfo kfo state labeled -valued flrst-order structures relationship previously investigated reasoning partial state spaces partial state space represented -valued propositional kripke structure spin model-checker path spp ddfs corresponds model checking abstraction spin -valued propositional logic edge labeled stands step combined automaton represents negation property interest spin double-dfs algorithm state-space exploration previous work flrst author corresponds path sfo sfo resulting model explored conflgurations violating specifled safety property paper concentrate aspects figure extraction -valued model -valued propositional kripke structure extracted program dynamic 
object thread allocations corresponds path sfo figure extracted kripke structure inflnite abstraction applied section extraction -valued model incorporates property-guided abstraction corresponds path sfo spfo spfo spp figure section section remainder paper organized section overview automata-based model checking background java section presents technique modelling program behavior -valued logical structures section presents method model extraction lays groundwork property-guided abstraction section describes -valued logical structures perform model checking abstraction section describes details prototype implementation preliminaries veriflcation linear temporal logic veriflcation ltl property consists verifying inflnite execution sequences program satisfy property-formula common automata-based veriflcation techniques verify ltl properties automata-based veriflcation represents verifled system desired ltl property uchi automata uchi automaton flve-tuple flnite alphabet automaton flnite set states relation labelled transitions set initial states set accepting states execution word inflnite sequence execution accepting ifi accepting state appears inflnitely language set behaviors modeled system traditionally veriflcation ltl property consists stages building uchi automaton negation property checked paper assume construction uchi automaton performed existing algorithm building representation system uchi automaton automaton alphabet set states set labeled transitions set initial states note states system automaton accepting states constructing product automata product automaton denoted hsi pji hsx pyi ifi checking accepting cycle reachable initial states product automaton accepting cycle found counterexample speciflcation property proven correct double-dfs algorithm ciently flnds accepting cycles constructed product automaton java concurrency work addresses problem verifying properties concurrent java programs section partial overview concurrency model java details presentation details found java supports concurrency specially designed class java lang thread objects class thread concurrently executing activities note allocation perspective thread object behaves object constructor class thread takes parameter object implements runnable interface requires object implement run method thread created executing thread allocation statement thread started invoking start method starts executing run method object implementing runnable interface initially program starts starting single thread executes main method user-specifled class java assumes threads scheduled arbitrarily java object unique implicit lock addition object block-set wait-set managing threads blocked object lock waiting object lock synchronized expr statement executed thread object expression expr evaluated resulting object lock checked availability lock acquired thread successfully acquires lock lock acquired thread thread blocked inserted lock block-set thread acquire lock acquire lock thread leaves synchronized block unlocks lock program shown figure consists request queue holding incoming requests main loop creating requesthandler thread request requesthandler thread repeatedly enter critical section perform operations exclusive shared resource logflle leave critical section modeling program behavior logical structures section shows construct model analyzed program logical structures section summarizes work yahav formal aspects detail public class requesthandler implements runnable public void run true synchronized critical stuff public class main public static void main true curr tail curr curr curr thread requesthandler start fig request handler program representing program conflgurations logical structures program conflguration encodes program global state consists global store program-location thread iii status locks threads thread waiting lock first-order logic paper express conflgurations properties analyzed program assume set predicate symbols flxed arity program conflguration -valued logical structure universe individuals individual represents heapallocated object represent threads program interpretation function mapping predicates truth-value structure predicate arity table predicates analyze program note predicates table written generic applied analyze difierent java programs modifying set labels flelds paper conflgurations presented directed graphs individual universe displayed node unary predicate holds node drawn inside node node written inside angle brackets ease presentation true binary predicate drawn directed edge labelled predicate symbol program figure handler threads compete shared lock figure shows conflguration arising program conflguration consists flve requests arranged queue requests handled created threads conflguration lock acquired thread properties conflguration extracted evaluating logical formulae respect conflguration formula thread held describes fact lock acquired thread inthispaper weusethenatural symbol global head global tail head curr tail global curr head curr head head thread handles thread acquired rvalue handles thread rvalue handles rvalue held fig conflguration program predicates intended meaning thread thread fat lab lab labelsg thread label lab frvalue fld fld fieldsg fleld fld object points object fglobal fld fld fieldsg fleld fld global environment points object held lock held thread blocked thread blocked lock table predicates semantics java fragment system transitions informally transition characterized kinds information source label lsrc source label transition precondition action enabled precondition expressed logical formula formula make free variables including designated free variable denote scheduled thread action performed operational semantics non-deterministic sense actions enabled simultaneously chosen execution selects scheduled thread assignment implements interleaving model concurrency collection predicate-update formulae table enabled transition creates conflguration interpretation predicate arity determined evaluating formula predicates target label ltgt deflnes target label transition refer pair enabling-condition action transition enabled assignment source conflguration lsrc holds satisfles action precondition note predicates lab regular unary predicates encoded part program conflguration special actions creation removal individuals special action creates individual unew results structure funewg special action free removes individual universe lock blocklock critical unlock skip fig transition system handler thread figure shows transitions single requesthandler thread write transitions form lsrc args ltgt denote pair consisting precondition update-formulae details table program transition system pts collection transitions procedure calls handled exceptions modelled transitions due space limitations omit additional discussion language features transition-system figure corresponds statements executed single requesthandler thread actions transition system deflned table note single statement condition represented single transition action precondition predicate-update formulae lock rvalue held held held blocked blocked unlock rvalue held held blocklock rvalue blocked blocked held table operational semantics lock actions divide predicates disjoint sets core predicates instrumentation predicates core predicates serve building blocks formulae model semantics actions predicates table actions table instrumentation predicates record derived properties individuals instrumentation predicates deflned logical formulae core predicates table lists instrumentation predicates program predicate intended meaning deflning formula fld referenced fleld object rvalue fld acquired acquired thread held glb fld object reachable object referenced byglobal glb path edges global glb rvalue fld table instrumentation predicates semantics java fragment thought speciflcation variant version kripke structure program kripke structure node labelled -valued logical structure subset atomic-propositions work model checking formally kfo structure four-tuple kfo potentially inflnite set states transition relation set initial states -struct -struct set general two-valued logical structures set predicates model extraction section describes non-standard approach 
construction product automaton approach plays key role section presents abstraction product automaton precise flrst built abstracted version system-automaton computed product-automaton property-guided sense abstraction speciflc property verifled extracting atomic propositions standard model-checking atomic propositions problem presented flat larger threshold information terminate search early instance alice interested set certificate chains valid hour search algorithm stopped certificate chains found valid half hours amount time longer hour computation limited timeout implementation implemented prototype distributed algorithm prototype evaluate scalability algorithm varying parameters configuration topology number certificates response time perspective clients performance metrics resources perform real-world test experiments configured synthetic data make configurations mimicked real world closely main conclusions drawn experiments network overhead dominant results show topology configuration affects system performance significant factor network overhead experiments show significant percentage total time spent network operations current implementation prototype reduce overhead optimization techniques local filtering effect expected certificates longer takes perform certificate-chain discovery time takes perform certificate-chain discovery increases smaller rate increase number certificates due call local filtering effect local rules represent lowest level information made actual actions processed site sections summary experimental results show distributed certificate-chain algorithm implemented top wpds efficient scalable rest section explain experimental design discussed results obtained square facultysquaresolid kuw faculty kls facultyd kls faculty kcs faculty faculty kbio faculty kcs faculty kbob bio fig case grants read permission directory faculty dir read bob requests read access directory square facultysquaresolid square bio facultysquaresolid kcs faculty kbcs faculty bio kbio faculty kbcs facultyd kbio faculty kalice bcs kbcs faculty kbob fig case authorization multiple paths grants read privilege directory faculty dir read write privilege bio faculty dir write bob requests read write access directory nsf square knsf programssquaresolid knsf kedu square knsf govsquare knsf gov kgov kedu programs kmanagera kedu programs kedu schools faculty kedu schools kwisc schools gov kgov programs kgov pubschools faculty kgov pubschools kwisc schools kgov square kgovprogramssquaresolid kgov programs kmanagerb wisc kwisc schools kuwd faculty kchancellor kuw faculty kls faculty kls faculty kcs faculty kls faculty kbio faculty kcs faculty kbob bio fig case authorizes nsf programs apply funda funda apply nsf gov programs apply fundb fundb apply bob attempts apply funda configuration topology parameter considered configuration topology configuration spki sdsi system consists multiple connected sites represented graph experiments considered configurations varying degrees complexity shown figures graph shaded nodes represent distinct sites distributed spki sdsi system labels represent cross-boundary spki sdsi certificates nodes symbol denote resource spki sdsi auth certs issued dashed lines denote certificate chain discovered algorithms bob requests access resource case root node denotes wisconsin denotes college letters science colleges bio represent departments computer science biology edge issued certificates respect site auth cert square kuw facultysquaresolid grants access kuw faculty cert kuw faculty kls faculty states kls faculty kuw faculty case represents simplest topology configurations case adds additional complexity top case forming dag result certificate chain consist multiple paths demonstrated dashed lines figure case builds top forms complex configuration number certificates configuration small medium large case case case table test configurations cell numbers number auth certs run number certs number certificates parameter considered number certificates real-world environment principal key issue certificates expect spki sdsi system thousands certificates distributed sites system configurations varied number certificates experiments ranged number reachable certificates unreachable contribute certificate-chain discovery table shows breakdown certificates experiments analysis section report results experiments response time perspective clients performance metric tests conducted simulated environment site runs separate machine local area network test machines identical configurations mhz pentium iii ram running tao linux version table shows performance results configurations configuration run times increasing numbers certificates comparison purposes collected performance data running certificatechain discovery centralized mode certificates stored fixed site largest number certificates topology effect data table shows response time certificate chain length manager funda apply manager fundb apply changellor funda apply bob funda apply bob fundb apply distributed centralized fig response time chain length case complex configuration effect configuration topology varies case case instance comparing cases observe performance 
difference small path-combining operation case adds overhead case substantial variance time process queries obvious observation certificate-chain length affects performance shown top line figure comparison flat line figure shows response time centralized certificates location time reflects cost running gps algorithm site network overhead communicating client site request reply reveals significant factor network overhead collected additional data confirmed hypothesis distributed certificatechain discovery time spent network-related operations establishing tcp connections sending receiving messages prototype investigating optimization techniques improve average performance number certificates table shows insignificant change performance number certificates increases small medium small increase average medium large attribute reasons local filtering effect caused relevant rules composed site corresponds lines algorithm shown figure wpds methodology efficient blaze feigenbaum ioannidis keromytis keynote trust-management system version rfc blaze feigenbaum ioannidis keromytis role trust management distributed systems security vitek jensen eds secure internet programming security issues mobile distributed objects lncs table performance results time distributed centralized configuration client request small medium large large case bob dir read bob dir read case bob dir read write managera funda apply managerb fundb apply case chancellor funda apply bob funda apply bob fundb apply weeks understanding trust management systems proceedings ieee symposium research security privacy research security privacy oakland ieee computer society technical committee security privacy ieee computer society press ellison frantz lampson rivest thomas onen rfc spki certificate theory internet society schwoon jha reps stubblebine generalized authorization problems proceedings ieee computer security foundations workshop csfw ieee computer society reps schwoon jha weighted pushdown systems application interprocedural dataflow analysis proceedings internation static analysis symposium sas san diego system clarke elien paper atomic ellison propositions fredette obtained morcos evaluation logical rivest formulae certficate flrst-order chain logic discovery formulae spki sdsi expressed journal terms computer core predicates security evaluated jha respect reps system analysis conflgurations spki call sdsi extracted certificates nullary model predicates checking vocabulary proceedings model-checking problem ieee computer set security foundations predicates workshop forms csfw language ieee computer express society properties verifled winsborough flnite mitchell set vocabulary distributed predicates credential chain denoted discovery ivoc trust approach management journal embodiment computer obs explains security atomic propositions winsborough mitchell complicated situation proof-of-compliance dealing safety availability objects analysis threads trust management dynamically allocated proceedings ieee deallocated symposium assume security deflning formulae privacy oakland vocabulary berkeley predicates provided user mitchell formulae provide understanding formal spki deflnitions sdsi distinctions first-order logic user proceedings wishes ieee make computer execution security states foundations workshop ltl csfw formulae ieee computer vocabulary society user howell state kotz desired path formal properties semantics -valued spki logical technical structure report set department nullary computer predicates science dartmouth college fpjp hanover set abadi nullary sdsi predicates linked local hold spaces journal kfo computer structure kfo security halpern van extraction der kripke meyden structure logical kfo reconstruction spki proceedings ieee computer security foundations ivoc workshop representing ieee product computer society automaton section press appel single kfo felten structure proof-carrying represent authentication product conf kfo comp structure commun program sec pfenning uchi automaton sch urmann negation system property description twelf interest meta-logical creates framework kind deductive inflnite systems uchi automaton ganzinger acceptance int conf deflned auto respect deduc springer-verlag flnite-cardinality partition lnai state jim space induced trust flnite management number system accepting states certified evaluation property automaton proceedings path ieee symposium constructed kfo security structure privacy accepting ieee computer inflnitely path society encounters jim state suciu dynamically property-automaton-state distributed component query accepting evaluation pods constructing proceedings system-automaton twentieth property-automaton acm separately sigmodsigact-sigart symposium combining principles product database systems construction acm present press jha reps model checking spki sdsi journal computer security reps schwoon jha melski weighted pushdown systems application interprocedural dataflow analysis science computer programming bouajjani esparza touili generic approach static analysis concurrent programs procedures proceedings popl esparza hansel rossmanith schwoon efficient algorithms model checking pushdown systems emerson sistla eds proceedings cav volume lecture notes computer science springer bouajjani esparza maler technique reachability analysis product-automaton pushdown automata constructed directly application model-checking instrumented version proceedings system concur actions volume lecture ltl notes property computer concurrent science program represented springer 
transition system flrst construct property-automaton negation desired property standard construction algorithm create instrumented version system-actions track state desired property program conflguration construction produces product system property conflguration constructed kfo structure incorporates information state system state property automaton approach incorporate state property automaton conflguration set nullary predicates adding nullary predicates property-automaton states predicate automaton state cient approach encode states propertyautomaton log jstatesjpredicates simplify presentation present flrst approach property automaton consists subsets instrumentation predicates set ivoc ivoc deflne set nullary predicates fnjn states automaton addition designated nullary predicate accepting deflned denote accepting states denote set nullary predicates fnjn facceptingg set actions representing automaton transitions transition represented action precondition predicateupdate formula update possibly accepting program figure purpose illustrating machinery suppose check system property thread acquires lock referenced atomic proposition formulated thread rvalue held ltl formula innot true fig automaton simple liveness property flrst compute negation property generate instrumentation predicates encapsulate flrstorder formulae negation property eventually thread acquire lock automaton negated property constructed resulting property automaton figure automaton states sout sin initial state sout accepting state sin generated set property-nullary predicates fnjn facceptingg fsout sin acceptingg set actions table action precondition predicate-update formulae sout sin sout sout sin accepting sout sout sout sin sin sin table actions property automaton figure conflguration product-automaton deflned product system-conflguration property-conflguration product conflguration -valued logical structure predicates individual universe represents heapallocated object predicate arity predicate precondition property-action formulated terms current predicate values system-action property-action composed single product-action table shows product propertyactions system lock action prime notation denotes predicate action applied simply shorthand predicate-update formula denotes instrumentation predicate system-action applied product action product precondition product predicate-update formulae lock rvalue sout sin accepting sout sin held rvalue lock sout held held blocked blocked lock rvalue rvalue lock sout sout held held held sout blocked blocked lock sin rvalue lock sin sin held held blocked blocked table product actions property automaton figure action lock note precondition veriflcation automatic abstraction section describe create conservative representation concrete model presented section flniteness high precision representing abstract program conflgurations -valued logical structures section presents abstraction mechanism obs make feasible perform model checking conservatively represent multiple conflgurations single logical structure flnite extra 
truth-value denotes values values called deflnite values called indeflnite commutative join operator denoted deflned xtx formally abstract conflguration -valued logical structure individual universe represents possibly allocated heap objects predicate arity individual represents single object called summary node conflguration represents concrete conflguration figure summary node labeled represents threads program label summary node labeled represents requests handled handler thread note abstract conflguration essentially represents concrete conflgurations threads residing program label requests possibly handled conflguration represents inflnitely concrete conflgurations note represents conflgurations requests preceding curr handled global head head global tail head curr tail global curr head curr head thread handles thread acquired rvalue handles rvalue held fig abstract conflguration represents concrete conflguration conflguration embedding formally deflne concrete conflgurations represented abstract conflgurations idea individual concrete conflguration mapped individual abstract conflguration generally map individuals abstract conflguration individual precise abstract conflguration note concrete conflgurations subset abstract conflgurations formally abstract conflgurations function surjective embed predicate arity holds represents exists embedding function denote fact embedded creating embedding function canonical abstraction canonical abstraction maps concrete individuals abstract individual based values subset unary predicates called abstraction predicates individuals values predicate symbols mapped abstract individual leads bounded-size logical structure jaj individuals resulting structure flrst-order structure denote abstraction set abstraction predicates absa note canonical abstraction captures commonalities difierent individuals populate concrete conflgurations set properties characterize threads names thread equivalence classes transition program involves dynamic allocation deallocation abstract conflguration automatically adjusts account presence absence deleted entity means canonical abstraction clusters processes flnite number equivalence classes property patterns arise reachable conflgurations implementing algorithm applying actions abstract conflgurations non-trivial relations possibly inflnite set represented concrete conflgurations roughly speaking corresponds evaluation precondition predicate-update formulae -valued logic describes focus coerce operations perform rewrites directly abstract conflgurations conservative precise structures kfo structure four-tuple kfo set states transition relation set initial states -struct -struct set -valued logical structures set predicates state kfo structure labeled -valued logical structure state represent possibly inflnite number states kfo structure embedding structures section presents abstraction mechanism obs creates kfo structure kfo kfo structure kfo structure kfo flnite structure structures labeling kfo abstracted canonical abstraction suppose kfo kfo convenient mappings boolean values valued transition relation considered characteristic mapping similarly considered characteristic function identifles set initial states structure kfo set abstraction predicates structures node labels induced kfo structure fabsa ffabsa absa ffabsa note -valued transition relation mapping values similarly -valued set initial structures maps elements note transition edges condensed kfo structure typically maytransition edges contrasts previous work made surjective embeddings abstracting system models -valued kripke structures mapped -valued kripke structures simulation preorder structures section show kfo structure simulate precise kfo structure deflne simulation preorder kfo structures show results obtained evaluating ltl 
formulae abstracted kfo structure conservative semantics -valued propositional modal logics combining -valued modal logic flrst-order language yields -valued flrst-order modal logic paper reader referred details flrst-order modal logic mfo hsm imiand qfo hsq iqi kfo structures relation simulation relation ifi holds conflguration labeling embedded conflguration labeling state exists mfo simulated qfo denoted mfo qfo exists simulation relation initial state initial state lemma preorder set kfo structures theorem kfo structures mfo qfo ltl formula mfo qfo show flnite abstraction product-automaton simulates possibly inflnite concrete product-automaton corresponds spfo figure simulating spfo flgure theorem sfo kfo -valued kripke structure modelling system behavior buchi automaton property verifled product automaton constructed framework spfo simulates possibly inflnite concrete product automaton spfo spfo spfo instrumentation abstraction property-guidedness principle instrumentation predicate deflned logical formula core predicates evaluating deflning formula conflguration arises instrumentation predicates explicitly updated predicate-update formulae actions reason things -valued logic generated conflguration instrumentation predicate predicate-update formula evaluated previous conflguration precise obtained evaluating instrumentation predicate deflning formula current conflguration instrumentation principle critical aspect instrumentation predicates fact afiect precision abstraction applied conflgurations framework abstraction guided things unary abstraction predicates individuals identical values unary abstraction predicates mapped single abstract individual adding unary abstraction predicates maintaining flner distinctions individuals nullary predicates nullary instrumentation predicate -valued conflguration unafiected canonical abstraction eqn introduce nullary predicates reflne set kfo structures induced canonical abstraction nullary instrumentation predicates ways record vocabulary temporal-logic property interest record state property automaton section kinds nullary predicates introduce distinctions conflgurations identical nullary automaton-state predicates important improving precision analysis instrumentation predicates capture difierent states relevant veriflcation property abstraction induce targeted structure automaton formula states property interest aspect approach permits claim model extraction propertyguided sense obs noted nullary automaton-state predicates generated automatically automaton property interest property guidedness obtained fully automatically vocabulary instrumentation predicates important improving precision analysis shown global head global tail head curr tail global curr head curr head head thread handles thread acquired rvalue handles rvalue held fig concrete conflguration partial request coverage concrete conflguration shows conflguration part requests preceding curr request queue handled concrete conflguration corresponds similar conflguration requests preceding curr handled conflgurations represented suppose reason requests preceding curr request queue handled formulate requirement head curr thread handles deflne vocabulary includes instrumentation predicate head curr thread handles frc property interest instrumentation predicates vocabulary conflgurations represented abstract conflguration deflnite information requests preceding curr handled evaluates adding instrumentation predicate reflnes abstraction capable distinguishing instrumentation predicate map difierent abstract conflgurations abstract conflgurations abstract state-space record versus requests precede curr request queue handled prototype implementation implemented prototype framework called vmc framework path sfo spfo spfo spp shown figure result path flnite abstract -valued propositional model simulating possibly inflnite concrete model model spp obtained path precise model spp obtained path sfo sfo spp abstraction afiected property verifled technically prototype implementation perform extraction model kfo model prototype implementation ddfs performs exploration kfo model building kfo model algorithm conservative miss counter-example flnd artiflcial counter-example caused abstraction algorithm produce false alarms detect cycle return counter-example language empty consequence theorem general model checking programs procedure calls concurrency unbounded data structures undecidable side-stepped problem giving algorithm flnite amount time guaranteed provide safe answer number abstract conflgurations arise program abstraction jaj jpj jaj number abstraction predicates modelling global state program jpj number predicates encode property automaton experience safety properties actual number conflgurations arising program signiflcantly smaller upper bound experience liveness properties large programs abdulla nyl cient veriflcation inflnite-state systems bruns godefroid model checking partial state spaces -valued temporal logics lecture notes computer science bruns godefroid generalized model checking reasoning partial state spaces concur int conf concurrency theory lncs burkart stefien model checking context-free processes concur volume lncs pages chase wegman zadeck analysis pointers structures conf prog lang design impl pages acm press chechik easterbrook petrovykh model-checking multi-valued logics proceedings fme march clarke grumberg jha verifying parameterized networks trans prog lang syst september clarke grumberg jha veith counterexample-guided abstraction reflnement cav july clarke grumberg andd long trans prog lang syst september clarke grumberg peled model checking mit press colcombet fradet enforcing trace properties program transformation proc popl pages january corbett shape analysis reduce flnite-state models concurrent java programs october corbett dwyer hatclifi pasareanu shawn hongjun bandera extracting flnite-state models java source code proc icse june courcoubetis vardi wolper yannakakis memory cient algorithms veriflcation temporal properties proc computer-aided veriflcation cav volume lncs pages berlin germany june springer cousot cousot temporal abstract interpretation proc popl pages january dams gerth ando grumberg acm transactions programming languages systems march daniele giunchiglia vardi improved automata generation linear temporal logic lecture notes computer science das dill park experience predicate abstraction int conf computer-aided veriflcation springer-verlag july trento italy demartini iosif sisto dspin dynamic extension spin september emersonanda sistla symmetryandmodelchecking inproc workshop computer-aided veriflcaton june july fitting many-valued modal logics fundamenta informaticae fitting many-valued modal logics fundamenta informaticae xvii fitting andr mendelsohn first-order modal logic volume synthese library kluwer academic publishers dordrecht gerth peled vardi wolper simple on-they automatic veriflcation linear temporal logic protocol speciflcation testing veriflcation pages warsaw poland chapman hall holzmann peled yannakakis nested depth flrst search spin veriflcation system pages proc spin workshop graf saidi construction abstract state graphs pvs lncs havelund pressburger model checking java programs java pathflnder int soft tools technology transfer april holzmann proving properties concurrent systems spin proc int conf concurrency theory concur volume lncs pages berlin ger august springer huth jagadeesan schmidt modal transition systems foundation three-valued program analysis proc esop jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications chapter pages prentice-hall englewood clifis knoop demand-driven model checking context-free processes proc annual asian comp sci conf volume lncs pages lea concurrent programming java addison-wesley reading massachusetts naumovich avrunin clarke data analysis checking properties concurrent java programs proc icse pages rinetskey interprocedural shape analysis recursive programs http technion maon sagiv reps wilhelm parametric shape analysis -valued logic symp princ prog lang stoller model-checking multi-threaded distributed java programs proc int spin workshop model checking software volume lncs pages springer-verlag august vardi pierre wolper reasoning inflnite computations information computation november wolperandb biogelot proc int computer aided veriflcation conference pages 
yahav verifying safety properties concurrent java programs -valued logic proc popl january http tau yahave popl yahav vmc user manual http tau yahave 
abstraction refinement -valued-logic analysis alexey loginov thomas reps mooly sagiv comp sci dept wisconsin falexey repsg wisc school comp sci tel-aviv msagiv post tau abstract paper concerns question create abstractions program analysis presents method refines abstraction automatically analysis problems semantics statements query interest expressed logical formulas refinement carried introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations tool incorporates algorithm implemented applied algorithms manipulate linked lists binary-search trees cases tool demonstrate partial correctness algorithms algorithms possess additional properties stability antistability introduction paper presents technique automatically creating abstractions program analysis previous work technique involves successive refinement abstraction unlike previous work work presented paper aimed specifically programs manipulate pointers heap-allocated data structures paper presents abstraction-refinement method static analyses based -valued logic semantics statements query interest expressed logical formulas refinement performed introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations algorithm presented analyzes sources imprecision evaluation query chooses define instrumentation relations subformulas query setting related logics play ordinary -valued logic related -valued logic memory configuration store modeled logicians call logical structure individual structure universe models single memory element case summary individual models collection memory elements run analyzer carries abstract interpretation collect set structures program point involves finding fixed point set equations fixed point reached structures collected program pointp describe superset execution states occur atp determine query satisfied atp checks holds structures collected instantiations framework capable establishing nontrivial properties programs perform complex pointerbased manipulations priori unbounded-size heap-allocated data structures tvla system three-valued-logic analyzer implements approach summary individuals play crucial role ensure abstract descriptors priori bounded size guarantees fixed-point reached constraint working limited-size descriptors implies loss information store intuitively properties concrete individuals lost due abstraction groups multiple individuals summary individuals property true concrete individuals group false individuals reason -valued logic uncertainty property captured means truth advantage -valued logic basis static analysis consistency -valued -valued viewpoints ensured basic theorem relates logics care design analysis danger abstract interpretation proceeds indefinite pervasive destroy ability recover interesting information -valued structures collected soundness maintained key role combating indefiniteness played instrumentation relations record auxiliary information logical structure provide mechanism finetune abstraction instrumentation relation defined logical formula core relation symbols captures property individual memory cell possess general adding additional instrumentation relations refines abstraction defining precise analysis prepared track finer distinctions stores properties program stores identified choice formulas definitions instrumentation relations crucial precision cost analysis tvla users faced task identifying instrumentation-relation set definite answer query make cost prohibitive arguably key remaining challenge tvla user-model contributions work summarized step automatically generating abstractions static analyses based -valued logic essentially user-level obligations tvla criticized past eliminated input required program analysis consists program present form transition system query formula characterizes acceptable outputs characterization program allowable inputs technique implemented extension tvla present experimental evidence approach iterative abstraction-refinement loop yield precise answers queries illustrate technique testing sortedness stability antistability queries collection programs perform destructive list manipulation testing partial correctness binary-search-tree algorithms methodology verifying properties programs advantages approach paper loop invariants required theorem provers involved refinement step terminate method based abstract interpretation entire process terminate method applies static analyses based -valued first-order logic applies programs manipulate pointers heap-allocated data structures eliminates user write usual proofs required abstract interpretation demonstrate abstract structures analyzer manipulates correctly model concrete heap-allocated data structures program manipulates remainder paper organized introduces terminology notation readers familiar tvla skip illustrates goals problem verifying partial correctness sorting routine describes method iterative abstraction refinement illustrates method presents experimental results discusses related work modeling abstracting heap logical structures typedef struct node struct node int data list relation intended meaning denote memory cell pointer variable point memory cell field point dle data field equal table declaration linked-list datatype core relations representing stores manipulated programs type list nulln fig store linked list section summarizes shape-analysis framework approach concrete memory configurations stores encoded logical structures vocabulary relation symbols arities terms fixed collection core relations core relations part underlying semantics language analyzed record atomic properties stores instance tab definition linked-list datatype lists relations represent stores manipulated programs type list store fig -valued logical structures represent memory configurations individuals set memory cells nullary relation represents boolean variable program unary relation represents pointer variable boolean-valued field record binary relation represents pointer field record numeric-valued variables numeric-valued fields data modeled introducing relations binary relation dle stands data less-than-orequal-to listed tab dle captures relative order nodes data values alternatively numeric-valued entities handled combining abstractions logical structures previously techniques creating numeric abstractions fig shows -valued structure represents store fig relations explained dle dle dle dle dle dle dleu fig logical structure represents store shown fig graphical tabular representations restricted class structures encode stores exclude structures represent admissible stores integrity constraints imposed instance program-analysis applications relation tab captures pointer variable points memory cell attribute unique imposes integrity constraint thatxcan hold individual structure feq png finite vocabulary relation symbols denotes set relation symbols arity set -valued structures denoted syntax first-order formulas equality reflexive transitive closure defined definition formula vocabulary feq png defined formulas variables rtc set free variables formula defined usual rtc stands reflexive transitive closure rtc free-variable set require free variables shorthand notations binary relationp rtc order precedence connectives highest lowest definition -valued interpretation -valued logical structure hus set individuals maps relation symbol arity truth-valued function addition distinct individuals assignment function maps variables individuals functionalityz -valued meaning formula denoted yields truth defined inductively shown fig min max max min rtc max nmin fig -valued meaning formula satisfy set -valued structures denoted program analysis -valued logic -valued logic formulas identical -valued logic semantic level truth introduced denote uncertainty definition truth values definite values indefinite information order defined iff symbol denotes least-upper-bound operation respect definition -valued interpretation -valued logical structure hus set individuals maps relation symbol arity truth-valued function addition distinct individuals assignment -valued meaning formula denoted yields truth meaning defined defn interpreted potentially satisfy set -valued structures denoted individual called summary individual program-analysis context summary individual abstracts fragments data structure represent concrete memory cell concrete operational semantics defined structure transformer kind edge cfg structure transformer providing collection relation-update formulas core relation formulas define core 
relations logical structures arises source ofeare transformed byeto create logical structure target typically define relation function edge optionally precondition formula filters structures follow transition alonge postcondition operator post edge defined lifting structure transformer sets structures collecting semantics program corresponds postcondition operator type suitable abstract domain instance programming language modeled supports allocation heap set individuals structure unbounded large practical point view priori upper bound cardinality elements sidestep problem abstracting sets -valued structures -valued structures equipped suitable order set stores represented finite set -valued logical structures definition lets hus ands hus ibe structures letf surjective function embeds denoted relation symbol embedded denoted exists function meaning formula preserved embedding sense piece information extracted formula conservative approximation information extracted formalize extend mappings individuals operate assignments function var assignment denotes assignment var theorem embedding theorem theorem hus hus structures function formula assignment defined free variables obtain computable abstract domain ensure -valued structures represent memory configurations finite size defining equivalence relation individuals finite quotient structure respect equivalence relation individual -valued logical structure representing concrete memory cell mapped individual -valued logical structure vector values concrete individual user-chosen collection unary abstraction relations definition canonical abstraction chosen subset unary relation symbols relations called abstraction relations define equivalence relation forall surjective function maps individual equivalence class canonical abstraction respect structure dle dle dle dleu fig -valued structures canonical abstraction structure unary relations abstraction relations canonical abstraction -valued logical structure shown fig represents lists elements element data lower data values rest list graphical notation depicting -valued logical structures individuals represented circles names values unary relations values omitted summary individual represented double circle unary relation pointer program variable represented solid arrow individual absence p-arrow node individuals relation shown binary relation represented solid arrow labeled pair individualsui anduj absence q-arrow pairs binary relations represented dotted arrows canonical abstraction ensures -valued structure larger fixed size priori formula interpreted consistently concrete domain abstract domain embedding theorem meaning interpretations consistent respect abstraction formula abstract structure precise concrete structure kind statement programming language structure transformers abstract semantics abstract postcondition operator defined collection formulas fact abstract transformers defined relation-update formulas define concrete semantics abstract interpretation collects set -valued structures program point implemented iterative procedure finds fixed point collection equations variables values instrumentation relations abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation relations record derived properties varying unary core unary instrumentation relations set abstraction relations set instrumentation relations denoted relation symbol defined instrumentation-relation definition formula instrumentation relation symbols defining formulas instrumentation relations long circular dependences intendedmeaning reachable fields reachable pointer variable fields directed cycle fields table defining formulas commonly instrumentation relations separate relation program variable recall shorthand rtc introduction unary instrumentation relations abstraction relations control concrete individuals merged abstract individual control amount information lost abstraction instrumentation relations involve reachability properties defined rtc transitive closure play crucial role definitions abstractions instance program-analysis applications reachability properties specific pointer variables effect keeping disjoint sublists summarized separately important analyzing program pointers advanced disjoint sublists tab lists instrumentation relations important analysis programs type list interested making assertions compare state store end procedure state start instance interested checking list elements reachable variable start procedure guaranteed reachable fromx end user make assertions double vocabulary relation extend program-analysis specification history relation serves indelible record state store entry point term history relations refer kind relations term active relations refer relations original vocabulary express property mentioned evaluates elements reachable procedure executes reachable beginning procedure procedure performs permutation list addition history relations introduce collection nullary instrumentation relations track active relations changed initial values active relation relation defined place formula asserting permutation property standpoint concrete semantics instrumentation relations represent cached information recomputed reevaluating instrumentation relation defining formula local state standpoint abstract semantics reevaluating formula local -valued state lead drastic loss precision gain maximum benefit instrumentation relations abstract-interpretation algorithm obtain values transition structure transformer instrumentation relation computed incrementally ins algorithm andp defining formula generate incremental relation-maintenance formula verifying sortedness void insertsort list list null null null data data prn null pln break fig stable version insertion sort static-analysis algorithm defined preceding section demonstrate partial correctness procedure user supply program-specific information procedure control-flow graph set -valued structures characterize acceptable inputs query formula characterizes intended outputs initial -valued structures supplied analysis algorithm abstract procedure entry point analysis algorithm run finally query evaluated structures generated exit point problem establishing version insertsort shown fig partially correct fig shows structures characterize set stores program variable points acyclic linked list running analysis insertsort check structures arise procedure exit node formula evaluates dle formula evaluates nodes reachable fromxmust non-decreasing order astute reader notice sorting procedure returns null satisfy formula exit point formula part specification post-condition correct sorting procedure property required correct sorting procedure procedures manipulate sorted linked lists output list permutation input list established formula fig shows -valued structure middle list node larger datavalue nodes stores structure represents shown fig note correct implementation insertion sort produce store fig accurate representation stores arise line fig structures shown fig abstract input structures abstract interpretation collects -valued structure shown fig line note formula evaluates list element guaranteed correct order respect remaining elements note definite dle edge node summary node guarantee list nodes represented summary node correct order represents admits store fig output abstraction insufficiently fine-grained establish partial correctness insertsort fact abstraction insufficiently fine-grained separate set sorted lists set lists sorted order lev-ami tvla establish partial correctness ofinsertsort key step introduction instrumentation relationinorder dle holds nodes data-components equal successor inorder dle defined inorder dle dle sortedness property stated formula inorder dle empty -element list lists elements dle dle dle dle fig structures describe inputs insertsort introduction relationinorder dle -valued structures collected abstract interpretation end insertsort describe stores variable points acyclic sorted linked list -valued structures formulas evaluate assuming case formula instrumentation relation added analysis insertsort guaranteed work correctly acceptable inputs iterative abstraction refinement instrumentation relation inorder dle defined explicitly tvla user heretofore burdens tvla user insight behavior program translate insight logical notation formulating instrumentation-relation definition formulas formula goal present paper automate introduction instrumentation relations inorder dle case insertsort goal obtain definite answers evaluating formula structures collected abstract interpretation 
line fig fig pseudo-code technique steps explained line data-structure constructor compute abstract input structures represent valid inputs program perform abstract interpretation collect set structures program point evaluate query structures exit definite answer obtained structures terminate perform abstraction refinement line identify subformulas query responsible imprecision define instrumentation relations line replace occurrences subformulas query definitions instrumentation relations instrumentation relation symbols apply finite differencing obtain relation-maintenance formulas newly introduced instrumentation relations instrumentation relations definitions changed line obtain precise values newly introduced instrumentation relations abstract structures define valid inputs program achieved reconstructing valid inputs performing abstract interpretation data-structure constructor input program transition relation data-structure constructor query closed formula construct abstract input perform abstract interpretation set -valued structures exit break find formulas instrumentation relations refine actions define program transition relation refine abstract input true fig pseudo-code iterative abstraction refinement query finitely subformulas number abstraction-refinement steps finite additionally run analysis explores bounded number -valued structures algorithm guaranteed terminate instrumentation relation generation attempt abstraction refinement introduction query instrumentation relation lead definite answer query instance insertsort introducing query instrumentation relation ineffective statement program effect changing instrumentation relation fig recursive-descent function instrum finds subformulas answer formula introduction unary instrumentation relation inorder dle sortedness query established inorder dle present statements program abstract interpretation results definite entries inorder dle instance lines fig insertion node pointed node pointed results definite entry inorder dle algorithm generate instrumentation relations account sources imprecision evaluating query algorithm identify subformulas responsible indefinite answer subformulas good candidates define instrumentation relations fig presents function instrum recursive-descent procedure generate defining formulas instrumentation relations arguments function formula logical structure assignment defined free variables top-level invocation nullary query empty structure collected exit node run abstract interpretation return instrum actions error instrum fpg instrum pjp instrum instrum pjp instrum rtc pjp instrum fig function instrum formulas definitions instrumentation relations precondition instrum starting assumption instrum attempts find subformulas sharpened sharpen formula figs subformulas found define instrumentation relations explanations cases instrum violates precondition instrum instrum case instrum unary set abstraction relations add set abstraction relations instrum sharpen definition unary set abstraction relations add set abstraction relations instrum define instrumentation relation definition instrumentation relation inspect find subformulas evaluate instrum define instrumentation relation definition instrumentation relation inspect bindings find subformulas evaluate sorted dle sorted dle sorted dle sorted dle table instrumentation relations created call instrum formula returned instrum definition instrumentation relation free variables order appearance formula unary instrumentation relations added non-abstraction relations added set abstraction relations subsequent iteration column entry fig handles core instrumentation relations abstract interpretation collects -valued structure fig exit node insertsort sortedness query formula evaluates triggering call instrum formula structure empty assignment arguments tab shows instrumentation relations created result call instrum iteration abstraction refinement note sorted defined inorder dle key insight results note instrum returned subformulas definition evaluates definite fig refinement actions define program transition relation sorted sorted sorted sorted sorted sorted sorted dle table final version instrumentation relations introduced abstraction refinement actions define program transition relation modified gain precision improvements storing maintaining instrumentation relations end instrumentation relation query instrumentation relations defining formulas scanned occurrences occurrence pfw vkg substituted free variable replaced withp enabling stored valuep place evaluation complete transition-relation refinement finite differencing creates relationmaintenance formulas instrumentation relations instrumentation relations definitions changed improves precision relations stored values maintained abstract interpretation transition-relation refinement insertsort formula query replaced stored sorted definitions instrumentation relations scanned occurrences sorted sorted order occurrences replaced names relations case relations definitions changed yielding definitions tab refinement abstract input performing abstract interpretation refined program update abstract structures characterize acceptable inputs procedure values instrumentation relations gain maximum benefit maintaining abstract interpretation start precise values abstract input structures simply evaluating abstract input structures assignments free variables results safe values values imprecise illustrate issue stability property property arises context sorting procedures applies list-manipulating programs general stability query formula asserts relative order elements equal data-components remains dle dle implementation round abstract interpretation stopped imprecision detected run abstract interpretation procedure insertsort result definite answer stability query round abstraction refinement introduces subformula formula instrumentation relation stable dle dle rightmost structure fig includes concrete summary individual call simply evaluate formula structure obtain definite tuples evaluation yields tuple dle equal abstraction slls program int sizeof node node node malloc eln head head empty list nondet sll constructor program fig illustration input specifications tvla programs manipulate singly-linked lists traditional input specification tvla fragment code nondeterministically constructs singlylinked lists loop set inputs methodology obtaining values abstract input structures perform abstract interpretation loop constructs family valid inputs program call loop datastructure constructor dsc values instrumentation relations maintained input structures manufactured empty store computed general results precise values instrumentation relations fig illustrates idea abstract interpretation dsc performed extended vocabulary instrumentation relation symbols -valued structures collected exit node dsc abstract input original procedure subsequent abstract interpretation procedure note history relations asr fromx intended record state store entry point procedure equivalently exit dsc make relations values maintained tandem active counterparts abstract interpretation dsc abstract input refinement completed values history relations frozen preparation abstract interpretation performed procedure proper stable instrumentation relation formula exemplifies benefits dsc methodology maintenance stable instrumentation relations starting empty store conclude stable tuple abstract input structure procedureinsertsort stability property holds initially dsc automatically construct abstract input structures abstract interpretation line fig user program inputs form program frees user details initial abstraction structure history relations values active counterparts omitted figure clarity success refinement insertsort structures collected exit node insertsort run abstract interpretation sorted permutation property holds structures facts establish partial correctness insertsort process required iteration abstraction refinement vanilla version specification needed user intervention experimental evaluation evaluate techniques presented paper extended tvla perform iterative abstraction refinement applied types queries programs fig insertsort test programs included sorting procedures bubblesortandinsertsort list-merging proceduremergeand in-situ listreversal procedure reverse antistability query formula asserts order elements equal data-components reversed part specification desired property remains assert produced list permutation input accomplished formula dle dle dscs tests programs generate unsorted lists arbitrary length case programs merge merge dsc program generate pairs unsorted lists test program sorted sorted sortedstableantistable stable antistable bubblesort insertsort insertsort merge reverse fig results applying iterative abstraction refinement verification properties programs manipulate 
linked lists columns correspond queries stated formulas sorted stableand sorted antistableare shorthands conjunctions formulas entries bold discussed fig shows iterative abstraction refinement generate instrumentation relations tvla establish facts tvla succeeds demonstrating sorting routines produce sorted lists bubblesort merge stable routines insertsort reverse antistable routines indefinite answers entries important understand occurrences fig precise correct answers instance result applying reverse unsorted list unsorted list case input list non-increasing order reverse produces sorted list precise answer query entries shown bold fig desired answers stable sorted stable entries insertsort cases illustrate reasons verification method unable obtain precise answer query discussed insertsort identical insertsortexcept line fig correct place insert current node implementation insertion sort antistable shortcomings subformula-based refinement strategy procedure insertsort consists nested loops fig outer loop traverses list setting pointer variable point list nodes iteration outer loop loop finds correct place insert target traversing list start pointer variable target inserted target data data insertsort satisfies invariant list nodes list target correct order data-component target data-component nodes ahead whichr target moved insertsortpreserves original order elements equal data-components insertsort stable routine approach incapable establishing true properties hold programs demonstrates present techniques fall short current abstraction-refinement strategy considers subformulas query introduces instrumentation relations verifying stability insertsort subformulas formula considered result sortedness invariant stated observed attempting verify stable tvla unable establish insertsort stable present cases user suggest additional formulas source instrumentation relations future tool framework strategies generating instrumentation relations abstraction refinement explored step direction weakest-precondition transformation method generate instrumentation relations instructive contrast verification antistability insertsort place insert target routine stops data data inserts target target analysis establish sortedness properties observe list node inserted node data-value instrumentation relations introduced based subformulas antistability query tvla establish antistability insertsort absence sortedness query imprecision abstract interpretation verifying conjunction stability sortedness queries oninsertsort iterative abstraction refinement introduce subformulas formulas result iterations analysis established invariant nodes appearing list target correctly sorted order prior insertion target target invariant analysis establish data-component target equal data-component nodes target addition data data data-component target equal datacomponent nodes insertion preserves stability analysis conclude data-component target possibly equal data-component nodes target manual intervention accomplished tvla addition focus formula constraint overcome imprecision allowing tvla verify stability insertsort real source problem abstract transformers created tvla approximation abstract transformer on-going work exploring ways incorporate transformers tvla performance sorted stable antistable sorted stable sorted antistable fig execution times seconds log scale fig execution times collected ghz linux ram longest-running analysis verifies bubblesort partially correct produces sorted list stable takes minutes majority analyses minute numbers close long takes verify sortedness query user carefully chooses instrumentation relations maximum amount memory tvla perform analyses varied megabytes megabytes additional experiments performed additional experiments test applicability technique queries data structures experiment successfully verified insitu list-reversal procedure reverse produces list reversal input list query expresses property experiment seconds megabytes memory experiments involved programs manipulate binarysearch trees insertbstinserts node binary-search tree anddeletebst deletes node binary-search tree programs technique successfully verified query nodes tree pointed variable remain sorted order end programs left dle dle initial specification analyses included standard instrumentation relations similar listed tab relation formula distinguishes nodes tree pointed dsc analyses non-deterministically constructed binary-search tree allocating node time inserting tree maintaining order property stated formula insertbst experiment seconds megabytes memory deletebst experiment approximately minutes megabytes memory related work work reported similar spirit counterexample-guided abstraction refinement counterexample query verified found analysis equipped technique analysis tests counterexample spurious relations guarantee elimination counterexample introduced analysis repeated counterexamples finite traces state graph slam toolkit implementation symbolic execution path strongest postcondition mechanism determine counterexample spurious symbolic execution sortedness query set tvla applied work tvla written java report maximum total memory minus free memory returned runtime identify abstraction relation eliminate counterexample hardware verification unabstracted system finite-state counterexample trace tested spuriousness actual system spurious counterexample minimally refine system avoid encountering counterexample subsequent iteration key difference setting explored prior work abstraction domain abstraction-refinement work date abstract domains fixed finite cartesian products boolean values domains predicate abstraction predicate abstraction relations introduced nullary relations designing abstraction-refinement technique abstract states -valued logical structures boolean vectors calls approach work lifts predicate-abstraction approach general setting abstraction-refinement algorithm paper introduce unary binary ternary relations addition nullary relations capability needed refinement algorithm gain full benefits richer class abstractions tvla supports weakest preconditions generate nullary instrumentation relations generalized manually abstract-interpretation technique presented produces precise results terminates guaranteed terminate cases contrast method guaranteed terminate automatically generates interesting non-nullary relations unary relation inorder dle crucial showing sortedness stability concept data-structure constructor non-deterministically constructs valid inputs program thought mechanism closing open programs related work slam toolkit http research microsoft slam tvla system http math tau rumster tvla ball rajamani generating abstract explanations spurious counterexamples programs technical report msr-tr- microsoft research january chaki clarke groce jha veith modular verification software components int conf softw eng pages clarke grumberg jha veith counterexample-guided abstraction refinement proc computer-aided verif pages july colby godefroid jagadeesan automatically closing open reactive programs conf prog lang design impl pages york acm press cousot cousot systematic design program analysis frameworks symp princ prog lang pages york acm press das dill successive approximation abstract transition relations symp logic comp sci das dill counter-example based predicate discovery predicate abstraction formal methods computer-aided design springer gopan dimaio dor reps sagiv numeric domains summarized dimensions tools algs construct analysis syst henzinger jhala majumdar qadeer thread-modular abstraction refinement proc computer-aided verif lec notes comp sci pages springer kurshan computer-aided verification coordinating processes princeton press lakhnech bensalem berezin owre incremental verification abstraction tools algs construct analysis syst lec notes comp sci pages springer lev-ami reps sagiv wilhelm putting static analysis work verification case study issta proc int symp software testing analysis pages lev-ami sagiv tvla system implementing static analyses static analysis symp pages pasareanu dwyer visser finding feasible counter-examples model checking java programs tools algs construct analysis syst lec notes comp sci springer ramalingam warshavsky field goyal sagiv deriving specialized program analyses certifying component-client conformance conf prog lang design impl pages york acm press reps sagiv loginov finite differencing logical formulas static analysis european symp programming rusu singerman proving safety properties integrating static analysis theorem 
proving abstraction tools algs construct analysis syst lec notes comp sci pages springer sagiv reps wilhelm parametric shape analysis -valued logic trans prog lang syst tkachuk dwyer pasareanu automated environment generation software model checking proc ase springer yorsh reps sagiv symbolically computing most-precise abstract operations shape analysis proc tacas springer 
integerdesctype enumdesctypetypedesctype chunkdesctype fieldstructype typebasetype ptr xyrect ptr refrect ptr nameddrawobj ptr varrayrect ptr vchunkrect ptr dblptrrect ptr intchunkrect ptr drawobj ptr rectangle ptr namedxyrect ptr arrayrect 
cpsp psp cps 
learning abstractions verifying data-structure properties alexey loginov univ wisconsin alexey wisc thomas reps univ wisconsin reps wisc mooly sagiv tel aviv univ msagiv post tau abstract paper concerns question create abstractions program analysis presents method refines abstraction automatically analysis problems semantics statements query interest expressed logical formulas present strategies refining abstraction simpler strategy effective cases strategy machine-learning algorithm learn abstraction tool incorporates method implemented applied programs manipulate linked lists binary-search trees cases tool demonstrate partial correctness programs programs possess additional properties stability antistability introduction paper presents approach automatically creating abstractions program analysis previous work approach involves successive refinement abstraction unlike previous work work presented paper aimed specifically programs manipulate pointers heap-allocated data structures paper presents abstraction-refinement method static analyses based -valued logic semantics statements query interest expressed logical formulas refinement performed introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations abstraction-refinement method refinement strategies strategy subformula-based refinement analyzes sources imprecision evaluation query chooses define instrumentation relations subformulas query strategy ilp-based refinement employs inductive logic programming machine-learning technique learn instrumentation relations stave imprecision due abstraction setting related logics play ordinary valued logic related -valued logic memory configuration store modeled logicians call logical structure individual structure universe models single memory element case summary individual models collection memory elements run analyzer carries abstract interpretation collect set structures permission make digital hard copies part work personal classroom granted fee provided copies made distributed profit commercial advantage copies bear notice full citation page copy republish post servers redistribute lists requires prior specific permission fee copyright acm x-xxxxx-xx-x program point determine query satisfied checks holds structures collected instantiations framework capable establishing nontrivial properties programs perform complex pointer-based manipulations priori unbounded-size heapallocated data structures tvla system three-valued-logic analyzer implements approach summary individuals play crucial role ensure abstract descriptors priori bounded size guarantees fixed-point reached constraint working limited-size descriptors implies loss information store intuitively properties concrete individuals lost due abstraction groups multiple individuals summary individuals property true concrete individuals group false individuals reason -valued logic uncertainty property captured means truth advantage -valued logic basis static analysis consistency -valued -valued viewpoints ensured basic theorem relates logics theorem care design analysis danger abstract interpretation proceeds indefinite pervasive destroy ability recover interesting information valued structures collected soundness maintained key role combating indefiniteness played instrumentation relations record auxiliary information logical structure provide mechanism fine-tune abstraction instrumentation relation defined logical formula core relation symbols captures property individual memory cell possess general introduction additional instrumentation relations refines abstraction prepared track finer distinctions stores properties program stores identified choice instrumentation relations crucial precision cost analysis tvla users faced task identifying instrumentationrelation set definite answer query make cost prohibitive arguably key remaining challenge tvla user-model contributions work summarized step automatically generating abstractions static analyses based -valued logic introduce inductive logic programming ilp learning instrumentation relations preserve information lost due abstraction essentially user-level obligations tvla criticized past eliminated input required program analysis consists program present transition system query formula identifies acceptable outputs characterization program allowable inputs relation intended meaning denote memory cell pointer variable point memory cell field point dle data field equal table core relations representing stores manipulated programs type list method implemented extension tvla present experimental evidence approach iterative abstraction-refinement loop yield precise answers queries tested effectiveness method sortedness stability antistability queries collection programs perform destructive list manipulation establish partial correctness binary-search-tree programs method successful cases tested remainder paper organized introduces terminology notation readers familiar tvla skip briefly summarizes ilp illustrates goals problem verifying partial correctness sorting routine describes subformula-based refinement illustrates discusses shortcoming subformulabased refinement describes ilp-based refinement ilp learning abstraction presents experimental results discusses related work background stores logical structures typedef struct node struct node int data list figure declaration linked-list datatype section summarizes shape-analysis framework approach concrete memory configurations stores encoded logical structures vocabulary relation symbols arities terms fixed collection core relations core relations part underlying semantics language analyzed record atomic properties stores instance tab lists relations represent stores manipulated programs type list declared shown fig store fig -valued logical structures represent memory configurations individuals set memory cells nullary relation represents boolean variable program unary relation represents pointer variable boolean-valued field record binary relation represents pointer field record numeric-valued variables numeric-valued fields data modeled introducing relations binary relation dle stands data less-than-or-equal-to listed tab dle captures relative order nodes data values fig shows -valued structures represents store fig relationstn explained figure store linked list restricted class structures encode stores exclude structures represent admissible stores integrity constraints imposed instance program-analysis applications relation likex tab captures pointer variablexpoints memory cell attribute unique dle dle dle dle dle dle dle figure logical structures represents store shown fig graphical tabular representations imposes constraint hold individual structure letr finite vocabulary relation symbols denotes set relation symbols arity set -valued structures denoted definition -valued interpretation -valued logical structure set individuals maps relation symbol arity truth-valued function addition distinct individuals -valued logic truth introduced denote uncertainty truth values definite values indefinite information order defined iff definition -valued interpretation -valued logical structure set individuals maps relation symbol arity truth-valued function addition distinct individuals set -valued structures denoted individual called summary individual program-analysis context summary individual abstracts fragments data structure represent concrete memory cell concrete abstract semantics concrete operational semantics defined structure transformer kind edge cfg structure transformer providing collection relation-update formulas core relation formulas define core relations logical structure arises source transformed create logical structure target formulas first-order formulas transitive closure formula vocabulary defined stands reflexive transitive closure formulas variables assignment function maps variables individuals functionality assignment -valued meaning formula denoted yields truth -valued meaning denoted yields truth defined inductively standard fashion dlex dle dle dle figure -valued structure canonical abstraction structure typically define relation function edge optionally precondition formula filters structures follow transition postcondition operator post edge defined lifting structure transformer sets structures collecting semantics program corresponds postcondition operator type suitable abstract domain instance language modeled supports allocation heap set individuals structure unbounded priori upper bound cardinality elements sidestep problem abstracting sets -valued structures -valued structures equipped suitable order set stores represented finite set -valued 
logical structures abstraction defined equivalence relation individuals finite quotient structure respect equivalence relation individual -valued logical structure representing concrete memory cell mapped individual -valued logical structure vector values concrete individual user-chosen collection unary abstraction relations definition canonical abstraction lets chosen subset unary relation symbols relations called abstraction relations define equivalence relation surjective function maps individual equivalence class canonical abstraction ofs respect structurefa unary relations abstraction relations canonical abstraction -valued logical structure shown fig represents lists elements element data higher data values rest list graphical notation depicting -valued logical structures individuals represented circles names values unary relations values omitted summary individual represented double circle unary relation pointer-valued program variable represented solid arrow individual absence p-arrow nodeu individuals relation shown binary relation represented solid arrow labeled pair individuals absence q-arrow pairs relations represented dotted arrows intendedmeaning reachable fields reachable pointer variable fields directed cycle fields table defining formulas commonly instrumentation relations separate relation program variable canonical abstraction ensures -valued structure larger fixed size priori formula interpreted consistently concrete domain abstract domain embedding theorem theorem meaning interpretations consistent respect abstraction formula abstract structure precise concrete structure kind statement programming language structure transformers abstract semantics defined relationupdate formulas define concrete semantics abstract interpretation collects set -valued structures program point implemented iterative procedure finds fixed point collection equations variables values instrumentation relations abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation relations record derived properties varying unary core unary instrumentation relations set abstraction relations set instrumentation relations denoted relation symbol defined instrumentationrelation definition formula instrumentation relation symbols defining formulas instrumentation relations long circular dependences introduction unary instrumentation relations abstraction relations control concrete individuals merged abstract individual control amount information lost abstraction instrumentation relations involve reachability properties defined operator play crucial role definitions abstractions instance program-analysis applications reachability properties specific pointer variables effect keeping disjoint sublists summarized separately tab lists instrumentation relations important analysis programs type list interested making assertions compare state store end procedure state start instance interested checking list elements reachable variable start procedure guaranteed reachable end user make assertions double vocabulary relation extend program-analysis specification history relation serves indelible record state store entry point term history relations refer kind relations term active relations refer relations original vocabulary express property mentioned formula evaluates elements reachable procedure executes reachable beginning procedure procedure performs permutation list addition history relations introduce collection nullary instrumentation relations track active relations changed initial values active relationp relation samep defined samep samern place formula asserting permutation property standpoint concrete semantics instrumentation relations represent cached information recomputed reevaluating instrumentation relation defining formula local state standpoint abstract semantics reevaluating formula local -valued state lead drastic loss precision address problem transition structure transformer instrumentation relation computed incrementally algorithm defining formula generate incremental relation-maintenance formula inductive logic programming ilp ilp subfield machine learning subfield artificial intelligence goal ilp algorithm learn logical relation agrees classification input examples background knowledge ilp algorithms produce answer form logic program non-recursive logic programs correspond subset first-order logic logic program thought disjunction program rules rule conjunction literals variables appearing head rule implicitly existentially quantified definition ilp set positive tuples set negative tuples set background facts represented definite entries logical structure goal ilp find formula satisfied covered satisfied figure linked list shared elements learning unary formula holds linked-list elements pointed fields element importance concept sharing heap data structures recognized -valued structure fig formula isshared meets objective covers positive negative tuples fig shows simplified ilp algorithm systems foil modified construct answer first-order logic formula disjunctive normal form algorithm capable learning formula isshared sequential covering algorithm parameterized functiongain characterizes usefulness adding literal generally heuristic fashion algorithm creates disjunct long positive examples covered existing disjuncts disjunct extended conjoining literal covers negative examples literal relation symbol background structure vocabulary valid arguments literal variables target relation variables long ilp algorithms capable producing recursive programs correspond first-order logic least-fixpoint operator general transitive closure input target relation structure set tuples pos set tuples neg target posnegationslash newdisjunct newneg neg newneg negationslash cand candidate literals cand max gain newdisjunct newdisjunct newdisjunct newneg subset newneg satisfying -quantify newdisjunct variables target target newdisjunct pos subset pos satisfying newdisjunct figure pseudo-code foil arguments variable current disjunct foil literal chosen line heuristic based information gain reader referred details verifying sortedness void insertsort list list null null null data data prn null pln break figure stable version insertion sort static-analysis algorithm defined demonstrate partial correctness procedure user supply program-specific information procedure controlflow graph set -valued structures identify acceptable inputs query formula identifies intended outputs initial -valued structures supplied analysis algorithm abstract procedure entry point analysis algorithm run finally query evaluated structures generated exit point problem establishing version insertsort shown fig partially correct fig shows structures characterize set stores program variable points acyclic linked list running analysis insertsort check structures arise procedure exit node formula evaluates dle formula evaluates nodes reachable non-decreasing order property required correct sorting procedure procedures manipulate linked lists output list permutation input list established checking formula empty list -element list lists elements dle dle dle dle figure structures describe inputs insertsort fig shows -valued structures middle list node larger data-value nodes stores structure represents shown fig fig correct implementation insertion sort represent store arise line structures shown fig abstract input structures abstract interpretation collects -valued structures shown fig line note formula evaluates ons list element guaranteed correct order respect remaining elements note definite dle edge node summary node guarantee list nodes represented summary node correct order instance represents store fig abstraction fine-grained establish partial correctness insertsort fact abstraction fine-grained separate set sorted lists lists sorted order lev-ami tvla establish partial correctness ofinsertsort key step introduction instrumentation relation inorderdle holds nodes data-components equal theirn-successor inorderdle defined inorderdle dle sortedness property stated formula inorderdle introduction relation inorderdle -valued structures collected abstract interpretation end insertsort describe stores variable points acyclic sorted linked list -valued structures formulas evaluate insertsort guaranteed work correctly acceptable inputs learning abstraction instrumentation relation inorderdle defined explicitly tvla user heretofore burdens tvla user insight behavior program translate insight instrumentation relations formula goal present paper automate identification instrumentation relations 
inorderdle case insertsort goal obtain definite answers evaluating formula structures collected abstract interpretation line fig fig pseudo-code method steps explained line data-structure constructor compute abstract input structures represent valid inputs program perform abstract interpretation collect set structures program point evaluate query structures exit definite answer obtained structures terminate perform abstraction refinement input program transition relation data-structure constructor query closed formula construct abstract input perform abstract interpretation set -valued structures exit negationslash break find formulas instrumentation relations refine actions define program transition relation refine abstract input true figure pseudo-code iterative abstraction refinement line identify formulas define instrumentation relations line replace occurrences formulas query definitions instrumentation relations instrumentation relation symbols apply finite differencing obtain relation-maintenance formulas newly introduced instrumentation relations instrumentation relations definitions changed line obtain precise values newly introduced instrumentation relations abstract structures define valid inputs program achieved reconstructing valid inputs performing abstract interpretation data-structure constructor query finitely subformulas limit round ilp-based refinement number abstraction-refinement steps finite additionally run analysis explores bounded number -valued structures algorithm guaranteed terminate attempt abstraction refinement introduction query instrumentation relation lead definite answer query instance insertsort introducing query instrumentation relation ineffective statement program effect changing instrumentation relation introduction unary instrumentation relation inorderdle sortedness query established inorderdle present statements program abstract interpretation results definite entries inorderdle instance comparison line fig insertion lines node pointed node pointed results definite entry inorderdle algorithm generate instrumentation relations account sources imprecision describes subformula-based refinement method query subformulas responsible indefinite answer generate instrumentation relations discusses shortcoming subformula-based refinement describes ilp-based refinement subformula-based refinement subformulas query responsible indefinite answer good candidates defining instrumentation relations fig presents function instrum recursive-descent procedure generate defining formulas instrumentation return instrum error instrum instrum instrum instrum mapsto instrum mapsto negationslash mapsto mapsto instrum mapsto mapsto figure function instrum formulas definitions instrumentation relations relations arguments function formula logical structure assignment defined free variables top-level invocation nullary query empty ands structure collected exit node figure recursivedescent function instrum finds subformulas answer imprecision or-subformula precondition instrum starting assumption instrum attempts find subformulas sharpened sharpen formula figs subformulas found define instrumentation relations explanations cases instrum violates precondition instrum instrum case instrum unary set abstraction relations add set abstraction relations instrum examine defining formula unary set abstraction relations add set abstraction relations instrum define instrumentation relation definition instrumentation relation examine find subformulas evaluate instrum define instrumentation relation definition instrumentation relation examine bindings mapsto find subformulas evaluate formula returned instrum definition instrumentation relationq free variables order appearance formula unary instrumentation relations added non-abstraction relations added set abstraction relations subsequent iteration line entry fig handles sorted dle sorted dle sorted dle sorted dle table instrumentation relations created call instrum core instrumentation relations abstract interpretation collects valued structure fig exit node insertsort sortedness query formula evaluates triggering call instrum formula structure empty assignment arguments tab shows instrumentation relations created result call instrum iteration abstraction refinement note sorted defined inorderdle key insight results note instrum returns subformulas definition evaluates definite mapsto mapsto fig refinement program actions sorted sorted sorted sorted sorted sorted sorted dle table final version instrumentation relations introduced abstraction refinement actions define program transition relation modified gain precision improvements storing maintaining instrumentation relations end relation query instrumentation relations defining formulas scanned occurrences occurrence substituted free variable replaced enabling stored place evaluation complete transition-relation refinement finite differencing creates relation-maintenance formulas instrumentation relations instrumentation relations definitions changed improves precision relations stored values maintained abstract interpretation forinsertsort formula query replaced stored sorted definitions instrumentation relations scanned occurrences sorted sorted order occurrences replaced names relations case relations definitions changed yielding definitions tab refinement abstract input performing abstract interpretation refined transition system update abstract structures characterize acceptable inputs procedure values instrumentation relations gain maximum benefit maintaining abstract interpretation start precise values abstract input structures simply evaluating abstract input structures assignments free variables results safe values abstraction slls program int sizeof node node node malloc eln head head empty list nondet sll constructor program figure illustration input specifications programs manipulate singly-linked lists traditional input specification tvla fragment code nondeterministically constructs singly-linked lists loop set inputs values imprecise illustrate issue stability property property arises context sorting procedures applies list-manipulating programs general stability query formula asserts relative order elements equal data-components remains dle dle run abstract interpretation insertsort result definite answer stability query round abstraction refinement introduces subformula formula instrumentation relation stable dle dle rightmost structure fig includes concrete summary individual call simply evaluate formula structure obtain definite tuples evaluation yields tuple dle equal methodology obtaining values abstract input structures perform abstract interpretation loop constructs family valid inputs program call loop data-structure constructor dsc values instrumentation relations maintained input structures manufactured empty store computed general results precise values instrumentation relations fig illustrates idea abstract interpretation dsc performed extended vocabulary instrumentation relation symbols -valued structures collected exit node dsc abstract input original procedure subsequent abstract interpretation procedure note history relations asr intended record state store entry point procedure equivalently exit dsc make relations values maintained tandem active counterparts abstract interpretation dsc abstract input refinement completed values history relations frozen preparation abstract interpretation related property antistability asserts order elements equal data-components reversed dle dle test suite includes program insertsort identical insertsort line fig correct place insert current node implementation insertion sort antistable structure history relations values astheir active counterparts omitted figure clarity performed procedure proper stable instrumentation relation defined formula exemplifies benefits dsc methodology maintenance stable instrumentation relations starting empty store conclude stable tuple abstract input structure procedure insertsort stability property holds initially dsc automatically construct abstract input structures run abstract interpretation line fig user program inputs form program frees user details initial abstraction success refinement insertsort structures collected exit node ofinsertsort run abstract interpretation sorted permutation property holds structures facts establish partial correctness insertsort process required iteration abstraction refinement basic version specification vocabulary consisted relations tabs history relations needed user intervention ilp-based refinement shortcomings strategy procedure insertsort consists nested loops fig outer loop traverses list setting pointer variable point list nodes iteration outer loop loop finds correct place insert target traversing list start pointer variable target inserted target data data insertsort satisfies invariant list 
nodes list target correct order data-component target data-component nodes ahead target moved insertsort preserves original order elements equal data-components insertsort stable routine subformula-based refinement capable establishing stability insertsort subformulas query case formula candidate instrumentation relations strategy unable introduce instrumentation relations maintain information transitive successors list node correct relative order learning instrumentation relations fig shows structure arises abstract interpretation line fig tabular version relations dle omit reachability relations figure clarity assignment nodes identical vectors values unary abstraction relations subsequent application canonical abstraction produces structure shown fig bold entries tables fig definite values transformed ins structures satisfies sortedness invariant discussed node dle relationship nodes contrast subformula-based refinement capable establishing antistability insertsort place insert target routine stops data data inserts target target analysis establish sortedness properties observe list node inserted node data-value refinement introduces instrumentation relations based subformulas antistability query tvla establish antistability insertsort dle dle dle rnl dle figure structure arises line fig unlabeled edges nodes represent dle relation rnpr dle dle figure structure transformation ofs statement line fig unlabeled edges nodes represent dle relation appearing list exceptr target piece information lost structure dle indicating nodes represented summary node sorted order respect successors refer abstraction steps information-loss points abstract structure transformer temporarily create structure image canonical abstraction subsequent application canonical abstraction transforms structure grouping set individuals single summary individual ofs loss precision due circumstances individuals possesses property individual possess property summary individual individuals property common recomputed precisely cases solution lies introduction instrumentation relations case introduce unary abstraction relation individuals possess property grouped case sufficient introduce non-abstraction relation arity captures common property individuals modified version algorithm learn formulas kinds relations type unary relation positive negative examples type unary relation positive examples type iii binary relation positive examples type relations intended prevent grouping individuals properties types iii intended capture common properties individuals background logical structure serves input ilp type iii relations generalized ternary higher-arity relations pass structures identified information-loss point restrict algorithm active relations structure lose definite entries result abstraction dle definite entries relations learn formulas evaluate positive negative modified algorithm ways learn multiple formulas invocation algorithm motivation find single instrumentation relation explains structure find instrumentation relations analysis establish property interest find multiple literals quality line fig extend distinct copies current disjunct literals extend distinct copies current formula resulting disjuncts change needed handle lack negative examples relations types iii change loop line fig loop do-while obtain non-trivial formulas absence negative examples replace foil information-gain heuristic simpler heuristic based percentage positive examples covered disjunct describe variant ilp learn binary formula structure fig set individuals grouped abstraction input set positive examples set relations lose definite values due abstraction includes dle literal dle covers examples holds bindings mapsto mapsto mapsto algorithm picks literal negative examples dle disjunct literal covers remaining positive algorithm returns formula dle re-written dle relationr abstraction maintain information transitive successors list node correct relative order dle establishing fact list nodes appearing prior target sorted order formulas dle learned ilp fig verification process introducing unnecessary instrumentation relations harm analysis increasing cost ilp refinement loop ilp powerful mechanism learning abstractions present employ subformula-based refinement cost strategy reasonable strategy successful refinement call instrum line fig returns formulas adds relations set abstraction relations turn ilp strategy iteration subformula-based refinement save logical structures information-loss points failure subformula-based refinement invoke ilp algorithm present implementation attempts learn binary formulas type iii prune returned set formulas lower cost analysis remove formulas defined terms single relation symbol formulas tautologies dle dle define instrumentation relations learned formulas simple bubble insert sort insert sort merge reverse post-ilp iteration pre-ilp iterations sorted stable antistable figure execution times program bars represent sorted stable antistable queries cases subformula-based refinement failed upper portion bars shows cost iteration analysis dsc program ilp cost form atomic subformulas finally relations refine abstraction performing steps lines fig subformula-based refinement attempting verify stability insertsort formulas learned ilp algorithm formula completion refinement steps subsequent run analysis successfully verifies stability ofinsertsort experimental evaluation evaluate method presented paper extended tvla perform iterative abstraction refinement applied queries programs fig insertsort test programs included sorting procedures bubblesort insertsort list-merging procedure merge in-situ list-reversal procedure reverse dsc tests procedure generate unsorted lists arbitrary length case programs merge merge dsc procedure generate pairs unsorted lists test program sortedstableantistable bubblesort insertsort insertsort merge reverse figure results applying iterative abstraction refinement verification properties programs manipulate linked lists fig shows method generate instrumentation relations tvla establish properties expect hold tvla succeeds demonstrating sorting routines produce sorted lists bubblesort insertsort andmerge stable routines insertsort reverse antistable routines indefinite answers entries important understand occurrences fig precise correct answers instance result applying reverse unsorted list unsorted list case input list non-increasing order reverse produces sorted list precise answer query fig shows numbers instrumentation relations iteration abstraction refinement number ilpsorted stable antistable test program instrum rels instrum rels instrum rels total ilp total ilp total ilp bubblesort insertsort insertsort merge reverse figure numbers instrumentation relations total learned ilp iteration abstraction refinement learned relations analysis small relative total number instrumentation relations fig execution times collected ghz linux ram longest-running analysis verifies thatinsertsortis stable takes minutes analyses minute rest seconds minutes total time tests minutes numbers close long takes verify sortedness queries user carefully chooses instrumentation relations maximum amount memory tvla perform analyses varied megabytes megabytes cost invocations ilp algorithm attempting verify antistability bubblesort seconds cost incurred information-loss points benchmarks ilp cost ten seconds costs low implementation ilp algorithm unoptimized advantage fact ilp computation information-loss point produces results ilp computations information-loss points performed additional experiments test applicability method queries data structures experiment subformula-based refinement successfully verified in-situ list-reversal procedure reverse produces list reversal input list query expresses property experiment seconds megabytes memory experiments involved programs manipulate binary-search trees insertbst inserts node binary-search tree deletebst deletes node binary-search tree programs subformula-based refinement successfully verified query nodes tree pointed variable remain sorted order end programs left dle dle initial specifications analyses included standard instrumentation relations similar listed tab relationrt formula distinguishes nodes tree pointed dsc analyses non-deterministically constructs binary-search tree allocating node time inserting tree position data-value insertbst experiment seconds megabytes memory 
deletebstexperiment approximately minutes megabytes memory sortedness query set tvla applied work tvla written java report maximum total memory minus free memory returned runtime related work work reported similar spirit counterexampleguided abstraction refinement key difference setting explored prior work abstract domain abstraction-refinement work date model-checking community abstract domains fixed finite cartesian products boolean values domains predicate abstraction predicate abstraction relations introduced nullary relations designing refinement method abstract states -valued logical structures boolean vectors calls approach work lifts predicate-abstraction approach general setting abstractionrefinement algorithm paper introduce unary binary ternary relations addition nullary relations capability needed refinement algorithm addresses richer class abstractions tvla supports distinguishing feature work method driven counterexample traces imprecise results evaluating query case subformula-based refinement loss information abstraction steps case ilp-based refinement slam toolkit identifies shortest prefix spurious counterexample trace extended feasible path general information-loss point occurs end prefix information-loss-guided refinement hand identify earliest points abstraction loses information find instrumentation relations earliest points part abstraction information important extend work learn first-order analog blast parsimonious abstractions abstraction-refinement techniques abstract-interpretation community capable refining domains based predicate abstraction polyhedra-based domain dynamically refined abstract domain work led develop approaches abstraction refinement based machine learning abstract-interpretation community strong albeit unattainable form abstraction refinement identified goal make abstract interpretation complete optimal case goal extend abstraction answer query make abstraction optimal weakest preconditions generate nullary instrumentation relations generalized manually technique presented produces precise results terminates guaranteed terminate cases contrast method guaranteed terminate automatically generates interesting non-nullary relations unary relation inorderdle crucial showing sortedness binary relation defined formula analysis establish stability insertsort concept data-structure constructor nondeterministically constructs valid inputs program thought mechanism closing open programs related work work relates machine-learning techniques program analysis includes strauss tool machine-learning approach discovering specifications api protocols underlying premise programs bugs hints reveal correct protocols cooperative bug isolation project instruments programs collects information executions statistical machine-learning techniques find bugs mining information crashing non-crashing runs technique finding mostprecise abstract set concrete stores expressed logical formula successively approximates result technique related algorithm find-s machine learning search space hypotheses find specific hypothesis satisfies positive examples input concrete stores work represents connection program analysis machine learning shows ilp part abstraction-refinement loop learn abstraction tvla system http tau tvla ammons bodik larus mining specifications popl pages ball rajamani automatically validating temporal safety properties interfaces spin pages chase wegman zadeck analysis pointers structures pldi pages clarke grumberg jha veith counterexample-guided abstraction refinement cav colby godefroid jagadeesan automatically closing open reactive programs pldi pages das dill counter-example based predicate discovery predicate abstraction fmcad pages giacobazzi ranzato scozzari making abstract interpretations complete acm henzinger jhala majumdar mcmillan abstractions proofs popl pages jeannet halbwachs raymond dynamic partitioning analyses numerical properties sas pages jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications chapter pages prentice-hall kurshan computer-aided verification coordinating processes princeton press lakhnech bensalem berezin owre incremental verification abstraction tacas pages lavra zeroski inductive logic programming techniques applications ellis horwood lev-ami reps sagiv wilhelm putting static analysis work verification case study issta lev-ami sagiv tvla system implementing static analyses sas pages liblit aiken zheng jordan bug isolation remote program sampling pldi pages tom mitchell machine learning mcgraw-hill muggleton inductive logic programming generation comp muggleton raedt inductive logic programming theory methods logic prog pasareanu dwyer visser finding feasible counter-examples model checking java programs tacas pages quinlan learning logical definitions relations mach learn quinlan cameron-jones induction logic programs foil related systems gen comp special issue ilp ramalingam warshavsky field goyal sagiv deriving specialized program analyses certifying component-client conformance pldi pages reps sagiv loginov finite differencing logical formulas applications program analysis esop reps sagiv yorsh symbolic implementation transformer vmcai pages sagiv reps wilhelm parametric shape analysis -valued logic toplas tkachuk dwyer pasareanu automated environment generation software model checking ase 
dynamic graph algorithms applications mikkel thorup labs research dynamic data structures static problems standard priority queue greedy algorithm dijkstra single source shortest path algorithm dynamic graph algorithms maintaining properties objects changing graph dynamic graph algorithms updates biconnectivity connectivity -edge-connectivity minimum spanning tree mst update mst insertion deletion delete insert biconnectied disconnected bridge -edge-connected articulatiion point connected applications constructing tree homeomorphic subtrees bac dcbad unique perfect matching talk dynamic shortest paths applications connectivity jvj updates starting maintain spanning forest dynamic forest takes logn time insert disconnected delete seek replacement edge reconnecting introduce levels blog ncg -maximal spanning forest spanning forest components vertices idea amortize level increases insert disconnected delete nfeg replace replace downto replacement edge level level replacement connect level edges level edges return return statement iterated mlog times statement supported logn time mlog total time decremental mst jvj jej maintain minimum spanning forest delete seek lightest replacement reconnecting fnf introduce levels blog ncg -maximal spanning forest spanning forest components vertices initially minimum spanning forest delete nfeg replace replace downto level edges level edges order increasing weight return return fully-dynamic polylogarimic mst general reduction henzinger king icalp -edge-connectivity jvj updates starting maintain spanning forest covers path lem -edge connected covered introduce levels blog ncg -edge connected components vertices maintain highest level covering edge denoted bridge connected insert disconnected call cover cover delete swap covering edge highest level recover cover called mlogn times polylogarithmic cost data structures dynamic forests applications constructing tree homeomorphic subtrees bac dcbad reduction decremental connectivity henzinger king warnow soda small trees represented triples obs descend child root make child component resolves triples disconnected grandchildren found removing edge resolved triple unique perfect matchings reduction decremental -edge connectivity gabow kaplan tarjan stoc lem kotzig unique perfect matching bridge constructing unique perfect matching component bridge components odd number vertices delete edges incident elseif components number vertices delete perfect matching exit empty return perfect matching application thm petersen bridgeless regular graph perfect matching biedl bose demaine lubiw soda dynamic -edge connectivity construct perfect matching time improving boundthe obtained general time boundfor matching shortest paths techniques ramalingam reps suggested lazy dijkstra single source shortest paths running time proportional edges incident vertices changing distance source works great practice recent break-through demetrescu italiano pairs-shortest path vertex update supported time works practice current update time logn log works arbitrary weights thorup internet tra engineering demand general routing max load shortest path routing max load optimizing shortest path routing dynamic shortest paths fortz thorup finding weights minimizing max utilization load capacity factor np-hard cisco default link weight inverse capacity telecommunications bernardfortz fortz poms ucl http poms ucl staff institutd universit ecatholiquedelouvain contents internetrouting anoverview optimizingospfweights internetrouting anoverview internet local search heuristics packet-switched iteratively change weight datacutin reduces smallpieces maxutilization packets loop thataresentoverthe networkoneatatime weight change callsetup shortest path level routes found evaluated ipforwarding ramalingam reps gave speed-up forwarding factor nodes destination edges gained differentpaths cisco default backbone basedondestination percent orlabel optimal loopsmayappear general routing tables concluding remarks talked dynamic graph ipforwarding algorithms source applications feldmann solving anoverview static problems similar priority queues technicaluniversityofmunich greedy algorithms challenge dynamic reachability static xed morecontrol sparse graphs -doesn augmenting paths tscale maxow algorithms 
dynamic compute bestroutes canbemadetoscalewell -consumecpu bandwidth memory -debuggingcanbehell routingprocess source feldmann anoverviewofinternetroutingproto- cols technicaluniversityofmunich exteriorvs interiorprotocols interiorgatewayprotocol igp forconnectivityinsidean autonomoussystem friendlyworld fullconnectivity rapidconvergence protocols ospf rip eigrp is-is mpls exteriorgatewayprotocol egp forconnectivitybetween autonomoussystems hostileworld restrictedconnectivity stability scalability protocol bgp policy-based basicmodel differenttechnologies distancevectors rip bgp distributedshortestpaths computations keeponlylocallinkdata linkstates ospf is-is distributednetworkdata openshortestpathfirst ospf linkstateprotocol linkmetricsbetween nolimitonpathmetric hasrapid loop-freeconvergence scaleswell topologymapateachnode salgorithm advertisements viaflooding forsimplicityweassume someoperatorsforbid thisbehavior is-isissimilar interlude afewwordsaboutmpls androutingisdonealonga labelswitchedpath lsp butforoperational purposes emerging fieldofapplicationsforor trafficengineering aim adaptrouting avoidcongestion ospfnotwellsuitedfor motivationforusingmpls ciscorecommendation useweightsinversely demand optimizationmodel totalroutingcost decisionvariables shortestpaths routing arc loadsla costfunction aarepiecewise linearfunctions cost load thebadnews mpls flowproblem worstcase badexample localsearchheuristic diversification algorithmicaspects numericalresults extensions changetheweightofonearc ofequalweights toobigneighborhoods randomsampling hashing storableon bits pawa completelyavoidscycling diversification twoapproaches randomperturbations algorithmicaspects bottleneck givenasetofweights fromscratch routingcomputation foreachdestinationt shortestpathstot backwarddijkstra buildthegraphg ofarcsthatbelongtoa shortestpathtot wij visitingv set andsetlt lforeach algorithmicaspects asolution dynamicupdatesofthecost theshortestpathsgraph computationtimedividedby foreachdestinationt decreasedweights criticalnodes forallarcs suchthatw wij ifd thensetm fjg whilem selecti mthatminimizesd setm mnfig foreach ifd thend jiandm fjg updateat increasedweights mod modifiednodes forallarcs suchthatw wij ifd atnf ifj setmod mod fig forallj mod forall atnf ifj setmod mod fig change forall mod ifd thend ijandm fig whilem selecti mthatminimizesd setm mnfig foreach ifd thend jiandm fjg updateat dynamicupdateofflows changeddistances update arcstobeaddedtoor deletedfromat setofcriticalnodes initialization nodeswithan whilem selectv mthatmaximizesd setm mnfvg set foreach isneworl set landaddwtom numericalexperiments iterationsoflocalsearch comparisonwith optimalrouting lowerbound unitospf invcapospf ciscorecommendation ospf randomospf performsreallybad numericalexperiments tproposedbackbonenodes- arcs cost demand invcapospf unitospf ospf randomospf heurospf opt numericalexperiments increaseindemands capacity ospfworkswell withour heuristic extensions robustnessvs hotspotsandlinkfailures multipledemandmatrices exactmethods verydifficultproblem somereferences ben-ameur michel gourdin andb liau routingstrategiesforip networks telektronikk bley tchel andr wess networks inproc dimacsworkshopon ams-dimacsseries fortz andmatveeva workinprogress fortz andm thorup inproc thieeeconf oncomputercommunications infocom fortz andm thorup optimizingospf fortz rexford andm thorup protocols ramalingam andt reps shortest-pathproblem jounalofalgorithms 
exit exit pow main entryglobal exitglobal entrypow exitpow entrymain exitmain pow main entryglobal exitglobal pow main entryglobal exitglobal entry main result call pow etn pow res call pow etn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow pow entry main result call pow retn pow res call pow retn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow powpow entry pow power exp power base exp-u return power gexit pow exit pow powpow entry main result call pow etn pow res call pow etn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow pow exitglobal entryglobal path numvalidcomps num valid completions numvalidcomps num valid completions edgevalueincontext numvalidcomps edgevalueincontext edgevalueincontext inumvalidcomps edgevalueincontext knumvalidcomps entryglobal exitglobal entryglobal exitglobal entryglobal exitglobal entry main result call pow etn pow res call pow etn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow pow gentry main gentry pow main main entry main result call pow etn pow res call pow etn pow res gexit main return exit main main exit global entry global entry pow power exp power base exp-u return power gexit pow exit pow pow gentry main gentry pow exit entryglobal exitglobal entryglobal exitglobal entryglobal exitglobal 
safety-checking machine code zhichen dissertation submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison thesis page tuesday december copyright zhichen rights reserved thesis page tuesday december safety-checking machine code zhichen supervision professor barton miller professor thomas reps wisconsin madison importing executing untrusted foreign code everyday occurrence web servers download plug-ins applets databases load type-specific extensions operating systems load customized policies performance measurement code certification safety untrusted code crucial domains developed methods determine statically safe untrusted machine code loaded trusted host system safety-checking technique operates directly untrusted machine-code program requiring initial inputs untrusted program annotated typestate information linear constraints approach opens possibility certify code produced compiler source language eliminates dependence safety correctness compiler final product compiler checked leads decoupling safety policy language untrusted code written makes safety checking performed respect extensible set safety properties host side implemented prototype safety checker sparc machine-language thesis page tuesday december programs applied safety checker examples ranging code branches code nested loops code function method calls safety checker mechanically synthesize loop invariants check examples times ranging dozens seconds thesis page tuesday december iii acknowledgments advisors bart miller tom reps guidance encouragement privilege advisors benefit greatly daily interactions setting high standard research patience admire intuitions encyclopedic knowledge marvin solomon rastislav bodik carefully reading thesis draft provide valuable feedback entire committee bart miller tom reps marvin solomon rastislav bodik gregory moses lively discussion dissertation defense xiaodong zhang mentor friend encouraging apply graduate school feel deeply debt people ari tamches brian wylie phil roth tia newhall vic zandy ling zheng oscar naim karen karavanic andrew bernat alexandre mirgorodskii good colleagues resources finally parents zhenxiang meiling wang encouraging pursue graduate study united states wife shen son alex wife tolerating long journey support succeeded son alex giving joy thesis page iii tuesday december contents abstract acknowledgments iii contents list figures viii introduction contributions organization dissertation related work safety checking dynamic techniques static techniques work related static techniques hybrid techniques array bounds checking techniques optimizing array bounds checks techniques propagating information array bounds program-verification techniques synthesis loop invariants overview safety properties policy abstract storage model thesis page tuesday december inputs safety-checking analysis phases safety-checking analysis preparation typestate propagation annotation local verification global verification typestate checking typestate system type type expressions subtyping relation typestate checking subtyping state access permissions abstract operational semantics sparc instructions overload resolution propagation type state access information typestate checking summarizing calls detecting local arrays related work annotation local verification annotation attachment safety predicates generating safety preconditions assertions local verification thesis page tuesday december global verification program verification linear constraints theorem prover induction-iteration method enhancements induction-iteration method handling sparc machine language handling store instructions handling multiple loops handling procedure calls strengthening formulae incorporating generalization controlling sizes formulae sharing common computations performing simple tests assuming acyclic code fragment scalability induction-iteration method potential improvements range analysis range analysis experimental evaluation prototype implementation case studies limitations lost precision due array lost precision due type system limitations induction-iteration method summary thesis page tuesday december vii conclusions future work limitations future research improving precision safety-checking analysis developing algorithms employing static run-time checks improving scalability safety-checking analysis employing modular checking employing analyses unsound producing proof-carrying code extending techniques safety checking enforcing security policy reverse engineering thesis page vii tuesday december viii list figures inputs phases safety-checking analysis simple summing elements integer array host-typestate specification invocation specification access policy initial annotations memory state line assertions safety preconditions line simple language type expressions inference rules define subtyping relation subtyping pointer types rule pointer unsound flow-insensitive type checking absence aliasing information contents store statement functionf figure portion state lattice propagation type state access information propagation typestate results typestate propagation safety preand postconditions safety preand post-conditions alias contexts inferring type size local array thesis page viii tuesday december attachment safety properties safety preconditions produced annotation phase weakest liberal preconditions sample sparc instructions respect postcondition basic induction-iteration algorithm branch delay slot handling sparc condition code weakest liberal precondition acyclic code region applying induction iteration method consecutive loops applying induction iteration method nested loops conditionals program weaken extent prevented loop-invariant induction-iteration algorithm breath-first search induction iteration binary operations symbolic expressions dataflow functions tests symbolic range analysis applied running prototype implementation sparc machine language characteristics examples performance results performance results times perform global verification range analysis normalized respect times perform global verification range analysis operator vector type introducing propagating nodes thesis page tuesday december examples induction-iteration method handle introducing basic induction variable examples shown figure thesis page tuesday december chapter introduction prevailing trends software development call techniques protect software component trend dynamic extensibility trusted host extended importing executing untrusted foreign code web browsers download plug-ins databases load typespecific extensions storing querying unconventional data operating systems load customized policies general functionality performance-measurement code operating systems download part application kernel application perform proposals loading application-specific policies internet routers certification safety untrusted code crucial domains trend component-based software development software components produced multiple vendors construct complete application component-based software-development model improves software reusability productivity thesis page tuesday december software components sources proper protection software components essential thesis show determine statically safe untrusted machine code loaded trusted host system contrast work enforces safety restricting things expressed source language safe languages certifying compilers typed assembly languages safe code written source language produced compiler long unsafe expressed machine code philosophical difference implications code producer freedom choosing implementation language building certifying compiler language certify code produced general-purpose off-the-shelf compiler leads decoupling safety policy language untrusted code written makes safety checking performed respect extensible set safety properties host side important high-level characteristics safety-checking technique operates directly binary code ability extend host fine-grained level untrusted foreign code manipulate internal data structures host directly iii enforces default collection safety conditions prevent type violations array out-of-bounds violations address-alignment violations uninitialized variables null-pointer dereferences stack-manipulation violations addition providing ability safety criterion extended thesis page tuesday december access policy host host-specified access policy lists host data accessed host functions methods called untrusted code means host grant privilege untrusted code accomplish task approach based annotating global data trusted host type information precisely typestate information untrusted 
code inferred analysis starts information initial memory state entry untrusted code abstractly interprets untrusted code produce safe approximation memory state program point annotates instruction safety conditions instruction obey checks conditions memory states entry program points untrusted code terms typestates linear constraints linear equalities inequalities combined quantifiers analysis typestates opposed types condition safe perform operation function types operation operands states safe write location stores uninitialized unsafe read typestates differ types providing information finer granularity typestate checking differs traditional type checking traditional type checking flow-insensitive analysis typestate checking flow-sensitive analysis typestates related security automata security automaton states accepting states automaton thesis page tuesday december detects security-policy violation reads symbol automaton current state transition defined design typestate system captures states security automaton security-violation state typestate checking method statically assessing security violation figure illustrates inputs phases safety-checking analfigure inputs phases safety-checking analysis dotted vertical line separates untrusted trusted worlds java off-the-shelf compiler ordinary binary access policy host-typestate speci cation invocation speci cation preparation initial memory state untrusted trusted typestate memory state program point annotation factslocal safety global safety local global propagation conditionsconditions veri cation veri cation thesis page tuesday december ysis inputs safety-checking analysis include host-typestate specification invocation specification addition untrusted code host-specified access policy host typestate specification describes type state host data invocation untrusted code safety preand post-conditions calling host functions methods invocation specification binding information host resources registers memory locations represent initial inputs untrusted code combination host-typestate specification invocation specification access policy information initial memory state time untrusted code invoked safety-checking analysis consists phases preparation typestatepropagation annotation local verification global verification phases find state instruction operates phases find safety conditions instruction obey check conditions preparation phase combines information provided hosttypestate specification invocation specification access policy produce initial annotation form abstract store program entry point phase produces interprocedural control-flow graph untrusted code typestate-propagation phase takes control-flow graph initial annotation inputs abstractly interprets untrusted code produce safe approximation memory contents typestate abstract location program point annotation phase takes input typestate information discovered typestate-propagation phase thesis page tuesday december traverses control-flow graph annotate instruction local global safety conditions assertions local safety preconditions conditions checked typestate information assertions restatements logical formulas facts implicit typestate information local-verificationphase checks local safety conditions global-verification phase verifies global safety conditions global safety conditions perform array bounds checks null-pointer dereference checks addressalignment checks represented linear constraints advantage synergy efficient range analysis expensive powerful technique applied demand array bounds checks range analysis determines safe estimates range values register program point information determining accesses arrays bounds conditions proven results range analysis program-verification techniques induction-iteration method synthesize loop invariants untrusted code loops description safety-checking analysis synthesizes verifies safety proof noted structure safety-checker principle separate safety-checker proof generator proof verifier proof generator generates proof-carrying code pcc proof checker validates safety proof technique lift current limitations certifying compilers produce pcc automatically programs written certhesis page tuesday december tain safe source languages implemented prototype safety checker sparc machine-language programs applied safety checker examples ranging code branches code nested loops code function method calls safety checker prove met safety conditions identify places safety conditions violated times ranging tens seconds ultrasparc machine remainder dissertation call party generates untrusted foreign code code producer human codegeneration tool party responsible trusted host code consumer contributions major contributions thesis technique opens possibility certify object code produced off-the-shelf compilers independent source language compiler require inputs untrusted code annotated typestate information linear constraints technique extensible addition default collection safety conditions checked additional safety conditions checked host extend notion typestate ways typestates thesis page tuesday december describe state information abstract locations abstract storage model extend typestates include access permissions extent untrusted code allowed access host resources iii addition typestates distinguish initialized values uninitialized typestates track pointers propose typestate-checking system perform safetychecking untrusted machine code implements inheritance polymorphism physical subtyping work introduces method coping subtyping presence mutable pointers introduce mechanism summarizing effects function calls safety preand post-conditions summaries analysis stop trusted boundaries form step checking untrusted code modular fashion make safety-checking technique scalable present technique infer information sizes types stackallocated arrays describe symbolic range analysis suitable propagating information array bounds range analysis speed safety checking generally expensive program-verification techniques bounds checks describe prototype implementation safety-checking technique experimental studies evaluate work thesis focuses enforcing fine-grained memory protecthesis page tuesday december tion decidable logic expressing safety conditions simple heuristics synthesizing loop invariants stress techniques originally developed verification correctness prove total partial correctness safety checking ambitious verification correctness organization dissertation dissertation organized chapters begin discussion related work chapter chapter describe safety properties enforce notion access policy present overview safety checking analysis means simple chapters describe phases safety-checking analysis starting phase chapter describe phase safety-checking analysis describe abstract storage model analysis typestate system present typestate-checking analysis recovers typestate information program point untrusted code typestate-checking system check safety untrusted machine code implements inheritance polymorphism physical subtyping describe techniques make safety-checking analysis precise efficient chapter present details annotation local-verification phases analysis chapter describe global-verification phase present induction-iteration method synthesizing loop invariants thesis page tuesday december enhancements describe symbolic range analysis array bounds checking chapter present experience safety-checking technique gained prototype implementation untrusted code written sparc machine languages case studies finally chapter present conclusions suggest directions future research thesis page tuesday december chapter related work chapter discuss research efforts closely related dissertation section survey techniques enforce safe program execution examine techniques statically check array out-of-bounds violations section discuss techniques synthesizing loop invariants section safety checking techniques enforce code safety fall categories dynamic static hybrid static techniques potentially efficient run-time dynamic hybrid techniques static techniques incur run-time overhead precise reject code determined safe statically dynamic technique incurs run-time cost require corrective actions case safety violation detected run-time hybrid techniques tend efficient dynamic techniques dynamic techniques require corrective actions thesis page tuesday december presence safety violation survey related work compare work static techniques closest dynamic techniques safety issues addressed dynamic technique enforce code safety safety violations detected corrective action violation detected run-time corrective action simple terminating offending code complex offending code accesses shared data structures trusted host extreme dynamic techniques safety interpretation virtual machine interprets untrusted 
code checks safety instruction run-time bsd network packet filter utility commonly referred bpf defines language interpreted operating system network driver interpreter checks run-time memory bounds packet data statically allocated scratch memory interpretation incurs high run-time cost bpf times slower versions written statically checked proof-carrying code languages designed interpreted small limited control data structures makes unsuitable general-purpose simple enforce safety untrusted code isolate hardware-enforced address space similar operating system kernels protect user-level applications approach hardware thesis page tuesday december operating system kernel prevent code address space corrupting code data address space prevent untrusted code leaving host software inconsistent state terminating releasing resources acquired untrusted code interact host software restricted interface apparent limitation requiring special hardware support major disadvantage approach high run-time cost cross-address-space call requires trap operating system kernel copying arguments caller callee saving restoring registers switching hardware address spaces dispatch back user level software fault isolation sfi pure software techniques achieve functionality hardware-enforced address spaces lower cost form sfi sandboxing ensures high bits memory address match sandbox region assigned foreign code vino exokernel systems sandboxing ensure extensions downloaded safe sfi hardware-enforced address spaces provide protection isolating untrusted code protection domain restricting interface interact host software sfi modifies binary code directly independent source language hardware-enforced address spaces protection provided sfi coarse-grained system finegrained sharing sfi incurs low run-time overhead processors large number registers register spilling needed free registers thesis page tuesday december sandboxing untrusted code interacts frequently code host environment untrusted components residing protection domains read operations checked overhead run-time checking amount opposed percent write operations checked checking read operations reads memory-mapped devices destructive finally sfi difficult implement correctly hard prevent code modifying protect contents stack leroy rouaix proposed theoretical model systematically placing type-based run-time checks interface routines host code provide fine-grained memory protection technique checks host requires source host api safety requirements enumerating set predetermined sensitive locations invariants locations technique related leroy rouaix technique technique type-based rely static analysis run-time checking addition technique works untrusted binary code technique instruments host api source level model safety policy chapter general finally perform type checking perform typestate checking chapter typestates provide finer grained information types typestate checking flow-sensitive analysis traditional type checking flow-insensitive analysis technique potentially precise thesis page tuesday december static techniques static techniques ensure code safety advantages code potentially efficient run-time checks involved corrective action needed code misbehave static techniques enforce code safety range provide accountability techniques formal methods verify binary conforms specification logic correctness checking techniques verify binary conforms safety properties type safety techniques emphasize finding potential bugs enforcing full safety techniques check correctness program hard automate techniques check program specific safety properties manageable correctness checking expensive techniques focus finding potential bugs analysis efficiency rely analyses sound complete simplest static technique enforcing safety personal authority microsoft activex digital signatures record information origin code svr kernels users super-user privilege install kernel modules device drivers kernel approach accountability safety research projects formal methods verify binary code conforms specification logical formula memory safety properties clutterbuck carre describe technique prove programs written subset intel machine language conform thesis page tuesday december specifications technique spade software tools work programs defined spade fdl spade program modelling language safety-checking analysis flow-analysis program-verification techniques flow analyses check problems unreachable code code exit reached multiple-entry loops undefined variables unused definitions redundant tests spade program verifier checks program conforms specification logical formulae boyer approach prove machine-code program memory safe consistent mathematical specification technique models semantics subset instruction set architecture isa meticulous detail giving machine code explicit formal operational semantics operational semantics logic automated reasoning system analogous supplying loop invariants floyd-style verification conditions approach requires manual construction lemmas major limitation general theorem-proving techniques proving validity arbitrary predicate first-order logic undecidable addition proving program loops satisfies preand postcondition floyd-style verification conditions involves synthesizing loop invariants general mechanically proving program conforms specification correct hard accomplish mechanically general projects focus verifying piece untrusted code specific safety properties examples thesis page tuesday december projects include proof-carrying code pcc certifying compiler typed-assembly language tal work pcc based observation generally faster easier validate proof generate pcc code producer code proof code safety properties necula lee pcc statically check safety network packet filters provide safe native extensions major advantage pcc safety depends correctness proof checker small trusted party needed pcc tamper proof change makes code unsafe proof invalid identified proof checker pcc ability associate proofs end-product machine code manual generation proofs tedious errorprone type safety property considered proof system needed adding proofs code considerably increase size code times original size avoid manual construction pcc necula lee introduce notion certifying compiler compiles high-level programming language program pcc prototype compiler touchstone compiles safe subset assembly code carries proofs type safety show loop invariants type safety array bounds checks generated automatically compiler work shows relevant operational content simple type systems encoded extensions first-order predicate logic thesis page tuesday december relying logic system encode types morrisett introduced notion typed assembly language tal approach type information high-level program incorporated representation program platform-independent typed intermediate form carried series transformations level target code compiler type information perform sophisticated optimizations internal errors compiler detected invoking type-checker code transformation compiler typed assembly language certifies type safety ensuring well-typed source program maps welltyped assembly program checking full safety time consuming analyses minimum sound static debugger static analysis find unsafe operations guarantee full safety make analyses sound complete interest efficiency flanagan describe interactive static debugger scheme identify program operations run-time errors dereferencing null pointer calling non-function program analysis computes value-set descriptions term program constructs flow graph connecting set descriptions evans describes extensions lclint checking tool tool statically checking programs tool perform stronger checking standard version lint detect dynamic memory errors dereferencing null pointers failure allocate deallocate memory undefined deallocated storage danthesis page tuesday december gerous unexpected aliasing technique interface annotations avoid expensive interprocedural analysis reduce amount error messages analysis loops treated conditional statements detlefs describe static checker common programming errors array index out-of-bounds null-pointer dereferencing synchronization errors multi-threaded programs analysis makes linear constraints automatically synthesizes loop-invariants perform bounds checking parameterized policy specification safety-checking analysis works source-language programs makes analyses 
sound complete policy specifications user-supplied modifies lists variables procedure modified offer degree access control work related static techniques static techniques closest certifying compiler typed-assembly language prominent difference approach certifying compiler tal approach philosophical certifying compiler approach enforces safety preventing bad things expressible source language safe subset touchstone compiler popcorn language talx pointer arithmetic pointer casting explicit deallocation memory contrast thesis page tuesday december safe code written language produced compiler long bad code philosophical difference implications code producer freedom choose language including unsafe languages assembly freedom produce code off-the-shelf compiler manually eliminates dependence safety correctness compiler pcc technique checks safety final product compiler leads decoupling safety policy source language turn makes safety checking performed respect extensible set safety properties host side approach introduce additional variable process partially programmer control code-generation idioms compiler defeat techniques system implementation analyses rely aware idioms compiler important difference approach certifying compiler tal approach safety properties enforce based notion typestate extensive information types addition high-level differences technical differences safety checker viewed certifier generates proofs recovering type information existed source-language program embodiment suggestion made necula lee approach safety checker differs touchstone thesis page tuesday december compiler respects touchstone replaces standard method generating verification conditions vcs formulae pushed backwards program forward pass program combines generation symbolic execution contrast system forward phase typestate checking kind symbolic execution fairly standard backward phase generation chapter description typestate checking chapter description generation vc-generation phase backwards pass program usual reason advantage propagating information backwards avoids existential quantifiers arise formulae pushed forward direction generate strongest post-conditions forward vc-generation phase quantifiers accumulate forcing work larger larger formulae safety-checking analysis mechanically synthesizes loop invariants bounds checking alignment checking touchstone generates code explicit bounds checks removes checks prove redundant comparing tal type system tal model language features instance tal models language features address exceptions existential types hand system models size alignment constraints tal tal type system support general pointers stack stack heap pointers distinguished tal declare function receives tuple argument accept heap-allocated thesis page tuesday december tuple call site stack-allocated call site talx introduces special macros array subscripting updating prevent optimizer rescheduling macros expand code sequences perform array-bounds checks impose restrictions idioms compiler employ implement array subscripting tal achieves flow-sensitivity system tal blocks code labeled functions types assigned registers function system achieves flow-sensitivity typestate instruction differences interesting note safety checker programs written typed assembly language untyped machine language work required recover type information perform overload resolution propagate state access information applies java bytecode type information contained bytecode instructions finally touchstone popcorn compiler talx track aliasing information introduced abstract storage model extended typestate checking track pointers result analysis provide precise popcorn touchstone work related work detlefs technique make linear constraints automatically synthesize loopinvariants perform bounds checking parameterized policy specifications safety-checking analysis works source-language prothesis page tuesday december grams makes analyses sound complete policy specifications general access policies terms regions categories access permissions chapter hybrid techniques technique combines static dynamic checking requires fewer run-time checks dynamic techniques corrective actions faults occur run-time examples hybrid techniques safety checking include safe languages java mesa modula safe language defined semantics valid programs written language guaranteed safety properties employs static run-time measures avoid operations potentially harmful systems safe languages system extensions include pilot runs programs written mesa hotjava web browser extended applets written java spin extensible extended modules written modula safe language safety property build language safe language relies strong typing enforce fine-grained memory protection data abstraction techniques based types programming-language semantics including pcc certifying compilers safe languages offer finer-grained access control flexibility based physical means thesis page tuesday december sfi hardware-enforced address spaces types correspond naturally computer resources protect safe languages prohibit badthings happening restricting expressiveness language consequence restricts applicability technique languages assembly code general-purpose type-safe languages java occasions functionality implemented low-level languages assembly code array bounds checking basic requirement safe program execution array accesses bounds array bounds checks essential enforcing program security buffer-overrun vulnerabilities malicious user overrun stack contents circumvent computer security checks long plagued security architects wagner report buffer overruns account today vulnerabilities based data cert advisories decade techniques performing array bounds checks include techniques optimizing array bounds checks symbolic analyses compute bounds index array program-verification techniques sections describe work areas thesis page tuesday december techniques optimizing array bounds checks markstein developed analysis technique moves array bounds checks loop eliminates checks analysis determine array out-of-bounds violations analysis places array bounds checks loop modifies loop-control condition guarantees array out-of-bounds violations occur places test loop exit ensure loop perform number iterations original program gupta technique optimizing array bound checks gupta optimizations reduce program execution time object code size elimination redundant checks propagation checks loops combination multiple checks single check analysis performed reduced control-flow graph consists minimal amount data flow information range-check optimizations kolte wolfe present compiler-optimization algorithm reduce run-time overhead array bounds checks algorithm based partial redundancy elimination incorporates previously developed algorithms including gupta array bounds checking optimizations techniques perform array bounds checking introducing code perform checks checking code optimized thesis page tuesday december techniques propagating information array bounds algorithms rely dataflow analysis abstract interpretation propagate information array bounds vary sophistication assertions rules propagating combining assertions assertions verbrugge intervals scalars cousot halbwachs convex polyhedra track correlations variables wagner flow-insensitive analysis analysis efficiency verbrugge flowand contextsensitive analysis harrison compile-time analysis reduce overhead due range checks compile-time techniques range propagation range analysis employed yielding bounds ranges variables points program harrison technique propagates ranges scalar intervals ranges simple symbolic bounds range information eliminate redundant range checks array subscripts verbrugge range-analysis technique called generalized constant propagation gcp gcp scalar interval domain employs flowand context-sensitive analysis attempts balance convergence precision analysis steppingup ranges decreasing lower bound increasing upper bound variables failed converge fixed number iterations gcp points-to information discovered earlier analysis phase thesis page tuesday december rugina rinard symbolic bounds analysis analysis gains context sensitivity representing symbolic bounds variable functions polynomials rational coefficients initial values formal parameters analysis proceeds basic block generates bounds variable entry abstractly interprets statements block compute bounds variable program point inside exit basic block based bounds build symbolic constraint system solve constraints reducing linear 
program coefficient variables symbolic-bound polynomials solve symbolic constraint system goal minimizing upper bounds maximizing lower bounds bodik describe method eliminate array bounds checks java programs method restricted form linear constraints called difference constraints solved efficient graph-traversal algorithm demand goal apply analysis array bounds checks selectively based profile information fall back run-time checks cold code blocks wagner formulated buffer-overrun-detection problem integer constraint problem solved linear time practice analysis flowand context-insensitive goal finding errors cousot halbwachs method based abstract interpretation convex hulls polyhedra technique precise thesis page tuesday december simply verify assertions discover assertions deduced semantics program propose range analysis array bounds checking section range analysis closest gcp differs gcp respects domain symbolic ranges perform widening operation quicker convergence sharpen analysis selecting suitable spots loops performing widening operation incorporating correlations register values gcp technique points-to information discovered earlier analysis phase current implementation range analysis context-insensitive gcp context-sensitive program-verification techniques suzuki ishihata german floyd-style program verification techniques verify absence array out-of-bound violations programs floyd-style program verification relies system ability synthesize loop invariants automatically suzuki ishihata introduced method called induction iteration synthesizing loop invariants german method relies simple heuristics suzuki ishihata german methods developed structured source-level programs synthesis loop invariants major problem building automatic verifier require programmer-supplied annotations system synthesize loop invarithesis page tuesday december ants ways synthesize loop invariants automatically heuristics difference equations abstract interpretation running program test-oriented fashion induction-iteration method katz manna wegbreit describe heuristics synthesize loop invariants approach back-substitutions performed starting postcondition produce trial loop predicates trial loop predicates loop invariants modified heuristics generate trial predicates heuristics domain specific shown examples domain integers integer arrays synthesizing loop invariants difference equations proceeds steps finding explicit expression variable iterations loop eliminating obtain invariants abstract interpretation method works forward precondition precondition hold treated data submitted input evaluator evaluator operators treated operations predicates abstract interpretation taking predicates arguments delivering predicate result evaluator encounters conditional chooses alternatives current state logically implies decision predicate negation control splits parallel branches junction nodes handled sequence operations predicates input arcs merged result merge joined previous predicate output edge form predicate output edge thesis page tuesday december loop invariants synthesized running program test-oriented fashion consists steps step selects values input variables step runs program inputs collects values output variables program point step establish relations variables induction-iteration method suzuki ishihata weakest liberal preconditions synthesizing loop-invariant postcondition loop verified inductively synthesizes loop invariant true entry loop implies postcondition extended induction-iteration method machine-language programs nested loops interprocedural verification description induction-iteration method extensions found chapter adopt induction-iteration method mechanical assertions prove general required prove program conforms specification thesis page tuesday december chapter overview goal check statically safe piece untrusted foreign machine code loaded trusted host system start ordinary machine code mechanically synthesize verify safety proof chief advantage approach opens possibility certify code produced general-purpose off-the-shelf compiler programs written languages work limit safety policy fixed set memory-access conditions avoided perform safety checking respect safety policy supplied host side proof-synthesis techniques employed host side approach viewed alternative proof-carrying code pcc approach pcc requires code producer create machine code proof code safe host perform proof-validation step proof-synthesis techniques employed code prothesis page tuesday december ducer foreign side untrusted trusted boundary approach viewed ally pcc helps lift current limitations certifying compilers produce pcc automatically programs written safe source languages mechanically synthesize verify safety proof piece untrusted code analysis starts description initial inputs untrusted code access policy abstractly interprets untrusted code produce safe approximation memory state program point memory states abstract storage model information discovered program point analysis annotates instruction safety conditions instruction obey verifies conditions reminder chapter describe safety properties enforce notion access policy describe abstract storage model inputs safety-checking analysis present overview safetychecking analysis means simple safety properties policy untrusted code imported host system acceptable behaviors untrusted code behavior specifications form safety conditions include collection default safety conditions host-specified access policies default safety conditions enforce fine-grained memory protection data abstraction based strong typing default safety conditions check type thesis page tuesday december violations array out-of-bounds violations address-alignment violations uninitialized values null-pointer dereferences stack-manipulation violations ensure untrusted code forge pointers operations untrusted code operate values proper types proper level initialization access policy additional flexibility allowing host host data accessed host functions methods called untrusted code means host privilege untrusted code accomplish task minimize potential damages untrusted code trusted host model view addresses passed piece untrusted code doors host data region access policy controls memory locations resources accessible pointer types memory locations reachable access policy specifies ways accessed terms types memory locations contents access policy classification memory locations regions list triples form region category access permitted region large entire address space small single variable category field set types aggregate fields access field subset meaning readable writable followable executable operable model properties location propthesis page tuesday december erties stored location access permission introduced pointer-typed values pointer dereferenced access permission applies values type pointerto function values hold address function function pointed called untrusted code access permission includes rights examine copy perform operations covered byx feel safety policy suppose user asked write extension piece untrusted code finds lightweight process thread running suppose information threads stored host address space linked list defined structure thread struct thread int tid int lwpid struct thread policy extension read examine tid lwpid fields follow field stands hostregion region list threads stored thread tid thread lwpid thread rfo model variety safety policies roughly equivalent sandboxing original sandboxing model partitions address space protection domains modifies piece untrusted code accesses thesis page tuesday december domain model sandboxing boils allowing untrusted code access memory valid addresses untrusted data region examine operate data items type address location host region dereferenced side-effects confined untrusted region approach differs sandboxing purely static make untrusted code sandboxing works situations limit memory accesses untrusted data region forbidding access data host region draconian measure instance access host data region applications simple performance instrumentation read statistics maintained host environment model aggressive policies defined allowing simple reads writes locations host data region forbidding pointers modified policies permit untrusted code follow types valid pointers host data region order traverse linked data structures 
aggressive policies permit untrusted code change shape host data structure allowing untrusted code modify pointers safety properties policies introduced ensure integrity host environment violated host resources accessed improperly safety policy include safety postconditions ensuring invariants defined host data restored time control returned host thesis page tuesday december abstract storage model introduce abstract storage model describing memory states program point abstract storage model abstract domain safety-checking analysis model includes notion abstract store linear constraints abstract store total map abstract locations typestates abstract location summarizes physical locations heapand stackallocated objects analysis finite domain work abstract location size alignment optional attributes abstract location readable writable access policy typestate describes type state access permissions stored abstract location typestates form meet semi-lattice typestates section linear constraints linear equalities linear inequalities combined logical operators quantifiers represent safety requirements array bounds checks address alignment checks null-pointer checks inputs safety-checking analysis inputs safety-checking analysis include untrusted code host-specified access policy section host-typestate specification invocation specification inputs untrusted code provided host host-typestate specification information regardthesis page tuesday december ing functions methods host called access permission access policy host functions called called host-typestate specification includes data aspect control aspect data aspect describes type state host data invocation untrusted code control aspect safety preconditions postconditions calling host functions methods safety preconditions postconditions form placeholder abstract locations typestate size placeholder abstract location safety precondition represent obligations actual parameter provide placeholder abstract locations postconditions typestates locations execution function verifying safety call host function method involves binding process matches actual parameters placeholder abstract locations safety preconditions update process computes memory state invocation call based safety postconditions detailed description summarize calls trusted functions section invocation specification binding information resources host registers memory locations represent parameters untrusted code host-typestate specification invocation specification access policy provide information initial memory state entry untrusted code thesis page tuesday december phases safety-checking analysis starting initial memory state analysis abstractly interpret untrusted code find safe approximation memory state program point approximations memory states abstract storage model analysis finds memory state program point description state instruction operates default safety conditions access policy attach safety predicate instruction check instruction obeys safety predicate safety-checking analysis consists phases preparation typestatepropagation annotation local verification global verification illustrate phases informally means simple figure shows piece untrusted code sparc assembly language sums elements untrusted code mov clr cmp bge goto clr sll cmp goto add retl nop figure simple summing elements integer array thesis page tuesday december integer array running entire thesis figure shows host-typestate specification access policy invocation specification figure host-typestate specification states base address integer array size single abstract location summarize elements array safety policy states region integers region readable operable base addresses integer array size region readable operable followable invocation specification states size passed registers code additional registers note annotation positive integer invocation untrusted code test lines figure redundant technique based annotating initial inputs untrusted host typestate access policy invocation int initialized int rfo int int rfo integer array size abstract location summarizes elements apandeare region integers region readable operable base addresses integer array size region readable operable followable size passed registers figure host-typestate specification invocation specification access policy thesis page tuesday december code makes assumption optimization untrusted code preparation preparation phase takes host-typestate specification access policy invocation specification translates initial annotations consist linear constraints typestates inputs initial annotation initial abstract store entry untrusted code preparation phase constructs interprocedural control graph untrusted code figure initial annotations shown figure fact address passed register line column register stores base address integer array points fact size passed register captured linear constraint note access permissions refer registers untrusted code permitted read change registers array overwritten initial typestate initial constraints int initialized int rwfo int initialized rwo figure initial annotations convenience listed access permissions abstract location permissions stored location thesis page tuesday december access permission acts surrogate elements permission note machine code register store values types program points model register memory location untrusted code stack writable typestate propagation typestate-propagation phase takes interprocedural control flow graph untrusted code initial annotations inputs abstractly interprets untrusted code annotate instruction abstract representation memory contents abstract storage model abstract representation memory characterizes memory state execution instruction phase discovers instruction line array access holding base address array representing index instruction line loads integer stores register figure summarizes memory state typestates abstract locations execution load instruction line chapter elaborate typestate-checking system phase analysis annotation annotation phase takes input typestate information discovered phase traverses untrusted code annotate instruction safety preconditions assertions safety preconditions divided thesis page tuesday december local safety preconditions global safety preconditions local safety preconditions conditions checked typestate information global safety preconditions verified analysis global safety preconditions include array bounds checks address alignment checks null pointer dereference checks assertions facts derived results typestate propagation assertions local safety preconditions global safety preconditions instruction line summarized figure stores base address integer array word aligned non-null instruction loads contents stores register local safety preconditions state location abstract store int initialized int initialized rwo int rwfo int initialized rwo int initialized rwo figure memory state line assertions local safety preconditions global safety preconditions address integer array mod null readable initialized writable followable operable array bounds checks mod alignment null-pointer checks mod null figure assertions safety preconditions line thesis page tuesday december readable initialized writable followable operable global safety conditions verify array index array bounds address calculated properly aligned non-null local verification local-verificationphase checks local safety preconditions performs linear scan instructions untrusted code finds local safety preconditions true line describe annotation phase local-verification phase analysis detail chapter global verification verify global safety preconditions program-verification techniques presence loops inductioniteration method synthesize loop invariants make global-verification phase efficient phase incorporates symbolic range analysis propagates range information registers analysis avoid expensive program-verification techniques range analysis sufficient verify array access bounds symbolic range analysis find line lower bound upper bound analysis verifies array out-of-bounds violations line thesis page tuesday december range analysis induction-iteration method synthesize loop invariant loop lines case prove line index array upper bound prove line note size integer bytes line computed line sll instruction induction-iteration method automatically synthesize loop invariant invariant implies 
holds line turn implies holds line chapter describe global-verification phase analysis detail thesis page tuesday december chapter typestate checking describe phase safety-checking analysis phase abstractly interprets untrusted code produce safe approximation memory state program point safe approximation memory state abstract storage model model represents memory state total map abstract locations typestates abstract location summarizes physical locations typestate describes properties values stored abstract location chapter organized parts part describe basic typestate system includes abstract storage model abstract operational semantics sparc machine-language instructions typestatechecking algorithm propagates typestate information typestate system incorporates subtyping relationship structures pointers analysis check safety untrusted machine code implements inheritance polymorphism physical subtyping thesis page tuesday december part describe techniques strengthen basic typestate-checking analysis techniques include summarize function calls method detect stack-allocated arrays summarizing function calls analysis stop trusted boundaries typestate system safety-checking analysis based abstract storage model abstract storage model includes notion abstract store linear constraints describe linear constraints detail section abstract store total map abstract locations typestates design domain abstract stores finite domain contrast concrete stores form infinite domain general number concrete activation records unbounded presence recursion number concrete objects allocated loop size concrete linked data-structures abstract location summarizes set physical locations abstract location size offset alignment optional attributes location readable writable untrusted code absloc denote set abstract locations symbols denote individual abstract locations size align denote size alignment abstract location call abstraction location summarizes physical location summary location register readable writable alignment thesis page tuesday december typestate records properties values stored abstract location typestate defined triple type state access define meet operation typestates typestates form meet semi-lattice meet typestates defined meet respective components describe type state access component typestate system sections type machine-language program register memory location store values types program points typestate-checking algorithm typestate-propagation phase flow-sensitive analysis determines typestate abstract location program point finding greatest fixed point set typestate-propagation equations typestate system incorporates notion subtyping structures pointers approach register memory location occurrence instruction resolved polymorphic type supertype acceptable values type expressions type component type system based physical type system siff figure shows language type expressions typestate system compared type system siff typestate system additionally includes bit-level representations integer types top bottom types parameterized size parameter iii pointer thesis page tuesday december middle array alignment size constraints types shown figure type int represents signed integer bits highest bits middle bits represent sign result sign extension lowest bits represent -bit signed integer represented int -bit signed integer char -bit sign extension represented int type uint represents unsigned integer middle bits zeros bit-level representation integers express effect instructions load store partial words code fragment sparc machine language copies character pointed register location pointed register ground ground types pointer base array type size pointer middle array type size ptr pointer struct union function top type bits bottom type bits type bits member labeled type offset ground int uint figure simple language type expressions stands type stands structure union member language chosen express type system bit assume untrusted code necessarily written thesis page tuesday december ldub stb points signed character c-like type system typestate checking lose precision checking code fragment loss precision instruction ldub loads register byte memory zero-fills highest bits type system treats unsigned integer contrast bit-level integer types figure assign type int execution load instruction preserves fact lowest bits store signed character int type denotes pointer points middle array type size introducing pointers middle array analysis handle array pointers precision program reads elements array advancing pointer initially points base address array iteration loop static type pointer inside loop pointer middle array preserves fact pointer points element array contrast type system conclude pointer pointer element type array type system forbid pointer arithmetic advances pointer point element array thesis page tuesday december subtyping relation introduce notion subtyping type expressions adopted physical-subtyping system chandra reps takes account layout aggregate fields memory figure lists rules define type physical subtype denoted note subtype ordering conventional typestate checking ordering flipped type lattice iff figure rules top bottom ground pointer array additions physical-subtyping system integer type subtype type range represented subrange range represented sign-extension bits rule member states structure subtype type type member structure subtype consequence rule valid figure inference rules define subtyping relation structures top sizeof bottom sizeof ground int int member members reflexivity array pointer ptr ptr uint uint uint int thesis page tuesday december program pass structure place supertype member expected rules structures members state structure subtype prefix member supertype member rule members constraints members structures rule pointer states subtype ptr subtype ptr rule array states pointer base array subtype pointer middle array array types element type physical subtype rule array crude states meet array types sizes return array size typestate-checking analysis lose precision checking programs outline solution problem section make notion subtyping safety-checking analysis section assignment legal type right-hand-side expression physical subtype type receiving location receiving location space rule array valid describes larger set states global-verification phase analysis check array bounds struct point int int struct colorpoint int int uint color void point y-figure subtyping pointer types thesis page tuesday december allowing subtyping integer types structures pointers typestate-checking analysis handle code implements inheritance polymorphism physical subtyping function accepts -bit integer legal invoke function actual parameter signed character int provided actual parameter stored register memory instruction handles sign extension properly case actual parameter physical subtype formal parameter figure shows involves subtyping structures pointers subtyping inference rules structures pointers type colorpointptr subtype pointptr function polymorphic legal pass actual parameter type colorpointptr function typestate checking subtyping readers familiar problems encountered subtyping presence mutable pointers suspicious rule pointer fact rule pointer unsound traditional flow-insensitive type systems absence alias information flow-insensitive analysis account aliasing unable determine indirect modifications shared data structure indirect modifications disastrous effects figure concrete statement line clrptr point object type point indirectly variable clrptr longer fulfill obligation supply color thesis page tuesday december field line figure shows contents store statement function static technique handle problem detect disastrous indirect modifications happen approaches problem found literature linear type system avoids aliases altogether indirect modifications consumtypedef point pointptr typedef colorpoint colorpointptr colorpoint clr point void void 
pointptr bwptr colorpointptr clrptr clr colorpointptr clrptr pointptr bwptr clrptrcolor figure rule pointer unsound flow-insensitive type checking absence aliasing information assume type declarations shown figure figure contents store statement function figure bwptr clrptr clr clrptr clr clrptr clr clrptr bwptr bwptr bwptr bwptr clr thesis page tuesday december ing pointer smith singleton types track pointers alias constraints model shape store goal tracks non-aliasing facilitate memory reuse safe deallocation objects approach involves introducing notions immutable fields objects idea subtype type type ptr subtype ptr field subtype field immutable field pointer object field points immutable rule applies transitively approach work correctly mechanism needed enforce immutability restrictions work represents fourth technique system performs typestate checking flow-sensitive analysis tracks aliasing relationships abstract locations state descriptors resemble storage-shape graphs chase similar diagrams shown figure describe state component typestate system section inspecting storage-shape graphs program points access heap-allocated storage safely detect illegal field access occur instance shape graph arises statement figure determine access color statement represents memory-access error programs accesses rejected safety checker state state component typestate captures notion object type state operations thesis page tuesday december state lattice bottom element denoted represents undefined type figure illustrates selected elements state lattice scalar type state denote uninitialized initialized values pointer type state state uninitialized pointer non-empty set abstract locations referenced elements null sets define iff aggregate type state states fields state descriptors track abstract locations represent pieces stackand heap-allocated storage resemble storageshape graphs chase figure portion state lattice null null scalars pointers aggregates thesis page tuesday december access permissions access permission subset tuple access permissions abstract location stores aggregate access permission tuple access permissions elements tuple denoting access permissions respective aggregate fields meet access-permission sets intersection meet tuples access permissions meet respective elements reader puzzled access policy defined terms kinds access permissions typestates kinds reason properties properties location typestates capture properties values access policies permissions abstract locations permissions values model constant access permission abstract operational semantics sparc instructions abstract store total map absloc typestate define abstract operational semantics sparc machine instruction transition function denote type state access component typestate abstract location machine-code operations overloaded typestate lattice includes top element typestate-propagation algorithm perform overload resolution on-the-fly section thesis page tuesday december overload resolution determine typestate abstract location program point finding greatest fixed point set typestate-propagation equations section overload resolution instructions add falls by-product process type components typestates obtained arguments overloaded instructions identify register holds scalar pointer base address array instruction add represents addition scalars pointer indirection array-index calculation achieve define abstract operational semantics sparc machine instructions strict typestate checking propagation information instructions loop delayed non-t arrives loop entrance artifact method occurrence overloaded instruction resolved single usage kind scalar addition pointer indirection array-index calculation call single-usage restriction restriction represent significant limitation practice performing typestate checking flow sensitive typestate checking instruction add resolved pointer indirection occurrence instruction array-index calculation occurrence remainder section assume non-t values disposal thesis page tuesday december propagation type state access information sake brevity figure shows rules propagating type state access information kinds add instruction scalar add array-index calculation storing aggregate field registers opnd integer constant register denote absloc denote types abstract location execution instruction define similarly refer possibly empty sequence field names function lookup takes type integers operation add opnd assumption scalar add array-index calculationt store aggregate field lookup type-propagation rule opnd summary location statepropagation rule opnd summary location accesspropagation rule opnd summary location figure propagation type state access information thesis page tuesday december input returns set fields offset size fields exist typestate-propagation rules scalar-add state execution add instruction typestate meet opnd execution typestate abstract locations absloc remain unchanged array-index calculation type destination register type array element type point element array state-propagation rule present single abstract location summarize entire array state destination register source register typestate-propagation rules storing aggregate field divided cases depending strong weak update abstract-location set represents set concrete locations instruction store pointer point unique concrete location summary location case receives typestate source register pointer point concrete locations summary location case destination receives meet typestate operation typestate source register typestate checking typestate-propagation algorithm works interprocedural control-flow graph nodes graph represent instructions edges represent control-flow usual fashion instruction node control-flow graph associate total maps pretypestate absloc typestate posttypestate absloc typestate thesis page tuesday december maps safely approximate program states instruction respective program point define meet total maps map constructed performing meet respective elements absloc typestate defined absloc facilitate presentation define notation initialstore map abstract locations typestates abstract locations entry untrusted code initial store computed phase cfgedge set control-flow edges instruction set instructions untrusted code startnode instruction entry point foreign code incoming outgoing instruction cfgedge cfgedge denotes power set cfgedge mapping functions give control-flow edges link instruction control-flow predecessors successors interpret instruction interpret abstract operational semantics instruction section algorithm standard worklist-based algorithm starts map program points abstract locations typestate algorithm typestate propagation shown figure initially start node untrusted code worklist instruction chosen worklist examined start node pretypestate initialstore typestates abstract locations entry examined instruction meet typestates exits instruction predecessors instruction interpreted abstractly thesis page tuesday december typestates abstract store exit instruction change case instruction successor examined instruction added worklist process repeated worklist empty figure shows results typestate propagation applied running column shows instructions left column shows abstract store execution instruction typestate propagation worklist startnode worklist empty select remove instruction worklist startnode initialstore foreach controlow edge incoming posttypestate pretypestate oldposttypestate posttypestate posttypestate interpret pretypestate posttypestate oldposttypestate foreach controlow edge outgoing worklist worklist figure propagation typestate nodes control-flow graph represent control-flow edge edge node represents source edge node represents target edge thesis page tuesday december lines correspond loop initially holds base address integer array elements summarized holds size array typestate checking initiated placing mov instruction line worklist abstract interpretation mov instruction line sets contents point typestate changed instruction line worklist interpretation clr instruction line sets contents process continues worklist empty line results show holds base address integer array integer index typestate untrusted code mov clr cmp bge clr sll cmp add retl nop figure results typestate propagation int rwfoe iint iint rwo iint iint rwo int rwfo int 
rwfo iint iint rwo rwo int rwfo iint iint rwo rwo int rwfo iint iint rwo rwo int rwfo iint iint rwo iint rwo iint rwo int rwfo iint iint rwo iint rwo iint rwo int rwfo iint rwo iint iint rwo iint rwo iint rwo iint rwo int rwfo iint iint rwo iint rwo iint rwo iint rwo int rwfo iint iint rwo iint rwo iint rwo iint rwo int rwfo iint iint rwo iint rwo iint rwo iint rwo int rwfo iint iint rwo iint rwo iint rwo int rwfo iint rwo iint iint rwo iint rwo iint rwo iint rwo int rwfo thesis page tuesday december sections describe techniques strengthen typestate-checking analysis techniques include technique summarize calls trusted functions technique determine types sizes stackallocated arrays summarizing calls summarizing function calls safety-checking analysis stop boundaries trusted code tracing body trusted callee analysis check call obeys safety precondition postcondition rest analysis describe method summarizing trusted calls safety preand post-conditions terms abstract locations typestates linear constraints safety preconditions describe obligations actual parameters meet postconditions provide guarantee resulting state produce safety preand post-conditions hand process error-prone desirable automate generation function summaries recent work interprocedural pointer analysis shown pointer analysis performed modular fashion techniques analyze function assuming unknown initial values parameters globals function entry point obtain summary function dataflow effect function follow-on work thesis investigate techniques create safety preand postconditions automatically thesis page tuesday december represent obligation provided actual parameter placeholder abstract location placeholder short size access permissions typestate provide detailed requirements actual parameter satisfy formal parameter pointer state descriptor include placeholders represent obligations provided locations pointed actual parameter model state descriptor pointer-typed placeholder refer null placeholder placeholder null refers null actual parameter point null refers placeholder locations pointed actual parameter satisfy obligation denoted placeholder state descriptor refers null placeholder actual parameter point null locations satisfy obligation represent obligations list pre-conditions form placeholder typestate safety postconditions provide safety-checking analysis compute resulting state call summarized function represented list postconditions form alias context placeholder typestate alias context set potential aliases potential non-aliases neq placeholders alias contexts capture aliasing actual parameters affect resulting state safety preand post-conditions include linear constraints safety preconditions represent additional safety requirethesis page tuesday december ments postconditions provide additional information resulting memory state call make idea concrete figure shows summarizes library function gettimeofday specifies call safe null address writable location size sufficient storing type struct timeval safety postconditions execution call fields location pointed call initialized initialized integer note points null execution call placeholder irrelevant bound actual abstract location perform binding process section sparc parameters function passed registers return function stored register int gettimeofday struct timeval safety precondition struct timeval ptr null struct timeval safety postcondition struct timeval int int int figure safety preand postconditions typestate aggregate typestates components enclosed component labeled offset bits closest enclosing aggregate thesis page tuesday december figure alias contexts empty ambiguity aliasing alias contexts summarize function calls precision opposed make fixed assumptions aliasing figure shows alias contexts provide precision function returns null object pointed parameter depending aliases checking call trusted function involves binding process update process binding process matches placeholders actual abstract locations checks meet obligation update process updates typestates actual locations represented placeholders safety postconditions pointptr pointptr pointptr null return safety precondition pointptr ptr pointptr ptr pointptr safety postcondition neq pointptr pointptr null figure safety preand post-conditions alias contexts thesis page tuesday december goal summarize library functions generally complicated things pointers present focused obligations represented tree placeholders obligations represented fall back letting typestate-propagation phase trace body function binding process carried simple algorithm binding algorithm iterates formal parameters obtains respective actual parameters typestate descriptors call site traverses obligation tree checks actual parameter meets obligation establishes mapping placeholders set abstract locations represent store callsite binding process distinguishes information information intuitively placeholder represent location binding algorithm establish represent unique concrete location algorithm updating process interprets postcondition distinguishes strong update weak update depending placeholder represent unique location represent multiple locations alias context evaluates true false strong update placeholder represents unique location alias context evaluates true weak update placeholder represent multiple locations alias contexts determined true false case typestate location receives meet typestate call typestate postcondition alias context thesis page tuesday december determined true false update postcondition place make safe assumption performing weak update detecting local arrays determining type bounds information arrays reside stack difficult describe method inferring subrange stack frame holds array illustrate method simple figure shows program updates local array column shows sparc machine code produced compiling program gcc version infer local array present examine live pointers time typestate-propagation algorithm reaches entry loop discussion abstract location denotes stack frame allocated add instruction line denotes point offset denotes subrange starts offset ends offset abstractly interpreting add instructions lines find points points time typestatechecking algorithm visits loop entry point column figure abstractly interpreting instructions line line reveals stores integer time typestate-checking algorithm visits loop entry points candidate local array reasoning runs thesis page tuesday december create fictitious components shown right-most column figure point component instruction polymorphic usage program point pointer pointer compatible types choice compatible type system pointer array letting denote type array element compute general type steps compute size compute greatest common divisor gcd sizes slots delimited pointer consideration slot size size compute limits array assume array ends location closest live pointer stack pointer consideration global-verification phase verify local array inferred bounds program sparc machine language time time typedef struct int int int main int main add add mov add cmp bgeu mov add cmp blu add retl figure inferring type size local array label represents entry loop int thesis page tuesday december compute type assuming size computed create fictitious location size give initial type slide area identified step bytes time bytes time perform meet operation covered area covered sub-area type assume type find struct int refinement needed general make refinements findings iterations typestate-checking algorithm refinement bring element type array type lattice address consideration register general form registers integer method heuristics compute bounds array affect soundness approach reasons typestate-propagation algorithm make program type correct ensure element type inferred consistent rest 
program global-verification phase verify inferred local array inferred bounds note matter analysis original program written terms n-dimensional array terms -dimensional array analysis treats arrays -dimensional arrays approach works thesis page tuesday december original code written terms n-dimensional array layout scheme compilers n-dimensional array involves linear indexing scheme reflected linear relationships analysis infers values registers related work compare typestate-checking analysis mycroft technique recovers type information binary code mycroft technique reverse engineers programs target machine code type-inference techniques type-reconstruction algorithm based milner algorithm associates type constraints instruction static single-assignment ssa representation program type reconstruction unification mycroft technique infers recursive data-types loops recursive procedures start annotations initial inputs untrusted code technique requires annotation abstract interpretation unification note technique detect local arrays based principle unification technique mycroft technique recovers types registers memory locations technique handle stackand heapallocated objects technique recovers type information propagates type state access information analysis flow-sensitive mycroft flow-insensitive recovers degree thesis page tuesday december flow sensitivity ssa form variables live ranges thesis page tuesday december chapter annotation local verification annotation phase safety-checking analysis annotates instruction piece untrusted code safety preconditions assertions safety preconditions assert instruction obeys safety properties enforce assertions facts assist validation safety preconditions local-verification phase verifies safety preconditions validated results typestate propagation describe annotation local-verification phases illustrate means running annotation annotation phase consists steps step attaches collection safety predicates usage instruction step annotates instruction untrusted code safety preconditions assertions linear scan untrusted code thesis page tuesday december attachment safety predicates instruction scalar add add arrayindex calculation annotation phase attaches collection safety predicates safety predicates assert instruction abides default safety conditions host-specified access policy safety predicates divided local safety predicates global safety predicates depending predicates validated typestate information illustrate local global safety predicates attached usage instruction figure summarizes safety predicates cases add scalar add array-index calculation case stores aggregate field case loads array operation assumptions local safety predicates global safety predicates add opnd scalar add operable operable opnd add opnd array-index calculationt operable operable opnd null inbounds sizeof opnd store aggregate field lookup followable operable forall assignable null forall align align sizeof opnd load array opnd int followable operable operable opnd readable operable assignable align inbounds sizeof opnd sizeof figure attachment safety properties registers readable writable default thesis page tuesday december scalar add safety predicate specifies uninitialized values predicate readable true iff readable predicate operable true iff predicate readable explicitly figure registers readable writable default safety predicates array-index calculation state opnd readable operable index bounds array predicate inbounds size low high true iff low size high size align size predicate align true iff safety predicates state followable valid index field size non-null address properly aligned predicate followable true iff pointer type predicate assignable true iff readable writable align align align sizeof size hold instruction loads array local safety predicates instruction state base address array followable operable operand array index operable integer type iii abstract location surrogate elements array readable operable predicate assignable true global safety predicate ensures loading address properly aligned array index bounds array generating safety preconditions assertions safety predicates annotation phase performs linear scan machine instructions untrusted code generates safety prethesis page tuesday december conditions instantiating safety predicates figure actual operands instructions instantiated safety predicates called local global safety preconditions depending precondition instantiated local global safety predicate safety preconditions annotation phase attaches assertions instruction assist verification phases assertions facts derived results typestate propagation machine code type means set values set valid operations defined values includes physical properties size alignment constraints typestate-propagation algorithm establishes location stores valid address type address alignment property assertions means give verifier access information local verification verification local safety preconditions purely local process phase generates error message violation local safety preconditions illustrate annotation local-verification phases applied running sums integer array results annotation phase shown figure thesis page tuesday december assertions shown column figure entry untrusted code register stores base address integer array non-zero word-aligned similarly typestate analysis revealed stores base address array program points annotation phase generate assertions points untrusted code assertions safety preconditions local global mov operable clr operable cmp operable operable bge clr sll operable followable operable operable operable readable operable cmp operable operable add operable operable retl nop figure safety preconditions produced annotation phase thesis page tuesday december columns figure show local global safety preconditions generated instruction untrusted code load instruction program point typestate information point register base address integer array integer array index load instruction loads arbitrary element array stores local safety preconditions state readable stored followable operable abstract location surrogate elements array readable operable global safety conditions program point state address calculated -byte aligned stored index greater equal upper bound array upper bound size array element global safety precondition states array index -byte aligned local-verification phase local process generates error message violation local safety preconditions running verify local safety preconditions true thesis page tuesday december chapter global verification global-verification phase safety-checking analysis verifies global safety preconditions check array out-of-bounds violations address misalignment violations null-pointer dereference violations global safety preconditions represented linear constraints verify global safety preconditions advantage synergy efficient range analysis expensive powerful program-verification technique applied demand range analysis determines safe estimates range values register program point determining accesses arrays bounds apply program-verification technique safety preconditions proven results range analysis rest chapter starts introduction program verification description linear constraints represent global safety preconditions technique synthesize loop invariants thesis page tuesday december symbolic range analysis perform array bounds checks key automated program verification system synthesize loop invariants describe induction-iteration method synthesizing loop invariants extensions induction-iteration method program verification floyd set cornerstone program verification idea attaching assertions statements describe behavior technique called inductive assertion method approach models program flowchart control-flow graph nodes represent program statements edges represent control flow logical assertions attached controlflow edges program correct respect assertions shown assertions true control passes edges hoare refined approach developing concise notation represent effect program construct terms logical precondition postcondition developed set axioms inference rules reasoning preand post-conditions traditionally program verification focused proving program conforms logical specification giving precondition true program inputs program entry point verifying postcondition true exit attach assertions edges program flowchart 
show assertions true control passes edges thesis page tuesday december postcondition true paths program entry program exit programs acyclic flowcharts attachment checking assertions generating verification conditions vcs verifying vcs theorem prover generation forward backward backward approach statement postcondition verified generation finds weakest precondition precondition true statement terminates postcondition true forward approach generation finds strongest postcondition program construct precondition major difficulty automated program verification system synthesize loop invariants presence loops program loops generation process terminate due cycles program control-flow graph cope problem program partitioned loop entry points loop invariant synthesized loop loop invariant assertion assertion true loop entry implies true loop entered iteration verifying correctness program loop involves proving loop invariant implies postconditions proved loop invariant true entry loop iii loop invariant reestablished subsequent iteration proving program program conforms specification general logic difficult achieve mechanically global-verification thesis page tuesday december phase analysis focuses small set conditions prevent program performing out-of-bounds array misaligned loads stores null pointer dereferences sections describe linear constraints expressing global safety conditions theorem prover induction-iteration method introduced suzuki ishihata synthesizing loop invariants unlike standard techniques program verification monolithic created properties prove induction-iteration method checks validity global safety preconditions demand-driven fashion verifies conditions time linear constraints theorem prover array-bounds null-pointer address-alignment requirements represented linear equalities inequalities theorem prover based omega library omega library represents relations sets presburger formulas formulas constructed combining affine constraints integer variables logical operations quantifiers affine constraints equality inequality constraints presburger formulas decidable give examples linear constraints index index length pointer pointer address thesis page tuesday december constraint expresses array index bounds array size length constraint expresses pointer null constraint expresses address -byte aligned omega library fourier-motzkin method determine presburger formula tautology satisfiable basic operation omega library projection set linear equalities inequalities set variables projecting constraints variables produces set constraints variables integer solution original problem omega library determines set constraints integer solutions projection eliminate variables constraints involve single variable point easy check integer solution projecting set constraints generates pugh wannacott propositions represented conjunction linear equalities inequalities omega test check tautology satisfiable tautology checking tautology trivial details omega library kelly pugh induction-iteration method untrusted code loops synthesize loop invariants system synthesis loop invariants attempted means thesis page tuesday december induction-iteration method present basic algorithm section describe extensions induction-iteration method chapter induction-iteration method weakestliberal precondition wlp heuristic generating loop invariants weakest liberal precondition statement respect postcondition denoted wlp condition statement executed state satisfying true termination terminates condition weaker satisfies weakest liberal precondition differs weakest precondition weakest liberal precondition guarantee termination technique works machine language programs extended induction-iteration method work reducible control-flow graphs description assume control-flow graph partitioned code regions cyclic natural loops acyclic control-flow graph reducible iff partitioned disjoint sets forward edge set back edge set forms dag node reached entry node edge target edge dominates source backedge control-flow graph nodes natural loop subgraph consisting set nodes nodes reached graph passing edge set connecting nodes set implementation merge natural loops share entry node reduce number loops global-verification phase analyze thesis page tuesday december restriction reducible control-flow graphs represent significant limitation practice study cited muchnick showed selection real-world fortran programs reducible control-flow graphs addition irreducible control-flow graph transformed reducible technique called node splitting method generating wlps non-conditional instructions generating weakest preconditions figure lists wlps respect postcondition sample sparc instructions figure registers icc integer condition code opnd integer constant register operations integer addition subtraction multiplication denotes occurrences replaced expression reminder chapter addr denote stored memory location address addr simplify matters instruction type weakest liberal precondition comments mov opnd opnd move add opnd opnd integer add sll opnd opnd logical left shift cmp opnd icc opnd comparison opnd opnd load label branch figure weakest liberal preconditions sample sparc instructions respect postcondition thesis page tuesday december omit sizes memory locations opnd represents stored address opnd weakest liberal precondition respect load instruction opnd occurrences replaced opnd show compute weakest liberal precondition store instruction section compute wlp natural loop define wlp generated back-substituting postcondition proved entry loop reached wlp loop-body define wlp loop-body wlp loop formula show compute weakest liberal precondition condition repect acyclic code region section denote induction-iteration method attempts find true entry loop loop invariant implies wlp loop-body suzuki ishihata show established showing true entry loop inv inv argument runs assumption implies implies observe equivalent wlp loop-body wlp loop-body wlp loop-body wlp loop-body thesis page tuesday december induction iteration method essence iterates steps create expression current candidate loop invariant generate vcs inv inv attempt verify vcs theorem prover figure shows basic induction-iteration algorithm suzuki ishihata rewritten pseudo code algorithm perform max number iterations induction steps discussed section found practice situation sufficient set max number iterations reader puzzled algorithm tests inv tests inv test inv matches test induction iteration success failure create formula max number iterations case theorem prover inv true return success case theorem prover wlp inv true wlp loop-body return failure return failure figure basic induction-iteration algorithm thesis page tuesday december inv performed previous iteration case inv holds vacuously true enhancements induction-iteration method made enhancements basic induction-iteration algorithm handle sparc instruction set store instructions nested loops procedure calls make global verification phase precise efficient handling sparc machine language section discuss extensions needed handle sparc instruction set including delay slots annulled instructions condition codes handle delay-slot instructions possibly annulled construct control-flow graph instruction delay slot basic block basic block basic block branch instruction instruction precedes branch target instruction precedes delay-slot instruction annul bit set respective delay-slot basic block included path basic block delayed instruction replicated included fall paths figure handle condition codes model sparc condition code variable icc holds result arithmetic operation thesis page tuesday december instruction cmprs opnd icc hold rs-opnd label exit edges conditions edges form icc relop relop relational operator including illustrate code fragment annulled branch cmp ble target add line number instruction represent instruction sequence numbers represent path figure illustrates compute wlp condition program point respect path model effect cmp instruction icc label edge represents fall branch condition icc wlp icc wlp icc compute wlp acyclic code region standard technique verification-condition generation figure illustrates condition branch direction enclosed 
figure branch delay slot instruction delay slot branch target fall icc icc branch annul bit set instruction delay slot branch target fall icc icc branch annul bit set instruction delay slot thesis page tuesday december curly brackets back-substitution control-flow merge point multiple outgoing edges conjunction conditions outgoing edge junction node computed performing back substitution junction node figure handling sparc condition code figure weakest liberal precondition acyclic code region wlp icc wlp weakest liberal precondition icc icc ble target control-flow graph add wlp wlp wlp wlp wlp wlp wlp wlp wlp wlp wlp branch code region control-flow edge wlp wlp wlp wlp thesis page tuesday december handling store instructions compute wlp store instructions based morris general axiom assignment general framework computing weakest precondition assignments pointer-typed variables describe morris general axiom assignment define weakest liberal precondition store instructions denote addresses denote pointer dereference ste denote storing result produced evaluating expression memory location address omit sizes memory locations assume side-effects define definition denote arbitrary postcondition axiom computing wlp store instruction wlp ste stands occurrences replaced words weakest liberal precondition assignment alias replaced difficulty analyzing machine-language programs determining addresses determined cases back-substitution code fragment load store instructions mov thesis page tuesday december mov verify postcondition program point show result back-substituting formula instructions code fragment line number instruction represent instruction wlp wlp wlp wlp true note destination address store instruction line source address load instruction line determined back-substitute formula mov instruction line multiple store instructions instruction sequence complicates situation determine dependences instructions point disambiguate addresses store instruction affect load instruction thesis page tuesday december killed store instruction load instruction morris axiom concurrent assignment handles situation list store instructions ste executed sequentially denote list addresses denote list expressions arbitrary address define definition pnthen enelse arbitrary postcondition axiom computing wlp list store instruction wlp ste stands occurrence replaced handling multiple loops basic induction-iteration algorithm assumes single loop program apply induction-iteration method programs multiple loops extensions needed simplify matters show extensions basic induction-iteration algorithm programs kinds thesis page tuesday december loop structures consecutive loops nested loops cases combinations cases figure illustrates steps prove postcondition program consecutive loops assume loops synthesize loop invariant loop implies induction step compute establish implied conjunction true entry loop establish true entry loop apply induction-iteration method recursively loop synthesize loop invariant loop generated loop verify true entry loop figure applying induction iteration method consecutive loops wlp inv inv implies program text control-flow graph test statement control-flow edge wlp thesis page tuesday december synthesize loop invariant inv loop inv imply condition figure illustrates steps needed prove postcondition program nested loops assume loops compute outer loop induction-iteration method synthesize loop invariant inv loop property inv wlp inv synthesized computed case formula wlp inv obtained true entry outer loop implies inv true entry loop prove explicitly inv true entry loop makes synthesizing inv local loop implementation extended induction-iteration algorithm employs backtracking strategy finding induction step overcome problem results weakening formula due irrelevant conditionals program apply strategy called generalization sectons backtracking synthesizing inv case computing wlp loop due synthesis loop invariant outer loop vely testing loop true entry loop process terminate record current trial invariant outer loop verify implies fails test true entry loop disregarding back edges paths entry program entry loop thesis page tuesday december treating part program entry entry loop acyclic weak tests provide means drive backtracking process synthesizing invariants loop affect soundness technique outer loop computed back-substituting respective invariant synthesized loop analysis verify outer loop true entry outer loop handling procedure calls procedure calls complicate induction-iteration method ways handling procedure call performing back-substitution reaching figure applying induction iteration method nested loops inv wlp wlp inv program text test statement control-flow edge control-flow graph begin end thesis page tuesday december procedure entry prove disprove condition iii recursion handle procedure calls back-substitution simply walk body callee inlined caller generate wlp callee function respect postcondition propagated callsite make generation efficient procedural calls tabulation procedure calls reuse previous results generation reach entry procedure check conditions true callsite conditions postconditions proven caller simplify matters present system detects rejects recursive programs principle induction-iteration method synthesize invariant entry conditions recursive functions loops strengthening formulae conditionals program weaken extent prevented loop invariant simple code fragment figure consecutive loops show fail prove index variable greater equal program point verify program point induction-iteration method produce loop subscript distinguish produced loop produced loop verify true entry loop synthesize loop invariant loop simplify things ignoring test program point produced loop thesis page tuesday december induction-iteration method fail synthesize loop invariant loop strengthened induction step induction iteration stronger address problem strengthen computing disjunctive normal form wlp loop-body disjuncts turn rank candidates simple heuristic comparing disjuncts original formula propagated program point figure conditionals program weaken extent prevented loop-invariant induction step induction step thesis page tuesday december conditionals test potential candidates breadth-first strategy shown figure easy verify disjunct loop invariant loop figure shows extended induction-iteration algorithm breathfirst search strategy algorithm worklist hold candidates item worklist components prev component formula tentative component prev backward link obtain respective represented formula function disjuncts returns set formulae disjuncts disjunctive normal form formula incorporating generalization breath-first strategy extended induction-iteration algorithm incorporates technique called generalization introduced suzuki ishihata generalization formula defined elimination elimination fourier-motzkin variable-elimination method eliminate variables set variables generate simplified set constraints integer solution resulting generalizations turn chosen generalized formula show generalization applied running section controlling sizes formulae conditionals program formula consideration grow exponentially size verification condition generation reduce thesis page tuesday december typedef struct node int presburger formula prev node ptr presburger formula max number iterations worklist list node ptr disjuncts presburger formula set presburger formua induction iteration success failure disjuncts wlp loop-body foreach worklist append node null worklist empty worklist prev prev k-case theorem prover inv true return success max number iterations theorem prover wlp inv disjuncts wlp loop-body foreach worklist append node switch return failure figure induction-iteration algorithm breath-first search thesis page tuesday december effect back-substitution code region performed backwards topological order respect program control-flow graph formula junction point simplified strategy effectively controls size formulas considered ultimately time spent theorem prover 
sharing common computations reduce number times induction-iteration algorithm performed back-substitute formulas proven reach loop entry partition formulae groups made comparable constituents invoke induction-iteration algorithm starting strongest formulas group verify stronger formula true implies formulae weaker formula true performing simple tests assuming acyclic code fragment program consecutive loops verify true entry loop synthesize loop invariants earlier loops conditions eventually part synthesized loop invariant waste effort conditions rejected reduce effect candidate expensive process verifying true entry loop perform simple test treats part program entry program entry loop acyclic performing simple test handle test case kernel device driver handle thesis page tuesday december illustrate induction-iteration method applied running introduced figure section control-flow graph program shown figure instructions lines replicated model semantics delayed branches single integer variable icc model sparc condition code label control-flow graph edge condition edge line number instruction denote instruction sequence line numbers square brackets represent path verify holds line perform back-substitution starting back-substituting condition line produces figure induction iteration sll cmp mov clr cmp bge clr add retl nop clr add icc icc icc icc thesis page tuesday december instruction line entry natural loop attempt synthesize loop invariant implies set tautology verify true entry loop create formula fact true entry loop shown back-substituting path create perform back-substitution loop body starting formula reach loop entry wlp wlp icc wlp icc wlp wlp formula tautology continuing creating strengthen generalization technique mentioned section steps generalize negating produces eliminating produces iii negating produces set generalized formula case tautology formula create round back-substitution thesis page tuesday december variables modified loop body implies means loop invariant synthesized line invariant implies holds line turn implies holds line scalability induction-iteration method potential improvements section address scalability verification phase discuss potential improvements enhanced induction-iteration method major cost verification phase performing induction-iteration method cost determined number iterations performed invariant identified cost iteration step induction-iteration method determined cost perform generation invoke theorem prover cost invoke theorem prover dominate costs ultimately determined characteristics untrusted code experience sufficient set maximum allowable number iterations loop intuition number iteration incorporate conditionals loop iteration test loop invariant information discovered iteration limit number induction steps loop assume loops program worst-case scenario thesis page tuesday december require induction steps verify safety condition program consecutive loops worst-case scenario verifying true entry loop requires synthesize loop invariant preceding loop situation preceding loop worst-case scenario happen program nested loops compute requires synthesis loop invariants loops practice worst-case scenario seldom happen variables loop initialized loop preceding loops verify true entry loop tests loops contribute proof condition outer loop enhancements previous section enhancements principle made existing prototype employ caching theorem prover represent formulas canonical form previous results perform tabulation function calls nodes multiple incoming edges reuse previous results generation efficient algorithms simple formulas people methods trade generality constraint system efficiency bodik describe method eliminate array-bounds checks java programs method restricted form linear constraints called difference constraints solved efficient graph-traversal algorithm demand wagner formulated buffer-overrun detection problem integer constraint problem solved linear time practice thesis page tuesday december finally profitable invariant-synthesis methods conjunction induction iteration chose induction-iteration method synthesize loop invariants works linear constraints totally mechanical conceivable techniques heuristic methods introduced katz manna wegbreit difference equations method introduced elspas abstract interpretation convex hulls cousot halbwachs cousot halbwachs method works forward program control-flow graph potential speed induction-iteration method pushing facts forward program control-flow graph preliminary investigation demonstrated substantial speedups induction-iteration method selectively pushing conditions involving array bounds forward program control-flow graph describe symbolic range analysis array-bounds checking section symbolic range analysis simpler method cousot halbwachs efficient range analysis induction-iteration method previous sections techniques cousot halbwachs powerful high cost describe simple range analysis determines safe estimates range values register program point information determining thesis page tuesday december accesses arrays bounds advantage synergy efficient range analysis expensive powerful induction-iteration method apply induction-iteration method global safety preconditions proven results range analysis range-analysis algorithm standard worklist-based forward dataflow algorithm finds symbolic range register program point analysis range denoted lower upper bounds form integer constants symbolic names serve placeholders base address length array reason restrict bounds form array-bounds checks involve checking range array index subrange lengthor range pointer points array subrange base base lengthwhere base length base address length array analysis symbolic names stand unknown values quantities base length ranges form meet semi-lattice respect meet operation ranges meet defined min max top element empty range bottom element largest range function min returns smaller comparable determine relative order instance min returns function thesis page tuesday december max defined similarly returns greater parameters parameters comparable give dataflow transfer function machine instruction define dataflow transfer functions strict respect top element introduce basic abstract operations describing dataflow transfer functions abstract operations summarized integer arithmetic operations bounds figure non-zero integers arithmetic operations ensure bounds form comparison instructions major source bounds information analysis works machine code tests forms operations figure binary operations symbolic expressions thesis page tuesday december program variables figure summarizes dataflow transfer functions forms assume ranges tests function min max defined upper bound range smaller lower bound range equivalent empty range dataflow functions variables false branch test improve precision slightly returning empty range equal ensure convergence range-analysis algorithm presence loops perform widening operation node loop dominates source loop backedge range arbitrary variable previous iteration dataflow current iteration resulting range widening operator defined test true branch max min max min false branch true branch min max false branch max min uwfigure dataflow functions tests min min comparable max max comparable thesis page tuesday december sharpen basic range analysis enhancements enhancement deals selecting suitable spot loop perform widening key observation do-while loop kind dominates binary code effective perform widening test exit loop case loop iterates array loop test length strategy minimizes imprecision crude widening operation range widened loop test immediately sharpened transfer function loop test range propagated loop backedge lengthconsequently analysis quiesces iterations enhancement utilize correlations register values test consideration establish program point constant incorporate information range analysis assuming branch tests n-c range analysis show range analysis applied running figure left column shows untrusted code sums elements integer array columns show results range analysis line loops 
common source code compilers typically transform do-while then-part transformation compiler exploit fact code body do-while executed loop executes perform code-motion fear slowing execution program compiler hoist expressions body loop point then-part loop guarded thesis page tuesday december shows range registers execution instruction line simplify presentation show range information propagated registers recall base address array passed register size array passed register size array passed range entry untrusted code instructions visited interpreting clr instruction line sets interpreting sll instruction line sets interpreting instruction line increments interpreting branch instruction line sets range path instructions visited time range set result performing meet range propagated untrusted code pass pass pass mov clr cmp bge clr sll cmp add retl nop figure symbolic range analysis applied running thesis page tuesday december edge range propagated edge interpreting instruction line sets range perform widening operation line brings range note interpreting branch instruction line path sets range pass range line result performing meet range propagated edge range propagated edge range set algorithm terminates fixed point reached knowing range implies bounds array induction-iteration method prove array accesses bounds section show range analysis speed global-verification phase test cases thesis page tuesday december chapter experimental evaluation present experimental evidence demonstrate technique enforce safe code execution feasible practical describe prototype implementation safety-checking analysis present initial experience prototype applied case studies prototype implementation techniques previous chapters exception technique infer sizes types local arrays section implemented prototype safety-checker sparc machine programs safety checker takes untrusted binary code form executable object files checks untrusted code obeys default safety conditions host-specified access policy reports reasons unsafe code safety violations safety checker implemented sparc machine language programs techniques embodied essentially language independent thesis page tuesday december alternative reimplementing language employ binary translation techniques achieve platform independence untrusted code written sparc machine language translate untrusted code semantically equivalent sparc code performing safety checking figure shows flow chart prototype implementation recapitulate phases safety-checking analysis mention details left previous chapters preparation phase produces initial annotation initial memory state entry untrusted code interprocedural control-flow graph produce interprocedural control-flow graph analysis identifies boundaries function symbol table information starting start function untrusted code dissembles instruction identifies basic blocks builds intraprocedural control-flow graphs functions reachable start function identifies targets call instructions build static call graph find targets calls registers simple intraprocedural constant propagation algorithm performed end interprocedural control-flow graph produced based intraprocedural control-flow graphs static call graph note interprocedural controlflow graph incomplete refined typestate-propagation phase typestate information interface-based programming addresses interface functions typically stored structure calling interface function typically involves load thesis page tuesday december figure prototype implementation sparc machine language extract functions untrusted code identify basic blocks build intraprocedural cfg identify natural loops build interprocedural cfg host typestate-specification invocation specification access policy combine interprocedural cfg initial annotation typestate propagation annotation local verification range analysis induction-iteration approximation memory program point local safety conditions global safety conditions facts preparation thesis page tuesday december structure call register holds loaded typestate loaded information callee typestate-propagation performed interprocedural control-flow graph initial annotation preparation phase identifies natural loops loop-nesting relationships information global-verification phase identify natural loops program implemented algorithm developed lengauer tarjan computing dominators algorithm nat loop algorithms muchnick book node control-flow graph dominator node control-flow paths reach node entry function node algorithm nat loop identifies natural loop back edge control-flow edge target node dominates source node reduce number natural loops global-verification phase analyze implementation merges natural loops back edges share target node important analysis treat nested loops expensive analyze typestate-propagation phase finds safe approximation memory state program point implementation replicates functions analysis achieve degree context sensitivity analysis finds parameter function pointing arrays sizes function replicated copy parameter points arrays size thesis page tuesday december untrusted code accesses structures multiple array-typed fields bounds information pointers index variables figure pointer points inside structure purpose run simple range analysis demand situation arises simple range analysis executed procedure implementation combined annotation phase local verification phase check local safety conditions annotated global-verification phase takes advantage synergy range analysis induction-iteration method represent results range analysis facts induction-iteration method case studies present initial experience system applied case studies test cases include array sum running previous chapters start-timer stop-timer code paradyn suite versions btree traversal version compares keys function call hash-table lookup kernel extension implements page-replacement policy bubble sort versions heap sort manually inlined version interprocedural version stack-smashing smith paper update message-digest algorithm functions jpvm device driver dev kerninst comprises modules dev kerninst symbol dev kerninst loggedwrites thesis page tuesday december stack-smashing program sample program demonstrates advantage vulnerability unix system intruder gains access system overrunning contents stack control subsequently transferred intruder code message-digest algorithm takes input message arbitrary length produces output -bit fingerprint messagedigest input intended digital-signature applications large file compressed secure manner encrypted private secret key public-key cryptosystem rsa jpvm java native interface pvm java platform java native interface jni native-programming interface java code runs inside java virtual machine interoperate applications libraries written programming languages assembler jpvm verify calls jni methods pvm library functions safe obey safety preconditions dev kerninst device driver installed solaris kernel kernel instrumentation tool kerninst modify running kernel on-the-fly module dev kerninst symbol api parsing kernel symbol table module dev kerninst loggedwrites recoverable modifications made instructions data run-time kernel experimental study check api function kerninst symtab dev kerninst symbol module api function loggedwrites performundoablealignedwrites dev kerninst loggedwrites module major functions modules examples written thesis page tuesday december dev kerninst compiled gcc version dev kerninst examples compiled sun workshop compiler figure characterizes examples terms number machine instructions number branches number loops total versus number loops number calls total versus number calls trusted functions number global safety conditions total versus number bounds checks source language test case written treat checking lower upper bounds separate safety conditions trusted function host function function trust check calls trusted function obey safety preconditions function experiments find safety violation implements page-replacement policy attempts dereference pointer null identified array out-of-bounds violations stacks ging olicy imer ash ubble imer tree tree eap eap pvm smashing pvm dev kerninst symbol dev kerninst logged rites instructions branches loops loops procedure calls trusted calls 
global conditions bounds checks source language figure characteristics examples performance results thesis page tuesday december smashing symbol table module dev kerninst figure summarizes time needed verify examples mhz sun ultra machine times divided times perform typestate propagation create annotations perform local verification perform range analysis perform program verification induction-iteration method time check examples ranges seconds performance results dev kerninst loggedwrites obtained based preliminary implementation features section section details features analysis handle meet array types sizes precision account correlations induction variables loop performing array bounds checks features analysis generate false warnings array out-of-bounds violations checks ging olicy imer ash ubble imer tree tree eap eap pvm smashing pvm dev kerninst symbol dev kerninst logged rites typestate propagation annotation range analysis inductioniteration total seconds figure performance results thesis page tuesday december ing dev kerninst loggedwrites dev kerninst loggedwrites takes longer time check test cases largely implementation features preliminary goal minimize made existing infrastructure implementation sufficiently complete full test abilities made note dev kerninst loggedwrites stack-smashing dev kerninst symbol longer times check examples array out-of-bounds violations exhaust breadth-first search induction-iteration method conclude array ofbound violation highlight benefits typestate system symbolic range analysis provide bit-level representations integers analysis deal instructions load store partial word update stack-smashing examples technique summarize trusted functions analysis summaries host library functions hash startand stop timer btree jpvm examples dev kerninst examples simply summarize library functions checking implies examples safe library functions safe principle check library code summaries subtyping structures pointers summaries jni methods polymorphic jni function jsize getarraylength jnienv env jarrayarray takes type jarray thesis page tuesday december parameter applicable types jintarray jobjectarray subtypes jarray java objects manipulated jni interface model types jintarray jobjectarray physical subtypes jarray summarizing jni interface functions symbolic range analysis system identify boundaries array field structure run intraprocedural version range analysis demand typestate-propagation algorithm information range register intraprocedural range analysis run function test cases array accesses range analysis eliminated total attempts synthesize loop invariants test cases eliminated synthesize loop invariants altogether resulting speedup global verification ranges median conjunction simple test treats part untrusted code acyclic code section range analysis verify dev kerninst symbol handle figure shows times performing program verification times performing range analysis normalized respect times performing global verification range analysis reason analysis stack-smashing speeded array accesses bounds array accesses bounds range analysis speed analysis analysis thesis page tuesday december apply program-verification technique conclude array out-of-bounds violations similarly reason hash slowed conditions array-bounds checking range analysis prove array accesses bounds note range analysis eliminated synthesize loop invariants array bounds checks cases reasons range analysis lost precision due widening inability range analysis algorithm recognize corfigure times perform global verification range analysis normalized respect times perform global verification range analysis sum hash bubble btree btree heap heap jpvm stackjpvm ratio time induction-iteration normalized time range analysis normalized smashing sort sort sort thesis page tuesday december relations registers implementation range analysis perform widening operation test exit loop precision nested loops widening operation loop information outer loop lose precision potential improvement range analysis perform widening variables invariants loop widening point potential improvement identify correlations loop induction variables include pass range analysis make correlations limitations initial success analysis limitations describe limitations outline solutions lost precision due array analysis lose precision due array recall single abstract location summarize elements array model pointer array base arbitrary array element pointer point summary location analysis loses precision determine assignment kills elements array analysis reported actual parameters host methods functions undefined jpvm examples fact defined dependence-analysis techniques parallelizing compilers address limitation thesis page tuesday december lost precision due type system typestate-checking system dissertation sophisticated handle test cases subtyping rule states meet array types sizes return array size rule analysis lose precision checking safety variable-length vector type dev kerninst loggedwrites vector type implemented template class shown template class class vector data int int tsz vector operator const data field vector array size field tsz field points slot vector operator adds additional element vector code implements operator simplified illustrated figure line type data meet tsz newtsz array line analysis generate false warning array bounds checks sketch enhancement typestate-propagation algorithm address limitation basic idea introduce node meet array types sizes propagate information node computed illustrate technique figure variables thesis page tuesday december type initially points base address program point time program points visited type time program point visited introduce node variable program point meet array types record depending edge arrive program point time program point visited introduce node variable record time program point visited update information computed process eventually converge array typed variable static program point introduce variable record information control-flow edges assist global-verification phase assignments bold face attached control-flow edges check condition program point vector operator const const unsigned newsz newsz tsz unsigned newtsz unsignedint bigger newsz newdata newtsz copy newdata data delete data data newdata tsz newtsz data return figure operator vector type thesis page tuesday december back-substitute condition edge similarly back-substitute condition edge perform global verification vector type field data array size tsz field equal field tsz invariant represented introducing symbolic names encoded range information shown data data array type size tsz tsz equals equals limitations induction-iteration method induction-iteration method powerful handle cases correlation loop tests calculation array index figure introducing propagating nodes pass pass thesis page tuesday december obvious happen compiler optimizations strength reduction optimizations address-calculations source code programming style show examples figure examples implementation vector class earlier key solving problem uncover correlations loop tests array-index calculations simple solution introduce basic induction variable represent induction variables linear expressions basic induction variable examples figure introduce basic induction variable transform examples programs shown figure show induction-iteration handle examples transformed prove condition ptr line program left-hand side figure ptr fact true entry loop shown back-substituting path ptr x-ptr int int figure examples induction-iteration method handle thesis page tuesday december show steps compute performing back-substitution loop body wlp ptr wlp n-i n-i true wlp true true true loop invariant synthesized ptr verifying program right-hand side figure slightly complicated prove condition line previous fact true entry loop shown back-substituting path tautology compute wlp wlp int ptr int n-i 
ptr n-i ptr int int int figure introducing basic induction variable examples shown figure thesis page tuesday december continuing compute strengthen carrying steps compute disjunctive normal form drop disjuncts involve non-basic induction variables iii perform generalization disjunctive normal form formula dropping disjunct involves non-basic induction variable performing generalization easy verify true entry loop modified body loop implied loop invariant synthesized loop invariant implies line standard techniques muchnick identify induction variables perform transformations address limitation induction-iteration method summary experience date make observations contrary initial intuition compiler optimizations loopinvariant code motion improved register-allocation algorithms make task safety checking easier memory-usage analysis part typestate checking lose precision instructions access memory registers job register allocation thesis page tuesday december precise typestate information recovered loop-invariant code motion makes induction iteration efficient making loops smaller simpler compiler optimizations strength reduction optimizations address-calculations complicate task global verification hide relationships induction-iteration method strategies make induction-iteration method effective conditions program pollute wlp loop-body compute disjunctive normal form wlp loop-body disjuncts turn rank potential candidates simple heuristic test candidate breadth-first strategy depth-first finally forward propagation information array bounds range analysis substantially reduce time spent induction-iteration method reduces time needed verify true entry eliminate generalization synthesize loop invariant implementation safety checker results range analysis assertions assist induction-iteration method verifying interprocedural version untrusted program time verifying manually inlined version manually inlined version replicates callee functions global conditions callee functions place analysis benefits procedure abstraction expensive verify programs array out-of-bounds violations programs safe exhaust thesis page tuesday december breath-first search induction-iteration method conclude array out-of-bounds violation work perform safety checking compiler information easy compiler retain hard analysis infer make analysis easier information include types sizes local arrays pointers array inside structure correlations loop induction variables hidden due compiler optimizations information correlations loop induction variables benefit range analysis inductioniteration method thesis page tuesday december chapter conclusions future work dissertation presented techniques statically checking safe piece untrusted foreign code loaded executed trusted host system techniques work ordinary machine code mechanically synthesize verify safety proof chapter examine limitations technique discuss future research directions limitations major limitation techniques enforce safety properties expressible typestates linear constraints excludes liveness properties safety properties array bounds checks array non-linear subscripting checks floating-point exceptions analysis flow-sensitive interprocedural analysis propagate typestate information verification phase fairly costly due synthesize loop invariants prove safety predicates scalability analysis remains evaluated bigger applications thesis page tuesday december static techniques technique incomplete analysis loses precision handling array single abstract location summarize elements array induction-iteration method incomplete linear constraints induction-iteration method prove correctness array accesses loop correctness depends data values set execution loop sentinel end array speed sequential search generalization capabilities system fall short problems care memory safety induction-iteration method fail cases loop invariant strengthened point end verifying large part partial correctness algorithm type system sophisticated handling cases type system dissertation meet array types element type numbers elements return array type size analysis lose precision checking kernel-device-driver finally analysis deal unconventional usages operations swapping non-integer values means exclusive operations thesis page tuesday december future research limitations method shows promise limitations represent potential research opportunities future research make analysis precise efficient continued engineering make technique practical larger programs discuss potential research directions sections follow improving precision safety-checking analysis developing algorithms interesting research direction develop typestate system algorithms make safety-checking analysis precise natural starting point address limitations identified including handling array handling meet array types precision developing heuristics strengthen induction-iteration method array bounds checks employing static run-time checks addition improving precision safety-checking algorithms sharpen analysis incorporating run-time checking rejecting untrusted code conditions checked statically generate code perform runtime checks straightforward technique annotation phase analysis generates safety conditions generate run-time checks conditions fail static checking thesis page tuesday december run-time checking address recovery problem fault detected run-time simplest thing terminate offending code ensure untrusted code violated violate default safety conditions access policy simply terminating offending code untrusted code accesses shared data acquires host resources general complicated actions ensure integrity host traditionally people avoid recovery problem allowing untrusted code interact trusted host well-defined interface transaction model untrusted code aborted fault occur notion typestate general dissertation type states correspond state machine operation bring operands state principle label states safe states states unsafe states safety policy include post-condition form typestates linear constraints invariants hold untrusted code terminates corrective actions generated automatically examining difference faulting state desired state typestate capture resources allocated released time fault generate corrective actions release resources thesis page tuesday december improving scalability safety-checking analysis employing modular checking make safety-checking analysis scalable perform intraprocedural analysis interprocedural analysis recent work interprocedural pointer analysis shown pointer analysis performed modular fashion techniques analyze function assuming unknown initial values parameters globals function entry point obtain summary function dataflow effect function techniques create safety preand postconditions automatically employing analyses unsound make technique scalable employ analyses efficient unsound examples include treating program loops acyclic terminating analysis fixed number iterations converges principle series techniques vary efficiency power apply techniques starting efficient apply expensive techniques producing proof-carrying code argument approach safety-checker implemented complicated proof checker proof-carrying code approach noted shown thesis structure safety checker principle separate safety-checker proof generator proof checker proof generator code producer synthethesis page tuesday december size attach safety proofs machine code proof checker code consumer check validity proofs extending techniques safety checking enforcing security policy work thesis focused enforcing safety based access control form discretionary access control discretionary access control policies impose restriction usage information obtained untrusted code prevent disastrous information leaks limitation addressed mandatory access control policies accesses allowed determined basis predefined rules generalization mandatory access policy represented information flow model denning denning policy based lattice model flow policy represented partial ordered set set security classes partial order called flow relation variable assigned security class flow information variable variable permissible iff security class security class function security class returns security class variable extend safety policy dissertation region category access include flow policy denning adding fourth component securityclass partial ordered set instances fourth component belong set check inforthesis page tuesday december mation higher security class flows location allocated storing information lower security class limitation denning flow certification 
method requires variables security class priori limitation makes unsuitable certifying legacy code code information machine code volpano irvine show limitations flow certification denning overcome secure flow type system flow control type checking focus producing principal types security requirements function abstractions treating information flow certification type-checking fits perfectly typestate-checking analysis enforce safety simple extension technique extend typestate system include orthogonal secureflow type component extend safety-checking analysis perform secure flow type checking consequence typestate-checking analysis enforce discretionary mandatory access policies reverse engineering safety-checking analysis works unannotated binary recovers typestate information existed source code typestate checking analysis reverse engineer machine code code typed source language information recovered analysis unannotated binary purposes safety checking type information recovered dynamic optimizer enable optimizations thesis page tuesday december impossible type information eliminate virtual function calls object-oriented programs usage information guide performance tool choose spots program insert instrumentation code gather present performance data human attractive aspect techniques forsake expensive parts analysis global verification care variable defined perform intraprocedural analysis signature function thesis page tuesday december abadi cardelli theory objects monographs computer science gries schneider springer-verlag york activex http microsoft tech activex asp aigner urs lzle eliminating virtual function calls programs european conference object-oriented programming linz austria alpern schneider recognizing safety liveness distributed computing amme data dependence analysis assembly code international conference parallel architectures compilation techniques pact paris october balasundaram kennedy technique summarizing data access parallelism enhancing transformations sigplan conference programming language design implementation portland usa june bershad savage pardyak sirer fiucynski becker eggers chambers extensibility safety performance spin operating system symposium operating system principles copper mountain december birrell nelson implementing remote procedure calls acm transaction computer systems february bodik gupta soffa refining data flow information infeasible paths acm sigsoft symposium foundations software engineering sixth european software engineering conference lncs springer verlag zurith switzerland sept bodik gupta sarkar abcd eliminating array bounds checks demand sigplan conference programming language design implementation vancouver canada june thesis page tuesday december boyer yuan automated proof object code widely microprocessor journal acm january callahan kennedy analysis interprocedural side effects parallel programming environment international conference supercomputing athens greece caplain finding invariant assertations proving programs international conference reliable software april chandra reps physical type checking paste sigplan-sigsoft workshop program analysis software tools engineering toulouse france september chase wegman zadeck analysis pointers structures sigplan conference programming language design implementation york chatterjee ryder landi relevant context inference acm symposium principles programming languages san antonio january cheng hwu modular interprocedural pointer analysis access paths design implementation evaluation sigplan conference programming language design implementation vancouver canada june chiueh venkitachalam pradhan integrating segmentation paging protection safe efficient transparent software extensions acm symposium operating systems principles charleston december clutterbuck carre verification low-level code software engineering journal colby lee necula blau plesko cline certifying compiler java sigplan conference programming language design implementation vancouver canada june cousot halbwachs automatic discovery linear restraints variables program annual acm symposium principles programming languages tucson january denning lattice model secure information flow communications acm thesis page tuesday december detlefs leino nelson saxe extended static checking research report compaq systems research center palo alto december dijkstra discipline programming prentice-hall englewood cliffs elspas green levitt waldinger research interactive program-proving techniques sri menlo park california engler kaashoek toole exokernel operating system architecture application-level resource management symposium operating system principles copper mountain december evans static detection dynamic memory errors acm sigplan conference programming language design implementation evans guttag horning tan lclint tool specifications check code sigsoft symposium foundations software engineering december fink knobe sarkar unified analysis array object strongly typed languages static analysis international symposium sas santa barbara june published jens oalsberg lecture notes computer science springer-verlag flanagan flatt krishnamurthi weirich catching bugs web program invariants acm sigplan conference programming language design implementation floyd assigning meanings programs proceedings symposia applied mathematics xix american mathematical society german automating proofs absence common runtime errors acm symposium principles programming languages tucson arizona january ghormley petrou rodrigues anderson slic extensibility system commodity operating systems usenix annual technical conference orleans louisiana june grand java language reilly associates july thesis page tuesday december gupta fresh optimizing array bound checking acm sigplan conference programming language design implementation white plains york june hailpern verifying concurrent processes temporal logic lecture notes computer science goos hartmanis eds springer-verlag harbison modulaprentice hall harrison compiler analysis ranges variables ieee transactions software engineering hoare axiomatic basis computer programming communications acm october illustra information technologies illustra datablade developer kit architecture manual release javasoft java native interface specification release jpvm native methods interface pvm java platform http chmsr gatech jpvm katz manna heuristic approach program verification international conference artificial intelligence august kelly maslov pugh rosser shpeisman wonnocott omega library version interface guide omega umd http umd projects omega november kolte wolfe elimination redundant array subscript range checks acm sigplan conference programming language design implementation jolla california june leroy rouaix security properties typed applets acm sigplan-sigact symposium principles programming languages san diego january lindholm yellin java virtual machine specification edition http java sun docs books vmspec ndedition html vmspectoc doc html markstein cocke markstein optimization range checking sigplan symposium compiler construction thesis page tuesday december mccanne jacobson bsd packet filter architecture user-level packet capture winter usenix conference usenix association san diego january mitchell maybury sweet mesa language manual technical report xerox palo alto research center microsoft microsoft technologies-information resources component object model-based technologies http microsoft march mycroft type-based decompilation program reconstruction type reconstruction european symposium programming esop amsterdam netherlands march miller callaghan cargille hollingsworth irvin karavanic kunchithapadam newhall paradyn parallel performance measurement tools ieee computer november milner theory type polymorphism programming journal computer system sciences mogul rashid accetta packet filter efficient mechanism user-level network code acm symposium operating systems principles austin november morris general axiom assignment theoretical foundations programming methodology lecture notes international summer school directed bauer dijkstra hoare manfred broy gunther schmidt reidel publishing company morrisett tarditi cheng stone harper lee til compiler performance safety types workshop compiler support systems software tucson february morrisett walker crary glew system typed assembly language annual acm symposium principles programming languages san diego january morrisett crary glew walker stack-based typed assembly 
language workshop types compilation published xavier leroy atsushi ohori lecture notes computer science springer-verlag thesis page tuesday december morrisett crary glew grossman samuels smith walker weirich zdancewic talx realistic typed assembly language acm workshop compiler support system software atlanda muchnick advanced compiler design implementation morgan kaufmann publishers necula compiling proofs dissertation carnegie mellon september necula lee design implementation certifying compiler acm sigplan conference programming language design implementation montreal canada june necula proof-carrying code annual acm symposium principles programming languages paris france january netscape browser plug-ins http home netscape plugins index html audrey black consel cowan inouye kethana walpole zhang optimistic incremental specialization streamlining commercial operating system acm symposium operating systems principles copper mountain december pugh omega test fast practical integer programming algorithm dependence analysis supercomputing albuquerque november pugh wonnacott eliminating false data dependences omega test acm sigplan conference programming language design implementation san francisco june pugh wonnacott experience constraint-based array dependence analysis technical report cs-truniversity maryland redell dalal horsley lauer lynch mcjones murray purcell pilot operating system personal computer communications acm february rivest message-digest algorithm request comments mit laboratory computer science rsa data security april thesis page tuesday december rugina rinard symbolic bounds analysis pointers array indices accessed memory regions sigplan conference programming language design implementation vancouver canada june samarati bertino ciampichetti jajodia information flow control object-oriented systems ieee transaction knowledge data engineering july august schneider fault-tolerant secure agentry international workshop distributed algorithms saarbr cken germany september seltzer endo small smith dealing disaster surviving misbehaved kernel extensions usenix symposium operating systems design implementation seattle october siff chandra ball kunchithapadam reps coping type casts seventh european software engineering conference seventh acm sigsoft symposium foundations software engineering toulouse france september smith stack smashing vulnerabilities unix operating system http destroy net machines security strom yellin extending typestate checking conditional liveness analysis ieee transactions software engineering strom yemini typestate programming language concept enhancing software reliability ieee transactions software engineering january small seltzer comparison extension technologies usenix annual technical conference san diego january smith walker morrisett alias types european symposium programming berlin germany march stonebraker inclusion types relational data base systems readings database systems edition michael stonebraker sun microsystems java plug-in overview http java sun products indexhtml october thesis page tuesday december susuki ishihata implementation array bound checker acm symposium principles programming languages los angeles january tamches miller fine-grained dynamic instrumentation commodity operating system kernels symposium operating system design implementation orleans february verbrugge hendren generalized constant propagation study international conference compiler construction link ping sweden april volpano irvine secure flow typing computer security wadler taste linear logic mathematical foundations computer science lecture notes computer science springer-verlag gdansk poland august tamir adi automatic derivation invariants ieee transactions software engineering sejanuary tennenhouse wetherall active network architecture computer communication review april wegner foster brewer aiken step automated detection buffer overrun vulnerabilities network distributed systems security conference san diego february wegbreit synthesis loop predicates communications acm february wahbe lucco anderson graham efficient softwarebased fault isolation symposium operating system principles asheville december miller reps safety checking machine code sigplan conference programming language design implementation vancouver canada june reps miller typestate checking machine code technical report wisconsin madison uly thesis page tuesday december 
refinement-based program verification three-valued-logic analysis alexey loginov dissertation submitted partial fulfillment requirements degree doctor philosophy computer sciences wisconsin madison dedicated loving memory father alexander volodin mother elena loginova proud acknowledgments foremost grateful advisor professor thomas reps infinite patience thoughtful counsel guided step put student interest taught taste research demanded perfection wife wendy unfaltering love support years graduate school reached point strength caring brother vladimir lifschitz sister-in-law elena lifschitz brought united states profound influence ways enumerate life transformed day met sasha amy wally kathy randy heather rest family love support helped low points celebrate high deeply indebted mooly sagiv pleasure collaborating projects mooly played big role development researcher thankful collaborators bertrand jeannet susan horwitz suan yong eran yahav roman manevich greta yorsh noam rinetzky tal lev-ami students susan tom research groups raghavan komondoor david melski denis gopan gogul balakrishnan akash lal nick kidd junghee lim interesting discussions neil immerman william hesse invaluable finite differencing richard bornat suggesting interesting challenge problem irene ong introducedme inductivelogic programmingand patientlyanswered questions learning fascinating technique iii members committee susan horwitz marvin solomon ben liblit david page insightful comments thesis stimulating discussions defense ian irene denis shura mihai sondra kevin ina hao jaime pedro ana vuk magdalena brad jen dave suan marc cheryl peter rest friends special place imagine life madison remember fondness wonderful dinner parties hosted jaime hao giordano tim jaglinski ainars marnauzs rest flying armadillos hockey team andy sullivan rest outdoor skating group support fun crisp passes completed dissertation support people mentioned deeply grateful discard page table contents page list figures vii abstract xii introduction solution organization thesis background first-order logic transitive closure stores logical structures abstractions instrumentation relations history relations abstract interpretation finite differencing logical formulas problem maintaining instrumentation relations finite-differencing scheme -valued -valued first-order logic extension sect reachability transitive closure transitive-closure maintenance acyclic graphs transitive-closure maintenance tree-shaped graphs reachability maintenance deterministic graphs experimental evaluation related work inductive logic programming ilp implementation ilp learning -valued logical structures implementation ilp learning -valued logical structures extensions algorithm fig abstraction refinement extension algorithm fig learning nullary relations page automatic abstraction refinement verifying sortedness iterative abstraction refinement instrumentation-relation discovery subformula-based refinement refinement actions define program transition relation refinement abstract input data-structure constructors success refinement insertsort ilp-based refinement experimental evaluation additional experiments acyclic lists properties reverse applied possibly-cyclic linked lists related work total correctness deutsch-schorr-waite tree-traversal algorithm binary-tree abstractions analyzing programs manipulate trees checking treeness maintained semantic reduction trees deutsch-schorr-waite tree-traversal algorithm shape abstraction verifying dsw establishing dsw terminates experimental evaluation discussion future work related work dsw arbitrary graphs dsw trees dags semantic minimization -valued propositional formulas terminology notation -valued propositional logic -valued propositional logic semantic minimization problem definition minimization problem justification problem definition algorithm semantic minimization realization monotonic boolean functions formulas page creating semantically minimal variant improved construction formula bdd-based minimization algorithm representing supervaluational semantics realization semantic minimization semantically minimal formulas related work conclusions future work list appendices appendix correctness finite-differencing scheme sect appendix proofs propositions chapter discard page vii list figures figure page information logical orders join operations store linked list declaration linked-list datatype core relations representing stores manipulated programs type list -valued logical structure represents store shown fig relations fig -valued logical structure canonical abstraction logical structure shown fig defining formulas instrumentation relations commonly employed analyses programs type list -valued logical structure represents store shown fig relations figs -valued logical structure canonical abstraction logical structure shown fig relation-update formulas express semantics assignment store elementuis shared isn formula created eqn showing imprecision illustrated fig avoided relation-maintenance formula viii figure page maintain -valued logic response values core relations caused execution statementst finite-difference formulas first-order formulas finite-difference formulas instrumentation relation isn optimized formulas operator fst non-atomic formula defining formulas instrumentation relations depend rtc justification finite-differencing method maintaining transitive closure acyclic graph response deletion single edge graph extension finite-differencing method fig cover rtc formulas unit-sized acyclic graph defined formulas obtained finite-differencing scheme figs positive values instrumentation relations fig formulas obtained finite-differencing scheme figs negative values instrumentation relations fig function anchored conservative identification anchored variables extension finite-differencing method fig cover rtc formulas unit-sized tree-shaped graph defined stores panhandle linked lists -valued logical structure represents store shown fig -valuedlogical structure represents type-xy panhandle lists store fig -valued logical structure canonical abstraction logical structure shown fig defining formulas extended set instrumentation relations -valued logical structure represents store shown fig extended set relations figure page -valued logical structure canonical abstraction logical structure shown fig assuming relations prx pris added toa -valued logical structure canonical abstraction logical structure shown fig results hand-crafted automatically generated maintenance formulas instrumentation relations alternative finite-differencing scheme first-order formulas linked list shared elements pseudo-code foil pseudo-code foil modified learn -valued logical structures logical structure element shared logical structure element shared stable version insertion sort structures describe inputs insertsort pseudo-code iterative abstraction refinement function instrum formulas definitions instrumentation relations illustration instrum formula asts instrumentation relations created subformula-based refinement verification partial correctness insertsort illustration data-structure constructors input specification structure arises lossy abstraction step analysis reverse structure arises lossy abstraction step analysis reverse figure page numbers instrumentation relations iteration abstraction refinement results applying iterative abstraction refinement verification properties programs manipulate linked lists execution times applying iterative abstraction refinement verification programs manipulate linked lists results ilp learn relations types verification stability insertsort results applying iterative abstraction refinement subformula-based refinement disabled verification properties programs manipulate linked lists logical structurethat represents store arises duringthe applicationof reverse acyclic list in-situ list reversal algorithm logical structures represent stores arises application reverse panhandle list data-structure constructors acyclic possibly-cyclic linked lists instrumentation relations created subformula-based refinement verification acyclic query reverse instrumentation relations created subformula-based refinement verification panhandle query reverse execution times applying iterative abstraction refinement verification properties reverse number distinct -valued structures collected iteration analysis reverse declaration binary-tree datatype core relations representing stores manipulated programs type tree store binary tree figure page defining formulas instrumentation relations commonly employed analyses programs type tree -valued logical structure represents store shown fig -valued logical structure canonical abstraction logical structure shown fig deutsch-schorr-waite algorithm states subtree cur pointing execution dsw states tree nodes subtree pointed 
cur execution dsw -valued structure represents trees size -valued structure collected exit dsw -valued structure arises prior rotation pointers node pointed cur execution dsw -valued truth tables propositional operators semi-bilattice -valued propositional logic semantic-minimization algorithm -valued propositional formulas refinement-based program verification three-valued-logic analysis alexey loginov supervision professor thomas reps wisconsin-madison recently sagiv reps wilhelm introduced powerful abstract-interpretation framework program analysis based three-valued logic instantiations framework show number interesting properties programs manipulate variety linked data structures aspects framework represented significant challenges user-model work reported thesis addressed shortcomings developed solutions carried experiments demonstrate effectiveness aspect set instrumentationrelations define abstraction analysis thesis presents method refines abstraction automatically refinement carried introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations present strategies refining abstraction simpler strategy effective cases strategy previously machine-learning algorithm learn abstraction learning defining formulas additional instrumentationrelations advantage method require theorem prover learning lieu deduction-based techniques constitutes paradigm shift abstraction constructed observing generalizing properties memory configurations aspect relation-maintenance formulas describe effect statements language expressed logical formulas describe core-relation values reflected values instrumentation relations formulas define abstract transfer functions abstract semantics analyzing programs manual creation relation-maintenance formulas time-consuming error-prone process thesis presents algorithm generate relation-maintenance formulas completely automatically algorithm based principle finite differencing transforms instrumentation relation defining formula relation-maintenance formula captures instrumentation relation thomas reps xii abstract recently sagiv reps wilhelm introduced powerful abstract-interpretation framework program analysis based three-valued logic instantiations framework show number interesting properties programs manipulate variety linked data structures aspects framework represented significant challenges user-model work reported thesis addressed shortcomings developed solutions carried experiments demonstrate effectiveness aspect set instrumentationrelations define abstraction analysis thesis presents method refines abstraction automatically refinement carried introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations present strategies refining abstraction simpler strategy effective cases strategy previously machine-learning algorithm learn abstraction learning defining formulas additional instrumentationrelations advantage method require theorem prover learning lieu deduction-based techniques constitutes paradigm shift abstraction constructed observing generalizing properties memory configurations aspect relation-maintenance formulas describe effect statements language expressed logical formulas describe core-relation values reflected values instrumentation relations formulas define abstract transfer functions abstract semantics analyzing programs manual creation relation-maintenance formulas time-consuming error-prone process thesis presents algorithm generate relation-maintenance formulas completely automatically xiii algorithm based principle finite differencing transforms instrumentation relation defining formula relation-maintenance formula captures instrumentation relation framework implemented tvla tool extended tvla automatic abstraction refinement finite differencing applied number programs manipulate cyclic acyclic singlyand doubly-linked lists binary trees binary-search trees tool demonstrate number interesting properties partial correctness programs additionally thesis reports automated verification total correctness partial correctness termination deutsch-schorr-waite dsw algorithm dsw algorithm traversing binary tree stack means destructive pointer manipulation prior approaches verification algorithm involved semi-automated applications theorem provers hand-written proofs tvla abstract-interpretation approach made automatic symbolic exploration memory configurations arise introduction simple core instrumentation relations tvla establish partial correctness termination dsw chapter introduction challenging setting static analysis software arises establish properties programs manipulate linked data structures programs written language supports heap-allocated storage destructive updating addressvalued fields recently sagiv reps wilhelm introduced approach based -valued logic addresses setting instantiations framework presented referred srw show safety heap manipulation programs find opportunities compile-time garbage collection show partial correctness linked-list sorting procedures ensure correct usage java interfaces collections iterators show partial correctness tricky concurrent algorithms srw related logics play ordinary -valued logic related -valued logic memory configuration store modeled logicians call logical structure individual structure universe models single memory element case summary individual models collection memory elements run analyzer carries abstract interpretation collect set structures program point involves finding fixed point set equations fixed point reached structures collected program point describe superset execution states occur determine query satisfied checks holds structures collected instantiations framework capable establishing nontrivial properties programs perform complex priori data structures tvla system three-valued-logic analyzer implements approach summary individuals play crucial role ensure abstract descriptors priori bounded size guarantees fixed-point reached constraint working limited-size descriptors implies loss information store intuitively properties concrete individuals lost due abstraction groups multiple individuals summary individuals property true concrete individuals group false individuals reason -valued logic uncertainty property captured means truth advantage -valued logic basis static analysis language extracting information concrete world abstract world identical syntactic expression logical formula interpreted -valued world -valued world consistency -valued -valued viewpoints ensured basic theorem relates logics formulas define concrete semantics interpreted -valued logic define sound abstract semantics interpreted -valued logic care design analysis danger abstract interpretation proceeds indefinite pervasive destroy ability recover interesting information -valued structures collected soundness maintained key role combating indefiniteness played instrumentation relations record auxiliary information logical structure srw annunciated benefit introducing instrumentation relations instrumentation principle observation instrumentation principle observation suppose valued structure represents -valued structure explicitly storing values formula extract precise information obtained evaluating ins instrumentation relations provide mechanism fine-tune abstraction instrumentation relation defined logical formula core relation symbols captures property individual memory cell possess general introduction additional instrumentation relations values stored maintained response effected program statements refines abstraction prepared track finer distinctions stores properties program stores identified means verifying properties programs advantages methodology srw loop invariants required methodology based abstract interpretation run analysis terminate methodology applies static analyses based -valued first-order logic applies programs manipulate pointers heap-allocated data structures eliminates user write usual proofs required abstract interpretation demonstrate abstract structures analyzer manipulates correctly model concrete heap-allocated data structures program manipulates key challenge wider applicability srw manually define instantiations framework capable yielding precise answer query program desirable replace user involvement automatic mechanism capable refining abstraction adaptive fashion mechanism requires parameterizable analysis framework ability change underlying abstraction abstract transformers ability create abstract transformers abstraction refinement ability select abstraction perform multiple iterations analysis srw addresses requirement includes solution requirements previously techniques automatic abstraction-refinement counterexample-guided abstraction refinement cegar apply setting key difference setting cegar approach abstract domain prior work abstract domains fixed finite cartesian products boolean values predicate-abstraction domains relations introduced nullary relations work applies richer class abstractions -valued structures generalize predicate-abstraction domains solution requirements introduce unary binary ternary relations transformers addition nullary relations distinguishing feature setting theorem provers limited applicability exist theorem provers first-order logic extended transitive closure capable identifying 
infeasible counterexample traces needed developtechniques tools slam blast solution organization thesis chapter introduces terminology notation presents logic employ describes logical structures representing memory stores chapter addressesrequirement applying abstract interpretation concrete semantics language desired abstraction create abstract transformers context semantics statements expressed logical formulas describe core-relation values instrumentation relations introduced refine abstraction challenge reflect core-relation values values instrumentationrelations algorithm presented chapter create formulas maintaincorrect values instrumentationrelations generate completely automatically part transformers abstract semantics deals instrumentation relations algorithm runs time linear size instrumentation relation defining formula research motivated work static analysis based -valued logic srw analysis method relies logic -valued -valued express program semantics benefit techniques standpoint concrete semantics instrumentation relations represent cached information recomputed reevaluating instrumentation relation defining formula local state standpoint abstract semantics reevaluating formula local -valued state lead drastic loss precision gain maximum benefit instrumentation relations abstract-interpretation algorithm obtain values problem instrumentation-relation maintenance solved incremental computation instrumentation relationpshould transition abstract state transformer state computed incrementally contributions work reported chapter summarized itcreates arelation-maintenance formula applying finite-differencing transformation defining formula algorithm runs time linear size defining formula present experimental evidence technique effective analysis programs manipulate cyclic acyclic singly-linked lists doubly-linked lists binary trees sorting programs relation-maintenance formulas produced automatically approach effective maintaining precision hand-crafted work related view-maintenance problem databases compared work novelty ability create relation-maintenance formulas suitable abstraction performed chapter presents inductive logic programming machinelearning technique instrumental solution requirement subject chapter chapter describes existing algorithm implements technique discusses implications algorithm setting -valued logic presents extensions implemented adapting algorithm articulated requirement chapter addressesrequirement applying abstract interpretation program query interest create abstraction sufficiently precise verify program satisfies query introduce approach creating abstractions automatically previous work involves successive refinement abstraction unlike previous work work presented thesis aimed analysis programs manipulate pointers heap-allocated data structures shape analysis demonstrate approach shape-analysis problems approach applicable programanalysis setting first-order logic chapter presents abstraction-refinement method static analyses based valued logic srw semantics statements query interest expressed logical formulas refinement performed introducing instrumentation relations defined logical formulas core relations capture basic properties memory configurations abstraction-refinement method refinement strategies strategy subformula-based refinement analyzes sources imprecision evaluation query chooses define instrumentation relations subformulas query strategy ilp-based refinement employs inductive logic programming ilp learn instrumentation relations stave imprecision due abstraction steps ilp forming boolean combinations existing relations previously introduced refinement techniques ilp create relations introducing quantifiers learning process choice instrumentation relations crucial precision cost analysis tvla users faced task identifying instrumentationrelation set definite answer query make cost prohibitive thiswas inthetvlauser-model thecontributions work chapter summarized establishes connection program analysis machine learning showing ilp relevant problem creating abstractions automatically ilp learning instrumentation relations preserve information lost due abstraction method implemented extension tvla input required program analysis consists transition system query formula identifies acceptable outputs iii characterization program valid inputs nonstandard form valid inputs giving non-deterministic program transition system generates valid inputs starting scratch data-structure constructors discussed sect present experimental evidence approach iterative abstractionrefinement loop yield precise answers queries tested effectiveness method sortedness stability antistability queries collection programs perform destructive list manipulation establish partial correctness binary-search-tree programs total correctness in-situ list-reversal program applied possibly-cyclic lists method successful cases tested identifyinggeneral rules aset ofobservedinstances inourcase relationships observed logical structure advantage approach based inductive learning require theorem prover beneficial setting logic undecidable chapter discusses deutsch-schorr-waite dsw algorithm dsw traverse tree stack temporarily systematically stealing pointer fields tree nodes serve place stack ordinarily in-order tree traversal subtlety algorithm complexity analyzing due fact traversal algorithm visits node tree times performs kind pointer rotation node visit time algorithm finishes restored original values node left-child right-child pointers restoring original tree richard bornat singles algorithm key test formal methods deutschschorr-waite algorithm mountain formalism pointer analysis climb past approaches involved hand-written proofs complicated invariants verify partial correctness algorithm automation efforts laborious proof performed jape proof editor pages key advantage tvla abstract-interpretation approach proof-theoretic approaches small number concepts involved defining abstraction structures arise execution verification carried automatically symbolic exploration memory configurations arise initial intention apply abstraction-refinement approach automatically create abstraction verify correctness algorithm dsw complexity made challenging verify algorithm manually-identified abstraction represents partial victory techniques finite differencing employed automatically create relation-maintenance formulas abstraction refinement learn abstraction verification algorithm correctness constituted standalone contribution worthy inclusion thesis contributions work reported chapter summarized defined abstraction canonical-abstraction framework tvla captures sufficient invariants dsw demonstrate partial correctness termination defined abstraction simple instrumentation relations key formulas atomic subformulas fact tree node passes states induced original state visits node define state-dependent abstraction requires fewer structures represent memory configurations arise dsw state dependence abstraction establish partial correctness dsw automatic symbolic exploration memory configurations state-dependent abstraction establish measure strictly decreases loop iteration establishing dsw terminates studying question precision analyses based -valued logic encountered non-standard logic-minimization problem arises -valued propositional logic chapter presents results problem illustrate issue trivial denote formula respect assignment truth values propositional variables -valued logic formula equivalent formula -valued logic assignments assign truth top contrast pand equivalent -valued logic values -valued assignments pmapsto pmapsto pmapsto negationslash pmapsto pmapsto pmapsto pmapsto formula definite answer butp pprovides indefinite answer demonstrates -valued logic notion formula formulas equivalent -valued logic evaluate definite -valued assignments interest phenomenon motivated possibility exploiting obtain answers applications -valued logic answer precise definite information answer imprecise indefinite information replacing formula formula improve precision answers obtained improving bysimplifying subtermsusingrewriting rules left questionof approach produces formula good chapter give algorithm approach algorithm produces formula well-defined sense work makes contributions provide formalization semantic-minimization problem formula goal find formula sect show find formula present methods creating formula chapter presents concluding remarks lessons learned future directions line research finally appendix presents proofs propositions app presents proof correctness solution requirement app presents proofs propositions stated chapter chapter background present chapter introduces terminology notation presents logic employ describes logical structures representing memory stores half sect introduces -valued first-order logic transitive closure concepts standard logic half section presents straightforward extension logic -valued setting truth introduced denote uncertainty remainder chapter summarizes program-analysis framework approach memory configurations encoded logical structures semantics programs properties memory configurations encoded logical formulas abstract interpretation computes set logical structures describe memory configurations arise point program analyzed first-order 
logic transitive closure -valued first-order logic transitive closure syntax first-order formulas equality reflexive transitive closure defined definition denote set arity-i relation symbols formula vocabulary uniontextiri defined formulas variables rtcv set free variables formula defined usual rtc stands reflexive transitive closure rtc free-variable set require negationslash free variables shorthand notations negationslash binary relation rtc c-like syntax conditional expressions order precedence connectives highest lowest drop parentheses emphasis definition -valued interpretation -valued logical structure set individuals maps relation symbol arity truth-valued function addition allu thatu andu distinct individuals assignment function maps variables individuals functionality defined free variables formula complete generally assume assignment arises connection discussion formula complete -valued meaning formula denoted yields truth defined inductively -valued logic shorthand -valued logic shorthand explained chapter min max max mapsto min mapsto rtcv ifz max nmin mapsto mapsto andz satisfy set -valued structures denoted -struct -valued logic embedding -valued logic formulas work identical -valued logic semantic level truth introduced denote uncertainty definition truth values definite values indefinite information order defined iff denotes thatl definite usel negationslash symbol denotes least-upper-bound operation respect asshowninfig weplacetwoorderingson theinformationorder denotedby andillustratedinfig captures certainty thelogicalorder showninfig defines meaning meet join logical order -valued logic retains number properties familiar -valued logic morgan laws associativityof distributivityof vice versa treated shorthand -valued logic chapter equalsv generalize defn define meaning formula respect -valued structure figure information order join operation logical order join operation definition -valued interpretation -valued logical structure set individuals maps relation symbol arity truth-valued function addition allu thatu andu distinct individuals assignment -valued meaning formula denoted yields truth meaning defined defn interpreted potentially satisfy set -valued structures denoted -struct defn requires individualu thevalueof anindividual iscalled asummaryindividual summary individual abstracts fragments data structure represent concrete memory cell embedding ordering structures defined definition lets ands structures letf surjectivefunction wesaythatf embedss ins denotedbys ifforeveryrelationsymbol rof arity embedded denoted exists function embedding theorem ifs piece information extracted formula conservative approximation information extracted formalize extend mappings individuals operate assignments iff function andz var assignment denotes assignmentf var theorem embedding theorem theorem structures letf function formula complete assignmentz stores logical structures abstractions figure store linked list program analysis -valued logic remainder chapter summarizes program-analysis framework approach concrete memory configurations stores encoded logical structures vocabulary relation symbols arities terms fixed collection core relations core relations part underlying semantics language analyzed record atomic properties stores instance fig definition linked-list datatype lists relations represent stores manipulated programs type list store fig core relations fixed combination language datatype general languages datatypes require collections core relations -valued logical structures represent memory configurations individuals set memory cells nullary relation represents boolean variable program unary relation represents pointer variable boolean-valued field record binary relation represents pointer field record unary relations represent pointer variables binary relation represents n-field list cell numeric-valued variables numeric-valued fields data modeled introducing relations binary relation dle stands data less-than-or-equal-to listed fig dle captures relative order nodes data values alternatively numeric-valued entities handled combining typedef struct node struct node int data list relation intended meaning dov andv denote memory cell pointer variable point memory cellv field ofv point tov dle data field ofv equal ofv figure declaration linked-list datatype core relations representing stores manipulated programs type list abstractions logical structures previously techniques creating numeric abstractions fig shows -valued structures represents store fig relations fig nodes andu represent list elements dle dle dle dle dle dle dle figure logical structures represents store shown fig graphical tabular forms relations fig relation shown explicitly node self-loop relation tabular form identity matrix informationcan extractedfrom logical structures evaluating formulas concrete operational semantics defined kind statementstin programming language structure transformer outgoing control-flow graph cfg edge structure transformer providing collection relation-transfer formulas core relationc formulas define core relations valued logical structures arises transformed create -valued logical structure typically define relationcins function edge optionally precondition formula filters structures follow transition postcondition operator post edgeeis defined liftinge structure transformer sets structures abstract stores -valued logical structures concrete stores abstracted abstract stores means embedding functions functions map individuals -valued structures tothoseofa -valuedstructures extracted froms evaluating formula information extracted froms evaluating obtain computable abstract domain ensure -valued structures represent memory configurations finite size defining equivalence relation individuals finite quotient structure respect equivalence relation individual -valued logical structure representing concrete memory cell mapped individual -valued logical structure vector values concrete individual user-chosen collection unary abstraction relations definition canonical abstraction -struct chosen subset unary relation symbols relations inaare called abstraction relations define equivalence relation onus allp surjective function maps individual equivalence class canonical abstraction respect toa denoted performs join information order relation values introducing dlex dle dlen dle figure -valued structure canonical abstraction structures intuitively canonical abstraction maps group individuals indistinguishable set unary abstraction relationsato single individual unary relationsare abstractionrelations canonical abstraction -valued logical structure shown fig addition represents list elements pointed program variable element data lower data values rest list note absence -valued -valued dle edge individualu individualu graphical notation depicting -valued logical structures individuals represented circles names nonvalues unary relations summary individuals represented double circles unary relation pointer-valued program variable represented solid arrow pto individualufor whichp absence ap-arrow nodeu individuals relation namep shown binary relationqis represented solid arrow labeledqbetween pair individuals absence q-arrow pairs whichq relations represented dotted arrows canonical abstraction ensures -valued structure larger fixed size priori instrumentation relations abstraction function analysis based precision analysis defined tuned choosing equip structures additional instrumentation relations record derived properties varying unary core unary instrumentation relations set abstraction relations set instrumentationrelations denoted arity-k relation symbol defined instrumentation-relation definition formula instrumentation relations defining formulas instrumentation relations long circular dependences introduction unary instrumentation relations abstraction relations control concrete individuals merged abstract individual control amount information lost abstraction instrumentation relations intended meaning isn fields list nodes point tov negationslash isv reachable fromv fields isv reachable pointer variable fields isv directed cycle fields figure defining formulas commonly instrumentation relations relation isn abbreviates is-shared separate reachability relation program variable recall thatv negationslash shorthand andn shorthand rtcv involve reachability properties defined rtc play crucial role definitions abstractions instance program-analysis applications reachability properties specific pointer variables effect keeping disjoint sublists summarized separately fig lists instrumentation 
relations important analysis programs type list dle dle dle dle dle dle dle figure logical structures represents store shown fig graphical tabular forms relations figs fig shows -valued structure represents store fig core relations fig instrumentation relations fig unary relations abstraction relations canonical abstraction valued logical structure shownin fig withfa history relations dlex dle dle dle figure -valued structures canonical abstraction structures interested making assertions compare state store end procedure state start instance interested variablex thestart ofa procedure guaranteed reachable end user make assertions double vocabulary relation extend program-analysis specification history relation serves indelible record state store entry point term history relations refer kind relations term active relations refer relations original vocabulary express property mentioned formula evaluates elements reachable procedure executes reachable beginning procedure procedure performs permutation list addition history relations introduce collection nullary instrumentation relations track active relations changed initial values active relation relation samep defined samep samern place formula asserting permutation property abstract interpretation collection formulas relation-transfer formula defines concrete semantics case core relation case instrumentation relation relationmaintenance formula abstract interpretation collects set -valued structures program point implemented iterative procedure finds fixed point set equations important understand analysis framework based logic model theoretic proof theoretic abstract interpretation collects sets -valued logical structures abstracted models actions donot relyon deductionor theorem proving fixed point reached structures collected program point describe relation-transfer formulas relation-maintenance formulas called relation-update formulas separate terms refer easily main subject chapter term relation-maintenance formula emphasizes connection work database community view maintenance sect view updating update made view relation propagated back base relations superset execution states occur determine property holds atp checks holds structures collected fig illustrates abstract execution statement -valued logical structure represents concrete lists length instrumentation relations relationmaintenance formulas omitted figure abstract execution statement revisited chapter discusses relation-maintenance formulas operations logical structures focus heuristic elaborates -valued structure causing replaced collection precise structures represent set concrete stores criterion refinement ensure formula evaluates definite complete assignments free variables operation brings focus invoking focus applying structure transformer focusing reduce numberof indefinitevalues arise whenrelation-transfer evaluated -valued structures focus formulas aim sharpen values relations applied individuals affected transformer involves materialization concrete individual summary individual program-analysis applications proposed statement form lhs rhs focus formula identify memory cells correspond l-value lhs r-value rhs ensures application abstract transformer performs strong update values core relations represent pointer variables fields updated statement set values logical structures represent admissible stores exclude structures impose integrity constraints instance relationx fig captures pointer variable points memory cell attribute unique imposes integrity constraint hold individual structure formula evaluates -valued logical structure corresponds operation viewed partial concretization structure unary rels binary rels indiv statement relation-transfer formulas structure unary rels binary rels indiv figure relation-transfer formulas forx andnexpress transformation logical structures corresponds semantics admissible store integrity constraints contribute concretization function abstraction integrity constraints enforced coerce clean-up operation sharpen -valued logical structure setting indefinite definite discard structure integrity constraint violated structure represent admissible store prevent analysis losing precision coerce applied steps algorithm application abstract transformer addition operations section constrained manipulate -valued structures images canonical abstraction rely embedding theorem applies pair structures embedded perform canonical abstraction application abstract structure transformer ensure abstract interpretation terminates canonical abstraction applied loop target backedge cfg chapter finite differencing logical formulas present chapter addresses instance fundamental challenge applying abstract interpretation concrete semantics language desired abstraction create abstract transformers context semantics statements expressed logical formulas describe core-relation values instrumentation relations defined logical formulas core relations introduced refine abstraction challenge reflect core-relation values values instrumentation relations algorithm presented chapter create formulas maintain correct values instrumentation relations generate completely automatically part transformers abstract semantics deals instrumentation relations algorithm based principle finite differencing transforms instrumentation relation defining formula relation-maintenance formula captures instrumentation relation algorithm runs time linear size instrumentation relation defining formula research motivated work static analysis based -valued logic analysis method relies logic -valued -valued express program semantics benefit techniques chapter organized sect defines relation-maintenance problem sect presents method generating maintenance formulas instrumentation relations sect discusses extensions handle instrumentation relations transitive closure sect presents experimental results sect discusses related work app proofs propositions problem maintaining instrumentation relations execution statement transforms logical structure represents store arises structure represents store executes structure consists core relations called proto-structure denoted proto creation ofs proto denoted bys proto expressed candu proto mapsto mapsto general compare relations proto tuples added deleted crux matter suppose defines instrumentation relation static-analysis engine obtain ofpins instrumentation relation defining formula expressed solely terms core relations core normal form circular dependences instrumentation relation defining formula put core normal form repeated substitution core relations remain core normal form converted core normal form determine instrumentation relationp evaluating structures proto eachu proto mapsto mapsto principle maintain values instrumentation relations eqn practice approach work observed working -valued logic retain precision defining special instrumentation-relation maintenance formula evaluating structures eachu mapsto mapsto advantage relation-maintenance approach results program analysis accurate -valued logic defined appropriately relation-maintenance strategy generate definite evaluation proto generates indefinite ensure analysis conservative show property holds definition suppose instrumentation relation defined formula relationmaintenance formula maintainspcorrectly statementstif alls -struct allz instrumentation relation core normal form provide relationmaintenance formula satisfies defn defining denotes formula obtained replacing relation occurrence denotes formula obtained replacing free occurrence variablevi bywi formula defined eqn maintains correctly statement -valued version eqn proto eqn evaluated structure place equivalent evaluated proto proto precisely drawback eqn obtain steps evaluating mimic evaluating proto pass -valued logic yields proto evaluating eqn satisfy defn obtained automatically eqn approach provide satisfactory solution relation-maintenance problem eqn is-shared fields isn negationslash captures memory cell pointed pointer fields memory cells fig figure store whichuis shared isn fig illustrates execution statement isn lose precision relation-maintenance formula created eqn initial -valued structure represents singly-linked lists length memory cells unshared execution change core relation formula isn created eqn negationslash shown fig structure created maintenance formula precise isn means represent shared cell final -valued structure represents cyclic linked lists sort imprecisioncan avoided devisingbetter relation-maintenance formulas instance isn defined formula isn meaning change isn imprecision illustrated fig avoided fig hand-crafted relation-maintenance formulas variety instrumentation relations formulas created hoc methods structure unary rels binary 
rels indiv isn statement relation-transfer formulas relation-maintenance formula isn negationslash structure unary rels binary rels indiv isn isn figure illustration loss precision isn relation-maintenance formula defined negationslash relation-maintenance formula structure created individualumay represent shared memory cell structure unary rels binary rels indiv isn statement relation-transfer formulas relation-maintenance formula isn isn structure unary rels binary rels indiv isn figure showing imprecision illustrated fig avoided relation-maintenance formula isn isn shows generated automatically sum prior work presented chapter user needed supplya formula instrumentation relationpand statementst effect user needed write separate characterizations instrumentation relationp defines pdirectly specifies execution kind statement language affects user responsibility ensure characterizations mutually consistent contrast method automatically creating relation-maintenance formulas presented sects user responsibility reduced defining obligation addressed chapter finite-differencing scheme -valued -valued first-order logic section presents finite-differencing scheme creating relation-maintenance formulas discussion couched terms -valued logic embedding theorem theorem theorem deriveprovidesound results interpreted -valued logic -valued logic demonstrated fig discussed resulting formula lead strictly precise result reevaluating instrumentation relation defining formula relation-maintenance formula defined terms finite-differencing operators denoted capture negative positive execution statement induces instrumentation relation formula created bycombiningpwith formula states conditions conditions terms values ofp values ins formula states ifp negative change ifp positive change fig depicts howthe ins andcombines values valuepto obtain desired valuep operators defined recursively shown fig definitions fig make evaluatea retrievestored execute statement sts evaluate stevaluate proto figure maintain -valued logic response values core relations caused execution statementst operator fst maintenance formula expressed fst eqn fig define syntax-directed translation scheme implemented recursive walk formula operators mutually recursive instance occurrence fst additional occurrences note exhibit convolution pattern characteristic differentiation finite differencing divided differencing continuing analogy differentiation helps bear mind independent variables core relations changed formulas dependent variable formal justification fig stated theorem cor explain informally cases fig atomic formula depend core relations unaffected tuples individuals removed forwhich alsoholds theyare tuples individualsremovedfrom holds form form form forms fst fst fst fst fst fst figure finite-difference formulas first-order formulas isn fst fst negationslash isn isn negationslash negationslash negationslash fst fst negationslash figure finite-difference formulas instrumentation relation isn change individual holds hold holds ifp iand similar previouscase doesnotalreadyhold isreplacedbytheformula pisevaluated thestoredvalue obtained reevaluating ifp iand negationslash characterize positive top apply top defining formula special case worth noting atomic formula shorthand depend core relations unaffected instrumentation relation isn is-shared fields defined eqn fig shows formulas obtained isn isn statement formulas fig simplified instance relation-transfer formula fig fig formulas bothn simplifies implementation simplifications performed greedily formula-construction time constructorfor rewrites pto ptop pto formulas infig simplify isn isn isn isn isn isn shownin fig definition isn avoids imprecision illustrated correctness finite-differencing scheme correctness finite-differencing scheme established lemma lemma formula statementst properties hold meta fst meta fst iii fst meta fst fst meta fst fst fst meta fst fst fst meta fst fst meta fst proof app simplify presentation lhs meta rhs lhs meta rhs shorthands lhs rhs lhs rhs anys -struct assignmentz complete lhs rhs lemma shows -structs specifies tuples relation defined added response execution ofst specifies tuples relation defined removed lemma proof theorem ensures correctness finite-differencing transformation fig theorem lets astructure -struct lets proto theproto-structurefor statement obtained structure obtained proto approximation filling instrumentationrelations topological ordering dependences arity-k relation obtained evaluating mapsto mapsto tuples formula complete assignmentz fst proof app -structs soundness finite-differencing transformation fig theorem embedding theorem theorem corollary -struct defined theorem -struct thatf embedss formula complete assignmentz fst optimized formulas fst foranon-atomicformula theoperatorfst asdefinedinformula evaluates hasnostoredvaluefor aresult definedinformula resultinhigherprecision topropagatefst intothe subformulas shown fig correctness operator fst defined fig guaranteed lemma generally propagation effect generating smaller finite-difference formulas result faster evaluation finite-difference formulas rely optimization implementation fst fst fst fst fst fst fst fst figure optimized formulas operator fst non-atomic formula discussion earlier thesis touted advantages apply related -valued -valued interpretation functions single formula inconsistent make transformation-based approach maintaining instrumentation relations lieu approach based overloading reason transformation-based approach opportunity simplify resulting formulas fly postprocessing phase finite differencing context evaluation -valued logic simplification important formulas tautologies -valued logic evaluate -valued logic instance yields nullary relation symbol finitedifferencing transformation implemented formula-minimization procedure valued logic developed minimization procedure chapter applies propositional logic propositional logic guaranteed return answer captures formula supervaluational meaning procedure subroutine heuristic method minimizing first-order formulas method works formula bottom-up applying propositional minimizer body non-propositional operator quantifier transitive-closure operator simplifiedin yield definite situations evaluation unsimplified relation-maintenance formula equivalently overloaded evaluation relation defining formula yields instance minimizingp yields evaluates relation-maintenance problem leads precise static-analysis algorithms malloc free modeling storage-allocation deallocation operations carried twostage statement transformer stage number individuals structure creates problems finite-differencing approach establishing mutually consistent values relation tuples involve newly allocated individual relation values needed stage relation-transfer formulas core relations relation-maintenance formulas instrumentation relations applied usual fashion eqns simple sidestep problem model free-storage list explicitly making substructure part -valued structure freelist malloc modeled advancing pointer freelist list returning memory cell pointed free modeled inserting head freelist list cell deallocated true structure model storage-allocation deallocation operations number individuals -valued structure change individual materialized usual mechanisms focus coerce operations values relation tuples involve newly materialized individual safe mutually consistent values intendedmeaning isv reachable fromv fields isv reachable pointer variable fields isv directed cycle fields figure defining formulas instrumentation relations depend rtc recall shorthand rtcv extension sect reachability transitive closure instrumentation relations depend rtc shown fig finding good maintain instrumentation relations defined rtc challenging general write first-order formula transitive-closure operator specifies maintain closure directed graph inresponse edge insertions deletions strategyhas toinvestigate special cases classes instrumentation relations first-order maintenance formulas exist apply system falls back safe maintenance formulas rtc sections confine important special cases maintenance insect case defines acyclic graph sect case defines tree-shaped graph finally sect case defines deterministic graph possibly-cyclic graph node outdegree class graphs corresponds possibly-cyclic linked lists collection techniques handle common data structures lists singlyand doubly-linked cyclic acyclic trees precision techniques due fact maintenance rtc reflect unit-size single-edge additions deletions performed first-order logical formulas maintaining rtc arbitrary graph maintaining techniques extended handle bounded-size addition deletion sets rtc restricted classes graphs arbitrary-size first-order expressible insuch cases ouralgorithmreturns formulathat thertc operator evaluation 
formula yield indefinite answers transitive-closure maintenance acyclic graphs definedby rtcv graph defined acyclic give first-order formula maintains addition deletion single -edge method minor modification method maintaining non-reflexive transitive closure acyclic graph due dong case insertion single -edge maintenance formula fst tuples represent paths andp connected -edge maintenance formula handle deletion single -edge bit complicated identify tuples represent paths rely edge deleted removed fromp stands suspicious collect set ofp-tuples remain inp stands trusted fst finally maintenance formula forpfor single -edge deletion fst figure edge deleted node pathu whichais reachable maintenance formulas maintain conditions hold graph defined acyclic change graph single edge addition deletion assumptions maintenance formula -edge deletion correct suppose suspicious tuple -path deleted -edge show fst suppose -edge deleted graph defined acyclic auinegationslash nodealongpathu fromwhichaisreachable seefig becausep andp hold becauseui reachable fromb acyclicity tuple suspicious andt edge graph defined fst means thatt yielding fst eqn fig extends method generating relation-maintenance formulas handle instrumentation relations rtc binary formula defines acyclic graph fig makes operator eqn recasts eqns finite-difference expressions figs show formulas obtained finite-differencing scheme figs positive negative instrumentation relations defined fig testing unit-size-change assumption special-case maintenance strategy applied statement analysis-generation time change performed atst graph definedby ifinanyadmissible -struct rtcv rtcv figure extension finite-differencing method fig cover rtc formulas unit-sized acyclic graph defined relationp fst fst fst fst figure formulas obtained finite-differencing scheme figs positive values instrumentation relations defined fig relationp fst fst fst fst fst fst fst fst fst fst fst figure formulas obtained finite-differencing scheme figs negative values instrumentation relations defined fig unique satisfying assignment free variables assignment satisfies pair defines change adds edge graph similarly admissible -struct unique satisfying assignment free variables assignment satisfies change deletion edge graph answering uniquesatisfiability questions logic general undecidable employ conservative approximation based syntactic analysis logical formulas analysis heuristic determine set variables admissible structure variables single binding formula satisfying assignments refer variables anchored variables instance relationq attribute unique admissiblestructure single possiblebinding variablevin assignment satisfies formula occurrence anchored variable conservative algorithm identifying anchored variables appears section ifbothfree variablesof areanchoredand graph defined similarly free variables anchored change removes edge graph cases reflexive transitive closure updated method discussed test anchored variables function anchored shown fig conservatively identifies anchored variables formula invoked anchored application top-level anchored handful patterns identify anchored variables variable anchored binary relation attribute function thenv anchored essence negations handled pushing negation deeper formula disjunction anchored variable anchored subformulas conjunction rule accumulates anchored variables process successive approximation variables anchored left subformula identify anchored variables subformulaand vice versa process iterated fixed point instance program-analysis applications relationn records field points function relation anchored unique function invfunction anchored anchored anchored anchored anchored anchored anchored anchored anchored anchored rtcv anchored figure function anchored conservatively identifies anchored variables variables anchored due surrounding context reached rules recursive calls anchored withv removed argument bound variablev refers occurrence ofv identically named anchored removed call returns avoid confusion outer scope note subtraction finally union ofa performed becausevmay ina case included answer rtcv handled similarly transitive-closure maintenance tree-shaped graphs definedby rtcv graph defined acyclic tree-shaped advantage fact fact bearing maintenance formula reflects positive unit-size change relation values relation formula negative unit-size change relation reflected values relation efficient manner tree-shaped graph exists path pair nodes path edge deleted removed formula fst fig extends method generating relation-maintenance formulas handle instrumentation relations rtc binary formula defines tree-shaped graph fig recasts eqn finite-difference expression comparing techniques sect maintenance rtc binary formula presented section refer method sect acyclicmaintenance method section tree-shapedmaintenance special-case maintenancestrategy describe section applies case change graph single edge addition deletion rely test sect ensure case rtcv figure extension finite-differencing method fig cover rtc formulas unit-sized tree-shaped graph defined finite-difference expression defined fig reachability maintenance deterministic graphs deterministic graph graph node outdegree graph defined deterministic give first-order formulas maintain reachability information graph response addition deletion single -edge abstractions possibly-cyclic linked lists class deterministic graphs corresponds set possibly-cyclic linked lists illustrate techniques panhandle lists linked lists cycle head list part cycle lists shown fig examples panhandle lists fig definition linked-list datatype lists core relations represent stores manipulated programs type list stores fig fig shows -valued structures represents store fig relations fig fig shows -valued structure represents store fig core relations fig instrumentation relations fig unary relations abstraction relations canonical abstraction -valued logical structure shown fig list nodes represented summary individualu ofs list nodes tou andu show dle relation rest chapter relevant problem reachability maintenance figure stores panhandle linked lists panhandle list pointed refer lists shape type-x lists panhandle list pointed pointing middle cycle refer lists shape type-xy lists nisnc xrn xrn cnr cnr cnr cnr cnr figure logical structures represents store shown fig graphical form relations fig relations figs transitive-closure relation omitted reduce clutter nnn figure logical structures represents type-xy panhandle lists store fig relations fig omitted reduce clutter values expected type-xy list holds nodes hold nodes cycle isn holds foru ins represented summary individualu ofs represents type-x panhandle list nodes panhandle nodes cycle reachability maintenance possibly-cyclic linked lists isnc cnrn figure -valued structures canonical abstraction structures addition tos represents type-x panhandle list nodes panhandle nodes cycle relations defined figs permit precise maintenance reachability information relation possiblycyclic lists difficulty arises reachability information updated reflect deletion edge cycle result statement null relations defined figs update requires recomputation transitive-closure formula generally results drastic loss precision presence abstraction demonstrate issue panhandle lists represented abstract structure shown fig lists type statement null effect deleting edge leaving making nodes represented unreachable note first-order-logic formula relations figs distinguish list nodes represented represented nodes reachable nodes exceptu unreachable nodes shared lie cycle inability formulafor transitive-closure subformula definition presence abstraction recomputing transitive-closure formulas yields instance formula evaluates assignment mapsto vmapsto values relation dashed edges connectingu withu essence solution enables maintaining reachability relations possibly-cyclic lists first-order logic find break symmetry cycle basic idea solution suggested william hesse neil immerman consists maintaining spanning-tree representation possibly-cyclic list reachability representation maintained first-order-logic formulas reachability actual list expressed first-order logic based spanning-tree representation explain approach highlight differences approach hesse approach relies introduction additional core instrumentation relations extend set core relations fig unary 
relation rocn designates node cycle representative cycle refer node rocn node relation rocn tracking unique cut edge cycle maintenance spanning tree fig shows -valued structure represents store fig extended set core relations rocn node general simply require node cycle designated rocn node section describe ensure fig lists extended set instrumentation relations divide description abstraction based set relations parts describe relations fig define directed spanning forests maintain precision cycle presence abstraction iii generate maintenance formulas instrumentation relations automatically parts highlight differences approach hesse intended meaning defining formula isn fields list nodes negationslash point tov sfen edge fromv tov rocn assuming thatv rocn node sfpn isv reachable fromv sfen edges sfe isv reachable fromv fields sfpn sfpn rocn sfpn isv reachable pointer variable fields isv directed cycle fields rocn sfpn prx doesv lie sfen path doesv sfpn precede n-path rocn node pris doesv lie sfen path shared isn sfpn node doesv precede shared node n-path rocn node figure defining formulas instrumentation relations sharing relation isn defined fig relations redefined first-order-logic formulas terms relations defining directed spanning forests instrumentation relation sfen sfe stands spanningforest edge maintain set edges form spanning forest list nodes hesse work spanning-forest edges retain direction edges result maintains spanning forests edges lead roots spanning forest designated rocn nodes abstraction clarity presentation define sfen reverse edges edges leaving rocn nodes graph defined sfen relation defines directed spanning forest rocn nodes spanning-forest roots usual orientation spanning-forest edges instrumentation relation sfpn sfp stands spanning-forest path maintain set paths spanning forest list nodes binary reachability actual lists relation fig defined terms rocn sfpn first-order-logic formula reachable spanning-forest path pair spanningforest paths source cut edge rocn node target cut edge n-successor rocn node unary reachability relations cyclicity relation defined first-order formulas defined terms binary reachability relation define terms chose simple definition observing node lies cycle spanning-forest path target cut edge n-successor rocn node fig shows -valued structures represents store fig extended set core instrumentation relations relations prx pris explained shortly preserving node ordering cycle presence abstraction fact techniques applicable presence abstraction introduces complication present setting studied hesse concern expressibility properties confines logic syntactic restrictions concern ability maintain precision framework canonical abstraction roc isnr cnpr prx pris roc sfen sfen sfensfen sfen sfen sfen sfen pris pris cnr cnr pris pris figure logical structures represents store shown fig graphical form extended set core relations extended set core instrumentation relations core relations grey transitive-closure relations sfpn omitted reduce clutter values transitive-closure relations readily graphical representation relations sfen instance nodeu related sfpn relation nodes appearing left pictorial representation unary reachability relations program variable play crucial role analysis programs manipulate acyclic linked lists addition keeping disjoint lists summarized separately list nodes visited traversal summarized separately nodes visited pointerused traverse list thenthe nodes visited relation nodes visited list cycle nodes cycle reachable set variables variables point node list result instrumentation relations discussed prevent nodes shown fig summarized assuming thatu rocn node canonical abstraction -valued structure shown fig nodes represented andu ofs represented single summary individualu ins symmetry hides information order traversal pointer variable values sfpn relation shown fig lose precision ancestors shared node spanning tree summarized descendants spanning tree xrn sfen rocnr cnr sfen sfen nsfe sfen sfe sfe isn figure -valued structures canonical abstraction structures relations prx pris added toaand nodeu rocn node break symmetry nodes cycle general mechanism unary properties akin unary reachability relations definitions relations prx fig full reachability relation replaced spanning-forest reachability relation sfpn relations prx distinguish nodes reachable program variable spanning-forest edges relation pris defined similarly instrumentation relation isn pris partitions nodes panhandle list ancestors descendants shared node spanning tree fig shows structures canonical abstraction ofs nnn prypr prypr pry prx prypr pry rocn prypr figure -valued structures canonical abstraction structures node rocn node represents panhandle lists typexy store fig instrumentation relations shown figure prx pry pris structures shown fig holds nodes hold nodes cycle isn holds foru fig assuming rocn node nodes distinct vector values relations pry pris breaking symmetry automatic generation maintenance formulas instrumentation relations thesis hesse hand-specified update formulas collection relations maintaining spanning-forest representation possibly-cyclic linked lists hand rely finite differencing previous sections chapter generate relation-maintenance formulas instrumentation relations maintenance formulas effective maintaining relations defined first-order-logic formulas relations fig sfpn additionally conditions finitedifferencing-generated maintenance formulas effective maintaining relations defined reflexive transitive closure binary relations conditions technique applicable maintenance relation sfpn graph-shape condition graph defined sfen acyclic tree-shaped unit-size-change condition change graph effected program statement single-edge addition deletion graph-shape condition applies setting graph defined sfen defines spanning forest acyclic tree-shaped unit-size-change condition requires discussion relation sfen defined terms rocn discussed relation-transfer formulas core relation rocn clear relation rocn change response change node field types statements change field effect reflected sfen relation statements forms null destroys edge leaving node pointed creates n-connection node pointed node pointed statements add remove single edge relation necessarily case add remove single edge sfen relation interpreted logical structure fig statement null effect deleting edge leaving action result deletion sfen edge entering shown figure preserve spanning-forest representation ensure rocn holds nodes lie cycle sfen represents spanning-forest edges requires settingthe valueof rocn foru adding sfen edge fromu tou illustrates language statement result deletion sfen edge addition techniques maintaining instrumentation relations defined transitive-closure operator sects applies work problem apply transformer statements null phases phase apply part transformer corresponds relation reflect values instrumentation relations phase apply part transformer corresponds relation rocn reflect values instrumentation relations explain phase transformers satisfies requirement change add delete single edge sfen relation additionally paying attention order phases ensure graph defined relation sfen remains acyclic tree-shaped application transformers preserve graph-shape condition case statement null apply part transformer corresponds relation null points rocn node null phase results deletion sfen edge enters node pointed phase apply part transformer corresponds relation rocn rocn null rocn sfpn thisphasesets therocn propertyofthesourcens ofacut edgeto forest path target cut edge point tons cut edge deleted phase results addition sfen edge tons preserve graph-shape condition case statement apply part transformer corresponds relation rocn rocn null rocn sfpn spanning-forest path nodenx pointed nodeny pointed statement creates cycle 
data structure update formula sets rocn property ofnx makingnx source cut edge andny target cut edge edge prior execution statement phase results change sfen relation phase apply part transformer corresponds relation null node pointed rocn node phase phase results addition sfen edge fromny tonx normalizing procedures include statement form null prior statement form ensure null prior assignment break-up transformers statements null phases ensures sfen relation remains acyclic tree-shaped throughouttheanalysis thegraph-shapecondition andthat thechangetothesfen relationeffected phase unit-size change unit-size-change condition sound maintain sfpn sfe techniques sect additionally sound maintain remaining instrumentation relations techniques sect remaining relations defined first-order-logic formulas soundness guarantees stored values instrumentation relations agree relations defining formulas analysis stored values agree relations intended meanings instance n-transfer phase transformer statement null removes non-cut edge cycle sfen relation temporarily span entire list long query results abstract interpretation phases two-phase transformer stored values instrumentation relations agree relations intended meanings defining formulas experimental evaluation evaluate techniques presented chapter extended tvla generate relationmaintenance formulas applied test suite existing analysis specifications involving programs fig test programs consisted operations acyclic singly-linked lists doubly-linked lists binary trees binary-search trees sorting programs system verify partial-correctness properties test programs instance reverse in-situ list-reversal program preserve list properties lose elements insertsorted good flow high-security input data flow low-security output channel chapter discusses verification stronger properties partial correctness test sect validates reasoning unit-size-change condition non-identity performance category test program maintenance formulas analysis time sec increase schemas inst ref total non-tc acyc tree acyc tree search getlast sll deleteall shape reverse analysis create delete merge insert dll append shape delete analysis splice binary insertsorted tree lindstrom shape dsw analysis deletesorted reversesorted bubblesort sll bubblesortbug sorting insertsortbug insertsort insertsortbug mergesorted information good flow flow bad flow figure results hand-crafted automatically generated maintenance formulas instrumentation relations algorithms lindstrom dsw variants deutsch-schorr-waite constant-space treetraversal algorithm destructive pointer rotation lindstrom dsw verified algorithms unsafe pointer operations memory leaks data structure produced end fact binary tree chapter discusses verification total correctness deutsch-schorr-waite binary tree produced end identical input tree algorithm terminates programs contained bugs instance insertsortbug insert-sort program ignores element list bubblebug bubble-sort program incorrect condition swapping elements infinite loop input list duplicate data values details tvla operational semantics programming language defined kind statement action schema outgoing cfg edges action schemas instantiated program statement instances create cfg combination action schema instrumentation relation maintenance-formula schema provided number non-identity maintenance-formula schemas reported columns fig broken columns defining formula occurrence rtc relation-maintenance formulas produced finite differencing generally larger hand-crafted affects analysis time number instances non-identity maintenance-formula schemas meaningful size measure experiments numbers column number instances non-identity schemas deletesorted high deletesorted includes inline expansions routine finds tree node takes place deleted node data structures manipulated programs test suite acyclic tree-shaped acyclic reachability maintenance techniques sect tree-shaped reachability maintenance techniques sect apply maintenance reachability relations absense hand-crafted maintenance formulas reachability relations work interprocedural shape analysis solution require inline-expanded programs possibly-cyclic linked lists extend experiments cover techniques sect validate techniques part verification properties reverse applied possibly-cyclic linked lists sect program test suite ran analysis hand-crafted maintenance formulas obtain answer cfg nodes annotated final sets logical structures ran analysis automatically generated maintenance formulas acyclic reachability maintenance compared result answer test programs analysis formulas yielded answers identical answers finally ran analysis automatically generated maintenance formulas tree-shaped reachability maintenance compared result answer test programs analysis automatically generated formulas yielded answers identical answers columns show performance data collected ghz ram running centos linux column labeled ref times columns labeled acyc give data analyses automatically generated maintenance formulas acyclic reachability maintenance columns labeled tree give data analyses automatically generated maintenance formulas tree-shaped reachability maintenance case runs made longest shortest times discarded set remaining averaged geometric slowdowns automatically generated formulas acyclic reachability maintenance approximately median due fact automatically generated formulas larger hand-crafted maximum slowdown highest slowdowns occured analyses programs involved deletions edges data structure graph edge-deletion maintenance formulas produced tree-shaped reachabilitymaintenancetechniqueare muchsmallerthanthosethat produced tenance expectation tree-shaped reachability-maintenance formulas smaller slowdown expectation confirmed geometric slowdowns automatically generated formulas tree-shaped reachability maintenance approximately witha median maximum slowdownwas analyses faster automatically generated formulas speedups due random variation accidental benefits subformula orderings advantageous short-circuit evaluation results encouraging abstractions commondata structures suggest algorithm generating relation-maintenance formulas sects capable automatically generating formulas precise hand-crafted tolerable effect runtime performance extended version tvla uncovered bugs hand-crafted formulas maintenance formula form called identity relationmaintenance formula identity relation-maintenance formula hand-crafted specification checked simplification generated relation-maintenance formula identity formula inconsistency turned error handcrafted specification found instance incorrect non-identity hand-crafted maintenance formula measurements reported fig based corrected hand-crafted specifications related work weakness past incarnations tvla user define relationmaintenance formulas statement affects instrumentation relation recent criticisms tvla based deficiency longer valid analyses defined formulas define acyclic relations classes formulas define cyclic relations algorithm presented sects user responsibility write formulas relation-maintenance formulas created automatically expect simple optimizations caching results evaluating subformulas reduce slowdown graf showed theorem provers generate abstract transformers abstract domains fixed finite cartesian products boolean values domains predicate abstraction predicate abstraction slam systems contrast abstract transformers created algorithm sects transformers algorithm simple linear-time recursive tree-traversal procedures theorem provers predicate abstraction guaranteed terminate setting makes richer abstract domains offered predicate abstraction experience date precision lost good abstract transformers instrumentation relations identified paige studied finite-differencing transformations applicative set-former expressions exploited optimize loops very-high-level languages setl liu related program-transformation methods setting functional programming language derive incremental algorithms problems specifications exhaustive algorithms work goal maintain functionf input undergoes small methods sects address similar kind incremental-computation problem language exhaustive incremental versions problem expressed first-order logic reflexive transitive closure finite-differencing operators defined sects closely related number previous papers logic databases finite-difference operators propositional case studied akers sharir previous work incrementally maintaining materialized views databases first-order incremental evaluation schemes foies dynamic descriptive complexity addressed problem maintaining auxiliary relations tuples inserted deleted base relations databases view maintenance solely optimization correct information obtained reevaluating formula abstract-interpretation context abstraction performed longer true reevaluating formula local -valued state lead drastic loss precision aspect sets work previous work figure alternative finite-differencing scheme first-order formulas goal developing finite-differencing transformation suitable abstraction performed finite-differencing transformations correct 
-valued logic satisfy theorem -valued logic instance fig presents alternative finite-differencing scheme first-order formulas scheme captures negativeandpositivechanges withfig maintenanceformulafor instrumentation relationpis denotes exclusive-or -valued logic eqn unfortunate property evaluates pinned indefinite successor structures successors eqn reacquire definite contrast maintenance formulas created finite-differencing scheme fig trouble formp if-then-else allowsp reacquire definite set ifp evaluates definite onuif vmapsto vmapsto vice versa sect compared work william hesse closest spirit techniques maintaining reachability information possibly-cyclic linked lists discuss approaches bear resemblance attempt translate simulate data structure handled core techniques idea spanning-tree representations reasoning data structures thatare closetotrees isnot graphtypes common non-tree-shaped data structures terms spanning-tree backbone regular expressions non-backbone edges occur backbone examples data structures graph types doubly-linked lists threaded trees panhandle list graph type graph type location non-backbone edge defined terms backbone regular expression regular expression existence backedge node occurs earlier list pale project incorporates work graph types manipulatedatastructures specifiedas graphtypes carried decision procedure monadic second-order logic decision procedure non-elementary complexity advantage approach pale rely decision procedure immerman presented structure simulation technique broadens applicability decisionprocedures toa larger class ofdata structures certainconditions allowsdata structures reasoned decidable logics translated data structures translation expressed first-order-logic formula unlike graph types structure simulation capable panhandle lists technique shares limitation graph types relies decision procedures automated reasoning programs manevich abstractions canonical-abstraction predicateabstractionforms lists maintaining reachability list segments interrupted nodes shared pointed variable break symmetry cycle definition key instrumentation relations work makes transitive-closure formulas handled precisely finite differencing result drawback work define relation-maintenance formulas hand drawback difficulty reasoning reachability list program variable reachability relations fig reachability list expressed terms reachability sequence uninterrupted segments formula expresses reachability node program variable list enumerate permutations program variables act interruptions path tov list number past approaches analysis programs manipulate linked lists relied first-order axiomatizations reachability information approaches involved first-order-logic decision procedures approach limitation instructive compare work approaches included mechanisms breaking symmetry cycle nelson defined set first-order axioms describe ternary reachability relation meaning reachable edges encountering relation sufficient setting presence abstraction require unary distinctions relations prx pris fig break symmetry additionally maintenance ternary relations expensive maintenance binary relations lahiri qadeer collection first-order axioms sufficient verify properties procedures perform single change cyclic list removal element verify properties in-situ list reversal albeit assumptionthat input list acyclic sect describe case study techniques developed sect verify properties reverse applied linked list including cyclic panhandle lists break symmetry cycles similar fashion blocking cells subset interruptions blocking cells include set head variables program variables act heads lists program set carefully maintained user satisfy thesystem definitionof acceptable well-founded lists allowthe system verify postconditions iii avoid falling prey difficulty arises thecurrent mechanismof panhandle lists set blocking cells include shared nodes limitationcan partially addressed generalizing set blocking cells mimic interruptions faithfully make difficult satisfy points iii stated work lahiri qadeer rely insight reachability information maintained first-order logic collection manually-specified update formulas define relations affected statements language user-inserted statements manage set head variables chapter inductive logic programming ilp present chapter discusses inductive logic programming ilp machine-learning technique key ingredient abstraction-refinement method discussed chapter present chapter starts defining problem solved ilp sect discusses existing algorithm implements technique sect discusses modification algorithm suitable learning -valued logical structures sect presents extensions implemented adapting algorithm part abstraction-refinement method finally sect presents extension algorithm learn nullary formulas employ capability learning nullary formulas abstraction-refinement method capability noteworthy technique predicate abstraction ilp identify nullary relations distinguish structure structures arising program point techniques algorithms discussed chapter abstraction refinement sect goal ilp algorithm arityk logical structures set positive assignments ofv individuals ofs set negative assignments ofv individuals ofs find logical formula free variables defined terms relations vocabulary ofs agrees classification input examples evaluates ins positive examples evaluates ins negative examples thesis describe called setting ilp setting employed large majority ilp systems setting number assignments logical formula learned labeled positive negative examples semantics ilp referred model-theory ilp assume thesis called normal semantics alternative semantics ilp non-monotonic semantics introducedby helft flach ilp systemsbased non-monotonicsemantics generally learn conservative properties systems based normal semantics reader referred survey muggleton raedt details theory methods ilp standard ilp algorithms produce answer form logic program technique non-recursive logic programs correspond subset first-order logic logic program thought disjunction program rules rule conjunction literals variables appearing head rule implicitlyexistentially quantified definition ilp list variablesv set assignmentse thevi individuals positive examples set assignments individuals negative examples logical structure goal ilp find formula alle satisfied covered ins noe satisfied ins formula defines arity-k relatione ilp algorithms capable producing recursive programs correspond first-order logic least-fixpoint operator general transitive closure learning unary formula variable holds linked-list elements pointed fields element defining formula sharing relation isn shown fig importance concept sharing heap data structures recognized mapsto mapsto mapsto mapsto -valued logical structure fig formula meets objective covers positive negative assignments implementation ilp learning -valued logical structures figure linked list shared elements fig presents ilp algorithm systems foil modified construct answer first-orderlogic formula disjunctive normal form input previous paragraph algorithm learns formula performing iteration outer loop iterations loop successively choose literals sequential covering algorithm parameterized function gain characterizes usefulness adding literal generally heuristic fashion algorithm creates disjunct long positiveexamples covered existing disjuncts disjunct extended conjoining literal covers negative examples literal relation symbol vocabulary structure valid arguments literal variables formal parameters additional variables long arguments variable current disjunct foil single literal chosen iteration loop lines heuristic based informationgain line foil informationgainto find theliteral distinguishes positive negative examples algorithm chooses literal vim condition prevents unconstrained searches yield simplest formula agrees classification input examples input target-relation list variables evars formal parameters logical structure -struct set assignments evars set assignments evars negationslash newdisjunct newe newe newe negationslash cand candidate literals vim vim cand max gainparenleftbigl vim newdisjunct newe newe parenrightbig newvars vim variables newdisjunct extend newe newe assignments newvars satisfy vim newe subset newe satisfying vim newdisjunct newdisjunct vim end subset satisfying newdisjunct -quantify variables newdisjunct newdisjunct end figure pseudo-code foil current sets assignments newe newe extended mappings variablevj vim occur current disjunct line updated sets newe newe consist assignments handled covered case newe excluded case newe assignmenta newe newe extended potentially multiple assignments 
mappings variables assignment satisfies vim agrees mapping variables common relational-algebra terminology updated assignment set newe newe natural join previous newe newe relation defined literal vim implementation ilp learning -valued logical structures ilp literature logical structure serves input algorithm generally partial -valued structure relation complete assignment unspecified structure extended structure -struct ways filling unspecified entries values general structures represent inadmissible stores partial logical structures formula learned algorithm shown fig guaranteed satisfied assignment evaluate structure -struct defined satisfied assignment evaluate logical structure corresponds minimal herbrand model values background relations classification input examples words extension changed maintaining extension satisfies input classification examples guarantee respect extensions -struct weaker formula guaranteed satisfied assignmente satisfied assignmente ins algorithmshown fig introducenegatedliterals uniquesuch extension statement corroborated code lines algorithm code lines algorithm continues process negative examples extensions satisfy vim algorithm makes kind closed-world assumption literal values true assumed false learning structure -struct natural define partial logical structures consists definite entries ofs entries relation values ofs unspecified withs input algorithm shown fig returns formula guaranteed satisfied assignmente evaluate concrete structures assignmente satisfied evaluate somes values ins guaranteed satisfied assignmente evaluate ins guaranteed possibly satisfied assignment evaluate ins intended setting program analysis generally transition systems define evolution logical structure important learned formulas guarantees alls yield negative examples alls ins achieve change operations shown lines fig process negative examples potentiallysatisfy vim satisfy vim change ensures algorithm retains extended negativeexample assignments excluded newdisjunct evaluate fig shows ilp algorithm fig modifications appearing bold henceforth assumethat learningfrom -valued logical structures performed algorithm shown fig differences algorithms shown figs effect learning non-partial -valued logical structures input target-relation list variables evars formal parameters logical structure -struct set assignments evars set assignments evars negationslash newdisjunct newe newe newe negationslash cand candidate literals vim vim cand max gainparenleftbigl vim newdisjunct newe newe parenrightbig newvars vim variables newdisjunct extend newe assignments newvars satisfy vim extend newe assignments newvars ctd cxcpd cpd cxd cudd vim newe subset newe ctd cxcpd cpd cxd cuddcxd vim newdisjunct newdisjunct vim end subset satisfying newdisjunct -quantify variables newdisjunct newdisjunct end figure pseudo-code foil modified learn -valued logical structures extensions algorithm fig abstraction refinement context ilp necessitates modifications basic algorithm fig changed algorithm learn multiple formulas invocation motivationisnot structure find instrumentationrelations analysis establishtheproperty interest find multiple literals quality metric line fig lies threshold highest-quality metric observed extend distinct copies current disjunct literals extend distinct copies current formula resulting disjuncts extension similar concept beam search implemented system beam search returns answers highest quality metric fixed extension puts bound number answers mentioned line motivation finding instrumentation relations analysis establish property interest cope potentially large number answers returned algorithm abstraction-refinement method includes heuristics pruning set answers returned ilp explained sect invoke ilp positive negative examples change needed enable algorithm fig return meaningful answers absence negative positive examples changing loop lines fig loop do-while obtain non-trivial formulas absence negative examples similarly changing outer loop lines fig loop do-while obtain non-trivial formulas absence positive examples algorithm invoked empty set negative positive examples place foil information-gain heuristic line fig simpler heuristic based percentage positive examples covered negative examples excluded disjunct extension algorithm fig learning nullary relations algorithm shown fig expects arity target relatione arities assignments sets greater algorithm learns relation requested arity satisfy classification examples unique input structure program-analysis applications abstraction based predicate-abstraction domains nullary relations express properties memory configurations desirable find nullary relations distinguish memory configurations arise program point conceptually simple change algorithm shown fig enables learn nullary relation evaluates set logical structures set logical structures lift operations expect set assignments individuals variables apply set pairs form logical structure set assignments individuals variables change signature algorithm state signature shortly instance finding subset remaining negative examples satisfy vim line fig computation newe vim replaced braceleftbig newe vim bracerightbig signature algorithm consists target-relation list variables formal parameters positive-example set form negative-example set form thes ands entries structures thet andt entries sets arity-k assignments attempting learn logical relation evaluates set structures set structures invoke modified algorithm figure logical structures whichuis shared figure logical structures element shared arguments target-relation empty variable list positiveexample set negative-example set instance invoke modified algorithm arguments empty variable list ande wheres ands shown figs algorithm identifies presence absence sharing key distinction structures returns formula attempting learn k-ary logical relation evaluates set positive-example assignments set negative-example assignments structure invoke modified algorithm arguments target-relation namee variables list single-element positive-exampleset single-element negative-example set input general form target-relation list variables formal parameters positive-example set negative-example set modified algorithm learns ak-ary relation evaluates ins assignments int fori ins assignments int forj chapter automatic abstraction refinement present chapter addresses instance fundamental challenge applying abstract interpretation program query interest create abstraction sufficiently precise verify program satisfies query chapter presents approach creating abstractions automatically previous work involves successive refinement abstraction unlike previous work work presented chapter aimed analysis programs manipulate pointers heap-allocated data structures shape analysis demonstrate approach shape-analysis problems approach applicable program-analysis setting first-order logic refinement performed introducing instrumentationrelations defined logical formulas core relations abstraction-refinement method refinement strategies strategy subformula-based refinement analyzes sources imprecision evaluation query chooses define instrumentation relations subformulas query strategy ilp-based refinement employs inductive logic programming ilp learn instrumentation relations stave imprecision due abstraction willbeexplainedinsect ilp-basedrefinement sect learn formulas kinds relations refine abstractions analysis framework abstractions generalize predicate-abstraction domains fourth ilp technique predicate abstraction ilp identify nullary relations distinguish positive-example structure structures arising program point sect version ilp algorithm capability steps ilp forming boolean combinations existing relations refinement techniques based predicate abstraction ilp create relations introducing quantifiers learning process chapter organized sect illustrates goals problem verifying partial correctness sorting routine sect presents abstraction-refinement method sect describes subformula-based refinement sect discusses shortcoming subformula-based refinement describes ilp-based refinement ilp learning abstraction sects present experimental results sect discusses related work verifying sortedness static-analysis algorithm defined sect demonstrate partial correctness procedure user supply program-specific information procedure control-flow graph data-structure constructor dsc code fragment non-deterministically constructs valid inputs query formula identifies intended outputs analysis algorithm run dsc concatenated procedure control-flow graph query evaluated structures generated exit problem establishing version insertsort shown fig partially correct fig shows structures characterize 
valid inputs insertsort theyrepresent thesetof toverify insertsort produces sorted permutation input list running analysis insertsort check structures arise procedure void insertsort list list null null null data data prn null pln break figure stable version insertion sort exit node formula evaluates dle formula evaluates nodes reachable non-decreasing order abstract interpretation collects -valued structures shown fig line note formula evaluates list element guaranteed correct order withrespect remainingelements notethe definite dle edge thefirst node summary node guarantee list nodes represented summary node correct order represents shown fig analysis admits possibility correct implementation insertion sort fig produce store shown fig abstraction fine-grained establish partial correctness insertsort fact abstraction fine-grained separate set sorted lists set lists sorted order lev-ami tvla establish partial correctness insertsort key step introduction instrumentation relation inorderdle holds nodes data-components equal n-successors inorderdle defined inorderdle dle sortedness property stated formula inorderdle introduction relation inorderdle -valued structures collected abstract interpretation end insertsort describe stores variable points acyclic sorted linked list structures formulas evaluate insertsort guaranteed work correctly valid inputs property required correct sorting procedure procedures manipulate linked lists output list permutation input list established checking formula chapter empty list -element list lists elements dle dle dle dle figure structures describe inputs insertsort iterative abstraction refinement instrumentation relation inorderdle defined explicitly tvla user heretofore burdens tvla user insight behavior program translate insight instrumentationrelations formula goal present chapter automate identification instrumentation relations inorderdle case insertsort goal obtain definite answers evaluating formula structures collected abstract interpretation line fig fig pseudo-code method steps explained line sect data-structure constructor compute abstract input structures represent valid inputs program perform abstract interpretation collect set structures program point evaluate query structures exit definite answer obtained structures terminate perform abstraction refinement line sects identify formulas define instrumentation relations input program transition relation data-structure constructor query closed formula construct abstract input perform abstract interpretation set -valued structures exit negationslash break find formulas instrumentation relations refine actions define program transition relation refine abstract input true figure pseudo-code iterative abstraction refinement line sect replace occurrences formulas query definitions instrumentation relations instrumentation relation symbols apply finite differencing generate relation-maintenance formulas newly introduced instrumentation relations instrumentation relations definitions changed line sect obtain precise values newly introduced instrumentation relations abstract structures define valid inputs program achieved reconstructing valid inputs performing abstract interpretation data-structure constructor sections verifying partial correctness insertsort illustrate steps iterative abstraction refinement instrumentation-relation discovery attempt abstraction refinement introduction query instrumentation relation lead definite answer query instance insertsort introducing query instrumentation relation ineffective relation contrast sect introduction unary instrumentation relation inorderdle sortedness query established inorderdle present statements program abstract interpretation results definite entries inorderdle instance comparison line fig insertion lines node pointed sayu node pointed results definite entry inorderdle algorithm generate instrumentationrelations account sources imprecision sect describes subformula-based refinement method query subformulas responsible indefinite answer generate instrumentationrelations sect discusses shortcoming subformula-based refinement describes ilp-based refinement ilp learning abstraction subformula-based refinement subformulas query responsible indefinite answer good candidates defining instrumentationrelations fig presents function instrum recursive-descent procedure generate defining formulas instrumentation relations arguments function formula logical structure -struct assignment defined free variables top-level invocation nullary query empty structure collected exit node run abstract interpretation precondition instrum starting assumption instrum attempts find subformulas sharpened sharpen formula figs subformulas found define instrumentation relations explanations cases instrum violates precondition instrum instrum case instrum unary set abstraction relations add set abstraction relations instrum examine defining formula ofp ifpis unary set abstraction relations add set abstraction relations instrum define instrumentation relation definition instrumentation relation examine find subformulas evaluate return instrum error instrum instrum instrum instrum uniontext vmapsto instrum vmapsto uniondisplay negationslash mapsto mapsto instrum mapsto mapsto figure function instrum formulas definitions instrumentation relations figure recursive-descent function instrum finds subformulas answer imprecision or-subformula instrum define instrumentation relation definition instrumentation relation examine bindingsvmapsto uto find subformulas evaluate formula returned instrum definition instrumentationrelationq wherev free variables order appearance formula unary instrumentation relations added non-abstraction relations added set abstraction relationsaon subsequent iteration abstraction refinement line entryp fig handles core instrumentation relations abstract interpretationof insertsort data-structure constructor fig sect constructs valid inputs procedure structures shown fig sect abstract interpretation collects -valued structure fig exit node insertsort sortedness query formula evaluates triggering call instrum formula structure empty assignment arguments column fig shows instrumentation relations created result call instrum iteration abstraction refinement note sorted defined implementation round abstract interpretation stopped imprecision detected call instrum final version sorted dle sorted sorted dle sorted sorted dle sorted sorted dle dle figure instrumentation relations created subformula-based refinement verification partial correctness insertsort inorderdle key insight results note instrum returns subformulas definition evaluates definite bothvmapsto andvmapsto fig refinementof stransition relation actions define program transition relation modified gain precision improvements storing maintaining instrumentation relations end instrumentation relationp query instrumentation relations defining formulas scanned occurrences occurrence substituted free variable replaced enabling stored valuep place evaluation finitedifferencing creates relation-maintenanceformulas instrumentation relations instrumentation relations definitions changed improves precision relations stored values maintained abstract interpretation insertsort formula query replaced stored sorted definitions instrumentation relations scanned occurrences sorted sorted order occurrences replaced names relations case relations definitions changed yielding definitions column fig transition-relation refinement completed invoking refinement abstract input data-structure constructors performing abstract interpretation refined transition system update abstract structures characterize acceptable inputs procedure values instrumentation relations gain maximum benefit maintainingp abstract interpretation start precise values abstract input structures simply evaluating abstract input structures assignments free variables results safe values values imprecise illustrate issue stability property property arises context sorting procedures applies list-manipulating programs general stability query formula asserts relative order elements equal data-components remains dle dle run abstract interpretation insertsort result definite answer stability query round abstraction refinement introduces subformula formula instrumentation relation stable dle dle rightmost structure fig includes concrete summary individual call themuc andus simply evaluate formula structure related property antistability asserts order elements equal data-components reversed dle dle test suite includes program insertsort identical insertsort line fig correct place insert current node implementation insertion sort antistable structure history relations ast values active counterparts omitted figure clarity abstraction slls program list null int sizeof list list malloc empty list nondeterministic sll constructor program figure illustration input specifications programs 
manipulate singly-linked lists traditional input specification tvla fragment code nondeterministically constructs singly-linked lists loop set inputs obtain definite tuples evaluation yields tuple dle andtn equal methodology obtaining values abstract input structures perform abstract interpretation loop constructs family valid inputs program call loop data-structure constructor dsc values instrumentation relations maintained input structures manufacturedfrom emptystore computed general results precise values instrumentation relations fig illustrates idea left-hand side shows traditional tvla approach program analyzed acyclic linked list pointed list constructed tail head deeply nested node loop exits number nodes added front list exampleof methodologyis depictedon theright-handside program analyzed composed dsc nondeterministic loop constructing singly-linked lists original procedure input specification consists empty list abstract interpretationof dsc performed usingan extended vocabulary instrumentation relation symbols -valued structures collected exit node dsc abstract input original procedure abstract procedure entry point subsequent abstract interpretation procedure note history relations chapter intended record state store entry point procedure equivalently exit dsc make relations values maintained tandem active counterparts abstract interpretation dsc abstract input refinement completed values history relations frozen preparation abstract interpretation performed procedure proper stable instrumentation relation defined formula exemplifies benefits dsc methodology themaintenanceofstable starting fromtheemptystore input structure procedure insertsort stability property holds initially fig shows linked-list dsc inputs insertsort abstract interpretation collects -valued structures exit node dsc empty structure single element structure values instrumentation relations definite structures sorted structure essentially rightmost structure fig values instrumentation relations data-values stored list elements dle relationships elements sorted structure unary relationssorted andsorted individuals structure structures collected exit node dsc abstract input structures abstract entry point insertsort run abstract interpretation insertsort dsc automatically construct abstract input structures run abstract interpretation line fig user program inputs form program frees user details initial abstraction success refinement insertsort structures collected exit node insertsort run abstract interpretation sorted permutation property holds structures facts establish partial correctness insertsort process required iteration abstraction refinement basic version specification vocabulary consisted relations figs history relations needed user intervention ilp-based refinement shortcomings subformula-based refinement procedure insertsort consists nested loops fig outer loop traverses list setting pointer variable point list nodes iteration outer loop loop finds correct place insert target traversing list start pointer variable target inserted target data data insertsort satisfies invariant list nodes list target correct order data-component target data-component nodes ahead target moved insertsort preserves original order elements equal data-components insertsort stable routine subformula-based refinement capable establishing stability insertsort subformulas query case formula candidate instrumentation relations strategy unable introduce instrumentation relations maintain information transitive successors list node correct relative order contrast capableof establishingthe antistability insertsort place insert target routine stops data data inserts target target analysis establish sortednessproperties observe dle dle dle rnl dle figure structures arises line fig unlabeled edges nodes represent dle relation learning instrumentation relations fig shows structures arises abstract interpretation line fig tabular version relationstn dle omit reachability relations figure clarity assignment nodes identical vectors values unary abstraction relations subsequent application canonical abstraction produces structures shown fig bold entries tables fig definite values transformed structure satisfies sortedness invariant discussed everynodeamongu hasthedle target piece information lost structures dle indicating nodes represented summary node sorted order respect successors refer abstraction steps information-loss points abstract structure transformer temporarily create structures image canonical abstraction subsequent application canonical abstraction transforms list node inserted node data-value refinement introduces instrumentation relations based subformulas antistability query tvla establish antistability insertsort rnpr dle dle figure structures transformation ofs statement line fig unlabeled edges nodes represent dle relation structure grouping set individuals single summary individual ofs loss precision due circumstances individuals possesses property individual possess property summary individual individuals inu property common recomputed precisely ins cases solution lies introduction instrumentation relations case introduce unary abstraction relation individuals possess property grouped case sufficient introduce non-abstraction relation arity captures common property individuals version ilp algorithm sect learn formulas kinds relations type unary relation mapsto braceleftbig mapsto bracerightbig type unary relationr withe braceleftbig mapsto bracerightbig type unary relationr withe braceleftbig mapsto bracerightbig type iii binary relationr withe braceleftbig mapsto mapsto bracerightbig type iii binary relationr withe braceleftbig mapsto mapsto bracerightbig type relations intended prevent grouping individuals properties types iii iii iii intended capture common properties individuals type iii relations generalized ternary higher-arity relations needed analysis framework abstractions generalize predicateabstraction domains fourth ilp technique predicate abstraction ilp identify nullary relations distinguish structures arising program point sect describes version ilp algorithm capability steps ilp forming boolean combinations existing relations refinement techniques based predicate abstraction ilp create relations introducing quantifiers learning process relation type suited analysis relation type explain shortly background logical structure serves input ilp pass structures identified information-loss point restrict algorithm relations structure query lose definite entries result abstraction dle definite entries relations learn formulas evaluate positive negative describe variant ilp sect learn binary formula structure fig formula define binary relation type iii set individuals grouped abstraction input set positive examples mapsto mapsto mapsto mapsto mapsto mapsto mapsto mapsto set relations lose definite values due abstraction includes dle literal dle covers examples holds assignments mapsto mapsto mapsto mapsto mapsto mapsto algorithm picks literal negative examples dle disjunct literal covers remaining positive mapsto mapsto algorithm returns formula dle re-written astn dle relation abstraction maintain information transitive successors list node correct relative order dle establishing fact list nodes appearing prior target sorted order formulas dle learned ilp fig verification process introducing unnecessary instrumentation relations harm analysis increasing cost discussion explained sect precision improvement subformula query define instrumentation relation due stored values query definitions instrumentation relations place defining formula picking defining formulas instrumentationrelations subformulas query ensures reuse relations learned ilp necessarily match subformulas query fact assuming subformula-based refinement fails verify property relations needed tocapture properties holdat earlier pointsof theprogram lost due abstraction precision improvement introducing instrumentation relation due sharpening relations terms defined relations occur sharpening achieved application coerce operation enforce additional integrity constraints generated automatically based definition instance based definition system generates integrity constraints dle dle relation type iii tuples consist elements case type type iii relations case type type iii relations abstraction step information-loss point loss precision point analysis precise values values relations occur defining formula sharpened automatically generated integrity constraints relations 
types capture common properties individuals relation type generally suited generating integrity constraints defining formulas relations types forms eqns logical literals system relation result automatic generation integrity constraints number disjuncts defining formula quantifiers relation hand results automatic generation constraints ilp learn relations type generally type relations effect precision analysis conclusions hold distinction relations types iii iii applied examples type iii ilp frequently learns defining formulas quantifiers relation discussed relations result generation integrity constraints improve precision analysis demonstrated relationr ilp refinement loop ilp powerful mechanism learning abstractions present generally employ subformula-based refinement cost strategy reasonable sect strategy successful mode operation call instrum line fig returns formulas adds relations set abstraction relations turn ilp strategy sect describes experiments alternative mode operation subformula-based refinement turned ilp-based refinement applied iteration subformula-based refinement save logical structures information-loss points failure subformula-based refinement invoke ilp algorithm sect lower cost analysis prune returned set formulas learned formula conservative test check introduction instrumentation relation defined sharpen tuples relations occur call formulas pass test effective test results previous round analysis simulate introduction ofp effective formulas learned ilp define instrumentation relations relations refine abstraction performing steps lines fig implementation learn relations types sect unary binary nullary present number instrumentation relations analysis tvla significant impact cost analysis experiments reported sect touch implications learning types relations sect invokingilp learn binary formulas type iii verification stability insertsort thirteen effective binary formulas learned ilp algorithm formula completion refinement steps subsequent run analysis successfully verifies stability insertsort experimental evaluation evaluate method presented chapter extended tvla perform iterative abstraction refinement applied queries programs fig insertsort test programs included sorting procedures bubblesort insertsort list-merging procedure merge in-situ list-reversal procedure reverse dsc tests procedure generate unsorted lists arbitrary length case programs merge merge dsc procedure generate pairs unsorted lists describe results applying iterative abstraction refinement invokes ilp learn binary formulas type iii fig shows method generate instrumentation relations tvla establish properties expect hold sorted stable antistable test program instrum rels instrum rels instrum rels total ilp total ilp total ilp bubblesort insertsort insertsort merge reverse figure numbers instrumentation relations iteration abstraction refinement numbers cell give total number relations number relations introduced subformula-based refinement number effective relations learned ilp tvla succeeds demonstrating sorting routines produce sorted lists bubblesort insertsort merge stable routines insertsort reverse antistable routines test program sortedstable antistable bubblesort insertsort insertsort merge reverse figure results applying iterative abstraction refinement verification properties programs manipulate linked lists columns correspond queries stated formulas indefinite answers entries important understand occurrences fig precise correct answers instance result applying reverse unsorted list unsorted list case input list non-increasing order reverse produces sorted list precise answer query fig shows numbers instrumentation relations iteration abstraction refinement number relations defined subformulas query small relative total number instrumentation relations verification test ilp learns effective relations verification stability insertsort test program sortedstable antistable bubblesort insertsort insertsort merge reverse figure total execution times applying iterative abstraction refinement seconds fig executiontimes collected ghz ram running centos linux longest-runninganalysis verifies insertsort stable takes minutes eleven analyses minute rest minutes total time tests minutes maximum amount memory tvla perform analyses varied megabytes megabytes sortedness bubblesort insertsort queries set tvla applied work queries performance iterative abstraction refinement close performance analysis user carefully chooses instrumentation relations ilp verification properties expect hold stability insertsort devised sets experiments testedtheresiliencyof ilp byvaryingthe types relationsthat ilp allowedtolearn verification stability insertsort discussion fig forced ilp invoked verification properties expecttohold thediscussionoffig discussed tvla written java report maximum total memory minus free memory returned runtime results varying types relations learned fig shows results varying types relations learned ilp abstraction refinement verifying stability insertsort short ilp invoked learn relations type type iii types resulting abstractions sufficiently precise establish stability insertsort surprised system capable establishing stability insertsort allowed learn type relations learning relations type total analysis time analysis time round analysis seconds faster learning relations type iii total analysis time learning relations type minutes key relation captures information relationr relationr type defined dle thisrelationhas themeaning hasa transitivepredecessor thatisout oforder theintroduction instrumentation relation results automatic generation integrity constraints dle dle constraints achieve effect constraints incidentally ofr individualin everystructure collected exit node insertsort analysis establishes insertsort fact produce sorted list query stability query case application ilp learned relation allowed analysis establish stronger output list sorted learning relations type ilp algorithm learn properties common nodes summarized result learn relations relation capable encoding sortedness invariant learning relations type analysis unable establish stability insertsort test program answer ilp execution time sec instrum rels total ilp iter type iii type type types figure results ilp learn relations types verification stability insertsort column number instrumentation relations introduced ilp columns give execution times total execution time execution time ilp execution time round analysis dsc insertsort intuitively relations types iii universal properties hold individuals captured case relations type type iii relations capture properties negations hold individuals relations relations type capture actual properties programs opposed coincidental properties arise exploration program reachable configurations costs invocation ilp effectiveness tests seconds costs incurred information-loss points costs low implementation ilp algorithm unoptimized advantage fact ilp computation information-loss point produces results ilp computations information-loss points fig shows higher number relations analysis cost learning relations types increases chance obtaining definite answer resulting analysis suffers slowdown times compared analysis ilp learn relations type slowdown concentrated iteration analysis slowdownon iteration fourfold performance learning relations type performed learning relations types iii lead definite answer query results turning subformula-based refinement attempt understand power ilp-based refinement approach performed experiment disabled subformula-based refinement verify automatically properties expect hold entries fig subformula-based refinement appears stave imprecision sufficiently ilp learn formulas effort learn relations absence subformulabased refinement made basic refinement mechanism ensured round analysis proceeds completion terminated imprecision detected results information-loss points ilp applied turned effectiveness test pruning set formulas returned ilp intended ilp learn formulas attempting verify sorting procedures fact produce sorted lists ilp learns type relationr defined dle note definition meaning negation definition inorderdle steps line fig result replacement formula dle sortedness query stored modified query evaluates structures collected exit nodes sorting procedures establishing sortedness property fully automatically total analysis times minutes insertsort insertsort minutes bubblesort attempting 
verify merge stable ilp learns type relationr defined definition meaning transitive predecessor input list longer transitive predecessor introduction relation result definite answer stability query subformula query result stored values ofr evaluation query absence individuals values relation structures collected exit node merge implies procedure stable establishes merge stable mechanically sortedness property required manual examination results recognize stability individuals forr structures collected exit node total analysis time minutes attempting verify reverse antistable ilp learns type relationr defined definition ofr meaning transitivesuccessor input list transitivepredecessor case merge introductionof learned relation analysis establish property antistability reverse indirect total analysis time seconds attempting verify bubblesort insertsort stable ilp learns type relationr defined dle definition ofr meaning transitive predecessor input list longer transitive predecessor equal ofv absence individuals values relation structures collected exit nodes procedures imply procedures stable relation values structure collected exit nodes bubblesort insertsort present mechanism unable establish stability routines subformula-based refinement introduction relationr qualified partial success finally attempting verify antistability insertsort ilp learn single formula captures property combination formulas absence subformula-based refinement structures arising information-loss points sufficient precision enable learning formula dle dle meaning transitive successor input list transitive predecessor equal reason ilp inability learn formula introduction instrumentation relation defined equality subformula dle dle analysis sufficient precision equality formula enable part ilp-learned relation subformula-based refinement needed improve precision evaluation simple combinations formulas relevant query combination dle dle makes equality formula provide ilp precision learn relations based combinations test program sortedstable antistable bubblesort insertsort insertsort merge reverse figure results applying iterative abstraction refinement subformula-based refinement disabled verification properties programs manipulate linked lists empty cells answers expected fig summarizes experiment nonempty cells correspond properties expect hold entries stability merge antistability reverse labeled distinguish answers answers obtained fully automatically case sortedness properties sorting procedures remaining cases definite conclusion property drawn based analysis case stability bubblesort insertsort claim partial success reasons additional experiments acyclic lists performed additional experiments test applicability method queries data structures experiment subformula-based refinement successfully verified in-situ list-reversal procedure reverse produces list reversal input list assuming input list acyclic query expresses property experiment seconds megabytes memory application reverse arbitrary lists sect experiments involved programs manipulate binary-search trees insertbst inserts node binary-search tree deletebst deletes node binary-search tree programs subformula-based refinement successfully verified query nodes tree pointed variable remain sorted order end programs left dle dle initial specifications analyses included standard instrumentation relations similar listed fig relation formula distinguishes nodes tree pointed sect discusses relations employed analyses programs type tree detail dsc analyses nondeterministicallyconstructs binary-search tree allocating node time inserting tree position data-value insertbst experiment seconds megabytes memory deletebst experiment approximately minutes megabytes memory properties cactdactd applied possibly-cyclic linked lists fourth experiment successfullyverified expected properties transformations performed reverse possibly-cyclic linked lists additionally simple progress monitor establish termination procedure input describe experiment detail remainder section fig thealgorithmperforms thereversal place pointer variables field list nodes reversed lines execution statements lines points node xyt figure logical structures represents store arises prior line reverse algorithm applied acyclic list processed points node field reversed points predecessor node void reverse list list null null null figure in-situ list reversal algorithm reverse processes acyclic list head pointed fig shows logical structure represents store arises line application reverse point edges nodes reversed remaining edges retain original orientation statements lines replace edge tou edge traversal continues loop iteration set point predecessor input list set point set null subsequent execution lines reverses remaining edge head reversed list pointed input list node lies cycle statement procedure assignment line restores head pointer transformation stated formally history relations samern samecn reverse processes list consists single cycle panhandle acyclic list discussed additional edge behavior reverse listlc identical behavior listla outgoing edges reversed time iteration set point tou set point set null subsequent execution lines reverses remaining edge head reversed list remains pointed list node lies cycle statement procedure assignment line restores head pointer transformation lists obeys property formula discuss reverse processes panhandle listlp initially procedure advances thethreepointervariables andt downthepanhandle reversingthenedges outofy afterthe panhandleis processed thealgorithmproceeds fig shows logical structurethat represents store arises prior line reverse processes nodes lie cycle reverse completes processing cycle steps identical steps processing listsla andlc note orientation edges panhandle reversed loop bodyis executedwith pointingtou reversingthe backedge end processingthe cycle result algorithm proceeds reversed edges panhandle reestablishing original orientation edges fig showsalogical structurethat represents storethat arises priortoline whilereverse processes panhandle nodes time reversing edge list listsla andlc algorithm reverses direction edge cycle reestablishes original direction edges panhandle cyclicity property nodes remains input head output list remains pointed statement procedure assignment line restores head pointer transformation stated formally history relations samern samecn reversing edge panhandle list requires shared node fig outgoing edges nnu nnn nnu nnn figure logical structures represents stores arise prior line reverse algorithm applied panhandle list logical structure represents store arises reverse processes nodes lie cycle processing nodes lie panhandle logical structure represents store arises reverse processes nodes lie panhandle time processing nodes lie cycle note behavior reverse lists consisting cycle panhandle formula mentioned formula case formula arises dsc possibly-cyclic linked lists methodology sect construct -valued structures represent valid inputs procedure round analysis reverse fig shows dsc constructs acyclic lists identical dsc shown fig slight modification shown nondeterministically constructs cyclic acyclic linked list pointed achieved setting point list node line nondeterministically setting point list node null line setting point line non-null possibly completing cycle null dsc constructs acyclic list points head list dsc constructs list consisting cycle panhandle null points head list dsc constructs panhandle list abstract interpretation dsc fig constructs abstract representation linked lists pointed testing application procedure acyclic lists select structures collected exit dsc satisfy formula refer input abstractions satisfying formula type acyclic testing application procedure cyclic lists panhandle select structures collected exit dsc satisfy formula refer input abstractions satisfying formula type cyclic testing application procedure panhandle lists select structures collected exit dsc satisfy formula refer input abstractions satisfying formula type panhandle note formulas ensure input types admits non-empty lists note types represent disjoint collections data structures additionally cross product set lists represented type acyclic set lists represented type cyclic one-toone correspondence 
withthe set lists represented type panhandle acyclic-list component corresponds panhandle panhandle list cyclic-list component corresponds cycle make facts sect abstraction valid input constructed analyzing dsc abstract structuresthatariseat program pointsofreverse tocheckif reverse satisfy query formula testing application procedure lists list null int sizeof list list malloc list ddb null int sizeof list list malloc bbbb cpdact cwct cpd csct cxcu bpbp cdc bbbb cpdact csct cdc cxcu brb bbbb cxcu cpd cpd cdc bbbb cwcxd dbcxd crd ctcpd crddcrd cxcu axbp cdc ddb bqd cwbn figure data-structure constructor acyclic linked lists dsc identical shown fig data-structure constructor possibly-cyclic linked lists including acyclic panhandle lists differences versions bold call instrum final version rev samern samecn samern samecn rev rev rev rev rev rev rev rev rev rev figure instrumentation relations created subformula-based refinement application reverse checked query expressed formula input abstraction type acyclic cyclic represented type acyclic formula testing application procedure lists represented type panhandle check query testing application procedure lists represented type cyclic queries formulas formulan subformula formula evaluates assignment mapsv andv summary individual -valued self-loop relation surprise run abstract interpretation returns indefinite answer checking formula formula column fig shows instrumentationrelations created result call instrum formula evaluated structure collected exit reverse input abstraction type acyclic cyclic transition-relation refinement reverse formula query replaced stored rev occurrences defining formulas rev rev replaced relation symbols column fig shows final version defining formulas relations column fig shows instrumentation relations created result call instrum formula evaluated structure collected exit reverse input abstraction type panhandle cyclic note subformulas acycsame introduced refinement triggered imprecise evaluation structure single concrete individual panhandle relation rev capable maintaining key property nodes panhandle precision refinement iteration required transition-relation refinement reverse formula query replaced stored rev occurrences defining formulas rev rev replaced relation symbols column fig shows final version defining formulas relations introduction instrumentation relations fig depending query verified abstract interpretation dsc performed extended vocabulary instrumentation-relation symbols subsequent abstract interpretation reverse succeeds structures collected exit rev establishing cactdactd terminates establish reverse terminates unary core relations simple progress monitor introduce collection unary core state relations state state state time reversal pointer list node pointed completed line fig node state changed state state relations carry nosemantics withrespect tothepointervaluesof nodes theysimplyrecord visit counts node state relation create copy save values relation start currently-processed loop iteration line fig give relations superscript hold loop-head values abstract operation iteration loop takes snapshot current states nodes statelhi statei eachi assignment ofvto individual abstract state relations added set abstraction relations call instrum final version rev samern samecn cycrev acycsame samern samecn rev rev cycrev acycsame rev rev cycrev acycsame rev rev cycrev acycsame rev acycsame rev cycrev rev rev rev rev rev rev figure instrumentation relations created subformula-based refinement application reverse checked query expressed formula input abstraction type panhandle cyclic compactness refer formula cycrev formula acycsame structure processed additionally asserts point list node state head loop point points node edge reversed operation loop iteration performs progress test asserting formula parenleftbigstatelh state statelh state parenrightbig logicalandtext negationslash logicalandtext parenleftbigstatelh statei parenrightbig assertion ensures node state makes forward progress line assertion node state line assertion assertion point list node state start loop progress monitor establishes list node visited establishing algorithm terminates performance tables shown fig give execution times collected ghz linux rows type data structures assumed input columns query verified case round abstraction refinement required obtain definite answer tothe query words tworounds analysis performed boththe dsc reverse analysis round dsc reverse initial abstraction core relations fig core relation rocn instrumentation relations fig history relations sect round final abstraction additionally includedthe relations fig dependingon query givenabstraction cost dsc analysis identical input types general dsc fig constructs abstraction input types structures represent chosen input type selected end formula gain understanding cost verifying reverse proper tables include execution times analysis round final abstraction reverse excluding analysis time dsc tables fig show tree-shaped-sfen maintenance techniques sect place acyclic-sfen maintenance techniques sect maintaining relation sfpn results reduction total analysis time factor range highest-cost analyses include type panhandle input tree-shapedsfen maintenance iteration analysis reverse input abstraction type panhandle cyclic takes approximately minutes total execution time approximately minutes iteration analysis reverse input abstraction type takes seconds majority total analysis cost cases due general dsc specialized produce input abstractions type acyclic cyclic efficiently dsc shown fig tables fig share qualitative characteristics draw conclusions fig conclusions drawn fig equally expected cost run analysis reverse input abstraction type acyclic cyclic close sum cost input abstraction type acyclic cost input abstraction type cyclic similarly cost run analysis reverse input abstraction type panhandle cyclic close sum cost input abstraction type panhandle cost input abstraction type cyclic curiously total cost analysis input abstraction type panhandle slightly higher total cost input abstraction type panhandle cyclic reason structure type cyclic triggers refinement process earlier point resulting shorter execution run analysis reverse explains counterintuitive relation total execution times cost analysis input abstraction type cyclic total cost cost iteration analysis reverse similarfor queries panhandle query formula results introduction complex abstraction figs costs column fig slightly higher cost verifying reverse terminates negligible compared cost verifying query progress monitor increase size reachable state space analyses represented column fig analyses panhandle query formula acyclic-sfen maintenance maximum approximately query input type acyclic panhandle total total acyclic cyclic acyclic cyclic panhandle panhandle cyclic query input type acyclic panhandle total total acyclic cyclic acyclic cyclic panhandle panhandle cyclic figure execution times seconds acyclic-sfen maintenance maintaining relation sfpn tree-shaped-sfen maintenance maintaining relation sfpn row labels input types acyclic cyclic panhandle cyclic denote abstraction represents lists type label column query acyclic denotes query formula label column query panhandle denotes query formula empty cells inappropriate input query combinations number column represents total execution time iterations analysis dsc reverse number represents execution time iteration analysis reverse dsc memory reported java runtime analyses required significantly memory query input type acyclic panhandle acyclic cyclic acyclic cyclic panhandle panhandle cyclic figure number distinct -valued structures collected iteration analysis reverse dsc rows columns meaning fig sanity check studied number distinct -valued structures collected points reverse run analysis expected information identical analysis relies acyclic-sfen maintenance relies 
tree-shaped-sfen maintenance providing cross-validationof implementationof methods structure counts shown fig figure shows input abstraction type cyclic number structures collected query number structures collected input abstraction type acyclic cyclic sumof thenumberwhen theinput abstraction type acyclic number input abstraction type cyclic similarly number structures collected input abstraction type panhandle cyclic sum number input abstraction type panhandle number input abstraction type cyclic additionally data collected experiments answer instance general question predict work analysis work related analyses correspondence lists represented type lists represented type acyclic lists represented type cyclic made prediction number structures collected analysis reverse input abstraction type panhandle panhandle query based number structures collected analyses reverse input abstraction types acyclic cyclic acyclic query represent numbers structures collected cfg nodenduring analysis reverse input abstraction type acyclic cyclic panhandle cfg node lies loop reverse expect cfg node lies inside loop expect centry aexit cexit centry number structures entry node reverse input abstraction type cyclic aexit number structures collected exit reverse input abstraction type acyclic cexit number structures collected exit reverse input abstraction type cyclic intuition summand formula acyclic structure collected input abstraction type acyclic extended centry panhandle structures structures represent states panhandle reversed cycle entered intuition summand formula cyclic structure collected input abstraction type cyclic extended aexit panhandle structures structures represent states cycle reversed panhandle reversed finally intuition summand formula acyclic structure collected extended cexit panhandle structures structures represent states panhandle un-reversed cycle reversed summation predicted values forpn nodesnof reverse structures prediction short actual number small discrepancy due fact prediction run panhandle query leads abstraction fig based numbers right-hand side quantities formula gathered runs slightly abstraction fig complex abstraction introduced verifying panhandle query apparently creates additional intermediate structures note sum numbers structures collected analyses input abstraction types acyclic cyclic lower number structures collected analysis input abstraction type panhandle sum execution times analyses input abstraction types acyclic cyclic lower execution time analysis input abstraction type panhandle extension work infer properties reverse applied input abstraction type panhandle properties reverse applied input abstractions types acyclic cyclic make find infer properties heap configurations properties components configurations concept local heaps introduced rinetzky relevant line research related work work reported chapter similar spirit counterexample-guided abstraction refinement key difference work prior work model-checking community abstract domain prior work abstract domains fixed finite cartesian products boolean values predicate-abstraction domains relations introduced nullary relations domains predicate abstraction work applies richer class abstractions -valued structures generalize predicate-abstraction domains abstraction-refinement algorithm chapter introduce unary binary ternary relations addition nullary relations demonstrated approach shape-analysis queries approach applicable setting first-order logic describe program states distinguishing feature work method driven counterexample traces imprecise results evaluating query case subformula-based refinement loss information abstraction steps case ilp-based refinement exist theorem provers first-order logic extended transitive closure capable identifying infeasible error traces needed develop techniques slam blast slam identifies shortest prefix spurious counterexample trace extended feasible path general information-loss point occurs end prefix identify earliest points information lost due abstraction instrumentationrelations added abstraction points potential advantage goal-driven information-loss-guided refinement discover relationships establishing query alleviate problem restricted ilp algorithm relations occur query abstraction-refinement techniques abstract-interpretation community capable refining domains based predicate abstraction polyhedrabased domain dynamically refined work based abstract domain led develop approaches abstraction refinement based machine learning astrong albeitoftenunattainable formofabstraction refinement identified goal make abstract interpretation complete optimal case goal extend abstraction answer query make abstraction optimal weakest preconditions generate nullary instrumentation relations generalized manually technique presented produces precise results terminates guaranteed terminate cases contrast method guaranteed terminate automatically generates interesting non-nullary relations unary relation inorderdle whichis crucial showingsortedness thebinary relationr defined formula analysis establish stability insertsort concept data-structure constructor non-deterministically constructs valid inputs program thought mechanism closing open programs related work work relates machine-learning techniques program analysis includes strauss tool machine-learning approach discovering specifications api protocols underlying premise programs bugs hints reveal correct protocols cooperative bug isolation project instruments programs collects information executions statistical machine-learning techniques find bugs mining information crashing non-crashing runs technique finding most-precise abstract set concrete stores expressed logical formula successively approximates result technique related algorithm find-s machine learning search space hypotheses find specific hypothesis satisfies positive examples input concrete stores work represents connection program analysis machine learning shows ilp part abstraction-refinement loop learn abstraction chapter total correctness deutsch-schorr-waite tree-traversal algorithm present chapter discusses automated verification total correctness partial correctness termination deutsch-schorr-waite dsw tree-traversal algorithm past approaches involved hand-written proofs complicated invariants verify partial correctness algorithm automation efforts laborious proof performed jape proof editor pages key advantage abstract-interpretation approach proof-theoretic approaches small number concepts involved defining abstraction structures arise execution verificationis carried automaticallyby symbolicexplorationof memory configurations arise chapter organized sect presents relations encode memory configurations include binary trees sect shows advantage fact kind data structure program manipulates binary tree sect discusses dsw algorithm detail sect presents extension abstraction defined sect employ establishing partial correctness dsw sect explains techniquethat forshowingthe terminationofthe algorithm sect presents experimental results sect makes observations choices made work discusses future directions sect discusses related work typedef struct node struct node left int data struct node tree relation intended meaning pointer variable point heap cellv left left field ofv point tov isv left child ofv field ofv point tov isv child ofv figure declaration binary-tree datatype core relations representing stores manipulated programs type tree binary-tree abstractions root figure store binary tree fig definition binary-tree datatype lists core relations represent stores manipulated programs type tree store fig unary relations represent pointer variables binary relations left represent left fields tree node fig shows -valued structure represents store fig relations fig fig lists instrumentation relations important analysis programs type tree instrumentationrelations suchasrelationrx oftenplayacrucial roleinthedefinitions abstractions relations effect keeping disjoint subtrees summarized separately fig shows -valued structure represents store fig core relations fig instrumentation relations fig unary relations abstraction relations canonical abstraction valued logical structure shown fig tree nodes pointed root represented summary individual bottom nodes left subtree root target indistinguishable subtree toa consisting relations intended meaning defining formula left fields ofv point tov left child ofv tdown isv reachable fromv left fields isv reachable pointer variable tdown left fields figure defining formulas instrumentation relations commonly employed analyses programs 
type tree separate reachability relationrx program variable recall shorthand rtcv root left left lef righ righ rroot rroot rroot rroot rroot rroot root left dow left dow lef righ dow righ dow figure logical structures represents store shown fig graphical form relations fig relations figs relations fig grey unlabeled curved arcs nodes represent thetdown relation self-loops thetdown relation reflexive tuples omitted reduce clutter program variable represents trees elements root node pointed program variable root analyzing programs manipulate trees rroot rroot root lef rig left tdown tdown figure -valued structures canonical abstraction structures addition tos represents tree size pointed program variable root analyzing program data structure point tree property call treeness advantage fact reduce abstract state space explored achieved analysis perform semantic reduction step filter non-trees crept representation analysis relies program maintain treeness guarantee results sound analysis check treeness preserved step address obligation techniques applicable wishes analyze programs input output intermediate data structures trees call analyses tree-specific shape analyses dsw analysis tree-specific shape analysis work tree-specific shape analyses developed includes checking treeness maintained analyzer checks treeness maintained asserting logical formulas capture conditions execution program statement result violation treeness computation transfer function logical formulas assertions evaluated formula possibly fails hold evaluate error report issued analysis terminated purposes thesis binary tree structure cycles nodes multiple incoming left pointers definition disallows sharing subtrees restrictive traditional definition requires path pair nodes inherent limitation tvla sharing subtrees permitted restriction sharing relaxed footnote data structure satisfies data-structure invariants binary tree type statement potential transform data structure violates properties statement form sel sel left creates sel-connection data structure logical formulas capture conditions guarantee application transformer statement form sel maintains treeness formula captures precondition remain acyclic tdown formula captures precondition statement avoid introducing sharing semantic reduction trees application abstract transformer perform semantic reduction filter non-trees crept abstract structures computed transformer reduction implemented application coerce enforce integrity constraints express data-structure invariants instance relation attributes acyclic invfunction acyclic attribute results automatic generation integrity constraint tdown tdown explainedin sect ensure sel null prior assignmentof form sel assignment creates sel-connection relaxed restriction sharing subtrees place formula employ slightly complex formula precludes possibility creating paths pair tree nodes path existed prior statement created due introduction sel edge tdown tdown tdown invfunction attribute results automatic generation integrity constraint operationcoerce appliedat transformer enforce constraints prevent analysis admitting non-trees possibly losing precision deutsch-schorr-waite tree-traversal algorithm original deutsch-schorr-waite algorithm reverses direction left pointers traverses tree attaches bits mark tag node mark bit serves prevent multiple visits nodes cycle shared subtrees tag bit records traversal reversed pointers node reached left child lindstrom gave variant eliminated bits provided input data structure cycles insightwas treat visit step internal node kind pointer-rotation operation completion tree-traversal established algorithm watch distinguished serves kind sentinel chapter lindstrom variant continue refer deutsch-schorrwaite dsw connectionbetween analysis thelindstromvariant andthe original version dsw discussed briefly sect fig shows versions deutsch-schorr-waite algorithm left-hand column shows version adapted lindstrom scanning right-hand column shows slightly modified version algorithm work differences versions constant lines replaced sentinel sentinel assumed distinguished node part input tree tvla pointer values equal null situation pointer point heap object point heap object allocated malloc sense void traverse tree root tree prev cur root null return prev cur root save left subtree curleft rotate pointers crd bqd ctcud crd bqd cxcvcwd crd bqd cxcvcwd ctdabn move forward prev cur cur cur traversal completed break cur null swap prev cur cur prev prev null void traverse tree root tree prev cur root null return prev cbbxc ccc bxc cur root save left subtree curleft rotate pointers crd bqd cxcvcwd bbbb cpcxd cpcxd ctctd ctd crd bqd cxcvcwd cdc crd bqd cxcvcwd ctdabn crd bqd ctcud cdc crd bqd ctcud move forward prev cur cur cur cbbxc ccc bxc traversal completed break cur null swap prev cur cur prev prev null figure original version deutsch-schorr-waite algorithm adapted modified version deutsch-schorr-waite algorithm analyzed tvla differences bold tvla semantics java non-null pointer values generated memory-allocation operations purely local transformation involving introduction temporary variable tmp applied lines curleft curright curright prev tmp curright maintain treeness curright null curright prev curleft null curleft tmp involved transformations assignmentstatementsof form sel sel normalizedtostatement sequences tmp sel sel tmp lines fig assignment statements form sel normalized statement sequences sel null sel lines fig thisensures statementsoftheform sel ycan thedatastructure thereachability tree nodes program variables assignmentscurright null andcurright prevhavebeen movedtolines assignments curleft change prevents child cur target temporarily incoming edges assignment curleft line resulting algorithm maintains invariant nodes input tree make data structures satisfy binary-tree properties assignment line fig nodes input tree make trees assignmentcurright null moved achieve desired effect moved assignments clarity rooted target rooted cur target original root descendant cur target transformations simple normalizations expect find translation programs written high-level language lower-level intermediate representation transformation prevents temporary sharing cur subtree briefly cur left cur subtree relax restriction sharing analyze version algorithm include transformation sect discusses approach task chose verify total correctness preservation treeness slightly modified version dsw algorithm shown fig transformation techniques sect apply analysis version describe version detail tree node body ile loop executed times cur pointing time considered left pointers rotated counter-clockwise fashion lines fig lines fig execution original values left pointers re-established explain execution lines fig cur pointing nodes subtrees rooted left subtrees original tree visited left pointers nodes subtrees rooted modified situation state fig illustrates situation pointer node left child prior rotation left pointers saved line rotation traversal continues moving tree rooted lines cur null values cur prev swappedon lines traversal tobacktrack tothe mostrecently visited node subtree original tree traversal backtracks algorithm reaches lines fig time cur pointing point nodes subtree nodes subtree visited left pointers nodes subtree rotated times restored original values left pointers nodes subtree modified situationwe state fig illustrates situation cur tmp prevn cur prev tmp cur tmp prev nextn cur tmp prev nextn figure states subtree cur pointing execution statement line fig state execution statement line fig state execution statement line fig state execution statement line fig state grey edges represent original values left fields pointer node left child prior rotation 
pointers saved rotation traversal continues moving tree rooted lines algorithm backtracks cur null traversal backtracks algorithm reaches lines fig final time cur pointing point nodes subtrees visited left pointers nodes subtrees rotated times restored original values situation state fig illustrates situation subsequent execution lines fig cur pointing left pointers restored original values point nodes subtree rooted visited left pointers subtree rotated times restored original values situation state fig illustrates situation algorithm traverses tree order visiting node times original left pointers parent subtree backtracking subtree thentraversingr subtree whilebacktrackingfrom subtree throughn ton parent original tree cur figure states tree nodes subtree pointed cur grey edges represent original values left fields fig depicts states tree nodes subtree pointed cur ancestors original tree cur target state indicating left subtree traversed cur target lies left subtree ancestor ancestor state state triangular shapes left represent nodes occur earlier cur target in-order traversal tree nodes exists ancestor cur target node left subtree ancestor cur target subtree ancestor nodes category state visited times left pointers reset original values triangular shapes represent nodes occur cur target in-order traversal tree nodes exists ancestor cur target node subtree ancestor cur target left subtree ancestor nodes category state visited left pointers original values shape abstraction verifying dsw problem establishing version deutsch-schorr-waite algorithm shown fig partially correct assertion compares state store end procedure state start partial correctness dsw means tree produced exit identical input tree node visited back property discuss total correctness dsw sect property left left left denote initial values relations left additionally correct traversal routine lose nodes input tree gain property implied properties challenge abstraction track unintended pointers stack simulationwith sufficient precision verify end algorithm correct usage reestablished canonical abstraction properties listed figs insufficiently precise abstraction demonstrate tree edges restored key relations establishing properties end program capture relationships pointers arise tree nodes traversal set unary relations capture properties nodes state nodes left pointers state nodes left pointer values restored eql left left eqr unary relations eql eqr distinguish individuals represent tree nodes left pointers initial values eql place formula eqr place formula asserting partial correctness dsw set unary relations capture properties nodes state visit nodes rotation left pointers eql left rer left rer unaryrelationeql treenodes whoseleft fieldpoints input tree subtree unary relations rer rer mnemonic reverse distinguish individuals represent tree nodes fields point parents input tree assuming left child case rer child set unary relations capture properties nodes state visits nodes rotations left pointers eqr left rel left left rel left unary relation eqr distinguishes individuals represent tree nodes field points left input tree subtree unary relations rel rel distinguish individuals represent tree nodes left fields point parents input tree assuming thatnis left child case rel child give intuition relations defined formulas partial-correctness verification dsw involves establishing left pointers initial values end dsw relations maintain relationship current original values left pointers prior rotation pointers node entries staterelations formulas change starting pointervalues theseentries allowthe analysistoconcludethat thecurrent iteration srotation pointers entry staterelations formula formulas similarly entries staterelations node establish entries staterelations formula formulas rotation pointers finally entries staterelations node establish entries staterelations formulas rotation pointers initial attempt establish partial correctness dsw added relations formulas set abstraction relations attempt failed terminated analysis days computation vast abstract state space needed explored pare abstract state space observed node distinctions introduced relations formulas instance note leaf node state state satisfies relations formula defineseql nominally staterelation outgoing left pointers internal tree node state state satisfy result eql prevents canonical abstraction summarizing leaf node state internal node states resulting abstraction larger-than-necessary state space ensure tree nodes state left field pointing original subtree property defined relationeql remove unnecessary distinctions introduce concept state-dependent abstraction component abstraction collection unary core state relations state state state state time rotation left pointers tree node pointedtoby cur completed line fig node state changed state state relations carry semantics respect pointer values nodes simply record visit counts node component abstraction introduce state-relation-guarded versions relations formulas eql state eql eqr state eqr eql state eql rer state rer rer state rer eqr state eqr rel state rel state relations added set abstraction relations rel state rel eql state eql eqr state eqr replace relations formulas set abstraction relations formulas resulting abstraction grouping nodes values relationeql long nodes state establishing dsw terminates established dsw terminates unary state relations sect simple progress monitor describe state relation create copy save values relation start currently-processed loop iteration line fig give relations superscript hold loop-head values abstract operation iteration loop takes snapshot current states nodes statelhi statei eachi assignment ofvto individual abstract structure processed additionally asserts cur point tree node state head loop operation loop iteration performs progress test asserting formula parenleftbigstatelh state statelh state statelh state parenrightbig logicalandtext negationslash logicalandtext parenleftbigstatelh statei parenrightbig assertion ensures node state makes forward progress line assertion node state line assertion assertion cur point tree node state start loop progress monitor establishes tree node visited times establishing algorithm terminates show section structure collected analysis dsw exit point non-sentinel node state analysis establishes tree node visited times establishing property partial correctness experimental evaluation applied tvla dsw algorithm shown fig analyzed abstraction defined sect input algorithm supplied -valued structure shown fig essentially structures fig refined values relations introduced sect additionally special sentinel node part input tree referenced program variable sentinel fig fig history relations left omitted reduce clutter values identical values active counterparts omitted values stateand staterelations eql rer rer eqr rel rel non-sentinel nodes figures sentinel nodes performing tree-specific shape analysis figures represent concrete structures satisfy treeness integrity constraints sect fig showstheuniquestructures collectedbytheanalysisat theexitnode thedefinite values relations eql eqr defined formulas individual establish outgoing left pointers tree node restored establishing partial correctness property tree produced exit identical input tree absence violations progress monitor defined sect establishes dsw terminates fact non-sentinel node state establishes tree node visited partial correctness property analysis hours ghz linux memory authors number ideas performance optimizations research system main goal demonstrate feasibility automatic symbolic exploration heap-manipulating programs vast abstract state spaces cost verifying dsw terminates negligible compared cost dsw partially correct progress monitor increase 
size reachable state rroot state eql eqr eql eqr root lef rig left tdown tdown rroot state eql eqr eql eqr state sentinel eql eqr eql eqr tdown figure -valued structures represents trees size rroot rprev state eql eqr eql eqr root prev lef rig left tdown tdown rroot rprev state eql eqr eql eqr rcurr sentinel state eql eqr eql eqr tin tdown figure -valued structures collected exit dsw space thenumberof distinctabstract structures collectedat program pointsexceeded number structures program points exceeded number surprising structures contained individuals intermediate steps structures withupto individuals limit imposed number distinct -valued structures represents number subsets individuals vector unary abstraction-relation values unary abstraction relations pointer relations reachability relations pointer-valued program variables ten relations formulas fig shows sample abstract structures arises line fig structures arise point state relations state-relationguarded relations defined formulas precise values individuals summary experiment showed abstraction defined sect automatic analysis maintain precision identify sufficient invariants demonstrate partial correctness termination dsw discussion future work analysis carried tvla performs fully-automatic state-space exploration bring bear expertise tvla analyses concept tree-specific shape analysis sect general utility reused analysis input output intermediate data structures trees instrumentation relations defined formulas capture pointer relationships tree nodes core state relations state state control precision abstraction specific problem verifying total correctness dsw key difference approach theorem-prover-based approaches loop invariants collection node distinctions node relationships relations eql rer formulas node distinctions observable analysis node distinctions abstract interpretation automatically infers invariants satisfied program cur state cur state cur prev state prev root state prev root sentinel state prev root sentinel tmp state cur tmp state prev state prev left leftdown leftdown rightdown state cur tmp left left downt rightdown left figure -valued structures arises prior rotation pointers node pointed cur line fig history relations omitted figure initially node child node pointed prev node root tree leaf sentinel original root parent sentinel nodes subtree visited subtree modified initial state chapter showed machine-learning technique identify key instrumentation relations automatically future identify key relations verifying dsw relations formulas instrumentation relations introduced sect tailored establishing correctness dsw concept state-dependent abstractions general utility fact simpler versions state-dependent abstractions arisen past work unary relation inorder establish partial correctness sorting statedependent abstractions defined chapter prepared deal states initial final case relation inorder state guard reduce number distinct properties recorded individuals reducing size abstract state space explored interesting analogy explicit state-tracking original dsw algorithm performs mark tag bits state relations abstraction sense state relations introduced purposes analysis impose dsw-like view world track actions lindstrom variant algorithm chose apply transformation ensures algorithm maintains treeness transformation sect verify unmodified algorithm fig introducing instrumentation relation islocallyshared left relation islocallyshared nodes input -valued structure indicating input valid binary tree relax restriction sharing tracking sharing occurs requiring absence applicable version algorithm include transformation tree-specific shape analysis sect generalized tohandlethe limitedclass dags arisein lines fig precondition absence sharing formula removed integrity constraints forbid structures sharing modified includean islocallyshared guard topermit kindof local sharingthat arises infig constraint islocallyshared dsw algorithm shown fig algorithm shown fig work correctly applied data structure cycle traversal terminates prematurely edges properly restored algorithm works correctly applied dag node paths root visited times times note exponential size graph bound verify correctness dsw dags relax restriction sharing introduce state relations state-relation-guarded relations unlessk small reachable state space explored computing resources general case input dag bound partial-correctness result obtained state relations nodes wrap visit node state results changing node state change sufficient establish outgoing left pointers dag node restored node visited analysis longer establish termination simple progress monitor sect inpractice potentially exponential cost applications process node depth-first order visit node constant number times achieved equipping nodes bits record visit count number nodes reachable node visit count visited times cur set point node visit count direction traversal reversed swapping values cur prev terminating exploration node subgraph relaxing restrictiononsharing correctness ofthemodifiedalgorithm dsw traverse dag algorithm temporarily create cycle data structure input dag forward edges case techniques sect techniques sect maintenance relation tdown apply general approach sect maintenance reachability possibly-cyclic deterministic graphs address limitation related work general form deutsch-schorr-waite algorithm works correctly arbitrary graphs unlike algorithm work general form constant-space mark tag bits divide discussion related work kind data structures analyzed algorithm applied dsw arbitrary graphs formal proofs partial correctness dsw performed manually morris topor suzuki automated steps partial-correctness verification algorithm introducing decision procedures handle heap-manipulating programs recently bornat jape proof editor construct partial-correctness proof dsw resulting proof pages automated approach obvious benefit disposing provide manual proofs require significant investments time expertise presence powerful theorem prover proof-based approaches rely user provide loop invariants sufficient establish property verified instance properties nodes subtrees sect figs text loop invariants discussed sect obligation simpler instrumentation relations act ingredients loop invariant analysis automatically synthesizes loop invariant form collection -valued structures overapproximate set concrete structures arise means state-space exploration discussion relies reported yang mehta nipkow gave manually-constructed machine-checkable proofs partial correctness dsw approaches share goal making formal reasoning heap-manipulating programs natural approach logic bunched implications precursor formalism separation logic permits user reason hoare triples presence complicated aliasing relationships approach isabelle holtoconstruct formal proofs human-readable approaches improve usability proof-based techniques lack automation approach dsw trees dags yelowitz duncan present termination argument deutsch-schorrwaite algorithm analyzed knuth version algorithm tag bits work correctly graphs cycle work dags version termination argument involved program invariants prove bounds number executions statements loop sect showed state relations defined sect simple progress monitor algorithm loop establish dsw terminates trees case partial correctness task reduced establishing distinctions nodes state relations complete state-space exploration shows violation progress monitor establishes bound number visits tree node algorithm terminate previouspapers reported weaker properties thedeutschschorr-waite algorithm algorithm unsafe pointer operations memory leaks data structure produced end fact binary tree authors established properties typo stating work establishes partial correctness reused tvla specification establishes properties finally extended framework grammars provide convenient syntactic sugar expressing shape properties data structures work relied grammars instrumentation relations express tree properties absence memory leaks chapter semantic minimization -valued propositional formulas studying question precision analyses based -valued logic encountered non-standard arises -valued propositional logic present chapter formalization semantic-minimization 
problem methods creating semantically minimal formula interest problem motivated possibility obtaining answers applications -valued logic answer precise definite information answer imprecise indefinite information replacing formula semantically-minimal equivalent improve precision answers obtained chapter organized sect introduces terminology notation sect defines problem semantic minimization -valued propositional logic sect presents couple methods performing semantic minimization sect defines semantic-minimization algorithm efficiency binary decision diagrams stages sect discusses related work proofs app terminology notation section define standard -valued propositional logic related valued propositional logic semantics due kleene -valued propositional logic write propositional formulas set propositional variablesvusing propositional constants unary connective binary connectives make conditional expressions adopt c-like syntax brevity juxtaposition place overbar denote negation written asxyz xyz propositional variables negations propositional variables referred collectively literals -valuedtruth-functional semanticsfor propositionallogicis definedinthestandardway definition assignmentais finite function inv givena formula propositional variables assignmenta defined -valued truth-functional meaning respect denoted truth defined inductively min max thatasatisfies denoted bya iff lateron syntactically related ways denote syntactic equality formulas rearrangements conjuncts disjuncts denote extended applications shorthand defn technical reasons shorthand defn morgan laws introductions cancellations double negations instance negationslash negationslash formulas -valued truth-functional meaning reserve semantic equality -valued propositional logic moving -valued logic language formulas work identical defined sect additional propositional constant semantic level truth introduced denote uncertainty values definite values indefinite define partial order truth values reflect degree definiteness information content denotes thatl definite asl definition information order forl define information order truth values iffl orl usel whenl andl negationslash symbol denotes least-upper-bound operation respect generalize defn define meaning formula respect -valued assignment convention lower-case letters -valued assignments upper-case letters -valued assignments definition -valued assignment finite function formula propositional variables assignment defined -valued truth-functional meaning respect denoted yields truth meaning defined inductively defn potentially satisfies denoted iff -valued truth tables propositional operators shown fig -valued logic yield equivalent definitions -valued truth-functional meaning -valued logic yields precise semantics truth table sub-table obtained evaluating identical truth table defn yields definite whenv andv assignment mapsto mapsto yields indefinite yields vantage point binary connective constructing formulas shorthand noted remainder chapter symbol means potential-satisfaction relation defn talking -valued assignment instance pmapsto pmapsto figure -valued truth tables propositional operators information order logical order figure semi-bilattice -valued propositional logic shown fig values form mathematical structure semibilattice semi-bilattice orderings information order logical order information order defined defn captures certainty logical order fig meet join logical order logical order potential truth called designated designated values assignment potentially satisfies formula formula truth-functional meaning respect designated values information ordering values extended pointwise information ordering assignments denoted pmapsto qmapsto pmapsto qmapsto pmapsto qmapsto pmapsto qmapsto pmapsto qmapsto pmapsto qmapsto bindings propositional variable definite write lower-casea kleene fig anddefn lemma formula assignments kleene semantics retains number properties familiar -valued logic including morgan laws ability introduce cancel double negations reason relate formulas semantically equivalent -valued logic lemma relate -valued -valued truth-functional meanings formulas obtained evaluating formula respect -valued assignment safe greater equal information order compared obtained evaluating respect -valued assignmenta yields definite yield definite yields -valued assignmentarepresents -valued assignmentsa outlook -valued -valued assignments related stems corollary immediately lemma corollary suppose thatarepresentsa ifa thena propositional formula -valued logic device accepting set -valued assignments considered formula -valued logic potentialsatisfaction relation corresponds implicit condition accepting rejecting entire set valued assignments represented -valued assignment acceptance potential-satisfaction relation safe respect actual set -valued assignments accepted assignments arep bya point view -valued assignments space abstract values abstract interpretation chou account symbolic trajectory evaluation abstractinterpretation terms adopt viewpoint sect order justify definition semantic-minimization problem semantic minimization problem chapter observed formula equivalent -valued logic -valued logic raises question formula turn raises question properties formula possess definition minimization problem concept formula formalized concept formula supervaluational meaning definition formula assignment -valued supervaluational meaning respect toa denoted truth defined unionsqdisplay rep definition propositional formula formula semantically minimal variant iff -valued assignments semanticminimization problem propositional logic propositional formula find formula semantically minimal variant instance semantically minimal variant ofp pmapsto unionsqdisplay pmapsto pmapsto pmapsto similarly semantically minimal variant ofp justification problem definition worthwhile spend moments defn definition semantic-minimization problem contrast defn alternative definition strawman definition propositional formula semantically minimal variant iff -valued assignmentsa motivation definition place obtain answers strictly definite obtain answers strictly definite question obtain acceptable answers strawman defn notethatwithdefn incontrast strawman defn formulas semantically minimal variants situation trouble meanings conflict strawman defn admissible semantically equivalent -valued logic contrast defn admissible semantically equivalent -valued logic definition meaning supervaluational meaning strawman defn unsatisfactory concepts semantically minimal variant relate view formula device accepting set assignments discussion cor desideratum acceptance device view formula device accepting set assignments correspond acceptance device applied assignment -valued -valued yield precise acceptance condition circumstances waffles waffle accepta rejecta safe respect -valued assignments accepts assignments arep bya similarly safe respect -valued assignments accepts assignments arep bya instance suppose formula strawman defn formula admissible eqn hold assignments assignments negationslash arep bya similarly strawman defn formula admissible eqn hold assignments assignments negationslash arep bya defn admissible eqns hold notion acceptance device expressed nicely parallels statement cor consequent desideratum acceptance device semantically minimal variant -valued assignment -valued assignment represents hold ifa thena ifa thena contrast unsatisfactory results obtained strawman defn properties desideratum parallel property stated cor property stated cor replaced lemma semantically minimal variant means concept defined defn desideratum holds proof desired properties restated proved unionsqdisplay rep unionsqdisplay rep unionsqdisplay rep unionsqdisplay rep henceforth term semantically minimal variant means concept defined defn strawman defn motivated desire obtain precise answers place fact defn property lemma semantically minimal variant -valued assignments proof semantically minimal variant monotonicity lemma unionsqdisplay rep term semantically minimal variant lemma semantically minimal variant formula agrees -valued assignments -valued assignmentsa proof semantically minimal variant monotonicity lemma unionsqdisplay rep unionsqdisplay rep algorithm semantic minimization return question formula answer affirmative precisely formula equivalence class formulas whichmayormaynotcontain duetoblamey relates boolean functions -valued propositional formulas result stated couple forms yield methods creating formula sect focus special case blamey result variant define efficient minimization algorithm realization monotonic boolean functions formulas section review theorem due blamey relates monotonic boolean functions -valued propositional formulas formula realizes function iff blamey theorem states -valued function monotonic information 
order formula built propositional variables realizes blamey proof result explicit method constructing formula realizes givenf definition letf anymonotonicfunctionin letabe -valued assignment defined define slight abuse notation refer boolean function member make applications -valued assignment inv confusion result thinks function formal parametersx assignmenta supplying values forx convention statements type formula iff anda iff anda iff anda iff iff anda iff anda iff anda iff logicalordisplay logicalanddisplay logicalanddisplay logicalordisplay formula theorem realization theorem monotonic function formula realizesf formula proof formula truth-functional semantics shown truth table twenty-seven disjuncts xyz xyz xyz xyz xyz xyz twenty-seven conjuncts andx formula created eqn formula xyz xyz xyz xyz xyz xyz reader verify eqn realizes truth table defn subtle instance assignmentaon whichf evaluates contributes conjunction logicalanddisplay formula necessarily necessarily due contributions terms capture behaves assignments logicalanddisplay effects blamey shown realization theorem holds applying morgan laws derive variants eqn lead variant forms eqn formula formula formula eqn formula constructed form sum-of-products product-of-sums eqn form sum-of-products sum-of-products instance eqn place eqn eqn formula xyz xyz xyz xyz xyz xyz xyz xyz creating semantically minimal variant defn eqns give tools needed construct semantically minimal variant formula theorem minimization theorem formula semantically minimal variant proof immediately defn supervaluational semantics monotonic function meets conditions theorem formula theorem semantically minimal variant formula table shows -valued assignmentsafor xmapsto ymapsto zmapsto xmapsto ymapsto zmapsto xmapsto ymapsto zmapsto supervaluational semantics formula created semantic-minimization algorithm eqn formula xyz xyz xyz xyz xyz xyz xyz xyz comparing eqn note additional disjuncts part eqn andx correspond entries truth table truth table improved construction formula blamey thesis improved construction formula results formula fewer complicated constituents definition letf monotonic function abe -valued assignment defined formula defined eqns redefined logicalordisplay logicalanddisplay logicalanddisplay logicalordisplay empty disjunction empty conjunction differences eqns eqns outer connectives indexed leads fewer terms generated indices connectives range values ofifor whicha definite generate literals leaving unnecessary occurrences formula discussed exs suppose formula defined eqn defined defn formula created formula formula xyz xyz eqn semantically minimal variant created formula formula xyz xyz eqn theorem letf monotonic function formula formula defined eqns formula realizesf formula proof henceforth operations defined defn eqns bdd-based minimization algorithm section presents improved algorithm semantic minimization worst-case running time algorithm exponential size operations implemented bdds issues face material presented sects efficiently represent function eqns efficiently implement indexing operations needed outermost connectives approach issue bdds approach issue based observation observation realization theorem construct -valued propositional formula realizes monotonic boolean function realization problem arises semantic-minimization problem require general method semantic-minimization problem monotonic boolean functions arise range concerned realization problems form formula focusing special case realization problem sidestep issue implementing differently stated eqns approach takes advantage bdd-based representation address issue representing supervaluational semantics goal find semantically minimal variant truth-valuational semantics equal supervaluational semantics unionsqdisplay rep order capture concern truth-functional semantics definite assignments portion truth-functional semantics words functions functions functions type called boolean functions don cares incompletely boolean functions incompletely boolean function represented pair total boolean functions functions denoted conflates conflates iff iff iff iff represented ordinary bdds proposed minato capture function represented pair functions formula propositional variablesx accomplished traversing applying translation rules bottom-up operations total boolean functions required right-hand sides rules standard repertoire bdd operations creation bdds application boolean operations existing bdds ite types boolean functions play role chapter -valued boolean functions incompletely boolean functions total boolean functions introduce special notation distinguish functions types terms form denote total boolean functions occurrences denote incompletely boolean functions total boolean functions denote -valued boolean functions clear context intended realization semantic minimization definition superscripted propositional variablexb whereb stands literal ifb ifb letf total boolean function propositional variablesx conjunction literals propositional variable appears negated unnegated logicalanddisplay xbii implicant -valued assignmentasuch thata alli conjunction literals form shown thought set literals xbii implicant prime implicant proper subsets implicant corresponds conjunction literals implicant xyz implicants implicants andxz prime implicants concern realization problems form formula show case realization implemented formula primes primes primes operation total boolean function creates disjunction prime implicants primes logicalordisplay prime implicant lemma -valued assignment formula logicalanddisplay prime implicant proof app lemma prime implicant -valued assignmentasuch alla iii logicalanddisplay proof app results yield procedure semantic minimization theorem primes primes semantically minimal variant proof defn eqn lemmas primes represented translation method equals implies primes primes claim theorems formula minimizeformula formula transform translation method return primes primes figure minimization algorithm theorem justification function minimizeformula shown fig propositional formula input minimizeformula creates returns semantically minimal variant minimizeformula auxiliary procedure primes creates sum-of-prime-implicants formula formula methods efficiently generating prime implicants step methods start bdd representation line implemented bdds kind input structure hand return formula exs minimizeformula create formula eqn minimizeformula arrive answer efficient method formula xyz xyz drawback minimizeformulais generate prime implicants substitute sum-of-products expressions represent function valued logic irredundant prime cover approach tenable instance formula substitute irredundant-prime-cover algorithm calls primes line minimizeformula formula xyz xyz formula semantically minimal variant assignment mapsto ymapsto zmapsto eqn evaluatesto formula evaluatesto formula worse eqn assignment xmapsto ymapsto zmapsto eqn evaluate formula evaluates semantically minimal formulas section derive forms subject theorem express semantically minimal formula proof theorem found app theorem iff total boolean function primes primes proof theorem showed primes primes imply primes primes applying theorem results relationships primes primes mix match eqns create expressionsthat onegivenintheorem function minimizeformula fig creates semantically minimal variant expressions line sum-of-products sum-of-products sum-of-products primes primes primes primes sum-of-products primes primes primes primes term sum-of-products form put product-of-sums form blow-up size applying morgan laws create semantically minimal formula combination sum-of-products product-of-sums terms desire final result condition generate semantically minimal variant occurrence corollary suppose formula total boolean function primes primes semantically minimal variants proof total boolean function result eqns elimination duplicate terms diagonal entries table formula explicit occurrence semantically minimal variant occurrence formula -valued logic treated syntactic shorthand sect discussed suitable syntactic shorthand extension -valued logic suitable shorthand derive means results semantic minimization explicit occurrence total boolean function primes semantically minimal variant related work substantial body work addresses methods syntactic minimization propositional formula previous work addressed finding minimal-size sum-of-products formulas minimal-size formulas forms contrast chapter concerns semantic minimization -valued propositional logic minimization 
criterion semantic syntactic formula results necessarily smaller realization problem versions realization theorem due blamey blamey work address semantic-minimization problem defined sect sect focused special case realization problem allowed define semantic-minimization algorithm minimizeformula efficient general realization constructions blamey motivation investigating semantic-minimization problem propositional logic heuristic creating formulas -valued first-order logic transitiveclosure operator applying finite-differencing transformations defining formulas instrumentation relations replacing formula formula improve precision answers system obtains implemented minimizeformula subroutine heuristic method minimizing first-order formulas method works formula bottom-up applying minimizeformula body non-propositional operator quantifier transitive-closure operator chapter conclusions future work thesis addressed fundamental challenges applying abstract interpretation program concrete semantics language query interest create abstraction sufficiently precise verify program satisfies query create abstract transformers challenge arises program-analysis problems semantics statements expressedusinglogicalformulas thatdescribechanges tocore-relationvalues instrumentation relations introduced refine abstraction challenge reflect core-relation values values instrumentation relations algorithm presented chapter create formulas maintain correct values instrumentation relations generate completely automatically part transformers abstract semantics deals instrumentation relations research motivated work static analysis based -valued logic analysis method relies logic -valued -valued express program semantics benefit techniques chapter addressed challenge presenting approach creating abstractions automatically program analysis previous work approach involves successive refinement abstraction unlike previous work work presented chapter aimed programs manipulate pointers heap-allocated data structures demonstrated approach shape-analysis problems approach applicable program-analysis setting first-order logic refinement performed introducing instrumentation relations defined logical formulas core relations abstractionrefinement method refinement strategies strategy analyzes sources imprecision evaluation query chooses define instrumentation relations subformulas query strategy ilp-based refinement employs inductive logic programming learn instrumentation relations stave imprecision due abstraction steps ilp forming boolean combinations existing relations refinement techniques based predicate abstraction ilp create relations introducing quantifiers learning process chapter discussed automated verification total correctness partial correctness termination deutsch-schorr-waite tree-traversal algorithm past approaches involved hand-written proofs complicated invariants verify partial correctness algorithm automation efforts laborious proof performed jape proof editor pages key advantage abstractinterpretation approach proof-theoretic approaches small number concepts involved defining abstraction structures arise execution verification carried automaticallyby symbolicexplorationof memory configurations arise studying question precision analyses based -valued logic encountered non-standard logic-minimization problem arises -valued propositional logic chapter presented formalization semantic-minimization problem showed semanticallyminimal formula exists gave methods creating semantically-minimal formulas discussion methodology work makes powerful logic expressing semantics programs query interest logic first-order logic extended transitive-closure operator user express properties transformations heapallocated data structures ease convenience cost logic fragments expressive stating interesting properties heap-allocated data structures undecidable semi-decision procedures logic exist performance theorem provers implement makes prohibitively expensive verification tasks present time work chose rely theorem provers key operation analysis formula evaluation deductive step presented non-standard issue pair formulas equivalent equivalent analysis give instances issue arises state techniques led develop addressing instance issue formula equivalent formula evaluates precise assignment pmapsto observation led formalize problem semantic minimization define algorithms computing semantically-minimal formulas formula equivalent formula defining formula frequently evaluate precise observation led work finite differencing mechanism update values instrumentation relations maximizing reuse stored values instrumentation relations additionally led work abstraction-refinement method introduces instrumentation relations serve sources stored values abstraction-refinement method intended remove obligation identifying loop invariantsand translatingthem intoappropriate abstractiondefinitions theabsence decision procedure identifying loop invariants design techniques extract information logical structures arise abstract interpretation decided forego deductive techniques favor viewing logical structures unstructured collections values learning relationships present collections future work heap-allocated data structures offers programmer great flexibility result data structures ubiquitous today software code manipulates heapallocated storage harbor errors unnecessary slowdowns potential resource bottlenecks plan continue research develop tools program understanding debugging reverse engineering apply analysis programs manipulate heapallocated data structures expressive power research system makes suitable settings shape analysis future work address important issues quality software concurrency information flow tvla power automatic exploration suitable solving challenging problems arise computer architecture verification cache-coherence protocols effort design scalable analysis intrigued possibility defining parsimonious abstractions introduced software-model-checking community parsimonious abstractions precision abstraction vary program point application inductive learning points program offers interesting possibilities regard inductive learning interesting applications software model checking standard abstraction mechanism predicate abstraction groups states based values set nullary logical formulas extension foil algorithm permit learning nullary formulas differentiate set structures makes refine abstraction predicate-abstraction framework inventing relations capture properties heap-allocated storage broader context plan continue mine connections program analysis machine learning exposed thesis program code comments annotations specifications descriptor behavior program explore machine-learning techniques employed extract interesting information static dynamic analyses domain program understanding interesting application techniques apply inductive learning inferring loop invariants automatically application suggests obvious integrate approach proof-based approaches verification manually defined loop invariants prevents widespread proof-based systems inductive learning inferring loop invariants automatically address limitation application inductive learning domain program understanding summarize effect statements entire procedures inductive learning application benefit program analysis creating summary transformers application system invoke learning algorithm learn formula static analysis data gathered dynamic analysis static analysis verify formula invariant program instances experiments presented chapter learning resulted relations defined formulas capture interesting properties sorting procedures procedure reverse interesting challenge describe essence bug fix states fixed sources application understanding documenting change regression-test generation suppose analyzed software system consists client server client respect server api client respects api specification api learning specification mining infer api based states clients additionally api answers produced learning algorithm suggest fixes bring incorrect client line correct api correct client search fix buggy client performing small perturbations program interchange system calls collection perturbations results learning specification agrees server api fix obtained success delta debugging hope approach feasible learning serve bridge gap testing verification application learning results testing data collected dynamic analysis inform verification helping construct abstraction based states observed testing dynamic analysis algorithms manipulate linked data structures storeless invariants algorithm abstraction sufficient verify algorithm correctness stated properties nodes regions data structure algorithm manipulates insertsort deutsch-schorr-waite examples storeless algorithms learning applied learn properties hold nodes region hand search performed learning algorithm abstract states computed verification find key differentiators good bad states helping construct test cases drive code good bad states anticipate learning occupy prominent place future research large software systems today important automate tasks left user instance research today focuses verifying software system conforms existing formal specification unrealistic expect formal specifications software systems specifications apis 
learning hold key future endeavors program understanding verification testing reverse engineering providing techniques infer specifications verification conditions abstractions test cases regions defined terms reachability relations list akers theory boolean functions society industrial applied math december ammons bodik larus mining specifications symp principles programming languages pages january ball majumdar millstein rajamani automatic predicate abstraction programs conf programming language design impl june ball rajamani automatically validating temporal safety properties interfaces spin workshop model checking software pages blamey partial-valued logic phd thesis univ oxford oxford eng blamey partial logic gabbay guenthner editors handbook phil logic vol alternatives classical logic pages reidel publishing blamey partial logic gabbay guenthner editors handbook phil logic vol pages kluwer acad bornat proofs pointer programs jape http dcs qmul tildewiderichard pointers bornat proving pointer programs hoare logic mathematics program construction pages july bornat sufrin animating formal proofs surface jape proof calculator computer journal brace rudell bryant efficient implementationof bdd package design automation conf pages june bryant graph-based algorithms boolean function manipulation ieee trans comp august chase wegman zadeck analysis pointers structures conf programming language design impl pages june chou mathematical foundation symbolic trajectory evaluation computeraided verification springer-verlag july clarkandt niblett thecn inductionalgorithm machinelearning clarke grumberg jha veith counterexample-guided abstraction refinement computer-aided verification pages july colby godefroid jagadeesan automatically closing open reactive programs conf programming language design impl pages june coudert two-level logic minimization overview integration vlsi journal october coudert madre graph based prime computation technique sasao editor logic synthesis optimization pages kluwer acad january coudert madre fraisse touati implicit prime cover computation overview workshop synthesis system integration mixed information technologies sasimi october cousot cousot systematic design program analysis frameworks symp principles programming languages pages january das dill counter-example based predicate discovery predicate abstraction formal methods computer-aided design pages november das dill park experience predicate abstraction computer-aided verification pages july dong incremental decremental evaluation transitive closure firstorder queries information computation dong incremental maintenance recursive views relational calculus sql sigmod record dor rodeh sagiv checking cleanness linked lists static analysis symp june flach framework inductive logic programming muggleton editor inductive logic programming volume apic series pages academic press flanagan software model checking iterative abstraction refinement constraint logic queries workshop constraint programming constraints verification march giacobazzi ranzato scozzari making abstract interpretations complete acm ginsberg multivalued logics uniform approach inference artificial intelligence computational intelligence gopan dimaio dor reps sagiv numeric domains summarized dimensions tools algs construction analysis systems pages march graf construction abstract state graphs pvs computer-aided verification pages june gupta mumick editors materialized views techniques implementations applications press cambridge helft induction nonmonotonic inference principles knowledge representation reasoning pages hendren parallelizing programs recursive data structures phd thesis dept computer science cornell january henzinger jhala majumdar mcmillan abstractionsfrom proofs symp principles programming languages pages january hesse dynamic computational complexity phd thesis dept computer science massachusetts june immerman rabinovich reps sagiv yorsh boundary decidability undecidability transitive closure logics workshop computer science logic pages september immerman rabinovich reps sagiv yorsh verification structure simulation computer-aided verification pages july ishtiaq hearn assertion language mutable data structures symp principles programming languages pages january jeannet halbwachs raymond dynamic partitioning analyses numerical properties static analysis symp pages september jeannet loginov reps sagiv relational approach interprocedural shape analysis static analysis symp pages august jones muchnick flow analysis optimization lisp-like structures program flow analysis theory applications pages prentice-hall klarlund schwartzbach graph types symp principles programming languages january kleene introduction metamathematics north-holland edition knuth art computer programming vol fundamental algorithms addisonwesley kurshan computer-aided verification coordinating processes princeton press lahiri qadeer verifying properties well-founded linked lists symp principles programming languages pages january lakhnech bensalem berezin ands owre incremental tools algs construction analysis systems pages april lavra zeroski inductive logic programming techniques applications ellis horwood lee yang automatic verification pointer programs grammarbased shape analysis european symp programming pages april lev-ami immerman sagiv fast precise abstraction shape analysis computer-aided verification pages august lev-ami reps sagiv wilhelm putting static analysis work verification case study int symp software testing analysis pages august lev-ami sagiv tvla system implementing static analyses static analysis symp pages june liblit aiken zheng jordan bug isolation remote program sampling conf programming language design impl pages june lindstrom scanning list structures stacks tag bits information processing letters june liu stoller teitelbaum discovering auxiliary information incremental computation symp principles programming languages pages january liu teitelbaum systematic derivation incremental programs science computer programming february manevich sagiv ramalingam field partially disjunctiveheap abstraction static analysis symp pages august manevich yahav ramalingam sagiv predicate abstraction canonical abstraction singly-linked lists verification model checking abstract interpretation pages january mcmillan verification infinite state systems compositional model checking correct hardware design verification methods charme pages september mehta nipkow proving pointer programs higher-order logic int conf automated deduction cade pages july minato fast generation irredundant sum-of-products forms binary decision diagrams workshop synthesis system integration mixed information technologies sasimi pages april minato ishiura yajima shared binary decision diagram attributed edges forefficient design automationconf pages june mitchell machine learning mcgraw-hill york june ller schwartzbach pointer assertion logic engine conf programming language design impl pages june morris verification-oriented language design tech report trcomputer science div california berkeley december muggleton inductive logic programming generation comp muggleton raedt inductive logic programming theory methods logic programming nelson verifying reachability invariants linked structures symp principles programming languages pages january paige koenig finite differencing computable expressions trans programming languages systems toplas july pasareanu dwyer visser finding feasible counter-examples model checking java programs tools algs construction analysis systems pages april patnaik immerman dyn-fo parallel dynamic complexity class computational systems science october quine problem simplifying truth functions american mathematical monthly october quinlan learning logical definitions relations machine learning quinlan cameron-jones foil midterm report european conference machine learning pages april quinlan cameron-jones induction logic programs foil related systems generation comp special issue ilp ramalingam warshavsky field goyal sagiv deriving specialized program analyses certifying component-client conformance conf programming language design impl pages june reps sagiv loginov finite differencing logical formulas static analysis european symp programming pages april reps sagiv yorsh symbolic implementation transformer verification model checking abstract interpretation pages january reynolds separation logic logic shared mutable data structures 
symp logic computer science pages july rinetzky bauer reps sagiv wilhelm semantics procedure local heaps abstractions symp principles programming languages pages january rinetzky sagiv interprocedural shape analysis recursive programs int conf compiler construction pages april sagiv reps wilhelm parametric shape analysis -valued logic trans programming languages systems toplas sasao ternary decision diagrams applications sasao fujita pages sasao fujita editors representations discrete functions kluwer acad schorr waite efficient machine independent procedure garbage collection list structures communications acm august shaham yahav kolodner sagiv establishing local temporal heap safety properties applications compile-time memory management static analysis symp pages june sharir observationsconcerning formal differentiationof set theoretic expressions trans programming languages systems toplas april suzuki automatic verification programs complex data structures phd thesis dept computer science stanford february tkachuk dwyer pasareanu automated environment generation software model checking automated software engineering pages october topor correctness schorr-waite list marking algorithm tech report mipr- school artificial intelligence edinburgh july tvla system http tau tildewidetvla van fraassen singular terms truth-value gaps free logic philosophy september yahav verifying safety properties concurrent java programs -valued logic symp principles programming languages pages january yahav ramalingam verifying safety properties separation heterogeneous abstractions conf programming language design impl pages june yahav sagiv automatically verifying concurrent queue algorithms electronic notes theoretical computer science yang local reasoning stateful programs phd thesis dept computer science illinois urbana-champaign june yelowitz duncan abstractions instantiations proofs marking algorithms insymp pages august yorsh reps sagiv wilhelm logical characterizations heap abstractions acm transactions computational logic tocl zeller yesterday program worked today european software engineering conf esec fse pages september zeller automated debugging close ieee computer pages november appendix correctness finite-differencing scheme sect proofs section induction size measure formulas based process putting core normal form assumption circular dependences definitions instrumentation relations put core normal form repeated substitution core relations remain size measure basically size put core normal form occurrence instrumentation relation encountered process counted larger size measure defining formula relation substituted formal parameters proofs standard structural-induction proofs case permitted assume induction hypothesis holds recall sect results couched terms -valued logic embedding theorem theorem theorem relation-maintenance formulas define provide sound results interpreted -valued logic first-order formulas correctness extension finitedifferencing scheme reachability transitive closure argued sect lemma lemma formula statementst properties hold meta fst meta fst iii fst meta fst fst meta fst fst fst meta fst fst simplify presentation lhs meta rhs lhs meta rhs shorthands lhs rhs lhs rhs anys -struct assignmentz complete lhs rhs fst meta fst fst meta fst proof atomic cases follow immediately formp meta meta meta definitions fst meta meta meta meta definitions fst formp meta meta meta definitions fst meta meta meta meta meta definitions fst formp meta meta meta meta meta definitions fst meta meta meta meta definitions fst forms meta meta meta definitions fst meta meta meta meta definitions fst forp meta meta inductive hypothesis meta defining formula forp meta meta fst inductive hypothesis meta defining formula forp meta meta fst inductive hypothesis meta inductive hypothesis iii meta meta inductive hypothesis meta fst meta fst inductive hypothesis iii iii fst meta meta meta definitions meta meta meta meta fst inductive hypothesis meta fst meta part iii proved independently meta fst fst meta fst fst fst fst inductive hypothesis meta fst fst meta fst fst meta fst part iii proved independently iii fst meta meta bracketleftbig fst fst bracketrightbig definitions meta bracketleftbig fst fst bracketrightbig bracketleftbig bracketrightbig meta bracketleftbig fst fst bracketrightbig meta fst fst meta fst fst fst fst fst fst fst fst meta fst fst weconsiderthetencases correspond cases ten disjuncts formula holds case concerns disjunct fst fst conjunct trivially implies fst fst holds remaining cases meta meta meta definition fst meta meta meta definition fst meta meta meta definition fst meta meta meta definition fst direction fst fst meta fst loss generality assume fst holds cases holds holds show cases imply disjunct formula holds disjunct formula holds fst hold holds formula holds assume holds meta fst inductive hypothesis meta rhs disjunct formula assume holds subcases holds holds assume holds meta meta inductive hypothesis meta fst definition fst meta rhs disjunct formula holds subcase result implies disjunct formula holds entries derived meta meta definition meta fst fst definition meta fst fst definition inductive hypothesis iii meta meta definition meta definition meta definition exists meta definition meta meta bracketleftbig fst bracketrightbig meta bracketleftbig bracketrightbig definitions meta definition fst meta fst definition meta fst meta inductive hypothesis meta fst bracketleftbig bracketrightbig meta bracketleftbig fst bracketrightbig meta bracketleftbig bracketrightbig definitions meta fst definition fst iii direction fst meta fst fst meta meta bracketleftbig fst bracketrightbig definitions meta fst cases correspond cases disjunctsof formula holds case concerns middledisjunct fst conjunct remaining cases assume holds meta meta meta fst definition fst assume holds meta meta meta fst definition fst direction fst meta fst fst meta definition fst meta meta cases correspond cases disjuncts formula holds assume holds meta meta meta fst definition fst meta bracketleftbig fst bracketrightbig meta bracketleftbig fst bracketrightbig meta definitions meta definition fst assume holds subcases holds holds assume holds meta meta fst definition fst meta bracketleftbig fst bracketrightbig meta bracketleftbig fst bracketrightbig meta definitions meta definition fst assume holds subcase meta meta meta bracketleftbig fst bracketrightbig meta definitions meta definition fst forall entries derived meta meta definition meta fst definition meta fst definition inductive hypothesis iii meta fst meta meta definition meta definition meta definition theorem theorem structure -struct proto protostructure statement obtained structure obtained proto approximation filling instrumentation relations topological ordering dependences arity-k relation obtained evaluating mapsto mapsto tuples formula complete assignmentz fst proof proof induction size mapsto mapsto lemma iii inductionhypothesis cases atomic formulas fst fst vik formp fst vik vik vik vik vik vik vik vik vik vik formp fst vik vik vik vik vik vik vik vik vik vik formp fst vik vik vik vik vik vik vik vik vik vik vik vik forms fst vik vik vik vik vik vik vik vik vik vik vik fst vik vik vik vik vik vik vik vik vik vik fst vik vik vik appendix proofs 
propositions chapter lemma -valued assignment formula logicalanddisplay prime implicant proof defn eqn presence guard index conjunction conjunction literals form shown conjunction logicalanddisplay assumption defn implies monotonic function allarep bya definitionof implies becausea allxi whicha implicant prime implicant right-hand side eqn set literals anys strict subset ofs set literals assignmenta wherea assumption means defn arep bya thereisa -valuedassignmenta suchthata forallxi forwhicha means precisely logicalanddisplay implicant prime implicant lemma prime implicant -valued assignment alla iii logicalanddisplay proof product logicalanddisplay xbii letas assignment mapsto ifi prime implicant represented definition defn defn mapsto formula property holds vacuously assume thatas binds onexi definite assignment agree possibly empty set xbii assumptions implicant -valued assignmenta definition pick anya represented byas prime implicant defn definition defn becausea represented bya unionsqdisplay rep iii rewritten logicalanddisplay xas showed formula turn expressed logicalanddisplay lemma iff total boolean function primes primes proof letabe -valued assignment defn monotonicityof lemma primes yields definite valued primes yieldd case primes show primes show exist definite assignments rep bya primes rep bya primes pick disjunct primes evaluates assignment logicalanddisplay xbii variables create fromaby replacing bindingxj mapsto withxj mapsto primes suppose sake argument allarep bya primes defn implies alla represented bya means formula logicalanddisplay implicant primes disjunct considered set literals subset considered set literals means primes contradicts assumption subsequent assumption assumption incorrect total boolean function definite assignment primes fact assumption incorrect implies exist ana rep byasuch primes lemma total boolean function definite assignments primes primes proof primes defn primes defn primes theorem iff total boolean function primes primes proof letabe -valued assignment primes primes lemma unionsqdisplay rep primes defn unionsqdisplay rep primes lemma unionsqdisplay rep primes unionsqdisplay rep primes primes defn primes lemma primes 
